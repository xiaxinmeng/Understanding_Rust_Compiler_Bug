{"sha": "6e5bdbe57703708e91cd37b707c75a20498ef4b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNWJkYmU1NzcwMzcwOGU5MWNkMzdiNzA3Yzc1YTIwNDk4ZWY0Yjg=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-19T10:38:51Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-19T10:39:01Z"}, "message": "Add inital implementation of ByValPair.\n\nThere are still hacks left to clean up.", "tree": {"sha": "485f2a52ae58070fada21c48c04f9eca901ad3cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/485f2a52ae58070fada21c48c04f9eca901ad3cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5bdbe57703708e91cd37b707c75a20498ef4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5bdbe57703708e91cd37b707c75a20498ef4b8", "html_url": "https://github.com/rust-lang/rust/commit/6e5bdbe57703708e91cd37b707c75a20498ef4b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5bdbe57703708e91cd37b707c75a20498ef4b8/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "678b9ca3285f08dd1ffb24cea0f2ec023023ffad", "url": "https://api.github.com/repos/rust-lang/rust/commits/678b9ca3285f08dd1ffb24cea0f2ec023023ffad", "html_url": "https://github.com/rust-lang/rust/commit/678b9ca3285f08dd1ffb24cea0f2ec023023ffad"}], "stats": {"total": 124, "additions": 85, "deletions": 39}, "files": [{"sha": "391ca5bdf985d807168c83b51ec7a74639ad586d", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 85, "deletions": 39, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6e5bdbe57703708e91cd37b707c75a20498ef4b8/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5bdbe57703708e91cd37b707c75a20498ef4b8/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=6e5bdbe57703708e91cd37b707c75a20498ef4b8", "patch": "@@ -103,10 +103,15 @@ pub struct Frame<'a, 'tcx: 'a> {\n ///\n /// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitve\n /// value held directly, outside of any allocation (`ByVal`).\n+///\n+/// For optimization of a few very common cases, there is also a representation for a pair of\n+/// primitive values (`ByValPair`). It allows Miri to avoid making allocations for check binary\n+/// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum Value {\n     ByRef(Pointer),\n     ByVal(PrimVal),\n+    ByValPair(PrimVal, PrimVal),\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -192,6 +197,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n+    fn target_isize_primval(&self, n: i64) -> PrimVal {\n+        match self.memory.pointer_size() {\n+            1 => PrimVal::I8(n as i8),\n+            2 => PrimVal::I16(n as i16),\n+            4 => PrimVal::I32(n as i32),\n+            8 => PrimVal::I64(n as i64),\n+            p => bug!(\"unsupported target pointer size: {}\", p),\n+        }\n+    }\n+\n+    fn target_usize_primval(&self, n: u64) -> PrimVal {\n+        match self.memory.pointer_size() {\n+            1 => PrimVal::U8(n as u8),\n+            2 => PrimVal::U16(n as u16),\n+            4 => PrimVal::U32(n as u32),\n+            8 => PrimVal::U64(n as u64),\n+            p => bug!(\"unsupported target pointer size: {}\", p),\n+        }\n+    }\n+\n     fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n@@ -217,19 +242,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Char(c) => Value::ByVal(PrimVal::Char(c)),\n \n             Str(ref s) => {\n-                // Create and freeze the allocation holding the characters.\n-                let static_ptr = self.memory.allocate(s.len(), 1)?;\n-                self.memory.write_bytes(static_ptr, s.as_bytes())?;\n-                self.memory.freeze(static_ptr.alloc_id)?;\n-\n-                // Create an allocation to hold the fat pointer to the above char allocation.\n-                // FIXME(solson): Introduce Value::ByValPair to remove this allocation.\n-                let psize = self.memory.pointer_size();\n-                let ptr = self.memory.allocate(psize * 2, psize)?;\n-                let (ptr, extra) = self.get_fat_ptr(ptr);\n-                self.memory.write_ptr(ptr, static_ptr)?;\n-                self.memory.write_usize(extra, s.len() as u64)?;\n-                Value::ByRef(ptr)\n+                let ptr = self.memory.allocate(s.len(), 1)?;\n+                self.memory.write_bytes(ptr, s.as_bytes())?;\n+                self.memory.freeze(ptr.alloc_id)?;\n+                Value::ByValPair(\n+                    PrimVal::AbstractPtr(ptr),\n+                    self.target_usize_primval(s.len() as u64)\n+                )\n             }\n \n             ByteStr(ref bs) => {\n@@ -762,6 +781,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let value = self.eval_operand(op)?;\n         match value {\n             Value::ByRef(ptr) => Ok(ptr),\n+\n             Value::ByVal(primval) => {\n                 let ty = self.operand_ty(op);\n                 let size = self.type_size(ty);\n@@ -770,6 +790,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_primval(ptr, primval)?;\n                 Ok(ptr)\n             }\n+\n+            Value::ByValPair(primval1, primval2) => {\n+                let ty = self.operand_ty(op);\n+                let size = self.type_size(ty);\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n+\n+                // FIXME(solson): Major dangerous assumptions here. Ideally obliterate this\n+                // function.\n+                self.memory.write_primval(ptr, primval1)?;\n+                self.memory.write_primval(ptr.offset((size / 2) as isize), primval2)?;\n+                Ok(ptr)\n+            }\n         }\n     }\n \n@@ -953,6 +986,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // TODO(solson): Sanity-check the primval type against the input type.\n             Value::ByVal(primval) => Ok(primval),\n+            Value::ByValPair(..) => bug!(\"can't turn a ByValPair into a single PrimVal\"),\n         }\n     }\n \n@@ -965,44 +999,56 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match value {\n             Value::ByRef(ptr) => self.move_(ptr, dest, dest_ty),\n             Value::ByVal(primval) => self.memory.write_primval(dest, primval),\n+            Value::ByValPair(primval1, primval2) => {\n+                let size = self.type_size(dest_ty);\n+\n+                // FIXME(solson): Major dangerous assumptions here.\n+                self.memory.write_primval(dest, primval1)?;\n+                self.memory.write_primval(dest.offset((size / 2) as isize), primval2)?;\n+                Ok(())\n+            }\n         }\n     }\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use syntax::ast::{IntTy, UintTy, FloatTy};\n-        let val = match (self.memory.pointer_size(), &ty.sty) {\n-            (_, &ty::TyBool)              => PrimVal::Bool(self.memory.read_bool(ptr)?),\n-            (_, &ty::TyChar)              => {\n+        let val = match &ty.sty {\n+            &ty::TyBool => PrimVal::Bool(self.memory.read_bool(ptr)?),\n+            &ty::TyChar => {\n                 let c = self.memory.read_uint(ptr, 4)? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::Char(ch),\n                     None => return Err(EvalError::InvalidChar(c as u64)),\n                 }\n             }\n-            (_, &ty::TyInt(IntTy::I8))    => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n-            (2, &ty::TyInt(IntTy::Is)) |\n-            (_, &ty::TyInt(IntTy::I16))   => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n-            (4, &ty::TyInt(IntTy::Is)) |\n-            (_, &ty::TyInt(IntTy::I32))   => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n-            (8, &ty::TyInt(IntTy::Is)) |\n-            (_, &ty::TyInt(IntTy::I64))   => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n-            (_, &ty::TyUint(UintTy::U8))  => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n-            (2, &ty::TyUint(UintTy::Us)) |\n-            (_, &ty::TyUint(UintTy::U16)) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n-            (4, &ty::TyUint(UintTy::Us)) |\n-            (_, &ty::TyUint(UintTy::U32)) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n-            (8, &ty::TyUint(UintTy::Us)) |\n-            (_, &ty::TyUint(UintTy::U64)) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n-\n-            (_, &ty::TyFloat(FloatTy::F32)) => PrimVal::F32(self.memory.read_f32(ptr)?),\n-            (_, &ty::TyFloat(FloatTy::F64)) => PrimVal::F64(self.memory.read_f64(ptr)?),\n-\n-            (_, &ty::TyFnDef(def_id, substs, fn_ty)) => {\n+            &ty::TyInt(IntTy::I8)    => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n+            &ty::TyInt(IntTy::I16)   => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n+            &ty::TyInt(IntTy::I32)   => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n+            &ty::TyInt(IntTy::I64)   => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n+            &ty::TyUint(UintTy::U8)  => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n+            &ty::TyUint(UintTy::U16) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n+            &ty::TyUint(UintTy::U32) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n+            &ty::TyUint(UintTy::U64) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n+\n+            &ty::TyInt(IntTy::Is) => {\n+                let psize = self.memory.pointer_size();\n+                self.target_isize_primval(self.memory.read_int(ptr, psize)?)\n+            }\n+\n+            &ty::TyUint(UintTy::Us) => {\n+                let psize = self.memory.pointer_size();\n+                self.target_usize_primval(self.memory.read_uint(ptr, psize)?)\n+            }\n+\n+            &ty::TyFloat(FloatTy::F32) => PrimVal::F32(self.memory.read_f32(ptr)?),\n+            &ty::TyFloat(FloatTy::F64) => PrimVal::F64(self.memory.read_f64(ptr)?),\n+\n+            &ty::TyFnDef(def_id, substs, fn_ty) => {\n                 PrimVal::FnPtr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n             },\n-            (_, &ty::TyFnPtr(_)) => self.memory.read_ptr(ptr).map(PrimVal::FnPtr)?,\n-            (_, &ty::TyRef(_, ty::TypeAndMut { ty, .. })) |\n-            (_, &ty::TyRawPtr(ty::TypeAndMut { ty, .. })) => {\n+            &ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::FnPtr)?,\n+            &ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+            &ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                 if self.type_is_sized(ty) {\n                     match self.memory.read_ptr(ptr) {\n                         Ok(p) => PrimVal::AbstractPtr(p),\n@@ -1016,7 +1062,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n \n-            (_, &ty::TyAdt(..)) => {\n+            &ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n                     match (discr.size().bytes(), signed) {"}]}