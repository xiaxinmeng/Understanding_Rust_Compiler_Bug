{"sha": "71bdeb022a9403707a17a62f51d9b35e5f76ff85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYmRlYjAyMmE5NDAzNzA3YTE3YTYyZjUxZDliMzVlNWY3NmZmODU=", "commit": {"author": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-20T22:15:41Z"}, "committer": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-20T22:15:41Z"}, "message": "Initial version of the documentation change of std::convert.", "tree": {"sha": "60fc06db144f1adfd7ba7821afc1a863735f8bc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60fc06db144f1adfd7ba7821afc1a863735f8bc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71bdeb022a9403707a17a62f51d9b35e5f76ff85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71bdeb022a9403707a17a62f51d9b35e5f76ff85", "html_url": "https://github.com/rust-lang/rust/commit/71bdeb022a9403707a17a62f51d9b35e5f76ff85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71bdeb022a9403707a17a62f51d9b35e5f76ff85/comments", "author": null, "committer": null, "parents": [{"sha": "cd45b19bd2d8b4f9a3940a409ea43285019f3280", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd45b19bd2d8b4f9a3940a409ea43285019f3280", "html_url": "https://github.com/rust-lang/rust/commit/cd45b19bd2d8b4f9a3940a409ea43285019f3280"}], "stats": {"total": 170, "additions": 85, "deletions": 85}, "files": [{"sha": "ca166abebdf2ab8107590aa12b428393946a138b", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/71bdeb022a9403707a17a62f51d9b35e5f76ff85/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bdeb022a9403707a17a62f51d9b35e5f76ff85/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=71bdeb022a9403707a17a62f51d9b35e5f76ff85", "patch": "@@ -1,26 +1,24 @@\n-//! Traits for conversions between types.\n //!\n-//! The traits in this module provide a general way to talk about conversions\n-//! from one type to another. They follow the standard Rust conventions of\n-//! `as`/`into`/`from`.\n+//! The traits in this module provide a way to convert from one type to another type.\n //!\n-//! Like many traits, these are often used as bounds for generic functions, to\n-//! support arguments of multiple types.\n+//! Each trait serves a different purpose:\n //!\n-//! - Implement the `As*` traits for reference-to-reference conversions\n-//! - Implement the [`Into`] trait when you want to consume the value in the conversion\n-//! - The [`From`] trait is the most flexible, useful for value _and_ reference conversions\n-//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but allow for the\n-//!   conversion to fail\n+//! - Implement the [`AsRef`] trait for cheap reference-to-reference conversions\n+//! - Implement the [`AsMut`] trait for cheap mutable-to-mutable conversions\n+//! - Implement the [`From`] trait for consuming value-to-value conversions\n+//! - Implement the [`Into`] trait for consuming value-to-value conversions to types outside the current crate\n+//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but should be implemented when\n+//! the conversion can fail.\n //!\n-//! As a library author, you should prefer implementing [`From<T>`][`From`] or\n+//! The traits in this module are often used as trait bounds for generic functions such that to\n+//! arguments of multiple types are supported. See the documentation of each trait for examples.\n+//!\n+//! As a library author, you should always prefer implementing [`From<T>`][`From`] or\n //! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n //! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n //! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n-//! blanket implementation in the standard library.  However, there are some cases\n-//! where this is not possible, such as creating conversions into a type defined\n-//! outside your library, so implementing [`Into`] instead of [`From`] is\n-//! sometimes necessary.\n+//! blanket implementation in the standard library. Only implement [`Into`] or [`TryInto`]\n+//! when a conversion to a type outside the current crate is required.\n //!\n //! # Generic Implementations\n //!\n@@ -99,28 +97,20 @@ use fmt;\n #[inline]\n pub const fn identity<T>(x: T) -> T { x }\n \n-/// A cheap reference-to-reference conversion. Used to convert a value to a\n-/// reference value within generic code.\n-///\n-/// `AsRef` is very similar to, but serves a slightly different purpose than,\n-/// [`Borrow`].\n+/// Used to do a cheap reference-to-reference conversion.\n+/// This trait is similar to [`AsMut`] which is used for converting between mutable references.\n+/// If you need to do a costly conversion it is better to implement [`From`] with type\n+/// ```&T``` or write a custom function.\n ///\n-/// `AsRef` is to be used when wishing to convert to a reference of another\n-/// type.\n-/// `Borrow` is more related to the notion of taking the reference. It is\n-/// useful when wishing to abstract over the type of reference\n-/// (`&T`, `&mut T`) or allow both the referenced and owned type to be treated\n-/// in the same manner.\n-///\n-/// The key difference between the two traits is the intention:\n ///\n+/// `AsRef` is very similar to, but serves a slightly different purpose than [`Borrow`]:\n /// - Use `AsRef` when the goal is to simply convert into a reference\n /// - Use `Borrow` when the goal is related to writing code that is agnostic to\n ///   the type of borrow and whether it is a reference or value\n ///\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n@@ -134,7 +124,11 @@ pub const fn identity<T>(x: T) -> T { x }\n ///\n /// # Examples\n ///\n-/// Both [`String`] and `&str` implement `AsRef<str>`:\n+/// By using trait bounds we can accept arguments of different types as long as they can be\n+/// converted a the specified type ```T```.\n+/// For example: By creating a generic function that takes an ```AsRef<str>``` we express that we\n+/// want to accept all references that can be converted to &str as an argument.\n+/// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n ///\n /// [`String`]: ../../std/string/struct.String.html\n ///\n@@ -157,12 +151,12 @@ pub trait AsRef<T: ?Sized> {\n     fn as_ref(&self) -> &T;\n }\n \n-/// A cheap, mutable reference-to-mutable reference conversion.\n-///\n-/// This trait is similar to `AsRef` but used for converting between mutable\n-/// references.\n+/// Used to do a cheap mutable-to-mutable reference conversion.\n+/// This trait is similar to [`AsRef`] but used for converting between mutable\n+/// references. If you need to do a costly conversion it is better to\n+/// implement [`From`] with type ```&mut T``` or write a custom function.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n@@ -176,10 +170,11 @@ pub trait AsRef<T: ?Sized> {\n ///\n /// # Examples\n ///\n-/// [`Box<T>`] implements `AsMut<T>`:\n-///\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n-///\n+/// Using ```AsMut``` as trait bound for a generic function we can accept all mutable references\n+/// that can be converted to type ```&mut T```. Because [`Box<T>`] implements ```AsMut<T>``` we can\n+/// write a function ```add_one```that takes all arguments that can be converted to ```&mut u64```.\n+/// Because [`Box<T>`] implements ```AsMut<T>``` ```add_one``` accepts arguments of type\n+/// ```&mut Box<u64>``` as well:\n /// ```\n /// fn add_one<T: AsMut<u64>>(num: &mut T) {\n ///     *num.as_mut() += 1;\n@@ -189,7 +184,7 @@ pub trait AsRef<T: ?Sized> {\n /// add_one(&mut boxed_num);\n /// assert_eq!(*boxed_num, 1);\n /// ```\n-///\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n@@ -198,29 +193,24 @@ pub trait AsMut<T: ?Sized> {\n     fn as_mut(&mut self) -> &mut T;\n }\n \n-/// A conversion that consumes `self`, which may or may not be expensive. The\n-/// reciprocal of [`From`][From].\n+/// A value-to-value conversion that consumes the input value. The\n+/// opposite of [`From`].\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use\n-/// [`TryInto`] or a dedicated method which returns an [`Option<T>`] or a\n-/// [`Result<T, E>`].\n+/// One should only implement [`Into`] if a conversion to a type outside the current crate is required.\n+/// Otherwise one should always prefer implementing [`From`] over [`Into`] because implementing [`From`] automatically\n+/// provides one with a implementation of [`Into`] thanks to the blanket implementation in the standard library.\n+/// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n ///\n-/// Library authors should not directly implement this trait, but should prefer\n-/// implementing the [`From`][From] trait, which offers greater flexibility and\n-/// provides an equivalent `Into` implementation for free, thanks to a blanket\n-/// implementation in the standard library.\n+/// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n ///\n /// # Generic Implementations\n ///\n-/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n-/// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n-///\n-/// # Implementing `Into`\n+/// - [`From<T>`]` for U` implies `Into<U> for T`\n+/// - [`Into`]` is reflexive, which means that `Into<T> for T` is implemented\n ///\n-/// There is one exception to implementing `Into`, and it's kind of esoteric.\n-/// If the destination type is not part of the current crate, and it uses a\n-/// generic variable, then you can't implement `From` directly. For example,\n-/// take this crate:\n+/// # Implementing `Into` for conversions to external types\n+/// If the destination type is not part of the current crate then you can't implement [`From`] directly.\n+/// For example, take this code:\n ///\n /// ```compile_fail\n /// struct Wrapper<T>(Vec<T>);\n@@ -230,8 +220,9 @@ pub trait AsMut<T: ?Sized> {\n ///     }\n /// }\n /// ```\n-///\n-/// To fix this, you can implement `Into` directly:\n+/// This will fail to compile because we cannot implement a trait for a type\n+/// if both the trait and the type are not defined by the current crate.\n+/// This is due to Rust's orphaning rules. To bypass this, you can implement `Into` directly:\n ///\n /// ```\n /// struct Wrapper<T>(Vec<T>);\n@@ -242,17 +233,21 @@ pub trait AsMut<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// This won't always allow the conversion: for example, `try!` and `?`\n-/// always use `From`. However, in most cases, people use `Into` to do the\n-/// conversions, and this will allow that.\n+/// It is important to understand that ```Into``` does not provide a [`From`] implementation (as [`From`] does with ```Into```).\n+/// Therefore, you should always try to implement [`From`] and then fall back to `Into` if [`From`] can't be implemented.\n+/// Prefer using ```Into``` over ```From``` when specifying trait bounds on a generic function\n+/// to ensure that types that only implement ```Into``` can be used as well.\n ///\n-/// In almost all cases, you should try to implement `From`, then fall back\n-/// to `Into` if `From` can't be implemented.\n ///\n /// # Examples\n ///\n /// [`String`] implements `Into<Vec<u8>>`:\n ///\n+/// In order to express that we want a generic function to take all arguments that can be\n+/// converted to a specified type ```T```, we can use a trait bound of ```Into<T>```.\n+/// For example: The function ```is_hello``` takes all arguments that can be converted into a\n+/// ```Vec<u8>```.\n+///\n /// ```\n /// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n ///    let bytes = b\"hello\".to_vec();\n@@ -276,44 +271,49 @@ pub trait Into<T>: Sized {\n     fn into(self) -> T;\n }\n \n-/// Simple and safe type conversions in to `Self`. It is the reciprocal of\n-/// `Into`.\n+/// Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n+/// [`Into`].\n ///\n-/// This trait is useful when performing error handling as described by\n-/// [the book][book] and is closely related to the `?` operator.\n+/// One should always prefer implementing [`From`] over [`Into`] because implementing [`From`] automatically\n+/// provides one with a implementation of [`Into`] thanks to the blanket implementation in the standard library.\n+/// Only implement [`Into`] if a conversion to a type outside the current crate is required.\n+/// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n+/// See [`Into`] for more details.\n ///\n-/// When constructing a function that is capable of failing the return type\n-/// will generally be of the form `Result<T, E>`.\n-///\n-/// The `From` trait allows for simplification of error handling by providing a\n-/// means of returning a single error type that encapsulates numerous possible\n-/// erroneous situations.\n+/// Prefer using [`Into`] over using [`From`] when specifying trait bounds on a generic function.\n+/// This way, types that directly implement [`Into`] can be used as arguments as well.\n ///\n-/// This trait is not limited to error handling, rather the general case for\n-/// this trait would be in any type conversions to have an explicit definition\n-/// of how they are performed.\n+/// The [`From`] is also very useful when performing error handling.\n+/// When constructing a function that is capable of failing, the return type\n+/// will generally be of the form `Result<T, E>`.\n+/// The `From` trait simplifies error handling by allowing a function to return a single error type\n+/// that encapsulate multiple error types. See the \"Examples\" section for more details.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use\n-/// [`TryFrom`] or a dedicated method which returns an [`Option<T>`] or a\n-/// [`Result<T, E>`].\n+/// **Note: This trait must not fail**. If the conversion can fail, use [`TryFrom`].\n ///\n /// # Generic Implementations\n ///\n-/// - `From<T> for U` implies [`Into<U>`]` for T`\n-/// - [`from`] is reflexive, which means that `From<T> for T` is implemented\n+/// - [`From<T>`]` for U` implies [`Into<U>`]` for T`\n+/// - [`From`] is reflexive, which means that `From<T> for T` is implemented\n ///\n /// # Examples\n ///\n /// [`String`] implements `From<&str>`:\n ///\n+/// An explicit conversion from a &str to a String is done as follows:\n /// ```\n /// let string = \"hello\".to_string();\n /// let other_string = String::from(\"hello\");\n ///\n /// assert_eq!(string, other_string);\n /// ```\n ///\n-/// An example usage for error handling:\n+/// While performing error handling it is often useful to implement ```From``` for your own error type.\n+/// By converting underlying error types to our own custom error type that encapsulates the underlying\n+/// error type, we can return a single error type without losing information on the underlying cause.\n+/// The '?' operator automatically converts the underlying error type to our custom error type by\n+/// calling ```Into<CliError>::into``` which is automatically provided when implementing ```From```.\n+/// The compiler then infers which implementation of ```Into``` should be used.\n ///\n /// ```\n /// use std::fs;\n@@ -350,7 +350,7 @@ pub trait Into<T>: Sized {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Into<U>`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n-/// [book]: ../../book/ch09-00-error-handling.html\n+/// [book]: ../../book/first-edition/error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {\n     /// Performs the conversion."}]}