{"sha": "572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MmMyZjNlMDdmZDA5MjdkNmM1MGE2NjA0YjljM2YyZmEzZWJiODY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-11-17T09:10:41Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-11-17T09:10:41Z"}, "message": "Fix issue #21546 and refactor NsDef", "tree": {"sha": "aacf8c0b5069f76ca271a3a848e10374bb46832a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aacf8c0b5069f76ca271a3a848e10374bb46832a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "html_url": "https://github.com/rust-lang/rust/commit/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a6187fde1de7b209bbd2b49ea3c669006a0d154", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6187fde1de7b209bbd2b49ea3c669006a0d154", "html_url": "https://github.com/rust-lang/rust/commit/8a6187fde1de7b209bbd2b49ea3c669006a0d154"}], "stats": {"total": 240, "additions": 62, "deletions": 178}, "files": [{"sha": "b519a729918635cb19d34f45946328202dafb08d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 26, "deletions": 146, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "patch": "@@ -27,7 +27,6 @@ use resolve_imports::Shadowable;\n use {resolve_error, ResolutionError};\n \n use self::DuplicateCheckingMode::*;\n-use self::NamespaceError::*;\n \n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n@@ -60,29 +59,12 @@ use std::rc::Rc;\n // another item exists with the same name in some namespace.\n #[derive(Copy, Clone, PartialEq)]\n enum DuplicateCheckingMode {\n-    ForbidDuplicateModules,\n-    ForbidDuplicateTypesAndModules,\n+    ForbidDuplicateTypes,\n     ForbidDuplicateValues,\n     ForbidDuplicateTypesAndValues,\n     OverwriteDuplicates,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum NamespaceError {\n-    NoError,\n-    ModuleError,\n-    TypeError,\n-    ValueError,\n-}\n-\n-fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n-    match ns {\n-        NoError => \"\",\n-        ModuleError | TypeError => \"type or module\",\n-        ValueError => \"value\",\n-    }\n-}\n-\n struct GraphBuilder<'a, 'b: 'a, 'tcx: 'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>,\n }\n@@ -112,27 +94,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         visit::walk_crate(&mut visitor, krate);\n     }\n \n-    /// Adds a new child item to the module definition of the parent node and\n-    /// returns its corresponding name bindings as well as the current parent.\n-    /// Or, if we're inside a block, creates (or reuses) an anonymous module\n-    /// corresponding to the innermost block ID and returns the name bindings\n-    /// as well as the newly-created parent.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if this node does not have a module definition and we are not inside\n-    /// a block.\n+    /// Adds a new child item to the module definition of the parent node,\n+    /// or if there is already a child, does duplicate checking on the child.\n+    /// Returns the child's corresponding name bindings.\n     fn add_child(&self,\n                  name: Name,\n                  parent: &Rc<Module>,\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n                  sp: Span)\n                  -> NameBindings {\n-        // If this is the immediate descendant of a module, then we add the\n-        // child name directly. Otherwise, we create or reuse an anonymous\n-        // module and add the child to that.\n-\n         self.check_for_conflicts_between_external_crates_and_items(&**parent, name, sp);\n \n         // Add or reuse the child.\n@@ -146,79 +117,33 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             Some(child) => {\n                 // Enforce the duplicate checking mode:\n                 //\n-                // * If we're requesting duplicate module checking, check that\n-                //   there isn't a module in the module with the same name.\n-                //\n                 // * If we're requesting duplicate type checking, check that\n-                //   there isn't a type in the module with the same name.\n+                //   the name isn't defined in the type namespace.\n                 //\n                 // * If we're requesting duplicate value checking, check that\n-                //   there isn't a value in the module with the same name.\n+                //   the name isn't defined in the value namespace.\n                 //\n-                // * If we're requesting duplicate type checking and duplicate\n-                //   value checking, check that there isn't a duplicate type\n-                //   and a duplicate value with the same name.\n+                // * If we're requesting duplicate type and value checking,\n+                //   check that the name isn't defined in either namespace.\n                 //\n                 // * If no duplicate checking was requested at all, do\n                 //   nothing.\n \n-                let mut duplicate_type = NoError;\n                 let ns = match duplicate_checking_mode {\n-                    ForbidDuplicateModules => {\n-                        if child.get_module_if_available().is_some() {\n-                            duplicate_type = ModuleError;\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateTypesAndModules => {\n-                        if child.type_ns.defined() {\n-                            duplicate_type = TypeError;\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateValues => {\n-                        if child.value_ns.defined() {\n-                            duplicate_type = ValueError;\n-                        }\n-                        Some(ValueNS)\n-                    }\n-                    ForbidDuplicateTypesAndValues => {\n-                        let mut n = None;\n-                        match child.type_ns.def() {\n-                            Some(DefMod(_)) | None => {}\n-                            Some(_) => {\n-                                n = Some(TypeNS);\n-                                duplicate_type = TypeError;\n-                            }\n-                        }\n-                        if child.value_ns.defined() {\n-                            duplicate_type = ValueError;\n-                            n = Some(ValueNS);\n-                        }\n-                        n\n-                    }\n-                    OverwriteDuplicates => None,\n+                    ForbidDuplicateTypes if child.type_ns.defined() => TypeNS,\n+                    ForbidDuplicateValues if child.value_ns.defined() => ValueNS,\n+                    ForbidDuplicateTypesAndValues if child.type_ns.defined() => TypeNS,\n+                    ForbidDuplicateTypesAndValues if child.value_ns.defined() => ValueNS,\n+                    _ => return child,\n                 };\n-                if duplicate_type != NoError {\n-                    // Return an error here by looking up the namespace that\n-                    // had the duplicate.\n-                    let ns = ns.unwrap();\n-                    resolve_error(\n-                        self,\n-                        sp,\n-                        ResolutionError::DuplicateDefinition(\n-                            namespace_error_to_string(duplicate_type),\n-                            name)\n-                    );\n-                    {\n-                        let r = child[ns].span();\n-                        if let Some(sp) = r {\n-                            self.session.span_note(sp,\n-                                                   &format!(\"first definition of {} `{}` here\",\n-                                      namespace_error_to_string(duplicate_type),\n-                                      name));\n-                        }\n-                    }\n+\n+                // Record an error here by looking up the namespace that had the duplicate\n+                let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n+                resolve_error(self, sp, ResolutionError::DuplicateDefinition(ns_str, name));\n+\n+                if let Some(sp) = child[ns].span() {\n+                    let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n+                    self.session.span_note(sp, &note);\n                 }\n                 child\n             }\n@@ -409,29 +334,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n \n             ItemMod(..) => {\n-                let child = parent.children.borrow().get(&name).cloned();\n-                if let Some(child) = child {\n-                    // check if there's struct of the same name already defined\n-                    if child.type_ns.defined() &&\n-                       child.get_module_if_available().is_none() {\n-                        self.session.span_warn(sp,\n-                                               &format!(\"duplicate definition of {} `{}`. \\\n-                                                         Defining a module and a struct with \\\n-                                                         the same name will be disallowed soon.\",\n-                                                        namespace_error_to_string(TypeError),\n-                                                        name));\n-                        {\n-                            let r = child.type_ns.span();\n-                            if let Some(sp) = r {\n-                                self.session.span_note(sp,\n-                                                       &format!(\"first definition of {} `{}` here\",\n-                                          namespace_error_to_string(TypeError),\n-                                          name));\n-                            }\n-                        }\n-                    }\n-                }\n-                let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateTypes, sp);\n \n                 let parent_link = self.get_parent_link(parent, name);\n                 let def = DefMod(self.ast_map.local_def_id(item.id));\n@@ -469,7 +372,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemTy(..) => {\n                 let name_bindings = self.add_child(name,\n                                                    parent,\n-                                                   ForbidDuplicateTypesAndModules,\n+                                                   ForbidDuplicateTypes,\n                                                    sp);\n \n                 let parent_link = self.get_parent_link(parent, name);\n@@ -481,7 +384,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemEnum(ref enum_definition, _) => {\n                 let name_bindings = self.add_child(name,\n                                                    parent,\n-                                                   ForbidDuplicateTypesAndModules,\n+                                                   ForbidDuplicateTypes,\n                                                    sp);\n \n                 let parent_link = self.get_parent_link(parent, name);\n@@ -501,31 +404,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemStruct(ref struct_def, _) => {\n                 // Adding to both Type and Value namespaces or just Type?\n                 let (forbid, ctor_id) = if struct_def.is_struct() {\n-                    (ForbidDuplicateTypesAndModules, None)\n+                    (ForbidDuplicateTypes, None)\n                 } else {\n-                    let child = parent.children.borrow().get(&name).cloned();\n-                    if let Some(child) = child {\n-                        // check if theres a DefMod\n-                        if let Some(DefMod(_)) = child.type_ns.def() {\n-                            self.session.span_warn(sp,\n-                                                   &format!(\"duplicate definition of {} `{}`. \\\n-                                                             Defining a module and a struct \\\n-                                                             with the same name will be \\\n-                                                             disallowed soon.\",\n-                                                            namespace_error_to_string(TypeError),\n-                                                            name));\n-                            {\n-                                let r = child.type_ns.span();\n-                                if let Some(sp) = r {\n-                                    self.session\n-                                        .span_note(sp,\n-                                                   &format!(\"first definition of {} `{}` here\",\n-                                                            namespace_error_to_string(TypeError),\n-                                                            name));\n-                                }\n-                            }\n-                        }\n-                    }\n                     (ForbidDuplicateTypesAndValues, Some(struct_def.id()))\n                 };\n \n@@ -566,7 +446,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemTrait(_, _, _, ref items) => {\n                 let name_bindings = self.add_child(name,\n                                                    parent,\n-                                                   ForbidDuplicateTypesAndModules,\n+                                                   ForbidDuplicateTypes,\n                                                    sp);\n \n                 let def_id = self.ast_map.local_def_id(item.id);"}, {"sha": "6a49db8a14665ac7aa1d2cdb3e340201681aa485", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "patch": "@@ -904,17 +904,20 @@ bitflags! {\n     }\n }\n \n-// Records a possibly-private definition.\n-// FIXME once #21546 is resolved, the def and module fields will never both be Some,\n-// so they can be refactored into something like Result<Def, Rc<Module>>.\n+// Records a possibly-private value, type, or module definition.\n #[derive(Debug)]\n struct NsDef {\n     modifiers: DefModifiers, // see note in ImportResolution about how to use this\n-    def: Option<Def>,\n-    module: Option<Rc<Module>>,\n+    def_or_module: DefOrModule,\n     span: Option<Span>,\n }\n \n+#[derive(Debug)]\n+enum DefOrModule {\n+    Def(Def),\n+    Module(Rc<Module>),\n+}\n+\n impl NsDef {\n     fn create_from_module(module: Rc<Module>, span: Option<Span>) -> Self {\n         let modifiers = if module.is_public {\n@@ -923,14 +926,24 @@ impl NsDef {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n \n-        NsDef { modifiers: modifiers, def: None, module: Some(module), span: span }\n+        NsDef { modifiers: modifiers, def_or_module: DefOrModule::Module(module), span: span }\n+    }\n+\n+    fn create_from_def(def: Def, modifiers: DefModifiers, span: Option<Span>) -> Self {\n+        NsDef { modifiers: modifiers, def_or_module: DefOrModule::Def(def), span: span }\n+    }\n+\n+    fn module(&self) -> Option<Rc<Module>> {\n+        match self.def_or_module {\n+            DefOrModule::Module(ref module) => Some(module.clone()),\n+            DefOrModule::Def(_) => None,\n+        }\n     }\n \n     fn def(&self) -> Option<Def> {\n-        match (self.def, &self.module) {\n-            (def @ Some(_), _) => def,\n-            (_, &Some(ref module)) => module.def.get(),\n-            _ => panic!(\"NsDef has neither a Def nor a Module\"),\n+        match self.def_or_module {\n+            DefOrModule::Def(def) => Some(def),\n+            DefOrModule::Module(ref module) => module.def.get(),\n         }\n     }\n }\n@@ -964,10 +977,10 @@ impl NameBinding {\n \n     fn borrow(&self) -> ::std::cell::Ref<Option<NsDef>> { self.0.borrow() }\n \n-    // Lifted versions of the NsDef fields and method\n+    // Lifted versions of the NsDef methods and fields\n     fn def(&self) -> Option<Def>           { self.and_then(NsDef::def) }\n+    fn module(&self) -> Option<Rc<Module>> { self.and_then(NsDef::module) }\n     fn span(&self) -> Option<Span>         { self.and_then(|def| def.span) }\n-    fn module(&self) -> Option<Rc<Module>> { self.and_then(|def| def.module.clone()) }\n     fn modifiers(&self) -> Option<DefModifiers> { self.and_then(|def| Some(def.modifiers)) }\n \n     fn defined(&self) -> bool { self.borrow().is_some() }\n@@ -1029,23 +1042,14 @@ impl NameBindings {\n \n     /// Records a type definition.\n     fn define_type(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining type for def {:?} with modifiers {:?}\",\n-               def,\n-               modifiers);\n-        // Merges the type with the existing type def or creates a new one.\n-        self.type_ns.set(NsDef {\n-            modifiers: modifiers, def: Some(def), module: self.type_ns.module(), span: Some(sp)\n-        });\n+        debug!(\"defining type for def {:?} with modifiers {:?}\", def, modifiers);\n+        self.type_ns.set(NsDef::create_from_def(def, modifiers, Some(sp)));\n     }\n \n     /// Records a value definition.\n     fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining value for def {:?} with modifiers {:?}\",\n-               def,\n-               modifiers);\n-        self.value_ns.set(NsDef {\n-            modifiers: modifiers, def: Some(def), module: None, span: Some(sp)\n-        });\n+        debug!(\"defining value for def {:?} with modifiers {:?}\", def, modifiers);\n+        self.value_ns.set(NsDef::create_from_def(def, modifiers, Some(sp)));\n     }\n \n     /// Returns the module node if applicable.\n@@ -1524,7 +1528,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.used_imports.insert((id, namespace));\n                     self.record_import_use(id, name);\n                     if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n-                         self.used_crates.insert(kid);\n+                        self.used_crates.insert(kid);\n                     }\n                     return Success((target, false));\n                 }"}, {"sha": "24a21bcdfb1b09d176a29a70f37c750fc94b43e4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "patch": "@@ -1039,7 +1039,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         match import_resolution.type_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n-                    let (what, note) = match ty.module.clone() {\n+                    let (what, note) = match ty.module() {\n                         Some(ref module) if module.is_normal() =>\n                             (\"existing submodule\", \"note conflicting module here\"),\n                         Some(ref module) if module.is_trait() =>"}, {"sha": "535630e0824ca571725c9c766d59e4983a817b7e", "filename": "src/test/compile-fail/issue-21546.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Ftest%2Fcompile-fail%2Fissue-21546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86/src%2Ftest%2Fcompile-fail%2Fissue-21546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21546.rs?ref=572c2f3e07fd0927d6c50a6604b9c3f2fa3ebb86", "patch": "@@ -16,7 +16,7 @@ mod Foo { }\n \n #[allow(dead_code)]\n struct Foo;\n-//~^ WARNING duplicate definition of type or module `Foo`\n+//~^ ERROR duplicate definition of type or module `Foo`\n \n \n #[allow(non_snake_case)]\n@@ -25,7 +25,7 @@ mod Bar { }\n \n #[allow(dead_code)]\n struct Bar(i32);\n-//~^ WARNING duplicate definition of type or module `Bar`\n+//~^ ERROR duplicate definition of type or module `Bar`\n \n \n #[allow(dead_code)]\n@@ -34,7 +34,7 @@ struct Baz(i32);\n \n #[allow(non_snake_case)]\n mod Baz { }\n-//~^ WARNING duplicate definition of type or module `Baz`\n+//~^ ERROR duplicate definition of type or module `Baz`\n \n \n #[allow(dead_code)]\n@@ -43,7 +43,7 @@ struct Qux { x: bool }\n \n #[allow(non_snake_case)]\n mod Qux { }\n-//~^ WARNING duplicate definition of type or module `Qux`\n+//~^ ERROR duplicate definition of type or module `Qux`\n \n \n #[allow(dead_code)]\n@@ -52,7 +52,7 @@ struct Quux;\n \n #[allow(non_snake_case)]\n mod Quux { }\n-//~^ WARNING duplicate definition of type or module `Quux`\n+//~^ ERROR duplicate definition of type or module `Quux`\n \n \n #[allow(dead_code)]"}]}