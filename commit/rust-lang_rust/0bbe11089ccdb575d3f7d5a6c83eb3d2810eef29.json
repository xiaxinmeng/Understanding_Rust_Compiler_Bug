{"sha": "0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYmUxMTA4OWNjZGI1NzVkM2Y3ZDVhNmM4M2ViM2QyODEwZWVmMjk=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-04T18:22:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-04T18:22:51Z"}, "message": "Rollup merge of #67812 - ssomers:btreemap_internal_doc, r=rkruppe\n\nTweak and extend internal BTreeMap documentation, including debug asserts.\n\nGathered from work on various other pull requests (e.g. #67725, #67686).", "tree": {"sha": "a1268072a6fad12c2758f30c8409adb3ea087c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1268072a6fad12c2758f30c8409adb3ea087c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeENf7CRBK7hj4Ov3rIwAAdHIIAF339QJv8egpsyPBGcWzzKo2\n02MeJmerxEieN2We+6c6eREBLWGUZULP3Ro9vHEZUbl7Ts6+uSNmf7r9A4Xf5sQF\nYTxj+fPLTlOna6mZHuUkaC5Rtle8YbWizlgUYFuWd9OzwrmZlQnznA5z318fwpqR\nFKmJKhaw1UcGCti60WRaozvLs72Cl7Dl7syeY16c2z4AMnIoEspvUDncdJb5F3xz\n9M3gRQ9EBxszlUEMrlpN+9ryV6yzaK7gjOYpRYvDA09nYJJ0X72YlP2KpOhyZQb3\nXC8KDJl6QtARYWbyXeB4nHQLV+/G9tXuv69Igr9rMdxcTt/5wkkfNkS4Q5vHK3Q=\n=eJrg\n-----END PGP SIGNATURE-----\n", "payload": "tree a1268072a6fad12c2758f30c8409adb3ea087c20\nparent 5dabc3b33987de6806af182c3d1afbb1790eaa07\nparent 92acdc8b892e0cd94f101272760a815aae3258fc\nauthor Dylan DPC <dylan.dpc@gmail.com> 1578162171 +0530\ncommitter GitHub <noreply@github.com> 1578162171 +0530\n\nRollup merge of #67812 - ssomers:btreemap_internal_doc, r=rkruppe\n\nTweak and extend internal BTreeMap documentation, including debug asserts.\n\nGathered from work on various other pull requests (e.g. #67725, #67686).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "html_url": "https://github.com/rust-lang/rust/commit/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dabc3b33987de6806af182c3d1afbb1790eaa07", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dabc3b33987de6806af182c3d1afbb1790eaa07", "html_url": "https://github.com/rust-lang/rust/commit/5dabc3b33987de6806af182c3d1afbb1790eaa07"}, {"sha": "92acdc8b892e0cd94f101272760a815aae3258fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/92acdc8b892e0cd94f101272760a815aae3258fc", "html_url": "https://github.com/rust-lang/rust/commit/92acdc8b892e0cd94f101272760a815aae3258fc"}], "stats": {"total": 54, "additions": 39, "deletions": 15}, "files": [{"sha": "302c2bcd5e4a32100d243d893b86ddc39a70c1bf", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "patch": "@@ -493,7 +493,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n     }\n \n-    /// Clears the map, removing all values.\n+    /// Clears the map, removing all elements.\n     ///\n     /// # Examples\n     ///\n@@ -2605,7 +2605,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n         // Handle underflow\n         let mut cur_node = small_leaf.forget_type();\n-        while cur_node.len() < node::CAPACITY / 2 {\n+        while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n                 AtRoot => break,\n                 EmptyParent(_) => unreachable!(),"}, {"sha": "260e51d635dbbc87a0801932847a2aea668b393e", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "patch": "@@ -308,15 +308,15 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n-///   Note that in case of a leaf node, this might still be the shared root!  Only turn\n-///   this into a `LeafNode` reference if you know it is not a root!  Shared references\n-///   must be dereferencable *for the entire size of their pointee*, so `&InternalNode`\n-///   pointing to the shared root is UB.\n-///   Turning this into a `NodeHeader` is always safe.\n+///   Note that in case of a leaf node, this might still be the shared root!\n+///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n+///   Shared references must be dereferencable *for the entire size of their pointee*,\n+///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n+///   Turning this into a `NodeHeader` reference is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n-    // This is null unless the borrow type is `Mut`\n+    // `root` is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>,\n }\n@@ -370,23 +370,33 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n-    /// Assert that this is indeed a proper leaf node, and not the shared root.\n+    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n+    /// If the node is a leaf, this function simply opens up its data.\n+    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n+    /// (header, keys and values), and this function exposes that.\n+    /// See `NodeRef` on why the node may not be a shared root.\n     unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n+        debug_assert!(!self.is_shared_root());\n         self.node.as_ref()\n     }\n \n     fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n     }\n \n+    /// Returns whether the node is the shared, empty root.\n     pub fn is_shared_root(&self) -> bool {\n         self.as_header().is_shared_root()\n     }\n \n+    /// Borrows a view into the keys stored in the node.\n+    /// Works on all possible nodes, including the shared root.\n     pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n+    /// Borrows a view into the values stored in the node.\n+    /// The caller must ensure that the node is not the shared root.\n     fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n@@ -491,16 +501,24 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n+    /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n+    /// If the node is a leaf, this function simply opens up its data.\n+    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n+    /// (header, keys and values), and this function exposes that.\n+    ///\n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n+    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n+    /// might not be properly aligned and definitely would not allow accessing keys and values.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n-        // We are mutable, so we cannot be the shared root, so accessing this as a leaf is okay.\n         self.node.as_ptr()\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn keys_mut(&mut self) -> &mut [K] {\n         unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn vals_mut(&mut self) -> &mut [V] {\n         unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n@@ -551,9 +569,10 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay\n+        // We cannot be the shared root, so `as_leaf` is okay.\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n@@ -587,6 +606,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_val_slice_mut(mut self) -> &'a mut [V] {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n@@ -597,6 +617,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         debug_assert!(!self.is_shared_root());\n         // We cannot use the getters here, because calling the second one\n@@ -655,6 +676,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -686,6 +708,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -773,6 +796,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n@@ -1116,8 +1140,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         }\n     }\n \n-    /// Removes the key/value pair pointed to by this handle, returning the edge between the\n-    /// now adjacent key/value pairs to the left and right of this handle.\n+    /// Removes the key/value pair pointed to by this handle and returns it, along with the edge\n+    /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n@@ -1260,7 +1284,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// This removes a key/value pair from the left child and replaces it with the key/value pair\n+    /// This removes a key/value pair from the left child and places it in the key/value storage\n     /// pointed to by this handle while pushing the old key/value pair of this handle into the right\n     /// child.\n     pub fn steal_left(&mut self) {\n@@ -1277,7 +1301,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// This removes a key/value pair from the right child and replaces it with the key/value pair\n+    /// This removes a key/value pair from the right child and places it in the key/value storage\n     /// pointed to by this handle while pushing the old key/value pair of this handle into the left\n     /// child.\n     pub fn steal_right(&mut self) {"}]}