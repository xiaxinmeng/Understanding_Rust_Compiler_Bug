{"sha": "bb1a03c4fcbe547168fab128fa39b08d1122a1c2", "node_id": "C_kwDOAAsO6NoAKGJiMWEwM2M0ZmNiZTU0NzE2OGZhYjEyOGZhMzliMDhkMTEyMmExYzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T23:15:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T23:15:51Z"}, "message": "Auto merge of #95224 - mjbshaw:patch-1, r=yaahc\n\nOptimize RcInnerPtr::inc_strong()/inc_weak() instruction count\n\nInspired by this internals thread: https://internals.rust-lang.org/t/rc-optimization-on-64-bit-targets/16362\n\n[The generated assembly is a bit smaller](https://rust.godbolt.org/z/TeTnf6144) and is a more efficient usage of the CPU's instruction cache. `unlikely` doesn't impact any of the small artificial tests I've done, but I've included it in case it might help more complex scenarios when this is inlined.", "tree": {"sha": "49856ac6e614484fd3439be2f5fd372d650a0b78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49856ac6e614484fd3439be2f5fd372d650a0b78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb1a03c4fcbe547168fab128fa39b08d1122a1c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb1a03c4fcbe547168fab128fa39b08d1122a1c2", "html_url": "https://github.com/rust-lang/rust/commit/bb1a03c4fcbe547168fab128fa39b08d1122a1c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb1a03c4fcbe547168fab128fa39b08d1122a1c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f391b84552f210adec7893b50c5da74f9362ae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f391b84552f210adec7893b50c5da74f9362ae4", "html_url": "https://github.com/rust-lang/rust/commit/3f391b84552f210adec7893b50c5da74f9362ae4"}, {"sha": "8d14c03568d0ec99c586e17ce19a93cc0684ab9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d14c03568d0ec99c586e17ce19a93cc0684ab9e", "html_url": "https://github.com/rust-lang/rust/commit/8d14c03568d0ec99c586e17ce19a93cc0684ab9e"}], "stats": {"total": 38, "additions": 28, "deletions": 10}, "files": [{"sha": "a42f1c3b4bbae1cc154726eccf840b2d3d4af71f", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bb1a03c4fcbe547168fab128fa39b08d1122a1c2/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1a03c4fcbe547168fab128fa39b08d1122a1c2/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=bb1a03c4fcbe547168fab128fa39b08d1122a1c2", "patch": "@@ -2511,14 +2511,23 @@ trait RcInnerPtr {\n     fn inc_strong(&self) {\n         let strong = self.strong();\n \n+        // We insert an `assume` here to hint LLVM at an otherwise\n+        // missed optimization.\n+        // SAFETY: The reference count will never be zero when this is\n+        // called.\n+        unsafe {\n+            core::intrinsics::assume(strong != 0);\n+        }\n+\n+        let strong = strong.wrapping_add(1);\n+        self.strong_ref().set(strong);\n+\n         // We want to abort on overflow instead of dropping the value.\n-        // The reference count will never be zero when this is called;\n-        // nevertheless, we insert an abort here to hint LLVM at\n-        // an otherwise missed optimization.\n-        if strong == 0 || strong == usize::MAX {\n+        // Checking for overflow after the store instead of before\n+        // allows for slightly better code generation.\n+        if core::intrinsics::unlikely(strong == 0) {\n             abort();\n         }\n-        self.strong_ref().set(strong + 1);\n     }\n \n     #[inline]\n@@ -2535,14 +2544,23 @@ trait RcInnerPtr {\n     fn inc_weak(&self) {\n         let weak = self.weak();\n \n+        // We insert an `assume` here to hint LLVM at an otherwise\n+        // missed optimization.\n+        // SAFETY: The reference count will never be zero when this is\n+        // called.\n+        unsafe {\n+            core::intrinsics::assume(weak != 0);\n+        }\n+\n+        let weak = weak.wrapping_add(1);\n+        self.weak_ref().set(weak);\n+\n         // We want to abort on overflow instead of dropping the value.\n-        // The reference count will never be zero when this is called;\n-        // nevertheless, we insert an abort here to hint LLVM at\n-        // an otherwise missed optimization.\n-        if weak == 0 || weak == usize::MAX {\n+        // Checking for overflow after the store instead of before\n+        // allows for slightly better code generation.\n+        if core::intrinsics::unlikely(weak == 0) {\n             abort();\n         }\n-        self.weak_ref().set(weak + 1);\n     }\n \n     #[inline]"}]}