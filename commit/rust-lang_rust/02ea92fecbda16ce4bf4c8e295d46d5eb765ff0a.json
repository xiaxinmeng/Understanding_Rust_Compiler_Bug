{"sha": "02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "node_id": "C_kwDOAAsO6NoAKDAyZWE5MmZlY2JkYTE2Y2U0YmY0YzhlMjk1ZDQ2ZDVlYjc2NWZmMGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-30T12:34:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-30T12:34:37Z"}, "message": "Auto merge of #14445 - Veykril:adt-flags, r=Veykril\n\ninternal: Introduce StructFlags", "tree": {"sha": "6c750ce3d2780664a8c798bdc27391ae7a3d961b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c750ce3d2780664a8c798bdc27391ae7a3d961b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "html_url": "https://github.com/rust-lang/rust/commit/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc8c5139fad70696f99d27e2ca1f59e4672fd017", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc8c5139fad70696f99d27e2ca1f59e4672fd017", "html_url": "https://github.com/rust-lang/rust/commit/fc8c5139fad70696f99d27e2ca1f59e4672fd017"}, {"sha": "33b6012827b5d5a31c746177582017248acb339b", "url": "https://api.github.com/repos/rust-lang/rust/commits/33b6012827b5d5a31c746177582017248acb339b", "html_url": "https://github.com/rust-lang/rust/commit/33b6012827b5d5a31c746177582017248acb339b"}], "stats": {"total": 147, "additions": 91, "deletions": 56}, "files": [{"sha": "7a5025aa6a524a106056fb03d8370afeed59bf74", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -3,6 +3,7 @@\n use std::sync::Arc;\n \n use base_db::CrateId;\n+use bitflags::bitflags;\n use cfg::CfgOptions;\n use either::Either;\n \n@@ -20,6 +21,7 @@ use crate::{\n     builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n+    lang_item::LangItem,\n     layout::{Align, ReprFlags, ReprOptions},\n     nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n@@ -39,8 +41,26 @@ pub struct StructData {\n     pub variant_data: Arc<VariantData>,\n     pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n-    pub rustc_has_incoherent_inherent_impls: bool,\n-    pub fundamental: bool,\n+    pub flags: StructFlags,\n+}\n+\n+bitflags! {\n+    pub struct StructFlags: u8 {\n+        const NO_FLAGS         = 0;\n+        /// Indicates whether the struct is `PhantomData`.\n+        const IS_PHANTOM_DATA  = 1 << 2;\n+        /// Indicates whether the struct has a `#[fundamental]` attribute.\n+        const IS_FUNDAMENTAL   = 1 << 3;\n+        // FIXME: should this be a flag?\n+        /// Indicates whether the struct has a `#[rustc_has_incoherent_inherent_impls]` attribute.\n+        const IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL      = 1 << 4;\n+        /// Indicates whether this struct is `Box`.\n+        const IS_BOX           = 1 << 5;\n+        /// Indicates whether this struct is `ManuallyDrop`.\n+        const IS_MANUALLY_DROP = 1 << 6;\n+        /// Indicates whether this struct is `UnsafeCell`.\n+        const IS_UNSAFE_CELL   = 1 << 6;\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -174,10 +194,25 @@ impl StructData {\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n+\n         let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n-        let rustc_has_incoherent_inherent_impls =\n-            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n-        let fundamental = attrs.by_key(\"fundamental\").exists();\n+\n+        let mut flags = StructFlags::NO_FLAGS;\n+        if attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists() {\n+            flags |= StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL;\n+        }\n+        if attrs.by_key(\"fundamental\").exists() {\n+            flags |= StructFlags::IS_FUNDAMENTAL;\n+        }\n+        if let Some(lang) = attrs.lang_item() {\n+            match lang {\n+                LangItem::PhantomData => flags |= StructFlags::IS_PHANTOM_DATA,\n+                LangItem::OwnedBox => flags |= StructFlags::IS_BOX,\n+                LangItem::ManuallyDrop => flags |= StructFlags::IS_MANUALLY_DROP,\n+                LangItem::UnsafeCell => flags |= StructFlags::IS_UNSAFE_CELL,\n+                _ => (),\n+            }\n+        }\n \n         let strukt = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -196,8 +231,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[strukt.visibility].clone(),\n-                rustc_has_incoherent_inherent_impls,\n-                fundamental,\n+                flags,\n             }),\n             diagnostics.into(),\n         )\n@@ -218,9 +252,13 @@ impl StructData {\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n-        let rustc_has_incoherent_inherent_impls =\n-            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n-        let fundamental = attrs.by_key(\"fundamental\").exists();\n+        let mut flags = StructFlags::NO_FLAGS;\n+        if attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists() {\n+            flags |= StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL;\n+        }\n+        if attrs.by_key(\"fundamental\").exists() {\n+            flags |= StructFlags::IS_FUNDAMENTAL;\n+        }\n \n         let union = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -239,8 +277,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[union.visibility].clone(),\n-                rustc_has_incoherent_inherent_impls,\n-                fundamental,\n+                flags,\n             }),\n             diagnostics.into(),\n         )"}, {"sha": "860df1b68b2b1a265d78808b16f14c2c7eb4502d", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -20,6 +20,7 @@ use syntax::{\n use crate::{\n     db::DefDatabase,\n     item_tree::{AttrOwner, Fields, ItemTreeId, ItemTreeNode},\n+    lang_item::LangItem,\n     nameres::{ModuleOrigin, ModuleSource},\n     src::{HasChildSource, HasSource},\n     AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n@@ -177,13 +178,13 @@ impl Attrs {\n \n         Arc::new(res)\n     }\n+}\n \n+impl Attrs {\n     pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n         AttrQuery { attrs: self, key }\n     }\n-}\n \n-impl Attrs {\n     pub fn cfg(&self) -> Option<CfgExpr> {\n         let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse);\n         let first = cfgs.next()?;\n@@ -206,6 +207,10 @@ impl Attrs {\n         self.by_key(\"lang\").string_value()\n     }\n \n+    pub fn lang_item(&self) -> Option<LangItem> {\n+        self.by_key(\"lang\").string_value().and_then(|it| LangItem::from_str(it))\n+    }\n+\n     pub fn docs(&self) -> Option<Documentation> {\n         let docs = self.by_key(\"doc\").attrs().filter_map(|attr| attr.string_value());\n         let indent = doc_indent(self);"}, {"sha": "e23ae750dd50f851f50375cbfd4df94b2012456f", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -4,10 +4,7 @@\n //! logic in rustc (which lives in rustc_hir_analysis/check/autoderef.rs).\n \n use chalk_ir::cast::Cast;\n-use hir_def::{\n-    lang_item::{LangItem, LangItemTarget},\n-    AdtId,\n-};\n+use hir_def::lang_item::LangItem;\n use hir_expand::name::name;\n use limit::Limit;\n \n@@ -90,13 +87,8 @@ pub(crate) fn builtin_deref<'ty>(\n         TyKind::Ref(.., ty) => Some(ty),\n         // FIXME: Maybe accept this but diagnose if its not explicit?\n         TyKind::Raw(.., ty) if explicit => Some(ty),\n-        &TyKind::Adt(chalk_ir::AdtId(AdtId::StructId(strukt)), ref substs) => {\n-            if Some(strukt)\n-                == table\n-                    .db\n-                    .lang_item(table.trait_env.krate, LangItem::OwnedBox)\n-                    .and_then(LangItemTarget::as_struct)\n-            {\n+        &TyKind::Adt(chalk_ir::AdtId(adt), ref substs) => {\n+            if crate::lang_items::is_box(table.db, adt) {\n                 substs.at(Interner, 0).ty(Interner)\n             } else {\n                 None"}, {"sha": "fe1cda71dd58ba679ccc77ee52de2019ed4eb2fb", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -379,7 +379,7 @@ impl HirDisplay for Pat {\n             }\n             PatKind::Deref { subpattern } => {\n                 match self.ty.kind(Interner) {\n-                    TyKind::Adt(adt, _) if is_box(adt.0, f.db) => write!(f, \"box \")?,\n+                    TyKind::Adt(adt, _) if is_box(f.db, adt.0) => write!(f, \"box \")?,\n                     &TyKind::Ref(mutbl, ..) => {\n                         write!(f, \"&{}\", if mutbl == Mutability::Mut { \"mut \" } else { \"\" })?\n                     }"}, {"sha": "b103fdc709daeb9f35ab93378bd9122cd5c63a57", "filename": "crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -384,7 +384,7 @@ impl Constructor {\n                 TyKind::Tuple(arity, ..) => arity,\n                 TyKind::Ref(..) => 1,\n                 TyKind::Adt(adt, ..) => {\n-                    if is_box(adt.0, pcx.cx.db) {\n+                    if is_box(pcx.cx.db, adt.0) {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         1\n@@ -800,7 +800,7 @@ impl<'p> Fields<'p> {\n                 }\n                 TyKind::Ref(.., rty) => Fields::wildcards_from_tys(cx, once(rty.clone())),\n                 &TyKind::Adt(AdtId(adt), ref substs) => {\n-                    if is_box(adt, cx.db) {\n+                    if is_box(cx.db, adt) {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         let subst_ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n@@ -905,7 +905,7 @@ impl<'p> DeconstructedPat<'p> {\n                         }\n                         fields = Fields::from_iter(cx, wilds)\n                     }\n-                    TyKind::Adt(adt, substs) if is_box(adt.0, cx.db) => {\n+                    TyKind::Adt(adt, substs) if is_box(cx.db, adt.0) => {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n@@ -992,7 +992,7 @@ impl<'p> DeconstructedPat<'p> {\n                         })\n                         .collect(),\n                 },\n-                TyKind::Adt(adt, _) if is_box(adt.0, cx.db) => {\n+                TyKind::Adt(adt, _) if is_box(cx.db, adt.0) => {\n                     // Without `box_patterns`, the only legal pattern of type `Box` is `_` (outside\n                     // of `std`). So this branch is only reachable when the feature is enabled and\n                     // the pattern is a box pattern."}, {"sha": "b0ad4fc946a8f8095de923139c98ecac0eadfa84", "filename": "crates/hir-ty/src/lang_items.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -1,22 +1,18 @@\n //! Functions to detect special lang items\n \n-use hir_def::{lang_item::LangItem, AdtId, HasModule};\n+use hir_def::{adt::StructFlags, lang_item::LangItem, AdtId};\n use hir_expand::name::Name;\n \n use crate::db::HirDatabase;\n \n-pub fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let krate = adt.module(db.upcast()).krate();\n-    let box_adt =\n-        db.lang_item(krate, LangItem::OwnedBox).and_then(|it| it.as_struct()).map(AdtId::from);\n-    Some(adt) == box_adt\n+pub fn is_box(db: &dyn HirDatabase, adt: AdtId) -> bool {\n+    let AdtId::StructId(id) = adt else { return false };\n+    db.struct_data(id).flags.contains(StructFlags::IS_UNSAFE_CELL)\n }\n \n-pub fn is_unsafe_cell(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let krate = adt.module(db.upcast()).krate();\n-    let box_adt =\n-        db.lang_item(krate, LangItem::UnsafeCell).and_then(|it| it.as_struct()).map(AdtId::from);\n-    Some(adt) == box_adt\n+pub fn is_unsafe_cell(db: &dyn HirDatabase, adt: AdtId) -> bool {\n+    let AdtId::StructId(id) = adt else { return false };\n+    db.struct_data(id).flags.contains(StructFlags::IS_UNSAFE_CELL)\n }\n \n pub fn lang_items_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, LangItem)> {"}, {"sha": "18199f327d14b99a17a68cc58cefc982397281d8", "filename": "crates/hir-ty/src/layout/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -71,7 +71,7 @@ pub fn layout_of_adt_query(\n             &repr,\n             &variants,\n             is_enum,\n-            is_unsafe_cell(def, db),\n+            is_unsafe_cell(db, def),\n             layout_scalar_valid_range(db, def),\n             |min, max| Integer::repr_discr(&dl, &repr, min, max).unwrap_or((Integer::I8, false)),\n             variants.iter_enumerated().filter_map(|(id, _)| {"}, {"sha": "d253b4cc03e680bd5b653c52db0e00d5666c2de0", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=02ea92fecbda16ce4bf4c8e295d46d5eb765ff0a", "patch": "@@ -7,8 +7,9 @@ use std::{ops::ControlFlow, sync::Arc};\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, TyKind, UniverseIndex, WhereClause};\n use hir_def::{\n-    data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n-    FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    adt::StructFlags, data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId,\n+    ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId,\n+    TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -405,12 +406,14 @@ pub fn def_crates(\n     match ty.kind(Interner) {\n         &TyKind::Adt(AdtId(def_id), _) => {\n             let rustc_has_incoherent_inherent_impls = match def_id {\n-                hir_def::AdtId::StructId(id) => {\n-                    db.struct_data(id).rustc_has_incoherent_inherent_impls\n-                }\n-                hir_def::AdtId::UnionId(id) => {\n-                    db.union_data(id).rustc_has_incoherent_inherent_impls\n-                }\n+                hir_def::AdtId::StructId(id) => db\n+                    .struct_data(id)\n+                    .flags\n+                    .contains(StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL),\n+                hir_def::AdtId::UnionId(id) => db\n+                    .union_data(id)\n+                    .flags\n+                    .contains(StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL),\n                 hir_def::AdtId::EnumId(id) => db.enum_data(id).rustc_has_incoherent_inherent_impls,\n             };\n             Some(if rustc_has_incoherent_inherent_impls {\n@@ -808,12 +811,14 @@ fn is_inherent_impl_coherent(\n             | TyKind::Scalar(_) => true,\n \n             &TyKind::Adt(AdtId(adt), _) => match adt {\n-                hir_def::AdtId::StructId(it) => {\n-                    db.struct_data(it).rustc_has_incoherent_inherent_impls\n-                }\n-                hir_def::AdtId::UnionId(it) => {\n-                    db.union_data(it).rustc_has_incoherent_inherent_impls\n-                }\n+                hir_def::AdtId::StructId(id) => db\n+                    .struct_data(id)\n+                    .flags\n+                    .contains(StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL),\n+                hir_def::AdtId::UnionId(id) => db\n+                    .union_data(id)\n+                    .flags\n+                    .contains(StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL),\n                 hir_def::AdtId::EnumId(it) => db.enum_data(it).rustc_has_incoherent_inherent_impls,\n             },\n             TyKind::Dyn(it) => it.principal().map_or(false, |trait_ref| {"}]}