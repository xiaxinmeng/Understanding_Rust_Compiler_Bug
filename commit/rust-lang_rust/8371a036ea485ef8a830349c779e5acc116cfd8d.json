{"sha": "8371a036ea485ef8a830349c779e5acc116cfd8d", "node_id": "C_kwDOAAsO6NoAKDgzNzFhMDM2ZWE0ODVlZjhhODMwMzQ5Yzc3OWU1YWNjMTE2Y2ZkOGQ", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-07-04T13:38:42Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-07-06T10:15:13Z"}, "message": "incr: cache dwarf objects in work products\n\nCache DWARF objects alongside object files in work products when those\nexist so that DWARF object files are available for thorin in packed mode\nin incremental scenarios.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "ac6ef78e238c03d1bd5b13d860038148edbd8d6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac6ef78e238c03d1bd5b13d860038148edbd8d6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8371a036ea485ef8a830349c779e5acc116cfd8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8371a036ea485ef8a830349c779e5acc116cfd8d", "html_url": "https://github.com/rust-lang/rust/commit/8371a036ea485ef8a830349c779e5acc116cfd8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8371a036ea485ef8a830349c779e5acc116cfd8d/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7", "html_url": "https://github.com/rust-lang/rust/commit/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7"}], "stats": {"total": 194, "additions": 128, "deletions": 66}, "files": [{"sha": "50d8fc30d7d7cabe13275e9a3c099834abb37c69", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=8371a036ea485ef8a830349c779e5acc116cfd8d", "patch": "@@ -66,7 +66,11 @@ fn emit_module(\n     let work_product = if backend_config.disable_incr_cache {\n         None\n     } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(tcx.sess, &name, &tmp_file)\n+        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+            tcx.sess,\n+            &name,\n+            &[(\"o\", &tmp_file)],\n+        )\n     };\n \n     ModuleCodegenResult(\n@@ -82,7 +86,10 @@ fn reuse_workproduct_for_cgu(\n ) -> CompiledModule {\n     let work_product = cgu.previous_work_product(tcx);\n     let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-    let source_file = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, &work_product.saved_file);\n+    let source_file = rustc_incremental::in_incr_comp_dir_sess(\n+        &tcx.sess,\n+        &work_product.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n+    );\n     if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n         tcx.sess.err(&format!(\n             \"unable to copy {} to {}: {}\","}, {"sha": "f4a5cac872e0516c2d5b7e483bd6ad3f9840fbaf", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=8371a036ea485ef8a830349c779e5acc116cfd8d", "patch": "@@ -494,12 +494,18 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n     let _timer = sess.timer(\"copy_all_cgu_workproducts_to_incr_comp_cache_dir\");\n \n     for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        if let Some(path) = &module.object {\n-            if let Some((id, product)) =\n-                copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, path)\n-            {\n-                work_products.insert(id, product);\n-            }\n+        let mut files = Vec::new();\n+        if let Some(object_file_path) = &module.object {\n+            files.push((\"o\", object_file_path.as_path()));\n+        }\n+        if let Some(dwarf_object_file_path) = &module.dwarf_object {\n+            files.push((\"dwo\", dwarf_object_file_path.as_path()));\n+        }\n+\n+        if let Some((id, product)) =\n+            copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, files.as_slice())\n+        {\n+            work_products.insert(id, product);\n         }\n     }\n \n@@ -856,29 +862,50 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     assert!(module_config.emit_obj != EmitObj::None);\n \n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n-    let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name));\n-    let source_file = in_incr_comp_dir(&incr_comp_session_dir, &module.source.saved_file);\n-    debug!(\n-        \"copying pre-existing module `{}` from {:?} to {}\",\n-        module.name,\n-        source_file,\n-        obj_out.display()\n+\n+    let load_from_incr_comp_dir = |output_path: PathBuf, saved_path: &str| {\n+        let source_file = in_incr_comp_dir(&incr_comp_session_dir, saved_path);\n+        debug!(\n+            \"copying pre-existing module `{}` from {:?} to {}\",\n+            module.name,\n+            source_file,\n+            output_path.display()\n+        );\n+        match link_or_copy(&source_file, &output_path) {\n+            Ok(_) => Some(output_path),\n+            Err(err) => {\n+                let diag_handler = cgcx.create_diag_handler();\n+                diag_handler.err(&format!(\n+                    \"unable to copy {} to {}: {}\",\n+                    source_file.display(),\n+                    output_path.display(),\n+                    err\n+                ));\n+                None\n+            }\n+        }\n+    };\n+\n+    let object = load_from_incr_comp_dir(\n+        cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name)),\n+        &module.source.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n     );\n-    if let Err(err) = link_or_copy(&source_file, &obj_out) {\n-        let diag_handler = cgcx.create_diag_handler();\n-        diag_handler.err(&format!(\n-            \"unable to copy {} to {}: {}\",\n-            source_file.display(),\n-            obj_out.display(),\n-            err\n-        ));\n-    }\n+    let dwarf_object =\n+        module.source.saved_files.get(\"dwo\").as_ref().and_then(|saved_dwarf_object_file| {\n+            let dwarf_obj_out = cgcx\n+                .output_filenames\n+                .split_dwarf_path(cgcx.split_debuginfo, cgcx.split_dwarf_kind, Some(&module.name))\n+                .expect(\n+                    \"saved dwarf object in work product but `split_dwarf_path` returned `None`\",\n+                );\n+            load_from_incr_comp_dir(dwarf_obj_out, &saved_dwarf_object_file)\n+        });\n \n     WorkItemResult::Compiled(CompiledModule {\n         name: module.name,\n         kind: ModuleKind::Regular,\n-        object: Some(obj_out),\n-        dwarf_object: None,\n+        object,\n+        dwarf_object,\n         bytecode: None,\n     })\n }"}, {"sha": "f59d8d596b98ec1f9bcf8d50a36d0967465d7ce7", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=8371a036ea485ef8a830349c779e5acc116cfd8d", "patch": "@@ -161,19 +161,13 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n                 Decodable::decode(&mut work_product_decoder);\n \n             for swp in work_products {\n-                let mut all_files_exist = true;\n-                let path = in_incr_comp_dir_sess(sess, &swp.work_product.saved_file);\n-                if !path.exists() {\n-                    all_files_exist = false;\n-\n-                    if sess.opts.debugging_opts.incremental_info {\n-                        eprintln!(\n-                            \"incremental: could not find file for work \\\n-                                    product: {}\",\n-                            path.display()\n-                        );\n+                let all_files_exist = swp.work_product.saved_files.iter().all(|(_, path)| {\n+                    let exists = in_incr_comp_dir_sess(sess, path).exists();\n+                    if !exists && sess.opts.debugging_opts.incremental_info {\n+                        eprintln!(\"incremental: could not find file for work product: {path}\",);\n                     }\n-                }\n+                    exists\n+                });\n \n                 if all_files_exist {\n                     debug!(\"reconcile_work_products: all files for {:?} exist\", swp);"}, {"sha": "4059b7cfc8eb9eb3d2ca072b795fffe2e619996a", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=8371a036ea485ef8a830349c779e5acc116cfd8d", "patch": "@@ -108,16 +108,17 @@ pub fn save_work_product_index(\n     for (id, wp) in previous_work_products.iter() {\n         if !new_work_products.contains_key(id) {\n             work_product::delete_workproduct_files(sess, wp);\n-            debug_assert!(!in_incr_comp_dir_sess(sess, &wp.saved_file).exists());\n+            debug_assert!(\n+                !wp.saved_files.iter().all(|(_, path)| in_incr_comp_dir_sess(sess, path).exists())\n+            );\n         }\n     }\n \n     // Check that we did not delete one of the current work-products:\n     debug_assert!({\n-        new_work_products\n-            .iter()\n-            .map(|(_, wp)| in_incr_comp_dir_sess(sess, &wp.saved_file))\n-            .all(|path| path.exists())\n+        new_work_products.iter().all(|(_, wp)| {\n+            wp.saved_files.iter().all(|(_, path)| in_incr_comp_dir_sess(sess, path).exists())\n+        })\n     });\n }\n "}, {"sha": "1b184eca964c34fa5247205613f3aadd9ea94f36", "filename": "compiler/rustc_incremental/src/persist/work_product.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs?ref=8371a036ea485ef8a830349c779e5acc116cfd8d", "patch": "@@ -3,6 +3,7 @@\n //! [work products]: WorkProduct\n \n use crate::persist::fs::*;\n+use rustc_data_structures::stable_map::FxHashMap;\n use rustc_fs_util::link_or_copy;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_session::Session;\n@@ -13,38 +14,41 @@ use std::path::Path;\n pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n     sess: &Session,\n     cgu_name: &str,\n-    path: &Path,\n+    files: &[(&'static str, &Path)],\n ) -> Option<(WorkProductId, WorkProduct)> {\n-    debug!(\"copy_cgu_workproduct_to_incr_comp_cache_dir({:?},{:?})\", cgu_name, path);\n+    debug!(?cgu_name, ?files);\n     sess.opts.incremental.as_ref()?;\n \n-    let file_name = format!(\"{}.o\", cgu_name);\n-    let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n-    let saved_file = match link_or_copy(path, &path_in_incr_dir) {\n-        Ok(_) => file_name,\n-        Err(err) => {\n-            sess.warn(&format!(\n-                \"error copying object file `{}` to incremental directory as `{}`: {}\",\n-                path.display(),\n-                path_in_incr_dir.display(),\n-                err\n-            ));\n-            return None;\n+    let mut saved_files = FxHashMap::default();\n+    for (ext, path) in files {\n+        let file_name = format!(\"{cgu_name}.{ext}\");\n+        let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n+        match link_or_copy(path, &path_in_incr_dir) {\n+            Ok(_) => {\n+                let _ = saved_files.insert(ext.to_string(), file_name);\n+            }\n+            Err(err) => {\n+                sess.warn(&format!(\n+                    \"error copying object file `{}` to incremental directory as `{}`: {}\",\n+                    path.display(),\n+                    path_in_incr_dir.display(),\n+                    err\n+                ));\n+            }\n         }\n-    };\n-\n-    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_file };\n+    }\n \n+    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_files };\n+    debug!(?work_product);\n     let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n     Some((work_product_id, work_product))\n }\n \n /// Removes files for a given work product.\n pub fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) {\n-    let path = in_incr_comp_dir_sess(sess, &work_product.saved_file);\n-    match std_fs::remove_file(&path) {\n-        Ok(()) => {}\n-        Err(err) => {\n+    for (_, path) in &work_product.saved_files {\n+        let path = in_incr_comp_dir_sess(sess, path);\n+        if let Err(err) = std_fs::remove_file(&path) {\n             sess.warn(&format!(\n                 \"file-system error deleting outdated file `{}`: {}\",\n                 path.display(),"}, {"sha": "3291717c550df27d2a5a7b3f3ba51b61c1d0f2f2", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371a036ea485ef8a830349c779e5acc116cfd8d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=8371a036ea485ef8a830349c779e5acc116cfd8d", "patch": "@@ -886,8 +886,12 @@ impl<K: DepKind> DepGraph<K> {\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Saved file associated with this CGU.\n-    pub saved_file: String,\n+    /// Saved files associated with this CGU. In each key/value pair, the value is the path to the\n+    /// saved file and the key is some identifier for the type of file being saved.\n+    ///\n+    /// By convention, file extensions are currently used as identifiers, i.e. the key \"o\" maps to\n+    /// the object file's path, and \"dwo\" to the dwarf object file's path.\n+    pub saved_files: FxHashMap<String, String>,\n }\n \n // Index type for `DepNodeData`'s edges."}, {"sha": "25c802d5a1d2e35471c6f143c7a263f724c4c33c", "filename": "src/test/incremental/split_debuginfo_cached.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8371a036ea485ef8a830349c779e5acc116cfd8d/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371a036ea485ef8a830349c779e5acc116cfd8d/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs?ref=8371a036ea485ef8a830349c779e5acc116cfd8d", "patch": "@@ -0,0 +1,25 @@\n+// Check that compiling with packed Split DWARF twice succeeds. This should confirm that DWARF\n+// objects are cached as work products and available to the incremental compilation for `thorin` to\n+// pack into a DWARF package.\n+\n+// ignore-tidy-linelength\n+// only-x86_64-unknown-linux-gnu\n+// revisions:rpass1 rpass2\n+\n+// [rpass1]compile-flags: -g -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split\n+// [rpass2]compile-flags: -g -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split\n+\n+#![feature(rustc_attrs)]\n+// For `rpass2`, nothing has changed so everything should re-used.\n+#![rustc_partition_reused(module = \"split_debuginfo_cached\", cfg = \"rpass2\")]\n+#![rustc_partition_reused(module = \"split_debuginfo_cached-another_module\", cfg = \"rpass2\")]\n+\n+mod another_module {\n+    pub fn foo() -> &'static str {\n+        \"hello world\"\n+    }\n+}\n+\n+pub fn main() {\n+    println!(\"{}\", another_module::foo());\n+}"}]}