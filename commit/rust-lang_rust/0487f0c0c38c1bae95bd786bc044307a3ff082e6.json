{"sha": "0487f0c0c38c1bae95bd786bc044307a3ff082e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ODdmMGMwYzM4YzFiYWU5NWJkNzg2YmMwNDQzMDdhM2ZmMDgyZTY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-09T02:04:05Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-17T00:24:00Z"}, "message": "Suggest calling async closure when needed\n\nWhen using an async closure as a value in a place that expects a future,\nsuggest calling the closure.\n\nFix #65923.", "tree": {"sha": "8181469e0ffab3791e947e0c0f936e3c8fde7a0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8181469e0ffab3791e947e0c0f936e3c8fde7a0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0487f0c0c38c1bae95bd786bc044307a3ff082e6", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0487f0c0c38c1bae95bd786bc044307a3ff082e6", "html_url": "https://github.com/rust-lang/rust/commit/0487f0c0c38c1bae95bd786bc044307a3ff082e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0487f0c0c38c1bae95bd786bc044307a3ff082e6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c5b8afd80e6fa1d24632153cb2257c686041d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c5b8afd80e6fa1d24632153cb2257c686041d41", "html_url": "https://github.com/rust-lang/rust/commit/5c5b8afd80e6fa1d24632153cb2257c686041d41"}], "stats": {"total": 198, "additions": 143, "deletions": 55}, "files": [{"sha": "4a51ce2b780df94f253c3108016e7fa85172ca19", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 101, "deletions": 52, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0487f0c0c38c1bae95bd786bc044307a3ff082e6", "patch": "@@ -1238,60 +1238,109 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         points_at_arg: bool,\n     ) {\n         let self_ty = trait_ref.self_ty();\n-        match self_ty.kind {\n+        let (def_id, output_ty, callable) = match self_ty.kind {\n+            ty::Closure(def_id, substs) => {\n+                (def_id, self.closure_sig(def_id, substs).output(), \"closure\")\n+            }\n             ty::FnDef(def_id, _) => {\n-                // We tried to apply the bound to an `fn`. Check whether calling it would evaluate\n-                // to a type that *would* satisfy the trait binding. If it would, suggest calling\n-                // it: `bar(foo)` -> `bar(foo)`. This case is *very* likely to be hit if `foo` is\n-                // `async`.\n-                let output_ty = self_ty.fn_sig(self.tcx).output();\n-                let new_trait_ref = ty::TraitRef {\n-                    def_id: trait_ref.def_id(),\n-                    substs: self.tcx.mk_substs_trait(output_ty.skip_binder(), &[]),\n-                };\n-                let obligation = Obligation::new(\n-                    obligation.cause.clone(),\n-                    obligation.param_env,\n-                    new_trait_ref.to_predicate(),\n-                );\n-                match self.evaluate_obligation(&obligation) {\n-                    Ok(EvaluationResult::EvaluatedToOk) |\n-                    Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n-                    Ok(EvaluationResult::EvaluatedToAmbig) => {\n-                        if let Some(hir::Node::Item(hir::Item {\n-                            ident,\n-                            kind: hir::ItemKind::Fn(.., body_id),\n-                            ..\n-                        })) = self.tcx.hir().get_if_local(def_id) {\n-                            let body = self.tcx.hir().body(*body_id);\n-                            let msg = \"use parentheses to call the function\";\n-                            let snippet = format!(\n-                                \"{}({})\",\n-                                ident,\n-                                body.params.iter()\n-                                    .map(|arg| match &arg.pat.kind {\n-                                        hir::PatKind::Binding(_, _, ident, None)\n-                                        if ident.name != kw::SelfLower => ident.to_string(),\n-                                        _ => \"_\".to_string(),\n-                                    }).collect::<Vec<_>>().join(\", \"),\n-                            );\n-                            // When the obligation error has been ensured to have been caused by\n-                            // an argument, the `obligation.cause.span` points at the expression\n-                            // of the argument, so we can provide a suggestion. This is signaled\n-                            // by `points_at_arg`. Otherwise, we give a more general note.\n-                            if points_at_arg {\n-                                err.span_suggestion(\n-                                    obligation.cause.span,\n-                                    msg,\n-                                    snippet,\n-                                    Applicability::HasPlaceholders,\n-                                );\n-                            } else {\n-                                err.help(&format!(\"{}: `{}`\", msg, snippet));\n-                            }\n-                        }\n+                (def_id, self_ty.fn_sig(self.tcx).output(), \"function\")\n+            }\n+            _ => return,\n+        };\n+        let msg = format!(\"use parentheses to call the {}\", callable);\n+        // We tried to apply the bound to an `fn` or closure. Check whether calling it would\n+        // evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n+        // it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n+\n+        let new_trait_ref = ty::TraitRef {\n+            def_id: trait_ref.def_id(),\n+            substs: self.tcx.mk_substs_trait(output_ty.skip_binder(), &[]),\n+        };\n+        let obligation = Obligation::new(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            new_trait_ref.to_predicate(),\n+        );\n+        let get_name = |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind| -> Option<String> {\n+            // Get the local name of this closure. This can be inaccurate because\n+            // of the possibility of reassignment, but this should be good enough.\n+            match &kind {\n+                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                    Some(format!(\"{}\", name))\n+                }\n+                _ => {\n+                    err.note(&msg);\n+                    None\n+                }\n+            }\n+        };\n+        match self.evaluate_obligation(&obligation) {\n+            Ok(EvaluationResult::EvaluatedToOk) |\n+            Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n+            Ok(EvaluationResult::EvaluatedToAmbig) => {\n+                let hir = self.tcx.hir();\n+                // Get the name of the callable and the arguments to be used in the suggestion.\n+                let snippet = match hir.get_if_local(def_id) {\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind: hir::ExprKind::Closure(_, decl, _, span, ..),\n+                        ..\n+                    })) => {\n+                        err.span_label(*span, \"consider calling this closure\");\n+                        let hir_id = match hir.as_local_hir_id(def_id) {\n+                            Some(hir_id) => hir_id,\n+                            None => return,\n+                        };\n+                        let parent_node = hir.get_parent_node(hir_id);\n+                        let name = match hir.find(parent_node) {\n+                            Some(hir::Node::Stmt(hir::Stmt {\n+                                kind: hir::StmtKind::Local(local), ..\n+                            })) => match get_name(err, &local.pat.kind) {\n+                                Some(name) => name,\n+                                None => return,\n+                            },\n+                            // Different to previous arm because one is `&hir::Local` and the other\n+                            // is `P<hir::Local>`.\n+                            Some(hir::Node::Local(local)) => match get_name(err, &local.pat.kind) {\n+                                Some(name) => name,\n+                                None => return,\n+                            },\n+                            _ => return,\n+                        };\n+                        let args = decl.inputs.iter()\n+                            .map(|_| \"_\")\n+                            .collect::<Vec<_>>().join(\", \");\n+                        format!(\"{}({})\", name, args)\n+                    }\n+                    Some(hir::Node::Item(hir::Item {\n+                        ident,\n+                        kind: hir::ItemKind::Fn(.., body_id),\n+                        ..\n+                    })) => {\n+                        err.span_label(ident.span, \"consider calling this function\");\n+                        let body = hir.body(*body_id);\n+                        let args = body.params.iter()\n+                            .map(|arg| match &arg.pat.kind {\n+                                hir::PatKind::Binding(_, _, ident, None)\n+                                if ident.name != kw::SelfLower => ident.to_string(),\n+                                _ => \"_\".to_string(),\n+                            }).collect::<Vec<_>>().join(\", \");\n+                        format!(\"{}({})\", ident, args)\n                     }\n-                    _ => {}\n+                    _ => return,\n+                };\n+                if points_at_arg {\n+                    // When the obligation error has been ensured to have been caused by\n+                    // an argument, the `obligation.cause.span` points at the expression\n+                    // of the argument, so we can provide a suggestion. This is signaled\n+                    // by `points_at_arg`. Otherwise, we give a more general note.\n+                    err.span_suggestion(\n+                        obligation.cause.span,\n+                        &msg,\n+                        snippet,\n+                        Applicability::HasPlaceholders,\n+                    );\n+                } else {\n+                    err.help(&format!(\"{}: `{}`\", msg, snippet));\n                 }\n             }\n             _ => {}"}, {"sha": "156162c9027c318a89675aabf092739df0a218aa", "filename": "src/test/ui/suggestions/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs?ref=0487f0c0c38c1bae95bd786bc044307a3ff082e6", "patch": "@@ -1,4 +1,5 @@\n // edition:2018\n+#![feature(async_closure)]\n use std::future::Future;\n \n async fn foo() {}\n@@ -7,4 +8,6 @@ fn bar(f: impl Future<Output=()>) {}\n \n fn main() {\n     bar(foo); //~ERROR E0277\n+    let async_closure = async || ();\n+    bar(async_closure); //~ERROR E0277\n }"}, {"sha": "05583876a066c3aca42f206fce868e9c75ebd380", "filename": "src/test/ui/suggestions/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr?ref=0487f0c0c38c1bae95bd786bc044307a3ff082e6", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: the trait bound `fn() -> impl std::future::Future {foo}: std::future::Future` is not satisfied\n-  --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:9:9\n+  --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:10:9\n    |\n+LL | async fn foo() {}\n+   |          --- consider calling this function\n+LL | \n LL | fn bar(f: impl Future<Output=()>) {}\n    |    ---         ----------------- required by this bound in `bar`\n ...\n@@ -10,6 +13,20 @@ LL |     bar(foo);\n    |         the trait `std::future::Future` is not implemented for `fn() -> impl std::future::Future {foo}`\n    |         help: use parentheses to call the function: `foo()`\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]: std::future::Future` is not satisfied\n+  --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:12:9\n+   |\n+LL | fn bar(f: impl Future<Output=()>) {}\n+   |    ---         ----------------- required by this bound in `bar`\n+...\n+LL |     let async_closure = async || ();\n+   |                         -------- consider calling this closure\n+LL |     bar(async_closure);\n+   |         ^^^^^^^^^^^^^\n+   |         |\n+   |         the trait `std::future::Future` is not implemented for `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]`\n+   |         help: use parentheses to call the closure: `async_closure()`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "4303e5c54056977b86abc8fdc9d83b957a1ea43d", "filename": "src/test/ui/suggestions/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.rs?ref=0487f0c0c38c1bae95bd786bc044307a3ff082e6", "patch": "@@ -15,4 +15,6 @@ fn bar(f: impl T<O=()>) {}\n \n fn main() {\n     bar(foo); //~ERROR E0277\n+    let closure = || S;\n+    bar(closure); //~ERROR E0277\n }"}, {"sha": "91f60e8f426c4fa552a8c5bb68c304a2cccca99f", "filename": "src/test/ui/suggestions/fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0487f0c0c38c1bae95bd786bc044307a3ff082e6/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr?ref=0487f0c0c38c1bae95bd786bc044307a3ff082e6", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: the trait bound `fn() -> impl T {foo}: T` is not satisfied\n   --> $DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:17:9\n    |\n+LL | fn foo() -> impl T<O=()> { S }\n+   |    --- consider calling this function\n+LL | \n LL | fn bar(f: impl T<O=()>) {}\n    |    ---         ------- required by this bound in `bar`\n ...\n@@ -10,6 +13,20 @@ LL |     bar(foo);\n    |         the trait `T` is not implemented for `fn() -> impl T {foo}`\n    |         help: use parentheses to call the function: `foo()`\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `[closure@$DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:18:19: 18:23]: T` is not satisfied\n+  --> $DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:19:9\n+   |\n+LL | fn bar(f: impl T<O=()>) {}\n+   |    ---         ------- required by this bound in `bar`\n+...\n+LL |     let closure = || S;\n+   |                   -- consider calling this closure\n+LL |     bar(closure);\n+   |         ^^^^^^^\n+   |         |\n+   |         the trait `T` is not implemented for `[closure@$DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:18:19: 18:23]`\n+   |         help: use parentheses to call the closure: `closure()`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}]}