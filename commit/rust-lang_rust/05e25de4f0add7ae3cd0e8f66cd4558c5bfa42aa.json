{"sha": "05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZTI1ZGU0ZjBhZGQ3YWUzY2QwZThmNjZjZDQ1NThjNWJmYTQyYWE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-08T12:16:12Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-11T11:34:48Z"}, "message": "[breaking-change] don't glob export ast::BinOp_", "tree": {"sha": "587130bb0d9d974e579d5a92a4893412351069fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/587130bb0d9d974e579d5a92a4893412351069fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "html_url": "https://github.com/rust-lang/rust/commit/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f875f4c4c24e8a14c04bbe4eedd230c4aa3c1431", "url": "https://api.github.com/repos/rust-lang/rust/commits/f875f4c4c24e8a14c04bbe4eedd230c4aa3c1431", "html_url": "https://github.com/rust-lang/rust/commit/f875f4c4c24e8a14c04bbe4eedd230c4aa3c1431"}], "stats": {"total": 328, "additions": 164, "deletions": 164}, "files": [{"sha": "662eaf136c266f4fbc0adf7512e0d0abf0462fe9", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -885,24 +885,24 @@ pub fn lower_unop(_lctx: &LoweringContext, u: UnOp) -> hir::UnOp {\n pub fn lower_binop(_lctx: &LoweringContext, b: BinOp) -> hir::BinOp {\n     Spanned {\n         node: match b.node {\n-            BiAdd => hir::BiAdd,\n-            BiSub => hir::BiSub,\n-            BiMul => hir::BiMul,\n-            BiDiv => hir::BiDiv,\n-            BiRem => hir::BiRem,\n-            BiAnd => hir::BiAnd,\n-            BiOr => hir::BiOr,\n-            BiBitXor => hir::BiBitXor,\n-            BiBitAnd => hir::BiBitAnd,\n-            BiBitOr => hir::BiBitOr,\n-            BiShl => hir::BiShl,\n-            BiShr => hir::BiShr,\n-            BiEq => hir::BiEq,\n-            BiLt => hir::BiLt,\n-            BiLe => hir::BiLe,\n-            BiNe => hir::BiNe,\n-            BiGe => hir::BiGe,\n-            BiGt => hir::BiGt,\n+            BinOpKind::Add => hir::BiAdd,\n+            BinOpKind::Sub => hir::BiSub,\n+            BinOpKind::Mul => hir::BiMul,\n+            BinOpKind::Div => hir::BiDiv,\n+            BinOpKind::Rem => hir::BiRem,\n+            BinOpKind::And => hir::BiAnd,\n+            BinOpKind::Or => hir::BiOr,\n+            BinOpKind::BitXor => hir::BiBitXor,\n+            BinOpKind::BitAnd => hir::BiBitAnd,\n+            BinOpKind::BitOr => hir::BiBitOr,\n+            BinOpKind::Shl => hir::BiShl,\n+            BinOpKind::Shr => hir::BiShr,\n+            BinOpKind::Eq => hir::BiEq,\n+            BinOpKind::Lt => hir::BiLt,\n+            BinOpKind::Le => hir::BiLe,\n+            BinOpKind::Ne => hir::BiNe,\n+            BinOpKind::Ge => hir::BiGe,\n+            BinOpKind::Gt => hir::BiGt,\n         },\n         span: b.span,\n     }"}, {"sha": "be6d65a01b50e69f07ce9e17cab1e09c705188b3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -10,7 +10,6 @@\n \n // The Rust abstract syntax tree.\n \n-pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::Decl_::*;\n@@ -627,97 +626,99 @@ pub enum Mutability {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum BinOp_ {\n+pub enum BinOpKind {\n     /// The `+` operator (addition)\n-    BiAdd,\n+    Add,\n     /// The `-` operator (subtraction)\n-    BiSub,\n+    Sub,\n     /// The `*` operator (multiplication)\n-    BiMul,\n+    Mul,\n     /// The `/` operator (division)\n-    BiDiv,\n+    Div,\n     /// The `%` operator (modulus)\n-    BiRem,\n+    Rem,\n     /// The `&&` operator (logical and)\n-    BiAnd,\n+    And,\n     /// The `||` operator (logical or)\n-    BiOr,\n+    Or,\n     /// The `^` operator (bitwise xor)\n-    BiBitXor,\n+    BitXor,\n     /// The `&` operator (bitwise and)\n-    BiBitAnd,\n+    BitAnd,\n     /// The `|` operator (bitwise or)\n-    BiBitOr,\n+    BitOr,\n     /// The `<<` operator (shift left)\n-    BiShl,\n+    Shl,\n     /// The `>>` operator (shift right)\n-    BiShr,\n+    Shr,\n     /// The `==` operator (equality)\n-    BiEq,\n+    Eq,\n     /// The `<` operator (less than)\n-    BiLt,\n+    Lt,\n     /// The `<=` operator (less than or equal to)\n-    BiLe,\n+    Le,\n     /// The `!=` operator (not equal to)\n-    BiNe,\n+    Ne,\n     /// The `>=` operator (greater than or equal to)\n-    BiGe,\n+    Ge,\n     /// The `>` operator (greater than)\n-    BiGt,\n+    Gt,\n }\n \n-impl BinOp_ {\n+impl BinOpKind {\n     pub fn to_string(&self) -> &'static str {\n+        use self::BinOpKind::*;\n         match *self {\n-            BiAdd => \"+\",\n-            BiSub => \"-\",\n-            BiMul => \"*\",\n-            BiDiv => \"/\",\n-            BiRem => \"%\",\n-            BiAnd => \"&&\",\n-            BiOr => \"||\",\n-            BiBitXor => \"^\",\n-            BiBitAnd => \"&\",\n-            BiBitOr => \"|\",\n-            BiShl => \"<<\",\n-            BiShr => \">>\",\n-            BiEq => \"==\",\n-            BiLt => \"<\",\n-            BiLe => \"<=\",\n-            BiNe => \"!=\",\n-            BiGe => \">=\",\n-            BiGt => \">\"\n+            Add => \"+\",\n+            Sub => \"-\",\n+            Mul => \"*\",\n+            Div => \"/\",\n+            Rem => \"%\",\n+            And => \"&&\",\n+            Or => \"||\",\n+            BitXor => \"^\",\n+            BitAnd => \"&\",\n+            BitOr => \"|\",\n+            Shl => \"<<\",\n+            Shr => \">>\",\n+            Eq => \"==\",\n+            Lt => \"<\",\n+            Le => \"<=\",\n+            Ne => \"!=\",\n+            Ge => \">=\",\n+            Gt => \">\",\n         }\n     }\n     pub fn lazy(&self) -> bool {\n         match *self {\n-            BiAnd | BiOr => true,\n+            BinOpKind::And | BinOpKind::Or => true,\n             _ => false\n         }\n     }\n \n     pub fn is_shift(&self) -> bool {\n         match *self {\n-            BiShl | BiShr => true,\n+            BinOpKind::Shl | BinOpKind::Shr => true,\n             _ => false\n         }\n     }\n     pub fn is_comparison(&self) -> bool {\n+        use self::BinOpKind::*;\n         match *self {\n-            BiEq | BiLt | BiLe | BiNe | BiGt | BiGe =>\n+            Eq | Lt | Le | Ne | Gt | Ge =>\n             true,\n-            BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem |\n-            BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr =>\n+            And | Or | Add | Sub | Mul | Div | Rem |\n+            BitXor | BitAnd | BitOr | Shl | Shr =>\n             false,\n         }\n     }\n     /// Returns `true` if the binary operator takes its arguments by value\n     pub fn is_by_value(&self) -> bool {\n-        !BinOp_::is_comparison(self)\n+        !self.is_comparison()\n     }\n }\n \n-pub type BinOp = Spanned<BinOp_>;\n+pub type BinOp = Spanned<BinOpKind>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnOp {"}, {"sha": "a5f6454cb386fed60fa97c7dd47f630f0c8c68c8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -116,7 +116,7 @@ pub trait AstBuilder {\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n-    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;\n@@ -605,7 +605,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n-    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprBinary(Spanned { node: op, span: sp }, lhs, rhs))\n     }"}, {"sha": "d6d0a35f2ce4499d961f640204069597274d7b6b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -13,13 +13,13 @@ pub use self::PathParsingMode::*;\n use abi;\n use ast::BareFnTy;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{Public, Unsafety, UnOp};\n-use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindingMode};\n-use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, Block};\n+use ast::{Public, Unsafety};\n+use ast::{Mod, Arg, Arm, Attribute, BindingMode};\n+use ast::Block;\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n use ast::{Constness, ConstTraitItem, Crate, CrateConfig};\n use ast::{Decl, DeclItem, DeclLocal, DefaultBlock, DefaultReturn};\n-use ast::{BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n+use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast, ExprInPlace};\n@@ -38,14 +38,14 @@ use ast::{LitBool, LitChar, LitByte, LitByteStr};\n use ast::{LitStr, LitInt, Local};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_};\n-use ast::{MutTy, BiMul, Mutability};\n+use ast::{MutTy, Mutability};\n use ast::{NamedField, NoReturn};\n use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatQPath, PatMac, PatRange};\n use ast::{PatRegion, PatStruct, PatTup, PatVec, PatWild};\n use ast::{PolyTraitRef, QSelf};\n-use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n+use ast::{Return, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, VariantData, StructField};\n-use ast::{BiSub, StrStyle};\n+use ast::StrStyle;\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{Ty, Ty_, TypeBinding, TyMac};\n@@ -57,6 +57,7 @@ use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n+use ast::{BinOpKind, UnOp};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n@@ -2925,16 +2926,16 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(lhs_span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n-                        token::Plus =>    BiAdd,\n-                        token::Minus =>   BiSub,\n-                        token::Star =>    BiMul,\n-                        token::Slash =>   BiDiv,\n-                        token::Percent => BiRem,\n-                        token::Caret =>   BiBitXor,\n-                        token::And =>     BiBitAnd,\n-                        token::Or =>      BiBitOr,\n-                        token::Shl =>     BiShl,\n-                        token::Shr =>     BiShr\n+                        token::Plus =>    BinOpKind::Add,\n+                        token::Minus =>   BinOpKind::Sub,\n+                        token::Star =>    BinOpKind::Mul,\n+                        token::Slash =>   BinOpKind::Div,\n+                        token::Percent => BinOpKind::Rem,\n+                        token::Caret =>   BinOpKind::BitXor,\n+                        token::And =>     BinOpKind::BitAnd,\n+                        token::Or =>      BinOpKind::BitOr,\n+                        token::Shl =>     BinOpKind::Shl,\n+                        token::Shr =>     BinOpKind::Shr,\n                     };\n                     let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n@@ -2961,7 +2962,7 @@ impl<'a> Parser<'a> {\n                 let op_span = mk_sp(op.span.lo, self.span.hi);\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n-                if op.node == BiLt && *outer_op == AssocOp::Greater {\n+                if op.node == BinOpKind::Lt && *outer_op == AssocOp::Greater {\n                     err.fileline_help(op_span,\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }"}, {"sha": "7d1b78b632f65eb3f477d7ec29656bc3a43b1830", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -15,7 +15,7 @@ pub use self::IdentStyle::*;\n pub use self::Lit::*;\n pub use self::Token::*;\n \n-use ast;\n+use ast::{self, BinOpKind};\n use ext::mtwt;\n use ptr::P;\n use util::interner::{RcStr, StrInterner};\n@@ -264,26 +264,26 @@ impl Token {\n     }\n \n     /// Maps a token to its corresponding binary operator.\n-    pub fn to_binop(&self) -> Option<ast::BinOp_> {\n+    pub fn to_binop(&self) -> Option<BinOpKind> {\n         match *self {\n-            BinOp(Star)     => Some(ast::BiMul),\n-            BinOp(Slash)    => Some(ast::BiDiv),\n-            BinOp(Percent)  => Some(ast::BiRem),\n-            BinOp(Plus)     => Some(ast::BiAdd),\n-            BinOp(Minus)    => Some(ast::BiSub),\n-            BinOp(Shl)      => Some(ast::BiShl),\n-            BinOp(Shr)      => Some(ast::BiShr),\n-            BinOp(And)      => Some(ast::BiBitAnd),\n-            BinOp(Caret)    => Some(ast::BiBitXor),\n-            BinOp(Or)       => Some(ast::BiBitOr),\n-            Lt              => Some(ast::BiLt),\n-            Le              => Some(ast::BiLe),\n-            Ge              => Some(ast::BiGe),\n-            Gt              => Some(ast::BiGt),\n-            EqEq            => Some(ast::BiEq),\n-            Ne              => Some(ast::BiNe),\n-            AndAnd          => Some(ast::BiAnd),\n-            OrOr            => Some(ast::BiOr),\n+            BinOp(Star)     => Some(BinOpKind::Mul),\n+            BinOp(Slash)    => Some(BinOpKind::Div),\n+            BinOp(Percent)  => Some(BinOpKind::Rem),\n+            BinOp(Plus)     => Some(BinOpKind::Add),\n+            BinOp(Minus)    => Some(BinOpKind::Sub),\n+            BinOp(Shl)      => Some(BinOpKind::Shl),\n+            BinOp(Shr)      => Some(BinOpKind::Shr),\n+            BinOp(And)      => Some(BinOpKind::BitAnd),\n+            BinOp(Caret)    => Some(BinOpKind::BitXor),\n+            BinOp(Or)       => Some(BinOpKind::BitOr),\n+            Lt              => Some(BinOpKind::Lt),\n+            Le              => Some(BinOpKind::Le),\n+            Ge              => Some(BinOpKind::Ge),\n+            Gt              => Some(BinOpKind::Gt),\n+            EqEq            => Some(BinOpKind::Eq),\n+            Ne              => Some(BinOpKind::Ne),\n+            AndAnd          => Some(BinOpKind::And),\n+            OrOr            => Some(BinOpKind::Or),\n             _               => None,\n         }\n     }"}, {"sha": "6fb81bb6a768421d89397ac8d652125619f5ba27", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use parse::token::{Token, BinOpToken, keywords};\n-use ast;\n+use ast::BinOpKind;\n \n /// Associative operator with precedence.\n ///\n@@ -108,28 +108,28 @@ impl AssocOp {\n         }\n     }\n \n-    /// Create a new AssocOp from ast::BinOp_.\n-    pub fn from_ast_binop(op: ast::BinOp_) -> Self {\n+    /// Create a new AssocOp from ast::BinOpKind.\n+    pub fn from_ast_binop(op: BinOpKind) -> Self {\n         use self::AssocOp::*;\n         match op {\n-            ast::BiLt => Less,\n-            ast::BiGt => Greater,\n-            ast::BiLe => LessEqual,\n-            ast::BiGe => GreaterEqual,\n-            ast::BiEq => Equal,\n-            ast::BiNe => NotEqual,\n-            ast::BiMul => Multiply,\n-            ast::BiDiv => Divide,\n-            ast::BiRem => Modulus,\n-            ast::BiAdd => Add,\n-            ast::BiSub => Subtract,\n-            ast::BiShl => ShiftLeft,\n-            ast::BiShr => ShiftRight,\n-            ast::BiBitAnd => BitAnd,\n-            ast::BiBitXor => BitXor,\n-            ast::BiBitOr => BitOr,\n-            ast::BiAnd => LAnd,\n-            ast::BiOr => LOr\n+            BinOpKind::Lt => Less,\n+            BinOpKind::Gt => Greater,\n+            BinOpKind::Le => LessEqual,\n+            BinOpKind::Ge => GreaterEqual,\n+            BinOpKind::Eq => Equal,\n+            BinOpKind::Ne => NotEqual,\n+            BinOpKind::Mul => Multiply,\n+            BinOpKind::Div => Divide,\n+            BinOpKind::Rem => Modulus,\n+            BinOpKind::Add => Add,\n+            BinOpKind::Sub => Subtract,\n+            BinOpKind::Shl => ShiftLeft,\n+            BinOpKind::Shr => ShiftRight,\n+            BinOpKind::BitAnd => BitAnd,\n+            BinOpKind::BitXor => BitXor,\n+            BinOpKind::BitOr => BitOr,\n+            BinOpKind::And => LAnd,\n+            BinOpKind::Or => LOr\n         }\n     }\n \n@@ -185,27 +185,27 @@ impl AssocOp {\n         }\n     }\n \n-    pub fn to_ast_binop(&self) -> Option<ast::BinOp_> {\n+    pub fn to_ast_binop(&self) -> Option<BinOpKind> {\n         use self::AssocOp::*;\n         match *self {\n-            Less => Some(ast::BiLt),\n-            Greater => Some(ast::BiGt),\n-            LessEqual => Some(ast::BiLe),\n-            GreaterEqual => Some(ast::BiGe),\n-            Equal => Some(ast::BiEq),\n-            NotEqual => Some(ast::BiNe),\n-            Multiply => Some(ast::BiMul),\n-            Divide => Some(ast::BiDiv),\n-            Modulus => Some(ast::BiRem),\n-            Add => Some(ast::BiAdd),\n-            Subtract => Some(ast::BiSub),\n-            ShiftLeft => Some(ast::BiShl),\n-            ShiftRight => Some(ast::BiShr),\n-            BitAnd => Some(ast::BiBitAnd),\n-            BitXor => Some(ast::BiBitXor),\n-            BitOr => Some(ast::BiBitOr),\n-            LAnd => Some(ast::BiAnd),\n-            LOr => Some(ast::BiOr),\n+            Less => Some(BinOpKind::Lt),\n+            Greater => Some(BinOpKind::Gt),\n+            LessEqual => Some(BinOpKind::Le),\n+            GreaterEqual => Some(BinOpKind::Ge),\n+            Equal => Some(BinOpKind::Eq),\n+            NotEqual => Some(BinOpKind::Ne),\n+            Multiply => Some(BinOpKind::Mul),\n+            Divide => Some(BinOpKind::Div),\n+            Modulus => Some(BinOpKind::Rem),\n+            Add => Some(BinOpKind::Add),\n+            Subtract => Some(BinOpKind::Sub),\n+            ShiftLeft => Some(BinOpKind::Shl),\n+            ShiftRight => Some(BinOpKind::Shr),\n+            BitAnd => Some(BinOpKind::BitAnd),\n+            BitXor => Some(BinOpKind::BitXor),\n+            BitOr => Some(BinOpKind::BitOr),\n+            LAnd => Some(BinOpKind::And),\n+            LOr => Some(BinOpKind::Or),\n             Inplace | Assign | AssignOp(_) | As | DotDot | Colon => None\n         }\n     }"}, {"sha": "2fa847ee430d8746408e7e64ca3bb4ae39fdca68", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -11,8 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast;\n-use syntax::ast::{MetaItem, Expr};\n+use syntax::ast::{MetaItem, Expr, BinOpKind, self};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -116,7 +115,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n \n             let assign = cx.stmt_let(span, false, test_id, new);\n \n-            let cond = cx.expr_binary(span, ast::BiEq,\n+            let cond = cx.expr_binary(span, BinOpKind::Eq,\n                                       cx.expr_ident(span, test_id),\n                                       cx.expr_path(equals_path.clone()));\n             let if_ = cx.expr_if(span,"}, {"sha": "0150a073b07d0bdf816f90ce0be0770a9d41b0b5", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, self};\n+use syntax::ast::{MetaItem, Expr, BinOpKind};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -35,9 +35,9 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n \n-                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n+                let eq = cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone());\n \n-                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n+                cx.expr_binary(span, BinOpKind::And, subexpr, eq)\n             },\n             cx.expr_bool(span, true),\n             Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n@@ -52,9 +52,9 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n \n-                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n+                let eq = cx.expr_binary(span, BinOpKind::Ne, self_f, other_f.clone());\n \n-                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n+                cx.expr_binary(span, BinOpKind::Or, subexpr, eq)\n             },\n             cx.expr_bool(span, false),\n             Box::new(|cx, span, _, _| cx.expr_bool(span, true)),"}, {"sha": "e857f7d52f912af544ad254f2ca207b512c55ab5", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -13,8 +13,7 @@ pub use self::OrderingOp::*;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast;\n-use syntax::ast::{MetaItem, Expr};\n+use syntax::ast::{MetaItem, Expr, BinOpKind, self};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -161,7 +160,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n \n             let assign = cx.stmt_let(span, false, test_id, new);\n \n-            let cond = cx.expr_binary(span, ast::BiEq,\n+            let cond = cx.expr_binary(span, BinOpKind::Eq,\n                                       cx.expr_ident(span, test_id),\n                                       equals_expr.clone());\n             let if_ = cx.expr_if(span,\n@@ -183,7 +182,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n /// Strict inequality.\n fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n          span: Span, substr: &Substructure) -> P<Expr> {\n-    let op = if less {ast::BiLt} else {ast::BiGt};\n+    let op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n     cs_fold(\n         false, // need foldr,\n         |cx, span, subexpr, self_f, other_fs| {\n@@ -214,8 +213,8 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n             let not_cmp = cx.expr_unary(span, ast::UnOp::Not,\n                                         cx.expr_binary(span, op, other_f.clone(), self_f));\n \n-            let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n-            cx.expr_binary(span, ast::BiOr, cmp, and)\n+            let and = cx.expr_binary(span, BinOpKind::And, not_cmp, subexpr);\n+            cx.expr_binary(span, BinOpKind::Or, cmp, and)\n         },\n         cx.expr_bool(span, equal),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {"}, {"sha": "9eb516cd07a27df46181af9dad56a99a31170d03", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -194,8 +194,7 @@ use std::vec;\n \n use syntax::abi::Abi;\n use syntax::abi;\n-use syntax::ast;\n-use syntax::ast::{EnumDef, Expr, Ident, Generics, VariantData};\n+use syntax::ast::{EnumDef, Expr, Ident, Generics, VariantData, BinOpKind, self};\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -1279,8 +1278,9 @@ impl<'a> MethodDef<'a> {\n                     Some(first) => {\n                         let first_expr = cx.expr_ident(sp, first);\n                         let id = cx.expr_ident(sp, ident);\n-                        let test = cx.expr_binary(sp, ast::BiEq, first_expr, id);\n-                        discriminant_test = cx.expr_binary(sp, ast::BiAnd, discriminant_test, test)\n+                        let test = cx.expr_binary(sp, BinOpKind::Eq, first_expr, id);\n+                        discriminant_test = cx.expr_binary(sp, BinOpKind::And,\n+                                                           discriminant_test, test)\n                     }\n                     None => {\n                         first_ident = Some(ident);"}, {"sha": "5f0ef4de491e0c5a5a2b89dc91b4524e05611da1", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -62,7 +62,7 @@ fn expand(cx: &mut ExtCtxt,\n                     let zero = cx.expr_isize(span, 0);\n                     cs_fold(false,\n                             |cx, span, subexpr, field, _| {\n-                                cx.expr_binary(span, ast::BiAdd, subexpr,\n+                                cx.expr_binary(span, ast::BinOpKind::Add, subexpr,\n                                     cx.expr_method_call(span, field,\n                                         token::str_to_ident(\"total_sum\"), vec![]))\n                             },"}, {"sha": "ba216289fd4c012c1e72e4ccebade88f22817bcd", "filename": "src/test/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa", "patch": "@@ -81,7 +81,7 @@ fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n         if item.attrs.iter().find(|a| a.check_name(\"ignore\")).is_some() {\n             acc\n         } else {\n-            cx.expr_binary(item.span, ast::BiAdd, acc,\n+            cx.expr_binary(item.span, ast::BinOpKind::Add, acc,\n                            cx.expr_method_call(item.span,\n                                                item.self_.clone(),\n                                                substr.method_ident,"}]}