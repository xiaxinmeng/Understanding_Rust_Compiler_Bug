{"sha": "1eaadebb3dee31669c7649b32747381d11614fae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYWFkZWJiM2RlZTMxNjY5Yzc2NDliMzI3NDczODFkMTE2MTRmYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-21T20:23:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-21T20:23:26Z"}, "message": "Auto merge of #78077 - petrochenkov:qvis, r=davidtwco\n\nCalculate visibilities once in resolve\n\nThen use them through a query based on resolver outputs.\n\nItem visibilities were previously calculated in three places - initially in `rustc_resolve`, then in `rustc_privacy` during type privacy checkin, and then in `rustc_metadata` during metadata encoding.\nThe visibility logic is not entirely trivial, especially for things like constructors or enum variants, and all of it was duplicated.\n\nThis PR deduplicates all the visibility calculations, visibilities are determined once during early name resolution and then stored in `ResolverOutputs` and are later available through `tcx` as a query `tcx.visibility(def_id)`.\n(This query existed previously, but only worked for other crates.)\n\nSome special cases (e.g. visibilities for closure types, which are needed for type privacy checking) are not processed in resolve, but deferred and performed directly in the query instead.", "tree": {"sha": "bae167a7740a9ca9f397f56b025bae5ea9c82655", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae167a7740a9ca9f397f56b025bae5ea9c82655"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eaadebb3dee31669c7649b32747381d11614fae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eaadebb3dee31669c7649b32747381d11614fae", "html_url": "https://github.com/rust-lang/rust/commit/1eaadebb3dee31669c7649b32747381d11614fae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eaadebb3dee31669c7649b32747381d11614fae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d2726726f8f3128e98191e4c6cb94bd76d0ddd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2726726f8f3128e98191e4c6cb94bd76d0ddd4", "html_url": "https://github.com/rust-lang/rust/commit/1d2726726f8f3128e98191e4c6cb94bd76d0ddd4"}, {"sha": "cee5521a03e81e75516a90c1a616c97545d8e07a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cee5521a03e81e75516a90c1a616c97545d8e07a", "html_url": "https://github.com/rust-lang/rust/commit/cee5521a03e81e75516a90c1a616c97545d8e07a"}], "stats": {"total": 730, "additions": 322, "deletions": 408}, "files": [{"sha": "65b96da95e9725204a4c277a8897d32cc82751a7", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2381,15 +2381,6 @@ impl VisibilityKind<'_> {\n             VisibilityKind::Crate(..) | VisibilityKind::Restricted { .. } => true,\n         }\n     }\n-\n-    pub fn descr(&self) -> &'static str {\n-        match *self {\n-            VisibilityKind::Public => \"public\",\n-            VisibilityKind::Inherited => \"private\",\n-            VisibilityKind::Crate(..) => \"crate-visible\",\n-            VisibilityKind::Restricted { .. } => \"restricted\",\n-        }\n-    }\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "7e33a479228bac820441c093e9a70b480a8906fc", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -28,7 +28,6 @@ use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_span::hygiene::{ExpnDataEncodeMode, HygieneEncodeContext};\n-use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n use rustc_target::abi::VariantIdx;\n@@ -436,8 +435,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        let vis = Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Public };\n-        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs, &vis);\n+        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -739,12 +737,8 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        let enum_id = tcx.hir().local_def_id_to_hir_id(def.did.expect_local());\n-        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <-\n-            ty::Visibility::from_hir(enum_vis, enum_id, self.tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n@@ -785,17 +779,8 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        // Variant constructors have the same visibility as the parent enums, unless marked as\n-        // non-exhaustive, in which case they are lowered to `pub(crate)`.\n-        let enum_id = tcx.hir().local_def_id_to_hir_id(def.did.expect_local());\n-        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n-        let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n-        if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n-            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-        }\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -811,13 +796,7 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_promoted_mir(def_id.expect_local());\n     }\n \n-    fn encode_info_for_mod(\n-        &mut self,\n-        id: hir::HirId,\n-        md: &hir::Mod<'_>,\n-        attrs: &[ast::Attribute],\n-        vis: &hir::Visibility<'_>,\n-    ) {\n+    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n         let tcx = self.tcx;\n         let local_def_id = tcx.hir().local_def_id(id);\n         let def_id = local_def_id.to_def_id();\n@@ -850,7 +829,7 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- attrs);\n         if self.is_proc_macro {\n@@ -881,7 +860,7 @@ impl EncodeContext<'a, 'tcx> {\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n-        record!(self.tables.visibility[def_id] <- field.vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n@@ -906,25 +885,8 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        let struct_id = tcx.hir().local_def_id_to_hir_id(adt_def.did.expect_local());\n-        let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n-        let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n-        for field in &variant.fields {\n-            if ctor_vis.is_at_least(field.vis, tcx) {\n-                ctor_vis = field.vis;\n-            }\n-        }\n-\n-        // If the structure is marked as non_exhaustive then lower the visibility\n-        // to within the crate.\n-        if adt_def.non_enum_variant().is_field_list_non_exhaustive()\n-            && ctor_vis == ty::Visibility::Public\n-        {\n-            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-        }\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n-        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n         self.encode_stability(def_id);\n@@ -1030,7 +992,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::AssocType(container)\n             }\n         });\n-        record!(self.tables.visibility[def_id] <- trait_item.vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- ast_item.span);\n         record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, ast_item.ident);\n@@ -1112,7 +1074,7 @@ impl EncodeContext<'a, 'tcx> {\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         });\n-        record!(self.tables.visibility[def_id] <- impl_item.vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- ast_item.span);\n         record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, impl_item.ident);\n@@ -1261,7 +1223,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.hir_id, m, &item.attrs, &item.vis);\n+                return self.encode_info_for_mod(item.hir_id, m, &item.attrs);\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1352,8 +1314,7 @@ impl EncodeContext<'a, 'tcx> {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         });\n-        record!(self.tables.visibility[def_id] <-\n-            ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- item.attrs);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n@@ -1470,7 +1431,7 @@ impl EncodeContext<'a, 'tcx> {\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- macro_def.span);\n         record!(self.tables.attributes[def_id] <- macro_def.attrs);\n         self.encode_ident_span(def_id, macro_def.ident);\n@@ -1480,7 +1441,6 @@ impl EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n         record!(self.tables.kind[def_id] <- kind);\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         if encode_type {\n             self.encode_item_type(def_id);\n@@ -1505,7 +1465,6 @@ impl EncodeContext<'a, 'tcx> {\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n-        record!(self.tables.visibility[def_id.to_def_id()] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id.to_def_id()] <- &self.tcx.get_attrs(def_id.to_def_id())[..]);\n         self.encode_item_type(def_id.to_def_id());\n@@ -1525,7 +1484,6 @@ impl EncodeContext<'a, 'tcx> {\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst(qualifs, const_data));\n-        record!(self.tables.visibility[def_id.to_def_id()] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id.to_def_id());\n         self.encode_generics(def_id.to_def_id());\n@@ -1762,8 +1720,7 @@ impl EncodeContext<'a, 'tcx> {\n             hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n-        record!(self.tables.visibility[def_id] <-\n-            ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- nitem.span);\n         record!(self.tables.attributes[def_id] <- nitem.attrs);\n         self.encode_ident_span(def_id, nitem.ident);"}, {"sha": "1a206b245d37b26fab5de503b501b56c51bebea6", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -256,24 +256,12 @@ pub enum EvalResult {\n }\n \n // See issue #38412.\n-fn skip_stability_check_due_to_privacy(tcx: TyCtxt<'_>, mut def_id: DefId) -> bool {\n-    // Check if `def_id` is a trait method.\n-    match tcx.def_kind(def_id) {\n-        DefKind::AssocFn | DefKind::AssocTy | DefKind::AssocConst => {\n-            if let ty::TraitContainer(trait_def_id) = tcx.associated_item(def_id).container {\n-                // Trait methods do not declare visibility (even\n-                // for visibility info in cstore). Use containing\n-                // trait instead, so methods of `pub` traits are\n-                // themselves considered `pub`.\n-                def_id = trait_def_id;\n-            }\n-        }\n-        _ => {}\n+fn skip_stability_check_due_to_privacy(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    if tcx.def_kind(def_id) == DefKind::TyParam {\n+        // Have no visibility, considered public for the purpose of this check.\n+        return false;\n     }\n-\n-    let visibility = tcx.visibility(def_id);\n-\n-    match visibility {\n+    match tcx.visibility(def_id) {\n         // Must check stability for `pub` items.\n         ty::Visibility::Public => false,\n "}, {"sha": "89faa97d50fca9be3d48cd8b7b3e67cb0d5b2c74", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -1267,6 +1267,7 @@ rustc_queries! {\n \n     TypeChecking {\n         query visibility(def_id: DefId) -> ty::Visibility {\n+            eval_always\n             desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         }\n     }"}, {"sha": "e8dd1ff4300c829e15f0c4a27029ca824773b3cb", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -22,7 +22,7 @@ use crate::ty::{\n     ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntVar,\n     IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n     ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n-    TyVid, TypeAndMut,\n+    TyVid, TypeAndMut, Visibility,\n };\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -911,6 +911,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n+    /// Visibilities produced by resolver.\n+    pub visibilities: FxHashMap<LocalDefId, Visibility>,\n+\n     /// Resolutions of `extern crate` items produced by resolver.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n \n@@ -1124,6 +1127,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n+            visibilities: resolutions.visibilities,\n             extern_crate_map: resolutions.extern_crate_map,\n             trait_map,\n             export_map: resolutions.export_map,"}, {"sha": "845fa8a47ae2caee3c05d322ca4bc31b772fc35e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -125,6 +125,7 @@ mod sty;\n pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n+    pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,"}, {"sha": "851e0dfbe0d45dbeb0a1b43931fb7975cc8c769c", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 81, "deletions": 138, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n use rustc_attr as attr;\n@@ -14,13 +15,14 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::fold::TypeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n use std::marker::PhantomData;\n@@ -233,125 +235,6 @@ where\n     }\n }\n \n-fn def_id_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> (ty::Visibility, Span, &'static str) {\n-    match def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id)) {\n-        Some(hir_id) => {\n-            let vis = match tcx.hir().get(hir_id) {\n-                Node::Item(item) => &item.vis,\n-                Node::ForeignItem(foreign_item) => &foreign_item.vis,\n-                Node::MacroDef(macro_def) => {\n-                    if tcx.sess.contains_name(&macro_def.attrs, sym::macro_export) {\n-                        return (ty::Visibility::Public, macro_def.span, \"public\");\n-                    } else {\n-                        &macro_def.vis\n-                    }\n-                }\n-                Node::TraitItem(..) | Node::Variant(..) => {\n-                    return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id).to_def_id());\n-                }\n-                Node::ImplItem(impl_item) => {\n-                    match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n-                        Node::Item(item) => match &item.kind {\n-                            hir::ItemKind::Impl { of_trait: None, .. } => &impl_item.vis,\n-                            hir::ItemKind::Impl { of_trait: Some(trait_ref), .. } => {\n-                                return def_id_visibility(tcx, trait_ref.path.res.def_id());\n-                            }\n-                            kind => bug!(\"unexpected item kind: {:?}\", kind),\n-                        },\n-                        node => bug!(\"unexpected node kind: {:?}\", node),\n-                    }\n-                }\n-                Node::Ctor(vdata) => {\n-                    let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n-                    match tcx.hir().get(parent_hir_id) {\n-                        Node::Variant(..) => {\n-                            let parent_did = tcx.hir().local_def_id(parent_hir_id);\n-                            let (mut ctor_vis, mut span, mut descr) =\n-                                def_id_visibility(tcx, parent_did.to_def_id());\n-\n-                            let adt_def = tcx.adt_def(tcx.hir().get_parent_did(hir_id).to_def_id());\n-                            let ctor_did = tcx.hir().local_def_id(vdata.ctor_hir_id().unwrap());\n-                            let variant = adt_def.variant_with_ctor_id(ctor_did.to_def_id());\n-\n-                            if variant.is_field_list_non_exhaustive()\n-                                && ctor_vis == ty::Visibility::Public\n-                            {\n-                                ctor_vis =\n-                                    ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                let attrs = tcx.get_attrs(variant.def_id);\n-                                span = tcx\n-                                    .sess\n-                                    .find_by_name(&attrs, sym::non_exhaustive)\n-                                    .unwrap()\n-                                    .span;\n-                                descr = \"crate-visible\";\n-                            }\n-\n-                            return (ctor_vis, span, descr);\n-                        }\n-                        Node::Item(..) => {\n-                            let item = match tcx.hir().get(parent_hir_id) {\n-                                Node::Item(item) => item,\n-                                node => bug!(\"unexpected node kind: {:?}\", node),\n-                            };\n-                            let (mut ctor_vis, mut span, mut descr) = (\n-                                ty::Visibility::from_hir(&item.vis, parent_hir_id, tcx),\n-                                item.vis.span,\n-                                item.vis.node.descr(),\n-                            );\n-                            for field in vdata.fields() {\n-                                let field_vis = ty::Visibility::from_hir(&field.vis, hir_id, tcx);\n-                                if ctor_vis.is_at_least(field_vis, tcx) {\n-                                    ctor_vis = field_vis;\n-                                    span = field.vis.span;\n-                                    descr = field.vis.node.descr();\n-                                }\n-                            }\n-\n-                            // If the structure is marked as non_exhaustive then lower the\n-                            // visibility to within the crate.\n-                            if ctor_vis == ty::Visibility::Public {\n-                                let adt_def =\n-                                    tcx.adt_def(tcx.hir().get_parent_did(hir_id).to_def_id());\n-                                if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n-                                    ctor_vis =\n-                                        ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                    span = tcx\n-                                        .sess\n-                                        .find_by_name(&item.attrs, sym::non_exhaustive)\n-                                        .unwrap()\n-                                        .span;\n-                                    descr = \"crate-visible\";\n-                                }\n-                            }\n-\n-                            return (ctor_vis, span, descr);\n-                        }\n-                        node => bug!(\"unexpected node kind: {:?}\", node),\n-                    }\n-                }\n-                Node::Expr(expr) => {\n-                    return (\n-                        ty::Visibility::Restricted(tcx.parent_module(expr.hir_id).to_def_id()),\n-                        expr.span,\n-                        \"private\",\n-                    );\n-                }\n-                node => bug!(\"unexpected node kind: {:?}\", node),\n-            };\n-            (ty::Visibility::from_hir(vis, hir_id, tcx), vis.span, vis.node.descr())\n-        }\n-        None => {\n-            let vis = tcx.visibility(def_id);\n-            let descr = if vis == ty::Visibility::Public { \"public\" } else { \"private\" };\n-            (vis, tcx.def_span(def_id), descr)\n-        }\n-    }\n-}\n-\n fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n@@ -424,7 +307,7 @@ trait VisibilityLike: Sized {\n impl VisibilityLike for ty::Visibility {\n     const MAX: Self = ty::Visibility::Public;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n-        min(def_id_visibility(find.tcx, def_id).0, find.min, find.tcx)\n+        min(find.tcx.visibility(def_id), find.min, find.tcx)\n     }\n }\n impl VisibilityLike for Option<AccessLevel> {\n@@ -534,17 +417,16 @@ impl EmbargoVisitor<'tcx> {\n             let hir_id = item_id.id;\n             let item_def_id = self.tcx.hir().local_def_id(hir_id);\n             let def_kind = self.tcx.def_kind(item_def_id);\n-            let item = self.tcx.hir().expect_item(hir_id);\n-            let vis = ty::Visibility::from_hir(&item.vis, hir_id, self.tcx);\n+            let vis = self.tcx.visibility(item_def_id);\n             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n                 if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n-                        let vis = def_id_visibility(self.tcx, def_id).0;\n                         if let Some(def_id) = def_id.as_local() {\n                             let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                            let vis = self.tcx.visibility(def_id.to_def_id());\n                             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n                     }\n@@ -596,7 +478,7 @@ impl EmbargoVisitor<'tcx> {\n                     {\n                         for field in struct_def.fields() {\n                             let field_vis =\n-                                ty::Visibility::from_hir(&field.vis, field.hir_id, self.tcx);\n+                                self.tcx.visibility(self.tcx.hir().local_def_id(field.hir_id));\n                             if field_vis.is_accessible_from(module, self.tcx) {\n                                 self.reach(field.hir_id, level).ty();\n                             }\n@@ -1015,11 +897,10 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.ev.tcx.hir().local_def_id_to_hir_id(def_id);\n-            if let ((ty::Visibility::Public, ..), _)\n-            | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n-                (def_id_visibility(self.tcx(), def_id.to_def_id()), self.access_level)\n+            if let (ty::Visibility::Public, _) | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n+                (self.tcx().visibility(def_id.to_def_id()), self.access_level)\n             {\n+                let hir_id = self.ev.tcx.hir().local_def_id_to_hir_id(def_id);\n                 self.ev.update(hir_id, self.access_level);\n             }\n         }\n@@ -1184,9 +1065,7 @@ impl<'tcx> TypePrivacyVisitor<'tcx> {\n     }\n \n     fn item_is_accessible(&self, did: DefId) -> bool {\n-        def_id_visibility(self.tcx, did)\n-            .0\n-            .is_accessible_from(self.current_item.to_def_id(), self.tcx)\n+        self.tcx.visibility(did).is_accessible_from(self.current_item.to_def_id(), self.tcx)\n     }\n \n     // Take node-id of an expression or pattern and check its type for privacy.\n@@ -1840,15 +1719,30 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n             None => return false,\n         };\n \n-        let (vis, vis_span, vis_descr) = def_id_visibility(self.tcx, def_id);\n+        let vis = self.tcx.visibility(def_id);\n         if !vis.is_at_least(self.required_visibility, self.tcx) {\n+            let vis_descr = match vis {\n+                ty::Visibility::Public => \"public\",\n+                ty::Visibility::Invisible => \"private\",\n+                ty::Visibility::Restricted(vis_def_id) => {\n+                    if vis_def_id == self.tcx.parent_module(hir_id).to_def_id() {\n+                        \"private\"\n+                    } else if vis_def_id.is_top_level_module() {\n+                        \"crate-private\"\n+                    } else {\n+                        \"restricted\"\n+                    }\n+                }\n+            };\n             let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n             if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n                 let mut err = if kind == \"trait\" {\n                     struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", make_msg())\n                 } else {\n                     struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", make_msg())\n                 };\n+                let vis_span =\n+                    self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n                 err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n                 err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n                 err.emit();\n@@ -1965,7 +1859,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n-        let item_visibility = ty::Visibility::from_hir(&item.vis, item.hir_id, tcx);\n+        let item_visibility = tcx.visibility(tcx.hir().local_def_id(item.hir_id).to_def_id());\n \n         match item.kind {\n             // Crates are always public.\n@@ -2019,7 +1913,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in foreign_mod.items {\n-                    let vis = ty::Visibility::from_hir(&foreign_item.vis, item.hir_id, tcx);\n+                    let vis = tcx.visibility(tcx.hir().local_def_id(foreign_item.hir_id));\n                     self.check(foreign_item.hir_id, vis).generics().predicates().ty();\n                 }\n             }\n@@ -2028,7 +1922,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.hir_id, tcx);\n+                    let field_visibility = tcx.visibility(tcx.hir().local_def_id(field.hir_id));\n                     self.check(field.hir_id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n@@ -2040,10 +1934,9 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n                 self.check(item.hir_id, impl_vis).generics().predicates();\n                 for impl_item_ref in items {\n-                    let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n                     let impl_item_vis = if of_trait.is_none() {\n                         min(\n-                            ty::Visibility::from_hir(&impl_item.vis, item.hir_id, tcx),\n+                            tcx.visibility(tcx.hir().local_def_id(impl_item_ref.id.hir_id)),\n                             impl_vis,\n                             tcx,\n                         )\n@@ -2064,13 +1957,63 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n+        visibility,\n         privacy_access_levels,\n         check_private_in_public,\n         check_mod_privacy,\n         ..*providers\n     };\n }\n \n+fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n+    let def_id = def_id.expect_local();\n+    match tcx.visibilities.get(&def_id) {\n+        Some(vis) => *vis,\n+        None => {\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+            match tcx.hir().get(hir_id) {\n+                // Unique types created for closures participate in type privacy checking.\n+                // They have visibilities inherited from the module they are defined in.\n+                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n+                    ty::Visibility::Restricted(tcx.parent_module(hir_id).to_def_id())\n+                }\n+                // - AST lowering may clone `use` items and the clones don't\n+                //   get their entries in the resolver's visibility table.\n+                // - AST lowering also creates opaque type items with inherited visibilies.\n+                //   Visibility on them should have no effect, but to avoid the visibility\n+                //   query failing on some items, we provide it for opaque types as well.\n+                Node::Item(hir::Item {\n+                    vis,\n+                    kind: hir::ItemKind::Use(..) | hir::ItemKind::OpaqueTy(..),\n+                    ..\n+                }) => ty::Visibility::from_hir(vis, hir_id, tcx),\n+                // Visibilities of trait impl items are inherited from their traits\n+                // and are not filled in resolve.\n+                Node::ImplItem(impl_item) => {\n+                    match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n+                        Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Impl { of_trait: Some(tr), .. },\n+                            ..\n+                        }) => tr.path.res.opt_def_id().map_or_else(\n+                            || {\n+                                tcx.sess.delay_span_bug(tr.path.span, \"trait without a def-id\");\n+                                ty::Visibility::Public\n+                            },\n+                            |def_id| tcx.visibility(def_id),\n+                        ),\n+                        _ => span_bug!(impl_item.span, \"the parent is not a trait impl\"),\n+                    }\n+                }\n+                _ => span_bug!(\n+                    tcx.def_span(def_id),\n+                    \"visibility table unexpectedly missing a def-id: {:?}\",\n+                    def_id,\n+                ),\n+            }\n+        }\n+    }\n+}\n+\n fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     // Check privacy of names not checked in previous compilation stages.\n     let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: None };"}, {"sha": "02e31ade41f26a96728c89e82279c9800f09eaa0", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 114, "deletions": 72, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -613,12 +613,21 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &'b Item) {\n+        if matches!(item.kind, ItemKind::Mod(..)) && item.ident.name == kw::Invalid {\n+            // Fake crate root item from expand.\n+            return;\n+        }\n+\n         let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n         let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n+        let local_def_id = self.r.local_def_id(item.id);\n+        let def_id = local_def_id.to_def_id();\n+\n+        self.r.visibilities.insert(local_def_id, vis);\n \n         match item.kind {\n             ItemKind::Use(ref use_tree) => {\n@@ -651,10 +660,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 } else if orig_name == Some(kw::SelfLower) {\n                     self.r.graph_root\n                 } else {\n-                    let def_id = self.r.local_def_id(item.id);\n-                    let crate_id =\n-                        self.r.crate_loader.process_extern_crate(item, &self.r.definitions, def_id);\n-                    self.r.extern_crate_map.insert(def_id, crate_id);\n+                    let crate_id = self.r.crate_loader.process_extern_crate(\n+                        item,\n+                        &self.r.definitions,\n+                        local_def_id,\n+                    );\n+                    self.r.extern_crate_map.insert(local_def_id, crate_id);\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n@@ -705,41 +716,32 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(parent, ident, TypeNS, imported_binding);\n             }\n \n-            ItemKind::Mod(..) if ident.name == kw::Invalid => {} // Crate root\n-\n             ItemKind::Mod(..) => {\n-                let def_id = self.r.local_def_id(item.id);\n-                let module_kind = ModuleKind::Def(DefKind::Mod, def_id.to_def_id(), ident.name);\n+                let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n                 let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n-                    ..ModuleData::new(\n-                        Some(parent),\n-                        module_kind,\n-                        def_id.to_def_id(),\n-                        expansion,\n-                        item.span,\n-                    )\n+                    ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.r.module_map.insert(def_id, module);\n+                self.r.module_map.insert(local_def_id, module);\n \n                 // Descend into the module.\n                 self.parent_scope.module = module;\n             }\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let res = Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Static, def_id);\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let res = Res::Def(DefKind::Const, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Const, def_id);\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let res = Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Fn, def_id);\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n@@ -749,13 +751,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n             // These items live in the type namespace.\n             ItemKind::TyAlias(..) => {\n-                let res = Res::Def(DefKind::TyAlias, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::TyAlias, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(_, _) => {\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n-                self.r.variant_vis.insert(def_id, vis);\n                 let module_kind = ModuleKind::Def(DefKind::Enum, def_id, ident.name);\n                 let module = self.r.new_module(\n                     parent,\n@@ -769,14 +769,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let res = Res::Def(DefKind::TraitAlias, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::TraitAlias, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref vdata, _) => {\n                 // Define a name in the type namespace.\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Struct, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -810,17 +809,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         }\n                         ret_fields.push(field_vis);\n                     }\n+                    let ctor_def_id = self.r.local_def_id(ctor_node_id);\n                     let ctor_res = Res::Def(\n                         DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(vdata)),\n-                        self.r.local_def_id(ctor_node_id).to_def_id(),\n+                        ctor_def_id.to_def_id(),\n                     );\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n+                    self.r.visibilities.insert(ctor_def_id, ctor_vis);\n+\n                     self.r.struct_constructors.insert(def_id, (ctor_res, ctor_vis, ret_fields));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Union, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -829,8 +830,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::Trait(..) => {\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n-\n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n                 let module = self.r.new_module(\n@@ -845,6 +844,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items do not add names to modules.\n+            ItemKind::Impl { of_trait: Some(..), .. } => {\n+                self.r.trait_impl_items.insert(local_def_id);\n+            }\n             ItemKind::Impl { .. } | ItemKind::ForeignMod(..) | ItemKind::GlobalAsm(..) => {}\n \n             ItemKind::MacroDef(..) | ItemKind::MacCall(_) => unreachable!(),\n@@ -853,22 +855,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n-        let (res, ns) = match item.kind {\n-            ForeignItemKind::Fn(..) => {\n-                (Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n-            }\n-            ForeignItemKind::Static(..) => {\n-                (Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n-            }\n-            ForeignItemKind::TyAlias(..) => {\n-                (Res::Def(DefKind::ForeignTy, self.r.local_def_id(item.id).to_def_id()), TypeNS)\n-            }\n+        let local_def_id = self.r.local_def_id(item.id);\n+        let def_id = local_def_id.to_def_id();\n+        let (def_kind, ns) = match item.kind {\n+            ForeignItemKind::Fn(..) => (DefKind::Fn, ValueNS),\n+            ForeignItemKind::Static(..) => (DefKind::Static, ValueNS),\n+            ForeignItemKind::TyAlias(..) => (DefKind::ForeignTy, TypeNS),\n             ForeignItemKind::MacCall(_) => unreachable!(),\n         };\n         let parent = self.parent_scope.module;\n         let expansion = self.parent_scope.expansion;\n         let vis = self.resolve_visibility(&item.vis);\n+        let res = Res::Def(def_kind, def_id);\n         self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        self.r.visibilities.insert(local_def_id, vis);\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n@@ -1205,6 +1205,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n+            self.r.visibilities.insert(def_id, vis);\n             MacroRulesScope::Binding(self.r.arenas.alloc_macro_rules_binding(MacroRulesBinding {\n                 parent_macro_rules_scope: parent_scope.macro_rules,\n                 binding,\n@@ -1224,6 +1225,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n+            self.r.visibilities.insert(def_id, vis);\n             self.parent_scope.macro_rules\n         }\n     }\n@@ -1297,36 +1299,64 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'b AssocItem, ctxt: AssocCtxt) {\n-        let parent = self.parent_scope.module;\n-\n         if let AssocItemKind::MacCall(_) = item.kind {\n             self.visit_invoc(item.id);\n             return;\n         }\n \n-        if let AssocCtxt::Impl = ctxt {\n-            self.resolve_visibility(&item.vis);\n-            visit::walk_assoc_item(self, item, ctxt);\n-            return;\n-        }\n+        let local_def_id = self.r.local_def_id(item.id);\n+        let def_id = local_def_id.to_def_id();\n+        let vis = match ctxt {\n+            AssocCtxt::Trait => {\n+                let (def_kind, ns) = match item.kind {\n+                    AssocItemKind::Const(..) => (DefKind::AssocConst, ValueNS),\n+                    AssocItemKind::Fn(_, ref sig, _, _) => {\n+                        if sig.decl.has_self() {\n+                            self.r.has_self.insert(def_id);\n+                        }\n+                        (DefKind::AssocFn, ValueNS)\n+                    }\n+                    AssocItemKind::TyAlias(..) => (DefKind::AssocTy, TypeNS),\n+                    AssocItemKind::MacCall(_) => bug!(), // handled above\n+                };\n \n-        // Add the item to the trait info.\n-        let item_def_id = self.r.local_def_id(item.id).to_def_id();\n-        let (res, ns) = match item.kind {\n-            AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n-            AssocItemKind::Fn(_, ref sig, _, _) => {\n-                if sig.decl.has_self() {\n-                    self.r.has_self.insert(item_def_id);\n+                let parent = self.parent_scope.module;\n+                let expansion = self.parent_scope.expansion;\n+                let res = Res::Def(def_kind, def_id);\n+                // Trait item visibility is inherited from its trait when not specified explicitly.\n+                let vis = match &item.vis.kind {\n+                    ast::VisibilityKind::Inherited => {\n+                        self.r.visibilities[&parent.def_id().unwrap().expect_local()]\n+                    }\n+                    _ => self.resolve_visibility(&item.vis),\n+                };\n+                // FIXME: For historical reasons the binding visibility is set to public,\n+                // use actual visibility here instead, using enum variants as an example.\n+                let vis_hack = ty::Visibility::Public;\n+                self.r.define(parent, item.ident, ns, (res, vis_hack, item.span, expansion));\n+                Some(vis)\n+            }\n+            AssocCtxt::Impl => {\n+                // Trait impl item visibility is inherited from its trait when not specified\n+                // explicitly. In that case we cannot determine it here in early resolve,\n+                // so we leave a hole in the visibility table to be filled later.\n+                // Inherent impl item visibility is never inherited from other items.\n+                if matches!(item.vis.kind, ast::VisibilityKind::Inherited)\n+                    && self\n+                        .r\n+                        .trait_impl_items\n+                        .contains(&ty::DefIdTree::parent(&*self.r, def_id).unwrap().expect_local())\n+                {\n+                    None\n+                } else {\n+                    Some(self.resolve_visibility(&item.vis))\n                 }\n-                (Res::Def(DefKind::AssocFn, item_def_id), ValueNS)\n             }\n-            AssocItemKind::TyAlias(..) => (Res::Def(DefKind::AssocTy, item_def_id), TypeNS),\n-            AssocItemKind::MacCall(_) => bug!(), // handled above\n         };\n \n-        let vis = ty::Visibility::Public;\n-        let expansion = self.parent_scope.expansion;\n-        self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        if let Some(vis) = vis {\n+            self.r.visibilities.insert(local_def_id, vis);\n+        }\n \n         visit::walk_assoc_item(self, item, ctxt);\n     }\n@@ -1394,7 +1424,8 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         if sf.is_placeholder {\n             self.visit_invoc(sf.id);\n         } else {\n-            self.resolve_visibility(&sf.vis);\n+            let vis = self.resolve_visibility(&sf.vis);\n+            self.r.visibilities.insert(self.r.local_def_id(sf.id), vis);\n             visit::walk_struct_field(self, sf);\n         }\n     }\n@@ -1408,35 +1439,46 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         let parent = self.parent_scope.module;\n-        let vis = self.r.variant_vis[&parent.def_id().expect(\"enum without def-id\")];\n+        let vis = match variant.vis.kind {\n+            // Variant visibility is inherited from its enum when not specified explicitly.\n+            ast::VisibilityKind::Inherited => {\n+                self.r.visibilities[&parent.def_id().unwrap().expect_local()]\n+            }\n+            _ => self.resolve_visibility(&variant.vis),\n+        };\n         let expn_id = self.parent_scope.expansion;\n         let ident = variant.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.r.local_def_id(variant.id).to_def_id();\n-        let res = Res::Def(DefKind::Variant, def_id);\n+        let def_id = self.r.local_def_id(variant.id);\n+        let res = Res::Def(DefKind::Variant, def_id.to_def_id());\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n+        self.r.visibilities.insert(def_id, vis);\n \n-        // If the variant is marked as non_exhaustive then lower the visibility to within the\n-        // crate.\n-        let mut ctor_vis = vis;\n-        let has_non_exhaustive = self.r.session.contains_name(&variant.attrs, sym::non_exhaustive);\n-        if has_non_exhaustive && vis == ty::Visibility::Public {\n-            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-        }\n+        // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n+        let ctor_vis = if vis == ty::Visibility::Public\n+            && self.r.session.contains_name(&variant.attrs, sym::non_exhaustive)\n+        {\n+            ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+        } else {\n+            vis\n+        };\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n         let ctor_node_id = variant.data.ctor_id().unwrap_or(variant.id);\n-        let ctor_def_id = self.r.local_def_id(ctor_node_id).to_def_id();\n+        let ctor_def_id = self.r.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.data);\n-        let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n+        let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id.to_def_id());\n         self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n+        if ctor_def_id != def_id {\n+            self.r.visibilities.insert(ctor_def_id, ctor_vis);\n+        }\n         // Record field names for error reporting.\n-        self.insert_field_names_local(ctor_def_id, &variant.data);\n+        self.insert_field_names_local(ctor_def_id.to_def_id(), &variant.data);\n \n         visit::walk_variant(self, variant);\n     }"}, {"sha": "cf9eae8d7bdc75b6556ac58f1f2e8a6f49e42be7", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -76,6 +76,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n         let def_data = match &i.kind {\n             ItemKind::Impl { .. } => DefPathData::Impl,\n             ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n+                // Fake crate root item from expand.\n                 return visit::walk_item(self, i);\n             }\n             ItemKind::Mod(..)"}, {"sha": "1c3641411a55e0a47ebea85afb1d1762234f3543", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -944,7 +944,8 @@ pub struct Resolver<'a> {\n \n     /// Maps glob imports to the names of items actually imported.\n     glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n-\n+    /// Visibilities in \"lowered\" form, for all entities that have them.\n+    visibilities: FxHashMap<LocalDefId, ty::Visibility>,\n     used_imports: FxHashSet<(NodeId, Namespace)>,\n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n@@ -1008,10 +1009,6 @@ pub struct Resolver<'a> {\n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n \n-    /// Stores enum visibilities to properly build a reduced graph\n-    /// when visiting the correspondent variants.\n-    variant_vis: DefIdMap<ty::Visibility>,\n-\n     lint_buffer: LintBuffer,\n \n     next_node_id: NodeId,\n@@ -1028,6 +1025,9 @@ pub struct Resolver<'a> {\n     invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n \n     next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n+    /// Some way to know that we are in a *trait* impl in `visit_assoc_item`.\n+    /// FIXME: Replace with a more general AST map (together with some other fields).\n+    trait_impl_items: FxHashSet<LocalDefId>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1195,7 +1195,8 @@ impl<'a> Resolver<'a> {\n         metadata_loader: &'a MetadataLoaderDyn,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a> {\n-        let root_def_id = DefId::local(CRATE_DEF_INDEX);\n+        let root_local_def_id = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n+        let root_def_id = root_local_def_id.to_def_id();\n         let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n@@ -1213,11 +1214,14 @@ impl<'a> Resolver<'a> {\n             )\n         });\n         let mut module_map = FxHashMap::default();\n-        module_map.insert(LocalDefId { local_def_index: CRATE_DEF_INDEX }, graph_root);\n+        module_map.insert(root_local_def_id, graph_root);\n \n         let definitions = Definitions::new(crate_name, session.local_crate_disambiguator());\n         let root = definitions.get_root_def();\n \n+        let mut visibilities = FxHashMap::default();\n+        visibilities.insert(root_local_def_id, ty::Visibility::Public);\n+\n         let mut def_id_to_span = IndexVec::default();\n         assert_eq!(def_id_to_span.push(rustc_span::DUMMY_SP), root);\n         let mut def_id_to_node_id = IndexVec::default();\n@@ -1290,7 +1294,7 @@ impl<'a> Resolver<'a> {\n             ast_transform_scopes: FxHashMap::default(),\n \n             glob_map: Default::default(),\n-\n+            visibilities,\n             used_imports: FxHashSet::default(),\n             maybe_unused_trait_imports: Default::default(),\n             maybe_unused_extern_crates: Vec::new(),\n@@ -1339,7 +1343,6 @@ impl<'a> Resolver<'a> {\n                 .map(|(feat, ..)| *feat)\n                 .chain(features.declared_lang_features.iter().map(|(feat, ..)| *feat))\n                 .collect(),\n-            variant_vis: Default::default(),\n             lint_buffer: LintBuffer::default(),\n             next_node_id: NodeId::from_u32(1),\n             def_id_to_span,\n@@ -1348,6 +1351,7 @@ impl<'a> Resolver<'a> {\n             placeholder_field_indices: Default::default(),\n             invocation_parents,\n             next_disambiguator: Default::default(),\n+            trait_impl_items: Default::default(),\n         }\n     }\n \n@@ -1371,6 +1375,7 @@ impl<'a> Resolver<'a> {\n \n     pub fn into_outputs(self) -> ResolverOutputs {\n         let definitions = self.definitions;\n+        let visibilities = self.visibilities;\n         let extern_crate_map = self.extern_crate_map;\n         let export_map = self.export_map;\n         let maybe_unused_trait_imports = self.maybe_unused_trait_imports;\n@@ -1379,6 +1384,7 @@ impl<'a> Resolver<'a> {\n         ResolverOutputs {\n             definitions: definitions,\n             cstore: Box::new(self.crate_loader.into_cstore()),\n+            visibilities,\n             extern_crate_map,\n             export_map,\n             glob_map,\n@@ -1396,6 +1402,7 @@ impl<'a> Resolver<'a> {\n         ResolverOutputs {\n             definitions: self.definitions.clone(),\n             cstore: Box::new(self.cstore().clone()),\n+            visibilities: self.visibilities.clone(),\n             extern_crate_map: self.extern_crate_map.clone(),\n             export_map: self.export_map.clone(),\n             glob_map: self.glob_map.clone(),"}, {"sha": "2562140bb5d7e03187029bb2084fac0da6b9a6fe", "filename": "compiler/rustc_ty/src/ty.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fty.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -80,7 +80,6 @@ fn sized_constraint_for_ty<'tcx>(\n fn associated_item_from_trait_item_ref(\n     tcx: TyCtxt<'_>,\n     parent_def_id: LocalDefId,\n-    parent_vis: &hir::Visibility<'_>,\n     trait_item_ref: &hir::TraitItemRef,\n ) -> ty::AssocItem {\n     let def_id = tcx.hir().local_def_id(trait_item_ref.id.hir_id);\n@@ -93,8 +92,7 @@ fn associated_item_from_trait_item_ref(\n     ty::AssocItem {\n         ident: trait_item_ref.ident,\n         kind,\n-        // Visibility of trait items is inherited from their traits.\n-        vis: ty::Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, tcx),\n+        vis: tcx.visibility(def_id),\n         defaultness: trait_item_ref.defaultness,\n         def_id: def_id.to_def_id(),\n         container: ty::TraitContainer(parent_def_id.to_def_id()),\n@@ -117,8 +115,7 @@ fn associated_item_from_impl_item_ref(\n     ty::AssocItem {\n         ident: impl_item_ref.ident,\n         kind,\n-        // Visibility of trait impl items doesn't matter.\n-        vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, tcx),\n+        vis: tcx.visibility(def_id),\n         defaultness: impl_item_ref.defaultness,\n         def_id: def_id.to_def_id(),\n         container: ty::ImplContainer(parent_def_id.to_def_id()),\n@@ -143,12 +140,8 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n-                let assoc_item = associated_item_from_trait_item_ref(\n-                    tcx,\n-                    parent_def_id,\n-                    &parent_item.vis,\n-                    trait_item_ref,\n-                );\n+                let assoc_item =\n+                    associated_item_from_trait_item_ref(tcx, parent_def_id, trait_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n                 return assoc_item;\n             }"}, {"sha": "ac2a4a464a7823e55dfa31fb1045156c2f9fe948", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -851,7 +851,6 @@ fn convert_variant(\n     parent_did: LocalDefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.unwrap_or(parent_did));\n     let fields = def\n         .fields()\n         .iter()\n@@ -868,11 +867,7 @@ fn convert_variant(\n                 seen_fields.insert(f.ident.normalize_to_macros_2_0(), f.span);\n             }\n \n-            ty::FieldDef {\n-                did: fid.to_def_id(),\n-                ident: f.ident,\n-                vis: ty::Visibility::from_hir(&f.vis, hir_id, tcx),\n-            }\n+            ty::FieldDef { did: fid.to_def_id(), ident: f.ident, vis: tcx.visibility(fid) }\n         })\n         .collect();\n     let recovered = match def {"}, {"sha": "1a66e0a2f975800c51b0e825c52dff0ae3da9c20", "filename": "src/test/ui/error-codes/E0445.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -1,18 +1,27 @@\n error[E0445]: private trait `Foo` in public interface\n   --> $DIR/E0445.rs:5:1\n    |\n+LL | trait Foo {\n+   | --------- `Foo` declared as private\n+...\n LL | pub trait Bar : Foo {}\n    | ^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `Foo` in public interface\n   --> $DIR/E0445.rs:7:1\n    |\n+LL | trait Foo {\n+   | --------- `Foo` declared as private\n+...\n LL | pub struct Bar2<T: Foo>(pub T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `Foo` in public interface\n   --> $DIR/E0445.rs:9:1\n    |\n+LL | trait Foo {\n+   | --------- `Foo` declared as private\n+...\n LL | pub fn foo<T: Foo> (t: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n "}, {"sha": "73b6ba3c50e378dcbc211a830aca751e7eb6f946", "filename": "src/test/ui/error-codes/E0446.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Ferror-codes%2FE0446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Ferror-codes%2FE0446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0446.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2,7 +2,7 @@ error[E0446]: private type `Bar` in public interface\n   --> $DIR/E0446.rs:4:5\n    |\n LL |     struct Bar(u32);\n-   |     - `Bar` declared as private\n+   |     ---------------- `Bar` declared as private\n LL | \n LL |     pub fn bar() -> Bar {\n    |     ^^^^^^^^^^^^^^^^^^^ can't leak private type"}, {"sha": "dc476f5edc700f2314fb391d56b004704510190f", "filename": "src/test/ui/issues/issue-18389.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2,7 +2,7 @@ error[E0445]: private trait `Private<<Self as Public>::P, <Self as Public>::R>`\n   --> $DIR/issue-18389.rs:7:1\n    |\n LL |   trait Private<P, R> {\n-   |   - `Private<<Self as Public>::P, <Self as Public>::R>` declared as private\n+   |   ------------------- `Private<<Self as Public>::P, <Self as Public>::R>` declared as private\n ...\n LL | / pub trait Public: Private<\n LL | |"}, {"sha": "e40b19420593aa3fd7c63700cff8804eac26f8f7", "filename": "src/test/ui/issues/issue-30079.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fissues%2Fissue-30079.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fissues%2Fissue-30079.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30079.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -12,7 +12,7 @@ error[E0446]: private type `m2::Priv` in public interface\n   --> $DIR/issue-30079.rs:18:9\n    |\n LL |     struct Priv;\n-   |     - `m2::Priv` declared as private\n+   |     ------------ `m2::Priv` declared as private\n LL |     impl ::std::ops::Deref for ::SemiPriv {\n LL |         type Target = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -21,7 +21,7 @@ error[E0446]: private type `m3::Priv` in public interface\n   --> $DIR/issue-30079.rs:35:9\n    |\n LL |     struct Priv;\n-   |     - `m3::Priv` declared as private\n+   |     ------------ `m3::Priv` declared as private\n LL |     impl ::SemiPrivTrait for () {\n LL |         type Assoc = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type"}, {"sha": "ba62a228b09fe66c60213fbce885f78f18f91707", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2,7 +2,7 @@ error[E0446]: private type `Priv` in public interface\n   --> $DIR/private-in-public-assoc-ty.rs:17:9\n    |\n LL |     struct Priv;\n-   |     - `Priv` declared as private\n+   |     ------------ `Priv` declared as private\n ...\n LL |         type A = Priv;\n    |         ^^^^^^^^^^^^^^ can't leak private type\n@@ -39,7 +39,7 @@ error[E0446]: private type `Priv` in public interface\n   --> $DIR/private-in-public-assoc-ty.rs:34:9\n    |\n LL |     struct Priv;\n-   |     - `Priv` declared as private\n+   |     ------------ `Priv` declared as private\n ...\n LL |         type Alias4 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -48,7 +48,7 @@ error[E0446]: private type `Priv` in public interface\n   --> $DIR/private-in-public-assoc-ty.rs:41:9\n    |\n LL |     struct Priv;\n-   |     - `Priv` declared as private\n+   |     ------------ `Priv` declared as private\n ...\n LL |         type Alias1 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -57,7 +57,7 @@ error[E0445]: private trait `PrivTr` in public interface\n   --> $DIR/private-in-public-assoc-ty.rs:44:9\n    |\n LL |     trait PrivTr {}\n-   |     - `PrivTr` declared as private\n+   |     ------------ `PrivTr` declared as private\n ...\n LL |         type Exist = impl PrivTr;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait"}, {"sha": "dd5f5b6f8f8f739cd5bfffc18a88dcfcb5940461", "filename": "src/test/ui/privacy/private-in-public-lint.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-lint.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2,7 +2,7 @@ error[E0446]: private type `m1::Priv` in public interface\n   --> $DIR/private-in-public-lint.rs:6:9\n    |\n LL |     struct Priv;\n-   |     - `m1::Priv` declared as private\n+   |     ------------ `m1::Priv` declared as private\n ...\n LL |         pub fn f() -> Priv {Priv}\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -11,7 +11,7 @@ error[E0446]: private type `m2::Priv` in public interface\n   --> $DIR/private-in-public-lint.rs:15:9\n    |\n LL |     struct Priv;\n-   |     - `m2::Priv` declared as private\n+   |     ------------ `m2::Priv` declared as private\n ...\n LL |         pub fn f() -> Priv {Priv}\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type"}, {"sha": "8240cc3649d074c3da50a22c998082f5e132cb29", "filename": "src/test/ui/privacy/private-in-public-warn.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -43,7 +43,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public-warn.rs:26:9\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |         type Alias = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -97,7 +97,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public-warn.rs:41:9\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |         type Alias = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -250,7 +250,7 @@ error[E0446]: private type `impls::Priv` in public interface\n   --> $DIR/private-in-public-warn.rs:135:9\n    |\n LL |     struct Priv;\n-   |     - `impls::Priv` declared as private\n+   |     ------------ `impls::Priv` declared as private\n ...\n LL |         type Alias = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -268,7 +268,7 @@ error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public-warn.rs:210:9\n    |\n LL |     struct Priv;\n-   |     - `aliases_pub::Priv` declared as private\n+   |     ------------ `aliases_pub::Priv` declared as private\n ...\n LL |         type Check = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -277,7 +277,7 @@ error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public-warn.rs:213:9\n    |\n LL |     struct Priv;\n-   |     - `aliases_pub::Priv` declared as private\n+   |     ------------ `aliases_pub::Priv` declared as private\n ...\n LL |         type Check = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -286,7 +286,7 @@ error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public-warn.rs:216:9\n    |\n LL |     struct Priv;\n-   |     - `aliases_pub::Priv` declared as private\n+   |     ------------ `aliases_pub::Priv` declared as private\n ...\n LL |         type Check = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -295,7 +295,7 @@ error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public-warn.rs:219:9\n    |\n LL |     struct Priv;\n-   |     - `aliases_pub::Priv` declared as private\n+   |     ------------ `aliases_pub::Priv` declared as private\n ...\n LL |         type Check = Priv;\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type"}, {"sha": "e8bb2cde4be8f1abbfb1fa4d16574fab84108218", "filename": "src/test/ui/privacy/private-in-public.stderr", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2,7 +2,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:13:5\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |     pub const C: Priv = Priv;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -11,7 +11,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:14:5\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |     pub static S: Priv = Priv;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -20,7 +20,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:15:5\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |     pub fn f1(arg: Priv) {}\n    |     ^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -29,7 +29,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:16:5\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |     pub fn f2() -> Priv { panic!() }\n    |     ^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -38,7 +38,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:17:19\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |     pub struct S1(pub Priv);\n    |                   ^^^^^^^^ can't leak private type\n@@ -47,7 +47,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:18:21\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |     pub struct S2 { pub field: Priv }\n    |                     ^^^^^^^^^^^^^^^ can't leak private type\n@@ -56,7 +56,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:20:9\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |         pub const C: Priv = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -65,7 +65,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:21:9\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |         pub fn f1(arg: Priv) {}\n    |         ^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -74,7 +74,7 @@ error[E0446]: private type `types::Priv` in public interface\n   --> $DIR/private-in-public.rs:22:9\n    |\n LL |     struct Priv;\n-   |     - `types::Priv` declared as private\n+   |     ------------ `types::Priv` declared as private\n ...\n LL |         pub fn f2() -> Priv { panic!() }\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -83,7 +83,7 @@ error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:31:5\n    |\n LL |     trait PrivTr {}\n-   |     - `traits::PrivTr` declared as private\n+   |     ------------ `traits::PrivTr` declared as private\n ...\n LL |     pub enum E<T: PrivTr> { V(T) }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -92,7 +92,7 @@ error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:32:5\n    |\n LL |     trait PrivTr {}\n-   |     - `traits::PrivTr` declared as private\n+   |     ------------ `traits::PrivTr` declared as private\n ...\n LL |     pub fn f<T: PrivTr>(arg: T) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -101,7 +101,7 @@ error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:33:5\n    |\n LL |     trait PrivTr {}\n-   |     - `traits::PrivTr` declared as private\n+   |     ------------ `traits::PrivTr` declared as private\n ...\n LL |     pub struct S1<T: PrivTr>(T);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -110,7 +110,7 @@ error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:34:5\n    |\n LL |       trait PrivTr {}\n-   |       - `traits::PrivTr` declared as private\n+   |       ------------ `traits::PrivTr` declared as private\n ...\n LL | /     impl<T: PrivTr> Pub<T> {\n LL | |         pub fn f<U: PrivTr>(arg: U) {}\n@@ -121,7 +121,7 @@ error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:35:9\n    |\n LL |     trait PrivTr {}\n-   |     - `traits::PrivTr` declared as private\n+   |     ------------ `traits::PrivTr` declared as private\n ...\n LL |         pub fn f<U: PrivTr>(arg: U) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -130,7 +130,7 @@ error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:44:5\n    |\n LL |     trait PrivTr {}\n-   |     - `traits_where::PrivTr` declared as private\n+   |     ------------ `traits_where::PrivTr` declared as private\n ...\n LL |     pub enum E<T> where T: PrivTr { V(T) }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -139,7 +139,7 @@ error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:46:5\n    |\n LL |     trait PrivTr {}\n-   |     - `traits_where::PrivTr` declared as private\n+   |     ------------ `traits_where::PrivTr` declared as private\n ...\n LL |     pub fn f<T>(arg: T) where T: PrivTr {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -148,7 +148,7 @@ error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:48:5\n    |\n LL |     trait PrivTr {}\n-   |     - `traits_where::PrivTr` declared as private\n+   |     ------------ `traits_where::PrivTr` declared as private\n ...\n LL |     pub struct S1<T>(T) where T: PrivTr;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -157,7 +157,7 @@ error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:50:5\n    |\n LL |       trait PrivTr {}\n-   |       - `traits_where::PrivTr` declared as private\n+   |       ------------ `traits_where::PrivTr` declared as private\n ...\n LL | /     impl<T> Pub<T> where T: PrivTr {\n LL | |\n@@ -170,7 +170,7 @@ error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:52:9\n    |\n LL |     trait PrivTr {}\n-   |     - `traits_where::PrivTr` declared as private\n+   |     ------------ `traits_where::PrivTr` declared as private\n ...\n LL |         pub fn f<U>(arg: U) where U: PrivTr {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -179,7 +179,7 @@ error[E0446]: private type `generics::Priv` in public interface\n   --> $DIR/private-in-public.rs:63:5\n    |\n LL |     struct Priv<T = u8>(T);\n-   |     - `generics::Priv` declared as private\n+   |     ----------------------- `generics::Priv` declared as private\n ...\n LL |     pub fn f1(arg: [Priv; 1]) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -188,7 +188,7 @@ error[E0446]: private type `generics::Priv` in public interface\n   --> $DIR/private-in-public.rs:64:5\n    |\n LL |     struct Priv<T = u8>(T);\n-   |     - `generics::Priv` declared as private\n+   |     ----------------------- `generics::Priv` declared as private\n ...\n LL |     pub fn f2(arg: Pub<Priv>) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -197,7 +197,7 @@ error[E0446]: private type `generics::Priv<generics::Pub>` in public interface\n   --> $DIR/private-in-public.rs:65:5\n    |\n LL |     struct Priv<T = u8>(T);\n-   |     - `generics::Priv<generics::Pub>` declared as private\n+   |     ----------------------- `generics::Priv<generics::Pub>` declared as private\n ...\n LL |     pub fn f3(arg: Priv<Pub>) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -206,7 +206,7 @@ error[E0446]: private type `impls::Priv` in public interface\n   --> $DIR/private-in-public.rs:80:9\n    |\n LL |     struct Priv;\n-   |     - `impls::Priv` declared as private\n+   |     ------------ `impls::Priv` declared as private\n ...\n LL |         pub fn f(arg: Priv) {}\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -215,7 +215,7 @@ error[E0445]: private trait `aliases_pub::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:104:5\n    |\n LL |     trait PrivTr {\n-   |     - `aliases_pub::PrivTr` declared as private\n+   |     ------------ `aliases_pub::PrivTr` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -224,7 +224,7 @@ error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public.rs:104:5\n    |\n LL |     struct Priv;\n-   |     - `aliases_pub::Priv` declared as private\n+   |     ------------ `aliases_pub::Priv` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -233,7 +233,7 @@ error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public.rs:109:9\n    |\n LL |     struct Priv;\n-   |     - `aliases_pub::Priv` declared as private\n+   |     ------------ `aliases_pub::Priv` declared as private\n ...\n LL |         pub fn f(arg: Priv) {}\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -242,7 +242,7 @@ error[E0446]: private type `Priv1` in public interface\n   --> $DIR/private-in-public.rs:131:5\n    |\n LL |     struct Priv1;\n-   |     - `Priv1` declared as private\n+   |     ------------- `Priv1` declared as private\n ...\n LL |     pub fn f1(arg: PrivUseAlias) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -251,7 +251,7 @@ error[E0446]: private type `Priv2` in public interface\n   --> $DIR/private-in-public.rs:132:5\n    |\n LL |     struct Priv2;\n-   |     - `Priv2` declared as private\n+   |     ------------- `Priv2` declared as private\n ...\n LL |     pub fn f2(arg: PrivAlias) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -260,7 +260,7 @@ error[E0445]: private trait `aliases_priv::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:133:5\n    |\n LL |     trait PrivTr {\n-   |     - `aliases_priv::PrivTr` declared as private\n+   |     ------------ `aliases_priv::PrivTr` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n@@ -269,7 +269,7 @@ error[E0446]: private type `aliases_priv::Priv` in public interface\n   --> $DIR/private-in-public.rs:133:5\n    |\n LL |     struct Priv;\n-   |     - `aliases_priv::Priv` declared as private\n+   |     ------------ `aliases_priv::Priv` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -278,7 +278,7 @@ error[E0446]: private type `aliases_params::Priv` in public interface\n   --> $DIR/private-in-public.rs:143:5\n    |\n LL |     struct Priv;\n-   |     - `aliases_params::Priv` declared as private\n+   |     ------------ `aliases_params::Priv` declared as private\n ...\n LL |     pub fn f2(arg: PrivAliasGeneric) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -287,7 +287,7 @@ error[E0446]: private type `aliases_params::Priv` in public interface\n   --> $DIR/private-in-public.rs:145:5\n    |\n LL |     struct Priv;\n-   |     - `aliases_params::Priv` declared as private\n+   |     ------------ `aliases_params::Priv` declared as private\n ...\n LL |     pub fn f3(arg: Result<u8>) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type"}, {"sha": "8c8163d3906b3c5a77c43cc9ae7244b81dcf4dc5", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2,7 +2,7 @@ error[E0446]: private type `Priv` in public interface\n   --> $DIR/private-inferred-type.rs:61:36\n    |\n LL |     struct Priv;\n-   |     - `Priv` declared as private\n+   |     ------------ `Priv` declared as private\n ...\n LL |     impl TraitWithAssocTy for u8 { type AssocTy = Priv; }\n    |                                    ^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -11,7 +11,7 @@ error[E0446]: private type `S2` in public interface\n   --> $DIR/private-inferred-type.rs:83:9\n    |\n LL |     struct S2;\n-   |     - `S2` declared as private\n+   |     ---------- `S2` declared as private\n ...\n LL |         type Target = S2Alias;\n    |         ^^^^^^^^^^^^^^^^^^^^^^ can't leak private type"}, {"sha": "c14382ce2905e7ac488f82f15d4e208d95c66fed", "filename": "src/test/ui/privacy/restricted/private-in-public.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -2,7 +2,7 @@ error[E0446]: private type `Priv` in public interface\n   --> $DIR/private-in-public.rs:8:9\n    |\n LL |     struct Priv;\n-   |     - `Priv` declared as private\n+   |     ------------ `Priv` declared as private\n ...\n LL |         pub(crate) fn g(_: Priv) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n@@ -11,7 +11,7 @@ error[E0446]: private type `Priv` in public interface\n   --> $DIR/private-in-public.rs:9:9\n    |\n LL |     struct Priv;\n-   |     - `Priv` declared as private\n+   |     ------------ `Priv` declared as private\n ...\n LL |         crate fn h(_: Priv) {}\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type"}, {"sha": "ce0e0839f1d17787ca7c5ffe284c3120f796b973", "filename": "src/test/ui/proc-macro/issue-50493.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fproc-macro%2Fissue-50493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fproc-macro%2Fissue-50493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-50493.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -3,8 +3,7 @@\n #[macro_use]\n extern crate issue_50493;\n \n-#[derive(Derive)] //~ ERROR field `field` of struct `Restricted` is private\n-                  //~| ERROR field `field` of struct `Restricted` is private\n+#[derive(Derive)]\n struct Restricted {\n     pub(in restricted) field: usize, //~ visibilities can only be restricted to ancestor modules\n }"}, {"sha": "23e103dbfcbd9366708d81dd7ed99841d1754778", "filename": "src/test/ui/proc-macro/issue-50493.stderr", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fproc-macro%2Fissue-50493.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fproc-macro%2Fissue-50493.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-50493.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -1,26 +1,9 @@\n error[E0742]: visibilities can only be restricted to ancestor modules\n-  --> $DIR/issue-50493.rs:9:12\n+  --> $DIR/issue-50493.rs:8:12\n    |\n LL |     pub(in restricted) field: usize,\n    |            ^^^^^^^^^^\n \n-error[E0616]: field `field` of struct `Restricted` is private\n-  --> $DIR/issue-50493.rs:6:10\n-   |\n-LL | #[derive(Derive)]\n-   |          ^^^^^^ private field\n-   |\n-   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0616]: field `field` of struct `Restricted` is private\n-  --> $DIR/issue-50493.rs:6:10\n-   |\n-LL | #[derive(Derive)]\n-   |          ^^^^^^ private field\n-   |\n-   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0616, E0742.\n-For more information about an error, try `rustc --explain E0616`.\n+For more information about this error, try `rustc --explain E0742`."}, {"sha": "67f888c5e940283f8f04f8dbd3e339a0bb6c71c4", "filename": "src/test/ui/pub/issue-33174-restricted-type-in-public-interface.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.rs?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -1,11 +1,11 @@\n-#![allow(non_camel_case_types)]  // genus is always capitalized\n+#![allow(non_camel_case_types)] // genus is always capitalized\n \n pub(crate) struct Snail;\n-//~^ NOTE `Snail` declared as crate-visible\n+//~^ NOTE `Snail` declared as private\n \n mod sea {\n     pub(super) struct Turtle;\n-    //~^ NOTE `Turtle` declared as restricted\n+    //~^ NOTE `Turtle` declared as crate-private\n }\n \n struct Tortoise;\n@@ -16,11 +16,11 @@ pub struct Shell<T> {\n }\n \n pub type Helix_pomatia = Shell<Snail>;\n-//~^ ERROR crate-visible type `Snail` in public interface\n-//~| NOTE can't leak crate-visible type\n+//~^ ERROR private type `Snail` in public interface\n+//~| NOTE can't leak private type\n pub type Dermochelys_coriacea = Shell<sea::Turtle>;\n-//~^ ERROR restricted type `Turtle` in public interface\n-//~| NOTE can't leak restricted type\n+//~^ ERROR crate-private type `Turtle` in public interface\n+//~| NOTE can't leak crate-private type\n pub type Testudo_graeca = Shell<Tortoise>;\n //~^ ERROR private type `Tortoise` in public interface\n //~| NOTE can't leak private type"}, {"sha": "29d45858ff15ce31a6326209a423e1b54054b406", "filename": "src/test/ui/pub/issue-33174-restricted-type-in-public-interface.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eaadebb3dee31669c7649b32747381d11614fae/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.stderr?ref=1eaadebb3dee31669c7649b32747381d11614fae", "patch": "@@ -1,26 +1,26 @@\n-error[E0446]: crate-visible type `Snail` in public interface\n+error[E0446]: private type `Snail` in public interface\n   --> $DIR/issue-33174-restricted-type-in-public-interface.rs:18:1\n    |\n LL | pub(crate) struct Snail;\n-   | ---------- `Snail` declared as crate-visible\n+   | ------------------------ `Snail` declared as private\n ...\n LL | pub type Helix_pomatia = Shell<Snail>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak crate-visible type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n-error[E0446]: restricted type `Turtle` in public interface\n+error[E0446]: crate-private type `Turtle` in public interface\n   --> $DIR/issue-33174-restricted-type-in-public-interface.rs:21:1\n    |\n LL |     pub(super) struct Turtle;\n-   |     ---------- `Turtle` declared as restricted\n+   |     ------------------------- `Turtle` declared as crate-private\n ...\n LL | pub type Dermochelys_coriacea = Shell<sea::Turtle>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak restricted type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak crate-private type\n \n error[E0446]: private type `Tortoise` in public interface\n   --> $DIR/issue-33174-restricted-type-in-public-interface.rs:24:1\n    |\n LL | struct Tortoise;\n-   | - `Tortoise` declared as private\n+   | ---------------- `Tortoise` declared as private\n ...\n LL | pub type Testudo_graeca = Shell<Tortoise>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type"}]}