{"sha": "45127211566c53bac386b66909a830649182ab7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MTI3MjExNTY2YzUzYmFjMzg2YjY2OTA5YTgzMDY0OTE4MmFiN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-28T00:18:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-28T00:18:52Z"}, "message": "Auto merge of #72494 - lcnr:predicate-cleanup, r=nikomatsakis\n\nPass more `Copy` types by value.\n\nThere are a lot of locations where we pass `&T where T: Copy` by reference,\nwhich should both be slightly less performant and less readable IMO.\n\nThis PR currently consists of three fairly self contained commits:\n\n- passes `ty::Predicate` by value and stops depending on `AsRef<ty::Predicate>`.\n- changes `<&List<_>>::into_iter` to iterate over the elements by value. This would break `List`s\n  of non copy types. But as the only list constructor requires `T` to be copy anyways, I think\n  the improved readability is worth this potential future restriction.\n- passes `mir::PlaceElem` by value. Mir currently has quite a few copy types which are passed by reference, e.g. `Local`. As I don't have a lot of experience working with MIR, I mostly did this to get some feedback from people who use MIR more frequently\n- tries to reuse `ty::Predicate` in case it did not change in some places, which should hopefully\n  fix the regression caused by #72055\n\nr? @nikomatsakis for the first commit, which continues the work of #72055 and makes adding `PredicateKind::ForAll` slightly more pleasant. Feel free to reassign though", "tree": {"sha": "821762c0357a83853b5a76f7ce6e47e578790a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/821762c0357a83853b5a76f7ce6e47e578790a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45127211566c53bac386b66909a830649182ab7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45127211566c53bac386b66909a830649182ab7a", "html_url": "https://github.com/rust-lang/rust/commit/45127211566c53bac386b66909a830649182ab7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45127211566c53bac386b66909a830649182ab7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "664fcd3f046e2a6824602da0fad81e3e2bb0d409", "url": "https://api.github.com/repos/rust-lang/rust/commits/664fcd3f046e2a6824602da0fad81e3e2bb0d409", "html_url": "https://github.com/rust-lang/rust/commit/664fcd3f046e2a6824602da0fad81e3e2bb0d409"}, {"sha": "f15e4b30c0d217b647e443333902ca7a948e0f58", "url": "https://api.github.com/repos/rust-lang/rust/commits/f15e4b30c0d217b647e443333902ca7a948e0f58", "html_url": "https://github.com/rust-lang/rust/commit/f15e4b30c0d217b647e443333902ca7a948e0f58"}], "stats": {"total": 390, "additions": 194, "deletions": 196}, "files": [{"sha": "57a3d8b5edcafc0b30f47061ef1a5a69d0361794", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -48,7 +48,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n         ty::Tuple(component_types) => {\n             output.push('(');\n-            for &component_type in component_types {\n+            for component_type in component_types {\n                 push_debuginfo_type_name(tcx, component_type.expect_ty(), true, output, visited);\n                 output.push_str(\", \");\n             }"}, {"sha": "fa0f29acc74334c0ddc7097349ffc556f6657f58", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -104,7 +104,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     ) {\n         let cx = self.fx.cx;\n \n-        if let [proj_base @ .., elem] = place_ref.projection {\n+        if let &[ref proj_base @ .., elem] = place_ref.projection {\n             let mut base_context = if context.is_mutating_use() {\n                 PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             } else {\n@@ -186,7 +186,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             // now that we have moved to the \"slice of projections\" representation.\n             if let mir::ProjectionElem::Index(local) = elem {\n                 self.visit_local(\n-                    local,\n+                    &local,\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                     location,\n                 );"}, {"sha": "2be0679382900650e9494f3f5e71a77eeacb9f4a", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -429,7 +429,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_consume(bx, mir::PlaceRef { local, projection: proj_base })\n                     .deref(bx.cx())\n             }\n-            mir::PlaceRef { local, projection: [proj_base @ .., elem] } => {\n+            mir::PlaceRef { local, projection: &[ref proj_base @ .., elem] } => {\n                 // FIXME turn this recursion into iteration\n                 let cg_base =\n                     self.codegen_place(bx, mir::PlaceRef { local, projection: proj_base });\n@@ -440,7 +440,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::from(*index));\n+                        let index = &mir::Operand::Copy(mir::Place::from(index));\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n                         cg_base.project_index(bx, llindex)\n@@ -450,22 +450,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         from_end: false,\n                         min_length: _,\n                     } => {\n-                        let lloffset = bx.cx().const_usize(*offset as u64);\n+                        let lloffset = bx.cx().const_usize(offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex {\n                         offset,\n                         from_end: true,\n                         min_length: _,\n                     } => {\n-                        let lloffset = bx.cx().const_usize(*offset as u64);\n+                        let lloffset = bx.cx().const_usize(offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to, from_end } => {\n                         let mut subslice =\n-                            cg_base.project_index(bx, bx.cx().const_usize(*from as u64));\n+                            cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n                         let projected_ty =\n                             PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n@@ -474,7 +474,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             assert!(from_end, \"slice subslices should be `from_end`\");\n                             subslice.llextra = Some(bx.sub(\n                                 cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((*from as u64) + (*to as u64)),\n+                                bx.cx().const_usize((from as u64) + (to as u64)),\n                             ));\n                         }\n \n@@ -487,7 +487,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                         subslice\n                     }\n-                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, *v),\n+                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, v),\n                 }\n             }\n         };"}, {"sha": "7310d2c3bdcf8318fc1d304069798bd98afa6331", "filename": "src/librustc_infer/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -87,7 +87,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) -> CanonicalVarValues<'tcx> {\n         let var_values: IndexVec<BoundVar, GenericArg<'tcx>> = variables\n             .iter()\n-            .map(|info| self.instantiate_canonical_var(span, *info, &universe_map))\n+            .map(|info| self.instantiate_canonical_var(span, info, &universe_map))\n             .collect();\n \n         CanonicalVarValues { var_values }"}, {"sha": "ab2393918c35420072b38b59010728123e16b3c2", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -464,12 +464,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     if info.is_existential() {\n                         match opt_values[BoundVar::new(index)] {\n                             Some(k) => k,\n-                            None => self.instantiate_canonical_var(cause.span, *info, |u| {\n+                            None => self.instantiate_canonical_var(cause.span, info, |u| {\n                                 universe_map[u.as_usize()]\n                             }),\n                         }\n                     } else {\n-                        self.instantiate_canonical_var(cause.span, *info, |u| {\n+                        self.instantiate_canonical_var(cause.span, info, |u| {\n                             universe_map[u.as_usize()]\n                         })\n                     }"}, {"sha": "92387f753f55ecdea5ad7f3e59bcec5e72685409", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -970,7 +970,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        predicate: &ty::PolySubtypePredicate<'tcx>,\n+        predicate: ty::PolySubtypePredicate<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n         // `shallow_resolve` just ignores anything that is not a type\n@@ -993,7 +993,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         Some(self.commit_if_ok(|snapshot| {\n             let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.replace_bound_vars_with_placeholders(&predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n@@ -1006,11 +1006,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn region_outlives_predicate(\n         &self,\n         cause: &traits::ObligationCause<'tcx>,\n-        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n+        predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.replace_bound_vars_with_placeholders(&predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });"}, {"sha": "82d32b008088ddde01bfa257e0d8537aca3b12b8", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -50,7 +50,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                 // for further background and discussion.\n                 let mut bounds = substs\n                     .iter()\n-                    .filter_map(|&child| match child.unpack() {\n+                    .filter_map(|child| match child.unpack() {\n                         GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n                         GenericArgKind::Lifetime(_) => None,\n                         GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n@@ -334,10 +334,10 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn collect_outlives_from_predicate_list(\n         &self,\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n-        predicates: impl Iterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n+        predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         predicates\n-            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n+            .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))\n     }"}, {"sha": "17b7b4e680f5e4764b4d953b6abbcce49b26585b", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -8,52 +8,46 @@ use rustc_span::Span;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    pred: &ty::Predicate<'tcx>,\n+    pred: ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    match pred.kind() {\n+    let kind = pred.kind();\n+    let new = match kind {\n         &ty::PredicateKind::Trait(ref data, constness) => {\n             ty::PredicateKind::Trait(tcx.anonymize_late_bound_regions(data), constness)\n-                .to_predicate(tcx)\n         }\n \n         ty::PredicateKind::RegionOutlives(data) => {\n             ty::PredicateKind::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n-                .to_predicate(tcx)\n         }\n \n         ty::PredicateKind::TypeOutlives(data) => {\n             ty::PredicateKind::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n-                .to_predicate(tcx)\n         }\n \n         ty::PredicateKind::Projection(data) => {\n-            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data)).to_predicate(tcx)\n+            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        &ty::PredicateKind::WellFormed(data) => {\n-            ty::PredicateKind::WellFormed(data).to_predicate(tcx)\n-        }\n+        &ty::PredicateKind::WellFormed(data) => ty::PredicateKind::WellFormed(data),\n \n-        &ty::PredicateKind::ObjectSafe(data) => {\n-            ty::PredicateKind::ObjectSafe(data).to_predicate(tcx)\n-        }\n+        &ty::PredicateKind::ObjectSafe(data) => ty::PredicateKind::ObjectSafe(data),\n \n         &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind).to_predicate(tcx)\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n         }\n \n         ty::PredicateKind::Subtype(data) => {\n-            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data)).to_predicate(tcx)\n+            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data))\n         }\n \n         &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(tcx)\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs)\n         }\n \n-        ty::PredicateKind::ConstEquate(c1, c2) => {\n-            ty::PredicateKind::ConstEquate(c1, c2).to_predicate(tcx)\n-        }\n-    }\n+        ty::PredicateKind::ConstEquate(c1, c2) => ty::PredicateKind::ConstEquate(c1, c2),\n+    };\n+\n+    if new != *kind { new.to_predicate(tcx) } else { pred }\n }\n \n struct PredicateSet<'tcx> {\n@@ -66,7 +60,7 @@ impl PredicateSet<'tcx> {\n         Self { tcx, set: Default::default() }\n     }\n \n-    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+    fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n         // We have to be careful here because we want\n         //\n         //    for<'a> Foo<&'a int>\n@@ -81,10 +75,10 @@ impl PredicateSet<'tcx> {\n     }\n }\n \n-impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n-    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+impl Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n+    fn extend<I: IntoIterator<Item = ty::Predicate<'tcx>>>(&mut self, iter: I) {\n         for pred in iter {\n-            self.insert(pred.as_ref());\n+            self.insert(pred);\n         }\n     }\n }\n@@ -132,7 +126,7 @@ pub fn elaborate_obligations<'tcx>(\n     mut obligations: Vec<PredicateObligation<'tcx>>,\n ) -> Elaborator<'tcx> {\n     let mut visited = PredicateSet::new(tcx);\n-    obligations.retain(|obligation| visited.insert(&obligation.predicate));\n+    obligations.retain(|obligation| visited.insert(obligation.predicate));\n     Elaborator { stack: obligations, visited }\n }\n \n@@ -172,7 +166,7 @@ impl Elaborator<'tcx> {\n                 // cases. One common case is when people define\n                 // `trait Sized: Sized { }` rather than `trait Sized { }`.\n                 let visited = &mut self.visited;\n-                let obligations = obligations.filter(|o| visited.insert(&o.predicate));\n+                let obligations = obligations.filter(|o| visited.insert(o.predicate));\n \n                 self.stack.extend(obligations);\n             }\n@@ -260,7 +254,7 @@ impl Elaborator<'tcx> {\n                             }\n                         })\n                         .map(|predicate_kind| predicate_kind.to_predicate(tcx))\n-                        .filter(|predicate| visited.insert(predicate))\n+                        .filter(|&predicate| visited.insert(predicate))\n                         .map(|predicate| predicate_obligation(predicate, None)),\n                 );\n             }"}, {"sha": "47cfa62abb14d6b02d7f9487e6a3a23313830de4", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -2077,10 +2077,10 @@ impl Debug for Place<'_> {\n                 ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n                     write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n                 }\n-                ProjectionElem::Subslice { from, to, from_end: true } if *to == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if to == 0 => {\n                     write!(fmt, \"[{:?}:]\", from)?;\n                 }\n-                ProjectionElem::Subslice { from, to, from_end: true } if *from == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if from == 0 => {\n                     write!(fmt, \"[:-{:?}]\", to)?;\n                 }\n                 ProjectionElem::Subslice { from, to, from_end: true } => {"}, {"sha": "4747aec2d5c24217a2625e7ea6df5d3e9fd109a2", "filename": "src/librustc_middle/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftcx.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -56,8 +56,8 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// Convenience wrapper around `projection_ty_core` for\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n-    pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: &PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), elem, |_, _, ty| ty)\n+    pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -124,7 +124,7 @@ impl<'tcx> Place<'tcx> {\n     {\n         projection\n             .iter()\n-            .fold(PlaceTy::from_ty(local_decls.local_decls()[local].ty), |place_ty, elem| {\n+            .fold(PlaceTy::from_ty(local_decls.local_decls()[local].ty), |place_ty, &elem| {\n                 place_ty.projection_ty(tcx, elem)\n             })\n     }"}, {"sha": "a29b7b75294b7d026b3d2339069211ae5e49986b", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -903,7 +903,7 @@ macro_rules! visit_place_fns {\n             let mut projection = Cow::Borrowed(projection);\n \n             for i in 0..projection.len() {\n-                if let Some(elem) = projection.get(i) {\n+                if let Some(&elem) = projection.get(i) {\n                     if let Some(elem) = self.process_projection_elem(elem, location) {\n                         // This converts the borrowed projection into `Cow::Owned(_)` and returns a\n                         // clone of the projection so we can mutate and reintern later.\n@@ -921,19 +921,19 @@ macro_rules! visit_place_fns {\n \n         fn process_projection_elem(\n             &mut self,\n-            elem: &PlaceElem<'tcx>,\n+            elem: PlaceElem<'tcx>,\n             location: Location,\n         ) -> Option<PlaceElem<'tcx>> {\n             match elem {\n                 PlaceElem::Index(local) => {\n-                    let mut new_local = *local;\n+                    let mut new_local = local;\n                     self.visit_local(\n                         &mut new_local,\n                         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                         location,\n                     );\n \n-                    if new_local == *local { None } else { Some(PlaceElem::Index(new_local)) }\n+                    if new_local == local { None } else { Some(PlaceElem::Index(new_local)) }\n                 }\n                 PlaceElem::Deref\n                 | PlaceElem::Field(..)\n@@ -959,7 +959,7 @@ macro_rules! visit_place_fns {\n             &mut self,\n             local: Local,\n             proj_base: &[PlaceElem<'tcx>],\n-            elem: &PlaceElem<'tcx>,\n+            elem: PlaceElem<'tcx>,\n             context: PlaceContext,\n             location: Location,\n         ) {\n@@ -990,7 +990,7 @@ macro_rules! visit_place_fns {\n             location: Location,\n         ) {\n             let mut cursor = projection;\n-            while let [proj_base @ .., elem] = cursor {\n+            while let &[ref proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n                 self.visit_projection_elem(local, cursor, elem, context, location);\n             }\n@@ -1000,7 +1000,7 @@ macro_rules! visit_place_fns {\n             &mut self,\n             _local: Local,\n             _proj_base: &[PlaceElem<'tcx>],\n-            elem: &PlaceElem<'tcx>,\n+            elem: PlaceElem<'tcx>,\n             _context: PlaceContext,\n             location: Location,\n         ) {\n@@ -1010,7 +1010,7 @@ macro_rules! visit_place_fns {\n                 }\n                 ProjectionElem::Index(local) => {\n                     self.visit_local(\n-                        local,\n+                        &local,\n                         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                         location,\n                     );"}, {"sha": "edcb69c5e8cbdf3fc3b01cbdf3d0e4883fee1f08", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -129,7 +129,7 @@ impl FlagComputation {\n             &ty::Dynamic(ref obj, r) => {\n                 let mut computation = FlagComputation::new();\n                 for predicate in obj.skip_binder().iter() {\n-                    match *predicate {\n+                    match predicate {\n                         ty::ExistentialPredicate::Trait(tr) => computation.add_substs(tr.substs),\n                         ty::ExistentialPredicate::Projection(p) => {\n                             let mut proj_computation = FlagComputation::new();"}, {"sha": "161783bb370d44904b4a492ae05d2c55e1636f22", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -5,6 +5,7 @@ use rustc_serialize::{Encodable, Encoder};\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::iter;\n use std::mem;\n use std::ops::Deref;\n use std::ptr;\n@@ -21,6 +22,10 @@ extern \"C\" {\n /// the same contents can exist in the same context.\n /// This means we can use pointer for both\n /// equality comparisons and hashing.\n+///\n+/// Unlike slices, The types contained in `List` are expected to be `Copy`\n+/// and iterating over a `List` returns `T` instead of a reference.\n+///\n /// Note: `Slice` was already taken by the `Ty`.\n #[repr(C)]\n pub struct List<T> {\n@@ -61,6 +66,15 @@ impl<T: Copy> List<T> {\n             result\n         }\n     }\n+\n+    // If this method didn't exist, we would use `slice.iter` due to\n+    // deref coercion.\n+    //\n+    // This would be weird, as `self.into_iter` iterates over `T` directly.\n+    #[inline(always)]\n+    pub fn iter(&self) -> <&'_ List<T> as IntoIterator>::IntoIter {\n+        self.into_iter()\n+    }\n }\n \n impl<T: fmt::Debug> fmt::Debug for List<T> {\n@@ -128,12 +142,12 @@ impl<T> AsRef<[T]> for List<T> {\n     }\n }\n \n-impl<'a, T> IntoIterator for &'a List<T> {\n-    type Item = &'a T;\n-    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+impl<'a, T: Copy> IntoIterator for &'a List<T> {\n+    type Item = T;\n+    type IntoIter = iter::Copied<<&'a [T] as IntoIterator>::IntoIter>;\n     #[inline(always)]\n     fn into_iter(self) -> Self::IntoIter {\n-        self[..].iter()\n+        self[..].iter().copied()\n     }\n }\n "}, {"sha": "055adba81afb7c9d2766295fa8ecb71757f684ff", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -1032,6 +1032,7 @@ impl<'tcx> PartialEq for Predicate<'tcx> {\n impl<'tcx> Eq for Predicate<'tcx> {}\n \n impl<'tcx> Predicate<'tcx> {\n+    #[inline(always)]\n     pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n         self.kind\n     }\n@@ -1094,12 +1095,6 @@ pub struct CratePredicatesMap<'tcx> {\n     pub predicates: FxHashMap<DefId, &'tcx [(ty::Predicate<'tcx>, Span)]>,\n }\n \n-impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n-    fn as_ref(&self) -> &Predicate<'tcx> {\n-        self\n-    }\n-}\n-\n impl<'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n@@ -1172,7 +1167,8 @@ impl<'tcx> Predicate<'tcx> {\n         // this trick achieves that).\n \n         let substs = &trait_ref.skip_binder().substs;\n-        let predicate = match self.kind() {\n+        let kind = self.kind();\n+        let new = match kind {\n             &PredicateKind::Trait(ref binder, constness) => {\n                 PredicateKind::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n             }\n@@ -1201,7 +1197,7 @@ impl<'tcx> Predicate<'tcx> {\n             }\n         };\n \n-        predicate.to_predicate(tcx)\n+        if new != *kind { new.to_predicate(tcx) } else { self }\n     }\n }\n \n@@ -1214,17 +1210,17 @@ pub struct TraitPredicate<'tcx> {\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> DefId {\n+    pub fn def_id(self) -> DefId {\n         self.trait_ref.def_id\n     }\n \n-    pub fn self_ty(&self) -> Ty<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }\n }\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> DefId {\n+    pub fn def_id(self) -> DefId {\n         // Ok to skip binder since trait `DefId` does not care about regions.\n         self.skip_binder().def_id()\n     }\n@@ -1320,6 +1316,7 @@ pub trait ToPredicate<'tcx> {\n }\n \n impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n+    #[inline(always)]\n     fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(*self)\n     }"}, {"sha": "1da042e161737ec6f7ebe730d06aa1bf0172bd76", "filename": "src/librustc_middle/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Foutlives.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -70,7 +70,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 // consistent with previous (accidental) behavior.\n                 // See https://github.com/rust-lang/rust/issues/70917\n                 // for further background and discussion.\n-                for &child in substs {\n+                for child in substs {\n                     match child.unpack() {\n                         GenericArgKind::Type(ty) => {\n                             compute_components(tcx, ty, out);"}, {"sha": "7d9943ab07902986478494a6a2e58041d901a5e4", "filename": "src/librustc_middle/ty/print/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -47,7 +47,7 @@ impl DefPathBasedNames<'tcx> {\n             }\n             ty::Tuple(component_types) => {\n                 output.push('(');\n-                for &component_type in component_types {\n+                for component_type in component_types {\n                     self.push_type_name(component_type.expect_ty(), output, debug);\n                     output.push_str(\", \");\n                 }"}, {"sha": "6a11e775c8c5a16eec17aaa33f26e9a0a4a1c982", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -496,7 +496,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Never => p!(write(\"!\")),\n             ty::Tuple(ref tys) => {\n-                p!(write(\"(\"), comma_sep(tys.iter().copied()));\n+                p!(write(\"(\"), comma_sep(tys.iter()));\n                 if tys.len() == 1 {\n                     p!(write(\",\"));\n                 }\n@@ -561,7 +561,7 @@ pub trait PrettyPrinter<'tcx>:\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if !substs.is_empty() {\n                             p!(write(\"::\"));\n-                            p!(generic_delimiters(|cx| cx.comma_sep(substs.iter().copied())));\n+                            p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n                         }\n                         return Ok(self);\n                     }\n@@ -1924,7 +1924,7 @@ define_print_and_forward_display! {\n     (self, cx):\n \n     &'tcx ty::List<Ty<'tcx>> {\n-        p!(write(\"{{\"), comma_sep(self.iter().copied()), write(\"}}\"))\n+        p!(write(\"{{\"), comma_sep(self.iter()), write(\"}}\"))\n     }\n \n     ty::TypeAndMut<'tcx> {"}, {"sha": "d507fcbc19404ff69002dfc65e22ba50240bbce4", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -143,7 +143,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        relation.relate_with_variance(variance, a, b)\n+        relation.relate_with_variance(variance, &a, &b)\n     });\n \n     Ok(tcx.mk_substs(params)?)\n@@ -319,7 +319,7 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n-        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n+        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(&a, &b)))?;\n         Ok(GeneratorWitness(types))\n     }\n }\n@@ -633,7 +633,7 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n         let tcx = relation.tcx();\n         let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n-            match (*ep_a, *ep_b) {\n+            match (ep_a, ep_b) {\n                 (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n                 (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n                 (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),"}, {"sha": "c6ecb08615fcf122fe5e49d3d230d57eac1ed27f", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -1091,7 +1091,7 @@ where\n     // Look for the first element that changed\n     if let Some((i, new_t)) = iter.by_ref().enumerate().find_map(|(i, t)| {\n         let new_t = t.fold_with(folder);\n-        if new_t == *t { None } else { Some((i, new_t)) }\n+        if new_t == t { None } else { Some((i, new_t)) }\n     }) {\n         // An element changed, prepare to intern the resulting list\n         let mut new_list = SmallVec::<[_; 8]>::with_capacity(list.len());"}, {"sha": "ef77d1b5b3f816ad4277988ab3a63e82eac235ef", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -669,15 +669,15 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     pub fn projection_bounds<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = ExistentialProjection<'tcx>> + 'a {\n-        self.iter().filter_map(|predicate| match *predicate {\n+        self.iter().filter_map(|predicate| match predicate {\n             ExistentialPredicate::Projection(projection) => Some(projection),\n             _ => None,\n         })\n     }\n \n     #[inline]\n     pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n-        self.iter().filter_map(|predicate| match *predicate {\n+        self.iter().filter_map(|predicate| match predicate {\n             ExistentialPredicate::AutoTrait(did) => Some(did),\n             _ => None,\n         })\n@@ -708,7 +708,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn iter<'a>(\n         &'a self,\n     ) -> impl DoubleEndedIterator<Item = Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n-        self.skip_binder().iter().cloned().map(Binder::bind)\n+        self.skip_binder().iter().map(Binder::bind)\n     }\n }\n "}, {"sha": "1529f1173b391caea5df017e76d86b1e957eb646", "filename": "src/librustc_middle/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsubst.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -340,11 +340,11 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         target_substs: SubstsRef<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n-        tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n+        tcx.mk_substs(target_substs.iter().chain(self.iter().skip(defs.params.len())))\n     }\n \n     pub fn truncate_to(&self, tcx: TyCtxt<'tcx>, generics: &ty::Generics) -> SubstsRef<'tcx> {\n-        tcx.mk_substs(self.iter().take(generics.count()).cloned())\n+        tcx.mk_substs(self.iter().take(generics.count()))\n     }\n }\n "}, {"sha": "c2b794ca4bdd9e0ed5e3d6a2ca0a16ed795551f6", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -413,7 +413,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let result = item_substs\n             .iter()\n             .zip(impl_substs.iter())\n-            .filter(|&(_, &k)| {\n+            .filter(|&(_, k)| {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n                         !impl_generics.region_param(ebr, self).pure_wrt_drop\n@@ -433,7 +433,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n             })\n-            .map(|(&item_param, _)| item_param)\n+            .map(|(item_param, _)| item_param)\n             .collect();\n         debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n         result"}, {"sha": "bf988a430263303e9687dae8e9d2ef91d26c56b2", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -128,7 +128,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 stack.push(lt.into());\n             }\n             ty::Projection(data) => {\n-                stack.extend(data.substs.iter().copied().rev());\n+                stack.extend(data.substs.iter().rev());\n             }\n             ty::Dynamic(obj, lt) => {\n                 stack.push(lt.into());\n@@ -143,7 +143,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                         }\n                     };\n \n-                    substs.iter().copied().rev().chain(opt_ty.map(|ty| ty.into()))\n+                    substs.iter().rev().chain(opt_ty.map(|ty| ty.into()))\n                 }));\n             }\n             ty::Adt(_, substs)\n@@ -152,14 +152,14 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             | ty::Generator(_, substs, _)\n             | ty::Tuple(substs)\n             | ty::FnDef(_, substs) => {\n-                stack.extend(substs.iter().copied().rev());\n+                stack.extend(substs.iter().rev());\n             }\n             ty::GeneratorWitness(ts) => {\n-                stack.extend(ts.skip_binder().iter().cloned().rev().map(|ty| ty.into()));\n+                stack.extend(ts.skip_binder().iter().rev().map(|ty| ty.into()));\n             }\n             ty::FnPtr(sig) => {\n                 stack.push(sig.skip_binder().output().into());\n-                stack.extend(sig.skip_binder().inputs().iter().cloned().rev().map(|ty| ty.into()));\n+                stack.extend(sig.skip_binder().inputs().iter().copied().rev().map(|ty| ty.into()));\n             }\n         },\n         GenericArgKind::Lifetime(_) => {}\n@@ -174,7 +174,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 | ty::ConstKind::Error => {}\n \n                 ty::ConstKind::Unevaluated(_, substs, _) => {\n-                    stack.extend(substs.iter().copied().rev());\n+                    stack.extend(substs.iter().rev());\n                 }\n             }\n         }"}, {"sha": "cadf1ebf1b774c30ef68ae59fbb8e4fd54a3a10b", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         for (i, elem) in self.projection.iter().enumerate() {\n             let proj_base = &self.projection[..i];\n \n-            if *elem == ProjectionElem::Deref {\n+            if elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(self.local, proj_base, body, tcx).ty;\n                 match ty.kind {\n                     ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {"}, {"sha": "246e4826e0e767676d15355662894392fbe639c6", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -138,7 +138,7 @@ fn place_components_conflict<'tcx>(\n     }\n \n     // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-    for (i, (borrow_c, access_c)) in\n+    for (i, (borrow_c, &access_c)) in\n         borrow_place.projection.iter().zip(access_place.projection.iter()).enumerate()\n     {\n         debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n@@ -313,8 +313,8 @@ fn place_projection_conflict<'tcx>(\n     body: &Body<'tcx>,\n     pi1_local: Local,\n     pi1_proj_base: &[PlaceElem<'tcx>],\n-    pi1_elem: &PlaceElem<'tcx>,\n-    pi2_elem: &PlaceElem<'tcx>,\n+    pi1_elem: PlaceElem<'tcx>,\n+    pi2_elem: PlaceElem<'tcx>,\n     bias: PlaceConflictBias,\n ) -> Overlap {\n     match (pi1_elem, pi2_elem) {\n@@ -449,7 +449,7 @@ fn place_projection_conflict<'tcx>(\n             // element (like -1 in Python) and `min_length` the first.\n             // Therefore, `min_length - offset_from_end` gives the minimal possible\n             // offset from the beginning\n-            if *offset_from_begin >= *min_length - *offset_from_end {\n+            if offset_from_begin >= min_length - offset_from_end {\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n                 Overlap::EqualOrDisjoint\n             } else {"}, {"sha": "5df033b48c1f9f5153a1c12005be45a5b0f45c27", "filename": "src/librustc_mir/borrow_check/renumber.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -66,14 +66,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n \n     fn process_projection_elem(\n         &mut self,\n-        elem: &PlaceElem<'tcx>,\n+        elem: PlaceElem<'tcx>,\n         _: Location,\n     ) -> Option<PlaceElem<'tcx>> {\n         if let PlaceElem::Field(field, ty) = elem {\n-            let new_ty = self.renumber_regions(ty);\n+            let new_ty = self.renumber_regions(&ty);\n \n-            if new_ty != *ty {\n-                return Some(PlaceElem::Field(*field, new_ty));\n+            if new_ty != ty {\n+                return Some(PlaceElem::Field(field, new_ty));\n             }\n         }\n "}, {"sha": "ac7da7ee42d66b212db34d44254269b72f21b5e2", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -611,14 +611,14 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn sanitize_projection(\n         &mut self,\n         base: PlaceTy<'tcx>,\n-        pi: &PlaceElem<'tcx>,\n+        pi: PlaceElem<'tcx>,\n         place: &Place<'tcx>,\n         location: Location,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n         let base_ty = base.ty;\n-        match *pi {\n+        match pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true);\n                 PlaceTy::from_ty(deref_ty.map(|t| t.ty).unwrap_or_else(|| {"}, {"sha": "6dd06743e2d5bdf187008aff53505c95ce1ec7ee", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -12,12 +12,12 @@ pub fn move_path_children_matching<'tcx, F>(\n     mut cond: F,\n ) -> Option<MovePathIndex>\n where\n-    F: FnMut(&mir::PlaceElem<'tcx>) -> bool,\n+    F: FnMut(mir::PlaceElem<'tcx>) -> bool,\n {\n     let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n         let move_path_children = &move_data.move_paths[child_index];\n-        if let Some(elem) = move_path_children.place.projection.last() {\n+        if let Some(&elem) = move_path_children.place.projection.last() {\n             if cond(elem) {\n                 return Some(child_index);\n             }"}, {"sha": "427ab1ca5cd229d20722df05bcd30e5296246e04", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -176,7 +176,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn add_move_path(\n         &mut self,\n         base: MovePathIndex,\n-        elem: &PlaceElem<'tcx>,\n+        elem: PlaceElem<'tcx>,\n         mk_place: impl FnOnce(TyCtxt<'tcx>) -> Place<'tcx>,\n     ) -> MovePathIndex {\n         let MoveDataBuilder {\n@@ -485,7 +485,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 let elem =\n                     ProjectionElem::ConstantIndex { offset, min_length: len, from_end: false };\n                 let path =\n-                    self.add_move_path(base_path, &elem, |tcx| tcx.mk_place_elem(base_place, elem));\n+                    self.add_move_path(base_path, elem, |tcx| tcx.mk_place_elem(base_place, elem));\n                 self.record_move(place, path);\n             }\n         } else {"}, {"sha": "95bc9810dab80f92d0eb0c1720a9e6f9e98418cd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -400,10 +400,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn operand_projection(\n         &self,\n         base: OpTy<'tcx, M::PointerTag>,\n-        proj_elem: &mir::PlaceElem<'tcx>,\n+        proj_elem: mir::PlaceElem<'tcx>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n-        Ok(match *proj_elem {\n+        Ok(match proj_elem {\n             Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),"}, {"sha": "dc6967c2c49e52728cde62d86c6a6f70e40dabc7", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -517,10 +517,10 @@ where\n     pub(super) fn mplace_projection(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n-        proj_elem: &mir::PlaceElem<'tcx>,\n+        proj_elem: mir::PlaceElem<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n-        Ok(match *proj_elem {\n+        Ok(match proj_elem {\n             Field(field, _) => self.mplace_field(base, field.index())?,\n             Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n             Deref => self.deref_operand(base.into())?,\n@@ -605,10 +605,10 @@ where\n     pub fn place_projection(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n+        &proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n-        Ok(match *proj_elem {\n+        Ok(match proj_elem {\n             Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n@@ -634,7 +634,7 @@ where\n         };\n \n         for elem in place.projection.iter() {\n-            place_ty = self.place_projection(place_ty, elem)?\n+            place_ty = self.place_projection(place_ty, &elem)?\n         }\n \n         self.dump_place(place_ty.place);"}, {"sha": "c75e8414e8ccaf38a7f205fcb11e3c7599d2ce66", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -449,7 +449,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     let type_length = instance\n         .substs\n         .iter()\n-        .flat_map(|&arg| arg.walk())\n+        .flat_map(|arg| arg.walk())\n         .filter(|arg| match arg.unpack() {\n             GenericArgKind::Type(_) | GenericArgKind::Const(_) => true,\n             GenericArgKind::Lifetime(_) => false,"}, {"sha": "05a7c78d59d395fa200da22501999273a92ebce0", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -206,8 +206,8 @@ where\n     F: FnMut(Local) -> bool,\n {\n     let mut projection = place.projection;\n-    while let [ref proj_base @ .., proj_elem] = projection {\n-        match *proj_elem {\n+    while let &[ref proj_base @ .., proj_elem] = projection {\n+        match proj_elem {\n             ProjectionElem::Index(index) if in_local(index) => return true,\n \n             ProjectionElem::Deref"}, {"sha": "80094e154bf66dcbc3d56f27b5ca8b4898ce191e", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -432,7 +432,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n         &mut self,\n         place_local: Local,\n         proj_base: &[PlaceElem<'tcx>],\n-        elem: &PlaceElem<'tcx>,\n+        elem: PlaceElem<'tcx>,\n         context: PlaceContext,\n         location: Location,\n     ) {"}, {"sha": "e4129f447d532532b17355d4139b6355fc414041", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -213,31 +213,31 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n \n     fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n-            ProjectionElem::Field(idx, _) => *idx == field,\n+            ProjectionElem::Field(idx, _) => idx == field,\n             _ => false,\n         })\n     }\n \n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n             ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n-                debug_assert!(size == *min_length, \"min_length should be exact for arrays\");\n+                debug_assert!(size == min_length, \"min_length should be exact for arrays\");\n                 assert!(!from_end, \"from_end should not be used for array element ConstantIndex\");\n-                *offset == index\n+                offset == index\n             }\n             _ => false,\n         })\n     }\n \n     fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| {\n-            *e == ProjectionElem::Deref\n+            e == ProjectionElem::Deref\n         })\n     }\n \n     fn downcast_subpath(&self, path: Self::Path, variant: VariantIdx) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n-            ProjectionElem::Downcast(_, idx) => *idx == variant,\n+            ProjectionElem::Downcast(_, idx) => idx == variant,\n             _ => false,\n         })\n     }"}, {"sha": "461b13c4f63826079d97a6ce3181ff6928b16bb3", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -132,7 +132,7 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor<'tcx> {\n \n             for elem in place.projection.iter() {\n                 if let PlaceElem::Index(local) = elem {\n-                    assert_ne!(*local, SELF_ARG);\n+                    assert_ne!(local, SELF_ARG);\n                 }\n             }\n         }\n@@ -171,7 +171,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n \n             for elem in place.projection.iter() {\n                 if let PlaceElem::Index(local) = elem {\n-                    assert_ne!(*local, SELF_ARG);\n+                    assert_ne!(local, SELF_ARG);\n                 }\n             }\n         }"}, {"sha": "6caa2b48f3d45357a077032c0d3cd234d60e0335", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -340,7 +340,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             // `let _: &'static _ = &(Cell::new(1), 2).1;`\n                             let mut place_projection = &place.projection[..];\n                             // FIXME(eddyb) use a forward loop instead of a reverse one.\n-                            while let [proj_base @ .., elem] = place_projection {\n+                            while let &[ref proj_base @ .., elem] = place_projection {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n                                 let ty =\n@@ -676,7 +676,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 if has_mut_interior {\n                     let mut place_projection = place.projection;\n                     // FIXME(eddyb) use a forward loop instead of a reverse one.\n-                    while let [proj_base @ .., elem] = place_projection {\n+                    while let &[ref proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n                         let ty = Place::ty_from(place.local, proj_base, self.body, self.tcx)"}, {"sha": "147c09d8f3af66a587706c57647303049a1016d3", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -1042,7 +1042,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n             {\n                 if let Some(i) =\n-                    source.projection.iter().rposition(|elem| *elem == ProjectionElem::Deref)\n+                    source.projection.iter().rposition(|elem| elem == ProjectionElem::Deref)\n                 {\n                     let proj_base = &source.projection[..i];\n "}, {"sha": "cb896810951baee40f1bf3d8fdbaf19aa4af1ddd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -176,7 +176,7 @@ where\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors.\n                 for predicate in *predicates.skip_binder() {\n-                    let trait_ref = match *predicate {\n+                    let trait_ref = match predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n                         ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n                         ty::ExistentialPredicate::AutoTrait(def_id) => {"}, {"sha": "1a536b6a4294feb96f7d28cb2ab9c9bca01e567e", "filename": "src/librustc_symbol_mangling/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_symbol_mangling%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_symbol_mangling%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Fv0.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -477,7 +477,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         for predicate in predicates {\n-            match *predicate {\n+            match predicate {\n                 ty::ExistentialPredicate::Trait(trait_ref) => {\n                     // Use a type that can't appear in defaults of type parameters.\n                     let dummy_self = self.tcx.mk_ty_infer(ty::FreshTy(0));"}, {"sha": "f78a6207a3ab53558b5b171f3b573821c90a42aa", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -647,7 +647,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // shifting.\n         let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n         let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n-            substs.iter().enumerate().map(|(index, subst)| (*subst, id_substs[index])).collect();\n+            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n \n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n@@ -890,7 +890,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 // during codegen.\n \n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, &kind)| {\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n                     if index < generics.parent_count {\n                         // Accommodate missing regions in the parent kinds...\n                         self.fold_kind_mapping_missing_regions_to_empty(kind)\n@@ -905,7 +905,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n             ty::Generator(def_id, substs, movability) => {\n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, &kind)| {\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n                     if index < generics.parent_count {\n                         // Accommodate missing regions in the parent kinds...\n                         self.fold_kind_mapping_missing_regions_to_empty(kind)"}, {"sha": "433e1e46f6bba24d74fc1f6b201e8c5ff43b2fc0", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -281,9 +281,8 @@ impl AutoTraitFinder<'tcx> {\n             },\n         }));\n \n-        let computed_preds = param_env.caller_bounds.iter().cloned();\n-        let mut user_computed_preds: FxHashSet<_> =\n-            user_env.caller_bounds.iter().cloned().collect();\n+        let computed_preds = param_env.caller_bounds.iter();\n+        let mut user_computed_preds: FxHashSet<_> = user_env.caller_bounds.iter().collect();\n \n         let mut new_env = param_env;\n         let dummy_cause = ObligationCause::dummy();\n@@ -768,12 +767,12 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                ty::PredicateKind::RegionOutlives(ref binder) => {\n+                &ty::PredicateKind::RegionOutlives(binder) => {\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                ty::PredicateKind::TypeOutlives(ref binder) => {\n+                &ty::PredicateKind::TypeOutlives(binder) => {\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "2d4d582c939b6e925a64c4399a97a3809e8b879f", "filename": "src/librustc_trait_selection/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -87,7 +87,7 @@ fn environment<'tcx>(\n         NodeKind::TraitImpl => {\n             let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n \n-            inputs.extend(trait_ref.substs.iter().flat_map(|&arg| arg.walk()));\n+            inputs.extend(trait_ref.substs.iter().flat_map(|arg| arg.walk()));\n         }\n \n         // In an inherent impl, we assume that the receiver type and all its"}, {"sha": "f8b33b782c017fe86aa6daf537ffc098661d5772", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -146,9 +146,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             continue;\n                         }\n \n-                        if self.error_implies(&error2.predicate, &error.predicate)\n+                        if self.error_implies(error2.predicate, error.predicate)\n                             && !(error2.index >= error.index\n-                                && self.error_implies(&error.predicate, &error2.predicate))\n+                                && self.error_implies(error.predicate, error2.predicate))\n                         {\n                             info!(\"skipping {:?} (implied by {:?})\", error, error2);\n                             is_suppressed[index] = true;\n@@ -504,7 +504,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ty::PredicateKind::RegionOutlives(ref predicate) => {\n                         let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self\n-                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .region_outlives_predicate(&obligation.cause, predicate)\n                             .err()\n                             .unwrap();\n                         struct_span_err!(\n@@ -959,7 +959,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n trait InferCtxtPrivExt<'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool;\n+    fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool;\n \n     fn report_fulfillment_error(\n         &self,\n@@ -1049,7 +1049,7 @@ trait InferCtxtPrivExt<'tcx> {\n impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+    fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool {\n         if cond == error {\n             return true;\n         }\n@@ -1062,7 +1062,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        for obligation in super::elaborate_predicates(self.tcx, std::iter::once(*cond)) {\n+        for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n             if let ty::PredicateKind::Trait(implication, _) = obligation.predicate.kind() {\n                 let error = error.to_poly_trait_ref();\n                 let implication = implication.to_poly_trait_ref();"}, {"sha": "252c84fba878493d3365f5c805815cf47c120948", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -372,7 +372,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::RegionOutlives(ref binder) => {\n+            &ty::PredicateKind::RegionOutlives(binder) => {\n                 match infcx.region_outlives_predicate(&obligation.cause, binder) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n@@ -475,7 +475,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::Subtype(subtype) => {\n+            &ty::PredicateKind::Subtype(subtype) => {\n                 match self.selcx.infcx().subtype_predicate(\n                     &obligation.cause,\n                     obligation.param_env,"}, {"sha": "b45de72ab026223d93908a51567ce35f1f3887d4", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -298,7 +298,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     );\n \n     let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.into_iter().cloned())\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.into_iter())\n             .map(|obligation| obligation.predicate)\n             .collect();\n "}, {"sha": "5befc797a517a39573862a48ac70447a307931d6", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -658,7 +658,6 @@ fn receiver_is_dispatchable<'tcx>(\n         let caller_bounds: Vec<Predicate<'tcx>> = param_env\n             .caller_bounds\n             .iter()\n-            .cloned()\n             .chain(iter::once(unsize_predicate))\n             .chain(iter::once(trait_predicate))\n             .collect();"}, {"sha": "cd5d0be003aaf784bf3f832038f4873a53f556b8", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -872,7 +872,7 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n         obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::ParamEnv,\n-        obligation.param_env.caller_bounds.iter().cloned(),\n+        obligation.param_env.caller_bounds.iter(),\n     );\n }\n \n@@ -1541,14 +1541,14 @@ fn assoc_ty_def(\n crate trait ProjectionCacheKeyExt<'tcx>: Sized {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n-        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+        predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self>;\n }\n \n impl<'tcx> ProjectionCacheKeyExt<'tcx> for ProjectionCacheKey<'tcx> {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n-        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+        predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,"}, {"sha": "b27fba2f82ba5115930f35044465a6159c386a3d", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -415,13 +415,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(t, _) => {\n+            &ty::PredicateKind::Trait(t, _) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n-                let obligation = obligation.with(*t);\n+                let obligation = obligation.with(t);\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n-            ty::PredicateKind::Subtype(p) => {\n+            &ty::PredicateKind::Subtype(p) => {\n                 // Does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -463,8 +463,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::Projection(data) => {\n-                let project_obligation = obligation.with(*data);\n+            &ty::PredicateKind::Projection(data) => {\n+                let project_obligation = obligation.with(data);\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(mut subobligations)) => {\n                         self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n@@ -962,7 +962,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n \n         if let Some(c) =\n-            self.check_candidate_cache(stack.obligation.param_env, &cache_fresh_trait_pred)\n+            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n         {\n             debug!(\"CACHE HIT: SELECT({:?})={:?}\", cache_fresh_trait_pred, c);\n             return c;\n@@ -1238,7 +1238,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn check_candidate_cache(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n-        cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>,\n+        cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>> {\n         let tcx = self.tcx();\n         let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;\n@@ -3145,7 +3145,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // Check that the source struct with the target's\n                 // unsizing parameters is equal to the target.\n-                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, &k)| {\n+                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, k)| {\n                     if unsizing_params.contains(i as u32) { substs_b[i] } else { k }\n                 }));\n                 let new_struct = tcx.mk_adt(def, substs);"}, {"sha": "f6f0c62c120f1c703f5e9c04636dd132b235b3ff", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -108,9 +108,9 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n         }\n \n         // Don't recurse if this trait alias is already on the stack for the DFS search.\n-        let anon_pred = anonymize_predicate(tcx, &pred);\n+        let anon_pred = anonymize_predicate(tcx, pred);\n         if item.path.iter().rev().skip(1).any(|(tr, _)| {\n-            anonymize_predicate(tcx, &tr.without_const().to_predicate(tcx)) == anon_pred\n+            anonymize_predicate(tcx, tr.without_const().to_predicate(tcx)) == anon_pred\n         }) {\n             return false;\n         }"}, {"sha": "714ca7a30cff63b26fbef84f7d25d69cc503cf20", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -66,7 +66,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n-    predicate: &ty::Predicate<'tcx>,\n+    predicate: ty::Predicate<'tcx>,\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };"}, {"sha": "1b059fa3dbdf0cd14b9843f38401b23973bd9fc8", "filename": "src/librustc_ty/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -11,7 +11,7 @@ type NeedsDropResult<T> = Result<T, AlwaysRequiresDrop>;\n \n fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let adt_fields =\n-        move |adt_def: &ty::AdtDef| tcx.adt_drop_tys(adt_def.did).map(|tys| tys.iter().copied());\n+        move |adt_def: &ty::AdtDef| tcx.adt_drop_tys(adt_def.did).map(|tys| tys.iter());\n     // If we don't know a type doesn't need drop, for example if it's a type\n     // parameter without a `Copy` bound, then we conservatively return that it\n     // needs drop."}, {"sha": "206619588c71dad3d6f5b91e752622d4090fe9eb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n-                    self.deduce_sig_from_projection(None, &pb)\n+                    self.deduce_sig_from_projection(None, pb)\n                 });\n                 let kind = object_type\n                     .principal_def_id()\n@@ -206,8 +206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let ty::PredicateKind::Projection(ref proj_predicate) =\n-                    obligation.predicate.kind()\n+                if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n@@ -238,7 +237,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn deduce_sig_from_projection(\n         &self,\n         cause_span: Option<Span>,\n-        projection: &ty::PolyProjectionPredicate<'tcx>,\n+        projection: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<ExpectedSig<'tcx>> {\n         let tcx = self.tcx;\n \n@@ -628,7 +627,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate.kind() {\n+            if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind() {\n                 self.deduce_future_output_from_projection(obligation.cause.span, proj_predicate)\n             } else {\n                 None\n@@ -649,7 +648,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn deduce_future_output_from_projection(\n         &self,\n         cause_span: Span,\n-        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+        predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         debug!(\"deduce_future_output_from_projection(predicate={:?})\", predicate);\n "}, {"sha": "e27c2e45039102a15017eb6554b46df2731e94fd", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -201,7 +201,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // just to look for all the predicates directly.\n \n     assert_eq!(dtor_predicates.parent, None);\n-    for (predicate, predicate_sp) in dtor_predicates.predicates {\n+    for &(predicate, predicate_sp) in dtor_predicates.predicates {\n         // (We do not need to worry about deep analysis of type\n         // expressions etc because the Drop impls are already forced\n         // to take on a structure that is roughly an alpha-renaming of\n@@ -224,7 +224,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // This implementation solves (Issue #59497) and (Issue #58311).\n         // It is unclear to me at the moment whether the approach based on `relate`\n         // could be extended easily also to the other `Predicate`.\n-        let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n+        let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (predicate.kind(), p.kind()) {\n                 (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n@@ -237,12 +237,12 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             }\n         };\n \n-        if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n+        if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n             let self_descr = tcx.def_kind(self_type_did).descr(self_type_did.to_def_id());\n             struct_span_err!(\n                 tcx.sess,\n-                *predicate_sp,\n+                predicate_sp,\n                 E0367,\n                 \"`Drop` impl requires `{}` but the {} it is implemented for does not\",\n                 predicate,"}, {"sha": "da711b9d48042d1d3d1f697e5df5a5132a6890a0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -2759,7 +2759,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         ty::GenericPredicates {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(self.param_env.caller_bounds.iter().filter_map(\n-                |&predicate| match predicate.kind() {\n+                |predicate| match predicate.kind() {\n                     ty::PredicateKind::Trait(ref data, _)\n                         if data.skip_binder().self_ty().is_param(index) =>\n                     {"}, {"sha": "e154184f1822ce8747ca2d475d60e442a359d66d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -819,8 +819,8 @@ fn check_where_clauses<'tcx, 'fcx>(\n     debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n-        predicates.predicates.iter().zip(predicates.spans.iter()).flat_map(|(p, sp)| {\n-            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, *sp)\n+        predicates.predicates.iter().zip(predicates.spans.iter()).flat_map(|(&p, &sp)| {\n+            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, sp)\n         });\n \n     for obligation in wf_obligations.chain(default_obligations) {\n@@ -900,7 +900,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                     if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n                         trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n                         let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-                        for (i, &arg) in substs.iter().enumerate() {\n+                        for (i, arg) in substs.iter().enumerate() {\n                             let arg_is_param = match arg.unpack() {\n                                 GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n "}, {"sha": "bf9a4d1cb6ca9b8232fe580e7af64f590933df23", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -223,7 +223,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n         .iter()\n         .enumerate()\n         .filter(|&(idx, _)| !constrained_params.contains(&(idx as u32)))\n-        .map(|(_, arg)| *arg)\n+        .map(|(_, arg)| arg)\n         .collect()\n }\n \n@@ -323,16 +323,13 @@ fn check_predicates<'tcx>(\n     // which is sound because we forbid impls like the following\n     //\n     // impl<D: Debug> AlwaysApplicable for D { }\n-    let always_applicable_traits = impl1_predicates\n-        .predicates\n-        .iter()\n-        .filter(|predicate| {\n+    let always_applicable_traits =\n+        impl1_predicates.predicates.iter().copied().filter(|&predicate| {\n             matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::AlwaysApplicable)\n             )\n-        })\n-        .copied();\n+        });\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for ty in tcx.impl_trait_ref(impl1_def_id).unwrap().substs.types() {\n@@ -355,12 +352,12 @@ fn check_predicates<'tcx>(\n \n     for predicate in impl1_predicates.predicates {\n         if !impl2_predicates.predicates.contains(&predicate) {\n-            check_specialization_on(tcx, &predicate, span)\n+            check_specialization_on(tcx, predicate, span)\n         }\n     }\n }\n \n-fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'tcx>, span: Span) {\n+fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n     match predicate.kind() {\n         // Global predicates are either always true or always false, so we\n@@ -393,7 +390,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'t\n \n fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    predicate: &ty::Predicate<'tcx>,\n+    predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n     match predicate.kind() {\n         ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {"}, {"sha": "eee0f764373a4d2acc864125e22d16cb4da1be93", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::Tuple(subtys) => {\n-                for &subty in subtys {\n+                for subty in subtys {\n                     self.add_constraints_from_ty(current, subty.expect_ty(), variance);\n                 }\n             }"}, {"sha": "1621c7f947c3314d96ffa3f0187985810acb633f", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45127211566c53bac386b66909a830649182ab7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45127211566c53bac386b66909a830649182ab7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=45127211566c53bac386b66909a830649182ab7a", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n \n-        let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.iter().copied())\n+        let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.iter())\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n                 if let ty::PredicateKind::Trait(poly_trait_ref, _) = obligation.predicate.kind() {\n@@ -179,7 +179,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                                 .substs\n                                 .iter()\n                                 .skip(1)\n-                                .cloned()\n                                 .collect::<Vec<_>>();\n                             implements_trait(cx, ty_empty_region, t.def_id(), ty_params)\n                         })"}]}