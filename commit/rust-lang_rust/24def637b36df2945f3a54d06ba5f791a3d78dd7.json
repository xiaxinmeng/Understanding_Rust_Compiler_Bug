{"sha": "24def637b36df2945f3a54d06ba5f791a3d78dd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZGVmNjM3YjM2ZGYyOTQ1ZjNhNTRkMDZiYTVmNzkxYTNkNzhkZDc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-05-03T16:40:07Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-05-03T16:42:00Z"}, "message": "Wire up tidy dependency checks for cg_clif", "tree": {"sha": "7ae0a010e3486b4796bf73952edfe45e52d4fdb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ae0a010e3486b4796bf73952edfe45e52d4fdb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24def637b36df2945f3a54d06ba5f791a3d78dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24def637b36df2945f3a54d06ba5f791a3d78dd7", "html_url": "https://github.com/rust-lang/rust/commit/24def637b36df2945f3a54d06ba5f791a3d78dd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24def637b36df2945f3a54d06ba5f791a3d78dd7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5db01aae99a82675565c333ece511daa31d545cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5db01aae99a82675565c333ece511daa31d545cb", "html_url": "https://github.com/rust-lang/rust/commit/5db01aae99a82675565c333ece511daa31d545cb"}], "stats": {"total": 134, "additions": 113, "deletions": 21}, "files": [{"sha": "aa27ce6a72316ec592b09a9d530c358a804c6024", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 113, "deletions": 21, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/24def637b36df2945f3a54d06ba5f791a3d78dd7/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24def637b36df2945f3a54d06ba5f791a3d78dd7/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=24def637b36df2945f3a54d06ba5f791a3d78dd7", "patch": "@@ -44,6 +44,23 @@ const EXCEPTIONS: &[(&str, &str)] = &[\n     (\"fortanix-sgx-abi\", \"MPL-2.0\"), // libstd but only for `sgx` target\n ];\n \n+const EXCEPTIONS_CRANELIFT: &[(&str, &str)] = &[\n+    (\"cranelift-bforest\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-codegen\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-codegen-meta\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-codegen-shared\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-entity\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-frontend\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-jit\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-module\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-native\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-object\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"libloading\", \"ISC\"),\n+    (\"mach\", \"BSD-2-Clause\"),\n+    (\"regalloc\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"target-lexicon\", \"Apache-2.0 WITH LLVM-exception\"),\n+];\n+\n /// These are the root crates that are part of the runtime. The licenses for\n /// these and all their dependencies *must not* be in the exception list.\n const RUNTIME_CRATES: &[&str] = &[\"std\", \"core\", \"alloc\", \"test\", \"panic_abort\", \"panic_unwind\"];\n@@ -212,6 +229,59 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"winapi-x86_64-pc-windows-gnu\",\n ];\n \n+const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n+    \"anyhow\",\n+    \"ar\",\n+    \"autocfg\",\n+    \"bitflags\",\n+    \"byteorder\",\n+    \"cfg-if\",\n+    \"cranelift-bforest\",\n+    \"cranelift-codegen\",\n+    \"cranelift-codegen-meta\",\n+    \"cranelift-codegen-shared\",\n+    \"cranelift-entity\",\n+    \"cranelift-frontend\",\n+    \"cranelift-jit\",\n+    \"cranelift-module\",\n+    \"cranelift-native\",\n+    \"cranelift-object\",\n+    \"crc32fast\",\n+    \"errno\",\n+    \"errno-dragonfly\",\n+    \"gcc\",\n+    \"gimli\",\n+    \"hashbrown\",\n+    \"indexmap\",\n+    \"libc\",\n+    \"libloading\",\n+    \"log\",\n+    \"mach\",\n+    \"object\",\n+    \"proc-macro2\",\n+    \"quote\",\n+    \"regalloc\",\n+    \"region\",\n+    \"rustc-hash\",\n+    \"smallvec\",\n+    \"syn\",\n+    \"target-lexicon\",\n+    \"thiserror\",\n+    \"thiserror-impl\",\n+    \"unicode-xid\",\n+    \"winapi\",\n+    \"winapi-i686-pc-windows-gnu\",\n+    \"winapi-x86_64-pc-windows-gnu\",\n+];\n+\n+const FORBIDDEN_TO_HAVE_DUPLICATES: &[&str] = &[\n+    // These two crates take quite a long time to build, so don't allow two versions of them\n+    // to accidentally sneak into our dependency graph, in order to ensure we keep our CI times\n+    // under control.\n+    \"cargo\",\n+    \"rustc-ap-rustc_ast\",\n+];\n+\n /// Dependency checks.\n ///\n /// `root` is path to the directory with the root `Cargo.toml` (for the workspace). `cargo` is path\n@@ -222,17 +292,39 @@ pub fn check(root: &Path, cargo: &Path, bad: &mut bool) {\n         .manifest_path(root.join(\"Cargo.toml\"))\n         .features(cargo_metadata::CargoOpt::AllFeatures);\n     let metadata = t!(cmd.exec());\n-    check_exceptions(&metadata, bad);\n-    check_dependencies(&metadata, bad);\n-    check_crate_duplicate(&metadata, bad);\n+    let runtime_ids = compute_runtime_crates(&metadata);\n+    check_exceptions(&metadata, EXCEPTIONS, runtime_ids, bad);\n+    check_dependencies(&metadata, PERMITTED_DEPENDENCIES, RESTRICTED_DEPENDENCY_CRATES, bad);\n+    check_crate_duplicate(&metadata, FORBIDDEN_TO_HAVE_DUPLICATES, bad);\n+\n+    // Check rustc_codegen_cranelift independently as it has it's own workspace.\n+    let mut cmd = cargo_metadata::MetadataCommand::new();\n+    cmd.cargo_path(cargo)\n+        .manifest_path(root.join(\"compiler/rustc_codegen_cranelift/Cargo.toml\"))\n+        .features(cargo_metadata::CargoOpt::AllFeatures);\n+    let metadata = t!(cmd.exec());\n+    let runtime_ids = HashSet::new();\n+    check_exceptions(&metadata, EXCEPTIONS_CRANELIFT, runtime_ids, bad);\n+    check_dependencies(\n+        &metadata,\n+        PERMITTED_CRANELIFT_DEPENDENCIES,\n+        &[\"rustc_codegen_cranelift\"],\n+        bad,\n+    );\n+    check_crate_duplicate(&metadata, &[], bad);\n }\n \n /// Check that all licenses are in the valid list in `LICENSES`.\n ///\n /// Packages listed in `EXCEPTIONS` are allowed for tools.\n-fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n+fn check_exceptions(\n+    metadata: &Metadata,\n+    exceptions: &[(&str, &str)],\n+    runtime_ids: HashSet<&PackageId>,\n+    bad: &mut bool,\n+) {\n     // Validate the EXCEPTIONS list hasn't changed.\n-    for (name, license) in EXCEPTIONS {\n+    for (name, license) in exceptions {\n         // Check that the package actually exists.\n         if !metadata.packages.iter().any(|p| p.name == *name) {\n             tidy_error!(\n@@ -264,8 +356,7 @@ fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n         }\n     }\n \n-    let exception_names: Vec<_> = EXCEPTIONS.iter().map(|(name, _license)| *name).collect();\n-    let runtime_ids = compute_runtime_crates(metadata);\n+    let exception_names: Vec<_> = exceptions.iter().map(|(name, _license)| *name).collect();\n \n     // Check if any package does not have a valid license.\n     for pkg in &metadata.packages {\n@@ -300,9 +391,14 @@ fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n /// `true` if a check failed.\n ///\n /// Specifically, this checks that the dependencies are on the `PERMITTED_DEPENDENCIES`.\n-fn check_dependencies(metadata: &Metadata, bad: &mut bool) {\n+fn check_dependencies(\n+    metadata: &Metadata,\n+    permitted_dependencies: &[&'static str],\n+    restricted_dependency_crates: &[&'static str],\n+    bad: &mut bool,\n+) {\n     // Check that the PERMITTED_DEPENDENCIES does not have unused entries.\n-    for name in PERMITTED_DEPENDENCIES {\n+    for name in permitted_dependencies {\n         if !metadata.packages.iter().any(|p| p.name == *name) {\n             tidy_error!(\n                 bad,\n@@ -313,12 +409,12 @@ fn check_dependencies(metadata: &Metadata, bad: &mut bool) {\n         }\n     }\n     // Get the list in a convenient form.\n-    let permitted_dependencies: HashSet<_> = PERMITTED_DEPENDENCIES.iter().cloned().collect();\n+    let permitted_dependencies: HashSet<_> = permitted_dependencies.iter().cloned().collect();\n \n     // Check dependencies.\n     let mut visited = BTreeSet::new();\n     let mut unapproved = BTreeSet::new();\n-    for &krate in RESTRICTED_DEPENDENCY_CRATES.iter() {\n+    for &krate in restricted_dependency_crates.iter() {\n         let pkg = pkg_from_name(metadata, krate);\n         let mut bad =\n             check_crate_dependencies(&permitted_dependencies, metadata, &mut visited, pkg);\n@@ -371,16 +467,12 @@ fn check_crate_dependencies<'a>(\n }\n \n /// Prevents multiple versions of some expensive crates.\n-fn check_crate_duplicate(metadata: &Metadata, bad: &mut bool) {\n-    const FORBIDDEN_TO_HAVE_DUPLICATES: &[&str] = &[\n-        // These two crates take quite a long time to build, so don't allow two versions of them\n-        // to accidentally sneak into our dependency graph, in order to ensure we keep our CI times\n-        // under control.\n-        \"cargo\",\n-        \"rustc-ap-rustc_ast\",\n-    ];\n-\n-    for &name in FORBIDDEN_TO_HAVE_DUPLICATES {\n+fn check_crate_duplicate(\n+    metadata: &Metadata,\n+    forbidden_to_have_duplicates: &[&str],\n+    bad: &mut bool,\n+) {\n+    for &name in forbidden_to_have_duplicates {\n         let matches: Vec<_> = metadata.packages.iter().filter(|pkg| pkg.name == name).collect();\n         match matches.len() {\n             0 => {"}]}