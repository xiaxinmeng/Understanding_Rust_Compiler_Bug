{"sha": "b32d7b592306a2784585e842193db1546a2f9587", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMmQ3YjU5MjMwNmEyNzg0NTg1ZTg0MjE5M2RiMTU0NmEyZjk1ODc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-18T19:53:50Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-24T17:59:44Z"}, "message": "syntax: Merge keywords and remaining special idents in one list\n\nSimplify the macro used for generation of keywords\nMake `Keyword::ident` private", "tree": {"sha": "4d12769084adfda5aad64a7cb699155f9ee751cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d12769084adfda5aad64a7cb699155f9ee751cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b32d7b592306a2784585e842193db1546a2f9587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b32d7b592306a2784585e842193db1546a2f9587", "html_url": "https://github.com/rust-lang/rust/commit/b32d7b592306a2784585e842193db1546a2f9587", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b32d7b592306a2784585e842193db1546a2f9587/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "923001ebb7980ec425e6df561575bccaf5f90240", "url": "https://api.github.com/repos/rust-lang/rust/commits/923001ebb7980ec425e6df561575bccaf5f90240", "html_url": "https://github.com/rust-lang/rust/commit/923001ebb7980ec425e6df561575bccaf5f90240"}], "stats": {"total": 345, "additions": 145, "deletions": 200}, "files": [{"sha": "b6adce4202e64b3dabe218412659cf7a55c7482f", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -18,7 +18,7 @@ use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n use syntax::ptr::P;\n-use syntax::parse::token;\n+use syntax::parse::token::keywords;\n use syntax::util::move_map::MoveMap;\n \n pub trait Folder : Sized {\n@@ -867,7 +867,7 @@ pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n     let config = folder.fold_meta_items(config);\n \n     let crate_mod = folder.fold_item(hir::Item {\n-        name: token::special_idents::Invalid.name,\n+        name: keywords::Invalid.name(),\n         attrs: attrs,\n         id: DUMMY_NODE_ID,\n         vis: hir::Public,"}, {"sha": "c2eb008c658fdae70b62f0ef9b38c39d6dbc1477", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -14,9 +14,8 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n use syntax::errors;\n-use syntax::parse::token::{self, BinOpToken};\n+use syntax::parse::token::{self, keywords, BinOpToken};\n use syntax::parse::lexer::comments;\n-use syntax::parse;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n@@ -2209,9 +2208,8 @@ impl<'a> State<'a> {\n             hir::TyInfer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n                 match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _) if\n-                        path1.node.name ==\n-                            parse::token::special_idents::Invalid.name => {\n+                    PatKind::Ident(_, ref path1, _)\n+                            if path1.node.name == keywords::Invalid.name() => {\n                         // Do nothing.\n                     }\n                     _ => {"}, {"sha": "eecdd1a0912f04604142700a4c4dbb10625aec7a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -1578,7 +1578,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;\n-                if name != keywords::SelfValue.ident.name {\n+                if name != keywords::SelfValue.name() {\n                     if !self.warn_about_unused(sp, p_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(p_id, sp, var, true);"}, {"sha": "23eb5a56c8439e4f25469f09bb1c1137d1216d63", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -29,7 +29,7 @@ use std::fmt;\n use std::mem::replace;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use util::nodemap::NodeMap;\n \n use hir;\n@@ -245,7 +245,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-        if lifetime_ref.name == special_idents::StaticLifetime.name {\n+        if lifetime_ref.name == keywords::StaticLifetime.name() {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n@@ -673,7 +673,7 @@ impl<'a> LifetimeContext<'a> {\n             let lifetime_i = &lifetimes[i];\n \n             for lifetime in lifetimes {\n-                if lifetime.lifetime.name == special_idents::StaticLifetime.name {\n+                if lifetime.lifetime.name == keywords::StaticLifetime.name() {\n                     span_err!(self.sess, lifetime.lifetime.span, E0262,\n                         \"invalid lifetime parameter name: `{}`\", lifetime.lifetime.name);\n                 }"}, {"sha": "9ec05a9b2927caa098e20859914f8bcb9e5cee91", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -200,7 +200,7 @@ pub struct ArgDecl<'tcx> {\n     /// and has to be collected from multiple actual arguments.\n     pub spread: bool,\n \n-    /// Either special_idents::invalid or the name of a single-binding\n+    /// Either keywords::Invalid or the name of a single-binding\n     /// pattern associated with this argument. Useful for debuginfo.\n     pub debug_name: Name\n }"}, {"sha": "5bde6df5123d69545303f4c2205be66332705f51", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -1069,7 +1069,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn mk_self_type(&self) -> Ty<'tcx> {\n-        self.mk_param(subst::SelfSpace, 0, keywords::SelfType.ident.name)\n+        self.mk_param(subst::SelfSpace, 0, keywords::SelfType.name())\n     }\n \n     pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {"}, {"sha": "709ec051ddcd6e2abed8270dae6830a280ae1d35", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -533,7 +533,7 @@ impl ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(subst::SelfSpace, 0, keywords::SelfType.ident.name)\n+        ParamTy::new(subst::SelfSpace, 0, keywords::SelfType.name())\n     }\n \n     pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {"}, {"sha": "b088425d58a2a12fb4a7c0a96c1d434fc08c3936", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -18,7 +18,7 @@ use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n+use syntax::parse::token::keywords;\n \n pub struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n@@ -238,7 +238,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                 ty::UpvarCapture::ByRef(..) => true\n             });\n             let mut decl = UpvarDecl {\n-                debug_name: token::special_idents::invalid.name,\n+                debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref\n             };\n             if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n@@ -296,7 +296,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n                                    argument_extent, &lvalue, ty);\n \n-                let mut name = token::special_idents::invalid.name;\n+                let mut name = keywords::Invalid.name();\n                 if let Some(pat) = pattern {\n                     if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n                         if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {"}, {"sha": "7ec3c9345be58fd16bed4092c8bc46d4e257e95f", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -22,7 +22,7 @@ use machine;\n use type_of;\n \n use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token;\n+use syntax::parse::token::keywords;\n \n use std::ops::Deref;\n use std::rc::Rc;\n@@ -286,7 +286,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         alloca: lltemp,\n                         address_operations: &ops\n                     };\n-                    declare_local(bcx, token::special_idents::Invalid.name,\n+                    declare_local(bcx, keywords::Invalid.name(),\n                                   tupled_arg_ty, scope, variable_access,\n                                   VariableKind::ArgumentVariable(arg_index + i + 1),\n                                   bcx.fcx().span.unwrap_or(DUMMY_SP));"}, {"sha": "d6e64ccd259e6efb72e67b4d1a90caeebac2a696", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -73,7 +73,7 @@ use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n \n use rustc::hir::print as pprust;\n use rustc::hir;\n@@ -1313,7 +1313,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n             match find_bound_for_assoc_item(this,\n                                             trait_node_id,\n-                                            token::keywords::SelfType.ident.name,\n+                                            keywords::SelfType.name(),\n                                             assoc_name,\n                                             span) {\n                 Ok(bound) => bound,"}, {"sha": "cdaea85da877cd5f13689b903fd8f59c11e66a0b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -120,7 +120,7 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Spanned};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -2851,7 +2851,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 method_ty\n             }\n             Err(error) => {\n-                if method_name.node != special_idents::Invalid.name {\n+                if method_name.node != keywords::Invalid.name() {\n                     method::report_error(fcx, method_name.span, expr_t,\n                                          method_name.node, Some(rcvr), error);\n                 }\n@@ -2990,7 +2990,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n             fcx.tcx().sess.span_err(expr.span, &msg);\n             fcx.write_ty(expr.id, field_ty);\n-        } else if field.node == special_idents::Invalid.name {\n+        } else if field.node == keywords::Invalid.name() {\n             fcx.write_error(expr.id);\n         } else if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n             fcx.type_error_struct(field.span,\n@@ -3780,7 +3780,7 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                     method::MethodError::PrivateMatch(def) => Some(def),\n                     _ => None,\n                 };\n-                if item_name != special_idents::Invalid.name {\n+                if item_name != keywords::Invalid.name() {\n                     method::report_error(fcx, span, ty, item_name, None, error);\n                 }\n                 def"}, {"sha": "3bfd53ceadae8db2cfa61f86e78f23ad4d96b924", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -472,7 +472,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let name = match space {\n             TypeSpace => ast_generics.ty_params[index].name,\n-            SelfSpace => keywords::SelfType.ident.name,\n+            SelfSpace => keywords::SelfType.name(),\n             FnSpace => bug!(\"Fn space occupied?\"),\n         };\n "}, {"sha": "4a6f7a6a2ef48f9dbaf797c7e6222cfc43b443af", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -1655,7 +1655,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let def = ty::TypeParameterDef {\n         space: SelfSpace,\n         index: 0,\n-        name: keywords::SelfType.ident.name,\n+        name: keywords::SelfType.name(),\n         def_id: ccx.tcx.map.local_def_id(param_id),\n         default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: None,"}, {"sha": "da792b363f0a5003a5a21bde7b62240e1e3a4298", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -2666,7 +2666,7 @@ fn resolve_type(cx: &DocContext,\n             hir::TyFloat(ast::FloatTy::F64) => return Primitive(F64),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(keywords::SelfType.ident.to_string());\n+            return Generic(keywords::SelfType.name().to_string());\n         }\n         Def::SelfTy(..) | Def::TyParam(..) => true,\n         _ => false,"}, {"sha": "b589eacb46d99de6fa643b254cd36a50d928a2e4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -13,9 +13,7 @@ use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n-use parse::token::{keywords, special_idents};\n-use parse::token::InternedString;\n-use parse::token;\n+use parse::token::{self, keywords, InternedString};\n use ptr::P;\n \n // Transitional reexports so qquote can find the paths it is looking for\n@@ -602,7 +600,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, keywords::SelfValue.ident)\n+        self.expr_ident(span, keywords::SelfValue.ident())\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n@@ -1132,7 +1130,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item> {\n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: special_idents::Invalid,\n+            ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(vp),\n             vis: vis,"}, {"sha": "dd6e9a1e4a643fa9bd76708adfa84358a7c7b973", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -25,7 +25,7 @@ use fold;\n use fold::*;\n use util::move_map::MoveMap;\n use parse;\n-use parse::token::{fresh_mark, fresh_name, intern};\n+use parse::token::{fresh_mark, fresh_name, intern, keywords};\n use ptr::P;\n use util::small_vector::SmallVector;\n use visit;\n@@ -380,7 +380,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n \n             Some(rc) => match *rc {\n                 NormalTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name != parse::token::special_idents::Invalid.name {\n+                    if ident.name != keywords::Invalid.name() {\n                         fld.cx\n                             .span_err(path_span,\n                                       &format!(\"macro {}! expects no ident argument, given '{}'\",\n@@ -401,7 +401,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     expander.expand(fld.cx, span, &marked_before[..])\n                 }\n                 IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name == parse::token::special_idents::Invalid.name {\n+                    if ident.name == keywords::Invalid.name() {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n                                                 extname));\n@@ -420,7 +420,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     expander.expand(fld.cx, span, ident, marked_tts)\n                 }\n                 MacroRulesTT => {\n-                    if ident.name == parse::token::special_idents::Invalid.name {\n+                    if ident.name == keywords::Invalid.name() {\n                         fld.cx.span_err(path_span, \"macro_rules! expects an ident argument\");\n                         return SmallVector::zero();\n                     }\n@@ -893,7 +893,7 @@ fn expand_annotatable(a: Annotatable,\n             }\n             ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n-                    it.ident.name != parse::token::special_idents::Invalid.name;\n+                    it.ident.name != keywords::Invalid.name();\n \n                 if valid_ident {\n                     fld.cx.mod_push(it.ident);\n@@ -1807,7 +1807,7 @@ mod tests {\n \n     // run one of the renaming tests\n     fn run_renaming_test(t: &RenamingTest, test_idx: usize) {\n-        let invalid_name = token::special_idents::Invalid.name;\n+        let invalid_name = keywords::Invalid.name();\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_string(), conns.clone(), bic)\n         };"}, {"sha": "8bf7d839467d4779d0570372dcbe0ab5860f64dd", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -22,7 +22,7 @@ use ast::*;\n use ast;\n use attr::{ThinAttributes, ThinAttributesExt};\n use codemap::{respan, Span, Spanned};\n-use parse::token;\n+use parse::token::{self, keywords};\n use ptr::P;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;\n@@ -1015,7 +1015,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n     let config = folder.fold_meta_items(config);\n \n     let mut items = folder.fold_item(P(ast::Item {\n-        ident: token::special_idents::Invalid,\n+        ident: keywords::Invalid.ident(),\n         attrs: attrs,\n         id: ast::DUMMY_NODE_ID,\n         vis: ast::Visibility::Public,"}, {"sha": "32078c875be32fbc3f078b9b47f2a14ea7995728", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 89, "deletions": 137, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -141,7 +141,7 @@ pub enum Token {\n     /// Doc comment\n     DocComment(ast::Name),\n     // In left-hand-sides of MBE macros:\n-    /// Parse a nonterminal (name to bind, name of NT, styles of their idents)\n+    /// Parse a nonterminal (name to bind, name of NT)\n     MatchNt(ast::Ident, ast::Ident),\n     // In right-hand-sides of MBE macros:\n     /// A syntactic variable that will be filled in by macro expansion.\n@@ -271,43 +271,39 @@ impl Token {\n     /// Returns `true` if the token is a given keyword, `kw`.\n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n         match *self {\n-            Ident(id) => id.name == kw.ident.name,\n+            Ident(id) => id.name == kw.name(),\n             _ => false,\n         }\n     }\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n         match *self {\n-            Ident(id) => id.name == keywords::Super.ident.name ||\n-                         id.name == keywords::SelfValue.ident.name ||\n-                         id.name == keywords::SelfType.ident.name,\n+            Ident(id) => id.name == keywords::Super.name() ||\n+                         id.name == keywords::SelfValue.name() ||\n+                         id.name == keywords::SelfType.name(),\n             _ => false,\n         }\n     }\n \n-    /// Returns `true` if the token is either a used or reserved keyword.\n+    /// Returns `true` if the token is either a strict or reserved keyword.\n     pub fn is_any_keyword(&self) -> bool {\n-        match *self {\n-            Ident(id) => id.name >= USED_KEYWORD_START &&\n-                         id.name <= RESERVED_KEYWORD_FINAL,\n-            _ => false\n-        }\n+        self.is_strict_keyword() || self.is_reserved_keyword()\n     }\n \n-    /// Returns `true` if the token is a used keyword.\n-    pub fn is_used_keyword(&self) -> bool {\n+    /// Returns `true` if the token is a strict keyword.\n+    pub fn is_strict_keyword(&self) -> bool {\n         match *self {\n-            Ident(id) => id.name >= USED_KEYWORD_START &&\n-                         id.name <= USED_KEYWORD_FINAL,\n+            Ident(id) => id.name >= keywords::As.name() &&\n+                         id.name <= keywords::While.name(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_reserved_keyword(&self) -> bool {\n         match *self {\n-            Ident(id) => id.name >= RESERVED_KEYWORD_START &&\n-                         id.name <= RESERVED_KEYWORD_FINAL,\n+            Ident(id) => id.name >= keywords::Abstract.name() &&\n+                         id.name <= keywords::Yield.name(),\n             _ => false,\n         }\n     }\n@@ -370,148 +366,104 @@ impl fmt::Debug for Nonterminal {\n     }\n }\n \n-// Get the first \"argument\"\n-macro_rules! first {\n-    ( $first:expr, $( $remainder:expr, )* ) => ( $first )\n-}\n-\n-// Get the last \"argument\" (has to be done recursively to avoid phoney local ambiguity error)\n-macro_rules! last {\n-    ( $first:expr, $( $remainder:expr, )+ ) => ( last!( $( $remainder, )+ ) );\n-    ( $first:expr, ) => ( $first )\n-}\n-\n // In this macro, there is the requirement that the name (the number) must be monotonically\n // increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n // except starting from the next number instead of zero.\n-macro_rules! declare_special_idents_and_keywords {(\n-    // So now, in these rules, why is each definition parenthesised?\n-    // Answer: otherwise we get a spurious local ambiguity bug on the \"}\"\n-    pub mod special_idents {\n-        $( ($si_index: expr, $si_const: ident, $si_str: expr); )*\n-    }\n-\n-    pub mod keywords {\n-        'used:\n-        $( ($ukw_index: expr, $ukw_const: ident, $ukw_str: expr); )*\n-        'reserved:\n-        $( ($rkw_index: expr, $rkw_const: ident, $rkw_str: expr); )*\n-    }\n+macro_rules! declare_keywords {(\n+    $( ($index: expr, $konst: ident, $string: expr) )*\n ) => {\n-    const USED_KEYWORD_START: ast::Name = first!($( ast::Name($ukw_index), )*);\n-    const USED_KEYWORD_FINAL: ast::Name = last!($( ast::Name($ukw_index), )*);\n-    const RESERVED_KEYWORD_START: ast::Name = first!($( ast::Name($rkw_index), )*);\n-    const RESERVED_KEYWORD_FINAL: ast::Name = last!($( ast::Name($rkw_index), )*);\n-\n-    pub mod special_idents {\n-        use ast;\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $si_const: ast::Ident = ast::Ident::with_empty_ctxt(ast::Name($si_index));\n-        )*\n-    }\n-\n-    /// Rust keywords are either 'used' in the language or 'reserved' for future use.\n     pub mod keywords {\n         use ast;\n         #[derive(Clone, Copy, PartialEq, Eq)]\n         pub struct Keyword {\n-            pub ident: ast::Ident,\n+            ident: ast::Ident,\n+        }\n+        impl Keyword {\n+            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n+            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n         }\n         $(\n             #[allow(non_upper_case_globals)]\n-            pub const $ukw_const: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(ast::Name($ukw_index))\n-            };\n-        )*\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $rkw_const: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(ast::Name($rkw_index))\n+            pub const $konst: Keyword = Keyword {\n+                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n             };\n         )*\n     }\n \n     fn mk_fresh_ident_interner() -> IdentInterner {\n-        interner::StrInterner::prefill(&[$($si_str,)* $($ukw_str,)* $($rkw_str,)*])\n+        interner::StrInterner::prefill(&[$($string,)*])\n     }\n }}\n \n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n // of the reserved words, and thus tagged as \"reserved\".\n-\n-declare_special_idents_and_keywords! {\n-    pub mod special_idents {\n-        // Special identifiers\n-        (0,                          Invalid,        \"\");\n-        (1,                          __Unused1,      \"<__unused1>\");\n-        (2,                          __Unused2,      \"<__unused2>\");\n-        (3,                          __Unused3,      \"<__unused3>\");\n-        (4,                          __Unused4,      \"<__unused4>\");\n-        (5,                          __Unused5,      \"<__unused5>\");\n-        (6,                          Union,          \"union\");\n-        (7,                          Default,        \"default\");\n-        (8,                          StaticLifetime, \"'static\");\n-    }\n-\n-    pub mod keywords {\n-        // Keywords\n-        'used:\n-        (9,                          Static,     \"static\");\n-        (10,                         Super,      \"super\");\n-        (11,                         SelfValue,  \"self\");\n-        (12,                         SelfType,   \"Self\");\n-        (13,                         As,         \"as\");\n-        (14,                         Break,      \"break\");\n-        (15,                         Crate,      \"crate\");\n-        (16,                         Else,       \"else\");\n-        (17,                         Enum,       \"enum\");\n-        (18,                         Extern,     \"extern\");\n-        (19,                         False,      \"false\");\n-        (20,                         Fn,         \"fn\");\n-        (21,                         For,        \"for\");\n-        (22,                         If,         \"if\");\n-        (23,                         Impl,       \"impl\");\n-        (24,                         In,         \"in\");\n-        (25,                         Let,        \"let\");\n-        (26,                         Loop,       \"loop\");\n-        (27,                         Match,      \"match\");\n-        (28,                         Mod,        \"mod\");\n-        (29,                         Move,       \"move\");\n-        (30,                         Mut,        \"mut\");\n-        (31,                         Pub,        \"pub\");\n-        (32,                         Ref,        \"ref\");\n-        (33,                         Return,     \"return\");\n-        (34,                         Struct,     \"struct\");\n-        (35,                         True,       \"true\");\n-        (36,                         Trait,      \"trait\");\n-        (37,                         Type,       \"type\");\n-        (38,                         Unsafe,     \"unsafe\");\n-        (39,                         Use,        \"use\");\n-        (40,                         While,      \"while\");\n-        (41,                         Continue,   \"continue\");\n-        (42,                         Box,        \"box\");\n-        (43,                         Const,      \"const\");\n-        (44,                         Where,      \"where\");\n-        'reserved:\n-        (45,                         Virtual,    \"virtual\");\n-        (46,                         Proc,       \"proc\");\n-        (47,                         Alignof,    \"alignof\");\n-        (48,                         Become,     \"become\");\n-        (49,                         Offsetof,   \"offsetof\");\n-        (50,                         Priv,       \"priv\");\n-        (51,                         Pure,       \"pure\");\n-        (52,                         Sizeof,     \"sizeof\");\n-        (53,                         Typeof,     \"typeof\");\n-        (54,                         Unsized,    \"unsized\");\n-        (55,                         Yield,      \"yield\");\n-        (56,                         Do,         \"do\");\n-        (57,                         Abstract,   \"abstract\");\n-        (58,                         Final,      \"final\");\n-        (59,                         Override,   \"override\");\n-        (60,                         Macro,      \"macro\");\n-    }\n+// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// this should be rarely necessary though if the keywords are kept in alphabetic order.\n+declare_keywords! {\n+    // Invalid identifier\n+    (0,  Invalid,        \"\")\n+\n+    // Strict keywords used in the language.\n+    (1,  As,             \"as\")\n+    (2,  Box,            \"box\")\n+    (3,  Break,          \"break\")\n+    (4,  Const,          \"const\")\n+    (5,  Continue,       \"continue\")\n+    (6,  Crate,          \"crate\")\n+    (7,  Else,           \"else\")\n+    (8,  Enum,           \"enum\")\n+    (9,  Extern,         \"extern\")\n+    (10, False,          \"false\")\n+    (11, Fn,             \"fn\")\n+    (12, For,            \"for\")\n+    (13, If,             \"if\")\n+    (14, Impl,           \"impl\")\n+    (15, In,             \"in\")\n+    (16, Let,            \"let\")\n+    (17, Loop,           \"loop\")\n+    (18, Match,          \"match\")\n+    (19, Mod,            \"mod\")\n+    (20, Move,           \"move\")\n+    (21, Mut,            \"mut\")\n+    (22, Pub,            \"pub\")\n+    (23, Ref,            \"ref\")\n+    (24, Return,         \"return\")\n+    (25, SelfValue,      \"self\")\n+    (26, SelfType,       \"Self\")\n+    (27, Static,         \"static\")\n+    (28, Struct,         \"struct\")\n+    (29, Super,          \"super\")\n+    (30, Trait,          \"trait\")\n+    (31, True,           \"true\")\n+    (32, Type,           \"type\")\n+    (33, Unsafe,         \"unsafe\")\n+    (34, Use,            \"use\")\n+    (35, Where,          \"where\")\n+    (36, While,          \"while\")\n+\n+    // Keywords reserved for future use.\n+    (37, Abstract,       \"abstract\")\n+    (38, Alignof,        \"alignof\")\n+    (39, Become,         \"become\")\n+    (40, Do,             \"do\")\n+    (41, Final,          \"final\")\n+    (42, Macro,          \"macro\")\n+    (43, Offsetof,       \"offsetof\")\n+    (44, Override,       \"override\")\n+    (45, Priv,           \"priv\")\n+    (46, Proc,           \"proc\")\n+    (47, Pure,           \"pure\")\n+    (48, Sizeof,         \"sizeof\")\n+    (49, Typeof,         \"typeof\")\n+    (50, Unsized,        \"unsized\")\n+    (51, Virtual,        \"virtual\")\n+    (52, Yield,          \"yield\")\n+\n+    // Weak keywords, have special meaning only in specific contexts.\n+    (53, Default,        \"default\")\n+    (54, StaticLifetime, \"'static\")\n+    (55, Union,          \"union\")\n }\n \n // looks like we can get rid of this completely..."}, {"sha": "798477d8fe50df046b5c060b1e9c945d91afc814", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -20,7 +20,7 @@ use attr;\n use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{self, CodeMap, BytePos};\n use errors;\n-use parse::token::{self, BinOpToken, Token, InternedString};\n+use parse::token::{self, keywords, BinOpToken, Token, InternedString};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n@@ -2957,9 +2957,8 @@ impl<'a> State<'a> {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n                 match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _) if\n-                        path1.node.name ==\n-                            parse::token::special_idents::Invalid.name => {\n+                    PatKind::Ident(_, ref path1, _)\n+                            if path1.node.name == keywords::Invalid.name() => {\n                         // Do nothing.\n                     }\n                     _ => {"}, {"sha": "84a7b14484828cb754de2202e43acbdbc6719d86", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -14,7 +14,7 @@ use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n use fold::Folder;\n use fold;\n-use parse::token::{intern, InternedString, special_idents};\n+use parse::token::{intern, InternedString, keywords};\n use parse::{token, ParseSess};\n use ptr::P;\n use util::small_vector::SmallVector;\n@@ -148,7 +148,7 @@ impl fold::Folder for PreludeInjector {\n         let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path)));\n         mod_.items.insert(0, P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: special_idents::Invalid,\n+            ident: keywords::Invalid.ident(),\n             node: ast::ItemKind::Use(vp),\n             attrs: vec![ast::Attribute {\n                 span: self.span,"}, {"sha": "8eeb61e0de46c3616f0ba6b4b3aeef46d7ef5288", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -31,7 +31,7 @@ use ext::expand::ExpansionConfig;\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n-use parse::token::{intern, InternedString};\n+use parse::token::{intern, keywords, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n use ast;\n@@ -116,7 +116,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n     fn fold_item(&mut self, i: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         let ident = i.ident;\n-        if ident.name != token::special_idents::Invalid.name {\n+        if ident.name != keywords::Invalid.name() {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n@@ -160,7 +160,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             ast::ItemKind::Mod(..) => fold::noop_fold_item(i, self),\n             _ => SmallVector::one(i),\n         };\n-        if ident.name != token::special_idents::Invalid.name {\n+        if ident.name != keywords::Invalid.name() {\n             self.cx.path.pop();\n         }\n         res\n@@ -453,7 +453,7 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n                                          path_node(vec!(id_test)))))),\n-         ast::Visibility::Public, token::special_idents::Invalid)\n+         ast::Visibility::Public, keywords::Invalid.ident())\n     } else {\n         (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)\n     };\n@@ -545,7 +545,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n \n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: token::special_idents::Invalid,\n+            ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Visibility::Inherited,\n@@ -590,7 +590,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n                                                     ecx.ident_of(\"test\"),\n                                                     ecx.ident_of(\"TestDescAndFn\")]));\n-    let static_lt = ecx.lifetime(sp, token::special_idents::StaticLifetime.name);\n+    let static_lt = ecx.lifetime(sp, keywords::StaticLifetime.name());\n     // &'static [self::test::TestDescAndFn]\n     let static_type = ecx.ty_rptr(sp,\n                                   ecx.ty(sp, ast::TyKind::Vec(struct_type)),"}, {"sha": "a3e70cc6321a6000f9c59365c07d60142f1a2006", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -201,8 +201,7 @@ use syntax::codemap::{self, DUMMY_SP};\n use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{intern, InternedString};\n-use syntax::parse::token::{keywords, special_idents};\n+use syntax::parse::token::{intern, keywords, InternedString};\n use syntax::ptr::P;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n@@ -635,7 +634,7 @@ impl<'a> TraitDef<'a> {\n \n         cx.item(\n             self.span,\n-            special_idents::Invalid,\n+            keywords::Invalid.ident(),\n             a,\n             ast::ItemKind::Impl(unsafety,\n                                 ast::ImplPolarity::Positive,\n@@ -866,7 +865,7 @@ impl<'a> MethodDef<'a> {\n             // creating fresh self id\n             _ => Some(ast::Arg::new_self(trait_.span,\n                                          ast::Mutability::Immutable,\n-                                         keywords::SelfValue.ident))\n+                                         keywords::SelfValue.ident()))\n         };\n         let args = {\n             let args = arg_types.into_iter().map(|(name, ty)| {"}, {"sha": "e19febe2a120354e3407afc2326cc0b31fb38620", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -264,15 +264,15 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfKind::Value(keywords::SelfValue.ident)))\n+            (self_path, respan(span, ast::SelfKind::Value(keywords::SelfValue.ident())))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfKind::Region(lt, mutbl, keywords::SelfValue.ident)\n+                        ast::SelfKind::Region(lt, mutbl, keywords::SelfValue.ident())\n                     }\n                     Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n                 });"}, {"sha": "6c61d6b914c5638fdedff38e3f258b9d032000fa", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b32d7b592306a2784585e842193db1546a2f9587/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=b32d7b592306a2784585e842193db1546a2f9587", "patch": "@@ -19,8 +19,7 @@ use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::fold::Folder;\n-use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n \n use std::collections::HashMap;\n@@ -449,7 +448,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let sp = piece_ty.span;\n         let ty = ecx.ty_rptr(sp,\n             ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n-            Some(ecx.lifetime(sp, special_idents::StaticLifetime.name)),\n+            Some(ecx.lifetime(sp, keywords::StaticLifetime.name())),\n             ast::Mutability::Immutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n@@ -475,7 +474,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n-        let static_lifetime = self.ecx.lifetime(self.fmtsp, special_idents::StaticLifetime.name);\n+        let static_lifetime = self.ecx.lifetime(self.fmtsp, keywords::StaticLifetime.name());\n         let piece_ty = self.ecx.ty_rptr(\n                 self.fmtsp,\n                 self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),"}]}