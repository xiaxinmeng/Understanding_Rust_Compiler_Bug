{"sha": "def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZjdiYzBlYzU1YTBhZmIyY2I1NzdlMmU4MGQ5NWIzM2ExY2YxMTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-18T12:30:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-18T12:30:58Z"}, "message": "drop dependency on thread_worker", "tree": {"sha": "1e29426acbe0e1f633e888f1929308be8725f3f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e29426acbe0e1f633e888f1929308be8725f3f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "html_url": "https://github.com/rust-lang/rust/commit/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9da37051911132279131530e958b0adc0a5a9aaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da37051911132279131530e958b0adc0a5a9aaa", "html_url": "https://github.com/rust-lang/rust/commit/9da37051911132279131530e958b0adc0a5a9aaa"}], "stats": {"total": 166, "additions": 99, "deletions": 67}, "files": [{"sha": "8f087749fce05d9d83c93be4dabdf87aa678b519", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "patch": "@@ -1130,7 +1130,6 @@ dependencies = [\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_worker 0.1.0\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "fdaf31b9c6f02997f1efe468e61d2dd0f2a0d705", "filename": "crates/ra_vfs/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "patch": "@@ -13,8 +13,6 @@ log = \"0.4.6\"\n notify = \"4.0.9\"\n parking_lot = \"0.7.0\"\n \n-thread_worker = { path = \"../thread_worker\" }\n-\n [dev-dependencies]\n tempfile = \"3\"\n flexi_logger = \"0.10.0\""}, {"sha": "b6a0576977125d548e73390f5170fcaf21e3adca", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 97, "deletions": 62, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "patch": "@@ -3,8 +3,9 @@ use std::{\n     path::{Path, PathBuf},\n     sync::{mpsc, Arc},\n     time::Duration,\n+    thread,\n };\n-use crossbeam_channel::{Sender, unbounded, RecvError, select};\n+use crossbeam_channel::{Sender, Receiver, unbounded, RecvError, select};\n use relative_path::RelativePathBuf;\n use walkdir::WalkDir;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n@@ -46,7 +47,40 @@ enum ChangeKind {\n \n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n-pub(crate) type Worker = thread_worker::Worker<Task, VfsTask>;\n+// Like thread::JoinHandle, but joins the thread on drop.\n+//\n+// This is useful because it guarantees the absence of run-away threads, even if\n+// code panics. This is important, because we might seem panics in the test and\n+// we might be used in an IDE context, where a failed component is just\n+// restarted.\n+//\n+// Because all threads are joined, care must be taken to avoid deadlocks. That\n+// typically means ensuring that channels are dropped before the threads.\n+struct ScopedThread(Option<thread::JoinHandle<()>>);\n+\n+impl ScopedThread {\n+    fn spawn(name: String, f: impl FnOnce() + Send + 'static) -> ScopedThread {\n+        let handle = thread::Builder::new().name(name).spawn(f).unwrap();\n+        ScopedThread(Some(handle))\n+    }\n+}\n+\n+impl Drop for ScopedThread {\n+    fn drop(&mut self) {\n+        let res = self.0.take().unwrap().join();\n+        if !thread::panicking() {\n+            res.unwrap();\n+        }\n+    }\n+}\n+\n+pub(crate) struct Worker {\n+    // XXX: it's important to drop `sender` before `_thread` to avoid deadlock.\n+    pub(crate) sender: Sender<Task>,\n+    _thread: ScopedThread,\n+    pub(crate) receiver: Receiver<VfsTask>,\n+}\n+\n pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n     // This is a pretty elaborate setup of threads & channels! It is\n     // explained by the following concerns:\n@@ -55,69 +89,70 @@ pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n     //    * we want to read all files from a single thread, to guarantee that\n     //      we always get fresher versions and never go back in time.\n     //    * we want to tear down everything neatly during shutdown.\n-    Worker::spawn(\n-        \"vfs\",\n-        128,\n-        // This are the channels we use to communicate with outside world.\n-        // If `input_receiver` is closed we need to tear ourselves down.\n-        // `output_sender` should not be closed unless the parent died.\n-        move |input_receiver, output_sender| {\n-            // Make sure that the destruction order is\n-            //\n-            // * notify_sender\n-            // * _thread\n-            // * watcher_sender\n-            //\n-            // this is required to avoid deadlocks.\n-\n-            // These are the corresponding crossbeam channels\n-            let (watcher_sender, watcher_receiver) = unbounded();\n-            let _thread;\n-            {\n-                // These are `std` channels notify will send events to\n-                let (notify_sender, notify_receiver) = mpsc::channel();\n-\n-                let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n-                    .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n-                    .ok();\n-                // Start a silly thread to transform between two channels\n-                _thread = thread_worker::ScopedThread::spawn(\"notify-convertor\", move || {\n-                    notify_receiver\n-                        .into_iter()\n-                        .for_each(|event| convert_notify_event(event, &watcher_sender))\n-                });\n-\n-                // Process requests from the called or notifications from\n-                // watcher until the caller says stop.\n-                loop {\n-                    select! {\n-                        // Received request from the caller. If this channel is\n-                        // closed, we should shutdown everything.\n-                        recv(input_receiver) -> t => match t {\n-                            Err(RecvError) => {\n-                                drop(input_receiver);\n-                                break\n-                            },\n-                            Ok(Task::AddRoot { root }) => {\n-                                watch_root(watcher.as_mut(), &output_sender, &*roots, root);\n-                            }\n-                        },\n-                        // Watcher send us changes. If **this** channel is\n-                        // closed, the watcher has died, which indicates a bug\n-                        // -- escalate!\n-                        recv(watcher_receiver) -> event => match event {\n-                            Err(RecvError) => panic!(\"watcher is dead\"),\n-                            Ok((path, change)) => {\n-                                handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n-                            }\n+    let _thread;\n+    // This are the channels we use to communicate with outside world.\n+    // If `input_receiver` is closed we need to tear ourselves down.\n+    // `output_sender` should not be closed unless the parent died.\n+    let (input_sender, input_receiver) = unbounded();\n+    let (output_sender, output_receiver) = unbounded();\n+\n+    _thread = ScopedThread::spawn(\"vfs\".to_string(), move || {\n+        // Make sure that the destruction order is\n+        //\n+        // * notify_sender\n+        // * _thread\n+        // * watcher_sender\n+        //\n+        // this is required to avoid deadlocks.\n+\n+        // These are the corresponding crossbeam channels\n+        let (watcher_sender, watcher_receiver) = unbounded();\n+        let _notify_thread;\n+        {\n+            // These are `std` channels notify will send events to\n+            let (notify_sender, notify_receiver) = mpsc::channel();\n+\n+            let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n+                .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n+                .ok();\n+            // Start a silly thread to transform between two channels\n+            _notify_thread = ScopedThread::spawn(\"notify-convertor\".to_string(), move || {\n+                notify_receiver\n+                    .into_iter()\n+                    .for_each(|event| convert_notify_event(event, &watcher_sender))\n+            });\n+\n+            // Process requests from the called or notifications from\n+            // watcher until the caller says stop.\n+            loop {\n+                select! {\n+                    // Received request from the caller. If this channel is\n+                    // closed, we should shutdown everything.\n+                    recv(input_receiver) -> t => match t {\n+                        Err(RecvError) => {\n+                            drop(input_receiver);\n+                            break\n                         },\n-                    }\n+                        Ok(Task::AddRoot { root }) => {\n+                            watch_root(watcher.as_mut(), &output_sender, &*roots, root);\n+                        }\n+                    },\n+                    // Watcher send us changes. If **this** channel is\n+                    // closed, the watcher has died, which indicates a bug\n+                    // -- escalate!\n+                    recv(watcher_receiver) -> event => match event {\n+                        Err(RecvError) => panic!(\"watcher is dead\"),\n+                        Ok((path, change)) => {\n+                            handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n+                        }\n+                    },\n                 }\n             }\n-            // Drain pending events: we are not interested in them anyways!\n-            watcher_receiver.into_iter().for_each(|_| ());\n-        },\n-    )\n+        }\n+        // Drain pending events: we are not interested in them anyways!\n+        watcher_receiver.into_iter().for_each(|_| ());\n+    });\n+    Worker { sender: input_sender, _thread, receiver: output_receiver }\n }\n \n fn watch_root("}, {"sha": "808c138dfee19d8c051ed27692acd99afbae5731", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def7bc0ec55a0afb2cb577e2e80d95b33a1cf115/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=def7bc0ec55a0afb2cb577e2e80d95b33a1cf115", "patch": "@@ -92,7 +92,7 @@ impl Vfs {\n \n         for root in roots.iter() {\n             root2files.insert(root, Default::default());\n-            worker.sender().send(io::Task::AddRoot { root }).unwrap();\n+            worker.sender.send(io::Task::AddRoot { root }).unwrap();\n         }\n         let res = Vfs { roots, files: Vec::new(), root2files, worker, pending_changes: Vec::new() };\n         let vfs_roots = res.roots.iter().collect();\n@@ -170,7 +170,7 @@ impl Vfs {\n     }\n \n     pub fn task_receiver(&self) -> &Receiver<VfsTask> {\n-        self.worker.receiver()\n+        &self.worker.receiver\n     }\n \n     pub fn handle_task(&mut self, task: VfsTask) {"}]}