{"sha": "57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "node_id": "C_kwDOAAsO6NoAKDU3ZTlmN2E1NTZhZTQ4NzNhY2MxNGM2MmJiNGQ2ZmM3ZWQ2MTIzYWM", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-06-28T11:19:38Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-15T15:56:17Z"}, "message": "Infer wildcard type from other patterns at every pattern level", "tree": {"sha": "b6040da3da0f22c390da16f9c6fa978553879b4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6040da3da0f22c390da16f9c6fa978553879b4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "html_url": "https://github.com/rust-lang/rust/commit/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e470a1de4f809af62d38df9a968c41f8887189", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e470a1de4f809af62d38df9a968c41f8887189", "html_url": "https://github.com/rust-lang/rust/commit/92e470a1de4f809af62d38df9a968c41f8887189"}], "stats": {"total": 98, "additions": 72, "deletions": 26}, "files": [{"sha": "c0fd19cf71c3186ede0fb0d75895f1afde65b6a3", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "patch": "@@ -1202,35 +1202,32 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n \n     /// Creates a new list of wildcard fields for a given constructor. The result must have a\n     /// length of `constructor.arity()`.\n-    pub(super) fn wildcards(\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        ty: Ty<'tcx>,\n-        constructor: &Constructor<'tcx>,\n-    ) -> Self {\n+    #[instrument(level = \"trace\")]\n+    pub(super) fn wildcards(pcx: PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n         let ret = match constructor {\n-            Single | Variant(_) => match ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter()),\n-                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n+            Single | Variant(_) => match pcx.ty.kind() {\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter()),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n-                        Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n+                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n-                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n+                        let tys = Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n                             .map(|(_, ty)| ty);\n-                        Fields::wildcards_from_tys(cx, tys)\n+                        Fields::wildcards_from_tys(pcx.cx, tys)\n                     }\n                 }\n-                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx),\n             },\n-            Slice(slice) => match *ty.kind() {\n+            Slice(slice) => match *pcx.ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n-                    Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n+                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty))\n                 }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, pcx),\n             },\n             Str(..)\n             | FloatRange(..)\n@@ -1243,7 +1240,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 bug!(\"called `Fields::wildcards` on an `Or` ctor\")\n             }\n         };\n-        debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n+        debug!(?ret);\n         ret\n     }\n \n@@ -1286,7 +1283,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n     /// `Some(_)`.\n     pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n-        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+        let fields = Fields::wildcards(pcx, &ctor);\n         DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n     }\n \n@@ -1553,13 +1550,13 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n     pub(super) fn specialize<'a>(\n         &'a self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         other_ctor: &Constructor<'tcx>,\n     ) -> SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]> {\n         match (&self.ctor, other_ctor) {\n             (Wildcard, _) => {\n                 // We return a wildcard for each field of `other_ctor`.\n-                Fields::wildcards(cx, self.ty, other_ctor).iter_patterns().collect()\n+                Fields::wildcards(pcx, other_ctor).iter_patterns().collect()\n             }\n             (Slice(self_slice), Slice(other_slice))\n                 if self_slice.arity() != other_slice.arity() =>\n@@ -1578,7 +1575,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n                         let wildcard: &_ =\n-                            cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                            pcx.cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n                         let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n                         prefix.iter().chain(extra_wildcards).chain(suffix).collect()"}, {"sha": "f27ec22a8dee25a8a4e0cfe6669d26856761002b", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "patch": "@@ -411,12 +411,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// This is roughly the inverse of `Constructor::apply`.\n     fn pop_head_constructor(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(pcx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n@@ -475,7 +475,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n         for row in &self.patterns {\n             if ctor.is_covered_by(pcx, row.head().ctor()) {\n-                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n+                let new_row = row.pop_head_constructor(pcx, ctor);\n                 matrix.push(new_row);\n             }\n         }\n@@ -786,7 +786,7 @@ fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'p, 'tcx> {\n-    debug!(\"matrix,v={:?}{:?}\", matrix, v);\n+    debug!(?matrix, ?v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -827,7 +827,15 @@ fn is_useful<'p, 'tcx>(\n             }\n         }\n     } else {\n-        let ty = v.head().ty();\n+        let mut ty = v.head().ty();\n+\n+        // Opaque types can't get destructured/split, but the patterns can\n+        // actually hint at hidden types, so we use the patterns' types instead.\n+        if let ty::Opaque(..) = v.head().ty().kind() {\n+            if let Some(row) = rows.first() {\n+                ty = row.head().ty();\n+            }\n+        }\n         let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n         debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n         let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n@@ -853,7 +861,7 @@ fn is_useful<'p, 'tcx>(\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n-            let v = v.pop_head_constructor(cx, &ctor);\n+            let v = v.pop_head_constructor(pcx, &ctor);\n             let usefulness = ensure_sufficient_stack(|| {\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false)\n             });"}, {"sha": "c0a371eca1c6feaa6945cbf5ce8cc01a97a00cde", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-only-pattern-rpit.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs?ref=57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "patch": "@@ -0,0 +1,29 @@\n+// check-pass\n+\n+#[allow(unconditional_recursion)]\n+fn foo(b: bool) -> impl Copy {\n+    let (mut x, mut y) = foo(false);\n+    x = 42;\n+    y = \"foo\";\n+    if b {\n+        panic!()\n+    } else {\n+        foo(true)\n+    }\n+}\n+\n+fn bar(b: bool) -> Option<impl Copy> {\n+    if b {\n+        return None;\n+    }\n+    match bar(!b) {\n+        Some((mut x, mut y)) => {\n+            x = 42;\n+            y = \"foo\";\n+        }\n+        None => {}\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "ec249958590f1ce12549e07194c661fe15d6e8ff", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-only-pattern.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs?ref=57e9f7a556ae4873acc14c62bb4d6fc7ed6123ac", "patch": "@@ -9,4 +9,16 @@ fn foo(foo: T) {\n     y = \"foo\";\n }\n \n+type U = impl Copy;\n+\n+fn bar(bar: Option<U>) {\n+    match bar {\n+        Some((mut x, mut y)) => {\n+            x = 42;\n+            y = \"foo\";\n+        }\n+        None => {}\n+    }\n+}\n+\n fn main() {}"}]}