{"sha": "92786a48f8c56046df8adf3aea49617a22f88d9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNzg2YTQ4ZjhjNTYwNDZkZjhhZGYzYWVhNDk2MTdhMjJmODhkOWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-23T19:03:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:21Z"}, "message": "consolidate and use `find_sub_region_live_at` for everything\n\nremove the old blame system", "tree": {"sha": "f01b1df5fa273f78176ef4c6ba6143ab75e463f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f01b1df5fa273f78176ef4c6ba6143ab75e463f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92786a48f8c56046df8adf3aea49617a22f88d9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92786a48f8c56046df8adf3aea49617a22f88d9e", "html_url": "https://github.com/rust-lang/rust/commit/92786a48f8c56046df8adf3aea49617a22f88d9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92786a48f8c56046df8adf3aea49617a22f88d9e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "078220daa89f060eba85251d0e9eebdcd69b4dc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/078220daa89f060eba85251d0e9eebdcd69b4dc8", "html_url": "https://github.com/rust-lang/rust/commit/078220daa89f060eba85251d0e9eebdcd69b4dc8"}], "stats": {"total": 143, "additions": 47, "deletions": 96}, "files": [{"sha": "0039958b6b14d3e724948fd7b6e2b77233e13fb9", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=92786a48f8c56046df8adf3aea49617a22f88d9e", "patch": "@@ -54,7 +54,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             borrow_region_vid\n         );\n \n-        let region_sub = regioncx.find_constraint(borrow_region_vid, context.loc);\n+        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, context.loc);\n \n         debug!(\n             \"explain_why_borrow_contains_point: region_sub={:?}\","}, {"sha": "acc1a33ea698dd9fdff445bfa6a106c774168404", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 24, "deletions": 81, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=92786a48f8c56046df8adf3aea49617a22f88d9e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -75,11 +74,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> (ConstraintCategory, Span) {\n+    ) -> (ConstraintCategory, Span, RegionVid) {\n         debug!(\"best_blame_constraint(from_region={:?})\", from_region);\n \n         // Find all paths\n-        let path = self\n+        let (path, target_region) = self\n             .find_constraint_paths_between_regions(from_region, target_test)\n             .unwrap();\n         debug!(\"best_blame_constraint: path={:#?}\", path);\n@@ -98,19 +97,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n         debug!(\"best_blame_constraint: sorted_path={:?}\", categorized_path);\n \n-        *categorized_path.first().unwrap()\n+        let &(category, span) = categorized_path.first().unwrap();\n+\n+        (category, span, target_region)\n     }\n \n     /// Walks the graph of constraints (where `'a: 'b` is considered\n     /// an edge `'a -> 'b`) to find all paths from `from_region` to\n     /// `to_region`. The paths are accumulated into the vector\n     /// `results`. The paths are stored as a series of\n     /// `ConstraintIndex` values -- in other words, a list of *edges*.\n+    ///\n+    /// Returns: a series of constraints as well as the region `R`\n+    /// that passed the target test.\n     fn find_constraint_paths_between_regions(\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Option<Vec<ConstraintIndex>> {\n+    ) -> Option<(Vec<ConstraintIndex>, RegionVid)> {\n         let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n         context[from_region] = Trace::StartRegion;\n \n@@ -138,7 +142,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                         Trace::StartRegion => {\n                             result.reverse();\n-                            return Some(result);\n+                            return Some((result, r));\n                         }\n                     }\n                 }\n@@ -253,7 +257,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, span) = self.best_blame_constraint(mir, fr, |r| r == outlived_fr);\n+        let (category, span, _) = self.best_blame_constraint(mir, fr, |r| r == outlived_fr);\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n@@ -393,82 +397,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         diag.buffer(errors_buffer);\n     }\n \n-    // Find some constraint `X: Y` where:\n-    // - `fr1: X` transitively\n-    // - and `Y` is live at `elem`\n-    crate fn find_constraint(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n-        let index = self.blame_constraint(fr1, elem);\n-        self.constraints[index].sub\n-    }\n-\n-    /// Tries to finds a good span to blame for the fact that `fr1`\n-    /// contains `fr2`.\n-    pub(super) fn blame_constraint(\n-        &self,\n-        fr1: RegionVid,\n-        elem: impl ToElementIndex,\n-    ) -> ConstraintIndex {\n-        // Find everything that influenced final value of `fr`.\n-        let influenced_fr1 = self.dependencies(fr1);\n-\n-        // Try to find some outlives constraint `'X: fr2` where `'X`\n-        // influenced `fr1`. Blame that.\n-        //\n-        // NB, this is a pretty bad choice most of the time. In\n-        // particular, the connection between `'X` and `fr1` may not\n-        // be obvious to the user -- not to mention the naive notion\n-        // of dependencies, which doesn't account for the locations of\n-        // contraints at all. But it will do for now.\n-        let relevant_constraint = self.constraints\n-            .iter_enumerated()\n-            .filter_map(|(i, constraint)| {\n-                if !self.liveness_constraints.contains(constraint.sub, elem) {\n-                    None\n-                } else {\n-                    influenced_fr1[constraint.sup]\n-                        .map(|distance| (distance, i))\n-                }\n+    // Finds some region R such that `fr1: R` and `R` is live at\n+    // `elem`.\n+    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+        // Find all paths\n+        let (_path, r) = self\n+            .find_constraint_paths_between_regions(fr1, |r| {\n+                self.liveness_constraints.contains(r, elem)\n             })\n-            .min() // constraining fr1 with fewer hops *ought* to be more obvious\n-            .map(|(_dist, i)| i);\n-\n-        relevant_constraint.unwrap_or_else(|| {\n-            bug!(\n-                \"could not find any constraint to blame for {:?}: {:?}\",\n-                fr1,\n-                elem,\n-            );\n-        })\n+            .unwrap();\n+        r\n     }\n \n-    /// Finds all regions whose values `'a` may depend on in some way.\n-    /// For each region, returns either `None` (does not influence\n-    /// `'a`) or `Some(d)` which indicates that it influences `'a`\n-    /// with distinct `d` (minimum number of edges that must be\n-    /// traversed).\n-    ///\n-    /// Used during error reporting, extremely naive and inefficient.\n-    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, Option<usize>> {\n-        let mut result_set = IndexVec::from_elem(None, &self.definitions);\n-        let mut changed = true;\n-        result_set[r0] = Some(0); // distance 0 from `r0`\n-\n-        while changed {\n-            changed = false;\n-            for constraint in self.constraints.iter() {\n-                if let Some(n) = result_set[constraint.sup] {\n-                    let m = n + 1;\n-                    if result_set[constraint.sub]\n-                        .map(|distance| m < distance)\n-                        .unwrap_or(true)\n-                    {\n-                        result_set[constraint.sub] = Some(m);\n-                        changed = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        result_set\n+    // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n+    crate fn find_outlives_blame_span(&self, mir: &Mir<'tcx>, fr1: RegionVid, fr2: RegionVid) -> Span {\n+        let (_, span, _) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n+        span\n     }\n }"}, {"sha": "cf64f22084534367a0d64a1983560a97ef95a854", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=92786a48f8c56046df8adf3aea49617a22f88d9e", "patch": "@@ -884,8 +884,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr, shorter_fr,\n             );\n \n-            let blame_index = self.blame_constraint(longer_fr, shorter_fr);\n-            let blame_span = self.constraints[blame_index].locations.span(mir);\n+            let blame_span = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do)."}, {"sha": "92225369c92711806bdc6a8bd65f132df1dcef5e", "filename": "src/test/ui/borrowck/mut-borrow-in-loop.nll.stderr", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92786a48f8c56046df8adf3aea49617a22f88d9e/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr?ref=92786a48f8c56046df8adf3aea49617a22f88d9e", "patch": "@@ -2,28 +2,37 @@ error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:20:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |             ------------^^^-\n-   |             |           |\n-   |             |           mutable borrow starts here in previous iteration of loop\n-   |             borrow later used here\n+   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the impl at 17:6...\n+  --> $DIR/mut-borrow-in-loop.rs:17:6\n+   |\n+LL | impl<'a, T : 'a> FuncWrapper<'a, T> {\n+   |      ^^\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:26:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |             ------------^^^-\n-   |             |           |\n-   |             |           mutable borrow starts here in previous iteration of loop\n-   |             borrow later used here\n+   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the impl at 17:6...\n+  --> $DIR/mut-borrow-in-loop.rs:17:6\n+   |\n+LL | impl<'a, T : 'a> FuncWrapper<'a, T> {\n+   |      ^^\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:33:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |             ------------^^^-\n-   |             |           |\n-   |             |           mutable borrow starts here in previous iteration of loop\n-   |             borrow later used here\n+   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the impl at 17:6...\n+  --> $DIR/mut-borrow-in-loop.rs:17:6\n+   |\n+LL | impl<'a, T : 'a> FuncWrapper<'a, T> {\n+   |      ^^\n \n error: aborting due to 3 previous errors\n "}]}