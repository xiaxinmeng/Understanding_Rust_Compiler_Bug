{"sha": "7efba4f982a200627605f77b444e09de02ab2a1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZmJhNGY5ODJhMjAwNjI3NjA1Zjc3YjQ0NGUwOWRlMDJhYjJhMWE=", "commit": {"author": {"name": "AnthonyMikh", "email": "anthony.mikh@yandex.ru", "date": "2020-10-08T13:02:06Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-13T13:57:24Z"}, "message": "Implement indexing slices with pairs of ops::Bound<usize>", "tree": {"sha": "3590a84d0d9bfb850343a58e8389ae8d96795606", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3590a84d0d9bfb850343a58e8389ae8d96795606"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7efba4f982a200627605f77b444e09de02ab2a1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7efba4f982a200627605f77b444e09de02ab2a1a", "html_url": "https://github.com/rust-lang/rust/commit/7efba4f982a200627605f77b444e09de02ab2a1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7efba4f982a200627605f77b444e09de02ab2a1a/comments", "author": {"login": "AnthonyMikh", "id": 19252795, "node_id": "MDQ6VXNlcjE5MjUyNzk1", "avatar_url": "https://avatars.githubusercontent.com/u/19252795?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AnthonyMikh", "html_url": "https://github.com/AnthonyMikh", "followers_url": "https://api.github.com/users/AnthonyMikh/followers", "following_url": "https://api.github.com/users/AnthonyMikh/following{/other_user}", "gists_url": "https://api.github.com/users/AnthonyMikh/gists{/gist_id}", "starred_url": "https://api.github.com/users/AnthonyMikh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AnthonyMikh/subscriptions", "organizations_url": "https://api.github.com/users/AnthonyMikh/orgs", "repos_url": "https://api.github.com/users/AnthonyMikh/repos", "events_url": "https://api.github.com/users/AnthonyMikh/events{/privacy}", "received_events_url": "https://api.github.com/users/AnthonyMikh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e7eb85b1df5fce97e274569acf403c212aab517", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7eb85b1df5fce97e274569acf403c212aab517", "html_url": "https://github.com/rust-lang/rust/commit/2e7eb85b1df5fce97e274569acf403c212aab517"}], "stats": {"total": 155, "additions": 155, "deletions": 0}, "files": [{"sha": "1ef040484c344f82a211ca1a88298ba00777d4a9", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7efba4f982a200627605f77b444e09de02ab2a1a/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efba4f982a200627605f77b444e09de02ab2a1a/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=7efba4f982a200627605f77b444e09de02ab2a1a", "patch": "@@ -81,6 +81,8 @@ mod private_slice_index {\n     impl Sealed for ops::RangeInclusive<usize> {}\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n     impl Sealed for ops::RangeToInclusive<usize> {}\n+    #[stable(feature = \"slice_index_with_ops_bound_pair\", since = \"1.51.0\")]\n+    impl Sealed for (ops::Bound<usize>, ops::Bound<usize>) {}\n }\n \n /// A helper trait used for indexing operations.\n@@ -546,3 +548,113 @@ where\n \n     ops::Range { start, end }\n }\n+\n+/// Convert pair of `ops::Bound`s into `ops::Range` without performing any bounds checking and (in debug) overflow checking\n+fn into_range_unchecked(\n+    len: usize,\n+    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n+) -> ops::Range<usize> {\n+    use ops::Bound;\n+    let start = match start {\n+        Bound::Included(i) => i,\n+        Bound::Excluded(i) => i + 1,\n+        Bound::Unbounded => 0,\n+    };\n+    let end = match end {\n+        Bound::Included(i) => i + 1,\n+        Bound::Excluded(i) => i,\n+        Bound::Unbounded => len,\n+    };\n+    start..end\n+}\n+\n+/// Convert pair of `ops::Bound`s into `ops::Range`.\n+/// Returns `None` on overflowing indices.\n+fn into_range(\n+    len: usize,\n+    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n+) -> Option<ops::Range<usize>> {\n+    use ops::Bound;\n+    let start = match start {\n+        Bound::Included(start) => start,\n+        Bound::Excluded(start) => start.checked_add(1)?,\n+        Bound::Unbounded => 0,\n+    };\n+\n+    let end = match end {\n+        Bound::Included(end) => end.checked_add(1)?,\n+        Bound::Excluded(end) => end,\n+        Bound::Unbounded => len,\n+    };\n+\n+    // Don't bother with checking `start < end` and `end <= len`\n+    // since these checks are handled by `Range` impls\n+\n+    Some(start..end)\n+}\n+\n+/// Convert pair of `ops::Bound`s into `ops::Range`.\n+/// Panics on overflowing indices.\n+fn into_slice_range(\n+    len: usize,\n+    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n+) -> ops::Range<usize> {\n+    use ops::Bound;\n+    let start = match start {\n+        Bound::Included(start) => start,\n+        Bound::Excluded(start) => {\n+            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+        }\n+        Bound::Unbounded => 0,\n+    };\n+\n+    let end = match end {\n+        Bound::Included(end) => {\n+            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+        }\n+        Bound::Excluded(end) => end,\n+        Bound::Unbounded => len,\n+    };\n+\n+    // Don't bother with checking `start < end` and `end <= len`\n+    // since these checks are handled by `Range` impls\n+\n+    start..end\n+}\n+\n+#[stable(feature = \"slice_index_with_ops_bound_pair\", since = \"1.51.0\")]\n+unsafe impl<T> SliceIndex<[T]> for (ops::Bound<usize>, ops::Bound<usize>) {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&Self::Output> {\n+        into_range(slice.len(), self)?.get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut Self::Output> {\n+        into_range(slice.len(), self)?.get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const Self::Output {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { into_range_unchecked(slice.len(), self).get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut Self::Output {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { into_range_unchecked(slice.len(), self).get_unchecked_mut(slice) }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &Self::Output {\n+        into_slice_range(slice.len(), self).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut Self::Output {\n+        into_slice_range(slice.len(), self).index_mut(slice)\n+    }\n+}"}, {"sha": "3a98cd9d2ee91be6c98e58c65acf05694956b95c", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7efba4f982a200627605f77b444e09de02ab2a1a/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efba4f982a200627605f77b444e09de02ab2a1a/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=7efba4f982a200627605f77b444e09de02ab2a1a", "patch": "@@ -1280,6 +1280,9 @@ mod slice_index {\n             }\n         )*) => {$(\n             mod $case_name {\n+                #[allow(unused_imports)]\n+                use core::ops::Bound;\n+\n                 #[test]\n                 fn pass() {\n                     let mut v = $data;\n@@ -1376,6 +1379,24 @@ mod slice_index {\n             bad: data[7..=6];\n             message: \"out of range\";\n         }\n+\n+        in mod boundpair_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[(Bound::Included(6), Bound::Unbounded)] == [];\n+            good: data[(Bound::Unbounded, Bound::Included(5))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Unbounded, Bound::Excluded(6))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Included(0), Bound::Included(5))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Included(0), Bound::Excluded(6))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Included(2), Bound::Excluded(4))] == [2, 3];\n+            good: data[(Bound::Excluded(1), Bound::Included(4))] == [2, 3, 4];\n+            good: data[(Bound::Excluded(5), Bound::Excluded(6))] == [];\n+            good: data[(Bound::Included(6), Bound::Excluded(6))] == [];\n+            good: data[(Bound::Excluded(5), Bound::Included(5))] == [];\n+            good: data[(Bound::Included(6), Bound::Included(5))] == [];\n+            bad: data[(Bound::Unbounded, Bound::Included(6))];\n+            message: \"out of range\";\n+        }\n     }\n \n     panic_cases! {\n@@ -1416,6 +1437,14 @@ mod slice_index {\n             bad: data[4..=2];\n             message: \"but ends at\";\n         }\n+\n+        in mod boundpair_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[(Bound::Included(4), Bound::Excluded(4))] == [];\n+            bad: data[(Bound::Included(4), Bound::Excluded(3))];\n+            message: \"but ends at\";\n+        }\n     }\n \n     panic_cases! {\n@@ -1434,6 +1463,20 @@ mod slice_index {\n             bad: data[..= usize::MAX];\n             message: \"maximum usize\";\n         }\n+\n+        in mod boundpair_overflow_end {\n+            data: [0; 1];\n+\n+            bad: data[(Bound::Unbounded, Bound::Included(usize::MAX))];\n+            message: \"maximum usize\";\n+        }\n+\n+        in mod boundpair_overflow_start {\n+            data: [0; 1];\n+\n+            bad: data[(Bound::Excluded(usize::MAX), Bound::Unbounded)];\n+            message: \"maximum usize\";\n+        }\n     } // panic_cases!\n }\n "}]}