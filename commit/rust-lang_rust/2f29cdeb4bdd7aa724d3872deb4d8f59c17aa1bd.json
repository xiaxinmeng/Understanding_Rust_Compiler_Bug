{"sha": "2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMjljZGViNGJkZDdhYTcyNGQzODcyZGViNGQ4ZjU5YzE3YWExYmQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-24T20:54:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-30T10:56:39Z"}, "message": "Remove the capture mode map and just store the capture mode for individual variables.\n\nAlso add test. Fixes #16749.", "tree": {"sha": "0ee83fe9414cef5c36b1c371601465130b2deb38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ee83fe9414cef5c36b1c371601465130b2deb38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "html_url": "https://github.com/rust-lang/rust/commit/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "html_url": "https://github.com/rust-lang/rust/commit/e0f5980ead4f88e78a47f4d84da4dc11472f66ba"}], "stats": {"total": 857, "additions": 418, "deletions": 439}, "files": [{"sha": "6c1a8a6f54bbf3fc7b595fef5f6800c2d35cd71d", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -140,7 +140,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_moves_map = 0x52,\n     tag_table_capture_map = 0x53,\n     tag_table_closures = 0x54,\n-    tag_table_upvar_borrow_map = 0x55,\n+    tag_table_upvar_capture_map = 0x55,\n     tag_table_capture_modes = 0x56,\n     tag_table_object_cast_map = 0x57,\n }"}, {"sha": "902c029fef4bf3907e82dcb61a0f109b292c0ad1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -518,10 +518,6 @@ fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &ty::Freevar) {\n     (*fv).encode(rbml_w).unwrap();\n }\n \n-fn encode_capture_mode(rbml_w: &mut Encoder, cm: ast::CaptureClause) {\n-    cm.encode(rbml_w).unwrap();\n-}\n-\n trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> ty::Freevar;\n@@ -559,6 +555,15 @@ impl tr for ty::UpvarBorrow {\n     }\n }\n \n+impl tr for ty::UpvarCapture {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarCapture {\n+        match *self {\n+            ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n+            ty::UpvarCapture::ByRef(ref data) => ty::UpvarCapture::ByRef(data.tr(dcx)),\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n@@ -1210,34 +1215,20 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         });\n \n         for freevar in fv.iter() {\n-            match tcx.capture_mode(id) {\n-                ast::CaptureByRef => {\n-                    rbml_w.tag(c::tag_table_upvar_borrow_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            let var_id = freevar.def.def_id().node;\n-                            let upvar_id = ty::UpvarId {\n-                                var_id: var_id,\n-                                closure_expr_id: id\n-                            };\n-                            let upvar_borrow = tcx.upvar_borrow_map.borrow()[upvar_id].clone();\n-                            var_id.encode(rbml_w);\n-                            upvar_borrow.encode(rbml_w);\n-                        })\n-                    })\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    for &cm in tcx.capture_modes.borrow().get(&id).iter() {\n-        rbml_w.tag(c::tag_table_capture_modes, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_capture_mode(rbml_w, *cm);\n+            rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n+                rbml_w.id(id);\n+                rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                    let var_id = freevar.def.def_id().node;\n+                    let upvar_id = ty::UpvarId {\n+                        var_id: var_id,\n+                        closure_expr_id: id\n+                    };\n+                    let upvar_capture = tcx.upvar_capture_map.borrow()[upvar_id].clone();\n+                    var_id.encode(rbml_w);\n+                    upvar_capture.encode(rbml_w);\n+                })\n             })\n-        })\n+        }\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n@@ -1911,21 +1902,14 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         }).unwrap().into_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n-                    c::tag_table_upvar_borrow_map => {\n+                    c::tag_table_upvar_capture_map => {\n                         let var_id: ast::NodeId = Decodable::decode(val_dsr).unwrap();\n                         let upvar_id = ty::UpvarId {\n                             var_id: dcx.tr_id(var_id),\n                             closure_expr_id: id\n                         };\n-                        let ub: ty::UpvarBorrow = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n-                    }\n-                    c::tag_table_capture_modes => {\n-                        let capture_mode = val_dsr.read_capture_mode();\n-                        dcx.tcx\n-                           .capture_modes\n-                           .borrow_mut()\n-                           .insert(id, capture_mode);\n+                        let ub: ty::UpvarCapture = Decodable::decode(val_dsr).unwrap();\n+                        dcx.tcx.upvar_capture_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);"}, {"sha": "7ef6ba3c190806bd801aa40159fa1b1b517adda8", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -1208,53 +1208,32 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n         ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n-            match self.tcx().capture_mode(closure_expr.id) {\n-                ast::CaptureByRef => {\n-                    self.walk_by_ref_captures(closure_expr, freevars);\n-                }\n-                ast::CaptureByValue => {\n-                    self.walk_by_value_captures(closure_expr, freevars);\n+            for freevar in freevars.iter() {\n+                let id_var = freevar.def.def_id().node;\n+                let upvar_id = ty::UpvarId { var_id: id_var,\n+                                             closure_expr_id: closure_expr.id };\n+                let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+                let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n+                                                                   closure_expr.span,\n+                                                                   freevar.def));\n+                match upvar_capture {\n+                    ty::UpvarCapture::ByValue => {\n+                        let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n+                        self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n+                    }\n+                    ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                        self.delegate.borrow(closure_expr.id,\n+                                             closure_expr.span,\n+                                             cmt_var,\n+                                             upvar_borrow.region,\n+                                             upvar_borrow.kind,\n+                                             ClosureCapture(freevar.span));\n+                    }\n                 }\n             }\n         });\n     }\n \n-    fn walk_by_ref_captures(&mut self,\n-                            closure_expr: &ast::Expr,\n-                            freevars: &[ty::Freevar]) {\n-        for freevar in freevars.iter() {\n-            let id_var = freevar.def.def_id().node;\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n-\n-            // Lookup the kind of borrow the callee requires, as\n-            // inferred by regionbk\n-            let upvar_id = ty::UpvarId { var_id: id_var,\n-                                         closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n-\n-            self.delegate.borrow(closure_expr.id,\n-                                 closure_expr.span,\n-                                 cmt_var,\n-                                 upvar_borrow.region,\n-                                 upvar_borrow.kind,\n-                                 ClosureCapture(freevar.span));\n-        }\n-    }\n-\n-    fn walk_by_value_captures(&mut self,\n-                              closure_expr: &ast::Expr,\n-                              freevars: &[ty::Freevar]) {\n-        for freevar in freevars.iter() {\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n-            let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n-            self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n-        }\n-    }\n-\n     fn cat_captured_var(&mut self,\n                         closure_id: ast::NodeId,\n                         closure_span: Span,"}, {"sha": "5fe5a4c7eb2cf7a4dbe38dda5e0af2fefa095095", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 115, "deletions": 120, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -277,9 +277,7 @@ pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow>;\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause;\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture>;\n }\n \n impl MutabilityCategory {\n@@ -595,8 +593,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               match ty.sty {\n                   ty::ty_closure(closure_id, _, _) => {\n                       let kind = self.typer.closure_kind(closure_id);\n-                      let mode = self.typer.capture_mode(fn_node_id);\n-                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode)\n+                      self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                   }\n                   _ => {\n                       self.tcx().sess.span_bug(\n@@ -628,10 +625,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId,\n-                 kind: ty::ClosureKind,\n-                 mode: ast::CaptureClause)\n-                 -> McResult<cmt<'tcx>> {\n-        // An upvar can have up to 3 components.  The base is a\n+                 kind: ty::ClosureKind)\n+                 -> McResult<cmt<'tcx>>\n+    {\n+        // An upvar can have up to 3 components. We translate first to a\n+        // `cat_upvar`, which is itself a fiction -- it represents the reference to the\n+        // field from the environment.\n+        //\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n         // appropriate borrow kind for closure kinds that take self by\n@@ -650,135 +650,130 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // Fn             | copied -> &'env      | upvar -> &'env -> &'up bk\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n-        let var_ty = try!(self.node_ty(var_id));\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n+        let var_ty = try!(self.node_ty(var_id));\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n \n-        // Construct information about env pointer dereference, if any\n-        let mutbl = match kind {\n-            ty::FnOnceClosureKind => None, // None, env is by-value\n-            ty::FnMutClosureKind => match mode { // Depends on capture type\n-                ast::CaptureByValue => Some(var_mutbl), // Mutable if the original var is\n-                ast::CaptureByRef => Some(McDeclared) // Mutable regardless\n-            },\n-            ty::FnClosureKind => Some(McImmutable) // Never mutable\n+        // Construct the upvar. This represents access to the field\n+        // from the environment (perhaps we should eventually desugar\n+        // this field further, but it will do for now).\n+        let cmt_result = cmt_ {\n+            id: id,\n+            span: span,\n+            cat: cat_upvar(Upvar {id: upvar_id, kind: kind}),\n+            mutbl: var_mutbl,\n+            ty: var_ty,\n+            note: NoteNone\n         };\n-        let env_info = mutbl.map(|env_mutbl| {\n-            // Look up the node ID of the closure body so we can construct\n-            // a free region within it\n-            let fn_body_id = {\n-                let fn_expr = match self.tcx().map.find(fn_node_id) {\n-                    Some(ast_map::NodeExpr(e)) => e,\n-                    _ => unreachable!()\n-                };\n \n-                match fn_expr.node {\n-                    ast::ExprClosure(_, _, _, ref body) => body.id,\n-                    _ => unreachable!()\n-                }\n-            };\n-\n-            // Region of environment pointer\n-            let env_region = ty::ReFree(ty::FreeRegion {\n-                scope: region::CodeExtent::from_node_id(fn_body_id),\n-                bound_region: ty::BrEnv\n-            });\n-\n-            let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n-                ty::MutBorrow\n-            } else {\n-                ty::ImmBorrow\n-            }, env_region);\n-\n-            (env_mutbl, env_ptr)\n-        });\n+        // If this is a `FnMut` or `Fn` closure, then the above is\n+        // conceptually a `&mut` or `&` reference, so we have to add a\n+        // deref.\n+        let cmt_result = match kind {\n+            ty::FnOnceClosureKind => {\n+                cmt_result\n+            }\n+            ty::FnMutClosureKind => {\n+                self.env_deref(id, span, upvar_id, var_mutbl, ty::MutBorrow, cmt_result)\n+            }\n+            ty::FnClosureKind => {\n+                self.env_deref(id, span, upvar_id, var_mutbl, ty::ImmBorrow, cmt_result)\n+            }\n+        };\n \n-        // First, switch by capture mode\n-        Ok(match mode {\n-            ast::CaptureByValue => {\n-                let mut base = cmt_ {\n+        // If this is a by-ref capture, then the upvar we loaded is\n+        // actually a reference, so we have to add an implicit deref\n+        // for that.\n+        let upvar_id = ty::UpvarId { var_id: var_id,\n+                                     closure_expr_id: fn_node_id };\n+        let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+        let cmt_result = match upvar_capture {\n+            ty::UpvarCapture::ByValue => {\n+                cmt_result\n+            }\n+            ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+                cmt_ {\n                     id: id,\n                     span: span,\n-                    cat: cat_upvar(Upvar {\n-                        id: upvar_id,\n-                        kind: kind\n-                    }),\n-                    mutbl: var_mutbl,\n+                    cat: cat_deref(Rc::new(cmt_result), 0, ptr),\n+                    mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n                     ty: var_ty,\n-                    note: NoteNone\n-                };\n-\n-                match env_info {\n-                    Some((env_mutbl, env_ptr)) => {\n-                        // We need to add the env deref.  This means\n-                        // that the above is actually immutable and\n-                        // has a ref type.  However, nothing should\n-                        // actually look at the type, so we can get\n-                        // away with stuffing a `ty_err` in there\n-                        // instead of bothering to construct a proper\n-                        // one.\n-                        base.mutbl = McImmutable;\n-                        base.ty = self.tcx().types.err;\n-                        Rc::new(cmt_ {\n-                            id: id,\n-                            span: span,\n-                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                            mutbl: env_mutbl,\n-                            ty: var_ty,\n-                            note: NoteClosureEnv(upvar_id)\n-                        })\n-                    }\n-                    None => Rc::new(base)\n+                    note: NoteUpvarRef(upvar_id)\n                 }\n-            },\n-            ast::CaptureByRef => {\n-                // The type here is actually a ref (or ref of a ref),\n-                // but we can again get away with not constructing one\n-                // properly since it will never be used.\n-                let mut base = cmt_ {\n-                    id: id,\n-                    span: span,\n-                    cat: cat_upvar(Upvar {\n-                        id: upvar_id,\n-                        kind: kind\n-                    }),\n-                    mutbl: McImmutable,\n-                    ty: self.tcx().types.err,\n-                    note: NoteNone\n-                };\n+            }\n+        };\n \n-                match env_info {\n-                    Some((env_mutbl, env_ptr)) => {\n-                        base = cmt_ {\n-                            id: id,\n-                            span: span,\n-                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                            mutbl: env_mutbl,\n-                            ty: self.tcx().types.err,\n-                            note: NoteClosureEnv(upvar_id)\n-                        };\n-                    }\n-                    None => {}\n-                }\n+        Ok(Rc::new(cmt_result))\n+    }\n \n-                // Look up upvar borrow so we can get its region\n-                let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n-                let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+    fn env_deref(&self,\n+                 id: ast::NodeId,\n+                 span: Span,\n+                 upvar_id: ty::UpvarId,\n+                 upvar_mutbl: MutabilityCategory,\n+                 env_borrow_kind: ty::BorrowKind,\n+                 cmt_result: cmt_<'tcx>)\n+                 -> cmt_<'tcx>\n+    {\n+        // Look up the node ID of the closure body so we can construct\n+        // a free region within it\n+        let fn_body_id = {\n+            let fn_expr = match self.tcx().map.find(upvar_id.closure_expr_id) {\n+                Some(ast_map::NodeExpr(e)) => e,\n+                _ => unreachable!()\n+            };\n \n-                Rc::new(cmt_ {\n-                    id: id,\n-                    span: span,\n-                    cat: cat_deref(Rc::new(base), 0, ptr),\n-                    mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n-                    ty: var_ty,\n-                    note: NoteUpvarRef(upvar_id)\n-                })\n+            match fn_expr.node {\n+                ast::ExprClosure(_, _, _, ref body) => body.id,\n+                _ => unreachable!()\n             }\n-        })\n+        };\n+\n+        // Region of environment pointer\n+        let env_region = ty::ReFree(ty::FreeRegion {\n+            scope: region::CodeExtent::from_node_id(fn_body_id),\n+            bound_region: ty::BrEnv\n+        });\n+\n+        let env_ptr = BorrowedPtr(env_borrow_kind, env_region);\n+\n+        let var_ty = cmt_result.ty;\n+\n+        // We need to add the env deref.  This means\n+        // that the above is actually immutable and\n+        // has a ref type.  However, nothing should\n+        // actually look at the type, so we can get\n+        // away with stuffing a `ty_err` in there\n+        // instead of bothering to construct a proper\n+        // one.\n+        let cmt_result = cmt_ {\n+            mutbl: McImmutable,\n+            ty: self.tcx().types.err,\n+            ..cmt_result\n+        };\n+\n+        let mut deref_mutbl = MutabilityCategory::from_borrow_kind(env_borrow_kind);\n+\n+        // Issue #18335. If variable is declared as immutable, override the\n+        // mutability from the environment and substitute an `&T` anyway.\n+        match upvar_mutbl {\n+            McImmutable => { deref_mutbl = McImmutable; }\n+            McDeclared | McInherited => { }\n+        }\n+\n+        cmt_ {\n+            id: id,\n+            span: span,\n+            cat: cat_deref(Rc::new(cmt_result), 0, env_ptr),\n+            mutbl: deref_mutbl,\n+            ty: var_ty,\n+            note: NoteClosureEnv(upvar_id)\n+        }\n     }\n \n     pub fn cat_rvalue_node(&self,"}, {"sha": "9958d015a8cd3f31fc61c840ce4b3395a6c91dae", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 57, "deletions": 103, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -777,7 +777,7 @@ pub struct ctxt<'tcx> {\n     pub populated_external_traits: RefCell<DefIdSet>,\n \n     /// Borrows\n-    pub upvar_borrow_map: RefCell<UpvarBorrowMap>,\n+    pub upvar_capture_map: RefCell<UpvarCaptureMap>,\n \n     /// These two caches are used by const_eval when decoding external statics\n     /// and variants that are found.\n@@ -803,9 +803,6 @@ pub struct ctxt<'tcx> {\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index>,\n \n-    /// Maps closures to their capture clauses.\n-    pub capture_modes: RefCell<CaptureModeMap>,\n-\n     /// Maps def IDs to true if and only if they're associated types.\n     pub associated_types: RefCell<DefIdMap<bool>>,\n \n@@ -1247,60 +1244,31 @@ pub enum BorrowKind {\n     MutBorrow\n }\n \n-/// Information describing the borrowing of an upvar. This is computed\n-/// during `typeck`, specifically by `regionck`. The general idea is\n-/// that the compiler analyses treat closures like:\n-///\n-///     let closure: &'e fn() = || {\n-///        x = 1;   // upvar x is assigned to\n-///        use(y);  // upvar y is read\n-///        foo(&z); // upvar z is borrowed immutably\n-///     };\n-///\n-/// as if they were \"desugared\" to something loosely like:\n-///\n-///     struct Vars<'x,'y,'z> { x: &'x mut int,\n-///                             y: &'y const int,\n-///                             z: &'z int }\n-///     let closure: &'e fn() = {\n-///         fn f(env: &Vars) {\n-///             *env.x = 1;\n-///             use(*env.y);\n-///             foo(env.z);\n-///         }\n-///         let env: &'e mut Vars<'x,'y,'z> = &mut Vars { x: &'x mut x,\n-///                                                       y: &'y const y,\n-///                                                       z: &'z z };\n-///         (env, f)\n-///     };\n-///\n-/// This is basically what happens at runtime. The closure is basically\n-/// an existentially quantified version of the `(env, f)` pair.\n-///\n-/// This data structure indicates the region and mutability of a single\n-/// one of the `x...z` borrows.\n-///\n-/// It may not be obvious why each borrowed variable gets its own\n-/// lifetime (in the desugared version of the example, these are indicated\n-/// by the lifetime parameters `'x`, `'y`, and `'z` in the `Vars` definition).\n-/// Each such lifetime must encompass the lifetime `'e` of the closure itself,\n-/// but need not be identical to it. The reason that this makes sense:\n-///\n-/// - Callers are only permitted to invoke the closure, and hence to\n-///   use the pointers, within the lifetime `'e`, so clearly `'e` must\n-///   be a sublifetime of `'x...'z`.\n-/// - The closure creator knows which upvars were borrowed by the closure\n-///   and thus `x...z` will be reserved for `'x...'z` respectively.\n-/// - Through mutation, the borrowed upvars can actually escape\n-///   the closure, so sometimes it is necessary for them to be larger\n-///   than the closure lifetime itself.\n+/// Information describing the capture of an upvar. This is computed\n+/// during `typeck`, specifically by `regionck`.\n+#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+pub enum UpvarCapture {\n+    /// Upvar is captured by value. This is always true when the\n+    /// closure is labeled `move`, but can also be true in other cases\n+    /// depending on inference.\n+    ByValue,\n+\n+    /// Upvar is captured by reference.\n+    ByRef(UpvarBorrow),\n+}\n+\n #[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct UpvarBorrow {\n+    /// The kind of borrow: by-ref upvars have access to shared\n+    /// immutable borrows, which are not part of the normal language\n+    /// syntax.\n     pub kind: BorrowKind,\n+\n+    /// Region of the resulting reference.\n     pub region: ty::Region,\n }\n \n-pub type UpvarBorrowMap = FnvHashMap<UpvarId, UpvarBorrow>;\n+pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n \n impl Region {\n     pub fn is_bound(&self) -> bool {\n@@ -1320,7 +1288,7 @@ impl Region {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-           RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Debug, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n@@ -1329,7 +1297,7 @@ pub struct FreeRegion {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-           RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -2359,7 +2327,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n-                     capture_modes: RefCell<CaptureModeMap>,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx>\n@@ -2413,7 +2380,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         used_mut_nodes: RefCell::new(NodeSet()),\n         populated_external_types: RefCell::new(DefIdSet()),\n         populated_external_traits: RefCell::new(DefIdSet()),\n-        upvar_borrow_map: RefCell::new(FnvHashMap()),\n+        upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n         extern_const_variants: RefCell::new(DefIdMap()),\n         method_map: RefCell::new(FnvHashMap()),\n@@ -2422,7 +2389,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         node_lint_levels: RefCell::new(FnvHashMap()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n-        capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap()),\n@@ -5646,7 +5612,6 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n     let tcx = typer.tcx();\n-    let capture_mode = tcx.capture_modes.borrow()[closure_id.node].clone();\n     match tcx.freevars.borrow().get(&closure_id.node) {\n         None => Some(vec![]),\n         Some(ref freevars) => {\n@@ -5659,43 +5624,38 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n                         };\n                         let freevar_ty = freevar_ty.subst(tcx, substs);\n \n-                        match capture_mode {\n-                            ast::CaptureByValue => {\n-                                Some(ClosureUpvar { def: freevar.def,\n-                                                    span: freevar.span,\n-                                                    ty: freevar_ty })\n+                        let upvar_id = ty::UpvarId {\n+                            var_id: freevar_def_id.node,\n+                            closure_expr_id: closure_id.node\n+                        };\n+\n+                        let captured_freevar_ty = match typer.upvar_capture(upvar_id) {\n+                            Some(UpvarCapture::ByValue) => {\n+                                freevar_ty\n                             }\n \n-                            ast::CaptureByRef => {\n-                                let upvar_id = ty::UpvarId {\n-                                    var_id: freevar_def_id.node,\n-                                    closure_expr_id: closure_id.node\n-                                };\n+                            Some(UpvarCapture::ByRef(borrow)) => {\n+                                mk_rptr(tcx,\n+                                        tcx.mk_region(borrow.region),\n+                                        ty::mt {\n+                                            ty: freevar_ty,\n+                                            mutbl: borrow.kind.to_mutbl_lossy(),\n+                                        })\n+                            }\n \n-                                // FIXME\n-                                let freevar_ref_ty = match typer.upvar_borrow(upvar_id) {\n-                                    Some(borrow) => {\n-                                        mk_rptr(tcx,\n-                                                tcx.mk_region(borrow.region),\n-                                                ty::mt {\n-                                                    ty: freevar_ty,\n-                                                    mutbl: borrow.kind.to_mutbl_lossy(),\n-                                                })\n-                                    }\n-                                    None => {\n-                                        // FIXME(#16640) we should really return None here;\n-                                        // but that requires better inference integration,\n-                                        // for now gin up something.\n-                                        freevar_ty\n-                                    }\n-                                };\n-                                Some(ClosureUpvar {\n-                                    def: freevar.def,\n-                                    span: freevar.span,\n-                                    ty: freevar_ref_ty,\n-                                })\n+                            None => {\n+                                // FIXME(#16640) we should really return None here;\n+                                // but that requires better inference integration,\n+                                // for now gin up something.\n+                                freevar_ty\n                             }\n-                        }\n+                        };\n+\n+                        Some(ClosureUpvar {\n+                            def: freevar.def,\n+                            span: freevar.span,\n+                            ty: captured_freevar_ty,\n+                        })\n                     })\n                     .collect()\n         }\n@@ -6449,14 +6409,13 @@ impl BorrowKind {\n }\n \n impl<'tcx> ctxt<'tcx> {\n-    pub fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.capture_modes.borrow()[closure_expr_id].clone()\n-    }\n-\n     pub fn is_method_call(&self, expr_id: ast::NodeId) -> bool {\n         self.method_map.borrow().contains_key(&MethodCall::expr(expr_id))\n     }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        Some(self.upvar_capture_map.borrow()[upvar_id].clone())\n+    }\n }\n \n impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n@@ -6494,13 +6453,8 @@ impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n         self.tcx.region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        Some(self.tcx.upvar_borrow_map.borrow()[upvar_id].clone())\n-    }\n-\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.tcx.capture_mode(closure_expr_id)\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.tcx.upvar_capture(upvar_id)\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {"}, {"sha": "15a91fd0f8da08cb159f6a333588bf3e1c6f18fc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -1292,6 +1292,15 @@ impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::UpvarCapture {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        match *self {\n+            ty::UpvarCapture::ByValue => format!(\"ByValue\"),\n+            ty::UpvarCapture::ByRef(ref data) => format!(\"ByRef({})\", data.repr(tcx)),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::IntVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{:?}\", self)"}, {"sha": "fc64cf9470ad7812136e592c5bc4e2e45a3a385f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -560,7 +560,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let resolve::CrateMap {\n         def_map,\n         freevars,\n-        capture_mode_map,\n         export_map,\n         trait_map,\n         external_exports,\n@@ -606,7 +605,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             named_region_map,\n                             ast_map,\n                             freevars,\n-                            capture_mode_map,\n                             region_map,\n                             lang_items,\n                             stability_index);"}, {"sha": "45ff1c4537cd5fdffe32e1de005c02a4ed94c4a7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -121,7 +121,7 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n-    let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n+    let resolve::CrateMap { def_map, freevars, .. } =\n         resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n@@ -132,7 +132,6 @@ fn test_env<F>(source_string: &str,\n                           named_region_map,\n                           ast_map,\n                           freevars,\n-                          capture_mode_map,\n                           region_map,\n                           lang_items,\n                           stability_index);"}, {"sha": "c099762036a969813e62d0620d29cff86d6812bd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::lang_items::LanguageItems;\n use rustc::middle::pat_util::pat_bindings;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n-use rustc::middle::ty::{CaptureModeMap, Freevar, FreevarMap, TraitMap, GlobMap};\n+use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n@@ -900,7 +900,6 @@ struct Resolver<'a, 'tcx:'a> {\n     def_map: DefMap,\n     freevars: RefCell<FreevarMap>,\n     freevars_seen: RefCell<NodeMap<NodeSet>>,\n-    capture_mode_map: CaptureModeMap,\n     export_map: ExportMap,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n@@ -974,7 +973,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             def_map: RefCell::new(NodeMap()),\n             freevars: RefCell::new(NodeMap()),\n             freevars_seen: RefCell::new(NodeMap()),\n-            capture_mode_map: NodeMap(),\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n             used_imports: HashSet::new(),\n@@ -4523,8 +4521,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprClosure(capture_clause, _, ref fn_decl, ref block) => {\n-                self.capture_mode_map.insert(expr.id, capture_clause);\n+            ExprClosure(_, _, ref fn_decl, ref block) => {\n                 self.resolve_function(ClosureRibKind(expr.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n@@ -4835,7 +4832,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n pub struct CrateMap {\n     pub def_map: DefMap,\n     pub freevars: RefCell<FreevarMap>,\n-    pub capture_mode_map: RefCell<CaptureModeMap>,\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n@@ -4875,7 +4871,6 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     CrateMap {\n         def_map: resolver.def_map,\n         freevars: resolver.freevars,\n-        capture_mode_map: RefCell::new(resolver.capture_mode_map),\n         export_map: resolver.export_map,\n         trait_map: resolver.trait_map,\n         external_exports: resolver.external_exports,"}, {"sha": "42bbbff22cd26a17ab514ddf6244d26f35e5d67a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -1789,7 +1789,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx = new_fn_ctxt(ccx,\n                       llfndecl,\n                       fn_ast_id,\n-                      closure_env.kind != closure::NotClosure,\n+                      closure_env.kind != closure::ClosureKind::NotClosure,\n                       output_type,\n                       param_substs,\n                       Some(body.span),\n@@ -1809,12 +1809,12 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n     let monomorphized_arg_types = match closure_env.kind {\n-        closure::NotClosure => {\n+        closure::ClosureKind::NotClosure => {\n             monomorphized_arg_types\n         }\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        closure::Closure(..) => {\n+        closure::ClosureKind::Closure => {\n             vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n         }\n     };\n@@ -1836,13 +1836,13 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n \n     bcx = match closure_env.kind {\n-        closure::NotClosure => {\n+        closure::ClosureKind::NotClosure => {\n             copy_args_to_allocas(bcx,\n                                  arg_scope,\n                                  &decl.inputs[],\n                                  arg_datums)\n         }\n-        closure::Closure(..) => {\n+        closure::ClosureKind::Closure => {\n             copy_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n@@ -1932,7 +1932,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   attrs,\n                   output_type,\n                   abi,\n-                  closure::ClosureEnv::new(&[], closure::NotClosure));\n+                  closure::ClosureEnv::new(&[], closure::ClosureKind::NotClosure));\n }\n \n pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "99ae0dc1007d6c200d283fab316aa1fea7f9e2f1", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::ClosureKind::*;\n-\n use back::link::mangle_internal_name_by_path_and_seq;\n use middle::mem_categorization::Typer;\n use trans::adt;\n@@ -33,9 +31,9 @@ use syntax::ast_util;\n \n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         arg_scope_id: ScopeId,\n-                                        freevar_mode: ast::CaptureClause,\n                                         freevars: &[ty::Freevar])\n-                                        -> Block<'blk, 'tcx> {\n+                                        -> Block<'blk, 'tcx>\n+{\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n@@ -65,18 +63,21 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     for (i, freevar) in freevars.iter().enumerate() {\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n+                                     closure_expr_id: closure_id.node };\n+        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n         let mut upvar_ptr = GEPi(bcx, llenv, &[0, i]);\n-        let captured_by_ref = match freevar_mode {\n-            ast::CaptureByRef => {\n+        let captured_by_ref = match upvar_capture {\n+            ty::UpvarCapture::ByValue => false,\n+            ty::UpvarCapture::ByRef(..) => {\n                 upvar_ptr = Load(bcx, upvar_ptr);\n                 true\n             }\n-            ast::CaptureByValue => false\n         };\n         let def_id = freevar.def.def_id();\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n \n-        if kind == ty::FnOnceClosureKind && freevar_mode == ast::CaptureByValue {\n+        if kind == ty::FnOnceClosureKind && !captured_by_ref {\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n                                       node_id_type(bcx, def_id.node))\n@@ -99,8 +100,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n #[derive(PartialEq)]\n pub enum ClosureKind<'tcx> {\n     NotClosure,\n-    // See load_closure_environment.\n-    Closure(ast::CaptureClause)\n+    Closure,\n }\n \n pub struct ClosureEnv<'a, 'tcx> {\n@@ -125,9 +125,9 @@ impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n         }\n \n         match self.kind {\n-            NotClosure => bcx,\n-            Closure(freevar_mode) => {\n-                load_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n+            ClosureKind::NotClosure => bcx,\n+            ClosureKind::Closure => {\n+                load_closure_environment(bcx, arg_scope, self.freevars)\n             }\n         }\n     }\n@@ -212,7 +212,6 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let freevars: Vec<ty::Freevar> =\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n-    let freevar_mode = bcx.tcx().capture_mode(id);\n \n     let sig = ty::erase_late_bound_regions(bcx.tcx(), &function_type.sig);\n \n@@ -225,8 +224,7 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::new(&freevars[],\n-                                  Closure(freevar_mode)));\n+                  ClosureEnv::new(&freevars[], ClosureKind::Closure));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and\n@@ -249,11 +247,14 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                    dest_addr,\n                                                    0,\n                                                    i);\n-        match freevar_mode {\n-            ast::CaptureByValue => {\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n+                                     closure_expr_id: id };\n+        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n+        match upvar_capture {\n+            ty::UpvarCapture::ByValue => {\n                 bcx = datum.store_to(bcx, upvar_slot_dest);\n             }\n-            ast::CaptureByRef => {\n+            ty::UpvarCapture::ByRef(..) => {\n                 Store(bcx, datum.to_llref(), upvar_slot_dest);\n             }\n         }"}, {"sha": "a0dbc9c40a68d535473c744552c58136e04970aa", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -679,13 +679,8 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n-    }\n-\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        Some(self.tcx().upvar_capture_map.borrow()[upvar_id].clone())\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {"}, {"sha": "0c4bec48dd46cf5227e690d46610e7d83038099f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -160,7 +160,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     item_substs: RefCell<NodeMap<ty::ItemSubsts<'tcx>>>,\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n     method_map: MethodMap<'tcx>,\n-    upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n+    upvar_capture_map: RefCell<ty::UpvarCaptureMap>,\n     closures: RefCell<DefIdMap<ty::Closure<'tcx>>>,\n     object_cast_map: ObjectCastMap<'tcx>,\n \n@@ -330,12 +330,8 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n         self.param_env().temporary_scope(rvalue_id)\n     }\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        self.inh.upvar_borrow_map.borrow().get(&upvar_id).cloned()\n-    }\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.ccx.tcx.capture_mode(closure_expr_id)\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.inh.upvar_capture_map.borrow().get(&upvar_id).cloned()\n     }\n }\n \n@@ -378,7 +374,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             adjustments: RefCell::new(NodeMap()),\n             method_map: RefCell::new(FnvHashMap()),\n             object_cast_map: RefCell::new(NodeMap()),\n-            upvar_borrow_map: RefCell::new(FnvHashMap()),\n+            upvar_capture_map: RefCell::new(FnvHashMap()),\n             closures: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),"}, {"sha": "d1fee578218280230fad008bbd56eabb96ff9f0e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -742,16 +742,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     match function_type.sty {\n         ty::ty_closure(_, region, _) => {\n-            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n-                ty::with_freevars(tcx, expr.id, |freevars| {\n-                    if !freevars.is_empty() {\n-                        // Variables being referenced must be constrained and registered\n-                        // in the upvar borrow map\n-                        constrain_free_variables_in_by_ref_closure(\n-                            rcx, *region, expr, freevars);\n-                    }\n-                })\n-            }\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n+                constrain_captured_variables(rcx, *region, expr, freevars);\n+            })\n         }\n         _ => { }\n     }\n@@ -799,14 +792,14 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let raw_var_ty = rcx.resolve_node_type(var_node_id);\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n-            let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().get(&upvar_id) {\n-                Some(upvar_borrow) => {\n+            let var_ty = match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n+                ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n                     ty::mk_rptr(rcx.tcx(),\n                                 rcx.tcx().mk_region(upvar_borrow.region),\n                                 ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n                                          ty: raw_var_ty })\n                 }\n-                None => raw_var_ty\n+                ty::UpvarCapture::ByValue => raw_var_ty,\n             };\n \n             // Check that the type meets the criteria of the existential bounds:\n@@ -824,17 +817,17 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     /// Make sure that all free variables referenced inside the closure outlive the closure's\n     /// lifetime bound. Also, create an entry in the upvar_borrows map with a region.\n-    fn constrain_free_variables_in_by_ref_closure(\n+    fn constrain_captured_variables(\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n         freevars: &[ty::Freevar])\n     {\n         let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"constrain_free_variables({}, {})\",\n+        debug!(\"constrain_captured_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n-            debug!(\"freevar def is {:?}\", freevar.def);\n+            debug!(\"constrain_captured_variables: freevar.def={:?}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n@@ -846,16 +839,20 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n \n-            let upvar_borrow = rcx.fcx.inh.upvar_borrow_map.borrow()[upvar_id];\n-\n-            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                            region_bound, upvar_borrow.region);\n-\n-            // Guarantee that the closure does not outlive the variable itself.\n-            let enclosing_region = region_of_def(rcx.fcx, def);\n-            debug!(\"enclosing_region = {}\", enclosing_region.repr(tcx));\n-            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                            region_bound, enclosing_region);\n+            match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n+                ty::UpvarCapture::ByValue => { }\n+                ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                                    region_bound, upvar_borrow.region);\n+\n+                    // Guarantee that the closure does not outlive the variable itself.\n+                    let enclosing_region = region_of_def(rcx.fcx, def);\n+                    debug!(\"constrain_captured_variables: enclosing_region = {}\",\n+                           enclosing_region.repr(tcx));\n+                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                                    region_bound, enclosing_region);\n+                }\n+            }\n         }\n     }\n }\n@@ -1333,22 +1330,20 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // Detect by-ref upvar `x`:\n     let cause = match note {\n         mc::NoteUpvarRef(ref upvar_id) => {\n-            let mut upvar_borrow_map =\n-                rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-            match upvar_borrow_map.get_mut(upvar_id) {\n-                Some(upvar_borrow) => {\n+            let upvar_capture_map = rcx.fcx.inh.upvar_capture_map.borrow_mut();\n+            match upvar_capture_map.get(upvar_id) {\n+                Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                     // The mutability of the upvar may have been modified\n                     // by the above adjustment, so update our local variable.\n                     ref_kind = upvar_borrow.kind;\n \n                     infer::ReborrowUpvar(span, *upvar_id)\n                 }\n-                None => {\n+                _ => {\n                     rcx.tcx().sess.span_bug(\n                         span,\n                         &format!(\"Illegal upvar id: {}\",\n-                                upvar_id.repr(\n-                                    rcx.tcx()))[]);\n+                                upvar_id.repr(rcx.tcx()))[]);\n                 }\n             }\n         }"}, {"sha": "22e4716f4bdc5fe3fcc8eda413059f0cb39a4f0c", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -121,25 +121,29 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      capture_clause: ast::CaptureClause,\n                      _body: &ast::Block)\n     {\n-        match capture_clause {\n-            ast::CaptureByValue => {}\n-            _ => {\n-                ty::with_freevars(self.tcx(), expr.id, |freevars| {\n-                    for freevar in freevars.iter() {\n-                        let var_node_id = freevar.def.local_node_id();\n-                        let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                                     closure_expr_id: expr.id };\n-                        debug!(\"seed upvar_id {:?}\", upvar_id);\n+        ty::with_freevars(self.tcx(), expr.id, |freevars| {\n+            for freevar in freevars.iter() {\n+                let var_node_id = freevar.def.local_node_id();\n+                let upvar_id = ty::UpvarId { var_id: var_node_id,\n+                                             closure_expr_id: expr.id };\n+                debug!(\"seed upvar_id {:?}\", upvar_id);\n+\n+                let capture_kind = match capture_clause {\n+                    ast::CaptureByValue => {\n+                        ty::UpvarCapture::ByValue\n+                    }\n+                    ast::CaptureByRef => {\n                         let origin = UpvarRegion(upvar_id, expr.span);\n                         let freevar_region = self.infcx().next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n                                                              region: freevar_region };\n-                        self.fcx.inh.upvar_borrow_map.borrow_mut().insert(upvar_id,\n-                                                                          upvar_borrow);\n+                        ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n-                });\n+                };\n+\n+                self.fcx.inh.upvar_capture_map.borrow_mut().insert(upvar_id, capture_kind);\n             }\n-        }\n+        });\n     }\n }\n \n@@ -150,7 +154,7 @@ struct AdjustBorrowKind<'a,'tcx:'a> {\n     fcx: &'a FnCtxt<'a,'tcx>\n }\n \n-impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n+impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>) -> AdjustBorrowKind<'a,'tcx> {\n         AdjustBorrowKind { fcx: fcx }\n     }\n@@ -195,8 +199,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n                     // upvar, then we need to modify the\n                     // borrow_kind of the upvar to make sure it\n                     // is inferred to mutable if necessary\n-                    let mut upvar_borrow_map = self.fcx.inh.upvar_borrow_map.borrow_mut();\n-                    let ub = &mut upvar_borrow_map[upvar_id];\n+                    let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                    let ub = &mut upvar_capture_map[upvar_id];\n                     self.adjust_upvar_borrow_kind(upvar_id, ub, ty::MutBorrow);\n                 } else {\n                     // assignment to deref of an `&mut`\n@@ -237,7 +241,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n                     // upvar, then we need to modify the\n                     // borrow_kind of the upvar to make sure it\n                     // is inferred to unique if necessary\n-                    let mut ub = self.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let mut ub = self.fcx.inh.upvar_capture_map.borrow_mut();\n                     let ub = &mut ub[upvar_id];\n                     self.adjust_upvar_borrow_kind(upvar_id, ub, ty::UniqueImmBorrow);\n                 } else {\n@@ -262,23 +266,30 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n     /// some particular use.\n     fn adjust_upvar_borrow_kind(&self,\n                                 upvar_id: ty::UpvarId,\n-                                upvar_borrow: &mut ty::UpvarBorrow,\n+                                upvar_capture: &mut ty::UpvarCapture,\n                                 kind: ty::BorrowKind) {\n-        debug!(\"adjust_upvar_borrow_kind: id={:?} kind=({:?} -> {:?})\",\n-               upvar_id, upvar_borrow.kind, kind);\n-\n-        match (upvar_borrow.kind, kind) {\n-            // Take RHS:\n-            (ty::ImmBorrow, ty::UniqueImmBorrow) |\n-            (ty::ImmBorrow, ty::MutBorrow) |\n-            (ty::UniqueImmBorrow, ty::MutBorrow) => {\n-                upvar_borrow.kind = kind;\n+        debug!(\"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n+               upvar_id, upvar_capture, kind);\n+\n+        match *upvar_capture {\n+            ty::UpvarCapture::ByValue => {\n+                // Upvar is already by-value, the strongest criteria.\n             }\n-            // Take LHS:\n-            (ty::ImmBorrow, ty::ImmBorrow) |\n-            (ty::UniqueImmBorrow, ty::ImmBorrow) |\n-            (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-            (ty::MutBorrow, _) => {\n+            ty::UpvarCapture::ByRef(ref mut upvar_borrow) => {\n+                match (upvar_borrow.kind, kind) {\n+                    // Take RHS:\n+                    (ty::ImmBorrow, ty::UniqueImmBorrow) |\n+                    (ty::ImmBorrow, ty::MutBorrow) |\n+                    (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+                        upvar_borrow.kind = kind;\n+                    }\n+                    // Take LHS:\n+                    (ty::ImmBorrow, ty::ImmBorrow) |\n+                    (ty::UniqueImmBorrow, ty::ImmBorrow) |\n+                    (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n+                    (ty::MutBorrow, _) => {\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "f7e1afed8fc53f219d1ea8d25d771ab447acd7c6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -182,16 +182,20 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        for (upvar_id, upvar_borrow) in self.fcx.inh.upvar_borrow_map.borrow().iter() {\n-            let r = upvar_borrow.region;\n-            let r = self.resolve(&r, ResolvingUpvar(*upvar_id));\n-            let new_upvar_borrow = ty::UpvarBorrow { kind: upvar_borrow.kind,\n-                                                     region: r };\n-            debug!(\"Upvar borrow for {} resolved to {}\",\n+        for (upvar_id, upvar_capture) in self.fcx.inh.upvar_capture_map.borrow().iter() {\n+            let new_upvar_capture = match *upvar_capture {\n+                ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n+                ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n+                    let r = upvar_borrow.region;\n+                    let r = self.resolve(&r, ResolvingUpvar(*upvar_id));\n+                    ty::UpvarCapture::ByRef(\n+                        ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n+                }\n+            };\n+            debug!(\"Upvar capture for {} resolved to {}\",\n                    upvar_id.repr(self.tcx()),\n-                   new_upvar_borrow.repr(self.tcx()));\n-            self.fcx.tcx().upvar_borrow_map.borrow_mut().insert(\n-                *upvar_id, new_upvar_borrow);\n+                   new_upvar_capture.repr(self.tcx()));\n+            self.fcx.tcx().upvar_capture_map.borrow_mut().insert(*upvar_id, new_upvar_capture);\n         }\n     }\n "}, {"sha": "9b9edce243bb77ce9a9c5e94b4ff5356cbe4b752", "filename": "src/test/compile-fail/borrowck-call-is-borrow-issue-12224.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -58,8 +58,10 @@ fn test6() {\n fn test7() {\n     fn foo<F>(_: F) where F: FnMut(Box<FnMut(isize)>, isize) {}\n     let mut f = |&mut: g: Box<FnMut(isize)>, b: isize| {};\n-    f(box |a| { //~ ERROR: cannot borrow `f` as immutable because it is also borrowed as mutable\n-        foo(f); //~ ERROR: cannot move out of captured outer variable\n+    f(box |a| {\n+        foo(f);\n+        //~^ ERROR cannot move `f` into closure because it is borrowed\n+        //~| ERROR cannot move out of captured outer variable in an `FnMut` closure\n     }, 3);\n }\n "}, {"sha": "1312b42fb82d4ccdeaf33e2cb2a738bc415fa182", "filename": "src/test/compile-fail/unboxed-closure-illegal-move.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -19,24 +19,24 @@ fn main() {\n     // By-ref cases\n     {\n         let x = box 0us;\n-        let f = |&:| drop(x); //~ cannot move\n+        let f = |&:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |&mut:| drop(x); //~ cannot move\n+        let f = |&mut:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |:| drop(x); //~ cannot move\n+        let f = |:| drop(x); // OK -- FnOnce\n     }\n     // By-value cases\n     {\n         let x = box 0us;\n-        let f = move |&:| drop(x); //~ cannot move\n+        let f = move |&:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = move |&mut:| drop(x); //~ cannot move\n+        let f = move |&mut:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;"}, {"sha": "96c7948dcb0469253d781a411a6e85ab3bfda608", "filename": "src/test/compile-fail/unboxed-closures-mutate-upvar.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs?ref=2f29cdeb4bdd7aa724d3872deb4d8f59c17aa1bd", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we cannot mutate an outer variable that is not declared\n+// as `mut` through a closure. Also test that we CAN mutate a moved copy,\n+// unless this is a `Fn` closure. Issue #16749.\n+\n+use std::mem;\n+\n+fn a() {\n+    let n = 0u8;\n+    let mut f = |&mut:| { //~ ERROR closure cannot assign\n+        n += 1;\n+    };\n+}\n+\n+fn b() {\n+    let mut n = 0u8;\n+    let mut f = |&mut:| {\n+        n += 1; // OK\n+    };\n+}\n+\n+fn c() {\n+    let n = 0u8;\n+    let mut f = move |&mut:| {\n+        // If we just did a straight-forward desugaring, this would\n+        // compile, but we do something a bit more subtle, and hence\n+        // we get an error.\n+        n += 1; //~ ERROR cannot assign\n+    };\n+}\n+\n+fn d() {\n+    let mut n = 0u8;\n+    let mut f = move |&mut:| {\n+        n += 1; // OK\n+    };\n+}\n+\n+fn e() {\n+    let n = 0u8;\n+    let mut f = move |&:| {\n+        n += 1; //~ ERROR cannot assign\n+    };\n+}\n+\n+fn f() {\n+    let mut n = 0u8;\n+    let mut f = move |&:| {\n+        n += 1; //~ ERROR cannot assign\n+    };\n+}\n+\n+fn main() { }"}]}