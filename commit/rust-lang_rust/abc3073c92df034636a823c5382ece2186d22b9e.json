{"sha": "abc3073c92df034636a823c5382ece2186d22b9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYzMwNzNjOTJkZjAzNDYzNmE4MjNjNTM4MmVjZTIxODZkMjJiOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T16:01:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T16:01:21Z"}, "message": "Auto merge of #69484 - Dylan-DPC:rollup-j6ripxy, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #68712 (Add methods to 'leak' RefCell borrows as references with the lifetime of the original reference)\n - #69209 (Miscellaneous cleanup to formatting)\n - #69381 (Allow getting `no_std` from the config file)\n - #69434 (rustc_metadata: Use binary search from standard library)\n - #69447 (Minor refactoring of statement parsing)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "73aa32f8c52ddbf5dd3c82a6261a6a980a92298d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73aa32f8c52ddbf5dd3c82a6261a6a980a92298d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abc3073c92df034636a823c5382ece2186d22b9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abc3073c92df034636a823c5382ece2186d22b9e", "html_url": "https://github.com/rust-lang/rust/commit/abc3073c92df034636a823c5382ece2186d22b9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abc3073c92df034636a823c5382ece2186d22b9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "892cb143e5984f220e6b26b48d972bd1f4644298", "url": "https://api.github.com/repos/rust-lang/rust/commits/892cb143e5984f220e6b26b48d972bd1f4644298", "html_url": "https://github.com/rust-lang/rust/commit/892cb143e5984f220e6b26b48d972bd1f4644298"}, {"sha": "ae383e2af8c671b3120a3f19c0c167e2df7b23e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae383e2af8c671b3120a3f19c0c167e2df7b23e2", "html_url": "https://github.com/rust-lang/rust/commit/ae383e2af8c671b3120a3f19c0c167e2df7b23e2"}], "stats": {"total": 851, "additions": 445, "deletions": 406}, "files": [{"sha": "746cddbabd6397469cf9292d9618eee52cf722a3", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -177,6 +177,15 @@ pub struct Target {\n     pub no_std: bool,\n }\n \n+impl Target {\n+    pub fn from_triple(triple: &str) -> Self {\n+        let mut target: Self = Default::default();\n+        if triple.contains(\"-none-\") || triple.contains(\"nvptx\") {\n+            target.no_std = true;\n+        }\n+        target\n+    }\n+}\n /// Structure of the `config.toml` file that configuration is read from.\n ///\n /// This structure uses `Decodable` to automatically decode a TOML configuration\n@@ -353,6 +362,7 @@ struct TomlTarget {\n     musl_root: Option<String>,\n     wasi_root: Option<String>,\n     qemu_rootfs: Option<String>,\n+    no_std: Option<bool>,\n }\n \n impl Config {\n@@ -595,7 +605,7 @@ impl Config {\n \n         if let Some(ref t) = toml.target {\n             for (triple, cfg) in t {\n-                let mut target = Target::default();\n+                let mut target = Target::from_triple(triple);\n \n                 if let Some(ref s) = cfg.llvm_config {\n                     target.llvm_config = Some(config.src.join(s));\n@@ -606,6 +616,9 @@ impl Config {\n                 if let Some(ref s) = cfg.android_ndk {\n                     target.ndk = Some(config.src.join(s));\n                 }\n+                if let Some(s) = cfg.no_std {\n+                    target.no_std = s;\n+                }\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.ar = cfg.ar.clone().map(PathBuf::from);"}, {"sha": "530e74da8cac0d9b4703a39effd2c836e9b4aa1d", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -17,6 +17,7 @@ use std::process::Command;\n \n use build_helper::{output, t};\n \n+use crate::config::Target;\n use crate::Build;\n \n struct Finder {\n@@ -192,13 +193,9 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n-        if target.contains(\"-none-\") || target.contains(\"nvptx\") {\n-            if build.no_std(*target).is_none() {\n-                let target = build.config.target_config.entry(target.clone()).or_default();\n-\n-                target.no_std = true;\n-            }\n+        build.config.target_config.entry(target.clone()).or_insert(Target::from_triple(target));\n \n+        if target.contains(\"-none-\") || target.contains(\"nvptx\") {\n             if build.no_std(*target) == Some(false) {\n                 panic!(\"All the *-none-* and nvptx* targets are no-std targets\")\n             }"}, {"sha": "9ebb317641875ae42b31634c61f3eeff9781cff2", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -1245,6 +1245,38 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         let borrow = orig.borrow.clone();\n         (Ref { value: a, borrow }, Ref { value: b, borrow: orig.borrow })\n     }\n+\n+    /// Convert into a reference to the underlying data.\n+    ///\n+    /// The underlying `RefCell` can never be mutably borrowed from again and will always appear\n+    /// already immutably borrowed. It is not a good idea to leak more than a constant number of\n+    /// references. The `RefCell` can be immutably borrowed again if only a smaller number of leaks\n+    /// have occurred in total.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::leak(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_leak)]\n+    /// use std::cell::{RefCell, Ref};\n+    /// let cell = RefCell::new(0);\n+    ///\n+    /// let value = Ref::leak(cell.borrow());\n+    /// assert_eq!(*value, 0);\n+    ///\n+    /// assert!(cell.try_borrow().is_ok());\n+    /// assert!(cell.try_borrow_mut().is_err());\n+    /// ```\n+    #[unstable(feature = \"cell_leak\", issue = \"69099\")]\n+    pub fn leak(orig: Ref<'b, T>) -> &'b T {\n+        // By forgetting this Ref we ensure that the borrow counter in the RefCell never goes back\n+        // to UNUSED again. No further mutable references can be created from the original cell.\n+        mem::forget(orig.borrow);\n+        orig.value\n+    }\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n@@ -1330,6 +1362,37 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         let borrow = orig.borrow.clone();\n         (RefMut { value: a, borrow }, RefMut { value: b, borrow: orig.borrow })\n     }\n+\n+    /// Convert into a mutable reference to the underlying data.\n+    ///\n+    /// The underlying `RefCell` can not be borrowed from again and will always appear already\n+    /// mutably borrowed, making the returned reference the only to the interior.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::leak(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_leak)]\n+    /// use std::cell::{RefCell, RefMut};\n+    /// let cell = RefCell::new(0);\n+    ///\n+    /// let value = RefMut::leak(cell.borrow_mut());\n+    /// assert_eq!(*value, 0);\n+    /// *value = 1;\n+    ///\n+    /// assert!(cell.try_borrow_mut().is_err());\n+    /// ```\n+    #[unstable(feature = \"cell_leak\", issue = \"69099\")]\n+    pub fn leak(orig: RefMut<'b, T>) -> &'b mut T {\n+        // By forgetting this BorrowRefMut we ensure that the borrow counter in the RefCell never\n+        // goes back to UNUSED again. No further references can be created from the original cell,\n+        // making the current borrow the only reference for the remaining lifetime.\n+        mem::forget(orig.borrow);\n+        orig.value\n+    }\n }\n \n struct BorrowRefMut<'b> {"}, {"sha": "5ef673009bb6d8469d765d081344db442194d33a", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -29,7 +29,6 @@ where\n             *num,\n             sign,\n             precision,\n-            false,\n             buf.get_mut(),\n             parts.get_mut(),\n         );\n@@ -59,7 +58,6 @@ where\n             *num,\n             sign,\n             precision,\n-            false,\n             buf.get_mut(),\n             parts.get_mut(),\n         );"}, {"sha": "993b1073493e9dd731b54217675dc6da4fd0d5fb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -238,16 +238,8 @@ pub struct Formatter<'a> {\n // NB. Argument is essentially an optimized partially applied formatting function,\n // equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n \n-struct Void {\n-    _priv: (),\n-    /// Erases all oibits, because `Void` erases the type of the object that\n-    /// will be used to produce formatted output. Since we do not know what\n-    /// oibits the real types have (and they can have any or none), we need to\n-    /// take the most conservative approach and forbid all oibits.\n-    ///\n-    /// It was added after #45197 showed that one could share a `!Sync`\n-    /// object across threads by passing it into `format_args!`.\n-    _oibit_remover: PhantomData<*mut dyn Fn()>,\n+extern \"C\" {\n+    type Opaque;\n }\n \n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n@@ -259,16 +251,23 @@ struct Void {\n #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n-    value: &'a Void,\n-    formatter: fn(&Void, &mut Formatter<'_>) -> Result,\n+    value: &'a Opaque,\n+    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n }\n \n-impl<'a> ArgumentV1<'a> {\n-    #[inline(never)]\n-    fn show_usize(x: &usize, f: &mut Formatter<'_>) -> Result {\n-        Display::fmt(x, f)\n-    }\n+// This gurantees a single stable value for the function pointer associated with\n+// indices/counts in the formatting infrastructure.\n+//\n+// Note that a function defined as such would not be correct as functions are\n+// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n+// address is not considered important to LLVM and as such the as_usize cast\n+// could have been miscompiled. In practice, we never call as_usize on non-usize\n+// containing data (as a matter of static generation of the formatting\n+// arguments), so this is merely an additional check.\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |_, _| loop {};\n \n+impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n@@ -278,11 +277,13 @@ impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n-        ArgumentV1::new(x, ArgumentV1::show_usize)\n+        ArgumentV1::new(x, USIZE_MARKER)\n     }\n \n     fn as_usize(&self) -> Option<usize> {\n-        if self.formatter as usize == ArgumentV1::show_usize as usize {\n+        if self.formatter as usize == USIZE_MARKER as usize {\n+            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n+            // the value is a usize, so this is safe\n             Some(unsafe { *(self.value as *const _ as *const usize) })\n         } else {\n             None\n@@ -1356,11 +1357,11 @@ impl<'a> Formatter<'a> {\n             let mut align = old_align;\n             if self.sign_aware_zero_pad() {\n                 // a sign always goes first\n-                let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n+                let sign = formatted.sign;\n                 self.buf.write_str(sign)?;\n \n                 // remove the sign from the formatted parts\n-                formatted.sign = b\"\";\n+                formatted.sign = \"\";\n                 width = width.saturating_sub(sign.len());\n                 align = rt::v1::Alignment::Right;\n                 self.fill = '0';\n@@ -1392,7 +1393,7 @@ impl<'a> Formatter<'a> {\n         }\n \n         if !formatted.sign.is_empty() {\n-            write_bytes(self.buf, formatted.sign)?;\n+            self.buf.write_str(formatted.sign)?;\n         }\n         for part in formatted.parts {\n             match *part {"}, {"sha": "5dfd3a8ecdbd695672699c9621995f40229fac16", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -369,11 +369,11 @@ macro_rules! impl_Exp {\n                 flt2dec::Part::Copy(exp_slice)\n             ];\n             let sign = if !is_nonnegative {\n-                &b\"-\"[..]\n+                \"-\"\n             } else if f.sign_plus() {\n-                &b\"+\"[..]\n+                \"+\"\n             } else {\n-                &b\"\"[..]\n+                \"\"\n             };\n             let formatted = flt2dec::Formatted{sign, parts};\n             f.pad_formatted_parts(&formatted)"}, {"sha": "f5cd26a1852d61efbb1bd9d0303218059091f0f5", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -237,7 +237,7 @@ impl<'a> Part<'a> {\n #[derive(Clone)]\n pub struct Formatted<'a> {\n     /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n-    pub sign: &'static [u8],\n+    pub sign: &'static str,\n     /// Formatted parts to be rendered after a sign and optional zero padding.\n     pub parts: &'a [Part<'a>],\n }\n@@ -259,7 +259,7 @@ impl<'a> Formatted<'a> {\n         if out.len() < self.sign.len() {\n             return None;\n         }\n-        out[..self.sign.len()].copy_from_slice(self.sign);\n+        out[..self.sign.len()].copy_from_slice(self.sign.as_bytes());\n \n         let mut written = self.sign.len();\n         for part in self.parts {\n@@ -402,38 +402,38 @@ pub enum Sign {\n }\n \n /// Returns the static byte string corresponding to the sign to be formatted.\n-/// It can be either `b\"\"`, `b\"+\"` or `b\"-\"`.\n-fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static [u8] {\n+/// It can be either `\"\"`, `\"+\"` or `\"-\"`.\n+fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static str {\n     match (*decoded, sign) {\n-        (FullDecoded::Nan, _) => b\"\",\n-        (FullDecoded::Zero, Sign::Minus) => b\"\",\n+        (FullDecoded::Nan, _) => \"\",\n+        (FullDecoded::Zero, Sign::Minus) => \"\",\n         (FullDecoded::Zero, Sign::MinusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"\"\n+                \"\"\n             }\n         }\n-        (FullDecoded::Zero, Sign::MinusPlus) => b\"+\",\n+        (FullDecoded::Zero, Sign::MinusPlus) => \"+\",\n         (FullDecoded::Zero, Sign::MinusPlusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"+\"\n+                \"+\"\n             }\n         }\n         (_, Sign::Minus) | (_, Sign::MinusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"\"\n+                \"\"\n             }\n         }\n         (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"+\"\n+                \"+\"\n             }\n         }\n     }\n@@ -462,7 +462,6 @@ pub fn to_shortest_str<'a, T, F>(\n     v: T,\n     sign: Sign,\n     frac_digits: usize,\n-    _upper: bool,\n     buf: &'a mut [u8],\n     parts: &'a mut [Part<'a>],\n ) -> Formatted<'a>\n@@ -679,7 +678,6 @@ pub fn to_exact_fixed_str<'a, T, F>(\n     v: T,\n     sign: Sign,\n     frac_digits: usize,\n-    _upper: bool,\n     buf: &'a mut [u8],\n     parts: &'a mut [Part<'a>],\n ) -> Formatted<'a>"}, {"sha": "e945d9c4a54ce26c09e3c88d3dab4ef5d7275139", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 224, "deletions": 236, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -500,102 +500,99 @@ where\n {\n     use core::num::flt2dec::Sign::*;\n \n-    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n     where\n         T: DecodableFloat,\n         F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n     {\n         to_string_with_parts(|buf, parts| {\n-            to_shortest_str(|d, b| f(d, b), v, sign, frac_digits, upper, buf, parts)\n+            to_shortest_str(|d, b| f(d, b), v, sign, frac_digits, buf, parts)\n         })\n     }\n \n     let f = &mut f_;\n \n-    assert_eq!(to_string(f, 0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, 0.0, Minus, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 8, true), \"0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 8, true), \"-0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 8, true), \"+0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8, true), \"-0.00000000\");\n-\n-    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0, false), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 0, true), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 0, false), \"+inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 0, true), \"+inf\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1, true), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64, true), \"NaN\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1, true), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64, true), \"-inf\");\n-\n-    assert_eq!(to_string(f, 3.14, Minus, 0, false), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 0, false), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 0, false), \"+3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0, false), \"+3.14\");\n-    assert_eq!(to_string(f, -3.14, Minus, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, 3.14, Minus, 1, true), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 2, true), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 3, true), \"+3.140\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4, true), \"+3.1400\");\n-    assert_eq!(to_string(f, -3.14, Minus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8, true), \"-3.14000000\");\n-\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 0, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 3, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n-\n-    assert_eq!(to_string(f, 1.9971e20, Minus, 0, false), \"199710000000000000000\");\n-    assert_eq!(to_string(f, 1.9971e20, Minus, 1, false), \"199710000000000000000.0\");\n-    assert_eq!(to_string(f, 1.9971e20, Minus, 8, false), \"199710000000000000000.00000000\");\n-\n-    assert_eq!(to_string(f, f32::MAX, Minus, 0, false), format!(\"34028235{:0>31}\", \"\"));\n-    assert_eq!(to_string(f, f32::MAX, Minus, 1, false), format!(\"34028235{:0>31}.0\", \"\"));\n-    assert_eq!(to_string(f, f32::MAX, Minus, 8, false), format!(\"34028235{:0>31}.00000000\", \"\"));\n+    assert_eq!(to_string(f, 0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, 0.0, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 1), \"+0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 8), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 8), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 8), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 0), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 0), \"+inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 0), \"+inf\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64), \"NaN\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64), \"-inf\");\n+\n+    assert_eq!(to_string(f, 3.14, Minus, 0), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 0), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 0), \"+3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0), \"+3.14\");\n+    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 0), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 0), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0), \"-3.14\");\n+    assert_eq!(to_string(f, 3.14, Minus, 1), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 2), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 3), \"+3.140\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 0), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 3), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13), \"0.0000000000750\");\n+\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 0), \"199710000000000000000\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 1), \"199710000000000000000.0\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 8), \"199710000000000000000.00000000\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0), format!(\"34028235{:0>31}\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1), format!(\"34028235{:0>31}.0\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 8), format!(\"34028235{:0>31}.00000000\", \"\"));\n \n     let minf32 = ldexp_f32(1.0, -149);\n-    assert_eq!(to_string(f, minf32, Minus, 0, false), format!(\"0.{:0>44}1\", \"\"));\n-    assert_eq!(to_string(f, minf32, Minus, 45, false), format!(\"0.{:0>44}1\", \"\"));\n-    assert_eq!(to_string(f, minf32, Minus, 46, false), format!(\"0.{:0>44}10\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 0), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 45), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 46), format!(\"0.{:0>44}10\", \"\"));\n \n-    assert_eq!(to_string(f, f64::MAX, Minus, 0, false), format!(\"17976931348623157{:0>292}\", \"\"));\n-    assert_eq!(to_string(f, f64::MAX, Minus, 1, false), format!(\"17976931348623157{:0>292}.0\", \"\"));\n-    assert_eq!(\n-        to_string(f, f64::MAX, Minus, 8, false),\n-        format!(\"17976931348623157{:0>292}.00000000\", \"\")\n-    );\n+    assert_eq!(to_string(f, f64::MAX, Minus, 0), format!(\"17976931348623157{:0>292}\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 1), format!(\"17976931348623157{:0>292}.0\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 8), format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n \n     let minf64 = ldexp_f64(1.0, -1074);\n-    assert_eq!(to_string(f, minf64, Minus, 0, false), format!(\"0.{:0>323}5\", \"\"));\n-    assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n-    assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 0), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 324), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 325), format!(\"0.{:0>323}50\", \"\"));\n \n     if cfg!(miri) {\n         // Miri is too slow\n         return;\n     }\n \n     // very large output\n-    assert_eq!(to_string(f, 1.1, Minus, 80000, false), format!(\"1.1{:0>79999}\", \"\"));\n+    assert_eq!(to_string(f, 1.1, Minus, 80000), format!(\"1.1{:0>79999}\", \"\"));\n }\n \n pub fn to_shortest_exp_str_test<F>(mut f_: F)\n@@ -996,207 +993,198 @@ where\n {\n     use core::num::flt2dec::Sign::*;\n \n-    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n     where\n         T: DecodableFloat,\n         F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n     {\n         to_string_with_parts(|buf, parts| {\n-            to_exact_fixed_str(|d, b, l| f(d, b, l), v, sign, frac_digits, upper, buf, parts)\n+            to_exact_fixed_str(|d, b, l| f(d, b, l), v, sign, frac_digits, buf, parts)\n         })\n     }\n \n     let f = &mut f_;\n \n-    assert_eq!(to_string(f, 0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, 0.0, Minus, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 8, true), \"0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 8, true), \"-0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 8, true), \"+0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8, true), \"-0.00000000\");\n-\n-    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0, false), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 1, true), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 8, false), \"+inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 64, true), \"+inf\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1, true), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64, true), \"NaN\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1, true), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64, true), \"-inf\");\n-\n-    assert_eq!(to_string(f, 3.14, Minus, 0, false), \"3\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 0, false), \"3\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 0, false), \"+3\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0, false), \"+3\");\n-    assert_eq!(to_string(f, -3.14, Minus, 0, false), \"-3\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 0, false), \"-3\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 0, false), \"-3\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3\");\n-    assert_eq!(to_string(f, 3.14, Minus, 1, true), \"3.1\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 2, true), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 3, true), \"+3.140\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4, true), \"+3.1400\");\n-    assert_eq!(to_string(f, -3.14, Minus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8, true), \"-3.14000000\");\n-\n-    assert_eq!(to_string(f, 0.195, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.195, MinusRaw, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.195, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.195, Minus, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.195, MinusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.195, MinusPlus, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, 0.195, Minus, 1, true), \"0.2\");\n-    assert_eq!(to_string(f, 0.195, MinusRaw, 2, true), \"0.20\");\n-    assert_eq!(to_string(f, 0.195, MinusPlus, 3, true), \"+0.195\");\n-    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 4, true), \"+0.1950\");\n-    assert_eq!(to_string(f, -0.195, Minus, 5, true), \"-0.19500\");\n-    assert_eq!(to_string(f, -0.195, MinusRaw, 6, true), \"-0.195000\");\n-    assert_eq!(to_string(f, -0.195, MinusPlus, 7, true), \"-0.1950000\");\n-    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 8, true), \"-0.19500000\");\n-\n-    assert_eq!(to_string(f, 999.5, Minus, 0, false), \"1000\");\n-    assert_eq!(to_string(f, 999.5, Minus, 1, false), \"999.5\");\n-    assert_eq!(to_string(f, 999.5, Minus, 2, false), \"999.50\");\n-    assert_eq!(to_string(f, 999.5, Minus, 3, false), \"999.500\");\n-    assert_eq!(to_string(f, 999.5, Minus, 30, false), \"999.500000000000000000000000000000\");\n-\n-    assert_eq!(to_string(f, 0.5, Minus, 0, false), \"1\");\n-    assert_eq!(to_string(f, 0.5, Minus, 1, false), \"0.5\");\n-    assert_eq!(to_string(f, 0.5, Minus, 2, false), \"0.50\");\n-    assert_eq!(to_string(f, 0.5, Minus, 3, false), \"0.500\");\n-\n-    assert_eq!(to_string(f, 0.95, Minus, 0, false), \"1\");\n-    assert_eq!(to_string(f, 0.95, Minus, 1, false), \"0.9\"); // because it really is less than 0.95\n-    assert_eq!(to_string(f, 0.95, Minus, 2, false), \"0.95\");\n-    assert_eq!(to_string(f, 0.95, Minus, 3, false), \"0.950\");\n-    assert_eq!(to_string(f, 0.95, Minus, 10, false), \"0.9500000000\");\n-    assert_eq!(to_string(f, 0.95, Minus, 30, false), \"0.949999999999999955591079014994\");\n-\n-    assert_eq!(to_string(f, 0.095, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.095, Minus, 1, false), \"0.1\");\n-    assert_eq!(to_string(f, 0.095, Minus, 2, false), \"0.10\");\n-    assert_eq!(to_string(f, 0.095, Minus, 3, false), \"0.095\");\n-    assert_eq!(to_string(f, 0.095, Minus, 4, false), \"0.0950\");\n-    assert_eq!(to_string(f, 0.095, Minus, 10, false), \"0.0950000000\");\n-    assert_eq!(to_string(f, 0.095, Minus, 30, false), \"0.095000000000000001110223024625\");\n-\n-    assert_eq!(to_string(f, 0.0095, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 1, false), \"0.0\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 2, false), \"0.01\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 3, false), \"0.009\"); // really is less than 0.0095\n-    assert_eq!(to_string(f, 0.0095, Minus, 4, false), \"0.0095\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 5, false), \"0.00950\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 10, false), \"0.0095000000\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 30, false), \"0.009499999999999999764077607267\");\n-\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 3, false), \"0.000\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 10, false), \"0.0000000001\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 11, false), \"0.00000000007\"); // ditto\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 20, false), \"0.00000000007500000000\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 30, false), \"0.000000000074999999999999999501\");\n-\n-    assert_eq!(to_string(f, 1.0e25, Minus, 0, false), \"10000000000000000905969664\");\n-    assert_eq!(to_string(f, 1.0e25, Minus, 1, false), \"10000000000000000905969664.0\");\n-    assert_eq!(to_string(f, 1.0e25, Minus, 3, false), \"10000000000000000905969664.000\");\n-\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 3, false), \"0.000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 6, false), \"0.000001\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 9, false), \"0.000001000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 12, false), \"0.000001000000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 22, false), \"0.0000010000000000000000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 23, false), \"0.00000099999999999999995\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 24, false), \"0.000000999999999999999955\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 25, false), \"0.0000009999999999999999547\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 35, false), \"0.00000099999999999999995474811182589\");\n+    assert_eq!(to_string(f, 0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, 0.0, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 1), \"+0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 8), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 8), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 8), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 1), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 8), \"+inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 64), \"+inf\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64), \"NaN\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64), \"-inf\");\n+\n+    assert_eq!(to_string(f, 3.14, Minus, 0), \"3\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 0), \"3\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 0), \"+3\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0), \"+3\");\n+    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 0), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 0), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0), \"-3\");\n+    assert_eq!(to_string(f, 3.14, Minus, 1), \"3.1\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 2), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 3), \"+3.140\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f, 0.195, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.195, MinusRaw, 0), \"0\");\n+    assert_eq!(to_string(f, 0.195, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.195, Minus, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, 0.195, Minus, 1), \"0.2\");\n+    assert_eq!(to_string(f, 0.195, MinusRaw, 2), \"0.20\");\n+    assert_eq!(to_string(f, 0.195, MinusPlus, 3), \"+0.195\");\n+    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 4), \"+0.1950\");\n+    assert_eq!(to_string(f, -0.195, Minus, 5), \"-0.19500\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw, 6), \"-0.195000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus, 7), \"-0.1950000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 8), \"-0.19500000\");\n+\n+    assert_eq!(to_string(f, 999.5, Minus, 0), \"1000\");\n+    assert_eq!(to_string(f, 999.5, Minus, 1), \"999.5\");\n+    assert_eq!(to_string(f, 999.5, Minus, 2), \"999.50\");\n+    assert_eq!(to_string(f, 999.5, Minus, 3), \"999.500\");\n+    assert_eq!(to_string(f, 999.5, Minus, 30), \"999.500000000000000000000000000000\");\n+\n+    assert_eq!(to_string(f, 0.5, Minus, 0), \"1\");\n+    assert_eq!(to_string(f, 0.5, Minus, 1), \"0.5\");\n+    assert_eq!(to_string(f, 0.5, Minus, 2), \"0.50\");\n+    assert_eq!(to_string(f, 0.5, Minus, 3), \"0.500\");\n+\n+    assert_eq!(to_string(f, 0.95, Minus, 0), \"1\");\n+    assert_eq!(to_string(f, 0.95, Minus, 1), \"0.9\"); // because it really is less than 0.95\n+    assert_eq!(to_string(f, 0.95, Minus, 2), \"0.95\");\n+    assert_eq!(to_string(f, 0.95, Minus, 3), \"0.950\");\n+    assert_eq!(to_string(f, 0.95, Minus, 10), \"0.9500000000\");\n+    assert_eq!(to_string(f, 0.95, Minus, 30), \"0.949999999999999955591079014994\");\n+\n+    assert_eq!(to_string(f, 0.095, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.095, Minus, 1), \"0.1\");\n+    assert_eq!(to_string(f, 0.095, Minus, 2), \"0.10\");\n+    assert_eq!(to_string(f, 0.095, Minus, 3), \"0.095\");\n+    assert_eq!(to_string(f, 0.095, Minus, 4), \"0.0950\");\n+    assert_eq!(to_string(f, 0.095, Minus, 10), \"0.0950000000\");\n+    assert_eq!(to_string(f, 0.095, Minus, 30), \"0.095000000000000001110223024625\");\n+\n+    assert_eq!(to_string(f, 0.0095, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 2), \"0.01\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 3), \"0.009\"); // really is less than 0.0095\n+    assert_eq!(to_string(f, 0.0095, Minus, 4), \"0.0095\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 5), \"0.00950\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 10), \"0.0095000000\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 30), \"0.009499999999999999764077607267\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 3), \"0.000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 10), \"0.0000000001\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 11), \"0.00000000007\"); // ditto\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13), \"0.0000000000750\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 20), \"0.00000000007500000000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 30), \"0.000000000074999999999999999501\");\n+\n+    assert_eq!(to_string(f, 1.0e25, Minus, 0), \"10000000000000000905969664\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 1), \"10000000000000000905969664.0\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 3), \"10000000000000000905969664.000\");\n+\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 3), \"0.000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 6), \"0.000001\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 9), \"0.000001000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 12), \"0.000001000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 22), \"0.0000010000000000000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 23), \"0.00000099999999999999995\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 24), \"0.000000999999999999999955\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 25), \"0.0000009999999999999999547\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 35), \"0.00000099999999999999995474811182589\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 45), \"0.000000999999999999999954748111825886258685614\");\n     assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 45, false),\n-        \"0.000000999999999999999954748111825886258685614\"\n-    );\n-    assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 55, false),\n+        to_string(f, 1.0e-6, Minus, 55),\n         \"0.0000009999999999999999547481118258862586856139387236908\"\n     );\n     assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 65, false),\n+        to_string(f, 1.0e-6, Minus, 65),\n         \"0.00000099999999999999995474811182588625868561393872369080781936646\"\n     );\n     assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 75, false),\n+        to_string(f, 1.0e-6, Minus, 75),\n         \"0.000000999999999999999954748111825886258685613938723690807819366455078125000\"\n     );\n \n-    assert_eq!(to_string(f, f32::MAX, Minus, 0, false), \"340282346638528859811704183484516925440\");\n-    assert_eq!(\n-        to_string(f, f32::MAX, Minus, 1, false),\n-        \"340282346638528859811704183484516925440.0\"\n-    );\n-    assert_eq!(\n-        to_string(f, f32::MAX, Minus, 2, false),\n-        \"340282346638528859811704183484516925440.00\"\n-    );\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0), \"340282346638528859811704183484516925440\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1), \"340282346638528859811704183484516925440.0\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 2), \"340282346638528859811704183484516925440.00\");\n \n     if cfg!(miri) {\n         // Miri is too slow\n         return;\n     }\n \n     let minf32 = ldexp_f32(1.0, -149);\n-    assert_eq!(to_string(f, minf32, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, minf32, Minus, 1, false), \"0.0\");\n-    assert_eq!(to_string(f, minf32, Minus, 2, false), \"0.00\");\n-    assert_eq!(to_string(f, minf32, Minus, 4, false), \"0.0000\");\n-    assert_eq!(to_string(f, minf32, Minus, 8, false), \"0.00000000\");\n-    assert_eq!(to_string(f, minf32, Minus, 16, false), \"0.0000000000000000\");\n-    assert_eq!(to_string(f, minf32, Minus, 32, false), \"0.00000000000000000000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, minf32, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, minf32, Minus, 2), \"0.00\");\n+    assert_eq!(to_string(f, minf32, Minus, 4), \"0.0000\");\n+    assert_eq!(to_string(f, minf32, Minus, 8), \"0.00000000\");\n+    assert_eq!(to_string(f, minf32, Minus, 16), \"0.0000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus, 32), \"0.00000000000000000000000000000000\");\n     assert_eq!(\n-        to_string(f, minf32, Minus, 64, false),\n+        to_string(f, minf32, Minus, 64),\n         \"0.0000000000000000000000000000000000000000000014012984643248170709\"\n     );\n     assert_eq!(\n-        to_string(f, minf32, Minus, 128, false),\n+        to_string(f, minf32, Minus, 128),\n         \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n                   2372958328991613128026194187651577175706828388979108268586060149\"\n     );\n     assert_eq!(\n-        to_string(f, minf32, Minus, 256, false),\n+        to_string(f, minf32, Minus, 256),\n         \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n                   2372958328991613128026194187651577175706828388979108268586060148\\\n                   6638188362121582031250000000000000000000000000000000000000000000\\\n                   0000000000000000000000000000000000000000000000000000000000000000\"\n     );\n \n     assert_eq!(\n-        to_string(f, f64::MAX, Minus, 0, false),\n+        to_string(f, f64::MAX, Minus, 0),\n         \"1797693134862315708145274237317043567980705675258449965989174768\\\n                 0315726078002853876058955863276687817154045895351438246423432132\\\n                 6889464182768467546703537516986049910576551282076245490090389328\\\n                 9440758685084551339423045832369032229481658085593321233482747978\\\n                 26204144723168738177180919299881250404026184124858368\"\n     );\n     assert_eq!(\n-        to_string(f, f64::MAX, Minus, 10, false),\n+        to_string(f, f64::MAX, Minus, 10),\n         \"1797693134862315708145274237317043567980705675258449965989174768\\\n                 0315726078002853876058955863276687817154045895351438246423432132\\\n                 6889464182768467546703537516986049910576551282076245490090389328\\\n@@ -1205,16 +1193,16 @@ where\n     );\n \n     let minf64 = ldexp_f64(1.0, -1074);\n-    assert_eq!(to_string(f, minf64, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, minf64, Minus, 1, false), \"0.0\");\n-    assert_eq!(to_string(f, minf64, Minus, 10, false), \"0.0000000000\");\n+    assert_eq!(to_string(f, minf64, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, minf64, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, minf64, Minus, 10), \"0.0000000000\");\n     assert_eq!(\n-        to_string(f, minf64, Minus, 100, false),\n+        to_string(f, minf64, Minus, 100),\n         \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n                   000000000000000000000000000000000000\"\n     );\n     assert_eq!(\n-        to_string(f, minf64, Minus, 1000, false),\n+        to_string(f, minf64, Minus, 1000),\n         \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n                   0000000000000000000000000000000000000000000000000000000000000000\\\n                   0000000000000000000000000000000000000000000000000000000000000000\\\n@@ -1234,15 +1222,15 @@ where\n     );\n \n     // very large output\n-    assert_eq!(to_string(f, 0.0, Minus, 80000, false), format!(\"0.{:0>80000}\", \"\"));\n-    assert_eq!(to_string(f, 1.0e1, Minus, 80000, false), format!(\"10.{:0>80000}\", \"\"));\n-    assert_eq!(to_string(f, 1.0e0, Minus, 80000, false), format!(\"1.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 0.0, Minus, 80000), format!(\"0.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e1, Minus, 80000), format!(\"10.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e0, Minus, 80000), format!(\"1.{:0>80000}\", \"\"));\n     assert_eq!(\n-        to_string(f, 1.0e-1, Minus, 80000, false),\n+        to_string(f, 1.0e-1, Minus, 80000),\n         format!(\"0.1000000000000000055511151231257827021181583404541015625{:0>79945}\", \"\")\n     );\n     assert_eq!(\n-        to_string(f, 1.0e-20, Minus, 80000, false),\n+        to_string(f, 1.0e-20, Minus, 80000),\n         format!(\n             \"0.0000000000000000000099999999999999994515327145420957165172950370\\\n                           2787392447107715776066783064379706047475337982177734375{:0>79881}\","}, {"sha": "3dacd2cbe95c8ef13d1d6296c1958d7fb39f8d64", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -408,20 +408,12 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             {\n                 last_source_file\n             } else {\n-                let mut a = 0;\n-                let mut b = imported_source_files.len();\n-\n-                while b - a > 1 {\n-                    let m = (a + b) / 2;\n-                    if imported_source_files[m].original_start_pos > lo {\n-                        b = m;\n-                    } else {\n-                        a = m;\n-                    }\n-                }\n+                let index = imported_source_files\n+                    .binary_search_by_key(&lo, |source_file| source_file.original_start_pos)\n+                    .unwrap_or_else(|index| index - 1);\n \n-                self.last_source_file_index = a;\n-                &imported_source_files[a]\n+                self.last_source_file_index = index;\n+                &imported_source_files[index]\n             }\n         };\n "}, {"sha": "d2a6f0b7fcf0cc7d22b54eb9bff64f9f827c9ac5", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 87, "deletions": 94, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -35,61 +35,32 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n \n-        if self.eat_keyword(kw::Let) {\n-            return self.parse_local_mk(lo, attrs.into()).map(Some);\n-        }\n-        if self.is_kw_followed_by_ident(kw::Mut) {\n-            return self.recover_stmt_local(lo, attrs.into(), \"missing keyword\", \"let mut\");\n-        }\n-        if self.is_kw_followed_by_ident(kw::Auto) {\n+        let stmt = if self.eat_keyword(kw::Let) {\n+            self.parse_local_mk(lo, attrs.into())?\n+        } else if self.is_kw_followed_by_ident(kw::Mut) {\n+            self.recover_stmt_local(lo, attrs.into(), \"missing keyword\", \"let mut\")?\n+        } else if self.is_kw_followed_by_ident(kw::Auto) {\n             self.bump(); // `auto`\n             let msg = \"write `let` instead of `auto` to introduce a new variable\";\n-            return self.recover_stmt_local(lo, attrs.into(), msg, \"let\");\n-        }\n-        if self.is_kw_followed_by_ident(sym::var) {\n+            self.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n+        } else if self.is_kw_followed_by_ident(sym::var) {\n             self.bump(); // `var`\n             let msg = \"write `let` instead of `var` to introduce a new variable\";\n-            return self.recover_stmt_local(lo, attrs.into(), msg, \"let\");\n-        }\n-\n-        // Starts like a simple path, being careful to avoid contextual keywords,\n-        // e.g., `union`, items with `crate` visibility, or `auto trait` items.\n-        // We aim to parse an arbitrary path `a::b` but not something that starts like a path\n-        // (1 token), but it fact not a path. Also, we avoid stealing syntax from `parse_item_`.\n-        if self.token.is_path_start() && !self.token.is_qpath_start() && !self.is_path_start_item()\n+            self.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n+        } else if self.token.is_path_start()\n+            && !self.token.is_qpath_start()\n+            && !self.is_path_start_item()\n         {\n-            let path = self.parse_path(PathStyle::Expr)?;\n-\n-            if self.eat(&token::Not) {\n-                return self.parse_stmt_mac(lo, attrs.into(), path);\n-            }\n-\n-            let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-                self.parse_struct_expr(lo, path, AttrVec::new())?\n-            } else {\n-                let hi = self.prev_span;\n-                self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n-            };\n-\n-            let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n-                this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n-            })?;\n-            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr))));\n-        }\n-\n-        // FIXME: Bad copy of attrs\n-        let old_directory_ownership =\n-            mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-        let item = self.parse_item_common(attrs.clone(), false, true, |_| true)?;\n-        self.directory.ownership = old_directory_ownership;\n-\n-        if let Some(item) = item {\n-            return Ok(Some(self.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))));\n-        }\n-\n-        // Do not attempt to parse an expression if we're done here.\n-        if self.token == token::Semi {\n+            // We have avoided contextual keywords like `union`, items with `crate` visibility,\n+            // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n+            // that starts like a path (1 token), but it fact not a path.\n+            // Also, we avoid stealing syntax from `parse_item_`.\n+            self.parse_stmt_path_start(lo, attrs)?\n+        } else if let Some(item) = self.parse_stmt_item(attrs.clone())? {\n+            // FIXME: Bad copy of attrs\n+            self.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))\n+        } else if self.token == token::Semi {\n+            // Do not attempt to parse an expression if we're done here.\n             self.error_outer_attrs(&attrs);\n             self.bump();\n             let mut last_semi = lo;\n@@ -104,27 +75,49 @@ impl<'a> Parser<'a> {\n                 ExprKind::Tup(Vec::new()),\n                 AttrVec::new(),\n             ));\n-            return Ok(Some(self.mk_stmt(lo.to(last_semi), kind)));\n-        }\n-\n-        if self.token == token::CloseDelim(token::Brace) {\n+            self.mk_stmt(lo.to(last_semi), kind)\n+        } else if self.token != token::CloseDelim(token::Brace) {\n+            // Remainder are line-expr stmts.\n+            let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+            self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n+        } else {\n             self.error_outer_attrs(&attrs);\n             return Ok(None);\n+        };\n+        Ok(Some(stmt))\n+    }\n+\n+    fn parse_stmt_item(&mut self, attrs: Vec<Attribute>) -> PResult<'a, Option<ast::Item>> {\n+        let old = mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+        let item = self.parse_item_common(attrs.clone(), false, true, |_| true)?;\n+        self.directory.ownership = old;\n+        Ok(item)\n+    }\n+\n+    fn parse_stmt_path_start(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, Stmt> {\n+        let path = self.parse_path(PathStyle::Expr)?;\n+\n+        if self.eat(&token::Not) {\n+            return self.parse_stmt_mac(lo, attrs.into(), path);\n         }\n \n-        // Remainder are line-expr stmts.\n-        let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs.into()))?;\n-        Ok(Some(self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))))\n+        let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+            self.parse_struct_expr(lo, path, AttrVec::new())?\n+        } else {\n+            let hi = self.prev_span;\n+            self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n+        };\n+\n+        let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n+            let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+            this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+        })?;\n+        Ok(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr)))\n     }\n \n     /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`.\n     /// At this point, the `!` token after the path has already been eaten.\n-    fn parse_stmt_mac(\n-        &mut self,\n-        lo: Span,\n-        attrs: AttrVec,\n-        path: ast::Path,\n-    ) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_mac(&mut self, lo: Span, attrs: AttrVec, path: ast::Path) -> PResult<'a, Stmt> {\n         let args = self.parse_mac_args()?;\n         let delim = args.delim();\n         let hi = self.prev_span;\n@@ -145,7 +138,7 @@ impl<'a> Parser<'a> {\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n             StmtKind::Expr(e)\n         };\n-        Ok(Some(self.mk_stmt(lo.to(hi), kind)))\n+        Ok(self.mk_stmt(lo.to(hi), kind))\n     }\n \n     /// Error on outer attributes in this context.\n@@ -167,12 +160,12 @@ impl<'a> Parser<'a> {\n         attrs: AttrVec,\n         msg: &str,\n         sugg: &str,\n-    ) -> PResult<'a, Option<Stmt>> {\n+    ) -> PResult<'a, Stmt> {\n         let stmt = self.parse_local_mk(lo, attrs)?;\n         self.struct_span_err(lo, \"invalid variable declaration\")\n             .span_suggestion(lo, msg, sugg.to_string(), Applicability::MachineApplicable)\n             .emit();\n-        Ok(Some(stmt))\n+        Ok(stmt)\n     }\n \n     fn parse_local_mk(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, Stmt> {\n@@ -372,36 +365,36 @@ impl<'a> Parser<'a> {\n \n         let mut eat_semi = true;\n         match stmt.kind {\n-            StmtKind::Expr(ref expr) if self.token != token::Eof => {\n-                // expression without semicolon\n-                if classify::expr_requires_semi_to_be_stmt(expr) {\n-                    // Just check for errors and recover; do not eat semicolon yet.\n-                    if let Err(mut e) =\n-                        self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n-                    {\n-                        if let TokenKind::DocComment(..) = self.token.kind {\n-                            if let Ok(snippet) = self.span_to_snippet(self.token.span) {\n-                                let sp = self.token.span;\n-                                let marker = &snippet[..3];\n-                                let (comment_marker, doc_comment_marker) = marker.split_at(2);\n-\n-                                e.span_suggestion(\n-                                    sp.with_hi(sp.lo() + BytePos(marker.len() as u32)),\n-                                    &format!(\n-                                        \"add a space before `{}` to use a regular comment\",\n-                                        doc_comment_marker,\n-                                    ),\n-                                    format!(\"{} {}\", comment_marker, doc_comment_marker),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n+            // Expression without semicolon.\n+            StmtKind::Expr(ref expr)\n+                if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) =>\n+            {\n+                // Just check for errors and recover; do not eat semicolon yet.\n+                if let Err(mut e) =\n+                    self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                {\n+                    if let TokenKind::DocComment(..) = self.token.kind {\n+                        if let Ok(snippet) = self.span_to_snippet(self.token.span) {\n+                            let sp = self.token.span;\n+                            let marker = &snippet[..3];\n+                            let (comment_marker, doc_comment_marker) = marker.split_at(2);\n+\n+                            e.span_suggestion(\n+                                sp.with_hi(sp.lo() + BytePos(marker.len() as u32)),\n+                                &format!(\n+                                    \"add a space before `{}` to use a regular comment\",\n+                                    doc_comment_marker,\n+                                ),\n+                                format!(\"{} {}\", comment_marker, doc_comment_marker),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n-                        e.emit();\n-                        self.recover_stmt();\n-                        // Don't complain about type errors in body tail after parse error (#57383).\n-                        let sp = expr.span.to(self.prev_span);\n-                        stmt.kind = StmtKind::Expr(self.mk_expr_err(sp));\n                     }\n+                    e.emit();\n+                    self.recover_stmt();\n+                    // Don't complain about type errors in body tail after parse error (#57383).\n+                    let sp = expr.span.to(self.prev_span);\n+                    stmt.kind = StmtKind::Expr(self.mk_expr_err(sp));\n                 }\n             }\n             StmtKind::Local(..) => {"}, {"sha": "c8439764effc331dfbd3d2a2a076da8fccdda4fb", "filename": "src/test/ui/fmt/send-sync.stderr", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/abc3073c92df034636a823c5382ece2186d22b9e/src%2Ftest%2Fui%2Ffmt%2Fsend-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abc3073c92df034636a823c5382ece2186d22b9e/src%2Ftest%2Fui%2Ffmt%2Fsend-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fsend-sync.stderr?ref=abc3073c92df034636a823c5382ece2186d22b9e", "patch": "@@ -1,34 +1,30 @@\n-error[E0277]: `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+error[E0277]: `core::fmt::Opaque` cannot be shared between threads safely\n   --> $DIR/send-sync.rs:8:5\n    |\n LL | fn send<T: Send>(_: T) {}\n    |    ----    ---- required by this bound in `send`\n ...\n LL |     send(format_args!(\"{:?}\", c));\n-   |     ^^^^ `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+   |     ^^^^ `core::fmt::Opaque` cannot be shared between threads safely\n    |\n-   = help: within `[std::fmt::ArgumentV1<'_>]`, the trait `std::marker::Sync` is not implemented for `*mut (dyn std::ops::Fn() + 'static)`\n-   = note: required because it appears within the type `std::marker::PhantomData<*mut (dyn std::ops::Fn() + 'static)>`\n-   = note: required because it appears within the type `core::fmt::Void`\n-   = note: required because it appears within the type `&core::fmt::Void`\n+   = help: within `[std::fmt::ArgumentV1<'_>]`, the trait `std::marker::Sync` is not implemented for `core::fmt::Opaque`\n+   = note: required because it appears within the type `&core::fmt::Opaque`\n    = note: required because it appears within the type `std::fmt::ArgumentV1<'_>`\n    = note: required because it appears within the type `[std::fmt::ArgumentV1<'_>]`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&[std::fmt::ArgumentV1<'_>]`\n    = note: required because it appears within the type `std::fmt::Arguments<'_>`\n \n-error[E0277]: `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+error[E0277]: `core::fmt::Opaque` cannot be shared between threads safely\n   --> $DIR/send-sync.rs:9:5\n    |\n LL | fn sync<T: Sync>(_: T) {}\n    |    ----    ---- required by this bound in `sync`\n ...\n LL |     sync(format_args!(\"{:?}\", c));\n-   |     ^^^^ `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+   |     ^^^^ `core::fmt::Opaque` cannot be shared between threads safely\n    |\n-   = help: within `std::fmt::Arguments<'_>`, the trait `std::marker::Sync` is not implemented for `*mut (dyn std::ops::Fn() + 'static)`\n-   = note: required because it appears within the type `std::marker::PhantomData<*mut (dyn std::ops::Fn() + 'static)>`\n-   = note: required because it appears within the type `core::fmt::Void`\n-   = note: required because it appears within the type `&core::fmt::Void`\n+   = help: within `std::fmt::Arguments<'_>`, the trait `std::marker::Sync` is not implemented for `core::fmt::Opaque`\n+   = note: required because it appears within the type `&core::fmt::Opaque`\n    = note: required because it appears within the type `std::fmt::ArgumentV1<'_>`\n    = note: required because it appears within the type `[std::fmt::ArgumentV1<'_>]`\n    = note: required because it appears within the type `&[std::fmt::ArgumentV1<'_>]`"}]}