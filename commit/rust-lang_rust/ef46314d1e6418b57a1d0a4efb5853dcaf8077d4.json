{"sha": "ef46314d1e6418b57a1d0a4efb5853dcaf8077d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNDYzMTRkMWU2NDE4YjU3YTFkMGE0ZWZiNTg1M2RjYWY4MDc3ZDQ=", "commit": {"author": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-07-25T03:21:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-03T18:28:18Z"}, "message": "std: integrating erickt's url encoding/decoding from github.com/erickt/rust-uri into std::net::url", "tree": {"sha": "cd01451b06310ead70ed2d92f98decab152930df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd01451b06310ead70ed2d92f98decab152930df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef46314d1e6418b57a1d0a4efb5853dcaf8077d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef46314d1e6418b57a1d0a4efb5853dcaf8077d4", "html_url": "https://github.com/rust-lang/rust/commit/ef46314d1e6418b57a1d0a4efb5853dcaf8077d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef46314d1e6418b57a1d0a4efb5853dcaf8077d4/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfe1f6260e7e076114b95b42053cf6dc4cbaca68", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe1f6260e7e076114b95b42053cf6dc4cbaca68", "html_url": "https://github.com/rust-lang/rust/commit/dfe1f6260e7e076114b95b42053cf6dc4cbaca68"}], "stats": {"total": 389, "additions": 385, "deletions": 4}, "files": [{"sha": "c54d624cfe6e0b90e7a6199f7dc4027aad248013", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 385, "deletions": 4, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/ef46314d1e6418b57a1d0a4efb5853dcaf8077d4/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef46314d1e6418b57a1d0a4efb5853dcaf8077d4/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=ef46314d1e6418b57a1d0a4efb5853dcaf8077d4", "patch": "@@ -1,6 +1,17 @@\n //! Types/fns concerning URLs (see RFC 3986)\n \n-export url, userinfo, query, from_str, to_str, get_scheme;\n+import map;\n+import map::{hashmap, str_hash};\n+import io::{reader, reader_util};\n+import dvec::{dvec, extensions};\n+\n+export url, userinfo, query;\n+export from_str, to_str;\n+export get_scheme;\n+\n+export encode, decode;\n+export encode_component, decode_component;\n+export encode_form_urlencoded, decode_form_urlencoded;\n \n type url = {\n     scheme: ~str,\n@@ -28,6 +39,223 @@ fn userinfo(-user: ~str, -pass: option<~str>) -> userinfo {\n     {user: user, pass: pass}\n }\n \n+fn encode_inner(s: ~str, full_url: bool) -> ~str {\n+    do io::with_str_reader(s) |rdr| {\n+        let mut out = ~\"\";\n+\n+        while !rdr.eof() {\n+            let ch = rdr.read_byte() as char;\n+            alt ch {\n+              // unreserved:\n+              'A' to 'Z' |\n+              'a' to 'z' |\n+              '0' to '9' |\n+              '-' | '.' | '_' | '~' {\n+                str::push_char(out, ch);\n+              }\n+              _ {\n+                if full_url {\n+                    alt ch {\n+                      // gen-delims:\n+                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                      // sub-delims:\n+                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                      '+' | ',' | ';' | '=' {\n+                        str::push_char(out, ch);\n+                      }\n+\n+                      _ { out += #fmt(\"%%%X\", ch as uint); }\n+                    }\n+                } else {\n+                    out += #fmt(\"%%%X\", ch as uint);\n+                }\n+              }\n+            }\n+        }\n+\n+        out\n+    }\n+}\n+\n+/** Encodes a URI by replacing reserved characters with percent encoded character\n+ * sequences.\n+ *\n+ * This function is compliant with RFC 3986.\n+ */\n+fn encode(s: ~str) -> ~str {\n+    encode_inner(s, true)\n+}\n+\n+/** Encodes a URI component by replacing reserved characters with percent encoded\n+ * character sequences.\n+ *\n+ * This function is compliant with RFC 3986.\n+ */\n+fn encode_component(s: ~str) -> ~str {\n+    encode_inner(s, false)\n+}\n+\n+fn decode_inner(s: ~str, full_url: bool) -> ~str {\n+    do io::with_str_reader(s) |rdr| {\n+        let mut out = ~\"\";\n+\n+        while !rdr.eof() {\n+            alt rdr.read_char() {\n+              '%' {\n+                let bytes = rdr.read_bytes(2u);\n+                let ch = uint::parse_buf(bytes, 16u).get() as char;\n+\n+                if full_url {\n+                    // Only decode some characters:\n+                    alt ch {\n+                      // gen-delims:\n+                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                      // sub-delims:\n+                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                      '+' | ',' | ';' | '=' {\n+                        str::push_char(out, '%');\n+                        str::push_char(out, bytes[0u] as char);\n+                        str::push_char(out, bytes[1u] as char);\n+                      }\n+\n+                      ch { str::push_char(out, ch); }\n+                    }\n+                } else {\n+                      str::push_char(out, ch);\n+                }\n+              }\n+              ch { str::push_char(out, ch); }\n+            }\n+        }\n+\n+        out\n+    }\n+}\n+\n+/** Decode a string encoded with percent encoding.\n+ * \n+ * This will only decode escape sequences generated by encode_uri.\n+ */\n+fn decode(s: ~str) -> ~str {\n+    decode_inner(s, true)\n+}\n+\n+/** Decode a string encoded with percent encoding.\n+ */\n+fn decode_component(s: ~str) -> ~str {\n+    decode_inner(s, false)\n+}\n+\n+fn encode_plus(s: ~str) -> ~str {\n+    do io::with_str_reader(s) |rdr| {\n+        let mut out = ~\"\";\n+\n+        while !rdr.eof() {\n+            let ch = rdr.read_byte() as char;\n+            alt ch {\n+              'A' to 'Z' | 'a' to 'z' | '0' to '9' | '_' | '.' | '-' {\n+                str::push_char(out, ch);\n+              }\n+              ' ' { str::push_char(out, '+'); }\n+              _ { out += #fmt(\"%%%X\", ch as uint); }\n+            }\n+        }\n+\n+        out\n+    }\n+}\n+\n+/** Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n+ */\n+fn encode_form_urlencoded(m: hashmap<~str, @dvec<@~str>>) -> ~str {\n+    let mut out = ~\"\";\n+    let mut first = true;\n+\n+    for m.each |key, values| {\n+        let key = encode_plus(key);\n+\n+        for (*values).each |value| {\n+            if first {\n+                first = false;\n+            } else {\n+                str::push_char(out, '&');\n+                first = false;\n+            }\n+\n+            out += #fmt(\"%s=%s\", key, encode_plus(*value)); \n+        }\n+    }\n+\n+    out\n+}\n+\n+/** Decode a string encoded with the 'application/x-www-form-urlencoded' media\n+ * type into a hashmap.\n+ */\n+fn decode_form_urlencoded(s: ~[u8]) -> hashmap<~str, @dvec<@~str>> {\n+    do io::with_bytes_reader(s) |rdr| {\n+        let m = str_hash();\n+        let mut key = ~\"\";\n+        let mut value = ~\"\";\n+        let mut parsing_key = true;\n+\n+        while !rdr.eof() {\n+            alt rdr.read_char() {\n+              '&' | ';' {\n+                if key != ~\"\" && value != ~\"\" {\n+                    let values = alt m.find(key) {\n+                      some(values) { values }\n+                      none {\n+                        let values = @dvec();\n+                        m.insert(key, values);\n+                        values\n+                      }\n+                    };\n+                    (*values).push(@value)\n+                }\n+\n+                parsing_key = true;\n+                key = ~\"\";\n+                value = ~\"\";\n+              }\n+              '=' { parsing_key = false; }\n+              ch {\n+                let ch = alt ch {\n+                  '%' {\n+                    uint::parse_buf(rdr.read_bytes(2u), 16u).get() as char\n+                  }\n+                  '+' { ' ' }\n+                  ch { ch }\n+                };\n+\n+                if parsing_key {\n+                    str::push_char(key, ch)\n+                } else {\n+                    str::push_char(value, ch)\n+                }\n+              }\n+            }\n+        }\n+\n+        if key != ~\"\" && value != ~\"\" {\n+            let values = alt m.find(key) {\n+              some(values) { values }\n+              none {\n+                let values = @dvec();\n+                m.insert(key, values);\n+                values\n+              }\n+            };\n+            (*values).push(@value)\n+        }\n+\n+        m\n+    }\n+}\n+\n+\n fn split_char_first(s: ~str, c: char) -> (~str, ~str) {\n     let mut v = str::splitn_char(s, c, 1);\n     if v.len() == 1 {\n@@ -62,7 +290,7 @@ fn query_from_str(rawquery: ~str) -> query {\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n             let (k, v) = split_char_first(p, '=');\n-            vec::push(query, (k, v));\n+            vec::push(query, (decode_component(k), decode_component(v)));\n         };\n     }\n     return query;\n@@ -72,7 +300,7 @@ fn query_to_str(query: query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n         let (k, v) = kv;\n-        strvec += ~[fmt!{\"%s=%s\", k, v}];\n+        strvec += ~[#fmt(\"%s=%s\", encode_component(k), encode_component(v))];\n     };\n     return str::connect(strvec, ~\"&\");\n }\n@@ -130,7 +358,7 @@ fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n     let (rest, query) = split_char_first(rest, '?');\n     let query = query_from_str(query);\n     let (host, pth) = split_char_first(rest, '/');\n-    let mut path = pth;\n+    let mut path = decode_component(pth);\n     if str::len(path) != 0 {\n         str::unshift_char(path, '/');\n     }\n@@ -242,4 +470,157 @@ mod tests {\n         assert to_str(result::unwrap(from_str(url))) == url;\n     }\n \n+    #[test]\n+    fn test_url_component_encoding() {\n+        let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n+        let u = result::unwrap(from_str(url));\n+        assert u.path == ~\"/doc uments\";\n+        assert u.query.find(|kv| kv.first() == ~\"ba%d \")\n+            .get().second() == ~\"#&+\";\n+    }\n+\n+    #[test]\n+    fn test_encode() {\n+        assert encode(~\"\") == ~\"\";\n+        assert encode(~\"http://example.com\") == ~\"http://example.com\";\n+        assert encode(~\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n+        assert encode(~\" \") == ~\"%20\";\n+        assert encode(~\"!\") == ~\"!\";\n+        assert encode(~\"\\\"\") == ~\"\\\"\";\n+        assert encode(~\"#\") == ~\"#\";\n+        assert encode(~\"$\") == ~\"$\";\n+        assert encode(~\"%\") == ~\"%25\";\n+        assert encode(~\"&\") == ~\"&\";\n+        assert encode(~\"'\") == ~\"%27\";\n+        assert encode(~\"(\") == ~\"(\";\n+        assert encode(~\")\") == ~\")\";\n+        assert encode(~\"*\") == ~\"*\";\n+        assert encode(~\"+\") == ~\"+\";\n+        assert encode(~\",\") == ~\",\";\n+        assert encode(~\"/\") == ~\"/\";\n+        assert encode(~\":\") == ~\":\";\n+        assert encode(~\";\") == ~\";\";\n+        assert encode(~\"=\") == ~\"=\";\n+        assert encode(~\"?\") == ~\"?\";\n+        assert encode(~\"@\") == ~\"@\";\n+        assert encode(~\"[\") == ~\"[\";\n+        assert encode(~\"]\") == ~\"]\";\n+    }\n+\n+    #[test]\n+    fn test_encode_component() {\n+        assert encode_component(~\"\") == ~\"\";\n+        assert encode_component(~\"http://example.com\") ==\n+            ~\"http%3A%2F%2Fexample.com\";\n+        assert encode_component(~\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n+        assert encode_component(~\" \") == ~\"%20\";\n+        assert encode_component(~\"!\") == ~\"%21\";\n+        assert encode_component(~\"#\") == ~\"%23\";\n+        assert encode_component(~\"$\") == ~\"%24\";\n+        assert encode_component(~\"%\") == ~\"%25\";\n+        assert encode_component(~\"&\") == ~\"%26\";\n+        assert encode_component(~\"'\") == ~\"%27\";\n+        assert encode_component(~\"(\") == ~\"%28\";\n+        assert encode_component(~\")\") == ~\"%29\";\n+        assert encode_component(~\"*\") == ~\"%2A\";\n+        assert encode_component(~\"+\") == ~\"%2B\";\n+        assert encode_component(~\",\") == ~\"%2C\";\n+        assert encode_component(~\"/\") == ~\"%2F\";\n+        assert encode_component(~\":\") == ~\"%3A\";\n+        assert encode_component(~\";\") == ~\"%3B\";\n+        assert encode_component(~\"=\") == ~\"%3D\";\n+        assert encode_component(~\"?\") == ~\"%3F\";\n+        assert encode_component(~\"@\") == ~\"%40\";\n+        assert encode_component(~\"[\") == ~\"%5B\";\n+        assert encode_component(~\"]\") == ~\"%5D\";\n+    }\n+\n+    #[test]\n+    fn test_decode() {\n+        assert decode(~\"\") == ~\"\";\n+        assert decode(~\"abc/def 123\") == ~\"abc/def 123\";\n+        assert decode(~\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\";\n+        assert decode(~\"%20\") == ~\" \";\n+        assert decode(~\"%21\") == ~\"%21\";\n+        assert decode(~\"%22\") == ~\"%22\";\n+        assert decode(~\"%23\") == ~\"%23\";\n+        assert decode(~\"%24\") == ~\"%24\";\n+        assert decode(~\"%25\") == ~\"%\";\n+        assert decode(~\"%26\") == ~\"%26\";\n+        assert decode(~\"%27\") == ~\"'\";\n+        assert decode(~\"%28\") == ~\"%28\";\n+        assert decode(~\"%29\") == ~\"%29\";\n+        assert decode(~\"%2A\") == ~\"%2A\";\n+        assert decode(~\"%2B\") == ~\"%2B\";\n+        assert decode(~\"%2C\") == ~\"%2C\";\n+        assert decode(~\"%2F\") == ~\"%2F\";\n+        assert decode(~\"%3A\") == ~\"%3A\";\n+        assert decode(~\"%3B\") == ~\"%3B\";\n+        assert decode(~\"%3D\") == ~\"%3D\";\n+        assert decode(~\"%3F\") == ~\"%3F\";\n+        assert decode(~\"%40\") == ~\"%40\";\n+        assert decode(~\"%5B\") == ~\"%5B\";\n+        assert decode(~\"%5D\") == ~\"%5D\";\n+    }\n+\n+    #[test]\n+    fn test_decode_component() {\n+        assert decode_component(~\"\") == ~\"\";\n+        assert decode_component(~\"abc/def 123\") == ~\"abc/def 123\";\n+        assert decode_component(~\"abc%2Fdef%20123\") == ~\"abc/def 123\";\n+        assert decode_component(~\"%20\") == ~\" \";\n+        assert decode_component(~\"%21\") == ~\"!\";\n+        assert decode_component(~\"%22\") == ~\"\\\"\";\n+        assert decode_component(~\"%23\") == ~\"#\";\n+        assert decode_component(~\"%24\") == ~\"$\";\n+        assert decode_component(~\"%25\") == ~\"%\";\n+        assert decode_component(~\"%26\") == ~\"&\";\n+        assert decode_component(~\"%27\") == ~\"'\";\n+        assert decode_component(~\"%28\") == ~\"(\";\n+        assert decode_component(~\"%29\") == ~\")\";\n+        assert decode_component(~\"%2A\") == ~\"*\";\n+        assert decode_component(~\"%2B\") == ~\"+\";\n+        assert decode_component(~\"%2C\") == ~\",\";\n+        assert decode_component(~\"%2F\") == ~\"/\";\n+        assert decode_component(~\"%3A\") == ~\":\";\n+        assert decode_component(~\"%3B\") == ~\";\";\n+        assert decode_component(~\"%3D\") == ~\"=\";\n+        assert decode_component(~\"%3F\") == ~\"?\";\n+        assert decode_component(~\"%40\") == ~\"@\";\n+        assert decode_component(~\"%5B\") == ~\"[\";\n+        assert decode_component(~\"%5D\") == ~\"]\";\n+    }\n+\n+    #[test]\n+    fn test_encode_form_urlencoded() {\n+        let m = str_hash();\n+        assert encode_form_urlencoded(m) == ~\"\";\n+\n+        m.insert(~\"\", @dvec());\n+        m.insert(~\"foo\", @dvec());\n+        assert encode_form_urlencoded(m) == ~\"\";\n+\n+        let m = str_hash();\n+        m.insert(~\"foo\", @dvec::from_vec(~[mut @~\"bar\", @~\"123\"]));\n+        assert encode_form_urlencoded(m) == ~\"foo=bar&foo=123\";\n+\n+        let m = str_hash();\n+        m.insert(~\"foo bar\", @dvec::from_vec(~[mut @~\"abc\", @~\"12 = 34\"]));\n+        assert encode_form_urlencoded(m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\";\n+    }\n+\n+    #[test]\n+    fn test_decode_form_urlencoded() {\n+        import map::hash_from_strs;\n+\n+        assert decode_form_urlencoded(~[]) == str_hash();\n+\n+        let s = str::bytes(~\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n+        assert decode_form_urlencoded(s) == hash_from_strs(~[\n+            (~\"a\", @dvec::from_elem(@~\"1\")),\n+            (~\"foo bar\", @dvec::from_vec(~[mut @~\"abc\", @~\"12 = 34\"]))\n+        ]);\n+    }\n+\n }\n+"}]}