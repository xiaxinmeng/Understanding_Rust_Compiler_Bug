{"sha": "b87e189694eebb5b83d758528032cf4d4db81472", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4N2UxODk2OTRlZWJiNWI4M2Q3NTg1MjgwMzJjZjRkNGRiODE0NzI=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-01-29T00:38:34Z"}, "committer": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-01T15:58:31Z"}, "message": "Implement manual flatten lint", "tree": {"sha": "f257ace42358cceeff9defda91299a61fde1c3a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f257ace42358cceeff9defda91299a61fde1c3a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b87e189694eebb5b83d758528032cf4d4db81472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b87e189694eebb5b83d758528032cf4d4db81472", "html_url": "https://github.com/rust-lang/rust/commit/b87e189694eebb5b83d758528032cf4d4db81472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b87e189694eebb5b83d758528032cf4d4db81472/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8973f2c03a87802ba266f1e3e08e6b4cf7f96b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8973f2c03a87802ba266f1e3e08e6b4cf7f96b8c", "html_url": "https://github.com/rust-lang/rust/commit/8973f2c03a87802ba266f1e3e08e6b4cf7f96b8c"}], "stats": {"total": 314, "additions": 208, "deletions": 106}, "files": [{"sha": "aceabcbbdfc8cc2ed0ea440811cdc2fa0f78a7d2", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -1969,7 +1969,6 @@ Released 2018-09-13\n [`fn_to_numeric_cast_with_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast_with_truncation\n [`for_kv_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_kv_map\n [`for_loops_over_fallibles`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loops_over_fallibles\n-[`for_loops_over_options_or_results`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loops_over_options_or_results\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n@@ -2040,6 +2039,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n+[`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or"}, {"sha": "cd0a95a45857a61b7b7ee4c73ed28992f07ea098", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -685,8 +685,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::EXPLICIT_ITER_LOOP,\n         &loops::FOR_KV_MAP,\n         &loops::FOR_LOOPS_OVER_FALLIBLES,\n-        &loops::FOR_LOOPS_OVER_OPTIONS_OR_RESULTS,\n         &loops::ITER_NEXT_LOOP,\n+        &loops::MANUAL_FLATTEN,\n         &loops::MANUAL_MEMCPY,\n         &loops::MUT_RANGE_BOUND,\n         &loops::NEEDLESS_COLLECT,\n@@ -1489,8 +1489,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n         LintId::of(&loops::FOR_LOOPS_OVER_FALLIBLES),\n-        LintId::of(&loops::FOR_LOOPS_OVER_OPTIONS_OR_RESULTS),\n         LintId::of(&loops::ITER_NEXT_LOOP),\n+        LintId::of(&loops::MANUAL_FLATTEN),\n         LintId::of(&loops::MANUAL_MEMCPY),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::NEEDLESS_COLLECT),\n@@ -1822,7 +1822,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n-        LintId::of(&loops::FOR_LOOPS_OVER_OPTIONS_OR_RESULTS),\n+        LintId::of(&loops::MANUAL_FLATTEN),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::SINGLE_ELEMENT_LOOP),\n         LintId::of(&loops::WHILE_LET_LOOP),"}, {"sha": "db5aec82e90c29c7a99739cd9c9db55b3ceffbbc", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -5,10 +5,10 @@ use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n-    last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, single_segment_path, snippet,\n-    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n-    span_lint_and_then, sugg, SpanlessEq,\n+    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_ok_ctor, is_refutable, is_some_ctor,\n+    is_type_diagnostic_item, last_path_segment, match_trait_method, match_type, match_var, multispan_sugg,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -495,8 +495,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for iteration of `Option`s with\n-    /// a single `if let Some()` expression inside.\n+    /// **What it does:** Check for unnecessary `if let` usage in a for loop\n+    /// where only the `Some` or `Ok` variant of the iterator element is used.\n     ///\n     /// **Why is this bad?** It is verbose and can be simplified\n     /// by first calling the `flatten` method on the `Iterator`.\n@@ -516,23 +516,23 @@ declare_clippy_lint! {\n     /// Use instead:\n     /// ```rust\n     /// let x = vec![Some(1), Some(2), Some(3)];\n-    /// for n in x.iter().flatten() {\n+    /// for n in x.into_iter().flatten() {\n     ///     println!(\"{}\", n);\n     /// }\n     /// ```\n-    pub FOR_LOOPS_OVER_OPTIONS_OR_RESULTS,\n+    pub MANUAL_FLATTEN,\n     complexity,\n     \"for loops over `Option`s or `Result`s with a single expression can be simplified\"\n }\n \n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n+    MANUAL_FLATTEN,\n     NEEDLESS_RANGE_LOOP,\n     EXPLICIT_ITER_LOOP,\n     EXPLICIT_INTO_ITER_LOOP,\n     ITER_NEXT_LOOP,\n     FOR_LOOPS_OVER_FALLIBLES,\n-    FOR_LOOPS_OVER_OPTIONS_OR_RESULTS,\n     WHILE_LET_LOOP,\n     NEEDLESS_COLLECT,\n     EXPLICIT_COUNTER_LOOP,\n@@ -549,14 +549,14 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((pat, arg, body)) = higher::for_loop(expr) {\n+        if let Some((pat, arg, body, span)) = higher::for_loop(expr) {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n             if body.span.from_expansion() {\n                 return;\n             }\n-            check_for_loop(cx, pat, arg, body, expr);\n+            check_for_loop(cx, pat, arg, body, expr, span);\n         }\n \n         // we don't want to check expanded macros\n@@ -851,6 +851,7 @@ fn check_for_loop<'tcx>(\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n+    span: Span,\n ) {\n     let is_manual_memcpy_triggered = detect_manual_memcpy(cx, pat, arg, body, expr);\n     if !is_manual_memcpy_triggered {\n@@ -862,7 +863,7 @@ fn check_for_loop<'tcx>(\n     check_for_mut_range_bound(cx, arg, body);\n     check_for_single_element_loop(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n-    check_for_loop_over_options_or_results(cx, pat, arg, body, expr);\n+    check_manual_flatten(cx, pat, arg, body, span);\n }\n \n // this function assumes the given expression is a `for` loop.\n@@ -1986,33 +1987,61 @@ fn check_for_single_element_loop<'tcx>(\n     }\n }\n \n-/// Check if a for loop loops over `Option`s or `Result`s and contains only\n-/// a `if let Some` or `if let Ok` expression.\n-fn check_for_loop_over_options_or_results<'tcx>(\n+/// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n+/// iterator element is used.\n+fn check_manual_flatten<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n-    expr: &'tcx Expr<'_>,\n+    span: Span,\n ) {\n     if_chain! {\n+        // Ensure the `if let` statement is the only expression in the for-loop\n         if let ExprKind::Block(ref block, _) = body.kind;\n         if block.stmts.is_empty();\n         if let Some(inner_expr) = block.expr;\n-        if let ExprKind::Match(ref _match_expr, ref _match_arms, MatchSource::IfLetDesugar{ contains_else_clause }) = inner_expr.kind;\n-        if !contains_else_clause;\n+        if let ExprKind::Match(\n+            ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+        ) = inner_expr.kind;\n+        // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+        if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+        if let ExprKind::Path(QPath::Resolved(None, match_expr_path)) = match_expr.kind;\n+        if let Res::Local(match_expr_path_id) = match_expr_path.res;\n+        if pat_hir_id == match_expr_path_id;\n+        // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+        if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n+        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+        let if_let_type = if is_some_ctor(cx, path.res) {\n+            \"Some\"\n+        } else {\n+            \"Ok\"\n+        };\n+        // Determine if `arg` is `Iterator` or implicitly calls `into_iter`\n+        let arg_ty = cx.typeck_results().expr_ty(arg);\n+        if let Some(id) = get_trait_def_id(cx, &paths::ITERATOR);\n+        if let is_iterator = implements_trait(cx, arg_ty, id, &[]);\n+\n         then {\n-            // println!(\"if_let_expr:\\n{:?}\", snippet(cx, if_let_expr.span, \"..\"));\n-            // println!(\"pat is:\\n {:?}\", snippet(cx, pat.span, \"..\"));\n-            // println!(\"arg is:\\n {:?}\", snippet(cx, arg.span, \"..\"));\n-            // println!(\"body is:\\n {:?}\", snippet(cx, body.span, \"..\"));\n-            // println!(\"arg kind is: {:?}\", arg.kind);\n-            // println!(\"expr is:\\n {:?}\", snippet(cx, expr.span, \"..\"));\n-            // todo!();\n+            // Prepare the error message\n+            let msg = format!(\"Unnecessary `if let` since only the `{}` variant of the iterator element is used.\", if_let_type);\n+\n+            // Prepare the help message\n             let arg_snippet = snippet(cx, arg.span, \"..\");\n-            let msg = \"looping over `Option`s or `Result`s with an `if let` expression.\";\n-            let hint = format!(\"try turn {} into an `Iterator` and use `flatten`: `{}.iter().flatten()`\", arg_snippet, arg_snippet);\n-            span_lint_and_help(cx, FOR_LOOPS_OVER_OPTIONS_OR_RESULTS, expr.span, msg, None, &hint);\n+            let hint = if is_iterator {\n+                format!(\"try: `{}.flatten()`\", arg_snippet)\n+            } else {\n+                format!(\"try: `{}.into_iter().flatten()`\", arg_snippet)\n+            };\n+\n+            span_lint_and_help(\n+                cx,\n+                MANUAL_FLATTEN,\n+                span,\n+                &msg,\n+                Some(arg.span),\n+                &hint,\n+            );\n         }\n     }\n }"}, {"sha": "d7239b328bbcd0a7f245ba19b827ffbf67f1b856", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        if let Some((_, arg, body)) = higher::for_loop(expr) {\n+        if let Some((_, arg, body, _)) = higher::for_loop(expr) {\n             // A `for` loop lowers to:\n             // ```rust\n             // match ::std::iter::Iterator::next(&mut iter) {"}, {"sha": "fe8d4d07abc15ae8a062e313c766a93c6c065bea", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -1,8 +1,6 @@\n use rustc_errors::Applicability;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::ty::DefIdTree;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::sym;\n@@ -160,7 +158,7 @@ fn is_some_or_ok_call<'a>(\n         // Check outer expression matches CALL_IDENT(ARGUMENT) format\n         if let ExprKind::Call(path, args) = &expr.kind;\n         if let ExprKind::Path(QPath::Resolved(None, path)) = &path.kind;\n-        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+        if utils::is_some_ctor(cx, path.res) || utils::is_ok_ctor(cx, path.res);\n \n         // Extract inner expression from ARGUMENT\n         if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;\n@@ -208,25 +206,3 @@ fn is_some_or_ok_call<'a>(\n fn has_implicit_error_from(cx: &LateContext<'_>, entire_expr: &Expr<'_>, inner_result_expr: &Expr<'_>) -> bool {\n     return cx.typeck_results().expr_ty(entire_expr) != cx.typeck_results().expr_ty(inner_result_expr);\n }\n-\n-fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == ok_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == some_id;\n-            }\n-        }\n-    }\n-    false\n-}"}, {"sha": "59503817c0fccfc97719e2d355defa325e8fb0fe", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -442,7 +442,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let mut cur_expr = expr;\n         while let Some(parent_expr) = get_parent_expr(cx, cur_expr) {\n             match higher::for_loop(parent_expr) {\n-                Some((_, args, _)) if args.hir_id == expr.hir_id => return true,\n+                Some((_, args, _, _)) if args.hir_id == expr.hir_id => return true,\n                 _ => cur_expr = parent_expr,\n             }\n         }"}, {"sha": "df7f0f957821877a9ed52c0db5f711d60f1dabd0", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -9,6 +9,7 @@ use rustc_ast::ast;\n use rustc_hir as hir;\n use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n #[must_use]\n@@ -133,11 +134,11 @@ pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n     false\n }\n \n-/// Recover the essential nodes of a desugared for loop:\n-/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n+/// Recover the essential nodes of a desugared for loop as well as the entire span:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n pub fn for_loop<'tcx>(\n     expr: &'tcx hir::Expr<'tcx>,\n-) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n+) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>, Span)> {\n     if_chain! {\n         if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n@@ -148,7 +149,7 @@ pub fn for_loop<'tcx>(\n         if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n         if let hir::StmtKind::Expr(ref expr) = body.kind;\n         then {\n-            return Some((&*local.pat, &iterargs[0], expr));\n+            return Some((&*local.pat, &iterargs[0], expr, arms[0].span));\n         }\n     }\n     None"}, {"sha": "b3eae933062114dd95299fd800d1446242d1dda4", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -841,15 +841,13 @@ pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n     // implementations of native types. Check lang items.\n     let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n     let lang_items = cx.tcx.lang_items();\n-    for lang_item in lang_items.items() {\n-        if let Some(def_id) = lang_item {\n-            let lang_item_path = cx.get_def_path(*def_id);\n-            if path_syms.starts_with(&lang_item_path) {\n-                if let [item] = &path_syms[lang_item_path.len()..] {\n-                    for child in cx.tcx.item_children(*def_id) {\n-                        if child.ident.name == *item {\n-                            return true;\n-                        }\n+    for item_def_id in lang_items.items().iter().flatten() {\n+        let lang_item_path = cx.get_def_path(*item_def_id);\n+        if path_syms.starts_with(&lang_item_path) {\n+            if let [item] = &path_syms[lang_item_path.len()..] {\n+                for child in cx.tcx.item_children(*item_def_id) {\n+                    if child.ident.name == *item {\n+                        return true;\n                     }\n                 }\n             }"}, {"sha": "3390c71dd8ecbe8fc521f38533e2abf5c24e92b0", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -37,7 +37,7 @@ use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n@@ -50,7 +50,7 @@ use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -1700,6 +1700,30 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     }\n }\n \n+/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n+pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == ok_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Check if the resolution of a given path is a `Some` variant of `Option`.\n+pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == some_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{reindent_multiline, without_block_comments};"}, {"sha": "c132e4de4f67ba450b877bf49fe09066bf5b32a8", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n \n         // search for `for _ in vec![\u2026]`\n         if_chain! {\n-            if let Some((_, arg, _)) = higher::for_loop(expr);\n+            if let Some((_, arg, _, _)) = higher::for_loop(expr);\n             if let Some(vec_args) = higher::vec_macro(cx, arg);\n             if is_copy(cx, vec_type(cx.typeck_results().expr_ty_adjusted(arg)));\n             then {"}, {"sha": "02e24b250f79652d73c06c2470421efe4f285771", "filename": "tests/ui/for_loops_over_options_or_results.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8973f2c03a87802ba266f1e3e08e6b4cf7f96b8c/tests%2Fui%2Ffor_loops_over_options_or_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8973f2c03a87802ba266f1e3e08e6b4cf7f96b8c/tests%2Fui%2Ffor_loops_over_options_or_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loops_over_options_or_results.rs?ref=8973f2c03a87802ba266f1e3e08e6b4cf7f96b8c", "patch": "@@ -1,31 +0,0 @@\n-#![warn(clippy::for_loops_over_options_or_results)]\n-\n-fn main() {\n-    let x = vec![Some(1), Some(2), Some(3)];\n-    for n in x {\n-        if let Some(n) = n {\n-            println!(\"{}\", n);\n-        }\n-    }\n-\n-    let y: Vec<Result<i32, i32>> = vec![];\n-    for n in y.clone() {\n-        if let Ok(n) = n {\n-            println!(\"{}\", n);\n-        }\n-    }\n-\n-    // This should not trigger the lint\n-    for n in y.clone() {\n-        if let Ok(n) = n {\n-            println!(\"{}\", n);\n-        } else {\n-            println!(\"Oops!\");\n-        }\n-    }\n-\n-    // This should not trigger the lint\n-    for n in vec![Some(1), Some(2), Some(3)].iter().flatten() {\n-        println!(\"{}\", n);\n-    }\n-}"}, {"sha": "f183ceecdd8971aa089b8cbf8b7290bf086b5cda", "filename": "tests/ui/manual_flatten.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/tests%2Fui%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/tests%2Fui%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_flatten.rs?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -0,0 +1,54 @@\n+#![warn(clippy::manual_flatten)]\n+\n+fn main() {\n+    let x = vec![Some(1), Some(2), Some(3)];\n+    for n in x {\n+        if let Some(n) = n {\n+            println!(\"{}\", n);\n+        }\n+    }\n+\n+    let y: Vec<Result<i32, i32>> = vec![];\n+    for n in y.clone() {\n+        if let Ok(n) = n {\n+            println!(\"{}\", n);\n+        }\n+    }\n+\n+    let z = vec![Some(1), Some(2), Some(3)];\n+    let z = z.iter();\n+    for n in z {\n+        if let Some(n) = n {\n+            println!(\"{}\", n);\n+        }\n+    }\n+\n+    // Using the `None` variant should not trigger the lint\n+    let z = vec![Some(1), Some(2), Some(3)];\n+    for n in z {\n+        if n.is_none() {\n+            println!(\"Nada.\");\n+        }\n+    }\n+\n+    // Using the `Err` variant should not trigger the lint\n+    for n in y.clone() {\n+        if let Err(e) = n {\n+            println!(\"Oops: {}!\", e);\n+        }\n+    }\n+\n+    // Having an else clause should not trigger the lint\n+    for n in y.clone() {\n+        if let Ok(n) = n {\n+            println!(\"{}\", n);\n+        } else {\n+            println!(\"Oops!\");\n+        }\n+    }\n+\n+    // Using manual flatten should not trigger the lint\n+    for n in vec![Some(1), Some(2), Some(3)].iter().flatten() {\n+        println!(\"{}\", n);\n+    }\n+}"}, {"sha": "cf99a2d9ab1f84d54b668e2ded35097cd7434626", "filename": "tests/ui/manual_flatten.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b87e189694eebb5b83d758528032cf4d4db81472/tests%2Fui%2Fmanual_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b87e189694eebb5b83d758528032cf4d4db81472/tests%2Fui%2Fmanual_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_flatten.stderr?ref=b87e189694eebb5b83d758528032cf4d4db81472", "patch": "@@ -0,0 +1,51 @@\n+error: Unnecessary `if let` since only the `Some` variant of the iterator element is used.\n+  --> $DIR/manual_flatten.rs:5:5\n+   |\n+LL | /     for n in x {\n+LL | |         if let Some(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-flatten` implied by `-D warnings`\n+help: try: `x.into_iter().flatten()`\n+  --> $DIR/manual_flatten.rs:5:14\n+   |\n+LL |     for n in x {\n+   |              ^\n+\n+error: Unnecessary `if let` since only the `Ok` variant of the iterator element is used.\n+  --> $DIR/manual_flatten.rs:12:5\n+   |\n+LL | /     for n in y.clone() {\n+LL | |         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try: `y.clone().into_iter().flatten()`\n+  --> $DIR/manual_flatten.rs:12:14\n+   |\n+LL |     for n in y.clone() {\n+   |              ^^^^^^^^^\n+\n+error: Unnecessary `if let` since only the `Some` variant of the iterator element is used.\n+  --> $DIR/manual_flatten.rs:20:5\n+   |\n+LL | /     for n in z {\n+LL | |         if let Some(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try: `z.flatten()`\n+  --> $DIR/manual_flatten.rs:20:14\n+   |\n+LL |     for n in z {\n+   |              ^\n+\n+error: aborting due to 3 previous errors\n+"}]}