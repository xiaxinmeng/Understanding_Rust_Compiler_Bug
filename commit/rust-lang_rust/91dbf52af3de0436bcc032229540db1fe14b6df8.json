{"sha": "91dbf52af3de0436bcc032229540db1fe14b6df8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZGJmNTJhZjNkZTA0MzZiY2MwMzIyMjk1NDBkYjFmZTE0YjZkZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T12:52:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T12:52:02Z"}, "message": "Auto merge of #44809 - arielb1:small-scope, r=eddyb\n\nencode region::Scope using fewer bytes\n\nNow that region::Scope is no longer interned, its size is more important. This PR encodes region::Scope in 8 bytes instead of 12, which should speed up region inference somewhat (perf testing needed) and should improve the margins on #36799 by 64MB (that's not a lot, I did this PR mostly to speed up region inference).\n\nThis is a perf-sensitive PR. Please don't roll me up.\n\nr? @eddyb\n\nThis is based on  #44743 so I could get more accurate measurements on #36799.", "tree": {"sha": "3dc7c82fe4664bba0117e1b8472db8c50579fdc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dc7c82fe4664bba0117e1b8472db8c50579fdc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91dbf52af3de0436bcc032229540db1fe14b6df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91dbf52af3de0436bcc032229540db1fe14b6df8", "html_url": "https://github.com/rust-lang/rust/commit/91dbf52af3de0436bcc032229540db1fe14b6df8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91dbf52af3de0436bcc032229540db1fe14b6df8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcb4378e18571fa01e20ef63820d960f1c2cc865", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb4378e18571fa01e20ef63820d960f1c2cc865", "html_url": "https://github.com/rust-lang/rust/commit/dcb4378e18571fa01e20ef63820d960f1c2cc865"}, {"sha": "7bb0923e464c34291e7ed60f270095957d8cd331", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb0923e464c34291e7ed60f270095957d8cd331", "html_url": "https://github.com/rust-lang/rust/commit/7bb0923e464c34291e7ed60f270095957d8cd331"}], "stats": {"total": 188, "additions": 141, "deletions": 47}, "files": [{"sha": "2bbf807807baddfda7ac88f21bb8186f021c081e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=91dbf52af3de0436bcc032229540db1fe14b6df8", "patch": "@@ -514,13 +514,8 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl_stable_hash_for!(enum ::middle::region::Scope {\n-    Node(local_id),\n-    Destruction(local_id),\n-    CallSite(local_id),\n-    Arguments(local_id),\n-    Remainder(block_remainder)\n-});\n+impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { idx });\n+impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n \n impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n     type KeyType = region::Scope;"}, {"sha": "ead20b5eb5a3e51e7e45c2f7b5c79b0ee09e2616", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=91dbf52af3de0436bcc032229540db1fe14b6df8", "patch": "@@ -72,6 +72,8 @@ use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n mod note;\n \n mod need_type_info;\n@@ -152,21 +154,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let scope_decorated_tag = match scope {\n-                    region::Scope::Node(_) => tag,\n-                    region::Scope::CallSite(_) => {\n+                let scope_decorated_tag = match scope.data() {\n+                    region::ScopeData::Node(_) => tag,\n+                    region::ScopeData::CallSite(_) => {\n                         \"scope of call-site for function\"\n                     }\n-                    region::Scope::Arguments(_) => {\n+                    region::ScopeData::Arguments(_) => {\n                         \"scope of function body\"\n                     }\n-                    region::Scope::Destruction(_) => {\n+                    region::ScopeData::Destruction(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::Scope::Remainder(r) => {\n+                    region::ScopeData::Remainder(r) => {\n                         new_string = format!(\"block suffix following statement {}\",\n-                                             r.first_statement_index);\n+                                             r.first_statement_index.index());\n                         &new_string[..]\n                     }\n                 };"}, {"sha": "cede0c2b9a2c27f155d9b3337184d0df5b5200a6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 117, "deletions": 23, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=91dbf52af3de0436bcc032229540db1fe14b6df8", "patch": "@@ -18,6 +18,7 @@ use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n+use std::fmt;\n use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n@@ -31,6 +32,7 @@ use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use mir::transform::MirSource;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n@@ -95,8 +97,24 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n+///\n+/// Scope is a bit-packed to save space - if `code` is SCOPE_DATA_REMAINDER_MAX\n+/// or less, it is a `ScopeData::Remainder`, otherwise it is a type specified\n+/// by the bitpacking.\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n+pub struct Scope {\n+    pub(crate) id: hir::ItemLocalId,\n+    pub(crate) code: u32\n+}\n+\n+const SCOPE_DATA_NODE: u32 = !0;\n+const SCOPE_DATA_CALLSITE: u32 = !1;\n+const SCOPE_DATA_ARGUMENTS: u32 = !2;\n+const SCOPE_DATA_DESTRUCTION: u32 = !3;\n+const SCOPE_DATA_REMAINDER_MAX: u32 = !4;\n+\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n-pub enum Scope {\n+pub enum ScopeData {\n     Node(hir::ItemLocalId),\n \n     // Scope of the call-site for a function or closure\n@@ -135,7 +153,90 @@ pub enum Scope {\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n     pub block: hir::ItemLocalId,\n-    pub first_statement_index: u32,\n+    pub first_statement_index: FirstStatementIndex,\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+         RustcDecodable, Copy)]\n+pub struct FirstStatementIndex { pub idx: u32 }\n+\n+impl Idx for FirstStatementIndex {\n+    fn new(idx: usize) -> Self {\n+        assert!(idx <= SCOPE_DATA_REMAINDER_MAX as usize);\n+        FirstStatementIndex { idx: idx as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.idx as usize\n+    }\n+}\n+\n+impl fmt::Debug for FirstStatementIndex {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.index(), formatter)\n+    }\n+}\n+\n+impl From<ScopeData> for Scope {\n+    #[inline]\n+    fn from(scope_data: ScopeData) -> Self {\n+        let (id, code) = match scope_data {\n+            ScopeData::Node(id) => (id, SCOPE_DATA_NODE),\n+            ScopeData::CallSite(id) => (id, SCOPE_DATA_CALLSITE),\n+            ScopeData::Arguments(id) => (id, SCOPE_DATA_ARGUMENTS),\n+            ScopeData::Destruction(id) => (id, SCOPE_DATA_DESTRUCTION),\n+            ScopeData::Remainder(r) => (r.block, r.first_statement_index.index() as u32)\n+        };\n+        Self { id, code }\n+    }\n+}\n+\n+impl fmt::Debug for Scope {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.data(), formatter)\n+    }\n+}\n+\n+#[allow(non_snake_case)]\n+impl Scope {\n+    #[inline]\n+    pub fn data(self) -> ScopeData {\n+        match self.code {\n+            SCOPE_DATA_NODE => ScopeData::Node(self.id),\n+            SCOPE_DATA_CALLSITE => ScopeData::CallSite(self.id),\n+            SCOPE_DATA_ARGUMENTS => ScopeData::Arguments(self.id),\n+            SCOPE_DATA_DESTRUCTION => ScopeData::Destruction(self.id),\n+            idx => ScopeData::Remainder(BlockRemainder {\n+                block: self.id,\n+                first_statement_index: FirstStatementIndex { idx }\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn Node(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::Node(id))\n+    }\n+\n+    #[inline]\n+    pub fn CallSite(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::CallSite(id))\n+    }\n+\n+    #[inline]\n+    pub fn Arguments(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::Arguments(id))\n+    }\n+\n+    #[inline]\n+    pub fn Destruction(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::Destruction(id))\n+    }\n+\n+    #[inline]\n+    pub fn Remainder(r: BlockRemainder) -> Self {\n+        Self::from(ScopeData::Remainder(r))\n+    }\n }\n \n impl Scope {\n@@ -144,16 +245,7 @@ impl Scope {\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn item_local_id(&self) -> hir::ItemLocalId {\n-        match *self {\n-            Scope::Node(id) => id,\n-\n-            // These cases all return rough approximations to the\n-            // precise scope denoted by `self`.\n-            Scope::Remainder(br) => br.block,\n-            Scope::Destruction(id) |\n-            Scope::CallSite(id) |\n-            Scope::Arguments(id) => id,\n-        }\n+        self.id\n     }\n \n     pub fn node_id(&self, tcx: TyCtxt, scope_tree: &ScopeTree) -> ast::NodeId {\n@@ -177,7 +269,7 @@ impl Scope {\n             return DUMMY_SP;\n         }\n         let span = tcx.hir.span(node_id);\n-        if let Scope::Remainder(r) = *self {\n+        if let ScopeData::Remainder(r) = self.data() {\n             if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n@@ -187,7 +279,7 @@ impl Scope {\n                 // (This is the special case aluded to in the\n                 // doc-comment for this method)\n \n-                let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n+                let stmt_span = blk.stmts[r.first_statement_index.index()].span;\n \n                 // To avoid issues with macro-generated spans, the span\n                 // of the statement must be nested in that of the block.\n@@ -387,7 +479,7 @@ impl<'tcx> ScopeTree {\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let Scope::Destruction(n) = child {\n+        if let ScopeData::Destruction(n) = child.data() {\n             self.destruction_scopes.insert(n, child);\n         }\n     }\n@@ -482,8 +574,8 @@ impl<'tcx> ScopeTree {\n         let mut id = Scope::Node(expr_id);\n \n         while let Some(&p) = self.parent_map.get(&id) {\n-            match p {\n-                Scope::Destruction(..) => {\n+            match p.data() {\n+                ScopeData::Destruction(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n                     return Some(id);\n@@ -573,9 +665,9 @@ impl<'tcx> ScopeTree {\n             // infer::region_inference for more details.\n             let a_root_scope = a_ancestors[a_index];\n             let b_root_scope = a_ancestors[a_index];\n-            return match (a_root_scope, b_root_scope) {\n-                (Scope::Destruction(a_root_id),\n-                 Scope::Destruction(b_root_id)) => {\n+            return match (a_root_scope.data(), b_root_scope.data()) {\n+                (ScopeData::Destruction(a_root_id),\n+                 ScopeData::Destruction(b_root_id)) => {\n                     if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -764,7 +856,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 visitor.enter_scope(\n                     Scope::Remainder(BlockRemainder {\n                         block: blk.hir_id.local_id,\n-                        first_statement_index: i as u32\n+                        first_statement_index: FirstStatementIndex::new(i)\n                     })\n                 );\n                 visitor.cx.var_parent = visitor.cx.parent;\n@@ -915,8 +1007,10 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n                 // Don't cross from closure bodies to their parent.\n-                Some(&Scope::CallSite(_)) => break,\n-                Some(&superscope) => scope = superscope,\n+                Some(&superscope) => match superscope.data() {\n+                    ScopeData::CallSite(_) => break,\n+                    _ => scope = superscope\n+                },\n                 None => break\n             }\n         }"}, {"sha": "f714a5e14c47fd8fc34bef70fe5f83686455dc93", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=91dbf52af3de0436bcc032229540db1fe14b6df8", "patch": "@@ -26,6 +26,7 @@ use std::fmt;\n use std::usize;\n \n use rustc_const_math::ConstInt;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax::abi::Abi;\n use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n@@ -530,17 +531,17 @@ impl fmt::Display for ty::RegionKind {\n                 write!(f, \"{}\", br)\n             }\n             ty::ReScope(scope) if identify_regions() => {\n-                match scope {\n-                    region::Scope::Node(id) =>\n+                match scope.data() {\n+                    region::ScopeData::Node(id) =>\n                         write!(f, \"'{}s\", id.as_usize()),\n-                    region::Scope::CallSite(id) =>\n+                    region::ScopeData::CallSite(id) =>\n                         write!(f, \"'{}cs\", id.as_usize()),\n-                    region::Scope::Arguments(id) =>\n+                    region::ScopeData::Arguments(id) =>\n                         write!(f, \"'{}as\", id.as_usize()),\n-                    region::Scope::Destruction(id) =>\n+                    region::ScopeData::Destruction(id) =>\n                         write!(f, \"'{}ds\", id.as_usize()),\n-                    region::Scope::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index),\n+                    region::ScopeData::Remainder(BlockRemainder { block, first_statement_index }) =>\n+                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n                 }\n             }\n             ty::ReVar(region_vid) if identify_regions() => {"}, {"sha": "032734194329cf87d1cd70838ed3a9504932da8a", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=91dbf52af3de0436bcc032229540db1fe14b6df8", "patch": "@@ -555,8 +555,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match self.scopes[1].region_scope {\n-            region::Scope::Arguments(_) => true,\n+        assert!(match self.scopes[1].region_scope.data() {\n+            region::ScopeData::Arguments(_) => true,\n             _ => false,\n         });\n         self.scopes[1].region_scope"}, {"sha": "6f6258f52f794acb522010020e544d16e8930a4a", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91dbf52af3de0436bcc032229540db1fe14b6df8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=91dbf52af3de0436bcc032229540db1fe14b6df8", "patch": "@@ -14,6 +14,8 @@ use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{self, BlockRemainder};\n use rustc::hir;\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n@@ -71,7 +73,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     hir::DeclLocal(ref local) => {\n                         let remainder_scope = region::Scope::Remainder(BlockRemainder {\n                             block: block_id,\n-                            first_statement_index: index as u32,\n+                            first_statement_index: region::FirstStatementIndex::new(index),\n                         });\n \n                         let pattern = cx.pattern_from_hir(&local.pat);"}]}