{"sha": "212d5d43524123a45c6a88174fd3c771057faf47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMmQ1ZDQzNTI0MTIzYTQ1YzZhODgxNzRmZDNjNzcxMDU3ZmFmNDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-08T18:18:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-14T10:23:37Z"}, "message": "syntax: Refactor parsing of method declarations\n\nFix spans and expected token lists, fix #33413 + other cosmetic improvements\nAdd test for #33413\nConvert between `Arg` and `ExplicitSelf` precisely\nSimplify pretty-printing for methods", "tree": {"sha": "48904f375373719fffc03d67a21f59fd01a0212d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48904f375373719fffc03d67a21f59fd01a0212d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/212d5d43524123a45c6a88174fd3c771057faf47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/212d5d43524123a45c6a88174fd3c771057faf47", "html_url": "https://github.com/rust-lang/rust/commit/212d5d43524123a45c6a88174fd3c771057faf47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/212d5d43524123a45c6a88174fd3c771057faf47/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "html_url": "https://github.com/rust-lang/rust/commit/d3ec9d43cf948813fa5aab3dfacf97035ee90d16"}], "stats": {"total": 411, "additions": 206, "deletions": 205}, "files": [{"sha": "f6a794bd8cd739559b0750f5011d3a86440914a5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 65, "deletions": 18, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=212d5d43524123a45c6a88174fd3c771057faf47", "patch": "@@ -16,13 +16,12 @@ pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n \n use attr::ThinAttributes;\n-use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n+use codemap::{mk_sp, respan, Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use errors;\n use ext::base;\n use ext::tt::macro_parser;\n-use parse::token::InternedString;\n-use parse::token;\n+use parse::token::{self, keywords, InternedString};\n use parse::lexer;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use print::pprust;\n@@ -1674,7 +1673,25 @@ pub struct Arg {\n     pub id: NodeId,\n }\n \n+/// Represents the kind of 'self' associated with a method.\n+/// String representation of `Ident` here is always \"self\", but hygiene contexts may differ.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum SelfKind {\n+    /// No self\n+    Static,\n+    /// `self`, `mut self`\n+    Value(Ident),\n+    /// `&'lt self`, `&'lt mut self`\n+    Region(Option<Lifetime>, Mutability, Ident),\n+    /// `self: TYPE`, `mut self: TYPE`\n+    Explicit(P<Ty>, Ident),\n+}\n+\n+pub type ExplicitSelf = Spanned<SelfKind>;\n+\n impl Arg {\n+    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n+    #[rustc_deprecated(since = \"1.10.0\", reason = \"use `from_self` instead\")]\n     pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n         let path = Spanned{span:span,node:self_ident};\n         Arg {\n@@ -1692,6 +1709,51 @@ impl Arg {\n             id: DUMMY_NODE_ID\n         }\n     }\n+\n+    pub fn to_self(&self) -> Option<ExplicitSelf> {\n+        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+            if ident.node.name == keywords::SelfValue.name() {\n+                return match self.ty.node {\n+                    TyKind::Infer => Some(respan(self.pat.span, SelfKind::Value(ident.node))),\n+                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::Infer => {\n+                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl, ident.node)))\n+                    }\n+                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n+                                     SelfKind::Explicit(self.ty.clone(), ident.node))),\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn from_self(eself: ExplicitSelf, ident_sp: Span, mutbl: Mutability) -> Arg {\n+        let pat = |ident, span| P(Pat {\n+            id: DUMMY_NODE_ID,\n+            node: PatKind::Ident(BindingMode::ByValue(mutbl), respan(ident_sp, ident), None),\n+            span: span,\n+        });\n+        let infer_ty = P(Ty {\n+            id: DUMMY_NODE_ID,\n+            node: TyKind::Infer,\n+            span: DUMMY_SP,\n+        });\n+        let arg = |ident, ty, span| Arg {\n+            pat: pat(ident, span),\n+            ty: ty,\n+            id: DUMMY_NODE_ID,\n+        };\n+        match eself.node {\n+            SelfKind::Static => panic!(\"bug: `Arg::from_self` is called \\\n+                                        with `SelfKind::Static` argument\"),\n+            SelfKind::Explicit(ty, ident) => arg(ident, ty, mk_sp(eself.span.lo, ident_sp.hi)),\n+            SelfKind::Value(ident) => arg(ident, infer_ty, eself.span),\n+            SelfKind::Region(lt, mutbl, ident) => arg(ident, P(Ty {\n+                id: DUMMY_NODE_ID,\n+                node: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl: mutbl }),\n+                span: DUMMY_SP,\n+            }), eself.span),\n+        }\n+    }\n }\n \n /// Represents the header (not the body) of a function declaration\n@@ -1772,21 +1834,6 @@ impl FunctionRetTy {\n     }\n }\n \n-/// Represents the kind of 'self' associated with a method\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum SelfKind {\n-    /// No self\n-    Static,\n-    /// `self`\n-    Value(Ident),\n-    /// `&'lt self`, `&'lt mut self`\n-    Region(Option<Lifetime>, Mutability, Ident),\n-    /// `self: TYPE`\n-    Explicit(P<Ty>, Ident),\n-}\n-\n-pub type ExplicitSelf = Spanned<SelfKind>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`."}, {"sha": "fc62cee92fdbc5948b2dec120236b7125c927129", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 102, "deletions": 144, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=212d5d43524123a45c6a88174fd3c771057faf47", "patch": "@@ -2036,7 +2036,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse mutability declaration (mut/const/imm)\n+    /// Parse mutability (`mut` or nothing).\n     pub fn parse_mutability(&mut self) -> PResult<'a, Mutability> {\n         if self.eat_keyword(keywords::Mut) {\n             Ok(Mutability::Mutable)\n@@ -4616,184 +4616,142 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn expect_self_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token {\n-            token::Ident(id) if id.name == keywords::SelfValue.name() => {\n-                self.bump();\n-                // The hygiene context of `id` needs to be preserved here,\n-                // so we can't just return `SelfValue.ident()`.\n-                Ok(id)\n-            },\n-            _ => {\n-                let token_str = self.this_token_to_string();\n-                return Err(self.fatal(&format!(\"expected `self`, found `{}`\",\n-                                   token_str)))\n-            }\n-        }\n-    }\n-\n-    /// Parse the argument list and result type of a function\n-    /// that may have a self type.\n+    /// Parse the parameter list and result type of a function that may have a `self` parameter.\n     fn parse_fn_decl_with_self<F>(&mut self,\n-                                  parse_arg_fn: F) -> PResult<'a, (ExplicitSelf, P<FnDecl>)> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n+                                  parse_arg_fn: F)\n+                                  -> PResult<'a, (ExplicitSelf, P<FnDecl>)>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n     {\n-        fn maybe_parse_borrowed_explicit_self<'b>(this: &mut Parser<'b>)\n-                                                  -> PResult<'b, ast::SelfKind> {\n-            // The following things are possible to see here:\n-            //\n-            //     fn(&mut self)\n-            //     fn(&mut self)\n-            //     fn(&'lt self)\n-            //     fn(&'lt mut self)\n-            //\n-            // We already know that the current token is `&`.\n-\n-            if this.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                Ok(SelfKind::Region(None, Mutability::Immutable, this.expect_self_ident()?))\n-            } else if this.look_ahead(1, |t| t.is_mutability()) &&\n-                      this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                let mutability = this.parse_mutability()?;\n-                Ok(SelfKind::Region(None, mutability, this.expect_self_ident()?))\n-            } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n-                      this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                let lifetime = this.parse_lifetime()?;\n-                let ident = this.expect_self_ident()?;\n-                Ok(SelfKind::Region(Some(lifetime), Mutability::Immutable, ident))\n-            } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n-                      this.look_ahead(2, |t| t.is_mutability()) &&\n-                      this.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                let lifetime = this.parse_lifetime()?;\n-                let mutability = this.parse_mutability()?;\n-                Ok(SelfKind::Region(Some(lifetime), mutability, this.expect_self_ident()?))\n-            } else {\n-                Ok(SelfKind::Static)\n-            }\n-        }\n+        let expect_ident = |this: &mut Self| match this.token {\n+            token::Ident(ident) => { this.bump(); ident } // Preserve hygienic context.\n+            _ => unreachable!()\n+        };\n \n         self.expect(&token::OpenDelim(token::Paren))?;\n \n-        // A bit of complexity and lookahead is needed here in order to be\n-        // backwards compatible.\n-        let lo = self.span.lo;\n-        let mut self_ident_lo = self.span.lo;\n-        let mut self_ident_hi = self.span.hi;\n-\n-        let mut mutbl_self = Mutability::Immutable;\n-        let explicit_self = match self.token {\n+        // Parse optional self parameter of a method.\n+        // Only a limited set of initial token sequences is considered self parameters, anything\n+        // else is parsed as a normal function parameter list, so some lookahead is required.\n+        let eself_lo = self.span.lo;\n+        let mut eself_mutbl = Mutability::Immutable;\n+        let (eself, eself_ident_sp) = match self.token {\n             token::BinOp(token::And) => {\n-                let eself = maybe_parse_borrowed_explicit_self(self)?;\n-                self_ident_lo = self.last_span.lo;\n-                self_ident_hi = self.last_span.hi;\n-                eself\n+                // &self\n+                // &mut self\n+                // &'lt self\n+                // &'lt mut self\n+                // &not_self\n+                if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    (SelfKind::Region(None, Mutability::Immutable, expect_ident(self)),\n+                        self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    self.bump();\n+                    (SelfKind::Region(None, Mutability::Mutable, expect_ident(self)),\n+                        self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    let lt = self.parse_lifetime()?;\n+                    (SelfKind::Region(Some(lt), Mutability::Immutable, expect_ident(self)),\n+                        self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n+                          self.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    let lt = self.parse_lifetime()?;\n+                    self.bump();\n+                    (SelfKind::Region(Some(lt), Mutability::Mutable, expect_ident(self)),\n+                        self.last_span)\n+                } else {\n+                    (SelfKind::Static, codemap::DUMMY_SP)\n+                }\n             }\n             token::BinOp(token::Star) => {\n-                // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n-                // emitting cryptic \"unexpected token\" errors.\n-                self.bump();\n-                let _mutability = if self.token.is_mutability() {\n-                    self.parse_mutability()?\n-                } else {\n-                    Mutability::Immutable\n-                };\n-                if self.token.is_keyword(keywords::SelfValue) {\n-                    let span = self.span;\n-                    self.span_err(span, \"cannot pass self by raw pointer\");\n+                // *self\n+                // *const self\n+                // *mut self\n+                // *not_self\n+                // Emit special error for `self` cases.\n+                if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n+                    self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n+                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_mutability()) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    self.bump();\n+                    self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n+                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                } else {\n+                    (SelfKind::Static, codemap::DUMMY_SP)\n                 }\n-                // error case, making bogus self ident:\n-                SelfKind::Value(keywords::SelfValue.ident())\n             }\n             token::Ident(..) => {\n                 if self.token.is_keyword(keywords::SelfValue) {\n-                    let self_ident = self.expect_self_ident()?;\n-\n-                    // Determine whether this is the fully explicit form, `self:\n-                    // TYPE`.\n+                    // self\n+                    // self: TYPE\n+                    let eself_ident = expect_ident(self);\n+                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        SelfKind::Explicit(self.parse_ty_sum()?, self_ident)\n+                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n                     } else {\n-                        SelfKind::Value(self_ident)\n+                        (SelfKind::Value(eself_ident), eself_ident_sp)\n                     }\n-                } else if self.token.is_mutability() &&\n+                } else if self.token.is_keyword(keywords::Mut) &&\n                         self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n-                    mutbl_self = self.parse_mutability()?;\n-                    let self_ident = self.expect_self_ident()?;\n-\n-                    // Determine whether this is the fully explicit form,\n-                    // `self: TYPE`.\n+                    // mut self\n+                    // mut self: TYPE\n+                    eself_mutbl = Mutability::Mutable;\n+                    self.bump();\n+                    let eself_ident = expect_ident(self);\n+                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        SelfKind::Explicit(self.parse_ty_sum()?, self_ident)\n+                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n                     } else {\n-                        SelfKind::Value(self_ident)\n+                        (SelfKind::Value(eself_ident), eself_ident_sp)\n                     }\n                 } else {\n-                    SelfKind::Static\n+                    (SelfKind::Static, codemap::DUMMY_SP)\n                 }\n             }\n-            _ => SelfKind::Static,\n+            _ => (SelfKind::Static, codemap::DUMMY_SP)\n         };\n+        let mut eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n \n-        let explicit_self_sp = mk_sp(self_ident_lo, self_ident_hi);\n-\n-        // shared fall-through for the three cases below. borrowing prevents simply\n-        // writing this as a closure\n-        macro_rules! parse_remaining_arguments {\n-            ($self_id:ident) =>\n-            {\n-            // If we parsed a self type, expect a comma before the argument list.\n-            match self.token {\n-                token::Comma => {\n+        // Parse the rest of the function parameter list.\n+        let sep = SeqSep::trailing_allowed(token::Comma);\n+        let fn_inputs = match eself.node {\n+            SelfKind::Static => {\n+                eself.span = codemap::DUMMY_SP;\n+                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n+            }\n+            SelfKind::Value(..) | SelfKind::Region(..) | SelfKind::Explicit(..) => {\n+                if self.check(&token::CloseDelim(token::Paren)) {\n+                    vec![Arg::from_self(eself.clone(), eself_ident_sp, eself_mutbl)]\n+                } else if self.check(&token::Comma) {\n                     self.bump();\n-                    let sep = SeqSep::trailing_allowed(token::Comma);\n-                    let mut fn_inputs = self.parse_seq_to_before_end(\n-                        &token::CloseDelim(token::Paren),\n-                        sep,\n-                        parse_arg_fn\n+                    let mut fn_inputs = vec![Arg::from_self(eself.clone(), eself_ident_sp,\n+                                                            eself_mutbl)];\n+                    fn_inputs.append(&mut self.parse_seq_to_before_end(\n+                        &token::CloseDelim(token::Paren), sep, parse_arg_fn)\n                     );\n-                    fn_inputs.insert(0, Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n-                }\n-                token::CloseDelim(token::Paren) => {\n-                    vec!(Arg::new_self(explicit_self_sp, mutbl_self, $self_id))\n-                }\n-                _ => {\n-                    let token_str = self.this_token_to_string();\n-                    return Err(self.fatal(&format!(\"expected `,` or `)`, found `{}`\",\n-                                       token_str)))\n+                } else {\n+                    return self.unexpected();\n                 }\n             }\n-            }\n-        }\n-\n-        let fn_inputs = match explicit_self {\n-            SelfKind::Static =>  {\n-                let sep = SeqSep::trailing_allowed(token::Comma);\n-                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n-            }\n-            SelfKind::Value(id) => parse_remaining_arguments!(id),\n-            SelfKind::Region(_,_,id) => parse_remaining_arguments!(id),\n-            SelfKind::Explicit(_,id) => parse_remaining_arguments!(id),\n         };\n \n-\n+        // Parse closing paren and return type.\n         self.expect(&token::CloseDelim(token::Paren))?;\n-\n-        let hi = self.span.hi;\n-\n-        let ret_ty = self.parse_ret_ty()?;\n-\n-        let fn_decl = P(FnDecl {\n+        Ok((eself, P(FnDecl {\n             inputs: fn_inputs,\n-            output: ret_ty,\n+            output: self.parse_ret_ty()?,\n             variadic: false\n-        });\n-\n-        Ok((spanned(lo, hi, explicit_self), fn_decl))\n+        })))\n     }\n \n     // parse the |arg, arg| header on a lambda"}, {"sha": "ebb4927d69c0b7cfad3d5f80bc1c509ca2fc84c6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=212d5d43524123a45c6a88174fd3c771057faf47", "patch": "@@ -1522,7 +1522,7 @@ impl<'a> State<'a> {\n                       m.abi,\n                       Some(ident),\n                       &m.generics,\n-                      Some(&m.explicit_self.node),\n+                      None,\n                       vis)\n     }\n \n@@ -2656,36 +2656,9 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n-                         opt_explicit_self: Option<&ast::SelfKind>,\n+                         _: Option<&ast::SelfKind>,\n                          is_closure: bool) -> io::Result<()> {\n-        // It is unfortunate to duplicate the commasep logic, but we want the\n-        // self type and the args all in the same box.\n-        self.rbox(0, Inconsistent)?;\n-        let mut first = true;\n-        if let Some(explicit_self) = opt_explicit_self {\n-            let m = match *explicit_self {\n-                ast::SelfKind::Static => ast::Mutability::Immutable,\n-                _ => match decl.inputs[0].pat.node {\n-                    PatKind::Ident(ast::BindingMode::ByValue(m), _, _) => m,\n-                    _ => ast::Mutability::Immutable\n-                }\n-            };\n-            first = !self.print_explicit_self(explicit_self, m)?;\n-        }\n-\n-        // HACK(eddyb) ignore the separately printed self argument.\n-        let args = if first {\n-            &decl.inputs[..]\n-        } else {\n-            &decl.inputs[1..]\n-        };\n-\n-        for arg in args {\n-            if first { first = false; } else { self.word_space(\",\")?; }\n-            self.print_arg(arg, is_closure)?;\n-        }\n-\n-        self.end()\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, is_closure))\n     }\n \n     pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl,\n@@ -2956,18 +2929,24 @@ impl<'a> State<'a> {\n         match input.ty.node {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n-                match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _)\n-                            if path1.node.name == keywords::Invalid.name() => {\n-                        // Do nothing.\n+                let (mutbl, invalid) = match input.pat.node {\n+                    PatKind::Ident(ast::BindingMode::ByValue(mutbl), ident, _) |\n+                    PatKind::Ident(ast::BindingMode::ByRef(mutbl), ident, _) => {\n+                        (mutbl, ident.node.name == keywords::Invalid.name())\n                     }\n-                    _ => {\n+                    _ => (ast::Mutability::Immutable, false)\n+                };\n+\n+                if let Some(eself) = input.to_self() {\n+                    self.print_explicit_self(&eself.node, mutbl)?;\n+                } else {\n+                    if !invalid {\n                         self.print_pat(&input.pat)?;\n                         word(&mut self.s, \":\")?;\n                         space(&mut self.s)?;\n                     }\n+                    self.print_type(&input.ty)?;\n                 }\n-                self.print_type(&input.ty)?;\n             }\n         }\n         self.end()"}, {"sha": "161edcca5b2838c8eea2448702da73ee9b535e2c", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d5d43524123a45c6a88174fd3c771057faf47/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=212d5d43524123a45c6a88174fd3c771057faf47", "patch": "@@ -864,9 +864,8 @@ impl<'a> MethodDef<'a> {\n         let self_arg = match explicit_self.node {\n             ast::SelfKind::Static => None,\n             // creating fresh self id\n-            _ => Some(ast::Arg::new_self(trait_.span,\n-                                         ast::Mutability::Immutable,\n-                                         keywords::SelfValue.ident()))\n+            _ => Some(ast::Arg::from_self(explicit_self.clone(), trait_.span,\n+                                          ast::Mutability::Immutable)),\n         };\n         let args = {\n             let args = arg_types.into_iter().map(|(name, ty)| {"}, {"sha": "699af8ca7ab4fda5bfce891b768c19f32308d7a3", "filename": "src/test/parse-fail/issue-33413.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/212d5d43524123a45c6a88174fd3c771057faf47/src%2Ftest%2Fparse-fail%2Fissue-33413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d5d43524123a45c6a88174fd3c771057faf47/src%2Ftest%2Fparse-fail%2Fissue-33413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-33413.rs?ref=212d5d43524123a45c6a88174fd3c771057faf47", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+impl S {\n+    fn f(*, a: u8) -> u8 {} //~ ERROR expected pattern, found `*`\n+    //~^ ERROR expected one of `)`, `-`, `box`, `false`, `mut`, `ref`, or `true`, found `*`\n+}"}, {"sha": "22baf88b43f5a2de2e1cc7cc29fc3a476ca64d0f", "filename": "src/test/parse-fail/no-unsafe-self.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/212d5d43524123a45c6a88174fd3c771057faf47/src%2Ftest%2Fparse-fail%2Fno-unsafe-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d5d43524123a45c6a88174fd3c771057faf47/src%2Ftest%2Fparse-fail%2Fno-unsafe-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fno-unsafe-self.rs?ref=212d5d43524123a45c6a88174fd3c771057faf47", "patch": "@@ -11,14 +11,16 @@\n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n trait A {\n-    fn foo(*mut self); //~ ERROR cannot pass self by raw pointer\n-    fn bar(*self); //~ ERROR cannot pass self by raw pointer\n+    fn foo(*mut self); //~ ERROR cannot pass `self` by raw pointer\n+    fn baz(*const self); //~ ERROR cannot pass `self` by raw pointer\n+    fn bar(*self); //~ ERROR cannot pass `self` by raw pointer\n }\n \n struct X;\n impl A for X {\n-    fn foo(*mut self) { } //~ ERROR cannot pass self by raw pointer\n-    fn bar(*self) { } //~ ERROR cannot pass self by raw pointer\n+    fn foo(*mut self) { } //~ ERROR cannot pass `self` by raw pointer\n+    fn baz(*const self) { } //~ ERROR cannot pass `self` by raw pointer\n+    fn bar(*self) { } //~ ERROR cannot pass `self` by raw pointer\n }\n \n fn main() { }"}]}