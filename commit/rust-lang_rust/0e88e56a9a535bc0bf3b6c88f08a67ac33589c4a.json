{"sha": "0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlODhlNTZhOWE1MzViYzBiZjNiNmM4OGYwOGE2N2FjMzM1ODljNGE=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-02T06:06:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-02T06:06:14Z"}, "message": "Rollup merge of #64805 - nnethercote:ObligForest-still-more, r=nikomatsakis\n\nStill more `ObligationForest` improvements.\n\nFollowing on from #64627, more readability improvements, but negligible effects on speed.\n\nr? @nikomatsakis", "tree": {"sha": "56b01a49b018432df365915e0eb8e61387131260", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56b01a49b018432df365915e0eb8e61387131260"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdlD5WCRBK7hj4Ov3rIwAAdHIIAEcPchf0L22y4vjN4j/jPmTG\nrsy5Hw3IvGpyWxXYquq/3r9qJAuVEEO9uXq/cfq47+SfSSmNs6RryaAzPaVmCn4C\nsSGKcSHmFVxy69vgavjkrFM8wttIu/5UefYAM5/hI4ZUMAYZ1oKjNWpjATzDxm4l\nrXS49NNsBjLRqxOuADvfCuAaYQty6/lJvOrntcQfA+eWuJrsTb7apnDnxGno4M+6\nsRDY8+i4gDCJv9aCq+Aj2BmsqiyYmKuCnBhUY2xTNxbzWvH+bCmSH/NeukoY3S/B\ndsj4PvcOWwHTQz4PJ2oO9TnW68UBR8eevySy2MkF734RkMF/8IGsBd2P5IWE9HM=\n=mYVM\n-----END PGP SIGNATURE-----\n", "payload": "tree 56b01a49b018432df365915e0eb8e61387131260\nparent bd9d843ae488e4571186f676d63798f762544c1e\nparent a820672f6c947c5f487d10a011b9b1e65c29f693\nauthor Tyler Mandry <tmandry@gmail.com> 1569996374 -0700\ncommitter GitHub <noreply@github.com> 1569996374 -0700\n\nRollup merge of #64805 - nnethercote:ObligForest-still-more, r=nikomatsakis\n\nStill more `ObligationForest` improvements.\n\nFollowing on from #64627, more readability improvements, but negligible effects on speed.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "html_url": "https://github.com/rust-lang/rust/commit/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd9d843ae488e4571186f676d63798f762544c1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd9d843ae488e4571186f676d63798f762544c1e", "html_url": "https://github.com/rust-lang/rust/commit/bd9d843ae488e4571186f676d63798f762544c1e"}, {"sha": "a820672f6c947c5f487d10a011b9b1e65c29f693", "url": "https://api.github.com/repos/rust-lang/rust/commits/a820672f6c947c5f487d10a011b9b1e65c29f693", "html_url": "https://github.com/rust-lang/rust/commit/a820672f6c947c5f487d10a011b9b1e65c29f693"}], "stats": {"total": 241, "additions": 115, "deletions": 126}, "files": [{"sha": "958ab617cb315b71bf64e505da245d7f8b02f120", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 94, "deletions": 119, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "patch": "@@ -151,9 +151,8 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// comments in `process_obligation` for details.\n     active_cache: FxHashMap<O::Predicate, usize>,\n \n-    /// A scratch vector reused in various operations, to avoid allocating new\n-    /// vectors.\n-    scratch: RefCell<Vec<usize>>,\n+    /// A vector reused in compress(), to avoid allocating new vectors.\n+    node_rewrites: RefCell<Vec<usize>>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n@@ -235,10 +234,6 @@ enum NodeState {\n     /// This obligation was resolved to an error. Error nodes are\n     /// removed from the vector by the compression step.\n     Error,\n-\n-    /// This is a temporary state used in DFS loops to detect cycles,\n-    /// it should not exist outside of these DFSes.\n-    OnDfsStack,\n }\n \n #[derive(Debug)]\n@@ -279,7 +274,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             nodes: vec![],\n             done_cache: Default::default(),\n             active_cache: Default::default(),\n-            scratch: RefCell::new(vec![]),\n+            node_rewrites: RefCell::new(vec![]),\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n@@ -305,9 +300,10 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         match self.active_cache.entry(obligation.as_predicate().clone()) {\n             Entry::Occupied(o) => {\n+                let index = *o.get();\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n-                       obligation, parent, o.get());\n-                let node = &mut self.nodes[*o.get()];\n+                       obligation, parent, index);\n+                let node = &mut self.nodes[index];\n                 if let Some(parent_index) = parent {\n                     // If the node is already in `active_cache`, it has already\n                     // had its chance to be marked with a parent. So if it's\n@@ -342,7 +338,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 if already_failed {\n                     Err(())\n                 } else {\n-                    v.insert(self.nodes.len());\n+                    let new_index = self.nodes.len();\n+                    v.insert(new_index);\n                     self.nodes.push(Node::new(parent, obligation, obligation_tree_id));\n                     Ok(())\n                 }\n@@ -352,15 +349,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     /// Converts all remaining obligations to the given error.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n-        let mut errors = vec![];\n-        for (index, node) in self.nodes.iter().enumerate() {\n-            if let NodeState::Pending = node.state.get() {\n-                errors.push(Error {\n+        let errors = self.nodes.iter().enumerate()\n+            .filter(|(_index, node)| node.state.get() == NodeState::Pending)\n+            .map(|(index, _node)| {\n+                Error {\n                     error: error.clone(),\n                     backtrace: self.error_at(index),\n-                });\n-            }\n-        }\n+                }\n+            })\n+            .collect();\n+\n         let successful_obligations = self.compress(DoCompleted::Yes);\n         assert!(successful_obligations.unwrap().is_empty());\n         errors\n@@ -370,15 +368,14 @@ impl<O: ForestObligation> ObligationForest<O> {\n     pub fn map_pending_obligations<P, F>(&self, f: F) -> Vec<P>\n         where F: Fn(&O) -> P\n     {\n-        self.nodes\n-            .iter()\n-            .filter(|n| n.state.get() == NodeState::Pending)\n-            .map(|n| f(&n.obligation))\n+        self.nodes.iter()\n+            .filter(|node| node.state.get() == NodeState::Pending)\n+            .map(|node| f(&node.obligation))\n             .collect()\n     }\n \n-    fn insert_into_error_cache(&mut self, node_index: usize) {\n-        let node = &self.nodes[node_index];\n+    fn insert_into_error_cache(&mut self, index: usize) {\n+        let node = &self.nodes[index];\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n@@ -408,10 +405,10 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // `self.active_cache`. This means that `self.active_cache` can get\n             // out of sync with `nodes`. It's not very common, but it does\n             // happen, and code in `compress` has to allow for it.\n-            let result = match node.state.get() {\n-                NodeState::Pending => processor.process_obligation(&mut node.obligation),\n-                _ => continue\n-            };\n+            if node.state.get() != NodeState::Pending {\n+                continue;\n+            }\n+            let result = processor.process_obligation(&mut node.obligation);\n \n             debug!(\"process_obligations: node {} got result {:?}\", index, result);\n \n@@ -476,64 +473,53 @@ impl<O: ForestObligation> ObligationForest<O> {\n     fn process_cycles<P>(&self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let mut stack = self.scratch.replace(vec![]);\n-        debug_assert!(stack.is_empty());\n+        let mut stack = vec![];\n \n         debug!(\"process_cycles()\");\n \n         for (index, node) in self.nodes.iter().enumerate() {\n             // For some benchmarks this state test is extremely\n             // hot. It's a win to handle the no-op cases immediately to avoid\n             // the cost of the function call.\n-            match node.state.get() {\n-                // Match arms are in order of frequency. Pending, Success and\n-                // Waiting dominate; the others are rare.\n-                NodeState::Pending => {},\n-                NodeState::Success => self.find_cycles_from_node(&mut stack, processor, index),\n-                NodeState::Waiting | NodeState::Done | NodeState::Error => {},\n-                NodeState::OnDfsStack => self.find_cycles_from_node(&mut stack, processor, index),\n+            if node.state.get() == NodeState::Success {\n+                self.find_cycles_from_node(&mut stack, processor, index);\n             }\n         }\n \n         debug!(\"process_cycles: complete\");\n \n         debug_assert!(stack.is_empty());\n-        self.scratch.replace(stack);\n     }\n \n     fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n         let node = &self.nodes[index];\n-        match node.state.get() {\n-            NodeState::OnDfsStack => {\n-                let rpos = stack.iter().rposition(|&n| n == index).unwrap();\n-                processor.process_backedge(stack[rpos..].iter().map(GetObligation(&self.nodes)),\n-                                           PhantomData);\n-            }\n-            NodeState::Success => {\n-                node.state.set(NodeState::OnDfsStack);\n-                stack.push(index);\n-                for &index in node.dependents.iter() {\n-                    self.find_cycles_from_node(stack, processor, index);\n+        if node.state.get() == NodeState::Success {\n+            match stack.iter().rposition(|&n| n == index) {\n+                None => {\n+                    stack.push(index);\n+                    for &index in node.dependents.iter() {\n+                        self.find_cycles_from_node(stack, processor, index);\n+                    }\n+                    stack.pop();\n+                    node.state.set(NodeState::Done);\n+                }\n+                Some(rpos) => {\n+                    // Cycle detected.\n+                    processor.process_backedge(\n+                        stack[rpos..].iter().map(GetObligation(&self.nodes)),\n+                        PhantomData\n+                    );\n                 }\n-                stack.pop();\n-                node.state.set(NodeState::Done);\n-            },\n-            NodeState::Waiting | NodeState::Pending => {\n-                // This node is still reachable from some pending node. We\n-                // will get to it when they are all processed.\n-            }\n-            NodeState::Done | NodeState::Error => {\n-                // Already processed that node.\n             }\n-        };\n+        }\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n     fn error_at(&self, mut index: usize) -> Vec<O> {\n-        let mut error_stack = self.scratch.replace(vec![]);\n+        let mut error_stack: Vec<usize> = vec![];\n         let mut trace = vec![];\n \n         loop {\n@@ -554,23 +540,32 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         while let Some(index) = error_stack.pop() {\n             let node = &self.nodes[index];\n-            match node.state.get() {\n-                NodeState::Error => continue,\n-                _ => node.state.set(NodeState::Error),\n+            if node.state.get() != NodeState::Error {\n+                node.state.set(NodeState::Error);\n+                error_stack.extend(node.dependents.iter());\n             }\n-\n-            error_stack.extend(node.dependents.iter());\n         }\n \n-        self.scratch.replace(error_stack);\n         trace\n     }\n \n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n         for &index in node.dependents.iter() {\n-            self.mark_as_waiting_from(&self.nodes[index]);\n+            let node = &self.nodes[index];\n+            match node.state.get() {\n+                NodeState::Waiting | NodeState::Error => {}\n+                NodeState::Success => {\n+                    node.state.set(NodeState::Waiting);\n+                    // This call site is cold.\n+                    self.uninlined_mark_neighbors_as_waiting_from(node);\n+                }\n+                NodeState::Pending | NodeState::Done => {\n+                    // This call site is cold.\n+                    self.uninlined_mark_neighbors_as_waiting_from(node);\n+                }\n+            }\n         }\n     }\n \n@@ -596,37 +591,28 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    fn mark_as_waiting_from(&self, node: &Node<O>) {\n-        match node.state.get() {\n-            NodeState::Waiting | NodeState::Error | NodeState::OnDfsStack => return,\n-            NodeState::Success => node.state.set(NodeState::Waiting),\n-            NodeState::Pending | NodeState::Done => {},\n-        }\n-\n-        // This call site is cold.\n-        self.uninlined_mark_neighbors_as_waiting_from(node);\n-    }\n-\n-    /// Compresses the vector, removing all popped nodes. This adjusts\n-    /// the indices and hence invalidates any outstanding\n-    /// indices. Cannot be used during a transaction.\n+    /// Compresses the vector, removing all popped nodes. This adjusts the\n+    /// indices and hence invalidates any outstanding indices.\n     ///\n     /// Beforehand, all nodes must be marked as `Done` and no cycles\n     /// on these nodes may be present. This is done by e.g., `process_cycles`.\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n-        let nodes_len = self.nodes.len();\n-        let mut node_rewrites: Vec<_> = self.scratch.replace(vec![]);\n-        node_rewrites.extend(0..nodes_len);\n+        let orig_nodes_len = self.nodes.len();\n+        let mut node_rewrites: Vec<_> = self.node_rewrites.replace(vec![]);\n+        debug_assert!(node_rewrites.is_empty());\n+        node_rewrites.extend(0..orig_nodes_len);\n         let mut dead_nodes = 0;\n+        let mut removed_done_obligations: Vec<O> = vec![];\n \n-        // Now move all popped nodes to the end. Try to keep the order.\n+        // Now move all Done/Error nodes to the end, preserving the order of\n+        // the Pending/Waiting nodes.\n         //\n         // LOOP INVARIANT:\n         //     self.nodes[0..index - dead_nodes] are the first remaining nodes\n         //     self.nodes[index - dead_nodes..index] are all dead\n         //     self.nodes[index..] are unchanged\n-        for index in 0..self.nodes.len() {\n+        for index in 0..orig_nodes_len {\n             let node = &self.nodes[index];\n             match node.state.get() {\n                 NodeState::Pending | NodeState::Waiting => {\n@@ -637,7 +623,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n                 NodeState::Done => {\n                     // This lookup can fail because the contents of\n-                    // `self.active_cache` is not guaranteed to match those of\n+                    // `self.active_cache` are not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n                     // for more details.\n                     if let Some((predicate, _)) =\n@@ -647,61 +633,50 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     } else {\n                         self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n-                    node_rewrites[index] = nodes_len;\n+                    if do_completed == DoCompleted::Yes {\n+                        // Extract the success stories.\n+                        removed_done_obligations.push(node.obligation.clone());\n+                    }\n+                    node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n                 }\n                 NodeState::Error => {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n                     self.active_cache.remove(node.obligation.as_predicate());\n-                    node_rewrites[index] = nodes_len;\n-                    dead_nodes += 1;\n                     self.insert_into_error_cache(index);\n+                    node_rewrites[index] = orig_nodes_len;\n+                    dead_nodes += 1;\n                 }\n-                NodeState::OnDfsStack | NodeState::Success => unreachable!()\n+                NodeState::Success => unreachable!()\n             }\n         }\n \n-        // No compression needed.\n-        if dead_nodes == 0 {\n-            node_rewrites.truncate(0);\n-            self.scratch.replace(node_rewrites);\n-            return if do_completed == DoCompleted::Yes { Some(vec![]) } else { None };\n+        if dead_nodes > 0 {\n+            // Remove the dead nodes and rewrite indices.\n+            self.nodes.truncate(orig_nodes_len - dead_nodes);\n+            self.apply_rewrites(&node_rewrites);\n         }\n \n-        // Pop off all the nodes we killed and extract the success stories.\n-        let successful = if do_completed == DoCompleted::Yes {\n-            Some((0..dead_nodes)\n-                .map(|_| self.nodes.pop().unwrap())\n-                .flat_map(|node| {\n-                    match node.state.get() {\n-                        NodeState::Error => None,\n-                        NodeState::Done => Some(node.obligation),\n-                        _ => unreachable!()\n-                    }\n-                })\n-                .collect())\n-        } else {\n-            self.nodes.truncate(self.nodes.len() - dead_nodes);\n-            None\n-        };\n-        self.apply_rewrites(&node_rewrites);\n-\n         node_rewrites.truncate(0);\n-        self.scratch.replace(node_rewrites);\n+        self.node_rewrites.replace(node_rewrites);\n \n-        successful\n+        if do_completed == DoCompleted::Yes {\n+            Some(removed_done_obligations)\n+        } else {\n+            None\n+        }\n     }\n \n     fn apply_rewrites(&mut self, node_rewrites: &[usize]) {\n-        let nodes_len = node_rewrites.len();\n+        let orig_nodes_len = node_rewrites.len();\n \n         for node in &mut self.nodes {\n             let mut i = 0;\n             while i < node.dependents.len() {\n                 let new_index = node_rewrites[node.dependents[i]];\n-                if new_index >= nodes_len {\n+                if new_index >= orig_nodes_len {\n                     node.dependents.swap_remove(i);\n                     if i == 0 && node.has_parent {\n                         // We just removed the parent.\n@@ -718,7 +693,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // removal of nodes within `compress` can fail. See above.\n         self.active_cache.retain(|_predicate, index| {\n             let new_index = node_rewrites[*index];\n-            if new_index >= nodes_len {\n+            if new_index >= orig_nodes_len {\n                 false\n             } else {\n                 *index = new_index;"}, {"sha": "54b6f6d0adc6cd2a1b01400263e075faeef6347a", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "patch": "@@ -116,7 +116,9 @@ fn push_pop() {\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"A.3\", \"A.1\", \"A.3.i\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A.1\", \"A.3\", \"A.3.i\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"A is for apple\",\n@@ -132,7 +134,9 @@ fn push_pop() {\n                 _ => panic!(\"unexpected obligation {:?}\", obligation),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"D.2.i\", \"D.2\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"D.2\", \"D.2.i\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"D is for dumb\",\n@@ -172,7 +176,9 @@ fn success_in_grandchildren() {\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"A.3\", \"A.1\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A.1\", \"A.3\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -193,7 +199,9 @@ fn success_in_grandchildren() {\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A\", \"A.2\", \"A.2.i\", \"A.2.i.a\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -261,7 +269,9 @@ fn diamond() {\n             }\n         }, |_|{}), DoCompleted::Yes);\n     assert_eq!(d_count, 1);\n-    assert_eq!(ok.unwrap(), vec![\"D\", \"A.2\", \"A.1\", \"A\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A\", \"A.1\", \"A.2\", \"D\"]);\n     assert_eq!(err.len(), 0);\n \n     let errors = forest.to_errors(());\n@@ -323,7 +333,9 @@ fn done_dependency() {\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"C: Sized\", \"B: Sized\", \"A: Sized\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"]);\n     assert_eq!(err.len(), 0);\n \n     forest.register_obligation(\"(A,B,C): Sized\");\n@@ -361,7 +373,9 @@ fn orphan() {\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"C2\", \"C1\"]);\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"C1\", \"C2\"]);\n     assert_eq!(err.len(), 0);\n \n     let Outcome { completed: ok, errors: err, .. } ="}]}