{"sha": "699da394ccd44de318da444bae28e472882ca830", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OWRhMzk0Y2NkNDRkZTMxOGRhNDQ0YmFlMjhlNDcyODgyY2E4MzA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-07-03T14:52:37Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-07-03T14:52:37Z"}, "message": "Validate simd and atomic intrinsic types", "tree": {"sha": "8a6ff8b95df2fb2cbfbd50584c84f70191394bf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a6ff8b95df2fb2cbfbd50584c84f70191394bf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/699da394ccd44de318da444bae28e472882ca830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/699da394ccd44de318da444bae28e472882ca830", "html_url": "https://github.com/rust-lang/rust/commit/699da394ccd44de318da444bae28e472882ca830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/699da394ccd44de318da444bae28e472882ca830/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d639cd778bb11fed2c230d8071664e24d30a84f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d639cd778bb11fed2c230d8071664e24d30a84f", "html_url": "https://github.com/rust-lang/rust/commit/8d639cd778bb11fed2c230d8071664e24d30a84f"}], "stats": {"total": 98, "additions": 87, "deletions": 11}, "files": [{"sha": "5fb47729c1108e62c065e0792278212a40f0ec15", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/699da394ccd44de318da444bae28e472882ca830/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699da394ccd44de318da444bae28e472882ca830/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=699da394ccd44de318da444bae28e472882ca830", "patch": "@@ -138,6 +138,27 @@ macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $\n     crate::atomic_shim::unlock_global_lock($fx);\n }\n \n+macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n+    match $ty.kind {\n+        ty::Uint(_) | ty::Int(_) => {}\n+        _ => {\n+            $fx.tcx.sess.span_err($span, &format!(\"`{}` intrinsic: expected basic integer type, found `{:?}`\", $intrinsic, $ty));\n+            // Prevent verifier error\n+            crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n+            return;\n+        }\n+    }\n+}\n+\n+macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n+    if !$ty.is_simd() {\n+        $fx.tcx.sess.span_err($span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", $intrinsic, $ty));\n+        // Prevent verifier error\n+        crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n+        return;\n+    }\n+}\n+\n fn lane_type_and_count<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     layout: TyAndLayout<'tcx>,\n@@ -866,12 +887,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n+            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n             let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n             ret.write_cvalue(fx, val);\n \n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n+            validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n@@ -880,6 +904,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             // Read old\n@@ -893,7 +919,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, v test_old, v new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n+            let test_old = test_old.load_scalar(fx);\n+            let new = new.load_scalar(fx);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             // Read old\n@@ -913,16 +944,26 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, v amount) {\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let amount = amount.load_scalar(fx);\n             atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, v amount) {\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let amount = amount.load_scalar(fx);\n             atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n+            let src = src.load_scalar(fx);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             let clif_ty = fx.clif_type(T).unwrap();\n@@ -934,23 +975,35 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n         };\n "}, {"sha": "32f561bdd3631e4988f185435d0fe2ee875a89c6", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/699da394ccd44de318da444bae28e472882ca830/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699da394ccd44de318da444bae28e472882ca830/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=699da394ccd44de318da444bae28e472882ca830", "patch": "@@ -21,6 +21,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_cast, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n             simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n                 let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n \n@@ -33,26 +34,34 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_eq, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, Equal(x, y) -> ret);\n         };\n         simd_ne, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, NotEqual(x, y) -> ret);\n         };\n         simd_lt, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedLessThan|SignedLessThan(x, y) -> ret);\n         };\n         simd_le, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedLessThanOrEqual|SignedLessThanOrEqual(x, y) -> ret);\n         };\n         simd_gt, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedGreaterThan|SignedGreaterThan(x, y) -> ret);\n         };\n         simd_ge, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual(x, y) -> ret);\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n         _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+\n             let n: u16 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n \n             assert_eq!(x.layout(), y.layout());\n@@ -105,6 +114,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_insert, (c base, o idx, v _val) {\n+            // FIXME validate\n             let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n                 idx_const\n             } else {\n@@ -132,6 +142,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_extract, (c v, o idx) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n             let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n                 idx_const\n             } else {\n@@ -155,34 +166,44 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_add, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, iadd|fadd(x, y) -> ret);\n         };\n         simd_sub, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, isub|fsub(x, y) -> ret);\n         };\n         simd_mul, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, imul|fmul(x, y) -> ret);\n         };\n         simd_div, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, udiv|sdiv|fdiv(x, y) -> ret);\n         };\n         simd_shl, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, ishl(x, y) -> ret);\n         };\n         simd_shr, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, ushr|sshr(x, y) -> ret);\n         };\n         simd_and, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, band(x, y) -> ret);\n         };\n         simd_or, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, bor(x, y) -> ret);\n         };\n         simd_xor, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, bxor(x, y) -> ret);\n         };\n \n         simd_fma, (c a, c b, c c) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n             assert_eq!(a.layout(), b.layout());\n             assert_eq!(a.layout(), c.layout());\n             let layout = a.layout();\n@@ -205,9 +226,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_fmin, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_flt_binop!(fx, fmin(x, y) -> ret);\n         };\n         simd_fmax, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_flt_binop!(fx, fmax(x, y) -> ret);\n         };\n     }"}]}