{"sha": "3f2de03daa410e963cfa8d2cff46a7766ec972d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMmRlMDNkYWE0MTBlOTYzY2ZhOGQyY2ZmNDZhNzc2NmVjOTcyZDM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-07T05:47:07Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-07T07:26:37Z"}, "message": "Rollup merge of #53455 - llogiq:num-byte-conversion-docs, r=steveklabnik\n\nIndividual docs for {from,to}_*_bytes", "tree": {"sha": "58a3a6ce7c0f0fd7d0bfa18046a0ac657d59e0ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a3a6ce7c0f0fd7d0bfa18046a0ac657d59e0ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f2de03daa410e963cfa8d2cff46a7766ec972d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAluSKC0ACgkQ/vbIBR0O\nATwEFw//ayVfuVwPIjldZG9hrSKIuyQqF5XhLKHS3e6+2FUt3wdXAAWzXTEx9Ofs\nMJ8i15N00XqUysDE6/+sK1L88MUhQrFQW5ZqZ6Ruwnyz3PgZyITYxEvppMcQ/ANe\n1rc8G5or+9deydi4qrorh88kaLQB/OuQ2+ISxlvApJ2mljRcX2o6QnW7T5fPQG7c\nz4H3Ci+kc6W6z4YZ6dqnWPZQP9QqAXx3qUxG8vFQ8nVkE1ChLZeFcInjJgrYj+lJ\n9la3ewQt3se/VZS+SEBUrXXvUa7jYOuSKVRbOeVnas+SJIxpwB4itC20KLF+lAQJ\nrCfKt6IuLeDak8rVGtwh7AngGrKvgjX+zT+N4Mq9+c9dx8LLbdkt959f7UoPwORP\noqm6HVXWjCaGJ3i5Vi+wkKqYbtO6lslMgsQzeapawDj8pXxEL3U0NN4qjYPNDoob\n8ijtw/mzVxl9ZKpYpuyBsc/j0aWMDI1pjunhJraVbQ/ORlGuegyZd2DU8sxML+ds\nOdfzk7DglVlV9F06KT4XxwFVoRijNGFggI2pyBcK07xe9RHw0Jarav/1yFmJmNC9\nbOf6I84e1UezGKdNzh+MO/snLMFrkvZC0A9nMhSAct1WA0epai291qQzOZYmaVa9\nJHo3j4sc70nrw1XF087xKKGdXHHYKbY8o56/gAT2EnIOVZK1LbE=\n=8deK\n-----END PGP SIGNATURE-----", "payload": "tree 58a3a6ce7c0f0fd7d0bfa18046a0ac657d59e0ca\nparent 654c5788aa2130acfc89a0883952c6de4bddac95\nparent 90b7c5acbca4e19272b545c01d98bca39a74b26c\nauthor kennytm <kennytm@gmail.com> 1536299227 +0800\ncommitter kennytm <kennytm@gmail.com> 1536305197 +0800\n\nRollup merge of #53455 - llogiq:num-byte-conversion-docs, r=steveklabnik\n\nIndividual docs for {from,to}_*_bytes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f2de03daa410e963cfa8d2cff46a7766ec972d3", "html_url": "https://github.com/rust-lang/rust/commit/3f2de03daa410e963cfa8d2cff46a7766ec972d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f2de03daa410e963cfa8d2cff46a7766ec972d3/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "654c5788aa2130acfc89a0883952c6de4bddac95", "url": "https://api.github.com/repos/rust-lang/rust/commits/654c5788aa2130acfc89a0883952c6de4bddac95", "html_url": "https://github.com/rust-lang/rust/commit/654c5788aa2130acfc89a0883952c6de4bddac95"}, {"sha": "90b7c5acbca4e19272b545c01d98bca39a74b26c", "url": "https://api.github.com/repos/rust-lang/rust/commits/90b7c5acbca4e19272b545c01d98bca39a74b26c", "html_url": "https://github.com/rust-lang/rust/commit/90b7c5acbca4e19272b545c01d98bca39a74b26c"}], "stats": {"total": 565, "additions": 314, "deletions": 251}, "files": [{"sha": "5ae984a4b155b11f25ce5e6577db92ef119983cf", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 314, "deletions": 251, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/3f2de03daa410e963cfa8d2cff46a7766ec972d3/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2de03daa410e963cfa8d2cff46a7766ec972d3/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=3f2de03daa410e963cfa8d2cff46a7766ec972d3", "patch": "@@ -192,7 +192,7 @@ mod wrapping;\n macro_rules! int_impl {\n     ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n      $EndFeature:expr, $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-     $reversed:expr) => {\n+     $reversed:expr, $le_bytes:expr, $be_bytes:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -2063,23 +2063,25 @@ $EndFeature, \"\n             self.to_be().to_ne_bytes()\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// big-endian (network) byte order.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let bytes = 0x12_34_56_78_i32.to_be_bytes();\n-        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-            self.to_be().to_ne_bytes()\n+        doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+big-endian (network) byte order.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\n+assert_eq!(bytes, \", $be_bytes, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_be().to_ne_bytes()\n+            }\n         }\n \n         /// no docs here\n@@ -2090,23 +2092,25 @@ $EndFeature, \"\n             self.to_le().to_ne_bytes()\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// little-endian byte order.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let bytes =  0x12_34_56_78_i32.to_le_bytes();\n-        /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-            self.to_le().to_ne_bytes()\n+doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+little-endian byte order.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\n+assert_eq!(bytes, \", $le_bytes, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_le().to_ne_bytes()\n+            }\n         }\n \n         /// no docs here\n@@ -2117,30 +2121,37 @@ $EndFeature, \"\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// native byte order.\n-        ///\n-        /// As the target platform's native endianness is used, portable code\n-        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n-        /// instead.\n-        ///\n-        /// [`to_be_bytes`]: #method.to_be_bytes\n-        /// [`to_le_bytes`]: #method.to_le_bytes\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let bytes = i32::min_value().to_be().to_ne_bytes();\n-        /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-            unsafe { mem::transmute(self) }\n+        doc_comment! {\n+            concat!(\"\n+Return the memory representation of this integer as a byte array in\n+native byte order.\n+\n+As the target platform's native endianness is used, portable code\n+should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+instead.\n+\n+[`to_be_bytes`]: #method.to_be_bytes\n+[`to_le_bytes`]: #method.to_le_bytes\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n+assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n+        \", $be_bytes, \"\n+    } else {\n+        \", $le_bytes, \"\n+    });\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                unsafe { mem::transmute(self) }\n+            }\n         }\n \n         /// no docs here\n@@ -2151,23 +2162,25 @@ $EndFeature, \"\n             Self::from_be(Self::from_ne_bytes(bytes))\n         }\n \n-        /// Create an integer value from its representation as a byte array in\n-        /// big endian.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let int = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n-        /// assert_eq!(int, 0x12_34_56_78);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-            Self::from_be(Self::from_ne_bytes(bytes))\n+doc_comment! {\n+            concat!(\"Create an integer value from its representation as a byte array in\n+big endian.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_be(Self::from_ne_bytes(bytes))\n+            }\n         }\n \n         /// no docs here\n@@ -2178,23 +2191,26 @@ $EndFeature, \"\n             Self::from_le(Self::from_ne_bytes(bytes))\n         }\n \n-        /// Create an integer value from its representation as a byte array in\n-        /// little endian.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let int = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n-        /// assert_eq!(int, 0x78_56_34_12);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-            Self::from_le(Self::from_ne_bytes(bytes))\n+doc_comment! {\n+            concat!(\"\n+Create an integer value from its representation as a byte array in\n+little endian.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_le(Self::from_ne_bytes(bytes))\n+            }\n         }\n \n         /// no docs here\n@@ -2205,87 +2221,101 @@ $EndFeature, \"\n             unsafe { mem::transmute(bytes) }\n         }\n \n-        /// Create an integer value from its memory representation as a byte\n-        /// array in native endianness.\n-        ///\n-        /// As the target platform's native endianness is used, portable code\n-        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n-        /// appropriate instead.\n-        ///\n-        /// [`from_be_bytes`]: #method.from_be_bytes\n-        /// [`from_le_bytes`]: #method.from_le_bytes\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let int = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n-        /// assert_eq!(int, i32::min_value());\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-            unsafe { mem::transmute(bytes) }\n+        doc_comment! {\n+            concat!(\"Create an integer value from its memory representation as a byte\n+array in native endianness.\n+\n+As the target platform's native endianness is used, portable code\n+likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+appropriate instead.\n+\n+[`from_be_bytes`]: #method.from_be_bytes\n+[`from_le_bytes`]: #method.from_le_bytes\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n+        \", $be_bytes, \"\n+    } else {\n+        \", $le_bytes, \"\n+    });\n+assert_eq!(value, \", $swap_op, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                unsafe { mem::transmute(bytes) }\n+            }\n         }\n     }\n }\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\", 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\" }\n+    int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\", 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n+        \"[0x12]\", \"[0x12]\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n     int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n-        \"0x2c48\" }\n+        \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n     int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n-        \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\" }\n+        \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n+        \"[0x12, 0x34, 0x56, 0x78]\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n     int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\", 12,\n          \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n-         \"0x6a2c48091e6a2c48\" }\n+         \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n         170141183460469231731687303715884105727, \"\", \"\", 16,\n         \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\"\n-    }\n+        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+        \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n-        \"0x3412\", \"0x2c48\" }\n+        \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n-        \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\" }\n+        \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n+        \"[0x12, 0x34, 0x56, 0x78]\" }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n     int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\",\n         12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n-         \"0x6a2c48091e6a2c48\" }\n+         \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n }\n \n // Emits the correct `cttz` call, depending on the size of the type.\n@@ -2305,7 +2335,7 @@ macro_rules! uint_cttz_call {\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n         $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-        $reversed:expr ) => {\n+        $reversed:expr, $le_bytes:expr, $be_bytes:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -3960,23 +3990,25 @@ $EndFeature, \"\n             self.to_be().to_ne_bytes()\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// big-endian (network) byte order.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let bytes =  0x12_34_56_78_i32.to_be_bytes();\n-        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-            self.to_be().to_ne_bytes()\n+                doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+big-endian (network) byte order.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\n+assert_eq!(bytes, \", $be_bytes, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_be().to_ne_bytes()\n+            }\n         }\n \n         /// no docs here\n@@ -3987,23 +4019,25 @@ $EndFeature, \"\n             self.to_le().to_ne_bytes()\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// little-endian byte order.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let bytes =  0x12_34_56_78_i32.to_le_bytes();\n-        /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-            self.to_le().to_ne_bytes()\n+        doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+little-endian byte order.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\n+assert_eq!(bytes, \", $le_bytes, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_le().to_ne_bytes()\n+            }\n         }\n \n         /// no docs here\n@@ -4014,30 +4048,37 @@ $EndFeature, \"\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// native byte order.\n-        ///\n-        /// As the target platform's native endianness is used, portable code\n-        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n-        /// instead.\n-        ///\n-        /// [`to_be_bytes`]: #method.to_be_bytes\n-        /// [`to_le_bytes`]: #method.to_le_bytes\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let bytes = i32::min_value().to_be().to_ne_bytes();\n-        /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-            unsafe { mem::transmute(self) }\n+        doc_comment! {\n+            concat!(\"\n+Return the memory representation of this integer as a byte array in\n+native byte order.\n+\n+As the target platform's native endianness is used, portable code\n+should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+instead.\n+\n+[`to_be_bytes`]: #method.to_be_bytes\n+[`to_le_bytes`]: #method.to_le_bytes\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n+assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n+        \", $be_bytes, \"\n+    } else {\n+        \", $le_bytes, \"\n+    });\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                unsafe { mem::transmute(self) }\n+            }\n         }\n \n         /// no docs here\n@@ -4048,23 +4089,25 @@ $EndFeature, \"\n             Self::from_be(Self::from_ne_bytes(bytes))\n         }\n \n-        /// Create an integer value from its representation as a byte array in\n-        /// big endian.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let int = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n-        /// assert_eq!(int, 0x12_34_56_78);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-            Self::from_be(Self::from_ne_bytes(bytes))\n+        doc_comment! {\n+            concat!(\"Create an integer value from its representation as a byte array in\n+big endian.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_be(Self::from_ne_bytes(bytes))\n+            }\n         }\n \n         /// no docs here\n@@ -4075,23 +4118,26 @@ $EndFeature, \"\n             Self::from_le(Self::from_ne_bytes(bytes))\n         }\n \n-        /// Create an integer value from its representation as a byte array in\n-        /// little endian.\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let int = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n-        /// assert_eq!(int, 0x78_56_34_12);\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-            Self::from_le(Self::from_ne_bytes(bytes))\n+        doc_comment! {\n+            concat!(\"\n+Create an integer value from its representation as a byte array in\n+little endian.\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_le(Self::from_ne_bytes(bytes))\n+            }\n         }\n \n         /// no docs here\n@@ -4102,37 +4148,44 @@ $EndFeature, \"\n             unsafe { mem::transmute(bytes) }\n         }\n \n-        /// Create an integer value from its memory representation as a byte\n-        /// array in native endianness.\n-        ///\n-        /// As the target platform's native endianness is used, portable code\n-        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n-        /// appropriate instead.\n-        ///\n-        /// [`from_be_bytes`]: #method.from_be_bytes\n-        /// [`from_le_bytes`]: #method.from_le_bytes\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(int_to_from_bytes)]\n-        ///\n-        /// let int = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n-        /// assert_eq!(int, i32::min_value());\n-        /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n-        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n-        #[inline]\n-        #[cfg(not(stage0))]\n-        pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-            unsafe { mem::transmute(bytes) }\n+        doc_comment! {\n+            concat!(\"Create an integer value from its memory representation as a byte\n+array in native endianness.\n+\n+As the target platform's native endianness is used, portable code\n+likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+appropriate instead.\n+\n+[`from_be_bytes`]: #method.from_be_bytes\n+[`from_le_bytes`]: #method.from_le_bytes\n+\n+# Examples\n+\n+```\n+#![feature(int_to_from_bytes)]\n+\n+let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n+        \", $be_bytes, \"\n+    } else {\n+        \", $le_bytes, \"\n+    });\n+assert_eq!(value, \", $swap_op, \");\n+```\"),\n+            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                unsafe { mem::transmute(bytes) }\n+            }\n         }\n     }\n }\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, u8, 8, 255, \"\", \"\", 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\" }\n+    uint_impl! { u8, u8, 8, 255, \"\", \"\", 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n+        \"[0x12]\" }\n \n \n     /// Checks if the value is within the ASCII range.\n@@ -4658,45 +4711,55 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\" }\n+    uint_impl! { u16, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+        \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n     uint_impl! { u32, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-        \"0x78563412\", \"0x1e6a2c48\" }\n+        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n     uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-        \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\" }\n+        \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n+        \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n }\n \n #[lang = \"u128\"]\n impl u128 {\n     uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\", 16,\n         \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\" }\n+        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+        \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u16, 16, 65536, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\" }\n+    uint_impl! { usize, u16, 16, 65536, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+        \"[0x34, 0x12]\", \"[0x12, 0x34]\" }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n     uint_impl! { usize, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-        \"0x78563412\", \"0x1e6a2c48\" }\n+        \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\" }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n     uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-        \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\" }\n+        \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n+        \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n }\n \n /// A classification of floating point numbers."}]}