{"sha": "8bb4b5f44c8b7c811e2075022e5205f927287e0a", "node_id": "C_kwDOAAsO6NoAKDhiYjRiNWY0NGM4YjdjODExZTIwNzUwMjJlNTIwNWY5MjcyODdlMGE", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2022-03-12T18:32:41Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2022-08-26T12:16:53Z"}, "message": "Support parsing IP addresses from a byte string", "tree": {"sha": "ef4117506f5cea3746bb9b410babdc4553eaf8a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef4117506f5cea3746bb9b410babdc4553eaf8a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb4b5f44c8b7c811e2075022e5205f927287e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb4b5f44c8b7c811e2075022e5205f927287e0a", "html_url": "https://github.com/rust-lang/rust/commit/8bb4b5f44c8b7c811e2075022e5205f927287e0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb4b5f44c8b7c811e2075022e5205f927287e0a/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "983f4daddf238d114c4adc4751c5528fc6695a5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/983f4daddf238d114c4adc4751c5528fc6695a5a", "html_url": "https://github.com/rust-lang/rust/commit/983f4daddf238d114c4adc4751c5528fc6695a5a"}], "stats": {"total": 138, "additions": 125, "deletions": 13}, "files": [{"sha": "a38031c48c86251d2c9c0b3e05246de82e3adc10", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 125, "deletions": 13, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8bb4b5f44c8b7c811e2075022e5205f927287e0a/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb4b5f44c8b7c811e2075022e5205f927287e0a/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=8bb4b5f44c8b7c811e2075022e5205f927287e0a", "patch": "@@ -39,8 +39,8 @@ struct Parser<'a> {\n }\n \n impl<'a> Parser<'a> {\n-    fn new(input: &'a str) -> Parser<'a> {\n-        Parser { state: input.as_bytes() }\n+    fn new(input: &'a [u8]) -> Parser<'a> {\n+        Parser { state: input }\n     }\n \n     /// Run a parser, and restore the pre-parse state if it fails.\n@@ -273,56 +273,168 @@ impl<'a> Parser<'a> {\n     }\n }\n \n+impl IpAddr {\n+    /// Parse an IP address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n+    /// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    ///\n+    /// assert_eq!(IpAddr::parse_ascii(b\"127.0.0.1\"), Ok(localhost_v4));\n+    /// assert_eq!(IpAddr::parse_ascii(b\"::1\"), Ok(localhost_v6));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_ip_addr(), AddrKind::Ip)\n+    }\n+}\n+\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ip_addr(), AddrKind::Ip)\n+        Self::parse_ascii(s.as_bytes())\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromStr for Ipv4Addr {\n-    type Err = AddrParseError;\n-    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n+impl Ipv4Addr {\n+    /// Parse an IPv4 address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n+    ///\n+    /// assert_eq!(Ipv4Addr::parse_ascii(b\"127.0.0.1\"), Ok(localhost));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n         // don't try to parse if too long\n-        if s.len() > 15 {\n+        if b.len() > 15 {\n             Err(AddrParseError(AddrKind::Ipv4))\n         } else {\n-            Parser::new(s).parse_with(|p| p.read_ipv4_addr(), AddrKind::Ipv4)\n+            Parser::new(b).parse_with(|p| p.read_ipv4_addr(), AddrKind::Ipv4)\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl FromStr for Ipv4Addr {\n+    type Err = AddrParseError;\n+    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl Ipv6Addr {\n+    /// Parse an IPv6 address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+    ///\n+    /// assert_eq!(Ipv6Addr::parse_ascii(b\"::1\"), Ok(localhost));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_ipv6_addr(), AddrKind::Ipv6)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv6Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ipv6_addr(), AddrKind::Ipv6)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddrV4 {\n+    /// Parse an IPv4 socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{Ipv4Addr, SocketAddrV4};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    ///\n+    /// assert_eq!(SocketAddrV4::parse_ascii(b\"127.0.0.1:8080\"), Ok(socket));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr_v4(), AddrKind::SocketV4)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV4 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v4(), AddrKind::SocketV4)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddrV6 {\n+    /// Parse an IPv6 socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{Ipv6Addr, SocketAddrV6};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    ///\n+    /// assert_eq!(SocketAddrV6::parse_ascii(b\"[2001:db8::1]:8080\"), Ok(socket));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr_v6(), AddrKind::SocketV6)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV6 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v6(), AddrKind::SocketV6)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddr {\n+    /// Parse a socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};\n+    ///\n+    /// let socket_v4 = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// let socket_v6 = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), 8080);\n+    ///\n+    /// assert_eq!(SocketAddr::parse_ascii(b\"127.0.0.1:8080\"), Ok(socket_v4));\n+    /// assert_eq!(SocketAddr::parse_ascii(b\"[::1]:8080\"), Ok(socket_v6));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr(), AddrKind::Socket)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for SocketAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr(), AddrKind::Socket)\n+        Self::parse_ascii(s.as_bytes())\n     }\n }\n "}]}