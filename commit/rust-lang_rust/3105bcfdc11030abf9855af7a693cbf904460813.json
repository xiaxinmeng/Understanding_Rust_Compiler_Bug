{"sha": "3105bcfdc11030abf9855af7a693cbf904460813", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMDViY2ZkYzExMDMwYWJmOTg1NWFmN2E2OTNjYmY5MDQ0NjA4MTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T23:16:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T23:16:43Z"}, "message": "librustc: De-export driver. rs=deexport", "tree": {"sha": "67b26cb94aa2ed863145b2c4737c69d9b2066f04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b26cb94aa2ed863145b2c4737c69d9b2066f04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3105bcfdc11030abf9855af7a693cbf904460813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3105bcfdc11030abf9855af7a693cbf904460813", "html_url": "https://github.com/rust-lang/rust/commit/3105bcfdc11030abf9855af7a693cbf904460813", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3105bcfdc11030abf9855af7a693cbf904460813/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b07059056463272788042a263b6cf8eb8be2533a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b07059056463272788042a263b6cf8eb8be2533a", "html_url": "https://github.com/rust-lang/rust/commit/b07059056463272788042a263b6cf8eb8be2533a"}], "stats": {"total": 463, "additions": 221, "deletions": 242}, "files": [{"sha": "f5ae2628b0268c9be862f59f5205f4f0b53a2f28", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3105bcfdc11030abf9855af7a693cbf904460813", "patch": "@@ -94,8 +94,6 @@ pub fn WriteOutputFile(sess: Session,\n }\n \n pub mod jit {\n-    #[legacy_exports];\n-\n     use back::link::llvm_err;\n     use lib::llvm::llvm;\n     use lib::llvm::{ModuleRef, PassManagerRef, mk_target_data};\n@@ -109,21 +107,20 @@ pub mod jit {\n \n     #[nolink]\n     #[abi = \"rust-intrinsic\"]\n-    extern mod rusti {\n-        #[legacy_exports];\n-        fn morestack_addr() -> *();\n+    pub extern mod rusti {\n+        pub fn morestack_addr() -> *();\n     }\n \n-    struct Closure {\n+    pub struct Closure {\n         code: *(),\n         env: *(),\n     }\n \n-    fn exec(sess: Session,\n-            pm: PassManagerRef,\n-            m: ModuleRef,\n-            opt: c_int,\n-            stacks: bool) {\n+    pub fn exec(sess: Session,\n+                pm: PassManagerRef,\n+                m: ModuleRef,\n+                opt: c_int,\n+                stacks: bool) {\n         unsafe {\n             let manager = llvm::LLVMRustPrepareJIT(rusti::morestack_addr());\n \n@@ -174,8 +171,6 @@ pub mod jit {\n }\n \n mod write {\n-    #[legacy_exports];\n-\n     use back::link::jit;\n     use back::link::{ModuleRef, WriteOutputFile, output_type};\n     use back::link::{output_type_assembly, output_type_bitcode};\n@@ -193,15 +188,15 @@ mod write {\n     use core::str;\n     use core::vec;\n \n-    fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n+    pub fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n         if ot == output_type_assembly || ot == output_type_object ||\n                ot == output_type_exe {\n             return true;\n         }\n         return false;\n     }\n \n-    fn run_passes(sess: Session, llmod: ModuleRef, output: &Path) {\n+    pub fn run_passes(sess: Session, llmod: ModuleRef, output: &Path) {\n         unsafe {\n             let opts = sess.opts;\n             if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }"}, {"sha": "9308b89a7b10d696419b770beaa17e955f5cd1aa", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=3105bcfdc11030abf9855af7a693cbf904460813", "patch": "@@ -208,8 +208,6 @@ fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n \n #[cfg(unix)]\n mod test {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use back::rpath::{get_absolute_rpath, get_install_prefix_rpath};\n@@ -221,14 +219,14 @@ mod test {\n     use core::str;\n \n     #[test]\n-    fn test_rpaths_to_flags() {\n+    pub fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags(~[Path(\"path1\"),\n                                       Path(\"path2\")]);\n         assert flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"];\n     }\n \n     #[test]\n-    fn test_prefix_rpath() {\n+    pub fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(\"triple\");\n         let d = Path(env!(\"CFG_PREFIX\"))\n             .push_rel(&Path(\"lib/rustc/triple/lib\"));\n@@ -239,21 +237,21 @@ mod test {\n     }\n \n     #[test]\n-    fn test_prefix_rpath_abs() {\n+    pub fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n         assert res.is_absolute;\n     }\n \n     #[test]\n-    fn test_minimize1() {\n+    pub fn test_minimize1() {\n         let res = minimize_rpaths([Path(\"rpath1\"),\n                                    Path(\"rpath2\"),\n                                    Path(\"rpath1\")]);\n         assert res == ~[Path(\"rpath1\"), Path(\"rpath2\")];\n     }\n \n     #[test]\n-    fn test_minimize2() {\n+    pub fn test_minimize2() {\n         let res = minimize_rpaths(~[Path(\"1a\"), Path(\"2\"), Path(\"2\"),\n                                     Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n                                     Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n@@ -262,63 +260,63 @@ mod test {\n     }\n \n     #[test]\n-    fn test_relative_to1() {\n+    pub fn test_relative_to1() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert res == Path(\"../lib\");\n     }\n \n     #[test]\n-    fn test_relative_to2() {\n+    pub fn test_relative_to2() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/bin/../lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert res == Path(\"../lib\");\n     }\n \n     #[test]\n-    fn test_relative_to3() {\n+    pub fn test_relative_to3() {\n         let p1 = Path(\"/usr/bin/whatever/rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert res == Path(\"../../lib/whatever\");\n     }\n \n     #[test]\n-    fn test_relative_to4() {\n+    pub fn test_relative_to4() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert res == Path(\"../lib/whatever\");\n     }\n \n     #[test]\n-    fn test_relative_to5() {\n+    pub fn test_relative_to5() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/../mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert res == Path(\"../lib\");\n     }\n \n     #[test]\n-    fn test_relative_to6() {\n+    pub fn test_relative_to6() {\n         let p1 = Path(\"/1\");\n         let p2 = Path(\"/2/3\");\n         let res = get_relative_to(&p1, &p2);\n         assert res == Path(\"2\");\n     }\n \n     #[test]\n-    fn test_relative_to7() {\n+    pub fn test_relative_to7() {\n         let p1 = Path(\"/1/2\");\n         let p2 = Path(\"/3\");\n         let res = get_relative_to(&p1, &p2);\n         assert res == Path(\"..\");\n     }\n \n     #[test]\n-    fn test_relative_to8() {\n+    pub fn test_relative_to8() {\n         let p1 = Path(\"/home/brian/Dev/rust/build/\").push_rel(\n             &Path(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n         let p2 = Path(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n@@ -333,7 +331,7 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"andorid\")]\n-    fn test_rpath_relative() {\n+    pub fn test_rpath_relative() {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n@@ -342,7 +340,7 @@ mod test {\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n-    fn test_rpath_relative() {\n+    pub fn test_rpath_relative() {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n@@ -351,7 +349,7 @@ mod test {\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n-    fn test_rpath_relative() {\n+    pub fn test_rpath_relative() {\n         // this is why refinements would be nice\n         let o = session::os_macos;\n         let res = get_rpath_relative_to_output(o,\n@@ -361,7 +359,7 @@ mod test {\n     }\n \n     #[test]\n-    fn test_get_absolute_rpath() {\n+    pub fn test_get_absolute_rpath() {\n         let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n         debug!(\"test_get_absolute_rpath: %s vs. %s\",\n                res.to_str(),"}, {"sha": "12281e0b9803f9ca4a5e33482e2e11302425504f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3105bcfdc11030abf9855af7a693cbf904460813", "patch": "@@ -46,7 +46,7 @@ use syntax::parse;\n use syntax::print::{pp, pprust};\n use syntax;\n \n-enum pp_mode {\n+pub enum pp_mode {\n     ppm_normal,\n     ppm_expanded,\n     ppm_typed,\n@@ -58,16 +58,16 @@ enum pp_mode {\n  * The name used for source code that doesn't originate in a file\n  * (e.g. source from stdin or a string)\n  */\n-fn anon_src() -> ~str { ~\"<anon>\" }\n+pub fn anon_src() -> ~str { ~\"<anon>\" }\n \n-fn source_name(input: input) -> ~str {\n+pub fn source_name(input: input) -> ~str {\n     match input {\n       file_input(ref ifile) => (*ifile).to_str(),\n       str_input(_) => anon_src()\n     }\n }\n \n-fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n+pub fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n    ast::crate_cfg {\n     let libc = match sess.targ_cfg.os {\n       session::os_win32 => ~\"msvcrt.dll\",\n@@ -106,15 +106,16 @@ fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n          mk(~\"build_input\", source_name(input))];\n }\n \n-fn append_configuration(+cfg: ast::crate_cfg, +name: ~str) -> ast::crate_cfg {\n+pub fn append_configuration(+cfg: ast::crate_cfg, +name: ~str)\n+                         -> ast::crate_cfg {\n     if attr::contains_name(cfg, name) {\n         return cfg;\n     } else {\n         return vec::append_one(cfg, attr::mk_word_item(name));\n     }\n }\n \n-fn build_configuration(sess: Session, +argv0: ~str, input: input) ->\n+pub fn build_configuration(sess: Session, +argv0: ~str, input: input) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -132,7 +133,7 @@ fn build_configuration(sess: Session, +argv0: ~str, input: input) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n+pub fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // FIXME (#2399): It would be nice to use the parser to parse all\n     // varieties of meta_item here. At the moment we just support the\n     // meta_word variant.\n@@ -143,14 +144,14 @@ fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     return words;\n }\n \n-enum input {\n+pub enum input {\n     /// Load source from file\n     file_input(Path),\n     /// The string is the source\n     str_input(~str)\n }\n \n-fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n+pub fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n     -> @ast::crate {\n     match input {\n       file_input(ref file) => {\n@@ -164,7 +165,7 @@ fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n     }\n }\n \n-fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n+pub fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n     if !do_it { return thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n@@ -174,25 +175,25 @@ fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n     move rv\n }\n \n-enum compile_upto {\n+pub enum compile_upto {\n     cu_parse,\n     cu_expand,\n     cu_typeck,\n     cu_no_trans,\n     cu_everything,\n }\n \n-impl compile_upto : cmp::Eq {\n+pub impl compile_upto : cmp::Eq {\n     pure fn eq(&self, other: &compile_upto) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &compile_upto) -> bool { !(*self).eq(other) }\n }\n \n-fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n-                input: input, upto: compile_upto,\n-                outputs: Option<output_filenames>)\n-    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n+pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n+                    input: input, upto: compile_upto,\n+                    outputs: Option<output_filenames>)\n+                 -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n     let time_passes = sess.time_passes();\n     let mut crate = time(time_passes, ~\"parsing\",\n                          || parse_input(sess, copy cfg, input) );\n@@ -337,8 +338,8 @@ fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n     return {crate: crate, tcx: None};\n }\n \n-fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n-                 outdir: &Option<Path>, output: &Option<Path>) {\n+pub fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n+                     outdir: &Option<Path>, output: &Option<Path>) {\n \n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n@@ -347,8 +348,8 @@ fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n     compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n-fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n-                      ppm: pp_mode) {\n+pub fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n+                          ppm: pp_mode) {\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n         match node {\n           pprust::node_expr(s, _) => pprust::popen(s),\n@@ -424,7 +425,7 @@ fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n     }\n }\n \n-fn get_os(triple: ~str) -> Option<session::os> {\n+pub fn get_os(triple: ~str) -> Option<session::os> {\n     if str::contains(triple, ~\"win32\") ||\n                str::contains(triple, ~\"mingw32\") {\n             Some(session::os_win32)\n@@ -439,7 +440,7 @@ fn get_os(triple: ~str) -> Option<session::os> {\n         } else { None }\n }\n \n-fn get_arch(triple: ~str) -> Option<session::arch> {\n+pub fn get_arch(triple: ~str) -> Option<session::arch> {\n     if str::contains(triple, ~\"i386\") ||\n         str::contains(triple, ~\"i486\") ||\n                str::contains(triple, ~\"i586\") ||\n@@ -454,8 +455,9 @@ fn get_arch(triple: ~str) -> Option<session::arch> {\n         } else { None }\n }\n \n-fn build_target_config(sopts: @session::options,\n-                       demitter: diagnostic::emitter) -> @session::config {\n+pub fn build_target_config(sopts: @session::options,\n+                           demitter: diagnostic::emitter)\n+                        -> @session::config {\n     let os = match get_os(sopts.target_triple) {\n       Some(os) => os,\n       None => early_error(demitter, ~\"unknown operating system\")\n@@ -481,7 +483,7 @@ fn build_target_config(sopts: @session::options,\n     return target_cfg;\n }\n \n-fn host_triple() -> ~str {\n+pub fn host_triple() -> ~str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've\n     // actually built.  We can't just take LLVM's host triple because they\n@@ -498,9 +500,10 @@ fn host_triple() -> ~str {\n         };\n }\n \n-fn build_session_options(+binary: ~str,\n-                         matches: &getopts::Matches,\n-                         demitter: diagnostic::emitter) -> @session::options {\n+pub fn build_session_options(+binary: ~str,\n+                             matches: &getopts::Matches,\n+                             demitter: diagnostic::emitter)\n+                          -> @session::options {\n     let crate_type = if opt_present(matches, ~\"lib\") {\n         session::lib_crate\n     } else if opt_present(matches, ~\"bin\") {\n@@ -637,8 +640,8 @@ fn build_session_options(+binary: ~str,\n     return sopts;\n }\n \n-fn build_session(sopts: @session::options,\n-                 demitter: diagnostic::emitter) -> Session {\n+pub fn build_session(sopts: @session::options,\n+                     demitter: diagnostic::emitter) -> Session {\n     let codemap = @codemap::CodeMap::new();\n     let diagnostic_handler =\n         diagnostic::mk_handler(Some(demitter));\n@@ -647,11 +650,11 @@ fn build_session(sopts: @session::options,\n     build_session_(sopts, codemap, demitter, span_diagnostic_handler)\n }\n \n-fn build_session_(sopts: @session::options,\n-                  cm: @codemap::CodeMap,\n-                  demitter: diagnostic::emitter,\n-                  span_diagnostic_handler: diagnostic::span_handler)\n-               -> Session {\n+pub fn build_session_(sopts: @session::options,\n+                      cm: @codemap::CodeMap,\n+                      demitter: diagnostic::emitter,\n+                      span_diagnostic_handler: diagnostic::span_handler)\n+                   -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n@@ -675,7 +678,7 @@ fn build_session_(sopts: @session::options,\n                lint_settings: lint_settings})\n }\n \n-fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n+pub fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n     match name {\n       ~\"normal\" => ppm_normal,\n       ~\"expanded\" => ppm_expanded,\n@@ -691,7 +694,7 @@ fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n }\n \n // rustc command line options\n-fn optgroups() -> ~[getopts::groups::OptGroup] {\n+pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n  ~[\n   optflag(~\"\",  ~\"bin\", ~\"Compile an executable crate (default)\"),\n   optflag(~\"c\", ~\"\",    ~\"Compile and assemble, but do not link\"),\n@@ -755,13 +758,13 @@ fn optgroups() -> ~[getopts::groups::OptGroup] {\n  ]\n }\n \n-type output_filenames = @{out_filename:Path, obj_filename:Path};\n+pub type output_filenames = @{out_filename:Path, obj_filename:Path};\n \n-fn build_output_filenames(input: input,\n-                          odir: &Option<Path>,\n-                          ofile: &Option<Path>,\n-                          sess: Session)\n-        -> output_filenames {\n+pub fn build_output_filenames(input: input,\n+                              odir: &Option<Path>,\n+                              ofile: &Option<Path>,\n+                              sess: Session)\n+                           -> output_filenames {\n     let obj_path;\n     let out_path;\n     let sopts = sess.opts;\n@@ -831,21 +834,19 @@ fn build_output_filenames(input: input,\n              obj_filename: obj_path};\n }\n \n-fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n+pub fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n     emitter(None, msg, diagnostic::fatal);\n     fail;\n }\n \n-fn list_metadata(sess: Session, path: &Path, out: io::Writer) {\n+pub fn list_metadata(sess: Session, path: &Path, out: io::Writer) {\n     metadata::loader::list_file_metadata(\n         sess.parse_sess.interner,\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n }\n \n #[cfg(test)]\n-mod test {\n-    #[legacy_exports];\n-\n+pub mod test {\n     use core::prelude::*;\n \n     use driver::driver::{build_configuration, build_session};\n@@ -859,7 +860,7 @@ mod test {\n \n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n-    fn test_switch_implies_cfg_test() {\n+    pub fn test_switch_implies_cfg_test() {\n         let matches =\n             &match getopts(~[~\"--test\"], optgroups()) {\n               Ok(copy m) => m,\n@@ -876,7 +877,7 @@ mod test {\n     // When the user supplies --test and --cfg test, don't implicitly add\n     // another --cfg test\n     #[test]\n-    fn test_switch_implies_cfg_test_unless_cfg_test() {\n+    pub fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(~[~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(copy m) => m,"}, {"sha": "2508e6d8aabc6b192eca0661b87e35014a61d2f2", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=3105bcfdc11030abf9855af7a693cbf904460813", "patch": "@@ -8,16 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[legacy_exports];\n+pub use syntax::diagnostic;\n \n-use syntax::diagnostic;\n-\n-export diagnostic;\n-\n-export driver;\n-export session;\n-\n-#[legacy_exports]\n-mod driver;\n-#[legacy_exports]\n-mod session;\n+pub mod driver;\n+pub mod session;"}, {"sha": "3b32952ba3175ef6da046c5d6b2718b24452f3f8", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 64, "deletions": 63, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=3105bcfdc11030abf9855af7a693cbf904460813", "patch": "@@ -29,54 +29,54 @@ use syntax::parse::parse_sess;\n use syntax::{ast, codemap};\n use syntax;\n \n-enum os { os_win32, os_macos, os_linux, os_android, os_freebsd, }\n+pub enum os { os_win32, os_macos, os_linux, os_android, os_freebsd, }\n \n-impl os : cmp::Eq {\n+pub impl os : cmp::Eq {\n     pure fn eq(&self, other: &os) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &os) -> bool { !(*self).eq(other) }\n }\n \n-enum arch { arch_x86, arch_x86_64, arch_arm, }\n+pub enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n-impl arch : cmp::Eq {\n+pub impl arch : cmp::Eq {\n     pure fn eq(&self, other: &arch) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &arch) -> bool { !(*self).eq(other) }\n }\n \n-enum crate_type { bin_crate, lib_crate, unknown_crate, }\n+pub enum crate_type { bin_crate, lib_crate, unknown_crate, }\n \n-type config =\n+pub type config =\n     {os: os,\n      arch: arch,\n      target_strs: target_strs::t,\n      int_type: int_ty,\n      uint_type: uint_ty,\n      float_type: float_ty};\n \n-const verbose: uint = 1 << 0;\n-const time_passes: uint = 1 << 1;\n-const count_llvm_insns: uint = 1 << 2;\n-const time_llvm_passes: uint = 1 << 3;\n-const trans_stats: uint = 1 << 4;\n-const no_asm_comments: uint = 1 << 5;\n-const no_verify: uint = 1 << 6;\n-const trace: uint = 1 << 7;\n-const coherence: uint = 1 << 8;\n-const borrowck_stats: uint = 1 << 9;\n-const borrowck_note_pure: uint = 1 << 10;\n-const borrowck_note_loan: uint = 1 << 11;\n-const no_landing_pads: uint = 1 << 12;\n-const debug_llvm: uint = 1 << 13;\n-const count_type_sizes: uint = 1 << 14;\n-const meta_stats: uint = 1 << 15;\n-const no_opt: uint = 1 << 16;\n-const no_monomorphic_collapse: uint = 1 << 17;\n-\n-fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n+pub const verbose: uint = 1 << 0;\n+pub const time_passes: uint = 1 << 1;\n+pub const count_llvm_insns: uint = 1 << 2;\n+pub const time_llvm_passes: uint = 1 << 3;\n+pub const trans_stats: uint = 1 << 4;\n+pub const no_asm_comments: uint = 1 << 5;\n+pub const no_verify: uint = 1 << 6;\n+pub const trace: uint = 1 << 7;\n+pub const coherence: uint = 1 << 8;\n+pub const borrowck_stats: uint = 1 << 9;\n+pub const borrowck_note_pure: uint = 1 << 10;\n+pub const borrowck_note_loan: uint = 1 << 11;\n+pub const no_landing_pads: uint = 1 << 12;\n+pub const debug_llvm: uint = 1 << 13;\n+pub const count_type_sizes: uint = 1 << 14;\n+pub const meta_stats: uint = 1 << 15;\n+pub const no_opt: uint = 1 << 16;\n+pub const no_monomorphic_collapse: uint = 1 << 17;\n+\n+pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n      (~\"time-passes\", ~\"measure time of each rustc pass\", time_passes),\n      (~\"count-llvm-insns\", ~\"count where LLVM \\\n@@ -105,21 +105,21 @@ fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ]\n }\n \n-enum OptLevel {\n+pub enum OptLevel {\n     No, // -O0\n     Less, // -O1\n     Default, // -O2\n     Aggressive // -O3\n }\n \n-impl OptLevel : cmp::Eq {\n+pub impl OptLevel : cmp::Eq {\n     pure fn eq(&self, other: &OptLevel) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &OptLevel) -> bool { !(*self).eq(other) }\n }\n \n-type options =\n+pub type options =\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process\n     {crate_type: crate_type,\n@@ -147,26 +147,26 @@ type options =\n      debugging_opts: uint,\n     };\n \n-type crate_metadata = {name: ~str, data: ~[u8]};\n-\n-type Session_ = {targ_cfg: @config,\n-                 opts: @options,\n-                 cstore: metadata::cstore::CStore,\n-                 parse_sess: parse_sess,\n-                 codemap: @codemap::CodeMap,\n-                 // For a library crate, this is always none\n-                 mut main_fn: Option<(node_id, codemap::span)>,\n-                 span_diagnostic: diagnostic::span_handler,\n-                 filesearch: filesearch::FileSearch,\n-                 mut building_library: bool,\n-                 working_dir: Path,\n-                 lint_settings: lint::lint_settings};\n-\n-enum Session {\n+pub type crate_metadata = {name: ~str, data: ~[u8]};\n+\n+pub type Session_ = {targ_cfg: @config,\n+                     opts: @options,\n+                     cstore: metadata::cstore::CStore,\n+                     parse_sess: parse_sess,\n+                     codemap: @codemap::CodeMap,\n+                     // For a library crate, this is always none\n+                     mut main_fn: Option<(node_id, codemap::span)>,\n+                     span_diagnostic: diagnostic::span_handler,\n+                     filesearch: filesearch::FileSearch,\n+                     mut building_library: bool,\n+                     working_dir: Path,\n+                     lint_settings: lint::lint_settings};\n+\n+pub enum Session {\n     Session_(@Session_)\n }\n \n-impl Session {\n+pub impl Session {\n     fn span_fatal(sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n@@ -271,7 +271,7 @@ impl Session {\n }\n \n /// Some reasonable defaults\n-fn basic_options() -> @options {\n+pub fn basic_options() -> @options {\n     @{\n         crate_type: session::lib_crate,\n         static: false,\n@@ -296,12 +296,15 @@ fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-fn expect<T: Copy>(sess: Session, opt: Option<T>, msg: fn() -> ~str) -> T {\n+pub fn expect<T: Copy>(sess: Session,\n+                       opt: Option<T>,\n+                       msg: fn() -> ~str)\n+                    -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n \n-fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n-                    testing: bool) -> bool {\n+pub fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n+                        testing: bool) -> bool {\n     match req_crate_type {\n       bin_crate => false,\n       lib_crate => true,\n@@ -320,7 +323,7 @@ fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n     }\n }\n \n-fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n+pub fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n     use metadata::loader;\n \n     match os {\n@@ -333,9 +336,7 @@ fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n }\n \n #[cfg(test)]\n-mod test {\n-    #[legacy_exports];\n-\n+pub mod test {\n     use core::prelude::*;\n \n     use driver::session::{bin_crate, building_library, lib_crate};\n@@ -344,7 +345,7 @@ mod test {\n     use syntax::ast;\n     use syntax::ast_util;\n \n-    fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n+    pub fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n         ast_util::respan(ast_util::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: ast_util::respan(ast_util::dummy_sp(),\n@@ -356,7 +357,7 @@ mod test {\n         })\n     }\n \n-    fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n+    pub fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n@@ -368,43 +369,43 @@ mod test {\n     }\n \n     #[test]\n-    fn bin_crate_type_attr_results_in_bin_output() {\n+    pub fn bin_crate_type_attr_results_in_bin_output() {\n         let crate = make_crate(true, false);\n         assert !building_library(unknown_crate, crate, false);\n     }\n \n     #[test]\n-    fn lib_crate_type_attr_results_in_lib_output() {\n+    pub fn lib_crate_type_attr_results_in_lib_output() {\n         let crate = make_crate(false, true);\n         assert building_library(unknown_crate, crate, false);\n     }\n \n     #[test]\n-    fn bin_option_overrides_lib_crate_type() {\n+    pub fn bin_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n         assert !building_library(bin_crate, crate, false);\n     }\n \n     #[test]\n-    fn lib_option_overrides_bin_crate_type() {\n+    pub fn lib_option_overrides_bin_crate_type() {\n         let crate = make_crate(true, false);\n         assert building_library(lib_crate, crate, false);\n     }\n \n     #[test]\n-    fn bin_crate_type_is_default() {\n+    pub fn bin_crate_type_is_default() {\n         let crate = make_crate(false, false);\n         assert !building_library(unknown_crate, crate, false);\n     }\n \n     #[test]\n-    fn test_option_overrides_lib_crate_type() {\n+    pub fn test_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n         assert !building_library(unknown_crate, crate, true);\n     }\n \n     #[test]\n-    fn test_option_does_not_override_requested_lib_type() {\n+    pub fn test_option_does_not_override_requested_lib_type() {\n         let crate = make_crate(false, false);\n         assert building_library(lib_crate, crate, true);\n     }"}, {"sha": "fcb0416858495b4af4e9cd93dade4016392a691f", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 76, "deletions": 83, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3105bcfdc11030abf9855af7a693cbf904460813/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=3105bcfdc11030abf9855af7a693cbf904460813", "patch": "@@ -19,7 +19,6 @@\n #[crate_type = \"lib\"];\n \n #[legacy_modes];\n-#[legacy_exports];\n #[legacy_records];\n \n #[allow(non_implicitly_copyable_typarams)];\n@@ -49,153 +48,147 @@ use driver_ = driver;\n use middle_ = middle;\n use back_ = back;\n \n-mod middle {\n-    #[legacy_exports];\n-    mod trans {\n-        #[legacy_exports];\n+pub mod middle {\n+    pub mod trans {\n         #[legacy_exports]\n-        mod inline;\n+        pub mod inline;\n         #[legacy_exports]\n-        mod monomorphize;\n+        pub mod monomorphize;\n         #[legacy_exports]\n-        mod controlflow;\n+        pub mod controlflow;\n         #[legacy_exports]\n-        mod glue;\n+        pub mod glue;\n         #[legacy_exports]\n-        mod datum;\n+        pub mod datum;\n         #[legacy_exports]\n-        mod callee;\n+        pub mod callee;\n         #[legacy_exports]\n-        mod expr;\n+        pub mod expr;\n         #[legacy_exports]\n-        mod common;\n+        pub mod common;\n         #[legacy_exports]\n-        mod consts;\n+        pub mod consts;\n         #[legacy_exports]\n-        mod type_of;\n+        pub mod type_of;\n         #[legacy_exports]\n-        mod build;\n+        pub mod build;\n         #[legacy_exports]\n-        mod base;\n+        pub mod base;\n         #[legacy_exports]\n-        mod _match;\n+        pub mod _match;\n         #[legacy_exports]\n-        mod uniq;\n+        pub mod uniq;\n         #[legacy_exports]\n-        mod closure;\n+        pub mod closure;\n         #[legacy_exports]\n-        mod tvec;\n+        pub mod tvec;\n         #[legacy_exports]\n-        mod meth;\n+        pub mod meth;\n         #[legacy_exports]\n-        mod cabi;\n+        pub mod cabi;\n         #[legacy_exports]\n-        mod cabi_x86_64;\n+        pub mod cabi_x86_64;\n         #[legacy_exports]\n-        mod foreign;\n+        pub mod foreign;\n         #[legacy_exports]\n-        mod reflect;\n+        pub mod reflect;\n         #[legacy_exports]\n-        mod shape;\n+        pub mod shape;\n         #[legacy_exports]\n-        mod debuginfo;\n+        pub mod debuginfo;\n         #[legacy_exports]\n-        mod type_use;\n+        pub mod type_use;\n         #[legacy_exports]\n-        mod reachable;\n-        mod machine;\n+        pub mod reachable;\n+        pub mod machine;\n     }\n     #[legacy_exports]\n-    mod ty;\n+    pub mod ty;\n     #[legacy_exports]\n-    mod resolve;\n+    pub mod resolve;\n     #[path = \"typeck/mod.rs\"]\n     pub mod typeck;\n     #[legacy_exports]\n-    mod check_loop;\n+    pub mod check_loop;\n     #[legacy_exports]\n-    mod check_match;\n+    pub mod check_match;\n     #[legacy_exports]\n-    mod check_const;\n+    pub mod check_const;\n     #[legacy_exports]\n-    mod lint;\n+    pub mod lint;\n     #[path = \"borrowck/mod.rs\"]\n     pub mod borrowck;\n     #[legacy_exports]\n-    mod mem_categorization;\n+    pub mod mem_categorization;\n     #[legacy_exports]\n-    mod liveness;\n+    pub mod liveness;\n     #[legacy_exports]\n-    mod kind;\n+    pub mod kind;\n     #[legacy_exports]\n-    mod freevars;\n+    pub mod freevars;\n     #[legacy_exports]\n-    mod capture;\n+    pub mod capture;\n     #[legacy_exports]\n-    mod pat_util;\n+    pub mod pat_util;\n     #[legacy_exports]\n-    mod region;\n+    pub mod region;\n     #[legacy_exports]\n-    mod const_eval;\n+    pub mod const_eval;\n     #[legacy_exports]\n-    mod astencode;\n+    pub mod astencode;\n     #[legacy_exports]\n-    mod lang_items;\n+    pub mod lang_items;\n     #[legacy_exports]\n-    mod privacy;\n-    mod mode;\n+    pub mod privacy;\n+    pub mod mode;\n }\n \n-mod front {\n-    #[legacy_exports];\n+pub mod front {\n     #[legacy_exports]\n-    mod config;\n+    pub mod config;\n     #[legacy_exports]\n-    mod test;\n+    pub mod test;\n     #[legacy_exports]\n-    mod core_inject;\n+    pub mod core_inject;\n     #[legacy_exports]\n-    mod intrinsic_inject;\n+    pub mod intrinsic_inject;\n }\n \n-mod back {\n-    #[legacy_exports];\n+pub mod back {\n     #[legacy_exports]\n-    mod link;\n+    pub mod link;\n     #[legacy_exports]\n-    mod abi;\n+    pub mod abi;\n     #[legacy_exports]\n-    mod upcall;\n+    pub mod upcall;\n     #[legacy_exports]\n-    mod arm;\n+    pub mod arm;\n     #[legacy_exports]\n-    mod x86;\n+    pub mod x86;\n     #[legacy_exports]\n-    mod x86_64;\n+    pub mod x86_64;\n     #[legacy_exports]\n-    mod rpath;\n+    pub mod rpath;\n     #[legacy_exports]\n-    mod target_strs;\n+    pub mod target_strs;\n }\n \n #[path = \"metadata/mod.rs\"]\n-mod metadata;\n+pub mod metadata;\n \n #[path = \"driver/mod.rs\"]\n-mod driver;\n+pub mod driver;\n \n-mod util {\n-    #[legacy_exports];\n+pub mod util {\n     #[legacy_exports]\n-    mod common;\n+    pub mod common;\n     #[legacy_exports]\n-    mod ppaux;\n+    pub mod ppaux;\n }\n \n-mod lib {\n-    #[legacy_exports];\n+pub mod lib {\n     #[legacy_exports]\n-    mod llvm;\n+    pub mod llvm;\n }\n \n use result::{Ok, Err};\n@@ -214,15 +207,15 @@ use driver::driver::{host_triple, optgroups, early_error,\n use driver::session;\n use middle::lint;\n \n-fn version(argv0: &str) {\n+pub fn version(argv0: &str) {\n     let mut vers = ~\"unknown version\";\n     let env_vers = env!(\"CFG_VERSION\");\n     if env_vers.len() != 0 { vers = env_vers; }\n     io::println(fmt!(\"%s %s\", argv0, vers));\n     io::println(fmt!(\"host: %s\", host_triple()));\n }\n \n-fn usage(argv0: &str) {\n+pub fn usage(argv0: &str) {\n     let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n     io::println(groups::usage(message, optgroups()) +\n                 ~\"Additional help:\n@@ -231,7 +224,7 @@ fn usage(argv0: &str) {\n \");\n }\n \n-fn describe_warnings() {\n+pub fn describe_warnings() {\n     io::println(fmt!(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n@@ -266,15 +259,15 @@ Available lint options:\n     io::println(~\"\");\n }\n \n-fn describe_debug_flags() {\n+pub fn describe_debug_flags() {\n     io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n     for session::debugging_opts_map().each |pair| {\n         let (name, desc, _) = /*bad*/copy *pair;\n         io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n     }\n }\n \n-fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n+pub fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     logging::console_off();\n \n@@ -361,12 +354,12 @@ fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     compile_input(sess, cfg, input, &odir, &ofile);\n }\n \n-enum monitor_msg {\n+pub enum monitor_msg {\n     fatal,\n     done,\n }\n \n-impl monitor_msg : cmp::Eq {\n+pub impl monitor_msg : cmp::Eq {\n     pure fn eq(&self, other: &monitor_msg) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n@@ -385,7 +378,7 @@ diagnostic emitter which records when we hit a fatal error. If the task\n fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n-fn monitor(+f: fn~(diagnostic::emitter)) {\n+pub fn monitor(+f: fn~(diagnostic::emitter)) {\n     let p = oldcomm::Port();\n     let ch = oldcomm::Chan(&p);\n \n@@ -435,7 +428,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     let mut args = os::args();\n     do monitor |move args, demitter| {\n         run_compiler(&args, demitter);"}]}