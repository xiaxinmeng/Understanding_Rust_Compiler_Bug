{"sha": "4b8446a2333ca7a22a594a24e3eb541cf5265792", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiODQ0NmEyMzMzY2E3YTIyYTU5NGEyNGUzZWI1NDFjZjUyNjU3OTI=", "commit": {"author": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2017-06-19T22:00:45Z"}, "committer": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2017-06-19T22:00:45Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "84ac480b1cb9c6172ec41fb17aa1e526e163ed38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84ac480b1cb9c6172ec41fb17aa1e526e163ed38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b8446a2333ca7a22a594a24e3eb541cf5265792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8446a2333ca7a22a594a24e3eb541cf5265792", "html_url": "https://github.com/rust-lang/rust/commit/4b8446a2333ca7a22a594a24e3eb541cf5265792", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b8446a2333ca7a22a594a24e3eb541cf5265792/comments", "author": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "html_url": "https://github.com/rust-lang/rust/commit/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d"}, {"sha": "04145943a25c3b8c7e7d7fe8c2efb04f259c25fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/04145943a25c3b8c7e7d7fe8c2efb04f259c25fb", "html_url": "https://github.com/rust-lang/rust/commit/04145943a25c3b8c7e7d7fe8c2efb04f259c25fb"}], "stats": {"total": 30829, "additions": 15957, "deletions": 14872}, "files": [{"sha": "b95196da356c86cc1fdf60a0c7c257d699a23119", "filename": ".travis.yml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -36,9 +36,10 @@ matrix:\n     - env: IMAGE=dist-x86_64-linux DEPLOY=1 ALLOW_TRY=1\n     - env: IMAGE=dist-x86_64-musl DEPLOY=1\n     - env: IMAGE=dist-x86_64-netbsd DEPLOY=1\n-    - env: IMAGE=emscripten\n+    - env: IMAGE=asmjs\n     - env: IMAGE=i686-gnu\n     - env: IMAGE=i686-gnu-nopt\n+    # - env: IMAGE=wasm32 issue 42646\n     - env: IMAGE=x86_64-gnu\n     - env: IMAGE=x86_64-gnu-full-bootstrap\n     - env: IMAGE=x86_64-gnu-aux\n@@ -54,7 +55,7 @@ matrix:\n     # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n     - env: >\n         RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=\"--build=x86_64-apple-darwin --enable-sanitizers\"\n+        RUST_CONFIGURE_ARGS=\"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler\"\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n         SCCACHE_ERROR_LOG=/tmp/sccache.log\n@@ -87,7 +88,7 @@ matrix:\n     # OSX 10.7 and `xcode7` is the latest Xcode able to compile LLVM for 10.7.\n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-extended\"\n+        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-extended --enable-profiler\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n@@ -101,7 +102,7 @@ matrix:\n         - *osx_install_sccache\n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-extended --enable-sanitizers\"\n+        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-extended --enable-sanitizers --enable-profiler\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1"}, {"sha": "0b209fd3e9492c126a86bbc87b6d436fdc06f301", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -7,9 +7,9 @@ standard library, and documentation.\n \n ## Quick Start\n \n-Read [\"Installing Rust\"] from [The Book].\n+Read [\"Installation\"] from [The Book].\n \n-[\"Installing Rust\"]: https://doc.rust-lang.org/book/getting-started.html#installing-rust\n+[\"Installation\"]: https://doc.rust-lang.org/book/second-edition/ch01-01-installation.html\n [The Book]: https://doc.rust-lang.org/book/index.html\n \n ## Building from Source"}, {"sha": "4711f34f830e68e00f07cc667949d7f1e5ca02b6", "filename": "appveyor.yml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -7,7 +7,7 @@ environment:\n   matrix:\n   # 32/64 bit MSVC tests\n   - MSYS_BITS: 64\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n     SCRIPT: python x.py test\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i586-pc-windows-msvc\n@@ -48,12 +48,14 @@ environment:\n   - RUST_CONFIGURE_ARGS: >\n       --build=x86_64-pc-windows-msvc\n       --enable-extended\n+      --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n   - RUST_CONFIGURE_ARGS: >\n       --build=i686-pc-windows-msvc\n       --target=i586-pc-windows-msvc\n       --enable-extended\n+      --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n   - MSYS_BITS: 32"}, {"sha": "2b493ee91b50ad9d4b5e40ede3f5e4a647979747", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/configure", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -452,6 +452,7 @@ opt vendor 0 \"enable usage of vendored Rust crates\"\n opt sanitizers 0 \"build the sanitizer runtimes (asan, lsan, msan, tsan)\"\n opt dist-src 1 \"when building tarballs enables building a source tarball\"\n opt cargo-openssl-static 0 \"static openssl in cargo\"\n+opt profiler 0 \"build the profiler runtime\"\n \n # Optimization and debugging options. These may be overridden by the release channel, etc.\n opt_nosave optimize 1 \"build optimized rust code\""}, {"sha": "f99ffc6472d25afdc78e285452c4bcf338eb9938", "filename": "src/Cargo.lock", "status": "modified", "additions": 401, "deletions": 391, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -36,6 +36,7 @@ name = \"alloc\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n+ \"std_unicode 0.0.0\",\n ]\n \n [[package]]\n@@ -44,7 +45,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -65,27 +66,37 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"arena\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"atty\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"backtrace\"\n-version = \"0.3.0\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace-sys 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"backtrace-sys\"\n-version = \"0.1.10\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -103,17 +114,22 @@ name = \"bitflags\"\n version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -140,49 +156,53 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.20.0\"\n-source = \"git+https://github.com/rust-lang/cargo#2b32084293d8da63b48de56363a0f2e986ec3367\"\n-replace = \"cargo 0.20.0\"\n+version = \"0.21.0\"\n+source = \"git+https://github.com/rust-lang/cargo#50b1c24d146fa072db71f12005deed319ac5ba9a\"\n+replace = \"cargo 0.21.0\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.20.0\"\n+version = \"0.21.0\"\n dependencies = [\n  \"advapi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargotest 0.1.0\",\n- \"crates-io 0.9.0\",\n+ \"crates-io 0.10.0\",\n  \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"docopt 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"docopt 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"fs2 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -191,21 +211,20 @@ name = \"cargotest\"\n version = \"0.1.0\"\n dependencies = [\n  \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cargo 0.20.0\",\n+ \"cargo 0.21.0\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -215,31 +234,31 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cfg-if\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.19.3\"\n+version = \"2.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"strsim 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-segmentation 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vec_map 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"yaml-rust 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.23\"\n+version = \"0.1.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -248,7 +267,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n  \"core 0.0.0\",\n- \"std_unicode 0.0.0\",\n ]\n \n [[package]]\n@@ -257,17 +275,17 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -277,13 +295,14 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n dependencies = [\n  \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -296,23 +315,24 @@ name = \"curl\"\n version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"curl-sys 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.3.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.3.11\"\n+version = \"0.3.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -341,12 +361,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"docopt\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -355,43 +376,38 @@ name = \"dtoa\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"either\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"enum_primitive\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"env_logger\"\n version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.4.2\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"error-chain\"\n version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -403,23 +419,23 @@ name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"flate2\"\n version = \"0.2.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -434,27 +450,18 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"fs2\"\n-version = \"0.4.1\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.50\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"gdi32-sys\"\n-version = \"0.2.0\"\n+version = \"0.3.51\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"getopts\"\n@@ -467,15 +474,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"git2\"\n-version = \"0.6.5\"\n+version = \"0.6.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -484,9 +491,9 @@ version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -503,7 +510,7 @@ name = \"hamcrest\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -513,29 +520,34 @@ version = \"0.25.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 0.9.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"hex\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"idna\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-bidi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-normalization 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-bidi 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n- \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.24.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -547,17 +559,18 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"itertools\"\n-version = \"0.5.10\"\n+name = \"itoa\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"either 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n-name = \"itoa\"\n-version = \"0.3.1\"\n+name = \"jobserver\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n name = \"kernel32-sys\"\n@@ -574,10 +587,10 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -595,21 +608,21 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.22\"\n+version = \"0.2.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.6.11\"\n+version = \"0.6.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"curl-sys 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.3.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -618,21 +631,22 @@ name = \"libssh2-sys\"\n version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"libz-sys\"\n-version = \"1.0.13\"\n+version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -641,36 +655,36 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"log\"\n-version = \"0.3.7\"\n+version = \"0.3.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"lzma-sys\"\n-version = \"0.1.4\"\n+version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"matches\"\n-version = \"0.1.4\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"mdbook\"\n version = \"0.0.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.24.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 0.25.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 0.9.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -681,24 +695,24 @@ name = \"memchr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"miniz-sys\"\n version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -712,53 +726,48 @@ dependencies = [\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"multimap\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"net2\"\n version = \"0.2.29\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cfg-if 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num\"\n-version = \"0.1.37\"\n+version = \"0.1.39\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num-bigint 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-complex 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-bigint 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-complex 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-iter 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-rational 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-rational 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num-bigint\"\n-version = \"0.1.37\"\n+version = \"0.1.39\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num-complex\"\n-version = \"0.1.37\"\n+version = \"0.1.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -767,7 +776,7 @@ name = \"num-integer\"\n version = \"0.1.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -776,31 +785,31 @@ version = \"0.1.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num-rational\"\n-version = \"0.1.36\"\n+version = \"0.1.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num-bigint 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-bigint 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num-traits\"\n-version = \"0.1.37\"\n+version = \"0.1.39\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.4.0\"\n+version = \"1.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -810,14 +819,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"openssl\"\n-version = \"0.9.12\"\n+version = \"0.9.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -827,14 +836,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.12\"\n+version = \"0.9.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gdi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"user32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -863,6 +870,11 @@ dependencies = [\n  \"unwind 0.0.0\",\n ]\n \n+[[package]]\n+name = \"percent-encoding\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"pest\"\n version = \"0.3.3\"\n@@ -889,6 +901,14 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"profiler_builtins\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"psapi-sys\"\n version = \"0.1.0\"\n@@ -932,16 +952,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"racer\"\n-version = \"2.0.6\"\n+version = \"2.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.24.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_syntax 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"typed-arena 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"typed-arena 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -956,7 +977,7 @@ name = \"rand\"\n version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -973,12 +994,12 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_local 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -990,7 +1011,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.4.0\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1005,40 +1026,49 @@ version = \"0.1.0\"\n name = \"rls\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo 0.20.0 (git+https://github.com/rust-lang/cargo)\",\n+ \"cargo 0.21.0 (git+https://github.com/rust-lang/cargo)\",\n  \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-analysis 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-analysis 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-vfs 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt 0.8.4 (git+https://github.com/rust-lang-nursery/rustfmt)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-vfs 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-nightly 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.2.1\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-data\"\n-version = \"0.3.1\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rls-data\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1051,24 +1081,24 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-vfs\"\n-version = \"0.3.0\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"racer 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.24.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mdbook 0.0.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1079,7 +1109,7 @@ dependencies = [\n  \"arena 0.0.0\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n@@ -1116,15 +1146,15 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n [[package]]\n name = \"rustc_back\"\n version = \"0.0.0\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n@@ -1138,7 +1168,7 @@ name = \"rustc_borrowck\"\n version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -1152,7 +1182,7 @@ name = \"rustc_const_eval\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -1174,7 +1204,7 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n ]\n \n@@ -1183,9 +1213,9 @@ name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro_plugin 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -1223,7 +1253,7 @@ name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -1235,7 +1265,7 @@ dependencies = [\n name = \"rustc_lint\"\n version = \"0.0.0\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n@@ -1248,7 +1278,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -1258,7 +1288,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1267,7 +1297,7 @@ name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n@@ -1286,7 +1316,7 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n@@ -1302,15 +1332,15 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n [[package]]\n name = \"rustc_passes\"\n version = \"0.0.0\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -1349,7 +1379,7 @@ name = \"rustc_resolve\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1360,8 +1390,8 @@ dependencies = [\n name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1375,8 +1405,8 @@ name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -1398,7 +1428,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1408,7 +1438,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"fmt_macros 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -1425,9 +1455,9 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -1445,29 +1475,24 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustfmt\"\n-version = \"0.8.4\"\n-source = \"git+https://github.com/rust-lang-nursery/rustfmt#bf9b3fa1d7cab2f7bd541539d397a92b4954ec96\"\n+name = \"rustfmt-nightly\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"multimap 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_errors 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_syntax 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"strings 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1480,13 +1505,18 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"scoped-tls\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"semver\"\n version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1501,22 +1531,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.6\"\n+version = \"1.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.6\"\n+version = \"1.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive_internals 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive_internals\"\n-version = \"0.15.0\"\n+version = \"0.15.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1528,7 +1558,7 @@ name = \"serde_ignored\"\n version = \"0.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1538,7 +1568,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1549,8 +1579,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1578,10 +1608,11 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n+ \"profiler_builtins 0.0.0\",\n  \"rand 0.0.0\",\n  \"rustc_asan 0.0.0\",\n  \"rustc_lsan 0.0.0\",\n@@ -1600,17 +1631,12 @@ dependencies = [\n \n [[package]]\n name = \"strings\"\n-version = \"0.0.1\"\n+version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"strsim\"\n-version = \"0.5.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"strsim\"\n version = \"0.6.0\"\n@@ -1648,7 +1674,7 @@ name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -1660,7 +1686,7 @@ name = \"syntax_ext\"\n version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros 0.0.0\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1671,6 +1697,7 @@ dependencies = [\n name = \"syntax_pos\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n ]\n \n@@ -1679,26 +1706,14 @@ name = \"syntex_errors\"\n version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"syntex_errors\"\n-version = \"0.58.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_pos 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"syntex_pos\"\n version = \"0.52.0\"\n@@ -1707,49 +1722,28 @@ dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"syntex_pos\"\n-version = \"0.58.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"syntex_syntax\"\n version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"syntex_syntax\"\n-version = \"0.58.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_errors 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_pos 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"tar\"\n version = \"0.4.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"xattr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1776,14 +1770,22 @@ dependencies = [\n \n [[package]]\n name = \"term_size\"\n-version = \"0.2.3\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"termcolor\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"wincolor 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"test\"\n version = \"0.0.0\"\n@@ -1798,7 +1800,7 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1807,7 +1809,7 @@ version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1860,30 +1862,25 @@ name = \"toml\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"typed-arena\"\n-version = \"1.2.0\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"unicode-bidi\"\n-version = \"0.2.5\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"unicode-normalization\"\n-version = \"0.1.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"unicode-segmentation\"\n-version = \"0.1.3\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1915,30 +1912,29 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"url\"\n-version = \"1.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+name = \"unstable-book-gen\"\n+version = \"0.1.0\"\n dependencies = [\n- \"idna 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tidy 0.1.0\",\n ]\n \n [[package]]\n-name = \"url_serde\"\n-version = \"0.2.0\"\n+name = \"url\"\n+version = \"1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"idna 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"percent-encoding 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n-name = \"user32-sys\"\n+name = \"url_serde\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1951,9 +1947,14 @@ name = \"utf8-ranges\"\n version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"vcpkg\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"vec_map\"\n-version = \"0.6.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1981,6 +1982,15 @@ name = \"winapi-build\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"wincolor\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ws2_32-sys\"\n version = \"0.2.1\"\n@@ -1995,15 +2005,15 @@ name = \"xattr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"xz2\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lzma-sys 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lzma-sys 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2016,74 +2026,75 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n-\"checksum backtrace 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f551bc2ddd53aea015d453ef0b635af89444afa5ed2405dd0b2062ad5d600d80\"\n-\"checksum backtrace-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d192fd129132fbc97497c1f2ec2c2c5174e376b95f535199ef4fe0a293d33842\"\n+\"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n+\"checksum backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72f9b4182546f4b04ebc4ab7f84948953a118bd6021a1b6a6c909e3e94f6be76\"\n+\"checksum backtrace-sys 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a0d842ea781ce92be2bf78a9b38883948542749640b8378b3b2f03d1fd9f1ff\"\n \"checksum bitflags 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f67931368edf3a9a51d29886d245f1c3db2f1ef0dcc9e35ff70341b78c10d23\"\n \"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n \"checksum bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1370e9fc2a6ae53aea8b7a5110edbd08836ed87c88736dfabccade1c2b44bff4\"\n+\"checksum bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n-\"checksum cargo 0.20.0 (git+https://github.com/rust-lang/cargo)\" = \"<none>\"\n-\"checksum cfg-if 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"de1e760d7b6535af4241fca8bd8adf68e2e7edacc6b29f5d399050c5e48cf88c\"\n-\"checksum clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"95b78f3fe0fc94c13c731714363260e04b557a637166f33a4570d3189d642374\"\n-\"checksum cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92278eb79412c8f75cfc89e707a1bb3a6490b68f7f2e78d15c774f30fe701122\"\n+\"checksum cargo 0.21.0 (git+https://github.com/rust-lang/cargo)\" = \"<none>\"\n+\"checksum cfg-if 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d0c47d456a36ebf0536a6705c83c1cbbcb9255fbc1d905a6ded104f479268a29\"\n+\"checksum clap 2.24.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6b8f69e518f967224e628896b54e41ff6acfb4dcfefc5076325c36525dac900f\"\n+\"checksum cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8ebbb35d3dc9cd09497168f33de1acb79b265d350ab0ac34133b98f8509af1f\"\n \"checksum crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c5ea215664ca264da8a9d9c3be80d2eaf30923c259d03e870388eb927508f97\"\n \"checksum curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c90e1240ef340dd4027ade439e5c7c2064dd9dc652682117bd50d1486a3add7b\"\n-\"checksum curl-sys 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23e7e544dc5e1ba42c4a4a678bd47985e84b9c3f4d3404c29700622a029db9c3\"\n+\"checksum curl-sys 0.3.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f00c8ba847fb0730c293069b4d1203dc01bf3c2e1f90b4e55f426ed8f4a1eeac\"\n \"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n \"checksum derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"41be6ca3b99e0c0483fb2389685448f650459c3ecbe4e18d7705d8010ec4ab8e\"\n \"checksum diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a515461b6c8c08419850ced27bc29e86166dcdcde8fbe76f8b1f0589bb49472\"\n-\"checksum docopt 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab32ea6e284d87987066f21a9e809a73c14720571ef34516f0890b3d355ccfd8\"\n+\"checksum docopt 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63e408eee8a772c5c61f62353992e3ebf51ef5c832dd04d986b3dc7d48c5b440\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n-\"checksum either 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18785c1ba806c258137c937e44ada9ee7e69a37e3c72077542cd2f069d78562a\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n-\"checksum env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3856f1697098606fc6cb97a93de88ca3f3bc35bb878c725920e6e82ecf05e83\"\n+\"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n \"checksum error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9435d864e017c3c6afeac1654189b06cdb491cf2ff73dbf0d73b0f292f42ff8\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n \"checksum flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36df0166e856739905cd3d7e0b210fe818592211a008862599845e012d8d304c\"\n \"checksum foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e4056b9bd47f8ac5ba12be771f77a0dae796d1bbaaf5fd0b9c2d38b69b8a29d\"\n-\"checksum fs2 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34edaee07555859dc13ca387e6ae05686bb4d0364c95d649b6dab959511f4baf\"\n-\"checksum gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f837c392f2ea61cb1576eac188653df828c861b7137d74ea4a5caa89621f9e6\"\n-\"checksum gdi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0912515a8ff24ba900422ecda800b52f4016a56251922d397c576bf92c690518\"\n+\"checksum fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ab76cfd2aaa59b7bf6688ad9ba15bbae64bff97f04ea02144cfd3443e5c2866\"\n+\"checksum gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\" = \"120d07f202dcc3f72859422563522b66fe6463a4c513df062874daad05f85f0a\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9de9df4358c17e448a778d90cd0272e1dab5eae30244502333fa2001c4e24357\"\n+\"checksum git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa01936ac96555c083c0e8553f672616274408d9d3fc5b8696603fbf63ff43ee\"\n \"checksum git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"68676bc784bf0bef83278898929bf64a251e87c0340723d0b93fa096c9c5bf8e\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n \"checksum hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf088f042a467089e9baa4972f57f9247e42a0cc549ba264c7a04fbb8ecb89d4\"\n \"checksum handlebars 0.25.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15bdf598fc3c2de40c6b340213028301c0d225eea55a2294e6cc148074e557a1\"\n-\"checksum idna 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ac85ec3f80c8e4e99d9325521337e14ec7555c458a14e377d189659a427f375\"\n-\"checksum itertools 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4833d6978da405305126af4ac88569b5d71ff758581ce5a987dbfa3755f694fc\"\n+\"checksum hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6a22814455d41612f41161581c2883c0c6a1c41852729b17d5ed88f01e153aa\"\n+\"checksum idna 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2233d4940b1f19f0418c158509cd7396b8d70a5db5705ce410914dc8fa603b37\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n+\"checksum jobserver 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e28adc987f6d0521ef66ad60b055968107b164b3bb3cf3dc8474e0a380474a6\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum languageserver-types 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97c2985bfcbbcb0189cfa25e1c10c1ac7111df2b6214b652c690127aefdf4e5b\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"babb8281da88cba992fa1f4ddec7d63ed96280a1a53ec9b919fd37b53d71e502\"\n-\"checksum libgit2-sys 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9dc31ee90fb179b706d35fb672e91d0b74e950d7fb4ea7eae3c0f5ecbf2d3d3\"\n+\"checksum libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f5c2b18a287cf78b4097db62e20f43cace381dc76ae5c0a3073067f78b7ddc\"\n+\"checksum libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df18a822100352d9863b302faf6f8f25c0e77f0e60feb40e5dbe1238b7f13b1d\"\n \"checksum libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0db4ec23611747ef772db1c4d650f8bd762f07b461727ec998f953c614024b75\"\n-\"checksum libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e5ee912a45d686d393d5ac87fac15ba0ba18daae14e8e7543c63ebf7fb7e970c\"\n-\"checksum log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5141eca02775a762cc6cd564d8d2c50f67c0ea3a372cbf1c51592b3e029e10ad\"\n-\"checksum lzma-sys 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fedff6a5cbb24494ec6ee4784e9ac5c187161fede04c7767d49bf87544013afa\"\n-\"checksum matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"efd7622e3022e1a6eaa602c4cea8912254e5582c9c692e9167714182244801b1\"\n+\"checksum libz-sys 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e70195f655a44af531ad7135b1ec2a0a82522b451fe09730fbb25674a85996e7\"\n+\"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n+\"checksum lzma-sys 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"013fa6506eb7d26040c46dab9ecb7ccb4e2896b5bf24a9d65932501ea9f67af8\"\n+\"checksum matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"100aabe6b8ff4e4a7e32c1c13523379802df0772b82466207ac25b013f193376\"\n \"checksum mdbook 0.0.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f1e2e9d848514dcfad4195788d0d42ae5153a477c191d75d5b84fab10f222fbd\"\n \"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n \"checksum miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28eaee17666671fa872e567547e8428e83308ebe5808cdf6a0e28397dbe2c726\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n-\"checksum multimap 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9223f4774d08e06185e44e555b9a7561243d387bac49c78a6205c42d6975fbf2\"\n \"checksum net2 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc01404e7568680f1259aa5729539f221cb1e6d047a0d9053cab4be8a73b5d67\"\n-\"checksum num 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"98b15ba84e910ea7a1973bccd3df7b31ae282bf9d8bd2897779950c9b8303d40\"\n-\"checksum num-bigint 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba6d838b16e56da1b6c383d065ff1ec3c7d7797f65a3e8f6ba7092fd87820bac\"\n-\"checksum num-complex 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"148eb324ca772230853418731ffdf13531738b50f89b30692a01fcdcb0a64677\"\n+\"checksum num 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2c3a3dc9f30bf824141521b30c908a859ab190b76e20435fcd89f35eb6583887\"\n+\"checksum num-bigint 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6361748d02e5291c72a422dc8ed4d8464a80cb1e618971f6fffe6d52d97e3286\"\n+\"checksum num-complex 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"412dfc143c56579aa6a22c574e38ddbf724522f1280ae2b257498cccff3fb6af\"\n \"checksum num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef1a4bf6f9174aa5783a9b4cc892cacd11aebad6c69ad027a0b65c6ca5f8aa37\"\n \"checksum num-iter 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7d1891bd7b936f12349b7d1403761c8a0b85a18b148e9da4429d5d102c1a41e\"\n-\"checksum num-rational 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c2dc5ea04020a8f18318ae485c751f8cfa1c0e69dcf465c29ddaaa64a313cc44\"\n-\"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n-\"checksum num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca313f1862c7ec3e0dfe8ace9fa91b1d9cb5c84ace3d00f5ec4216238e93c167\"\n+\"checksum num-rational 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33c881e104a26e1accc09449374c095ff2312c8e0c27fab7bbefe16eac7c776d\"\n+\"checksum num-traits 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1708c0628602a98b52fad936cf3edb9a107af06e52e49fdf0707e884456a6af6\"\n+\"checksum num_cpus 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6e416ba127a4bb3ff398cb19546a8d0414f73352efe2857f4060d36f5fe5983a\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n-\"checksum openssl 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb5d1663b73d10c6a3eda53e2e9d0346f822394e7b858d7257718f65f61dfbe2\"\n+\"checksum openssl 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11ba043cb65fc9af71a431b8a36ffe8686cd4751cdf70a473ec1d01066ac7e41\"\n \"checksum openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d98df0270d404ccd3c050a41d579c52d1db15375168bb3471e04ec0f5f378daf\"\n-\"checksum openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a5886d87d3e2a0d890bf62dc8944f5e3769a405f7e1e9ef6e517e47fd7a0897\"\n+\"checksum openssl-sys 0.9.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"236c718c2e2c2b58a546d86ffea5194400bb15dbe01ca85325ffd357b03cf66c\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n+\"checksum percent-encoding 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"de154f638187706bde41d9b4738748933d64e6b37bdbffc0b47a97d16a6ae356\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n \"checksum pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a8b4c6b8165cd1a1cd4b9b120978131389f64bdaf456435caa41e630edba903\"\n \"checksum psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"abcd5d1a07d360e29727f757a9decb3ce8bc6e0efa8969cfaad669a8317a2478\"\n@@ -2092,47 +2103,46 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c36987d4978eb1be2e422b1e0423a557923a5c3e7e6f31d5699e9aafaefa469\"\n \"checksum quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c5cf478fe1006dbcc72567121d23dbdae5f1632386068c5c86ff4f645628504\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n-\"checksum racer 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0d72b3afd67882adfca61d609fafb8d7aa5f9e814f12c32fcc6e171995920e8\"\n+\"checksum racer 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"edf2dfc188373ef96168bec3646a0415c5c21111c6144c0c36104fc720587ecd\"\n \"checksum rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"022e0636ec2519ddae48154b028864bdce4eaf7d35226ab8e65c611be97b189d\"\n \"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n-\"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\"\n+\"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n-\"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n-\"checksum rls-analysis 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a62d88c341375c6f3f8b2e18b9b364896e7d3e7aa916907de717d0267e116506\"\n-\"checksum rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc4277ce3c57f456b11fe3145b181a844a25201bab5cbaa1978457e6e2f27d47\"\n+\"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n+\"checksum rls-analysis 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d77d58e8933752142b5b92e3f8ba6d6f1630be6da5627c492268a43f79ffbda\"\n+\"checksum rls-data 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"374a8fad31cc0681a7bfd8a04079dd4afd0e981d34e18a171b1a467445bdf51e\"\n+\"checksum rls-data 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e2087477364c34faca86c2476765deb1185dbae3c598cfb1eb040f3a74d22b5\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n-\"checksum rls-vfs 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"986eada111517bcb5a7a75205b3f2b70c82e7766653cca61a23f5afce79bdb94\"\n+\"checksum rls-vfs 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ace07060dd154731b39254864245cbdd33c8f5f64fe1f630a089c72e2468f854\"\n \"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum rustfmt 0.8.4 (git+https://github.com/rust-lang-nursery/rustfmt)\" = \"<none>\"\n+\"checksum rustfmt-nightly 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"277deb9c0ee9c4788ee94faef5988fa334179cd7363bf281a2cae027edbbc8bf\"\n \"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n+\"checksum scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f417c22df063e9450888a7561788e9bd46d3bb3c1466435b4eccb903807f147d\"\n \"checksum semver 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd61b85a0fa777f7fb7c454b9189b2941b110d1385ce84d7f76efdf1606a85\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \"checksum serde 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34b623917345a631dc9608d5194cc206b3fe6c3554cd1c75b937e55e285254af\"\n-\"checksum serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38a3db3a5757f68069aba764b793823ea9fb9717c42c016f8903f8add50f508a\"\n-\"checksum serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e46ef71ee001a4279a4513e79a6ebbb59da3a4987bf77a6df2e5534cd6f21d82\"\n-\"checksum serde_derive_internals 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"021c338d22c7e30f957a6ab7e388cb6098499dda9fd4ba1661ee074ca7a180d1\"\n+\"checksum serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c2f530d36fb84ec48fb7146936881f026cdbf4892028835fd9398475f82c1bb4\"\n+\"checksum serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"10552fad5500771f3902d0c5ba187c5881942b811b7ba0d8fbbfbf84d80806d3\"\n+\"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n \"checksum serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c10e798e4405d7dcec3658989e35ee6706f730a9ed7c1184d5ebd84317e82f46\"\n \"checksum serde_json 0.9.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad8bcf487be7d2e15d3d543f04312de991d631cfe1b43ea0ade69e6a8a5b16a1\"\n \"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n \"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n \"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n-\"checksum strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"54f86446ab480b4f60782188f4f78886465c5793aee248cbb48b7fdc0d022420\"\n-\"checksum strsim 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"67f84c44fbb2f91db7fef94554e6b2ac05909c9c0b0bc23bb98d3a1aebfe7f7c\"\n+\"checksum strings 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"da75d8bf2c4d210d63dd09581a041b036001f9f6e03d9b151dbff810fb7ba26a\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n \"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n \"checksum syn 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ae6fb0dcc9bd85f89a1a4adc0df2fd90c90c98849d61433983dd7a9df6363f7\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n \"checksum syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e52bffe6202cfb67587784cf23e0ec5bf26d331eef4922a16d5c42e12aa1e9b\"\n-\"checksum syntex_errors 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"867cc5c2d7140ae7eaad2ae9e8bf39cb18a67ca651b7834f88d46ca98faadb9c\"\n \"checksum syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"955ef4b16af4c468e4680d1497f873ff288f557d338180649e18f915af5e15ac\"\n-\"checksum syntex_pos 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"13ad4762fe52abc9f4008e85c4fb1b1fe3aa91ccb99ff4826a439c7c598e1047\"\n \"checksum syntex_syntax 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76a302e717e348aa372ff577791c3832395650073b8d8432f8b3cb170b34afde\"\n-\"checksum syntex_syntax 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6e0e4dbae163dd98989464c23dd503161b338790640e11537686f2ef0f25c791\"\n \"checksum tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"281285b717926caa919ad905ef89c63d75805c7d89437fb873100925a53f2b1b\"\n \"checksum tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"87974a6f5c1dfb344d733055601650059a3363de2a6104819293baff662132d6\"\n \"checksum term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d168af3930b369cfe245132550579d47dfd873d69470755a19c2c6568dbbd989\"\n-\"checksum term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07b6c1ac5b3fffd75073276bca1ceed01f67a28537097a2a9539e116e50fb21a\"\n+\"checksum term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2b6b55df3198cc93372e85dd2ed817f0e38ce8cc0f22eb32391bfad9c4bf209\"\n+\"checksum termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a5193a56b8d82014662c4b933dea6bec851daf018a2b01722e007daaf5f9dca\"\n \"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n \"checksum thread-id 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8df7875b676fddfadffd96deea3b1124e5ede707d4884248931077518cf1f773\"\n \"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n@@ -2141,25 +2151,25 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"736b60249cb25337bc196faa43ee12c705e426f3d55c214d73a4e7be06f92cb4\"\n \"checksum toml 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bd86ad9ebee246fdedd610e0f6d0587b754a3d81438db930a244d0480ed7878f\"\n \"checksum toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4cc5dbfb20a481e64b99eb7ae280859ec76730c7191570ba5edaa962394edb0a\"\n-\"checksum typed-arena 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8e2f9dc90da4f9d66ffc9ad3ead2c7d57582a26f4a3292d2ce7011bd29965100\"\n-\"checksum unicode-bidi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3a078ebdd62c0e71a709c3d53d2af693fe09fe93fbff8344aebe289b78f9032\"\n-\"checksum unicode-normalization 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e28fa37426fceeb5cf8f41ee273faa7c82c47dc8fba5853402841e665fcd86ff\"\n-\"checksum unicode-segmentation 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c3bc443ded17b11305ffffe6b37e2076f328a5a8cb6aa877b1b98f77699e98b5\"\n+\"checksum typed-arena 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5934776c3ac1bea4a9d56620d6bf2d483b20d394e49581db40f187e1118ff667\"\n+\"checksum unicode-bidi 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a6a2c4e3710edd365cd7e78383153ed739fa31af19f9172f72d3575060f5a43a\"\n+\"checksum unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51ccda9ef9efa3f7ef5d91e8f9b83bbe6955f9bf86aec89d5cce2c874625920f\"\n \"checksum unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a8083c594e02b8ae1654ae26f0ade5158b119bd88ad0e8227a5d8fcd72407946\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n \"checksum unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36dff09cafb4ec7c8cf0023eb0b686cb6ce65499116a12201c9e11840ca01beb\"\n \"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n \"checksum unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f2ae5ddb18e1c92664717616dd9549dde73f539f01bd7b77c2edb2446bdff91\"\n-\"checksum url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5ba8a749fb4479b043733416c244fa9d1d3af3d7c23804944651c8a448cb87e\"\n+\"checksum url 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a69a2e36a5e5ed3f3063c8c64a3b028c4d50d689fa6c862abd7cfe65f882595c\"\n \"checksum url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n-\"checksum user32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4ef4711d107b21b410a3a974b1204d9accc8b10dad75d8324b5d755de1617d47\"\n \"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n-\"checksum vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cac5efe5cb0fa14ec2f84f83c701c562ee63f6dcc680861b21d65c682adfb05f\"\n+\"checksum vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e0a7d8bed3178a8fb112199d466eeca9ed09a14ba8ad67718179b4fd5487d0b\"\n+\"checksum vec_map 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"887b5b631c2ad01628bbbaa7dd4c869f80d3186688f8d0b6f58774fbe324988c\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb08f9e670fab86099470b97cd2b252d6527f0b3cc1401acdb595ffc9dd288ff\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\"\n+\"checksum wincolor 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99c2af1426e2166e6f66d88b09b2a4d63afce06875f149174e386f2f1ee9779b\"\n \"checksum ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e\"\n \"checksum xattr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f04de8a1346489a2f9e9bd8526b73d135ec554227b17568456e86aa35b6f3fc\"\n \"checksum xz2 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e9510bdf100731599107c61f77daf46713a69a568f75458999c1f9dbf6ba25b0\""}, {"sha": "9cf6297d463be27873c95629368db651dba8e72d", "filename": "src/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -9,6 +9,7 @@ members = [\n   \"tools/error_index_generator\",\n   \"tools/linkchecker\",\n   \"tools/rustbook\",\n+  \"tools/unstable-book-gen\",\n   \"tools/tidy\",\n   \"tools/build-manifest\",\n   \"tools/remote-test-client\",\n@@ -36,4 +37,4 @@ debug = false\n debug-assertions = false\n \n [replace]\n-\"https://github.com/rust-lang/cargo#0.20.0\" = { path = \"tools/cargo\" }\n+\"https://github.com/rust-lang/cargo#0.21.0\" = { path = \"tools/cargo\" }"}, {"sha": "0d3cc2e0b1b72f014e3a031aa095bd53ae1f6648", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -245,6 +245,9 @@ pub fn compiletest(build: &Build,\n     let llvm_config = build.llvm_config(target);\n     let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n     cmd.arg(\"--llvm-version\").arg(llvm_version);\n+    if !build.is_rust_llvm(target) {\n+        cmd.arg(\"--system-llvm\");\n+    }\n \n     cmd.args(&build.flags.cmd.test_args());\n \n@@ -299,6 +302,10 @@ pub fn compiletest(build: &Build,\n         cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n     }\n \n+    if build.config.profiler {\n+        cmd.env(\"PROFILER_SUPPORT\", \"1\");\n+    }\n+\n     cmd.arg(\"--adb-path\").arg(\"adb\");\n     cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n     if target.contains(\"android\") {\n@@ -563,7 +570,9 @@ fn find_tests(dir: &Path,\n         let filename = e.file_name().into_string().unwrap();\n         if (target.contains(\"windows\") && filename.ends_with(\".exe\")) ||\n            (!target.contains(\"windows\") && !filename.contains(\".\")) ||\n-           (target.contains(\"emscripten\") && filename.ends_with(\".js\")) {\n+           (target.contains(\"emscripten\") &&\n+            filename.ends_with(\".js\") &&\n+            !filename.ends_with(\".asm.js\")) {\n             dst.push(e.path());\n         }\n     }"}, {"sha": "64b2a665e257182aab416b7ce910841a3f8768e7", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -50,6 +50,7 @@ pub struct Config {\n     pub full_bootstrap: bool,\n     pub extended: bool,\n     pub sanitizers: bool,\n+    pub profiler: bool,\n \n     // llvm codegen options\n     pub llvm_assertions: bool,\n@@ -162,6 +163,7 @@ struct Build {\n     extended: Option<bool>,\n     verbose: Option<usize>,\n     sanitizers: Option<bool>,\n+    profiler: Option<bool>,\n     openssl_static: Option<bool>,\n }\n \n@@ -318,6 +320,7 @@ impl Config {\n         set(&mut config.extended, build.extended);\n         set(&mut config.verbose, build.verbose);\n         set(&mut config.sanitizers, build.sanitizers);\n+        set(&mut config.profiler, build.profiler);\n         set(&mut config.openssl_static, build.openssl_static);\n \n         if let Some(ref install) = toml.install {\n@@ -471,6 +474,7 @@ impl Config {\n                 (\"FULL_BOOTSTRAP\", self.full_bootstrap),\n                 (\"EXTENDED\", self.extended),\n                 (\"SANITIZERS\", self.sanitizers),\n+                (\"PROFILER\", self.profiler),\n                 (\"DIST_SRC\", self.rust_dist_src),\n                 (\"CARGO_OPENSSL_STATIC\", self.openssl_static),\n             }"}, {"sha": "3a467dafbfb8dca14669e8bd48d55ccd8d9ad141", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -147,6 +147,9 @@\n # Build the sanitizer runtimes\n #sanitizers = false\n \n+# Build the profiler runtime\n+#profiler = false\n+\n # Indicates whether the OpenSSL linked into Cargo will be statically linked or\n # not. If static linkage is specified then the build system will download a\n # known-good version of OpenSSL, compile it, and link it to Cargo."}, {"sha": "f92e6f50eb3e2047cbaf8b3ab79f96ac307c169b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -376,8 +376,8 @@ pub fn debugger_scripts(build: &Build,\n         install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n             0o755);\n \n+        cp_debugger_script(\"natvis/liballoc.natvis\");\n         cp_debugger_script(\"natvis/libcore.natvis\");\n-        cp_debugger_script(\"natvis/libcollections.natvis\");\n     } else {\n         cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n@@ -570,6 +570,7 @@ pub fn rust_src(build: &Build) {\n         \"src/libgetopts\",\n         \"src/compiler-rt\",\n         \"src/jemalloc\",\n+        \"src/libprofiler_builtins\",\n     ];\n     let std_src_dirs_exclude = [\n         \"src/compiler-rt/test\","}, {"sha": "30f631ca2df646d301e3c7fe562937c2817b67ce", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -27,18 +27,26 @@ use {Build, Compiler, Mode};\n use util::{cp_r, symlink_dir};\n use build_helper::up_to_date;\n \n-/// Invoke `rustbook` as compiled in `stage` for `target` for the doc book\n-/// `name` into the `out` path.\n+/// Invoke `rustbook` for `target` for the doc book `name`.\n ///\n /// This will not actually generate any documentation if the documentation has\n /// already been generated.\n pub fn rustbook(build: &Build, target: &str, name: &str) {\n+    let src = build.src.join(\"src/doc\");\n+    rustbook_src(build, target, name, &src);\n+}\n+\n+/// Invoke `rustbook` for `target` for the doc book `name` from the `src` path.\n+///\n+/// This will not actually generate any documentation if the documentation has\n+/// already been generated.\n+pub fn rustbook_src(build: &Build, target: &str, name: &str, src: &Path) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n \n     let out = out.join(name);\n     let compiler = Compiler::new(0, &build.config.build);\n-    let src = build.src.join(\"src/doc\").join(name);\n+    let src = src.join(name);\n     let index = out.join(\"index.html\");\n     let rustbook = build.tool(&compiler, \"rustbook\");\n     if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n@@ -354,6 +362,19 @@ pub fn error_index(build: &Build, target: &str) {\n     build.run(&mut index);\n }\n \n+pub fn unstable_book_gen(build: &Build, target: &str) {\n+    println!(\"Generating unstable book md files ({})\", target);\n+    let out = build.md_doc_out(target).join(\"unstable-book\");\n+    t!(fs::create_dir_all(&out));\n+    t!(fs::remove_dir_all(&out));\n+    let compiler = Compiler::new(0, &build.config.build);\n+    let mut cmd = build.tool_cmd(&compiler, \"unstable-book-gen\");\n+    cmd.arg(build.src.join(\"src\"));\n+    cmd.arg(out);\n+\n+    build.run(&mut cmd);\n+}\n+\n fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n     if let Ok(m) = fs::symlink_metadata(dst) {\n         if m.file_type().is_dir() {"}, {"sha": "dc9dac73627880b864916fc24816c3a23fd185b5", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -196,9 +196,14 @@ Arguments:\n         ./x.py build\n         ./x.py build --stage 1\n \n-    For a quick build with a usable compile, you can pass:\n+    For a quick build of a usable compiler, you can pass:\n \n-        ./x.py build --stage 1 src/libtest\");\n+        ./x.py build --stage 1 src/libtest\n+\n+    This will first build everything once (like --stage 0 without further\n+    arguments would), and then use the compiler built in stage 0 to build\n+    src/libtest and its dependencies.\n+    Once this is done, build/$ARCH/stage1 contains a usable compiler.\");\n             }\n             \"test\" => {\n                 subcommand_help.push_str(\"\\n\n@@ -237,11 +242,18 @@ Arguments:\n         let cwd = t!(env::current_dir());\n         let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();\n \n+        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n+            if fs::metadata(\"config.toml\").is_ok() {\n+                Some(PathBuf::from(\"config.toml\"))\n+            } else {\n+                None\n+            }\n+        });\n \n         // All subcommands can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n             let flags = Flags::parse(&[\"build\".to_string()]);\n-            let mut config = Config::default();\n+            let mut config = Config::parse(&flags.build, cfg_file.clone());\n             config.build = flags.build.clone();\n             let mut build = Build::new(flags, config);\n             metadata::build(&mut build);\n@@ -302,14 +314,6 @@ Arguments:\n         };\n \n \n-        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n-            if fs::metadata(\"config.toml\").is_ok() {\n-                Some(PathBuf::from(\"config.toml\"))\n-            } else {\n-                None\n-            }\n-        });\n-\n         let mut stage = matches.opt_str(\"stage\").map(|j| j.parse().unwrap());\n \n         if matches.opt_present(\"incremental\") {"}, {"sha": "e0e6583b93598cb1a830a39de5faef766d8ccf08", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -594,6 +594,9 @@ impl Build {\n         if self.config.backtrace {\n             features.push_str(\" backtrace\");\n         }\n+        if self.config.profiler {\n+            features.push_str(\" profiler\");\n+        }\n         return features\n     }\n \n@@ -677,6 +680,11 @@ impl Build {\n         self.out.join(target).join(\"doc\")\n     }\n \n+    /// Output directory for some generated md crate documentation for a target (temporary)\n+    fn md_doc_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"md-doc\")\n+    }\n+\n     /// Output directory for all crate documentation for a target (temporary)\n     ///\n     /// The artifacts here are then copied into `doc_out` above."}, {"sha": "5f0724c657757f0b9ac2a787acdb0cde143b837c", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -463,7 +463,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n          .dep(|s| s.name(\"tool-linkchecker\").stage(0))\n          .dep(|s| s.name(\"default:doc\"))\n-         .default(true)\n+         .default(build.config.docs)\n          .host(true)\n          .run(move |s| check::linkcheck(build, s.target));\n     rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n@@ -548,6 +548,10 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"librustc-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n+    rules.build(\"tool-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n     rules.build(\"tool-tidy\", \"src/tools/tidy\")\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n@@ -662,8 +666,12 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n               .target(&build.config.build)\n               .stage(0)\n          })\n+         .dep(move |s| s.name(\"doc-unstable-book-gen\"))\n          .default(build.config.docs)\n-         .run(move |s| doc::rustbook(build, s.target, \"unstable-book\"));\n+         .run(move |s| doc::rustbook_src(build,\n+                                         s.target,\n+                                         \"unstable-book\",\n+                                         &build.md_doc_out(s.target)));\n     rules.doc(\"doc-standalone\", \"src/doc\")\n          .dep(move |s| {\n              s.name(\"rustc\")\n@@ -679,6 +687,17 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .default(build.config.docs)\n          .host(true)\n          .run(move |s| doc::error_index(build, s.target));\n+    rules.doc(\"doc-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n+         .dep(move |s| {\n+             s.name(\"tool-unstable-book-gen\")\n+              .host(&build.config.build)\n+              .target(&build.config.build)\n+              .stage(0)\n+         })\n+         .dep(move |s| s.name(\"libstd-link\"))\n+         .default(build.config.docs)\n+         .host(true)\n+         .run(move |s| doc::unstable_book_gen(build, s.target));\n     for (krate, path, default) in krates(\"std\") {\n         rules.doc(&krate.doc_step, path)\n              .dep(|s| s.name(\"libstd-link\"))\n@@ -1407,13 +1426,20 @@ mod tests {\n     fn build(args: &[&str],\n              extra_host: &[&str],\n              extra_target: &[&str]) -> Build {\n+        build_(args, extra_host, extra_target, true)\n+    }\n+\n+    fn build_(args: &[&str],\n+              extra_host: &[&str],\n+              extra_target: &[&str],\n+              docs: bool) -> Build {\n         let mut args = args.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n         args.push(\"--build\".to_string());\n         args.push(\"A\".to_string());\n         let flags = Flags::parse(&args);\n \n         let mut config = Config::default();\n-        config.docs = true;\n+        config.docs = docs;\n         config.build = \"A\".to_string();\n         config.host = vec![config.build.clone()];\n         config.host.extend(extra_host.iter().map(|s| s.to_string()));\n@@ -1768,4 +1794,22 @@ mod tests {\n         assert!(!plan.iter().any(|s| s.name.contains(\"tidy\")));\n         assert!(plan.iter().any(|s| s.name.contains(\"valgrind\")));\n     }\n+\n+    #[test]\n+    fn test_disable_docs() {\n+        let build = build_(&[\"test\"], &[], &[], false);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(!plan.iter().any(|s| {\n+            s.name.contains(\"doc-\") || s.name.contains(\"default:doc\")\n+        }));\n+        // none of the dependencies should be a doc rule either\n+        assert!(!plan.iter().any(|s| {\n+            rules.rules[s.name].deps.iter().any(|dep| {\n+                let dep = dep(&rules.sbuild.name(s.name));\n+                dep.name.contains(\"doc-\") || dep.name.contains(\"default:doc\")\n+            })\n+        }));\n+    }\n }"}, {"sha": "899ce1e4569df7bd41a7de302a23f1d42b99b2a2", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,44 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n+\n+# emscripten\n+COPY scripts/emscripten.sh /scripts/\n+RUN bash /scripts/emscripten.sh\n+\n+# env\n+ENV PATH=$PATH:/emsdk-portable\n+ENV PATH=$PATH:/emsdk-portable/clang/e1.37.13_64bit/\n+ENV PATH=$PATH:/emsdk-portable/emscripten/1.37.13/\n+ENV PATH=$PATH:/emsdk-portable/node/4.1.1_64bit/bin/\n+ENV EMSCRIPTEN=/emsdk-portable/emscripten/1.37.13/\n+ENV BINARYEN_ROOT=/emsdk-portable/clang/e1.37.13_64bit/binaryen/\n+ENV EM_CONFIG=/emsdk-portable/.emscripten\n+\n+ENV TARGETS=asmjs-unknown-emscripten\n+\n+ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n+\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+\n+# cache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# init\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "daf398ac0962f805229f66ec9565144fb3e96d6d", "filename": "src/ci/docker/disabled/wasm32/Dockerfile", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,44 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n+\n+# emscripten\n+COPY scripts/emscripten.sh /scripts/\n+RUN bash /scripts/emscripten.sh\n+COPY wasm32/node.sh /usr/local/bin/node\n+\n+# env\n+ENV PATH=$PATH:/emsdk-portable\n+ENV PATH=$PATH:/emsdk-portable/clang/e1.37.13_64bit/\n+ENV PATH=$PATH:/emsdk-portable/emscripten/1.37.13/\n+ENV EMSCRIPTEN=/emsdk-portable/emscripten/1.37.13/\n+ENV BINARYEN_ROOT=/emsdk-portable/clang/e1.37.13_64bit/binaryen/\n+ENV EM_CONFIG=/emsdk-portable/.emscripten\n+\n+ENV TARGETS=wasm32-unknown-emscripten\n+\n+ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n+\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+\n+# cache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# init\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "dfa7f221ffa2022ae0b235b2e4d0ba3c579688f6", "filename": "src/ci/docker/disabled/wasm32/node.sh", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2Fnode.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2Fnode.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2Fnode.sh?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,18 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+path=\"$(dirname $1)\"\n+file=\"$(basename $1)\"\n+\n+shift\n+\n+cd \"$path\"\n+exec /node-v8.0.0-linux-x64/bin/node \"$file\" \"$@\""}, {"sha": "9145e9dfc8d1a5fbe50babebdb05e93536efd30c", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -90,7 +90,8 @@ ENV HOSTS=i686-unknown-linux-gnu\n ENV RUST_CONFIGURE_ARGS \\\n       --host=$HOSTS \\\n       --enable-extended \\\n-      --enable-sanitizers\n+      --enable-sanitizers \\\n+      --enable-profiler\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "78b62839a35d5a14604b621851a282f576664a73", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -90,7 +90,8 @@ ENV HOSTS=x86_64-unknown-linux-gnu\n ENV RUST_CONFIGURE_ARGS \\\n       --host=$HOSTS \\\n       --enable-extended \\\n-      --enable-sanitizers\n+      --enable-sanitizers \\\n+      --enable-profiler\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "0f0e5b69c32cf787d2a2fafb6dacbd370bce6c7a", "filename": "src/ci/docker/emscripten/Dockerfile", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fci%2Fdocker%2Femscripten%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fci%2Fdocker%2Femscripten%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Femscripten%2FDockerfile?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,41 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils \\\n-  lib32stdc++6\n-\n-RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl && \\\n-      chmod +x /usr/local/bin/sccache\n-\n-RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n-    dpkg -i dumb-init_*.deb && \\\n-    rm dumb-init_*.deb\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n-WORKDIR /tmp\n-COPY emscripten/build-emscripten.sh /tmp/\n-RUN ./build-emscripten.sh\n-ENV PATH=$PATH:/tmp/emsdk_portable\n-ENV PATH=$PATH:/tmp/emsdk_portable/clang/tag-e1.37.10/build_tag-e1.37.10_32/bin\n-ENV PATH=$PATH:/tmp/emsdk_portable/node/4.1.1_32bit/bin\n-ENV PATH=$PATH:/tmp/emsdk_portable/emscripten/tag-1.37.10\n-ENV EMSCRIPTEN=/tmp/emsdk_portable/emscripten/tag-1.37.10\n-\n-ENV RUST_CONFIGURE_ARGS --target=asmjs-unknown-emscripten\n-\n-# Run `emcc` first as it's got a prompt and doesn't actually do anything, after\n-# that's done with do the real build.\n-ENV SCRIPT emcc && \\\n-      python2.7 ../x.py test --target asmjs-unknown-emscripten\n-"}, {"sha": "8d6a28f418bf955b8d75b049d33f49794630e538", "filename": "src/ci/docker/emscripten/build-emscripten.sh", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fci%2Fdocker%2Femscripten%2Fbuild-emscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fci%2Fdocker%2Femscripten%2Fbuild-emscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Femscripten%2Fbuild-emscripten.sh?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,53 +0,0 @@\n-#!/bin/bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-\n-hide_output() {\n-  set +x\n-  on_err=\"\n-echo ERROR: An error was encountered with the build.\n-cat /tmp/build.log\n-exit 1\n-\"\n-  trap \"$on_err\" ERR\n-  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n-  PING_LOOP_PID=$!\n-  $@ &> /tmp/build.log\n-  trap - ERR\n-  kill $PING_LOOP_PID\n-  rm /tmp/build.log\n-  set -x\n-}\n-\n-curl https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz | \\\n-    tar xzf -\n-\n-# Some versions of the EMSDK archive have their contents in .emsdk-portable\n-# and others in emsdk_portable. Make sure the EMSDK ends up in a fixed path.\n-if [ -d emsdk-portable ]; then\n-    mv emsdk-portable emsdk_portable\n-fi\n-\n-if [ ! -d emsdk_portable ]; then\n-    echo \"ERROR: Invalid emsdk archive. Dumping working directory.\" >&2\n-    ls -l\n-    exit 1\n-fi\n-\n-# Some versions of the EMSDK set the permissions of the root directory to\n-# 0700. Ensure the directory is readable by all users.\n-chmod 755 emsdk_portable\n-\n-source emsdk_portable/emsdk_env.sh\n-hide_output emsdk update\n-hide_output emsdk install --build=Release sdk-tag-1.37.10-32bit\n-hide_output emsdk activate --build=Release sdk-tag-1.37.10-32bit"}, {"sha": "8aa5a98d7fc5296d6eb6b3893e9d88fa81725bc3", "filename": "src/ci/docker/scripts/emscripten.sh", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,53 @@\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  rm -f /tmp/build.log\n+  set -x\n+}\n+\n+cd /\n+curl -L https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz | \\\n+    tar -xz\n+\n+cd /emsdk-portable\n+./emsdk update\n+hide_output ./emsdk install sdk-1.37.13-64bit\n+./emsdk activate sdk-1.37.13-64bit\n+\n+# Compile and cache libc\n+source ./emsdk_env.sh\n+echo \"main(){}\" > a.c\n+HOME=/emsdk-portable/ emcc a.c\n+HOME=/emsdk-portable/ emcc -s BINARYEN=1 a.c\n+rm -f a.*\n+\n+# Make emsdk usable by any user\n+cp /root/.emscripten /emsdk-portable\n+chmod a+rxw -R /emsdk-portable\n+\n+# node 8 is required to run wasm\n+cd /\n+curl -L https://nodejs.org/dist/v8.0.0/node-v8.0.0-linux-x64.tar.xz | \\\n+    tar -xJ"}, {"sha": "0bbbded57f27d23c1828cafcda0e4bfd5f040370", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -22,5 +22,5 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n     rm dumb-init_*.deb\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-sanitizers\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-sanitizers --enable-profiler\n ENV SCRIPT python2.7 ../x.py test"}, {"sha": "817ed8dd55437e08338e54b1e00b8ac320609d14", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -22,9 +22,6 @@ REPO_DIR=\"$1\"\n CACHE_DIR=\"$2\"\n \n cache_src_dir=\"$CACHE_DIR/src\"\n-# If the layout of the cache directory changes, bump the number here\n-# (and anywhere else this file is referenced) so the cache is wiped\n-cache_valid_file=\"$CACHE_DIR/cache_valid1\"\n \n if [ ! -d \"$REPO_DIR\" -o ! -d \"$REPO_DIR/.git\" ]; then\n     echo \"Error: $REPO_DIR does not exist or is not a git repo\"\n@@ -36,47 +33,19 @@ if [ ! -d \"$CACHE_DIR\" ]; then\n     exit 1\n fi\n \n-# Wipe the cache if it's not valid, or mark it as invalid while we update it\n-if [ ! -f \"$cache_valid_file\" ]; then\n-    echo \"Invalid cache, wiping ($cache_valid_file missing)\"\n-    rm -rf \"$CACHE_DIR\"\n-    mkdir \"$CACHE_DIR\"\n-else\n-    # Ignore errors while gathering information about the possible brokenness\n-    # of the git repo since our gathered info will tell us something is wrong\n-    set +o errexit\n-    stat_lines=$(cd \"$cache_src_dir\" && git status --porcelain | wc -l)\n-    stat_ec=$(cd \"$cache_src_dir\" && git status >/dev/null 2>&1; echo $?)\n-    set -o errexit\n-    if [ ! -d \"$cache_src_dir/.git\" -o $stat_lines != 0 -o $stat_ec != 0 ]; then\n-        # Something is badly wrong - the cache valid file is here, but something\n-        # about the git repo is fishy. Nuke it all, just in case\n-        echo \"WARNING: $cache_valid_file exists but bad repo: l:$stat_lines, ec:$stat_ec\"\n-        rm -rf \"$CACHE_DIR\"\n-        mkdir \"$CACHE_DIR\"\n-    else\n-        echo \"Valid cache ($cache_valid_file exists)\"\n-        rm \"$cache_valid_file\"\n-    fi\n-fi\n+rm -rf \"$CACHE_DIR\"\n+mkdir \"$CACHE_DIR\"\n \n travis_fold start update_cache\n travis_time_start\n \n # Update the cache (a pristine copy of the rust source master)\n-if [ ! -d \"$cache_src_dir/.git\" ]; then\n-    retry sh -c \"rm -rf $cache_src_dir && mkdir -p $cache_src_dir && \\\n-        git clone https://github.com/rust-lang/rust.git $cache_src_dir\"\n-fi\n-retry sh -c \"cd $cache_src_dir && git reset --hard && git pull\"\n+retry sh -c \"rm -rf $cache_src_dir && mkdir -p $cache_src_dir && \\\n+    git clone --depth 1 https://github.com/rust-lang/rust.git $cache_src_dir\"\n (cd $cache_src_dir && git rm src/llvm)\n retry sh -c \"cd $cache_src_dir && \\\n     git submodule deinit -f . && git submodule sync && git submodule update --init\"\n \n-# Cache was updated without errors, mark it as valid\n-echo \"Refreshed cache (touch $cache_valid_file)\"\n-touch \"$cache_valid_file\"\n-\n travis_fold end update_cache\n travis_time_finish\n "}, {"sha": "325c3da0814f44916bef00ff225f934f2d613203", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1 +1 @@\n-Subproject commit f746084b099060f55ac5e7d8050797593fcedd6e\n+Subproject commit 325c3da0814f44916bef00ff225f934f2d613203"}, {"sha": "78432b6a9659370cac1ae373770e795f0b8469b7", "filename": "src/doc/grammar.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -154,19 +154,19 @@ token : simple_token | ident | literal | symbol | whitespace token ;\n \n <p id=\"keyword-table-marker\"></p>\n \n-|          |          |          |          |         |\n-|----------|----------|----------|----------|---------|\n-| abstract | alignof  | as       | become   | box     |\n-| break    | const    | continue | crate    | do      |\n-| else     | enum     | extern   | false    | final   |\n-| fn       | for      | if       | impl     | in      |\n-| let      | loop     | macro    | match    | mod     |\n-| move     | mut      | offsetof | override | priv    |\n-| proc     | pub      | pure     | ref      | return  |\n-| Self     | self     | sizeof   | static   | struct  |\n-| super    | trait    | true     | type     | typeof  |\n-| unsafe   | unsized  | use      | virtual  | where   |\n-| while    | yield    |          |          |         |\n+|          |          |          |          |          |\n+|----------|----------|----------|----------|----------|\n+| _        | abstract | alignof  | as       | become   |\n+| box      | break    | const    | continue | crate    |\n+| do       | else     | enum     | extern   | false    |\n+| final    | fn       | for      | if       | impl     |\n+| in       | let      | loop     | macro    | match    |\n+| mod      | move     | mut      | offsetof | override |\n+| priv     | proc     | pub      | pure     | ref      |\n+| return   | Self     | self     | sizeof   | static   |\n+| struct   | super    | trait    | true     | type     |\n+| typeof   | unsafe   | unsized  | use      | virtual  |\n+| where    | while    | yield    |          |          |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are"}, {"sha": "2b3ef338fad5860605a9b04b64a9e607e242136b", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,222 +0,0 @@\n-[The Unstable Book](the-unstable-book.md)\n-\n-- [Compiler flags](compiler-flags.md)\n-    - [linker_flavor](compiler-flags/linker-flavor.md)\n-    - [remap_path_prefix](compiler-flags/remap-path-prefix.md)\n-- [Language features](language-features.md)\n-    - [abi_msp430_interrupt](language-features/abi-msp430-interrupt.md)\n-    - [abi_ptx](language-features/abi-ptx.md)\n-    - [abi_sysv64](language-features/abi-sysv64.md)\n-    - [abi_thiscall](language-features/abi-thiscall.md)\n-    - [abi_unadjusted](language-features/abi-unadjusted.md)\n-    - [abi_vectorcall](language-features/abi-vectorcall.md)\n-    - [abi_x86_interrupt](language-features/abi-x86-interrupt.md)\n-    - [advanced_slice_patterns](language-features/advanced-slice-patterns.md)\n-    - [allocator](language-features/allocator.md)\n-    - [allow_internal_unstable](language-features/allow-internal-unstable.md)\n-    - [asm](language-features/asm.md)\n-    - [associated_consts](language-features/associated-consts.md)\n-    - [associated_type_defaults](language-features/associated-type-defaults.md)\n-    - [attr_literals](language-features/attr-literals.md)\n-    - [box_patterns](language-features/box-patterns.md)\n-    - [box_syntax](language-features/box-syntax.md)\n-    - [catch_expr](language-features/catch-expr.md)\n-    - [cfg_target_feature](language-features/cfg-target-feature.md)\n-    - [cfg_target_has_atomic](language-features/cfg-target-has-atomic.md)\n-    - [cfg_target_thread_local](language-features/cfg-target-thread-local.md)\n-    - [cfg_target_vendor](language-features/cfg-target-vendor.md)\n-    - [compiler_builtins](language-features/compiler-builtins.md)\n-    - [concat_idents](language-features/concat-idents.md)\n-    - [conservative_impl_trait](language-features/conservative-impl-trait.md)\n-    - [const_fn](language-features/const-fn.md)\n-    - [const_indexing](language-features/const-indexing.md)\n-    - [custom_attribute](language-features/custom-attribute.md)\n-    - [custom_derive](language-features/custom-derive.md)\n-    - [default_type_parameter_fallback](language-features/default-type-parameter-fallback.md)\n-    - [drop_types_in_const](language-features/drop-types-in-const.md)\n-    - [dropck_eyepatch](language-features/dropck-eyepatch.md)\n-    - [dropck_parametricity](language-features/dropck-parametricity.md)\n-    - [exclusive_range_pattern](language-features/exclusive-range-pattern.md)\n-    - [fundamental](language-features/fundamental.md)\n-    - [generic_param_attrs](language-features/generic-param-attrs.md)\n-    - [global_asm](language-features/global_asm.md)\n-    - [i128_type](language-features/i128-type.md)\n-    - [inclusive_range_syntax](language-features/inclusive-range-syntax.md)\n-    - [intrinsics](language-features/intrinsics.md)\n-    - [lang_items](language-features/lang-items.md)\n-    - [link_args](language-features/link-args.md)\n-    - [link_cfg](language-features/link-cfg.md)\n-    - [link_llvm_intrinsics](language-features/link-llvm-intrinsics.md)\n-    - [linkage](language-features/linkage.md)\n-    - [log_syntax](language-features/log-syntax.md)\n-    - [macro_reexport](language-features/macro-reexport.md)\n-    - [macro_vis_matcher](language-features/macro-vis-matcher.md)\n-    - [main](language-features/main.md)\n-    - [naked_functions](language-features/naked-functions.md)\n-    - [needs_allocator](language-features/needs-allocator.md)\n-    - [needs_panic_runtime](language-features/needs-panic-runtime.md)\n-    - [never_type](language-features/never-type.md)\n-    - [no_core](language-features/no-core.md)\n-    - [no_debug](language-features/no-debug.md)\n-    - [non_ascii_idents](language-features/non-ascii-idents.md)\n-    - [omit_gdb_pretty_printer_section](language-features/omit-gdb-pretty-printer-section.md)\n-    - [on_unimplemented](language-features/on-unimplemented.md)\n-    - [optin_builtin_traits](language-features/optin-builtin-traits.md)\n-    - [overlapping_marker_traits](language-features/overlapping-marker-traits.md)\n-    - [panic_runtime](language-features/panic-runtime.md)\n-    - [placement_in_syntax](language-features/placement-in-syntax.md)\n-    - [platform_intrinsics](language-features/platform-intrinsics.md)\n-    - [plugin](language-features/plugin.md)\n-    - [plugin_registrar](language-features/plugin-registrar.md)\n-    - [prelude_import](language-features/prelude-import.md)\n-    - [proc_macro](language-features/proc-macro.md)\n-    - [quote](language-features/quote.md)\n-    - [repr_align](language-features/repr-align.md)\n-    - [repr_simd](language-features/repr-simd.md)\n-    - [rustc_attrs](language-features/rustc-attrs.md)\n-    - [rustc_diagnostic_macros](language-features/rustc-diagnostic-macros.md)\n-    - [rvalue_static_promotion](language-features/rvalue-static-promotion.md)\n-    - [sanitizer_runtime](language-features/sanitizer-runtime.md)\n-    - [simd](language-features/simd.md)\n-    - [simd_ffi](language-features/simd-ffi.md)\n-    - [slice_patterns](language-features/slice-patterns.md)\n-    - [specialization](language-features/specialization.md)\n-    - [staged_api](language-features/staged-api.md)\n-    - [start](language-features/start.md)\n-    - [static_nobundle](language-features/static-nobundle.md)\n-    - [stmt_expr_attributes](language-features/stmt-expr-attributes.md)\n-    - [struct_field_attributes](language-features/struct-field-attributes.md)\n-    - [structural_match](language-features/structural-match.md)\n-    - [target_feature](language-features/target-feature.md)\n-    - [thread_local](language-features/thread-local.md)\n-    - [trace_macros](language-features/trace-macros.md)\n-    - [type_ascription](language-features/type-ascription.md)\n-    - [unboxed_closures](language-features/unboxed-closures.md)\n-    - [untagged_unions](language-features/untagged-unions.md)\n-    - [unwind_attributes](language-features/unwind-attributes.md)\n-    - [use_extern_macros](language-features/use-extern-macros.md)\n-    - [used](language-features/used.md)\n-- [Library Features](library-features.md)\n-    - [alloc_jemalloc](library-features/alloc-jemalloc.md)\n-    - [alloc_system](library-features/alloc-system.md)\n-    - [alloc](library-features/alloc.md)\n-    - [as_c_str](library-features/as-c-str.md)\n-    - [ascii_ctype](library-features/ascii-ctype.md)\n-    - [box_heap](library-features/box-heap.md)\n-    - [c_void_variant](library-features/c-void-variant.md)\n-    - [char_escape_debug](library-features/char-escape-debug.md)\n-    - [coerce_unsized](library-features/coerce-unsized.md)\n-    - [collection_placement](library-features/collection-placement.md)\n-    - [collections_range](library-features/collections-range.md)\n-    - [collections](library-features/collections.md)\n-    - [command_envs](library-features/command-envs.md)\n-    - [compiler_builtins_lib](library-features/compiler-builtins-lib.md)\n-    - [compiler_fences](library-features/compiler-fences.md)\n-    - [concat_idents_macro](library-features/concat-idents-macro.md)\n-    - [core_char_ext](library-features/core-char-ext.md)\n-    - [core_float](library-features/core-float.md)\n-    - [core_intrinsics](library-features/core-intrinsics.md)\n-    - [core_panic](library-features/core-panic.md)\n-    - [core_private_bignum](library-features/core-private-bignum.md)\n-    - [core_private_diy_float](library-features/core-private-diy-float.md)\n-    - [core_slice_ext](library-features/core-slice-ext.md)\n-    - [core_str_ext](library-features/core-str-ext.md)\n-    - [dec2flt](library-features/dec2flt.md)\n-    - [decode_utf8](library-features/decode-utf8.md)\n-    - [derive_clone_copy](library-features/derive-clone-copy.md)\n-    - [derive_eq](library-features/derive-eq.md)\n-    - [discriminant_value](library-features/discriminant-value.md)\n-    - [error_type_id](library-features/error-type-id.md)\n-    - [exact_size_is_empty](library-features/exact-size-is-empty.md)\n-    - [fd](library-features/fd.md)\n-    - [fd_read](library-features/fd-read.md)\n-    - [fixed_size_array](library-features/fixed-size-array.md)\n-    - [float_bits_conv](library-features/float-bits-conv.md)\n-    - [flt2dec](library-features/flt2dec.md)\n-    - [fmt_flags_align](library-features/fmt-flags-align.md)\n-    - [fmt_internals](library-features/fmt-internals.md)\n-    - [fn_traits](library-features/fn-traits.md)\n-    - [fnbox](library-features/fnbox.md)\n-    - [from_utf8_error_as_bytes](library-features/from_utf8_error_as_bytes.md)\n-    - [fused](library-features/fused.md)\n-    - [future_atomic_orderings](library-features/future-atomic-orderings.md)\n-    - [get_type_id](library-features/get-type-id.md)\n-    - [heap_api](library-features/heap-api.md)\n-    - [hint_core_should_pause](library-features/hint-core-should-pause.md)\n-    - [i128](library-features/i128.md)\n-    - [inclusive_range](library-features/inclusive-range.md)\n-    - [integer_atomics](library-features/integer-atomics.md)\n-    - [into_boxed_c_str](library-features/into-boxed-c-str.md)\n-    - [into_boxed_os_str](library-features/into-boxed-os-str.md)\n-    - [into_boxed_path](library-features/into-boxed-path.md)\n-    - [io_error_internals](library-features/io-error-internals.md)\n-    - [io](library-features/io.md)\n-    - [ip](library-features/ip.md)\n-    - [iter_rfind](library-features/iter-rfind.md)\n-    - [iterator_step_by](library-features/iterator-step-by.md)\n-    - [libstd_io_internals](library-features/libstd-io-internals.md)\n-    - [libstd_sys_internals](library-features/libstd-sys-internals.md)\n-    - [libstd_thread_internals](library-features/libstd-thread-internals.md)\n-    - [linked_list_extras](library-features/linked-list-extras.md)\n-    - [lookup_host](library-features/lookup-host.md)\n-    - [manually_drop](library-features/manually-drop.md)\n-    - [more_io_inner_methods](library-features/more-io-inner-methods.md)\n-    - [mpsc_select](library-features/mpsc-select.md)\n-    - [n16](library-features/n16.md)\n-    - [never_type_impls](library-features/never-type-impls.md)\n-    - [nonzero](library-features/nonzero.md)\n-    - [offset_to](library-features/offset-to.md)\n-    - [once_poison](library-features/once-poison.md)\n-    - [oom](library-features/oom.md)\n-    - [option_entry](library-features/option-entry.md)\n-    - [osstring_shrink_to_fit](library-features/osstring-shrink-to-fit.md)\n-    - [panic_abort](library-features/panic-abort.md)\n-    - [panic_unwind](library-features/panic-unwind.md)\n-    - [pattern](library-features/pattern.md)\n-    - [placement_in](library-features/placement-in.md)\n-    - [placement_new_protocol](library-features/placement-new-protocol.md)\n-    - [print_internals](library-features/print-internals.md)\n-    - [proc_macro_internals](library-features/proc-macro-internals.md)\n-    - [question_mark_carrier](library-features/question-mark-carrier.md)\n-    - [rand](library-features/rand.md)\n-    - [range_contains](library-features/range-contains.md)\n-    - [raw](library-features/raw.md)\n-    - [reverse_cmp_key](library-features/reverse-cmp-key.md)\n-    - [rt](library-features/rt.md)\n-    - [rustc_private](library-features/rustc-private.md)\n-    - [sanitizer_runtime_lib](library-features/sanitizer-runtime-lib.md)\n-    - [set_stdio](library-features/set-stdio.md)\n-    - [shared](library-features/shared.md)\n-    - [sip_hash_13](library-features/sip-hash-13.md)\n-    - [slice_concat_ext](library-features/slice-concat-ext.md)\n-    - [slice_get_slice](library-features/slice-get-slice.md)\n-    - [slice_rotate](library-features/slice-rotate.md)\n-    - [slice_rsplit](library-features/slice-rsplit.md)\n-    - [sort_internals](library-features/sort-internals.md)\n-    - [sort_unstable](library-features/sort-unstable.md)\n-    - [splice](library-features/splice.md)\n-    - [step_by](library-features/step-by.md)\n-    - [step_trait](library-features/step-trait.md)\n-    - [str_checked_slicing](library-features/str-checked-slicing.md)\n-    - [str_escape](library-features/str-escape.md)\n-    - [str_internals](library-features/str-internals.md)\n-    - [str_box_extras](library-features/str-box-extras.md)\n-    - [str_mut_extras](library-features/str-mut-extras.md)\n-    - [test](library-features/test.md)\n-    - [thread_id](library-features/thread-id.md)\n-    - [thread_local_internals](library-features/thread-local-internals.md)\n-    - [thread_local_state](library-features/thread-local-state.md)\n-    - [toowned_clone_into](library-features/toowned-clone-into.md)\n-    - [trusted_len](library-features/trusted-len.md)\n-    - [try_from](library-features/try-from.md)\n-    - [try_trait](library-features/try-trait.md)\n-    - [unicode](library-features/unicode.md)\n-    - [unique](library-features/unique.md)\n-    - [unsize](library-features/unsize.md)\n-    - [utf8_error_error_len](library-features/utf8-error-error-len.md)\n-    - [vec_resize_default](library-features/vec-resize-default.md)\n-    - [vec_remove_item](library-features/vec-remove-item.md)\n-    - [windows_c](library-features/windows-c.md)\n-    - [windows_handle](library-features/windows-handle.md)\n-    - [windows_net](library-features/windows-net.md)\n-    - [windows_stdio](library-features/windows-stdio.md)"}, {"sha": "66d14fd09978fb631ec7a8efecc143a38db0497c", "filename": "src/doc/unstable-book/src/compiler-flags/profile.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,21 @@\n+# `profile`\n+\n+The tracking issue for this feature is: [#42524](https://github.com/rust-lang/rust/issues/42524).\n+\n+------------------------\n+\n+This feature allows the generation of code coverage reports.\n+\n+Set the `-Zprofile` compiler flag in order to enable gcov profiling.\n+\n+For example:\n+```Bash\n+cargo new testgcov --bin\n+cd testgcov\n+export RUSTFLAGS=\"-Zprofile\"\n+cargo build\n+cargo run\n+```\n+\n+Once you've built and run your program, files with the `gcno` (after build) and `gcda` (after execution) extensions will be created.\n+You can parse them with [llvm-cov gcov](http://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov) or [grcov](https://github.com/marco-c/grcov)."}, {"sha": "27f61d56342cf786aaed6548c852d338b86f0e4f", "filename": "src/doc/unstable-book/src/language-features/abi-sysv64.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-sysv64.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-sysv64.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-sysv64.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `abi_sysv64`\n-\n-The tracking issue for this feature is: [#36167]\n-\n-[#36167]: https://github.com/rust-lang/rust/issues/36167\n-\n-------------------------"}, {"sha": "2e3113abdbf2bcff759c868dede0d62d16a4392a", "filename": "src/doc/unstable-book/src/language-features/abi-unadjusted.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-unadjusted.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-unadjusted.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-unadjusted.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `abi_unadjusted`\n-\n-The tracking issue for this feature is: none.\n-\n-------------------------\n-"}, {"sha": "3e36b1569fd4a4c8ad846316cdfb37ca199e7fa8", "filename": "src/doc/unstable-book/src/language-features/abi-vectorcall.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-vectorcall.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-vectorcall.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-vectorcall.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `abi_vectorcall`\n-\n-The tracking issue for this feature is: none.\n-\n-------------------------\n-\n-"}, {"sha": "c89d2ee2106c91d7e1b4f9148905d35c7251b485", "filename": "src/doc/unstable-book/src/language-features/abi-x86-interrupt.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-x86-interrupt.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-x86-interrupt.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-x86-interrupt.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `abi_x86_interrupt`\n-\n-The tracking issue for this feature is: [#40180]\n-\n-[#40180]: https://github.com/rust-lang/rust/issues/40180\n-\n-------------------------"}, {"sha": "74709ad5aeb4dedad1e77836a93e88031d08e43f", "filename": "src/doc/unstable-book/src/language-features/allow-internal-unstable.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallow-internal-unstable.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallow-internal-unstable.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallow-internal-unstable.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `allow_internal_unstable`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "f22095fe5de2e632bdcaae4142b204b744815748", "filename": "src/doc/unstable-book/src/language-features/asm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -190,4 +190,4 @@ constraints, etc.\n [llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n \n If you need more power and don't mind losing some of the niceties of\n-`asm!`, check out [global_asm](language-features/global_asm.html).\n+`asm!`, check out [global_asm](language-features/global-asm.html)."}, {"sha": "56cc8a5b3060aac34be6ea9bd100e74ef1dd7254", "filename": "src/doc/unstable-book/src/language-features/associated-type-defaults.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fassociated-type-defaults.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fassociated-type-defaults.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fassociated-type-defaults.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `associated_type_defaults`\n-\n-The tracking issue for this feature is: [#29661]\n-\n-[#29661]: https://github.com/rust-lang/rust/issues/29661\n-\n-------------------------\n-\n-\n-"}, {"sha": "ddd88bdc2cb17e257db75a708b4a7f0c87534f10", "filename": "src/doc/unstable-book/src/language-features/cfg-target-feature.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-feature.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-feature.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-feature.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `cfg_target_feature`\n-\n-The tracking issue for this feature is: [#29717]\n-\n-[#29717]: https://github.com/rust-lang/rust/issues/29717\n-\n-------------------------\n-\n-\n-"}, {"sha": "7496e42e1cd84a6e3d3955146a9c9ec286d75c30", "filename": "src/doc/unstable-book/src/language-features/cfg-target-has-atomic.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-has-atomic.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-has-atomic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-has-atomic.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `cfg_target_has_atomic`\n-\n-The tracking issue for this feature is: [#32976]\n-\n-[#32976]: https://github.com/rust-lang/rust/issues/32976\n-\n-------------------------\n-\n-\n-"}, {"sha": "a5adb38db3df0040ce42fbbc9853b37d284b0ef8", "filename": "src/doc/unstable-book/src/language-features/cfg-target-thread-local.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-thread-local.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-thread-local.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-thread-local.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `cfg_target_thread_local`\n-\n-The tracking issue for this feature is: [#29594]\n-\n-[#29594]: https://github.com/rust-lang/rust/issues/29594\n-\n-------------------------\n-\n-\n-"}, {"sha": "ddd88bdc2cb17e257db75a708b4a7f0c87534f10", "filename": "src/doc/unstable-book/src/language-features/cfg-target-vendor.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-vendor.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-vendor.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-target-vendor.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `cfg_target_feature`\n-\n-The tracking issue for this feature is: [#29717]\n-\n-[#29717]: https://github.com/rust-lang/rust/issues/29717\n-\n-------------------------\n-\n-\n-"}, {"sha": "838f09670d2cd2cd6d079133134597dbbf1b6d1b", "filename": "src/doc/unstable-book/src/language-features/custom-attribute.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-attribute.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `custom_attribute`\n-\n-The tracking issue for this feature is: [#29642]\n-\n-[#29642]: https://github.com/rust-lang/rust/issues/29642\n-\n-------------------------\n-\n-\n-"}, {"sha": "d5fdd2b708bb8c5c869d610ee017e096f8cec28a", "filename": "src/doc/unstable-book/src/language-features/custom-derive.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-derive.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-derive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-derive.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `custom_derive`\n-\n-The tracking issue for this feature is: [#29644]\n-\n-[#29644]: https://github.com/rust-lang/rust/issues/29644\n-\n-------------------------\n-\n-\n-"}, {"sha": "4700b252e2d1af63e4fee26986d127995cfc797b", "filename": "src/doc/unstable-book/src/language-features/decl-macro.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `decl_macro`\n-\n-The tracking issue for this feature is: [#39412]\n-\n-[#39412]: https://github.com/rust-lang/rust/issues/39412\n-\n-------------------------\n-\n-\n-"}, {"sha": "fd16dbf898537141e0c2a5412b9c36ae8d8be119", "filename": "src/doc/unstable-book/src/language-features/default-type-parameter-fallback.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdefault-type-parameter-fallback.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdefault-type-parameter-fallback.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdefault-type-parameter-fallback.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `default_type_parameter_fallback`\n-\n-The tracking issue for this feature is: [#27336]\n-\n-[#27336]: https://github.com/rust-lang/rust/issues/27336\n-\n-------------------------\n-\n-\n-"}, {"sha": "b3367d0df4459f877259ad9676003c9d275a3ad3", "filename": "src/doc/unstable-book/src/language-features/drop-types-in-const.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdrop-types-in-const.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdrop-types-in-const.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdrop-types-in-const.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `drop_types_in_const`\n-\n-The tracking issue for this feature is: [#33156]\n-\n-[#33156]: https://github.com/rust-lang/rust/issues/33156\n-\n-------------------------\n-\n-\n-"}, {"sha": "2f189e9b6454ad6707197b0f0925d38c4d8d3c13", "filename": "src/doc/unstable-book/src/language-features/dropck-eyepatch.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdropck-eyepatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdropck-eyepatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdropck-eyepatch.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `dropck_eyepatch`\n-\n-The tracking issue for this feature is: [#34761]\n-\n-[#34761]: https://github.com/rust-lang/rust/issues/34761\n-\n-------------------------\n-\n-\n-"}, {"sha": "c5ae721954b82c11ae19ecec4786fd90ef2b21b6", "filename": "src/doc/unstable-book/src/language-features/dropck-parametricity.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdropck-parametricity.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdropck-parametricity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdropck-parametricity.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `dropck_parametricity`\n-\n-The tracking issue for this feature is: [#28498]\n-\n-[#28498]: https://github.com/rust-lang/rust/issues/28498\n-\n-------------------------\n-\n-\n-"}, {"sha": "b669ce83132d460ea5e9c8f569721e30dfd6698e", "filename": "src/doc/unstable-book/src/language-features/exclusive-range-pattern.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexclusive-range-pattern.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexclusive-range-pattern.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexclusive-range-pattern.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `exclusive_range_pattern`\n-\n-The tracking issue for this feature is: [#37854]\n-\n-[#37854]: https://github.com/rust-lang/rust/issues/37854\n-\n-------------------------\n-\n-\n-"}, {"sha": "a068dadf95d12fef85e97707b2bba1e79415b82b", "filename": "src/doc/unstable-book/src/language-features/fundamental.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffundamental.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffundamental.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffundamental.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `fundamental`\n-\n-The tracking issue for this feature is: [#29635]\n-\n-[#29635]: https://github.com/rust-lang/rust/issues/29635\n-\n-------------------------\n-\n-\n-"}, {"sha": "ba49c850e4d600cf14d780a301e7b73e68fab0e6", "filename": "src/doc/unstable-book/src/language-features/generic-param-attrs.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgeneric-param-attrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgeneric-param-attrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgeneric-param-attrs.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `generic_param_attrs`\n-\n-The tracking issue for this feature is: [#34761]\n-\n-[#34761]: https://github.com/rust-lang/rust/issues/34761\n-\n-------------------------\n-\n-\n-"}, {"sha": "f1ef74a63b513acedd4ff96396812640b451ac9b", "filename": "src/doc/unstable-book/src/language-features/global-asm.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-asm.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/doc/unstable-book/src/language-features/global_asm.md"}, {"sha": "7393d0628e4f5b716a2135c801921e33ae0ef195", "filename": "src/doc/unstable-book/src/language-features/link-cfg.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-cfg.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `link_cfg`\n-\n-The tracking issue for this feature is: [#37406]\n-\n-[#37406]: https://github.com/rust-lang/rust/issues/37406\n-\n-------------------------\n-\n-\n-"}, {"sha": "ba639cb57fc6d2e9ccab9b14bcd05192650ca079", "filename": "src/doc/unstable-book/src/language-features/link-llvm-intrinsics.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-llvm-intrinsics.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-llvm-intrinsics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flink-llvm-intrinsics.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `link_llvm_intrinsics`\n-\n-The tracking issue for this feature is: [#29602]\n-\n-[#29602]: https://github.com/rust-lang/rust/issues/29602\n-\n-------------------------\n-\n-\n-"}, {"sha": "5773d28a00ecc2cc7e9e52438331d74972c9f32d", "filename": "src/doc/unstable-book/src/language-features/linkage.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flinkage.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flinkage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flinkage.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `linkage`\n-\n-The tracking issue for this feature is: [#29603]\n-\n-[#29603]: https://github.com/rust-lang/rust/issues/29603\n-\n-------------------------\n-\n-\n-"}, {"sha": "b13f5ccfd9179a343bc9813f6768b4aee86a8fb1", "filename": "src/doc/unstable-book/src/language-features/log-syntax.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flog-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flog-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flog-syntax.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `log_syntax`\n-\n-The tracking issue for this feature is: [#29598]\n-\n-[#29598]: https://github.com/rust-lang/rust/issues/29598\n-\n-------------------------\n-\n-\n-"}, {"sha": "32ffa3b4c31e52a9dce64323578f35da6821ee5d", "filename": "src/doc/unstable-book/src/language-features/macro-reexport.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-reexport.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-reexport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-reexport.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `macro_reexport`\n-\n-The tracking issue for this feature is: [#29638]\n-\n-[#29638]: https://github.com/rust-lang/rust/issues/29638\n-\n-------------------------\n-\n-\n-"}, {"sha": "579aabfff88b90c98639d86ce36d33c46a1da6d9", "filename": "src/doc/unstable-book/src/language-features/main.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmain.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmain.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `main`\n-\n-The tracking issue for this feature is: [#29634]\n-\n-[#29634]: https://github.com/rust-lang/rust/issues/29634\n-\n-------------------------\n-\n-\n-"}, {"sha": "e56ce4770aab00a78565e78e5d055243143e5465", "filename": "src/doc/unstable-book/src/language-features/naked-functions.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnaked-functions.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnaked-functions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnaked-functions.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `naked_functions`\n-\n-The tracking issue for this feature is: [#32408]\n-\n-[#32408]: https://github.com/rust-lang/rust/issues/32408\n-\n-------------------------\n-\n-\n-"}, {"sha": "22aa10b2183cb2f580a5e9c962cf007aaf0b079f", "filename": "src/doc/unstable-book/src/language-features/needs-allocator.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fneeds-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fneeds-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fneeds-allocator.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `needs_allocator`\n-\n-The tracking issue for this feature is: [#27389]\n-\n-[#27389]: https://github.com/rust-lang/rust/issues/27389\n-\n-------------------------\n-\n-\n-"}, {"sha": "627c946c1bb271fd9fd91b457ae7d85465fcb6d4", "filename": "src/doc/unstable-book/src/language-features/needs-panic-runtime.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fneeds-panic-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fneeds-panic-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fneeds-panic-runtime.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `needs_panic_runtime`\n-\n-The tracking issue for this feature is: [#32837]\n-\n-[#32837]: https://github.com/rust-lang/rust/issues/32837\n-\n-------------------------\n-\n-\n-"}, {"sha": "3b3729a4b21d79ee0ce5b218cca43fe3919be5e2", "filename": "src/doc/unstable-book/src/language-features/never-type.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnever-type.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnever-type.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnever-type.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `never_type`\n-\n-The tracking issue for this feature is: [#35121]\n-\n-[#35121]: https://github.com/rust-lang/rust/issues/35121\n-\n-------------------------\n-\n-\n-"}, {"sha": "6238753447c9cdd01ab7868451bf2956e0d8411c", "filename": "src/doc/unstable-book/src/language-features/no-core.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-core.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-core.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-core.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `no_core`\n-\n-The tracking issue for this feature is: [#29639]\n-\n-[#29639]: https://github.com/rust-lang/rust/issues/29639\n-\n-------------------------\n-\n-\n-"}, {"sha": "7536ed9d4e106e3469db46bc0ec5639cf28c4838", "filename": "src/doc/unstable-book/src/language-features/no-debug.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-debug.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-debug.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-debug.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `no_debug`\n-\n-The tracking issue for this feature is: [#29721]\n-\n-[#29721]: https://github.com/rust-lang/rust/issues/29721\n-\n-------------------------\n-\n-\n-"}, {"sha": "d8ac520fcb5e2cd1e008566fdbacbfd7482cbb00", "filename": "src/doc/unstable-book/src/language-features/omit-gdb-pretty-printer-section.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fomit-gdb-pretty-printer-section.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fomit-gdb-pretty-printer-section.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fomit-gdb-pretty-printer-section.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `omit_gdb_pretty_printer_section`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "0b2d60accd59a95a3049cf7d5dd7ddc5c0342b2b", "filename": "src/doc/unstable-book/src/language-features/optin-builtin-traits.md", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,9 +0,0 @@\n-# `optin_builtin_traits`\n-\n-The tracking issue for this feature is: [#13231]\n-\n-[#13231]: https://github.com/rust-lang/rust/issues/13231\n-\n-------------------------\n-\n-"}, {"sha": "a4920839c6ca9d8199f3ef4cb3232ac94bd3b1c4", "filename": "src/doc/unstable-book/src/language-features/overlapping-marker-traits.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foverlapping-marker-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foverlapping-marker-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foverlapping-marker-traits.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `overlapping_marker_traits`\n-\n-The tracking issue for this feature is: [#29864]\n-\n-[#29864]: https://github.com/rust-lang/rust/issues/29864\n-\n-------------------------"}, {"sha": "65b067e8296131e8ade4df36e8ba7b2b9a9369d2", "filename": "src/doc/unstable-book/src/language-features/panic-runtime.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fpanic-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fpanic-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fpanic-runtime.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `panic_runtime`\n-\n-The tracking issue for this feature is: [#32837]\n-\n-[#32837]: https://github.com/rust-lang/rust/issues/32837\n-\n-------------------------\n-\n-\n-"}, {"sha": "da12559a01b86b0935695b1b84c798621d6ec48e", "filename": "src/doc/unstable-book/src/language-features/placement-in-syntax.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplacement-in-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplacement-in-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplacement-in-syntax.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `placement_in_syntax`\n-\n-The tracking issue for this feature is: [#27779]\n-\n-[#27779]: https://github.com/rust-lang/rust/issues/27779\n-\n-------------------------\n-\n-\n-"}, {"sha": "377ac8f7342ef0e36698392230981d27198e31d8", "filename": "src/doc/unstable-book/src/language-features/platform-intrinsics.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplatform-intrinsics.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplatform-intrinsics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplatform-intrinsics.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `platform_intrinsics`\n-\n-The tracking issue for this feature is: [#27731]\n-\n-[#27731]: https://github.com/rust-lang/rust/issues/27731\n-\n-------------------------\n-\n-\n-"}, {"sha": "75dae5cfb7401b0c8766dfb1cd0adea459b0bf00", "filename": "src/doc/unstable-book/src/language-features/prelude-import.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fprelude-import.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fprelude-import.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fprelude-import.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `prelude_import`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "aee86f63952a5007bcea1cfb5639751f6e12906b", "filename": "src/doc/unstable-book/src/language-features/profiler-runtime.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fprofiler-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fprofiler-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fprofiler-runtime.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,5 @@\n+# `profiler_runtime`\n+\n+The tracking issue for this feature is: [#42524](https://github.com/rust-lang/rust/issues/42524).\n+\n+------------------------"}, {"sha": "b4e078d920c4eec9f12852cb9a36cbf4c22cb003", "filename": "src/doc/unstable-book/src/language-features/quote.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fquote.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fquote.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fquote.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `quote`\n-\n-The tracking issue for this feature is: [#29601]\n-\n-[#29601]: https://github.com/rust-lang/rust/issues/29601\n-\n-------------------------\n-\n-\n-"}, {"sha": "deea04f4c51cc7525328b0844034bebe1e603430", "filename": "src/doc/unstable-book/src/language-features/repr-align.md", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,11 +0,0 @@\n-# `repr_align`\n-\n-The tracking issue for this feature is: [#33626]\n-\n-[#33626]: https://github.com/rust-lang/rust/issues/33626\n-\n-------------------------\n-\n-\n-\n-"}, {"sha": "c6f051e4fffc1220b137bf8947c49b25d46bf6f5", "filename": "src/doc/unstable-book/src/language-features/repr-simd.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-simd.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-simd.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-simd.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `repr_simd`\n-\n-The tracking issue for this feature is: [#27731]\n-\n-[#27731]: https://github.com/rust-lang/rust/issues/27731\n-\n-------------------------\n-\n-\n-"}, {"sha": "d1f18cead068372c9c7991ca8f6afe570cd9587f", "filename": "src/doc/unstable-book/src/language-features/rustc-attrs.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-attrs.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `rustc_attrs`\n-\n-The tracking issue for this feature is: [#29642]\n-\n-[#29642]: https://github.com/rust-lang/rust/issues/29642\n-\n-------------------------\n-\n-\n-"}, {"sha": "0df6ca12089eebf94b7ed3243c74ae2b0ec2497d", "filename": "src/doc/unstable-book/src/language-features/rustc-diagnostic-macros.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-diagnostic-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-diagnostic-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frustc-diagnostic-macros.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `rustc_diagnostic_macros`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "f19504de58e120ff98c04ca921bc071a7735d9ba", "filename": "src/doc/unstable-book/src/language-features/sanitizer-runtime.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsanitizer-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsanitizer-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsanitizer-runtime.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `sanitizer_runtime`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "d85779c3d3dc9c9171d7e7df869a0a21733c18f5", "filename": "src/doc/unstable-book/src/language-features/simd-ffi.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsimd-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsimd-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsimd-ffi.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `simd_ffi`\n-\n-The tracking issue for this feature is: [#27731]\n-\n-[#27731]: https://github.com/rust-lang/rust/issues/27731\n-\n-------------------------\n-\n-\n-"}, {"sha": "13c9722c5243a0250c51d82eac5b80f27740fbe2", "filename": "src/doc/unstable-book/src/language-features/simd.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsimd.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsimd.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fsimd.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `simd`\n-\n-The tracking issue for this feature is: [#27731]\n-\n-[#27731]: https://github.com/rust-lang/rust/issues/27731\n-\n-------------------------\n-\n-\n-"}, {"sha": "efc380df6e1194e1de0fa7183b81b39b604a6968", "filename": "src/doc/unstable-book/src/language-features/specialization.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fspecialization.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fspecialization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fspecialization.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `specialization`\n-\n-The tracking issue for this feature is: [#31844]\n-\n-[#31844]: https://github.com/rust-lang/rust/issues/31844\n-\n-------------------------\n-\n-\n-"}, {"sha": "1409e570e887ba1cfe6ae87834e6d6d481000d93", "filename": "src/doc/unstable-book/src/language-features/staged-api.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstaged-api.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstaged-api.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstaged-api.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `staged_api`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "1ea6d59c78d5b46362ce83fdb334b3fc08c56874", "filename": "src/doc/unstable-book/src/language-features/start.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstart.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstart.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstart.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `start`\n-\n-The tracking issue for this feature is: [#29633]\n-\n-[#29633]: https://github.com/rust-lang/rust/issues/29633\n-\n-------------------------\n-\n-\n-"}, {"sha": "97b9d71d433a4b5a2e8089ccc3956968def71681", "filename": "src/doc/unstable-book/src/language-features/static-nobundle.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstatic-nobundle.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstatic-nobundle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstatic-nobundle.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `static_nobundle`\n-\n-The tracking issue for this feature is: [#37403]\n-\n-[#37403]: https://github.com/rust-lang/rust/issues/37403\n-\n-------------------------\n-\n-\n-"}, {"sha": "71092fcf29040e5635b95db92fcedbde94c9b011", "filename": "src/doc/unstable-book/src/language-features/stmt-expr-attributes.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstmt-expr-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstmt-expr-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstmt-expr-attributes.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `stmt_expr_attributes`\n-\n-The tracking issue for this feature is: [#15701]\n-\n-[#15701]: https://github.com/rust-lang/rust/issues/15701\n-\n-------------------------\n-\n-\n-"}, {"sha": "1a94562968d192a11db9be21bda24c6f2e7f081e", "filename": "src/doc/unstable-book/src/language-features/struct-field-attributes.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstruct-field-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstruct-field-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstruct-field-attributes.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `struct_field_attributes`\n-\n-The tracking issue for this feature is: [#38814]\n-\n-[#38814]: https://github.com/rust-lang/rust/issues/38814\n-\n-------------------------\n-\n-\n-"}, {"sha": "b3ca26e6474deffcc886999d9ccfdd4841b7ccca", "filename": "src/doc/unstable-book/src/language-features/structural-match.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstructural-match.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstructural-match.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstructural-match.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `structural_match`\n-\n-The tracking issue for this feature is: [#31434]\n-\n-[#31434]: https://github.com/rust-lang/rust/issues/31434\n-\n-------------------------\n-\n-\n-"}, {"sha": "85ab1ab39efe643901cdd7e1a7fe4457dca80f99", "filename": "src/doc/unstable-book/src/language-features/target-feature.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftarget-feature.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftarget-feature.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftarget-feature.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `target_feature`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "83de2f9cd4b5471a88f99711ffd193eda0c0e85c", "filename": "src/doc/unstable-book/src/language-features/thread-local.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fthread-local.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fthread-local.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fthread-local.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `thread_local`\n-\n-The tracking issue for this feature is: [#29594]\n-\n-[#29594]: https://github.com/rust-lang/rust/issues/29594\n-\n-------------------------\n-\n-\n-"}, {"sha": "856f1b0a7bbb05446adfaaeffa7f37c69777cba4", "filename": "src/doc/unstable-book/src/language-features/trace-macros.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrace-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrace-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrace-macros.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `trace_macros`\n-\n-The tracking issue for this feature is: [#29598]\n-\n-[#29598]: https://github.com/rust-lang/rust/issues/29598\n-\n-------------------------\n-\n-\n-"}, {"sha": "3ebd0d87ccff995850e909133571ebe1d4482be2", "filename": "src/doc/unstable-book/src/language-features/type-ascription.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-ascription.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-ascription.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-ascription.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `type_ascription`\n-\n-The tracking issue for this feature is: [#23416]\n-\n-[#23416]: https://github.com/rust-lang/rust/issues/23416\n-\n-------------------------\n-\n-\n-"}, {"sha": "2cbb436ce0bb16446d45fb2299fc85ee09cc530d", "filename": "src/doc/unstable-book/src/language-features/unboxed-closures.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `unboxed_closures`\n-\n-The tracking issue for this feature is: [#29625]\n-\n-[#29625]: https://github.com/rust-lang/rust/issues/29625\n-\n-------------------------\n-\n-\n-"}, {"sha": "6fe4f088ac237fcf9b0e83b3ec439af1a9067cf3", "filename": "src/doc/unstable-book/src/language-features/untagged-unions.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funtagged-unions.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funtagged-unions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funtagged-unions.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `untagged_unions`\n-\n-The tracking issue for this feature is: [#32836]\n-\n-[#32836]: https://github.com/rust-lang/rust/issues/32836\n-\n-------------------------\n-\n-\n-"}, {"sha": "0167a33b081a568bf32c0f46daea4b86bf3714d1", "filename": "src/doc/unstable-book/src/language-features/unwind-attributes.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funwind-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funwind-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funwind-attributes.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,6 +0,0 @@\n-# `unwind_attributes`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-"}, {"sha": "bc6149115028f393940206e04a62ea25df39314b", "filename": "src/doc/unstable-book/src/language-features/use-extern-macros.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-extern-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-extern-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-extern-macros.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,10 +0,0 @@\n-# `use_extern_macros`\n-\n-The tracking issue for this feature is: [#35896]\n-\n-[#35896]: https://github.com/rust-lang/rust/issues/35896\n-\n-------------------------\n-\n-\n-"}, {"sha": "47eeb0874fba1edf8a4e9b6b683de52a54181f09", "filename": "src/doc/unstable-book/src/library-features/alloc.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `alloc`\n-\n-The tracking issue for this feature is: [#27783]\n-\n-[#27783]: https://github.com/rust-lang/rust/issues/27783\n-\n-------------------------"}, {"sha": "ed32eedb3481e22828bcfb88f4700ba893b7bcdf", "filename": "src/doc/unstable-book/src/library-features/as-c-str.md", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-c-str.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-c-str.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-c-str.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,8 +0,0 @@\n-# `as_c_str`\n-\n-The tracking issue for this feature is: [#40380]\n-\n-[#40380]: https://github.com/rust-lang/rust/issues/40380\n-\n-------------------------\n-"}, {"sha": "e253b4dcd9b5a1e6e456af8dcd0f235869d43b01", "filename": "src/doc/unstable-book/src/library-features/ascii-ctype.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fascii-ctype.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fascii-ctype.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fascii-ctype.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,5 +0,0 @@\n-# `ascii_ctype`\n-\n-The tracking issue for this feature is: [#39658]\n-\n-[#39658]: https://github.com/rust-lang/rust/issues/39658"}, {"sha": "0f3f01ba0e164e0fddbf343c1d38687738cd0297", "filename": "src/doc/unstable-book/src/library-features/box-heap.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbox-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbox-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbox-heap.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `box_heap`\n-\n-The tracking issue for this feature is: [#27779]\n-\n-[#27779]: https://github.com/rust-lang/rust/issues/27779\n-\n-------------------------"}, {"sha": "21aa486219e0de17b2a699c35cc8d34f84b52160", "filename": "src/doc/unstable-book/src/library-features/char-escape-debug.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-escape-debug.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-escape-debug.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-escape-debug.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `char_escape_debug`\n-\n-The tracking issue for this feature is: [#35068]\n-\n-[#35068]: https://github.com/rust-lang/rust/issues/35068\n-\n-------------------------"}, {"sha": "078d3faf42a7b19f032cd3e855ed7a55bf87357a", "filename": "src/doc/unstable-book/src/library-features/coerce-unsized.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcoerce-unsized.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcoerce-unsized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcoerce-unsized.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `coerce_unsized`\n-\n-The tracking issue for this feature is: [#27732]\n-\n-[#27732]: https://github.com/rust-lang/rust/issues/27732\n-\n-------------------------"}, {"sha": "268ca6ea590d52557083f82ede375cc2e42a69c1", "filename": "src/doc/unstable-book/src/library-features/collection-placement.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollection-placement.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollection-placement.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollection-placement.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `collection_placement`\n-\n-The tracking issue for this feature is: [#30172]\n-\n-[#30172]: https://github.com/rust-lang/rust/issues/30172\n-\n-------------------------"}, {"sha": "ea4f999ba0f9ac6ca1dd640b8a8a6a47cf9339d0", "filename": "src/doc/unstable-book/src/library-features/collections-range.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections-range.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections-range.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections-range.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `collections_range`\n-\n-The tracking issue for this feature is: [#30877]\n-\n-[#30877]: https://github.com/rust-lang/rust/issues/30877\n-\n-------------------------"}, {"sha": "0ab89e278cdf7bfba028ceb0ebd3152e53059f2f", "filename": "src/doc/unstable-book/src/library-features/command-envs.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcommand-envs.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcommand-envs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcommand-envs.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `command_envs`\n-\n-The tracking issue for this feature is: [#38526]\n-\n-[#38526]: https://github.com/rust-lang/rust/issues/38526\n-\n-------------------------"}, {"sha": "ac2fdd4fceb6dafc9239b52d65484c3d83ce2ce5", "filename": "src/doc/unstable-book/src/library-features/concat-idents-macro.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents-macro.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `concat_idents_macro`\n-\n-The tracking issue for this feature is: [#29599]\n-\n-[#29599]: https://github.com/rust-lang/rust/issues/29599\n-\n-------------------------"}, {"sha": "d37d6b5c6d0bafd9b3025e2940bd9bd996e6be92", "filename": "src/doc/unstable-book/src/library-features/core-char-ext.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-char-ext.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-char-ext.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-char-ext.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `core_char_ext`\n-\n-The tracking issue for this feature is: [#32110]\n-\n-[#32110]: https://github.com/rust-lang/rust/issues/32110\n-\n-------------------------"}, {"sha": "194b2608dd02bfb5c89fe45b456bfab629115a0b", "filename": "src/doc/unstable-book/src/library-features/core-float.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-float.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-float.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-float.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `core_float`\n-\n-The tracking issue for this feature is: [#32110]\n-\n-[#32110]: https://github.com/rust-lang/rust/issues/32110\n-\n-------------------------"}, {"sha": "c50d44ac0ce3e1cd44b212f03b38715a798fa12d", "filename": "src/doc/unstable-book/src/library-features/core-slice-ext.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-slice-ext.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-slice-ext.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-slice-ext.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `core_slice_ext`\n-\n-The tracking issue for this feature is: [#32110]\n-\n-[#32110]: https://github.com/rust-lang/rust/issues/32110\n-\n-------------------------"}, {"sha": "08c68f11c6eca6e41b0c1d45ea94dadcabf82355", "filename": "src/doc/unstable-book/src/library-features/core-str-ext.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-str-ext.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-str-ext.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcore-str-ext.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `core_str_ext`\n-\n-The tracking issue for this feature is: [#32110]\n-\n-[#32110]: https://github.com/rust-lang/rust/issues/32110\n-\n-------------------------"}, {"sha": "b96854ebcd461a27b405c0c77631f5259fb05b6a", "filename": "src/doc/unstable-book/src/library-features/decode-utf8.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdecode-utf8.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdecode-utf8.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdecode-utf8.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `decode_utf8`\n-\n-The tracking issue for this feature is: [#27783]\n-\n-[#27783]: https://github.com/rust-lang/rust/issues/27783\n-\n-------------------------"}, {"sha": "2f99f5ecab39f6cb11609680d6b723a360197a3d", "filename": "src/doc/unstable-book/src/library-features/discriminant-value.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdiscriminant-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdiscriminant-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdiscriminant-value.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `discriminant_value`\n-\n-The tracking issue for this feature is: [#24263]\n-\n-[#24263]: https://github.com/rust-lang/rust/issues/24263\n-\n-------------------------"}, {"sha": "be7a3ffd4dc43ff20f939ba59806cca9117be0d6", "filename": "src/doc/unstable-book/src/library-features/error-type-id.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ferror-type-id.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ferror-type-id.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ferror-type-id.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `error_type_id`\n-\n-The tracking issue for this feature is: [#27745]\n-\n-[#27745]: https://github.com/rust-lang/rust/issues/27745\n-\n-------------------------"}, {"sha": "200ec38725176b0235ceec6d67c85aecfe46ba90", "filename": "src/doc/unstable-book/src/library-features/exact-size-is-empty.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fexact-size-is-empty.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fexact-size-is-empty.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fexact-size-is-empty.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `exact_size_is_empty`\n-\n-The tracking issue for this feature is: [#35428]\n-\n-[#35428]: https://github.com/rust-lang/rust/issues/35428\n-\n-------------------------"}, {"sha": "9e24e6a0850d1acc27b73c7d1ac55caeb5da5102", "filename": "src/doc/unstable-book/src/library-features/fixed-size-array.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffixed-size-array.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffixed-size-array.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffixed-size-array.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `fixed_size_array`\n-\n-The tracking issue for this feature is: [#27778]\n-\n-[#27778]: https://github.com/rust-lang/rust/issues/27778\n-\n-------------------------"}, {"sha": "f519545ac78b5208bd2f0fa6e30690e896bae186", "filename": "src/doc/unstable-book/src/library-features/float-bits-conv.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-bits-conv.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-bits-conv.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-bits-conv.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `float_bits_conv`\n-\n-The tracking issue for this feature is: [#40470]\n-\n-[#40470]: https://github.com/rust-lang/rust/issues/40470\n-\n-------------------------"}, {"sha": "755263bd9a61fbf60589745d5101abb90f1cb72c", "filename": "src/doc/unstable-book/src/library-features/fmt-flags-align.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffmt-flags-align.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffmt-flags-align.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffmt-flags-align.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `fmt_flags_align`\n-\n-The tracking issue for this feature is: [#27726]\n-\n-[#27726]: https://github.com/rust-lang/rust/issues/27726\n-\n-------------------------"}, {"sha": "3942cda553889a0374d38aafada58cd688e81fe0", "filename": "src/doc/unstable-book/src/library-features/fn-traits.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `fn_traits`\n-\n-The tracking issue for this feature is: [#29625]\n-\n-[#29625]: https://github.com/rust-lang/rust/issues/29625\n-\n-------------------------"}, {"sha": "a9b74d4f00470a16aaa18a5d149782ffec60df45", "filename": "src/doc/unstable-book/src/library-features/fnbox.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `fnbox`\n-\n-The tracking issue for this feature is: [#28796]\n-\n-[#28796]: https://github.com/rust-lang/rust/issues/28796\n-\n-------------------------"}, {"sha": "570f779417f0980056664c3569c33a8b57c134db", "filename": "src/doc/unstable-book/src/library-features/from_utf8_error_as_bytes.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffrom_utf8_error_as_bytes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffrom_utf8_error_as_bytes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffrom_utf8_error_as_bytes.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `from_utf8_error_as_bytes`\n-\n-The tracking issue for this feature is: [#40895]\n-\n-[#40895]: https://github.com/rust-lang/rust/issues/40895\n-\n-------------------------"}, {"sha": "460555bf1b0dbee4a6b1e501d65c294726eef506", "filename": "src/doc/unstable-book/src/library-features/fused.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffused.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffused.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffused.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `fused`\n-\n-The tracking issue for this feature is: [#35602]\n-\n-[#35602]: https://github.com/rust-lang/rust/issues/35602\n-\n-------------------------"}, {"sha": "afdb030c406dd194ace707858584d537be1ce232", "filename": "src/doc/unstable-book/src/library-features/get-type-id.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fget-type-id.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fget-type-id.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fget-type-id.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `get_type_id`\n-\n-The tracking issue for this feature is: [#27745]\n-\n-[#27745]: https://github.com/rust-lang/rust/issues/27745\n-\n-------------------------"}, {"sha": "01404e49dbda369559530ea824e2a14d6e21aed8", "filename": "src/doc/unstable-book/src/library-features/heap-api.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fheap-api.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fheap-api.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fheap-api.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `heap_api`\n-\n-The tracking issue for this feature is: [#27700]\n-\n-[#27700]: https://github.com/rust-lang/rust/issues/27700\n-\n-------------------------"}, {"sha": "a1a7ce8e63f443d3cdcc11fe57726c6874e3e466", "filename": "src/doc/unstable-book/src/library-features/i128.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fi128.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fi128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fi128.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `i128`\n-\n-The tracking issue for this feature is: [#35118]\n-\n-[#35118]: https://github.com/rust-lang/rust/issues/35118\n-\n-------------------------"}, {"sha": "2e88e2047868d2a9029ae11d4c8b73fd4c2636c3", "filename": "src/doc/unstable-book/src/library-features/inclusive-range.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finclusive-range.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finclusive-range.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finclusive-range.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `inclusive_range`\n-\n-The tracking issue for this feature is: [#28237]\n-\n-[#28237]: https://github.com/rust-lang/rust/issues/28237\n-\n-------------------------"}, {"sha": "50db9fd4ca45c6976b58981296bc305e381a02bd", "filename": "src/doc/unstable-book/src/library-features/integer-atomics.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finteger-atomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finteger-atomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finteger-atomics.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `integer_atomics`\n-\n-The tracking issue for this feature is: [#32976]\n-\n-[#32976]: https://github.com/rust-lang/rust/issues/32976\n-\n-------------------------"}, {"sha": "0d94b4fc560571a2c18701369ef6797f1b606ec3", "filename": "src/doc/unstable-book/src/library-features/into-boxed-c-str.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-c-str.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-c-str.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-c-str.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `into_boxed_c_str`\n-\n-The tracking issue for this feature is: [#40380]\n-\n-[#40380]: https://github.com/rust-lang/rust/issues/40380\n-\n-------------------------"}, {"sha": "7636e20b14d88fc4f52875ea6257ef8775c044f8", "filename": "src/doc/unstable-book/src/library-features/into-boxed-os-str.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-os-str.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-os-str.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-os-str.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `into_boxed_os_str`\n-\n-The tracking issue for this feature is: [#into_boxed_os_str]\n-\n-[#into_boxed_os_str]: https://github.com/rust-lang/rust/issues/40380\n-\n-------------------------"}, {"sha": "754c6042f07f6a2360050876e29a39a7c1cd925a", "filename": "src/doc/unstable-book/src/library-features/into-boxed-path.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-path.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-path.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finto-boxed-path.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `into_boxed_path`\n-\n-The tracking issue for this feature is: [#40380]\n-\n-[#40380]: https://github.com/rust-lang/rust/issues/40380\n-\n-------------------------"}, {"sha": "ed6cae24e32de7267f1d8693f9900eb7707fa708", "filename": "src/doc/unstable-book/src/library-features/io.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fio.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fio.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fio.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `io`\n-\n-The tracking issue for this feature is: [#27802]\n-\n-[#27802]: https://github.com/rust-lang/rust/issues/27802\n-\n-------------------------"}, {"sha": "7e7d52adbdb0fd76bafbdc14703e0b8dc6323b89", "filename": "src/doc/unstable-book/src/library-features/ip.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fip.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fip.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fip.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `ip`\n-\n-The tracking issue for this feature is: [#27709]\n-\n-[#27709]: https://github.com/rust-lang/rust/issues/27709\n-\n-------------------------"}, {"sha": "444714490345b3b0a2938a65ec66a85d3b5431cc", "filename": "src/doc/unstable-book/src/library-features/iter-rfind.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiter-rfind.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiter-rfind.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiter-rfind.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `iter_rfind`\n-\n-The tracking issue for this feature is: [#39480]\n-\n-[#39480]: https://github.com/rust-lang/rust/issues/39480\n-\n-------------------------"}, {"sha": "8467cb68862f7996cb8c6bc8a660d29e3a2fde56", "filename": "src/doc/unstable-book/src/library-features/iterator-step-by.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-step-by.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-step-by.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-step-by.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `iterator_step_by`\n-\n-The tracking issue for this feature is: [#27741]\n-\n-[#27741]: https://github.com/rust-lang/rust/issues/27741\n-\n-------------------------"}, {"sha": "be3b96aea70d8933ec5d0b2275dcd17aab91f1a1", "filename": "src/doc/unstable-book/src/library-features/linked-list-extras.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Flinked-list-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Flinked-list-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Flinked-list-extras.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `linked_list_extras`\n-\n-The tracking issue for this feature is: [#27794]\n-\n-[#27794]: https://github.com/rust-lang/rust/issues/27794\n-\n-------------------------"}, {"sha": "b60e7a010945a423269242cdf77f463c469ed3ce", "filename": "src/doc/unstable-book/src/library-features/lookup-host.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Flookup-host.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Flookup-host.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Flookup-host.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `lookup_host`\n-\n-The tracking issue for this feature is: [#27705]\n-\n-[#27705]: https://github.com/rust-lang/rust/issues/27705\n-\n-------------------------"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/unstable-book/src/library-features/manually-drop.md", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmanually-drop.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmanually-drop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmanually-drop.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d"}, {"sha": "1405b6c5cb245f48883efa2fa20de5feeac70426", "filename": "src/doc/unstable-book/src/library-features/mpsc-select.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmpsc-select.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmpsc-select.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmpsc-select.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,5 +0,0 @@\n-# `mpsc_select`\n-\n-The tracking issue for this feature is: [#27800]\n-\n-[#27800]: https://github.com/rust-lang/rust/issues/27800"}, {"sha": "10ae95695a2dbdd55aefc2142a63fe48cddf95df", "filename": "src/doc/unstable-book/src/library-features/needs-drop.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fneeds-drop.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fneeds-drop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fneeds-drop.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `needs_drop`\n-\n-The tracking issue for this feature is: [#41890]\n-\n-[#41890]: https://github.com/rust-lang/rust/issues/41890\n-\n-------------------------"}, {"sha": "4063cd0db01d60c0d7ac647b726df7f9bac37f12", "filename": "src/doc/unstable-book/src/library-features/never-type-impls.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fnever-type-impls.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fnever-type-impls.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fnever-type-impls.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `never_type_impls`\n-\n-The tracking issue for this feature is: [#35121]\n-\n-[#35121]: https://github.com/rust-lang/rust/issues/35121\n-\n-------------------------"}, {"sha": "f200f8e2786fa40c262299f14136c3357d5f2c20", "filename": "src/doc/unstable-book/src/library-features/nonzero.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fnonzero.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fnonzero.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fnonzero.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `nonzero`\n-\n-The tracking issue for this feature is: [#27730]\n-\n-[#27730]: https://github.com/rust-lang/rust/issues/27730\n-\n-------------------------"}, {"sha": "03d990eb4ae970421d5bdea89b0d6c76ba71076a", "filename": "src/doc/unstable-book/src/library-features/offset-to.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foffset-to.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foffset-to.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foffset-to.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `offset_to`\n-\n-The tracking issue for this feature is: [#41079]\n-\n-[#41079]: https://github.com/rust-lang/rust/issues/41079\n-\n-------------------------"}, {"sha": "3c16cafae5014ff95d4116fdbf22dd801c7e2b89", "filename": "src/doc/unstable-book/src/library-features/once-poison.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fonce-poison.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fonce-poison.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fonce-poison.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `once_poison`\n-\n-The tracking issue for this feature is: [#33577]\n-\n-[#33577]: https://github.com/rust-lang/rust/issues/33577\n-\n-------------------------"}, {"sha": "908caeb75c60166333fa3bbc9ff824d75093c2cd", "filename": "src/doc/unstable-book/src/library-features/oom.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foom.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foom.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foom.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `oom`\n-\n-The tracking issue for this feature is: [#27700]\n-\n-[#27700]: https://github.com/rust-lang/rust/issues/27700\n-\n-------------------------"}, {"sha": "edb4efc09e5877de1103df4954c08397d5e788e0", "filename": "src/doc/unstable-book/src/library-features/option-entry.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foption-entry.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foption-entry.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Foption-entry.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `option_entry`\n-\n-The tracking issue for this feature is: [#39288]\n-\n-[#39288]: https://github.com/rust-lang/rust/issues/39288\n-\n-------------------------"}, {"sha": "21dc7d095c808c5845267a54b39d15379453ada0", "filename": "src/doc/unstable-book/src/library-features/osstring-shrink-to-fit.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fosstring-shrink-to-fit.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fosstring-shrink-to-fit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fosstring-shrink-to-fit.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `osstring_shrink_to_fit`\n-\n-The tracking issue for this feature is: [#40421]\n-\n-[#40421]: https://github.com/rust-lang/rust/issues/40421\n-\n-------------------------"}, {"sha": "07a957626905ed4da2bf52197fe50bad96050aa2", "filename": "src/doc/unstable-book/src/library-features/panic-abort.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpanic-abort.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpanic-abort.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpanic-abort.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `panic_abort`\n-\n-The tracking issue for this feature is: [#32837]\n-\n-[#32837]: https://github.com/rust-lang/rust/issues/32837\n-\n-------------------------"}, {"sha": "840e492597b54c0f93a5587edae2f786cce4dba7", "filename": "src/doc/unstable-book/src/library-features/panic-unwind.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpanic-unwind.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpanic-unwind.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpanic-unwind.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `panic_unwind`\n-\n-The tracking issue for this feature is: [#32837]\n-\n-[#32837]: https://github.com/rust-lang/rust/issues/32837\n-\n-------------------------"}, {"sha": "e76ee6beb675b450d28acc8fdf32a6b4c4c542b0", "filename": "src/doc/unstable-book/src/library-features/pattern.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpattern.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpattern.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fpattern.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `pattern`\n-\n-The tracking issue for this feature is: [#27721]\n-\n-[#27721]: https://github.com/rust-lang/rust/issues/27721\n-\n-------------------------"}, {"sha": "6ff010b7e3855f4d195e0a9ce78142d1007750b9", "filename": "src/doc/unstable-book/src/library-features/placement-in.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fplacement-in.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fplacement-in.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fplacement-in.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `placement_in`\n-\n-The tracking issue for this feature is: [#27779]\n-\n-[#27779]: https://github.com/rust-lang/rust/issues/27779\n-\n-------------------------"}, {"sha": "d53225f0a352eaeb84f5232c30496a4ba7c037fb", "filename": "src/doc/unstable-book/src/library-features/placement-new-protocol.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fplacement-new-protocol.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fplacement-new-protocol.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fplacement-new-protocol.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `placement_new_protocol`\n-\n-The tracking issue for this feature is: [#27779]\n-\n-[#27779]: https://github.com/rust-lang/rust/issues/27779\n-\n-------------------------"}, {"sha": "ea087c0a4f7b0182f0a8c5182eda7121584db97b", "filename": "src/doc/unstable-book/src/library-features/proc-macro-internals.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fproc-macro-internals.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fproc-macro-internals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fproc-macro-internals.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `proc_macro_internals`\n-\n-The tracking issue for this feature is: [#27812]\n-\n-[#27812]: https://github.com/rust-lang/rust/issues/27812\n-\n-------------------------"}, {"sha": "a01f1e73ab4047b32ab16b91693d198f618242d3", "filename": "src/doc/unstable-book/src/library-features/profiler-runtime-lib.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fprofiler-runtime-lib.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fprofiler-runtime-lib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fprofiler-runtime-lib.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,5 @@\n+# `profiler_runtime_lib`\n+\n+This feature is internal to the Rust compiler and is not intended for general use.\n+\n+------------------------"}, {"sha": "ac4581faf2ae410089dcaad17552522398ba0fa9", "filename": "src/doc/unstable-book/src/library-features/range-contains.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-contains.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-contains.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-contains.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `range_contains`\n-\n-The tracking issue for this feature is: [#32311]\n-\n-[#32311]: https://github.com/rust-lang/rust/issues/32311\n-\n-------------------------"}, {"sha": "d7caf22813dc727fd690f7eca4e18c8e7c5c014a", "filename": "src/doc/unstable-book/src/library-features/raw.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fraw.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fraw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fraw.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `raw`\n-\n-The tracking issue for this feature is: [#27751]\n-\n-[#27751]: https://github.com/rust-lang/rust/issues/27751\n-\n-------------------------"}, {"sha": "a1a851d6ed6328847bcc9c9a130df9ebe4ff74f1", "filename": "src/doc/unstable-book/src/library-features/reverse-cmp-key.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Freverse-cmp-key.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Freverse-cmp-key.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Freverse-cmp-key.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `reverse_cmp_key`\n-\n-The tracking issue for this feature is: [#40893]\n-\n-[#40893]: https://github.com/rust-lang/rust/issues/40893\n-\n-------------------------"}, {"sha": "2453475efe59970f6c993c6fcb193c3d373e15b4", "filename": "src/doc/unstable-book/src/library-features/rustc-private.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frustc-private.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frustc-private.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frustc-private.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `rustc_private`\n-\n-The tracking issue for this feature is: [#27812]\n-\n-[#27812]: https://github.com/rust-lang/rust/issues/27812\n-\n-------------------------"}, {"sha": "b79d1212c62f0d9a2829bcf598a46f5eb5f943b2", "filename": "src/doc/unstable-book/src/library-features/shared.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fshared.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fshared.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fshared.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `shared`\n-\n-The tracking issue for this feature is: [#27730]\n-\n-[#27730]: https://github.com/rust-lang/rust/issues/27730\n-\n-------------------------"}, {"sha": "8f69c3ab2def7c31da3cb399c08ceda9dbc9f99b", "filename": "src/doc/unstable-book/src/library-features/sip-hash-13.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsip-hash-13.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsip-hash-13.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsip-hash-13.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `sip_hash_13`\n-\n-The tracking issue for this feature is: [#34767]\n-\n-[#34767]: https://github.com/rust-lang/rust/issues/34767\n-\n-------------------------"}, {"sha": "9ba2de5adc7268eb9752e3a2afd14d4ffd2d9e5e", "filename": "src/doc/unstable-book/src/library-features/slice-concat-ext.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-concat-ext.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-concat-ext.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-concat-ext.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `slice_concat_ext`\n-\n-The tracking issue for this feature is: [#27747]\n-\n-[#27747]: https://github.com/rust-lang/rust/issues/27747\n-\n-------------------------"}, {"sha": "57e2c148e7963acc23c096538bc48974d3b6bd80", "filename": "src/doc/unstable-book/src/library-features/slice-get-slice.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-get-slice.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-get-slice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-get-slice.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `slice_get_slice`\n-\n-The tracking issue for this feature is: [#35729]\n-\n-[#35729]: https://github.com/rust-lang/rust/issues/35729\n-\n-------------------------"}, {"sha": "77fd598f1ea922537eed146ec4286a267a1ef1d7", "filename": "src/doc/unstable-book/src/library-features/slice-rotate.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rotate.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rotate.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rotate.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `slice_rotate`\n-\n-The tracking issue for this feature is: [#41891]\n-\n-[#41891]: https://github.com/rust-lang/rust/issues/41891\n-\n-------------------------"}, {"sha": "b649496cdd80b7ef47e9c0f036482c3cd37bc710", "filename": "src/doc/unstable-book/src/library-features/step-by.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstep-by.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstep-by.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstep-by.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `step_by`\n-\n-The tracking issue for this feature is: [#27741]\n-\n-[#27741]: https://github.com/rust-lang/rust/issues/27741\n-\n-------------------------"}, {"sha": "56050c20c69151d117309df59f110f62f2411805", "filename": "src/doc/unstable-book/src/library-features/step-trait.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstep-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstep-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstep-trait.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `step_trait`\n-\n-The tracking issue for this feature is: [#42168]\n-\n-[#42168]: https://github.com/rust-lang/rust/issues/42168\n-\n-------------------------"}, {"sha": "d05dcafa84da9adf74d6c497d4648436c69895c6", "filename": "src/doc/unstable-book/src/library-features/str-box-extras.md", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-box-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-box-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-box-extras.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,9 +0,0 @@\n-# `str_box_extras`\n-\n-The tracking issue for this feature is: [#str_box_extras]\n-\n-[#str_box_extras]: https://github.com/rust-lang/rust/issues/41119\n-\n-------------------------\n-\n-"}, {"sha": "d390139a6befaef8024cbac2fe7fefa32417264f", "filename": "src/doc/unstable-book/src/library-features/str-checked-slicing.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-checked-slicing.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-checked-slicing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-checked-slicing.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `str_checked_slicing`\n-\n-The tracking issue for this feature is: [#39932]\n-\n-[#39932]: https://github.com/rust-lang/rust/issues/39932\n-\n-------------------------"}, {"sha": "61e31c89443261dd66b6bad58cb720f2b4824b2b", "filename": "src/doc/unstable-book/src/library-features/str-escape.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-escape.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-escape.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-escape.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `str_escape`\n-\n-The tracking issue for this feature is: [#27791]\n-\n-[#27791]: https://github.com/rust-lang/rust/issues/27791\n-\n-------------------------"}, {"sha": "df4f35832cdc1e0dde69bf7d3797de39f8d5e70f", "filename": "src/doc/unstable-book/src/library-features/str-mut-extras.md", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-mut-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-mut-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstr-mut-extras.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,8 +0,0 @@\n-# `str_mut_extras`\n-\n-The tracking issue for this feature is: [#str_mut_extras]\n-\n-[#str_mut_extras]: https://github.com/rust-lang/rust/issues/41119\n-\n-------------------------\n-"}, {"sha": "af3ea991025f7958f72b6e884f6426bb74fc84c3", "filename": "src/doc/unstable-book/src/library-features/thread-id.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fthread-id.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fthread-id.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fthread-id.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `thread_id`\n-\n-The tracking issue for this feature is: [#21507]\n-\n-[#21507]: https://github.com/rust-lang/rust/issues/21507\n-\n-------------------------"}, {"sha": "113c1e910dca349cf2be8b5df6bfe376d36bc3a6", "filename": "src/doc/unstable-book/src/library-features/thread-local-state.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fthread-local-state.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fthread-local-state.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fthread-local-state.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `thread_local_state`\n-\n-The tracking issue for this feature is: [#27716]\n-\n-[#27716]: https://github.com/rust-lang/rust/issues/27716\n-\n-------------------------"}, {"sha": "eccc7e0e4dda0146a2c9720cd61dc2a25e2948aa", "filename": "src/doc/unstable-book/src/library-features/toowned-clone-into.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftoowned-clone-into.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftoowned-clone-into.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftoowned-clone-into.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `toowned_clone_into`\n-\n-The tracking issue for this feature is: [#41263]\n-\n-[#41263]: https://github.com/rust-lang/rust/issues/41263\n-\n-------------------------"}, {"sha": "80213cf1fdbb99c31017fc92a7c91e70cdb995f5", "filename": "src/doc/unstable-book/src/library-features/trusted-len.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrusted-len.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrusted-len.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrusted-len.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `trusted_len`\n-\n-The tracking issue for this feature is: [#37572]\n-\n-[#37572]: https://github.com/rust-lang/rust/issues/37572\n-\n-------------------------"}, {"sha": "d763caff5aacbdbaadba6daa563c809430024e1b", "filename": "src/doc/unstable-book/src/library-features/try-from.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftry-from.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftry-from.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftry-from.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `try_from`\n-\n-The tracking issue for this feature is: [#33417]\n-\n-[#33417]: https://github.com/rust-lang/rust/issues/33417\n-\n-------------------------"}, {"sha": "9fecec2ac36d33a4548802622d5be3c227f0c469", "filename": "src/doc/unstable-book/src/library-features/unicode.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funicode.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funicode.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funicode.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `unicode`\n-\n-The tracking issue for this feature is: [#27783]\n-\n-[#27783]: https://github.com/rust-lang/rust/issues/27783\n-\n-------------------------"}, {"sha": "99a3490d106bb6c2bce9fdace851b8b835c65666", "filename": "src/doc/unstable-book/src/library-features/unique.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funique.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funique.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funique.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `unique`\n-\n-The tracking issue for this feature is: [#27730]\n-\n-[#27730]: https://github.com/rust-lang/rust/issues/27730\n-\n-------------------------"}, {"sha": "92807e2858ffdcabd6c288790c90f0521547fd16", "filename": "src/doc/unstable-book/src/library-features/unsize.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funsize.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funsize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Funsize.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `unsize`\n-\n-The tracking issue for this feature is: [#27732]\n-\n-[#27732]: https://github.com/rust-lang/rust/issues/27732\n-\n-------------------------"}, {"sha": "1c14a5a9fa08b214752a9bb5b4cf4fd7a32693bc", "filename": "src/doc/unstable-book/src/library-features/utf8-error-error-len.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Futf8-error-error-len.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Futf8-error-error-len.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Futf8-error-error-len.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `utf8_error_error_len`\n-\n-The tracking issue for this feature is: [#40494]\n-\n-[#40494]: https://github.com/rust-lang/rust/issues/40494\n-\n-------------------------"}, {"sha": "2b8c9f046eefd92fa4a86ceb0fae62a6af8f6498", "filename": "src/doc/unstable-book/src/library-features/vec-remove-item.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-remove-item.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-remove-item.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-remove-item.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `vec_remove_item`\n-\n-The tracking issue for this feature is: [#40062]\n-\n-[#40062]: https://github.com/rust-lang/rust/issues/40062\n-\n-------------------------"}, {"sha": "5803d3215a54b93bbfbcbe84a2be995fa494b2bb", "filename": "src/doc/unstable-book/src/library-features/vec-resize-default.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-resize-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-resize-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-resize-default.md?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,7 +0,0 @@\n-# `vec_resize_default`\n-\n-The tracking issue for this feature is: [#41758]\n-\n-[#41758]: https://github.com/rust-lang/rust/issues/41758\n-\n-------------------------"}, {"sha": "4a38d4be083fdcac5202d1dcd3c6431c2d968caf", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -46,6 +46,7 @@\n TYPE_KIND_PTR               = 15\n TYPE_KIND_FIXED_SIZE_VEC    = 16\n TYPE_KIND_REGULAR_UNION     = 17\n+TYPE_KIND_OS_STRING         = 18\n \n ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\"\n@@ -64,6 +65,9 @@\n # std::String related constants\n STD_STRING_FIELD_NAMES = [\"vec\"]\n \n+# std::ffi::OsString related constants\n+OS_STRING_FIELD_NAMES = [\"inner\"]\n+\n \n class Type(object):\n     \"\"\"\n@@ -162,6 +166,11 @@ def __classify_struct(self):\n             self.__conforms_to_field_layout(STD_STRING_FIELD_NAMES)):\n             return TYPE_KIND_STD_STRING\n \n+        # OS STRING\n+        if (unqualified_type_name == \"OsString\" and\n+            self.__conforms_to_field_layout(OS_STRING_FIELD_NAMES)):\n+            return TYPE_KIND_OS_STRING\n+\n         # ENUM VARIANTS\n         if fields[0].name == ENUM_DISR_FIELD_NAME:\n             if field_count == 1:\n@@ -345,3 +354,8 @@ def extract_type_name(qualified_type_name):\n         return qualified_type_name\n     else:\n         return qualified_type_name[index + 2:]\n+\n+try:\n+    compat_str = unicode  # Python 2\n+except NameError:\n+    compat_str = str"}, {"sha": "822dc58140470146510262e9950a2c7e43ebc8e6", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -78,7 +78,8 @@ def get_child_at_index(self, index):\n \n     def as_integer(self):\n         if self.gdb_val.type.code == gdb.TYPE_CODE_PTR:\n-            return int(str(self.gdb_val), 0)\n+            as_str = rustpp.compat_str(self.gdb_val).split()[0]\n+            return int(as_str, 0)\n         return int(self.gdb_val)\n \n     def get_wrapped_value(self):\n@@ -99,8 +100,10 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     val = GdbValue(gdb_val)\n     type_kind = val.type.get_type_kind()\n \n-    if (type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT or\n-        type_kind == rustpp.TYPE_KIND_EMPTY):\n+    if type_kind == rustpp.TYPE_KIND_EMPTY:\n+        return RustEmptyPrinter(val)\n+\n+    if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n         return RustStructPrinter(val,\n                                  omit_first_field = False,\n                                  omit_type_name = False,\n@@ -124,6 +127,9 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     if type_kind == rustpp.TYPE_KIND_STD_STRING:\n         return RustStdStringPrinter(val)\n \n+    if type_kind == rustpp.TYPE_KIND_OS_STRING:\n+        return RustOsStringPrinter(val)\n+\n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return RustStructPrinter(val,\n                                  omit_first_field = False,\n@@ -170,6 +176,14 @@ def rust_pretty_printer_lookup_function(gdb_val):\n #=------------------------------------------------------------------------------\n # Pretty Printer Classes\n #=------------------------------------------------------------------------------\n+class RustEmptyPrinter(object):\n+    def __init__(self, val):\n+        self.__val = val\n+\n+    def to_string(self):\n+        return self.__val.type.get_unqualified_type_name()\n+\n+\n class RustStructPrinter(object):\n     def __init__(self, val, omit_first_field, omit_type_name, is_tuple_like):\n         self.__val = val\n@@ -186,10 +200,10 @@ def children(self):\n         cs = []\n         wrapped_value = self.__val.get_wrapped_value()\n \n-        for field in self.__val.type.get_fields():\n+        for number, field in enumerate(self.__val.type.get_fields()):\n             field_value = wrapped_value[field.name]\n             if self.__is_tuple_like:\n-                cs.append((\"\", field_value))\n+                cs.append((str(number), field_value))\n             else:\n                 cs.append((field.name, field_value))\n \n@@ -268,6 +282,21 @@ def to_string(self):\n                                                             length=length)\n \n \n+class RustOsStringPrinter(object):\n+    def __init__(self, val):\n+        self.__val = val\n+\n+    def to_string(self):\n+        buf = self.__val.get_child_at_index(0)\n+        vec = buf.get_child_at_index(0)\n+        if vec.type.get_unqualified_type_name() == \"Wtf8Buf\":\n+            vec = vec.get_child_at_index(0)\n+\n+        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(\n+            vec)\n+        return '\"%s\"' % data_ptr.get_wrapped_value().string(length=length)\n+\n+\n class RustCStyleVariantPrinter(object):\n     def __init__(self, val):\n         assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM"}, {"sha": "1f6d17748ab00d1d6fd5b51fc7f7c438ec25103f", "filename": "src/etc/natvis/liballoc.natvis", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n-  <Type Name=\"collections::vec::Vec&lt;*&gt;\">\n+  <Type Name=\"alloc::vec::Vec&lt;*&gt;\">\n     <DisplayString>{{ size={len} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[size]\" ExcludeView=\"simple\">len</Item>\n@@ -11,7 +11,7 @@\n       </ArrayItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"collections::vec_deque::VecDeque&lt;*&gt;\">\n+  <Type Name=\"alloc::vec_deque::VecDeque&lt;*&gt;\">\n     <DisplayString>{{ size={tail &lt;= head ? head - tail : buf.cap - tail + head} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[size]\" ExcludeView=\"simple\">tail &lt;= head ? head - tail : buf.cap - tail + head</Item>\n@@ -30,18 +30,18 @@\n       </CustomListItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"collections::linked_list::LinkedList&lt;*&gt;\">\n+  <Type Name=\"alloc::linked_list::LinkedList&lt;*&gt;\">\n     <DisplayString>{{ size={len} }}</DisplayString>\n     <Expand>\n       <LinkedListItems>\n         <Size>len</Size>\n-        <HeadPointer>*(collections::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n-        <NextPointer>*(collections::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n+        <HeadPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n+        <NextPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n         <ValueNode>element</ValueNode>\n       </LinkedListItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"collections::string::String\">\n+  <Type Name=\"alloc::string::String\">\n     <DisplayString>{*(char**)this,[vec.len]}</DisplayString>\n     <StringView>*(char**)this,[vec.len]</StringView>\n     <Expand>\n@@ -53,4 +53,4 @@\n       </ArrayItems>\n     </Expand>\n   </Type>\n-</AutoVisualizer>\n\\ No newline at end of file\n+</AutoVisualizer>", "previous_filename": "src/etc/natvis/libcollections.natvis"}, {"sha": "d008320713c3b828037709a56345656aad5b5cc6", "filename": "src/etc/platform-intrinsics/arm.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fplatform-intrinsics%2Farm.json", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Fplatform-intrinsics%2Farm.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Farm.json?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1,7 +1,7 @@\n {\n     \"platform\": \"arm_v\",\n     \"intrinsic_prefix\": \"\",\n-    \"llvm_prefix\": \"llvm.neon.v\",\n+    \"llvm_prefix\": \"llvm.arm.neon.v\",\n     \"number_info\": {\n         \"signed\": {\n             \"kind\": \"s\","}, {"sha": "b09b37c1db423080bd47f8f31155f57f14cb2e32", "filename": "src/etc/rust-windbg.cmd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Frust-windbg.cmd", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fetc%2Frust-windbg.cmd", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-windbg.cmd?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -15,4 +15,4 @@ for /f \"delims=\" %%i in ('rustc --print=sysroot') do set rustc_sysroot=%%i\n \n set rust_etc=%rustc_sysroot%\\lib\\rustlib\\etc\n \n-windbg -c \".nvload %rust_etc%\\libcore.natvis;.nvload %rust_etc%\\libcollections.natvis;\" %*\n\\ No newline at end of file\n+windbg -c \".nvload %rust_etc%\\liballoc.natvis; .nvload %rust_etc%\\libcore.natvis;\" %*"}, {"sha": "91652bfdf2467046f5e35083be2a81933b587de3", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -126,7 +126,7 @@ while    { return WHILE; }\n {ident}  { return IDENT; }\n \n 0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n-0o[0-8_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n+0o[0-7_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n 0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n [0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n [0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }"}, {"sha": "11bfb0dcf85f7aa92abd30524bb1e42e18d108c6", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1 +1 @@\n-Subproject commit 3288e0659c08fb5006f6d6dd4b5675ed0c2c432a\n+Subproject commit 11bfb0dcf85f7aa92abd30524bb1e42e18d108c6"}, {"sha": "686e5681d12b4c68625467efb04c3f3a0c424045", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -9,3 +9,12 @@ path = \"lib.rs\"\n \n [dependencies]\n core = { path = \"../libcore\" }\n+std_unicode = { path = \"../libstd_unicode\" }\n+\n+[[test]]\n+name = \"collectionstests\"\n+path = \"../liballoc/tests/lib.rs\"\n+\n+[[bench]]\n+name = \"collectionsbenches\"\n+path = \"../liballoc/benches/lib.rs\""}, {"sha": "7c51c4b161ca861693e07cfed920fe8b5b0b1935", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -42,7 +42,8 @@ use heap::deallocate;\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n-/// A thread-safe reference-counting pointer.\n+/// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n+/// Reference Counted'.\n ///\n /// The type `Arc<T>` provides shared ownership of a value of type `T`,\n /// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n@@ -1221,11 +1222,12 @@ mod tests {\n     use std::sync::atomic;\n     use std::sync::atomic::Ordering::{Acquire, SeqCst};\n     use std::thread;\n-    use std::vec::Vec;\n-    use super::{Arc, Weak};\n     use std::sync::Mutex;\n     use std::convert::From;\n \n+    use super::{Arc, Weak};\n+    use vec::Vec;\n+\n     struct Canary(*mut atomic::AtomicUsize);\n \n     impl Drop for Canary {"}, {"sha": "744afb991b00e99ebf4eff3cc8c7836796d6139c", "filename": "src/liballoc/benches/btree/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/btree/map.rs"}, {"sha": "f436b0ac0c0375063da64723236781c25f628b41", "filename": "src/liballoc/benches/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/btree/mod.rs"}, {"sha": "958020d0b0e0c33e3b70b803f187fc204c0f84bb", "filename": "src/liballoc/benches/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/lib.rs"}, {"sha": "bbac44553f18a267bfd7b016a3677d5e3e77ede5", "filename": "src/liballoc/benches/linked_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flinked_list.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/linked_list.rs"}, {"sha": "aa5a438b35e62341e5611755f233b1b12c7c830e", "filename": "src/liballoc/benches/slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/slice.rs"}, {"sha": "fc4063fae927754353d5e736099f0a365b0dd2d7", "filename": "src/liballoc/benches/str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/str.rs"}, {"sha": "36be21d978e1fdac8574e031a233a2915d062762", "filename": "src/liballoc/benches/string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstring.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/string.rs"}, {"sha": "414901170683effec41392bb7c3002e44a156d5a", "filename": "src/liballoc/benches/vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/vec.rs"}, {"sha": "380645e7cd03a9236f31f2ff4cdd88b61fa54aac", "filename": "src/liballoc/benches/vec_deque.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/benches/vec_deque.rs"}, {"sha": "988f88516255731e47a4f43cb9cdc9987b574afc", "filename": "src/liballoc/binary_heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/binary_heap.rs"}, {"sha": "a662e4b1f4f931de28292c8ed094f559e4d0b031", "filename": "src/liballoc/borrow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/borrow.rs"}, {"sha": "2f867912f582468c7fdf70589a10b8a29d9a980f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -95,6 +95,7 @@ pub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\",\n            issue = \"27779\")]\n+#[allow(missing_debug_implementations)]\n #[derive(Copy, Clone)]\n pub struct ExchangeHeapSingleton {\n     _force_singleton: (),\n@@ -129,6 +130,7 @@ pub struct Box<T: ?Sized>(Unique<T>);\n #[unstable(feature = \"placement_in\",\n            reason = \"placement box design is still being worked out.\",\n            issue = \"27779\")]\n+#[allow(missing_debug_implementations)]\n pub struct IntermediateBox<T: ?Sized> {\n     ptr: *mut u8,\n     size: usize,"}, {"sha": "d73c0254a74574221e1cd44d9ff12fe858cf588d", "filename": "src/liballoc/btree/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/btree/map.rs"}, {"sha": "087c9f228d4448bb6c119675ce28eac9e354a6b4", "filename": "src/liballoc/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/btree/mod.rs"}, {"sha": "811174b331e2b3669fa4bd9477fc6ecfbc23047f", "filename": "src/liballoc/btree/node.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -41,14 +41,14 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n-use alloc::heap;\n use core::marker::PhantomData;\n use core::mem;\n use core::nonzero::NonZero;\n use core::ptr::{self, Unique};\n use core::slice;\n \n use boxed::Box;\n+use heap;\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;", "previous_filename": "src/libcollections/btree/node.rs"}, {"sha": "bc1272fbc786e7aa4c2c9e39e24345c3a84f68a4", "filename": "src/liballoc/btree/search.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fsearch.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/btree/search.rs"}, {"sha": "d32460da9392342e12834e28d1e5684956297b0a", "filename": "src/liballoc/btree/set.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/btree/set.rs"}, {"sha": "62a88164621913fd494c67488ce5f1c720dada64", "filename": "src/liballoc/fmt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/fmt.rs"}, {"sha": "5252dabc12791d1b2ab308892c85fae7a9f688c1", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 150, "deletions": 10, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # The Rust core allocation library\n+//! # The Rust core allocation and collections library\n //!\n-//! This is the lowest level library through which allocation in Rust can be\n-//! performed.\n+//! This library provides smart pointers and collections for managing\n+//! heap-allocated values.\n //!\n //! This library, like libcore, is not intended for general usage, but rather as\n //! a building block of other libraries. The types and interfaces in this\n //! library are reexported through the [standard library](../std/index.html),\n //! and should not be used through this library.\n //!\n-//! Currently, there are four major definitions in this library.\n-//!\n //! ## Boxed values\n //!\n //! The [`Box`](boxed/index.html) type is a smart pointer type. There can\n@@ -51,6 +49,12 @@\n //! paired with synchronization primitives such as mutexes to allow mutation of\n //! shared resources.\n //!\n+//! ## Collections\n+//!\n+//! Implementations of the most common general purpose data structures are\n+//! defined in this library. They are reexported through the\n+//! [standard collections library](../std/collections/index.html).\n+//!\n //! ## Heap interfaces\n //!\n //! The [`heap`](heap/index.html) module defines the low-level interface to the\n@@ -71,25 +75,54 @@\n #![no_std]\n #![needs_allocator]\n #![deny(warnings)]\n+#![deny(missing_debug_implementations)]\n \n+#![cfg_attr(test, allow(deprecated))] // rand\n+#![cfg_attr(test, feature(placement_in))]\n+#![cfg_attr(not(test), feature(char_escape_debug))]\n+#![cfg_attr(not(test), feature(core_float))]\n+#![cfg_attr(not(test), feature(exact_size_is_empty))]\n+#![cfg_attr(not(test), feature(slice_rotate))]\n+#![cfg_attr(not(test), feature(sort_unstable))]\n+#![cfg_attr(not(test), feature(str_checked_slicing))]\n+#![cfg_attr(test, feature(rand, test))]\n #![feature(allocator)]\n+#![feature(allow_internal_unstable)]\n+#![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n-#![cfg_attr(not(test), feature(exact_size_is_empty))]\n+#![feature(exact_size_is_empty)]\n+#![feature(fmt_internals)]\n #![feature(fundamental)]\n+#![feature(fused)]\n #![feature(generic_param_attrs)]\n+#![feature(i128_type)]\n+#![feature(inclusive_range)]\n #![feature(lang_items)]\n+#![feature(manually_drop)]\n #![feature(needs_allocator)]\n+#![feature(nonzero)]\n+#![feature(offset_to)]\n #![feature(optin_builtin_traits)]\n+#![feature(pattern)]\n #![feature(placement_in_syntax)]\n+#![feature(placement_new_protocol)]\n #![feature(shared)]\n+#![feature(slice_get_slice)]\n+#![feature(slice_patterns)]\n+#![feature(slice_rsplit)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(str_internals)]\n+#![feature(str_mut_extras)]\n+#![feature(trusted_len)]\n #![feature(unboxed_closures)]\n+#![feature(unicode)]\n #![feature(unique)]\n #![feature(unsize)]\n \n@@ -101,6 +134,10 @@\n #[cfg(test)]\n #[macro_use]\n extern crate std;\n+#[cfg(test)]\n+extern crate test;\n+\n+extern crate std_unicode;\n \n // Module with internal macros used by other modules (needs to be included before other modules).\n #[macro_use]\n@@ -120,16 +157,119 @@ pub mod heap;\n pub mod boxed;\n #[cfg(test)]\n mod boxed {\n-    pub use std::boxed::{Box, HEAP};\n+    pub use std::boxed::{Box, IntermediateBox, HEAP};\n }\n #[cfg(test)]\n mod boxed_test;\n #[cfg(target_has_atomic = \"ptr\")]\n pub mod arc;\n pub mod rc;\n pub mod raw_vec;\n-#[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n-pub mod str;\n pub mod oom;\n \n+// collections modules\n+pub mod binary_heap;\n+mod btree;\n+pub mod borrow;\n+pub mod fmt;\n+pub mod linked_list;\n+pub mod range;\n+pub mod slice;\n+pub mod str;\n+pub mod string;\n+pub mod vec;\n+pub mod vec_deque;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod btree_map {\n+    //! A map based on a B-Tree.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use btree::map::*;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod btree_set {\n+    //! A set based on a B-Tree.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use btree::set::*;\n+}\n+\n+#[cfg(not(test))]\n+mod std {\n+    pub use core::ops;      // RangeFull\n+}\n+\n+/// An endpoint of a range of keys.\n+///\n+/// # Examples\n+///\n+/// `Bound`s are range endpoints:\n+///\n+/// ```\n+/// #![feature(collections_range)]\n+///\n+/// use std::collections::range::RangeArgument;\n+/// use std::collections::Bound::*;\n+///\n+/// assert_eq!((..100).start(), Unbounded);\n+/// assert_eq!((1..12).start(), Included(&1));\n+/// assert_eq!((1..12).end(), Excluded(&12));\n+/// ```\n+///\n+/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n+/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+/// use std::collections::Bound::{Excluded, Included, Unbounded};\n+///\n+/// let mut map = BTreeMap::new();\n+/// map.insert(3, \"a\");\n+/// map.insert(5, \"b\");\n+/// map.insert(8, \"c\");\n+///\n+/// for (key, value) in map.range((Excluded(3), Included(8))) {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n+/// ```\n+///\n+/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n+#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Included(T),\n+    /// An exclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Excluded(T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Unbounded,\n+}\n+\n+/// An intermediate trait for specialization of `Extend`.\n+#[doc(hidden)]\n+trait SpecExtend<I: IntoIterator> {\n+    /// Extends `self` with the contents of the given iterator.\n+    fn spec_extend(&mut self, iter: I);\n+}\n+\n pub use oom::oom;\n+\n+#[doc(no_inline)]\n+pub use binary_heap::BinaryHeap;\n+#[doc(no_inline)]\n+pub use btree_map::BTreeMap;\n+#[doc(no_inline)]\n+pub use btree_set::BTreeSet;\n+#[doc(no_inline)]\n+pub use linked_list::LinkedList;\n+#[doc(no_inline)]\n+pub use vec_deque::VecDeque;\n+#[doc(no_inline)]\n+pub use string::String;\n+#[doc(no_inline)]\n+pub use vec::Vec;"}, {"sha": "e8973b7d28537fa99d6eb49471afa021a1f441b1", "filename": "src/liballoc/linked_list.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -22,7 +22,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use alloc::boxed::{Box, IntermediateBox};\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n@@ -32,6 +31,7 @@ use core::mem;\n use core::ops::{BoxPlace, InPlace, Place, Placer};\n use core::ptr::{self, Shared};\n \n+use boxed::{Box, IntermediateBox};\n use super::SpecExtend;\n \n /// A doubly-linked list with owned nodes.", "previous_filename": "src/libcollections/linked_list.rs"}, {"sha": "763f04fcd0dcddb698170e89d1fb2d9f45e644d0", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -8,6 +8,89 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/// Creates a `Vec` containing the arguments.\n+///\n+/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n+/// There are two forms of this macro:\n+///\n+/// - Create a `Vec` containing a given list of elements:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+///\n+/// - Create a `Vec` from a given element and size:\n+///\n+/// ```\n+/// let v = vec![1; 3];\n+/// assert_eq!(v, [1, 1, 1]);\n+/// ```\n+///\n+/// Note that unlike array expressions this syntax supports all elements\n+/// which implement `Clone` and the number of elements doesn't have to be\n+/// a constant.\n+///\n+/// This will use `clone()` to duplicate an expression, so one should be careful\n+/// using this with types having a nonstandard `Clone` implementation. For\n+/// example, `vec![Rc::new(1); 5]` will create a vector of five references\n+/// to the same boxed integer value, not five references pointing to independently\n+/// boxed integers.\n+#[cfg(not(test))]\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow_internal_unstable]\n+macro_rules! vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::vec::from_elem($elem, $n)\n+    );\n+    ($($x:expr),*) => (\n+        <[_]>::into_vec(box [$($x),*])\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n+// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n+// required for this macro definition, is not available. Instead use the\n+// `slice::into_vec`  function which is only available with cfg(test)\n+// NB see the slice::hack module in slice.rs for more information\n+#[cfg(test)]\n+macro_rules! vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::vec::from_elem($elem, $n)\n+    );\n+    ($($x:expr),*) => (\n+        $crate::slice::into_vec(box [$($x),*])\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n+/// Use the syntax described in `std::fmt` to create a value of type `String`.\n+/// See [`std::fmt`][fmt] for more information.\n+///\n+/// [fmt]: ../std/fmt/index.html\n+///\n+/// # Panics\n+///\n+/// `format!` panics if a formatting trait implementation returns an error.\n+/// This indicates an incorrect implementation\n+/// since `fmt::Write for String` never returns an error itself.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10, y = 30);\n+/// ```\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+macro_rules! format {\n+    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n+}\n+\n // Private macro to get the offset of a struct field in bytes from the address of the struct.\n macro_rules! offset_of {\n     ($container:path, $field:ident) => {{"}, {"sha": "f862da0d61e012ed816811947a14f3fcab5005a5", "filename": "src/liballoc/range.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -27,14 +27,14 @@ pub trait RangeArgument<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections)]\n+    /// #![feature(alloc)]\n     /// #![feature(collections_range)]\n     ///\n-    /// extern crate collections;\n+    /// extern crate alloc;\n     ///\n     /// # fn main() {\n-    /// use collections::range::RangeArgument;\n-    /// use collections::Bound::*;\n+    /// use alloc::range::RangeArgument;\n+    /// use alloc::Bound::*;\n     ///\n     /// assert_eq!((..10).start(), Unbounded);\n     /// assert_eq!((3..10).start(), Included(&3));\n@@ -49,14 +49,14 @@ pub trait RangeArgument<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections)]\n+    /// #![feature(alloc)]\n     /// #![feature(collections_range)]\n     ///\n-    /// extern crate collections;\n+    /// extern crate alloc;\n     ///\n     /// # fn main() {\n-    /// use collections::range::RangeArgument;\n-    /// use collections::Bound::*;\n+    /// use alloc::range::RangeArgument;\n+    /// use alloc::Bound::*;\n     ///\n     /// assert_eq!((3..).end(), Unbounded);\n     /// assert_eq!((3..10).end(), Excluded(&10));", "previous_filename": "src/libcollections/range.rs"}, {"sha": "34ab0a19d4e0963035ee21189a15449c262e4024", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -44,6 +44,7 @@ use core::cmp;\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n+#[allow(missing_debug_implementations)]\n pub struct RawVec<T> {\n     ptr: Unique<T>,\n     cap: usize,"}, {"sha": "21a56ff9899e3b67dd614a9f16ae728df4555180", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -10,7 +10,8 @@\n \n #![allow(deprecated)]\n \n-//! Single-threaded reference-counting pointers.\n+//! Single-threaded reference-counting pointers. 'Rc' stands for 'Reference\n+//! Counted'.\n //!\n //! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n //! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n@@ -266,7 +267,8 @@ struct RcBox<T: ?Sized> {\n     value: T,\n }\n \n-/// A single-threaded reference-counting pointer.\n+/// A single-threaded reference-counting pointer. 'Rc' stands for 'Reference\n+/// Counted'.\n ///\n /// See the [module-level documentation](./index.html) for more details.\n ///\n@@ -426,7 +428,7 @@ impl Rc<str> {\n     #[doc(hidden)]\n     #[unstable(feature = \"rustc_private\",\n                reason = \"for internal use in rustc\",\n-               issue = \"0\")]\n+               issue = \"27812\")]\n     pub fn __from_str(value: &str) -> Rc<str> {\n         unsafe {\n             // Allocate enough space for `RcBox<str>`.\n@@ -451,7 +453,7 @@ impl<T> Rc<[T]> {\n     #[doc(hidden)]\n     #[unstable(feature = \"rustc_private\",\n                reason = \"for internal use in rustc\",\n-               issue = \"0\")]\n+               issue = \"27812\")]\n     pub fn __from_array(value: Box<[T]>) -> Rc<[T]> {\n         unsafe {\n             let ptr: *mut RcBox<[T]> ="}, {"sha": "88876999d765afc04b8be737998491ff330c0951", "filename": "src/liballoc/slice.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -97,14 +97,14 @@\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n-use alloc::boxed::Box;\n use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n use core::slice as core_slice;\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n+use boxed::Box;\n use vec::Vec;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -141,7 +141,7 @@ pub use self::hack::to_vec;\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n-    use alloc::boxed::Box;\n+    use boxed::Box;\n     use core::mem;\n \n     #[cfg(test)]", "previous_filename": "src/libcollections/slice.rs"}, {"sha": "f56288c30132c13e52196507acfcf17247c40aa7", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1982, "deletions": 1, "changes": 1983, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -8,11 +8,1992 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Methods for dealing with boxed strings.\n+//! Unicode string slices.\n+//!\n+//! The `&str` type is one of the two main string types, the other being `String`.\n+//! Unlike its `String` counterpart, its contents are borrowed.\n+//!\n+//! # Basic Usage\n+//!\n+//! A basic string declaration of `&str` type:\n+//!\n+//! ```\n+//! let hello_world = \"Hello, World!\";\n+//! ```\n+//!\n+//! Here we have declared a string literal, also known as a string slice.\n+//! String literals have a static lifetime, which means the string `hello_world`\n+//! is guaranteed to be valid for the duration of the entire program.\n+//! We can explicitly specify `hello_world`'s lifetime as well:\n+//!\n+//! ```\n+//! let hello_world: &'static str = \"Hello, world!\";\n+//! ```\n+//!\n+//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+// Many of the usings in this module are only used in the test configuration.\n+// It's cleaner to just turn off the unused_imports warning than to fix them.\n+#![allow(unused_imports)]\n+\n+use core::fmt;\n+use core::str as core_str;\n+use core::str::pattern::Pattern;\n+use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n+use core::iter::FusedIterator;\n+use std_unicode::str::{UnicodeStr, Utf16Encoder};\n \n+use vec_deque::VecDeque;\n+use borrow::{Borrow, ToOwned};\n+use string::String;\n+use std_unicode;\n+use vec::Vec;\n+use slice::{SliceConcatExt, SliceIndex};\n use boxed::Box;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{FromStr, Utf8Error};\n+#[allow(deprecated)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{Lines, LinesAny};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{Split, RSplit};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{SplitN, RSplitN};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{SplitTerminator, RSplitTerminator};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{Matches, RMatches};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{MatchIndices, RMatchIndices};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use std_unicode::str::SplitWhitespace;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::pattern;\n+\n+\n+#[unstable(feature = \"slice_concat_ext\",\n+           reason = \"trait should not have to exist\",\n+           issue = \"27747\")]\n+impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n+    type Output = String;\n+\n+    fn concat(&self) -> String {\n+        if self.is_empty() {\n+            return String::new();\n+        }\n+\n+        // `len` calculation may overflow but push_str will check boundaries\n+        let len = self.iter().map(|s| s.borrow().len()).sum();\n+        let mut result = String::with_capacity(len);\n+\n+        for s in self {\n+            result.push_str(s.borrow())\n+        }\n+\n+        result\n+    }\n+\n+    fn join(&self, sep: &str) -> String {\n+        if self.is_empty() {\n+            return String::new();\n+        }\n+\n+        // concat is faster\n+        if sep.is_empty() {\n+            return self.concat();\n+        }\n+\n+        // this is wrong without the guarantee that `self` is non-empty\n+        // `len` calculation may overflow but push_str but will check boundaries\n+        let len = sep.len() * (self.len() - 1) +\n+                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n+        let mut result = String::with_capacity(len);\n+        let mut first = true;\n+\n+        for s in self {\n+            if first {\n+                first = false;\n+            } else {\n+                result.push_str(sep);\n+            }\n+            result.push_str(s.borrow());\n+        }\n+        result\n+    }\n+\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n+    }\n+}\n+\n+/// An iterator of [`u16`] over the string encoded as UTF-16.\n+///\n+/// [`u16`]: ../../std/primitive.u16.html\n+///\n+/// This struct is created by the [`encode_utf16`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n+/// [`str`]: ../../std/primitive.str.html\n+#[derive(Clone)]\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub struct EncodeUtf16<'a> {\n+    encoder: Utf16Encoder<Chars<'a>>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<'a> fmt::Debug for EncodeUtf16<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EncodeUtf16 { .. }\")\n+    }\n+}\n+\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+impl<'a> Iterator for EncodeUtf16<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        self.encoder.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.encoder.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a> FusedIterator for EncodeUtf16<'a> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Borrow<str> for String {\n+    #[inline]\n+    fn borrow(&self) -> &str {\n+        &self[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToOwned for str {\n+    type Owned = String;\n+    fn to_owned(&self) -> String {\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n+    }\n+\n+    fn clone_into(&self, target: &mut String) {\n+        let mut b = mem::replace(target, String::new()).into_bytes();\n+        self.as_bytes().clone_into(&mut b);\n+        *target = unsafe { String::from_utf8_unchecked(b) }\n+    }\n+}\n+\n+/// Methods for string slices.\n+#[lang = \"str\"]\n+#[cfg(not(test))]\n+impl str {\n+    /// Returns the length of `self`.\n+    ///\n+    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n+    /// it may not be what a human considers the length of the string.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let len = \"foo\".len();\n+    /// assert_eq!(3, len);\n+    ///\n+    /// let len = \"\u0192oo\".len(); // fancy f!\n+    /// assert_eq!(4, len);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        core_str::StrExt::len(self)\n+    }\n+\n+    /// Returns `true` if `self` has a length of zero bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"\";\n+    /// assert!(s.is_empty());\n+    ///\n+    /// let s = \"not empty\";\n+    /// assert!(!s.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        core_str::StrExt::is_empty(self)\n+    }\n+\n+    /// Checks that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`) are\n+    /// considered to be\n+    /// boundaries.\n+    ///\n+    /// Returns `false` if `index` is greater than `self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n+    #[inline]\n+    pub fn is_char_boundary(&self, index: usize) -> bool {\n+        core_str::StrExt::is_char_boundary(self, index)\n+    }\n+\n+    /// Converts a string slice to a byte slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bytes = \"bors\".as_bytes();\n+    /// assert_eq!(b\"bors\", bytes);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline(always)]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        core_str::StrExt::as_bytes(self)\n+    }\n+\n+    /// Converts a mutable string slice to a mutable byte slice.\n+    #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n+    #[inline(always)]\n+    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n+        core_str::StrExt::as_bytes_mut(self)\n+    }\n+\n+    /// Converts a string slice to a raw pointer.\n+    ///\n+    /// As string slices are a slice of bytes, the raw pointer points to a\n+    /// [`u8`]. This pointer will be pointing to the first byte of the string\n+    /// slice.\n+    ///\n+    /// [`u8`]: primitive.u8.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Hello\";\n+    /// let ptr = s.as_ptr();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const u8 {\n+        core_str::StrExt::as_ptr(self)\n+    }\n+\n+    /// Returns a subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n+    /// assert!(v.get(1..).is_none());\n+    /// assert!(v.get(..8).is_none());\n+    /// assert!(v.get(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        core_str::StrExt::get(self, i)\n+    }\n+\n+    /// Returns a mutable subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n+    /// assert!(v.get_mut(1..).is_none());\n+    /// assert!(v.get_mut(..8).is_none());\n+    /// assert!(v.get_mut(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        core_str::StrExt::get_mut(self, i)\n+    }\n+\n+    /// Returns a unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        core_str::StrExt::get_unchecked(self, i)\n+    }\n+\n+    /// Returns a mutable, unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        core_str::StrExt::get_unchecked_mut(self, i)\n+    }\n+\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`Index`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`Index`]: ops/trait.Index.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get a mutable string slice instead, see the\n+    /// [`slice_mut_unchecked`] method.\n+    ///\n+    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n+    /// }\n+    ///\n+    /// let s = \"Hello, world!\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n+        core_str::StrExt::slice_unchecked(self, begin, end)\n+    }\n+\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`IndexMut`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`IndexMut`]: ops/trait.IndexMut.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get an immutable string slice instead, see the\n+    /// [`slice_unchecked`] method.\n+    ///\n+    /// [`slice_unchecked`]: #method.slice_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n+    #[inline]\n+    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n+    }\n+\n+    /// Divide one string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get mutable string slices instead, see the [`split_at_mut`]\n+    /// method.\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Per Martin-L\u00f6f\";\n+    ///\n+    /// let (first, last) = s.split_at(3);\n+    ///\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n+        core_str::StrExt::split_at(self, mid)\n+    }\n+\n+    /// Divide one mutable string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get immutable string slices instead, see the [`split_at`] method.\n+    ///\n+    /// [`split_at`]: #method.split_at\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n+    ///\n+    /// let (first, last) = s.split_at_mut(3);\n+    ///\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        core_str::StrExt::split_at_mut(self, mid)\n+    }\n+\n+    /// Returns an iterator over the [`char`]s of a string slice.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns such an iterator.\n+    ///\n+    /// It's important to remember that [`char`] represents a Unicode Scalar\n+    /// Value, and may not match your idea of what a 'character' is. Iteration\n+    /// over grapheme clusters may be what you actually want.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.chars().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut chars = word.chars();\n+    ///\n+    /// assert_eq!(Some('g'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('d'), chars.next());\n+    /// assert_eq!(Some('b'), chars.next());\n+    /// assert_eq!(Some('y'), chars.next());\n+    /// assert_eq!(Some('e'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut chars = y.chars();\n+    ///\n+    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n+    /// assert_eq!(Some('\\u{0306}'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chars(&self) -> Chars {\n+        core_str::StrExt::chars(self)\n+    }\n+    /// Returns an iterator over the [`char`]s of a string slice, and their\n+    /// positions.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns an iterator of both\n+    /// these [`char`]s, as well as their byte positions.\n+    ///\n+    /// The iterator yields tuples. The position is first, the [`char`] is\n+    /// second.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.char_indices().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut char_indices = word.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'g')), char_indices.next());\n+    /// assert_eq!(Some((1, 'o')), char_indices.next());\n+    /// assert_eq!(Some((2, 'o')), char_indices.next());\n+    /// assert_eq!(Some((3, 'd')), char_indices.next());\n+    /// assert_eq!(Some((4, 'b')), char_indices.next());\n+    /// assert_eq!(Some((5, 'y')), char_indices.next());\n+    /// assert_eq!(Some((6, 'e')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut char_indices = y.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n+    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn char_indices(&self) -> CharIndices {\n+        core_str::StrExt::char_indices(self)\n+    }\n+\n+    /// An iterator over the bytes of a string slice.\n+    ///\n+    /// As a string slice consists of a sequence of bytes, we can iterate\n+    /// through a string slice by byte. This method returns such an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut bytes = \"bors\".bytes();\n+    ///\n+    /// assert_eq!(Some(b'b'), bytes.next());\n+    /// assert_eq!(Some(b'o'), bytes.next());\n+    /// assert_eq!(Some(b'r'), bytes.next());\n+    /// assert_eq!(Some(b's'), bytes.next());\n+    ///\n+    /// assert_eq!(None, bytes.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn bytes(&self) -> Bytes {\n+        core_str::StrExt::bytes(self)\n+    }\n+\n+    /// Split a string slice by whitespace.\n+    ///\n+    /// The iterator returned will return string slices that are sub-slices of\n+    /// the original string slice, separated by any amount of whitespace.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut iter = \"A few words\".split_whitespace();\n+    ///\n+    /// assert_eq!(Some(\"A\"), iter.next());\n+    /// assert_eq!(Some(\"few\"), iter.next());\n+    /// assert_eq!(Some(\"words\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    ///\n+    /// All kinds of whitespace are considered:\n+    ///\n+    /// ```\n+    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n+    /// assert_eq!(Some(\"Mary\"), iter.next());\n+    /// assert_eq!(Some(\"had\"), iter.next());\n+    /// assert_eq!(Some(\"a\"), iter.next());\n+    /// assert_eq!(Some(\"little\"), iter.next());\n+    /// assert_eq!(Some(\"lamb\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    #[inline]\n+    pub fn split_whitespace(&self) -> SplitWhitespace {\n+        UnicodeStr::split_whitespace(self)\n+    }\n+\n+    /// An iterator over the lines of a string, as string slices.\n+    ///\n+    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n+    /// a line feed (`\\r\\n`).\n+    ///\n+    /// The final line ending is optional.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    ///\n+    /// The final line ending isn't required:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn lines(&self) -> Lines {\n+        core_str::StrExt::lines(self)\n+    }\n+\n+    /// An iterator over the lines of a string.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n+    #[inline]\n+    #[allow(deprecated)]\n+    pub fn lines_any(&self) -> LinesAny {\n+        core_str::StrExt::lines_any(self)\n+    }\n+\n+    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n+    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+    pub fn encode_utf16(&self) -> EncodeUtf16 {\n+        EncodeUtf16 { encoder: Utf16Encoder::new(self[..].chars()) }\n+    }\n+\n+    /// Returns `true` if the given pattern matches a sub-slice of\n+    /// this string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.contains(\"nana\"));\n+    /// assert!(!bananas.contains(\"apples\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::contains(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a prefix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.starts_with(\"bana\"));\n+    /// assert!(!bananas.starts_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::starts_with(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a suffix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.ends_with(\"anas\"));\n+    /// assert!(!bananas.ends_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::ends_with(self, pat)\n+    }\n+\n+    /// Returns the byte index of the first character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n+    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.find(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        core_str::StrExt::find(self, pat)\n+    }\n+\n+    /// Returns the byte index of the last character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n+    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.rfind(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rfind(self, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit`] method can be used.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`rsplit`]: #method.rsplit\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    /// ```\n+    ///\n+    /// If a string contains multiple contiguous separators, you will end up\n+    /// with empty strings in the output:\n+    ///\n+    /// ```\n+    /// let x = \"||||a||b|c\".to_string();\n+    /// let d: Vec<_> = x.split('|').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators are separated by the empty string.\n+    ///\n+    /// ```\n+    /// let x = \"(///)\".to_string();\n+    /// let d: Vec<_> = x.split('/').collect();\n+    ///\n+    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n+    /// ```\n+    ///\n+    /// Separators at the start or end of a string are neighbored\n+    /// by empty strings.\n+    ///\n+    /// ```\n+    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n+    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n+    /// ```\n+    ///\n+    /// When the empty string is used as a separator, it separates\n+    /// every character in the string, along with the beginning\n+    /// and end of the string.\n+    ///\n+    /// ```\n+    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n+    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators can lead to possibly surprising behavior\n+    /// when whitespace is used as the separator. This code is correct:\n+    ///\n+    /// ```\n+    /// let x = \"    a  b c\".to_string();\n+    /// let d: Vec<_> = x.split(' ').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// It does _not_ give you:\n+    ///\n+    /// ```,ignore\n+    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Use [`split_whitespace`] for this behavior.\n+    ///\n+    /// [`split_whitespace`]: #method.split_whitespace\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n+        core_str::StrExt::split(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`split`] method can be used.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring\n+    /// is skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit_terminator`] method can be used.\n+    ///\n+    /// [`rsplit_terminator`]: #method.rsplit_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n+        core_str::StrExt::split_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring is\n+    /// skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search, and it will be double ended if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// For iterating from the front, the [`split_terminator`] method can be\n+    /// used.\n+    ///\n+    /// [`split_terminator`]: #method.split_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n+    /// assert_eq!(v, [\"B\", \"A\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by a\n+    /// pattern, restricted to returning at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is\n+    /// not efficient to support.\n+    ///\n+    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n+    /// used.\n+    ///\n+    /// [`rsplitn`]: #method.rsplitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(self, n, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by a\n+    /// pattern, starting from the end of the string, restricted to returning\n+    /// at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not\n+    /// efficient to support.\n+    ///\n+    /// For splitting from the front, the [`splitn`] method can be used.\n+    ///\n+    /// [`splitn`]: #method.splitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplitn(self, n, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within the given string\n+    /// slice.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatches`] method can be used.\n+    ///\n+    /// [`rmatches`]: #method.rmatches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n+    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        core_str::StrExt::matches(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within this string slice,\n+    /// yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`matches`] method can be used.\n+    ///\n+    /// [`matches`]: #method.matches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n+    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatches(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within this string\n+    /// slice as well as the index that the match starts at.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the first match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines\n+    /// if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatch_indices`] method can be used.\n+    ///\n+    /// [`rmatch_indices`]: #method.rmatch_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n+        core_str::StrExt::match_indices(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within `self`,\n+    /// yielded in reverse order along with the index of the match.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the last match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`match_indices`] method can be used.\n+    ///\n+    /// [`match_indices`]: #method.match_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatch_indices(self, pat)\n+    }\n+\n+    /// Returns a string slice with leading and trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\", s.trim());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim(&self) -> &str {\n+        UnicodeStr::trim(self)\n+    }\n+\n+    /// Returns a string slice with leading whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"  English\";\n+    /// assert!(Some('E') == s.trim_left().chars().next());\n+    ///\n+    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n+    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left(&self) -> &str {\n+        UnicodeStr::trim_left(self)\n+    }\n+\n+    /// Returns a string slice with trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"English  \";\n+    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n+    ///\n+    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n+    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right(&self) -> &str {\n+        UnicodeStr::trim_right(self)\n+    }\n+\n+    /// Returns a string slice with all prefixes and suffixes that match a\n+    /// pattern repeatedly removed.\n+    ///\n+    /// The pattern can be a [`char`] or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n+        core_str::StrExt::trim_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all prefixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        core_str::StrExt::trim_left_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all suffixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::trim_right_matches(self, pat)\n+    }\n+\n+    /// Parses this string slice into another type.\n+    ///\n+    /// Because `parse` is so general, it can cause problems with type\n+    /// inference. As such, `parse` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which type\n+    /// you're trying to parse into.\n+    ///\n+    /// `parse` can parse any type that implements the [`FromStr`] trait.\n+    ///\n+    /// [`FromStr`]: str/trait.FromStr.html\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will return [`Err`] if it's not possible to parse this string slice into\n+    /// the desired type.\n+    ///\n+    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n+    ///\n+    /// # Example\n+    ///\n+    /// Basic usage\n+    ///\n+    /// ```\n+    /// let four: u32 = \"4\".parse().unwrap();\n+    ///\n+    /// assert_eq!(4, four);\n+    /// ```\n+    ///\n+    /// Using the 'turbofish' instead of annotating `four`:\n+    ///\n+    /// ```\n+    /// let four = \"4\".parse::<u32>();\n+    ///\n+    /// assert_eq!(Ok(4), four);\n+    /// ```\n+    ///\n+    /// Failing to parse:\n+    ///\n+    /// ```\n+    /// let nope = \"j\".parse::<u32>();\n+    ///\n+    /// assert!(nope.is_err());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n+        core_str::StrExt::parse(self)\n+    }\n+\n+    /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n+    #[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n+    pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n+        self.into()\n+    }\n+\n+    /// Replaces all matches of a pattern with another string.\n+    ///\n+    /// `replace` creates a new [`String`], and copies the data from this string slice into it.\n+    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n+    /// replaces them with the replacement string slice.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    ///\n+    /// assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n+    /// ```\n+    ///\n+    /// When the pattern doesn't match:\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n+        let mut result = String::new();\n+        let mut last_end = 0;\n+        for (start, part) in self.match_indices(from) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = start + part.len();\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n+    }\n+\n+    /// Replaces first N matches of a pattern with another string.\n+    ///\n+    /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n+    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n+    /// replaces them with the replacement string slice at most `count` times.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"foo foo 123 foo\";\n+    /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n+    /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n+    /// assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n+    /// ```\n+    ///\n+    /// When the pattern doesn't match:\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n+    /// ```\n+    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n+    pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n+        // Hope to reduce the times of re-allocation\n+        let mut result = String::with_capacity(32);\n+        let mut last_end = 0;\n+        for (start, part) in self.match_indices(pat).take(count) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = start + part.len();\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n+    }\n+\n+    /// Returns the lowercase equivalent of this string slice, as a new [`String`].\n+    ///\n+    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n+    /// `Lowercase`.\n+    ///\n+    /// Since some characters can expand into multiple characters when changing\n+    /// the case, this function returns a [`String`] instead of modifying the\n+    /// parameter in-place.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"HELLO\";\n+    ///\n+    /// assert_eq!(\"hello\", s.to_lowercase());\n+    /// ```\n+    ///\n+    /// A tricky example, with sigma:\n+    ///\n+    /// ```\n+    /// let sigma = \"\u03a3\";\n+    ///\n+    /// assert_eq!(\"\u03c3\", sigma.to_lowercase());\n+    ///\n+    /// // but at the end of a word, it's \u03c2, not \u03c3:\n+    /// let odysseus = \"\u1f48\u0394\u03a5\u03a3\u03a3\u0395\u038e\u03a3\";\n+    ///\n+    /// assert_eq!(\"\u1f40\u03b4\u03c5\u03c3\u03c3\u03b5\u03cd\u03c2\", odysseus.to_lowercase());\n+    /// ```\n+    ///\n+    /// Languages without case are not changed:\n+    ///\n+    /// ```\n+    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n+    ///\n+    /// assert_eq!(new_year, new_year.to_lowercase());\n+    /// ```\n+    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n+    pub fn to_lowercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        for (i, c) in self[..].char_indices() {\n+            if c == '\u03a3' {\n+                // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n+                // This is the only conditional (contextual) but language-independent mapping\n+                // in `SpecialCasing.txt`,\n+                // so hard-code it rather than have a generic \"condition\" mechanism.\n+                // See https://github.com/rust-lang/rust/issues/26035\n+                map_uppercase_sigma(self, i, &mut s)\n+            } else {\n+                s.extend(c.to_lowercase());\n+            }\n+        }\n+        return s;\n+\n+        fn map_uppercase_sigma(from: &str, i: usize, to: &mut String) {\n+            // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+            // for the definition of `Final_Sigma`.\n+            debug_assert!('\u03a3'.len_utf8() == 2);\n+            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n+                                !case_ignoreable_then_cased(from[i + 2..].chars());\n+            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n+        }\n+\n+        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n+            use std_unicode::derived_property::{Cased, Case_Ignorable};\n+            match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n+                Some(c) => Cased(c),\n+                None => false,\n+            }\n+        }\n+    }\n+\n+    /// Returns the uppercase equivalent of this string slice, as a new [`String`].\n+    ///\n+    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n+    /// `Uppercase`.\n+    ///\n+    /// Since some characters can expand into multiple characters when changing\n+    /// the case, this function returns a [`String`] instead of modifying the\n+    /// parameter in-place.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"hello\";\n+    ///\n+    /// assert_eq!(\"HELLO\", s.to_uppercase());\n+    /// ```\n+    ///\n+    /// Scripts without case are not changed:\n+    ///\n+    /// ```\n+    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n+    ///\n+    /// assert_eq!(new_year, new_year.to_uppercase());\n+    /// ```\n+    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n+    pub fn to_uppercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        s.extend(self.chars().flat_map(|c| c.to_uppercase()));\n+        return s;\n+    }\n+\n+    /// Escapes each char in `s` with [`char::escape_debug`].\n+    ///\n+    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n+    #[unstable(feature = \"str_escape\",\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n+    pub fn escape_debug(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_debug()).collect()\n+    }\n+\n+    /// Escapes each char in `s` with [`char::escape_default`].\n+    ///\n+    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n+    #[unstable(feature = \"str_escape\",\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n+    pub fn escape_default(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_default()).collect()\n+    }\n+\n+    /// Escapes each char in `s` with [`char::escape_unicode`].\n+    ///\n+    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n+    #[unstable(feature = \"str_escape\",\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n+    pub fn escape_unicode(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_unicode()).collect()\n+    }\n+\n+    /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    /// [`Box<str>`]: boxed/struct.Box.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let string = String::from(\"birthday gift\");\n+    /// let boxed_str = string.clone().into_boxed_str();\n+    ///\n+    /// assert_eq!(boxed_str.into_string(), string);\n+    /// ```\n+    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n+    pub fn into_string(self: Box<str>) -> String {\n+        unsafe {\n+            let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);\n+            String::from_utf8_unchecked(slice.into_vec())\n+        }\n+    }\n+\n+    /// Create a [`String`] by repeating a string `n` times.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n+    /// ```\n+    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n+    pub fn repeat(&self, n: usize) -> String {\n+        let mut s = String::with_capacity(self.len() * n);\n+        s.extend((0..n).map(|_| self));\n+        s\n+    }\n+}\n+\n /// Converts a boxed slice of bytes to a boxed string slice without checking\n /// that the string contains valid UTF-8.\n #[unstable(feature = \"str_box_extras\", issue = \"41119\")]"}, {"sha": "2cb81029f95e2a1ea89d9fb4aad1ca5111456057", "filename": "src/liballoc/string.rs", "status": "renamed", "additions": 24, "deletions": 103, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -56,21 +56,19 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use alloc::str as alloc_str;\n-\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n use core::ops::{self, Add, AddAssign, Index, IndexMut};\n use core::ptr;\n-use core::str as core_str;\n use core::str::pattern::Pattern;\n+use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n use range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};\n-use str::{self, FromStr, Utf8Error, Chars};\n+use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n \n@@ -535,111 +533,34 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n-        let mut i;\n-        match str::from_utf8(v) {\n-            Ok(s) => return Cow::Borrowed(s),\n-            Err(e) => i = e.valid_up_to(),\n-        }\n+        let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n \n-        const TAG_CONT_U8: u8 = 128;\n-        const REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n-        let total = v.len();\n-        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n-            unsafe { *xs.get_unchecked(i) }\n-        }\n-        fn safe_get(xs: &[u8], i: usize, total: usize) -> u8 {\n-            if i >= total { 0 } else { unsafe_get(xs, i) }\n-        }\n+        let (first_valid, first_broken) = if let Some(chunk) = iter.next() {\n+            let lossy::Utf8LossyChunk { valid, broken } = chunk;\n+            if valid.len() == v.len() {\n+                debug_assert!(broken.is_empty());\n+                return Cow::Borrowed(valid);\n+            }\n+            (valid, broken)\n+        } else {\n+            return Cow::Borrowed(\"\");\n+        };\n \n-        let mut res = String::with_capacity(total);\n+        const REPLACEMENT: &'static str = \"\\u{FFFD}\";\n \n-        if i > 0 {\n-            unsafe { res.as_mut_vec().extend_from_slice(&v[..i]) };\n+        let mut res = String::with_capacity(v.len());\n+        res.push_str(first_valid);\n+        if !first_broken.is_empty() {\n+            res.push_str(REPLACEMENT);\n         }\n \n-        // subseqidx is the index of the first byte of the subsequence we're\n-        // looking at.  It's used to copy a bunch of contiguous good codepoints\n-        // at once instead of copying them one by one.\n-        let mut subseqidx = i;\n-\n-        while i < total {\n-            let i_ = i;\n-            let byte = unsafe_get(v, i);\n-            i += 1;\n-\n-            macro_rules! error { () => ({\n-                unsafe {\n-                    if subseqidx != i_ {\n-                        res.as_mut_vec().extend_from_slice(&v[subseqidx..i_]);\n-                    }\n-                    subseqidx = i;\n-                    res.as_mut_vec().extend_from_slice(REPLACEMENT);\n-                }\n-            })}\n-\n-            if byte < 128 {\n-                // subseqidx handles this\n-            } else {\n-                let w = core_str::utf8_char_width(byte);\n-\n-                match w {\n-                    2 => {\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    3 => {\n-                        match (byte, safe_get(v, i, total)) {\n-                            (0xE0, 0xA0...0xBF) => (),\n-                            (0xE1...0xEC, 0x80...0xBF) => (),\n-                            (0xED, 0x80...0x9F) => (),\n-                            (0xEE...0xEF, 0x80...0xBF) => (),\n-                            _ => {\n-                                error!();\n-                                continue;\n-                            }\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    4 => {\n-                        match (byte, safe_get(v, i, total)) {\n-                            (0xF0, 0x90...0xBF) => (),\n-                            (0xF1...0xF3, 0x80...0xBF) => (),\n-                            (0xF4, 0x80...0x8F) => (),\n-                            _ => {\n-                                error!();\n-                                continue;\n-                            }\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    _ => {\n-                        error!();\n-                        continue;\n-                    }\n-                }\n+        for lossy::Utf8LossyChunk { valid, broken } in iter {\n+            res.push_str(valid);\n+            if !broken.is_empty() {\n+                res.push_str(REPLACEMENT);\n             }\n         }\n-        if subseqidx < total {\n-            unsafe { res.as_mut_vec().extend_from_slice(&v[subseqidx..total]) };\n-        }\n+\n         Cow::Owned(res)\n     }\n \n@@ -1464,7 +1385,7 @@ impl String {\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n     pub fn into_boxed_str(self) -> Box<str> {\n         let slice = self.vec.into_boxed_slice();\n-        unsafe { alloc_str::from_boxed_utf8_unchecked(slice) }\n+        unsafe { from_boxed_utf8_unchecked(slice) }\n     }\n }\n ", "previous_filename": "src/libcollections/string.rs"}, {"sha": "06d585f8ea82f699e64a181921554f237083ff21", "filename": "src/liballoc/tests/binary_heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/binary_heap.rs"}, {"sha": "2c899d96940ece9e222adc3ff21600f7f164c708", "filename": "src/liballoc/tests/btree/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/btree/map.rs"}, {"sha": "ae8b18d0c9fd92203fef9cc2bfd826aad5883bcc", "filename": "src/liballoc/tests/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/btree/mod.rs"}, {"sha": "6171b8ba624cd5581b505d3eb47cfc43d8e81c7c", "filename": "src/liballoc/tests/btree/set.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/btree/set.rs"}, {"sha": "aa87ee84b3e9769ea36625c20afc7ec77a3698f6", "filename": "src/liballoc/tests/cow_str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fcow_str.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/cow_str.rs"}, {"sha": "70e21c65a1806549eb10764d5bbb67ddfb616a6e", "filename": "src/liballoc/tests/fmt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Ffmt.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/fmt.rs"}, {"sha": "c6d70ee7575f8a6754159504da48bd1075d0e4f6", "filename": "src/liballoc/tests/lib.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -10,11 +10,11 @@\n \n #![deny(warnings)]\n \n+#![feature(alloc)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n #![feature(inclusive_range_syntax)]\n #![feature(collection_placement)]\n-#![feature(collections)]\n #![feature(const_fn)]\n #![feature(exact_size_is_empty)]\n #![feature(iterator_step_by)]\n@@ -24,13 +24,14 @@\n #![feature(repr_align)]\n #![feature(slice_rotate)]\n #![feature(splice)]\n+#![feature(str_checked_slicing)]\n #![feature(str_escape)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(utf8_error_error_len)]\n \n-extern crate collections;\n+extern crate alloc;\n extern crate test;\n extern crate std_unicode;\n extern crate core;", "previous_filename": "src/libcollections/tests/lib.rs"}, {"sha": "a59724a017b1241de3e9995727a719782b76ea7f", "filename": "src/liballoc/tests/linked_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/linked_list.rs"}, {"sha": "7fa65a2144e9b47d1f3f093c04fa980bc6bf5596", "filename": "src/liballoc/tests/slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/slice.rs"}, {"sha": "9d8ca38b20e48c822af8beb5f756c25c88ad5d7e", "filename": "src/liballoc/tests/str.rs", "status": "renamed", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -358,6 +358,48 @@ fn test_slice_fail() {\n     &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n }\n \n+#[test]\n+#[should_panic]\n+fn test_str_slice_rangetoinclusive_max_panics() {\n+    &\"hello\"[...usize::max_value()];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_slice_rangeinclusive_max_panics() {\n+    &\"hello\"[1...usize::max_value()];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_slicemut_rangetoinclusive_max_panics() {\n+    let mut s = \"hello\".to_owned();\n+    let s: &mut str = &mut s;\n+    &mut s[...usize::max_value()];\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_str_slicemut_rangeinclusive_max_panics() {\n+    let mut s = \"hello\".to_owned();\n+    let s: &mut str = &mut s;\n+    &mut s[1...usize::max_value()];\n+}\n+\n+#[test]\n+fn test_str_get_maxinclusive() {\n+    let mut s = \"hello\".to_owned();\n+    {\n+        let s: &str = &s;\n+        assert_eq!(s.get(...usize::max_value()), None);\n+        assert_eq!(s.get(1...usize::max_value()), None);\n+    }\n+    {\n+        let s: &mut str = &mut s;\n+        assert_eq!(s.get(...usize::max_value()), None);\n+        assert_eq!(s.get(1...usize::max_value()), None);\n+    }\n+}\n \n #[test]\n fn test_is_char_boundary() {", "previous_filename": "src/libcollections/tests/str.rs"}, {"sha": "b1731b2a5dcaa486b8e189e97b88dbdf23b9e85f", "filename": "src/liballoc/tests/string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/string.rs"}, {"sha": "fdf453b39cf5d9144c21cf9c4091af7c41c44312", "filename": "src/liballoc/tests/vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/vec.rs"}, {"sha": "a992351653d7b996e2f2100c57f5c8c1c4ee82a1", "filename": "src/liballoc/tests/vec_deque.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "previous_filename": "src/libcollections/tests/vec_deque.rs"}, {"sha": "8bb16febb0483cbb8465da8435a052060e59d88b", "filename": "src/liballoc/vec.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! A contiguous growable array type with heap-allocated contents, written\n-//! `Vec<T>` but pronounced 'vector.'\n+//! `Vec<T>`.\n //!\n //! Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and\n //! `O(1)` pop (from the end).\n@@ -66,10 +66,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use alloc::boxed::Box;\n-use alloc::raw_vec::RawVec;\n-use borrow::ToOwned;\n-use borrow::Cow;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n@@ -84,6 +80,10 @@ use core::ptr;\n use core::ptr::Shared;\n use core::slice;\n \n+use borrow::ToOwned;\n+use borrow::Cow;\n+use boxed::Box;\n+use raw_vec::RawVec;\n use super::range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};\n ", "previous_filename": "src/libcollections/vec.rs"}, {"sha": "18175a5d01bd2bc7bb13400a2a7aedae265d6437", "filename": "src/liballoc/vec_deque.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -29,7 +29,7 @@ use core::slice;\n use core::hash::{Hash, Hasher};\n use core::cmp;\n \n-use alloc::raw_vec::RawVec;\n+use raw_vec::RawVec;\n \n use super::range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};", "previous_filename": "src/libcollections/vec_deque.rs"}, {"sha": "f3a0eebe6984d2a11ca73d93871b6c4314683c15", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -93,7 +93,29 @@ fn main() {\n        .env(\"AR\", &ar)\n        .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n \n-    if target.contains(\"ios\") {\n+    if target.contains(\"windows\") {\n+        // A bit of history here, this used to be --enable-lazy-lock added in\n+        // #14006 which was filed with jemalloc in jemalloc/jemalloc#83 which\n+        // was also reported to MinGW:\n+        //\n+        //  http://sourceforge.net/p/mingw-w64/bugs/395/\n+        //\n+        // When updating jemalloc to 4.0, however, it was found that binaries\n+        // would exit with the status code STATUS_RESOURCE_NOT_OWNED indicating\n+        // that a thread was unlocking a mutex it never locked. Disabling this\n+        // \"lazy lock\" option seems to fix the issue, but it was enabled by\n+        // default for MinGW targets in 13473c7 for jemalloc.\n+        //\n+        // As a result of all that, force disabling lazy lock on Windows, and\n+        // after reading some code it at least *appears* that the initialization\n+        // of mutexes is otherwise ok in jemalloc, so shouldn't cause problems\n+        // hopefully...\n+        //\n+        // tl;dr: make windows behave like other platforms by disabling lazy\n+        //        locking, but requires passing an option due to a historical\n+        //        default with jemalloc.\n+        cmd.arg(\"--disable-lazy-lock\");\n+    } else if target.contains(\"ios\") {\n         cmd.arg(\"--disable-tls\");\n     } else if target.contains(\"android\") {\n         // We force android to have prefixed symbols because apparently"}, {"sha": "800e36161d245b39f36c3e33e8c0bc1daaa91641", "filename": "src/libcollections/Cargo.toml", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -10,12 +10,3 @@ path = \"lib.rs\"\n [dependencies]\n alloc = { path = \"../liballoc\" }\n core = { path = \"../libcore\" }\n-std_unicode = { path = \"../libstd_unicode\" }\n-\n-[[test]]\n-name = \"collectionstests\"\n-path = \"../libcollections/tests/lib.rs\"\n-\n-[[bench]]\n-name = \"collectionsbenches\"\n-path = \"../libcollections/benches/lib.rs\""}, {"sha": "de5d6df328cbd4fd7ca975e115c925b21c8b7fbe", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 38, "deletions": 158, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,185 +8,65 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Collection types.\n-//!\n-//! See [`std::collections`](../std/collections/index.html) for a detailed\n-//! discussion of collections in Rust.\n-\n #![crate_name = \"collections\"]\n #![crate_type = \"rlib\"]\n+#![allow(unused_attributes)]\n #![unstable(feature = \"collections\",\n-            reason = \"library is unlikely to be stabilized with the current \\\n-                      layout and name, use std::collections instead\",\n+            reason = \"this library is unlikely to be stabilized in its current \\\n+                      form or name\",\n             issue = \"27783\")]\n+#![rustc_deprecated(since = \"1.20.0\",\n+                    reason = \"collections moved to `alloc`\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n-\n-#![cfg_attr(test, allow(deprecated))] // rand\n+#![no_std]\n+#![needs_allocator]\n #![deny(warnings)]\n-#![deny(missing_debug_implementations)]\n \n #![feature(alloc)]\n-#![feature(allow_internal_unstable)]\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-#![cfg_attr(not(test), feature(char_escape_debug))]\n-#![cfg_attr(not(test), feature(core_float))]\n-#![feature(core_intrinsics)]\n-#![feature(dropck_eyepatch)]\n-#![feature(exact_size_is_empty)]\n-#![feature(fmt_internals)]\n-#![feature(fused)]\n-#![feature(generic_param_attrs)]\n-#![feature(heap_api)]\n-#![feature(i128_type)]\n-#![feature(inclusive_range)]\n-#![feature(lang_items)]\n-#![feature(manually_drop)]\n-#![feature(nonzero)]\n-#![feature(pattern)]\n-#![feature(placement_in)]\n-#![feature(placement_in_syntax)]\n-#![feature(placement_new_protocol)]\n-#![feature(shared)]\n-#![feature(slice_get_slice)]\n-#![feature(slice_patterns)]\n-#![cfg_attr(not(test), feature(slice_rotate))]\n-#![feature(slice_rsplit)]\n-#![cfg_attr(not(test), feature(sort_unstable))]\n-#![feature(specialization)]\n+#![feature(collections_range)]\n+#![feature(macro_reexport)]\n+#![feature(needs_allocator)]\n #![feature(staged_api)]\n-#![feature(str_internals)]\n-#![feature(str_box_extras)]\n-#![feature(str_mut_extras)]\n-#![feature(trusted_len)]\n-#![feature(unicode)]\n-#![feature(unique)]\n-#![cfg_attr(not(test), feature(str_checked_slicing))]\n-#![cfg_attr(test, feature(rand, test))]\n-#![feature(offset_to)]\n \n-#![no_std]\n+//! Collection types\n+//!\n+//! See [`std::collections`](../std/collections/index.html) for a detailed\n+//! discussion of collections in Rust.\n \n-extern crate std_unicode;\n+#[macro_reexport(vec, format)]\n extern crate alloc;\n \n-#[cfg(test)]\n-#[macro_use]\n-extern crate std;\n-#[cfg(test)]\n-extern crate test;\n+pub use alloc::Bound;\n+\n+pub use alloc::binary_heap;\n+pub use alloc::borrow;\n+pub use alloc::fmt;\n+pub use alloc::linked_list;\n+pub use alloc::range;\n+pub use alloc::slice;\n+pub use alloc::str;\n+pub use alloc::string;\n+pub use alloc::vec;\n+pub use alloc::vec_deque;\n+\n+pub use alloc::btree_map;\n+pub use alloc::btree_set;\n \n #[doc(no_inline)]\n-pub use binary_heap::BinaryHeap;\n+pub use alloc::binary_heap::BinaryHeap;\n #[doc(no_inline)]\n-pub use btree_map::BTreeMap;\n+pub use alloc::btree_map::BTreeMap;\n #[doc(no_inline)]\n-pub use btree_set::BTreeSet;\n+pub use alloc::btree_set::BTreeSet;\n #[doc(no_inline)]\n-pub use linked_list::LinkedList;\n+pub use alloc::linked_list::LinkedList;\n #[doc(no_inline)]\n-pub use vec_deque::VecDeque;\n+pub use alloc::vec_deque::VecDeque;\n #[doc(no_inline)]\n-pub use string::String;\n+pub use alloc::string::String;\n #[doc(no_inline)]\n-pub use vec::Vec;\n-\n-// Needed for the vec! macro\n-pub use alloc::boxed;\n-\n-#[macro_use]\n-mod macros;\n-\n-pub mod binary_heap;\n-mod btree;\n-pub mod borrow;\n-pub mod fmt;\n-pub mod linked_list;\n-pub mod range;\n-pub mod slice;\n-pub mod str;\n-pub mod string;\n-pub mod vec;\n-pub mod vec_deque;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod btree_map {\n-    //! A map based on a B-Tree.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use btree::map::*;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod btree_set {\n-    //! A set based on a B-Tree.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use btree::set::*;\n-}\n-\n-#[cfg(not(test))]\n-mod std {\n-    pub use core::ops;      // RangeFull\n-}\n-\n-/// An endpoint of a range of keys.\n-///\n-/// # Examples\n-///\n-/// `Bound`s are range endpoints:\n-///\n-/// ```\n-/// #![feature(collections_range)]\n-///\n-/// use std::collections::range::RangeArgument;\n-/// use std::collections::Bound::*;\n-///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n-/// ```\n-///\n-/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n-/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n-///\n-/// ```\n-/// use std::collections::BTreeMap;\n-/// use std::collections::Bound::{Excluded, Included, Unbounded};\n-///\n-/// let mut map = BTreeMap::new();\n-/// map.insert(3, \"a\");\n-/// map.insert(5, \"b\");\n-/// map.insert(8, \"c\");\n-///\n-/// for (key, value) in map.range((Excluded(3), Included(8))) {\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n-/// ```\n-///\n-/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n-#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n-pub enum Bound<T> {\n-    /// An inclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Included(T),\n-    /// An exclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Excluded(T),\n-    /// An infinite endpoint. Indicates that there is no bound in this direction.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Unbounded,\n-}\n-\n-/// An intermediate trait for specialization of `Extend`.\n-#[doc(hidden)]\n-trait SpecExtend<I: IntoIterator> {\n-    /// Extends `self` with the contents of the given iterator.\n-    fn spec_extend(&mut self, iter: I);\n-}\n+pub use alloc::vec::Vec;"}, {"sha": "396a917dfde261f87ba8823e17c533f2d0f8f660", "filename": "src/libcollections/macros.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,92 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Creates a `Vec` containing the arguments.\n-///\n-/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n-/// There are two forms of this macro:\n-///\n-/// - Create a `Vec` containing a given list of elements:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-///\n-/// - Create a `Vec` from a given element and size:\n-///\n-/// ```\n-/// let v = vec![1; 3];\n-/// assert_eq!(v, [1, 1, 1]);\n-/// ```\n-///\n-/// Note that unlike array expressions this syntax supports all elements\n-/// which implement `Clone` and the number of elements doesn't have to be\n-/// a constant.\n-///\n-/// This will use `clone()` to duplicate an expression, so one should be careful\n-/// using this with types having a nonstandard `Clone` implementation. For\n-/// example, `vec![Rc::new(1); 5]` will create a vector of five references\n-/// to the same boxed integer value, not five references pointing to independently\n-/// boxed integers.\n-#[cfg(not(test))]\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n-macro_rules! vec {\n-    ($elem:expr; $n:expr) => (\n-        $crate::vec::from_elem($elem, $n)\n-    );\n-    ($($x:expr),*) => (\n-        <[_]>::into_vec(box [$($x),*])\n-    );\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n-// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n-// required for this macro definition, is not available. Instead use the\n-// `slice::into_vec`  function which is only available with cfg(test)\n-// NB see the slice::hack module in slice.rs for more information\n-#[cfg(test)]\n-macro_rules! vec {\n-    ($elem:expr; $n:expr) => (\n-        $crate::vec::from_elem($elem, $n)\n-    );\n-    ($($x:expr),*) => (\n-        $crate::slice::into_vec(box [$($x),*])\n-    );\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See [`std::fmt`][fmt] for more information.\n-///\n-/// [fmt]: ../std/fmt/index.html\n-///\n-/// # Panics\n-///\n-/// `format!` panics if a formatting trait implementation returns an error.\n-/// This indicates an incorrect implementation\n-/// since `fmt::Write for String` never returns an error itself.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// format!(\"test\");\n-/// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10, y = 30);\n-/// ```\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n-}"}, {"sha": "eb32f4781948df7d2fa99c63cbde502ad75fff13", "filename": "src/libcollections/str.rs", "status": "removed", "additions": 0, "deletions": 1997, "changes": 1997, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d", "patch": "@@ -1,1997 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Unicode string slices.\n-//!\n-//! The `&str` type is one of the two main string types, the other being `String`.\n-//! Unlike its `String` counterpart, its contents are borrowed.\n-//!\n-//! # Basic Usage\n-//!\n-//! A basic string declaration of `&str` type:\n-//!\n-//! ```\n-//! let hello_world = \"Hello, World!\";\n-//! ```\n-//!\n-//! Here we have declared a string literal, also known as a string slice.\n-//! String literals have a static lifetime, which means the string `hello_world`\n-//! is guaranteed to be valid for the duration of the entire program.\n-//! We can explicitly specify `hello_world`'s lifetime as well:\n-//!\n-//! ```\n-//! let hello_world: &'static str = \"Hello, world!\";\n-//! ```\n-//!\n-//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-// Many of the usings in this module are only used in the test configuration.\n-// It's cleaner to just turn off the unused_imports warning than to fix them.\n-#![allow(unused_imports)]\n-\n-use core::fmt;\n-use core::str as core_str;\n-use core::str::pattern::Pattern;\n-use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n-use core::mem;\n-use core::iter::FusedIterator;\n-use std_unicode::str::{UnicodeStr, Utf16Encoder};\n-\n-use vec_deque::VecDeque;\n-use borrow::{Borrow, ToOwned};\n-use string::String;\n-use std_unicode;\n-use vec::Vec;\n-use slice::{SliceConcatExt, SliceIndex};\n-use boxed::Box;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{FromStr, Utf8Error};\n-#[allow(deprecated)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Lines, LinesAny};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Split, RSplit};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{SplitN, RSplitN};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{SplitTerminator, RSplitTerminator};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Matches, RMatches};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{MatchIndices, RMatchIndices};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n-#[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n-pub use alloc::str::from_boxed_utf8_unchecked;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use std_unicode::str::SplitWhitespace;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::pattern;\n-\n-\n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n-    type Output = String;\n-\n-    fn concat(&self) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.borrow().len()).sum();\n-        let mut result = String::with_capacity(len);\n-\n-        for s in self {\n-            result.push_str(s.borrow())\n-        }\n-\n-        result\n-    }\n-\n-    fn join(&self, sep: &str) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // concat is faster\n-        if sep.is_empty() {\n-            return self.concat();\n-        }\n-\n-        // this is wrong without the guarantee that `self` is non-empty\n-        // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1) +\n-                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n-        let mut result = String::with_capacity(len);\n-        let mut first = true;\n-\n-        for s in self {\n-            if first {\n-                first = false;\n-            } else {\n-                result.push_str(sep);\n-            }\n-            result.push_str(s.borrow());\n-        }\n-        result\n-    }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n-}\n-\n-/// An iterator of [`u16`] over the string encoded as UTF-16.\n-///\n-/// [`u16`]: ../../std/primitive.u16.html\n-///\n-/// This struct is created by the [`encode_utf16`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n-/// [`str`]: ../../std/primitive.str.html\n-#[derive(Clone)]\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-pub struct EncodeUtf16<'a> {\n-    encoder: Utf16Encoder<Chars<'a>>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a> fmt::Debug for EncodeUtf16<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"EncodeUtf16 { .. }\")\n-    }\n-}\n-\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-impl<'a> Iterator for EncodeUtf16<'a> {\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        self.encoder.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.encoder.size_hint()\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<'a> FusedIterator for EncodeUtf16<'a> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Borrow<str> for String {\n-    #[inline]\n-    fn borrow(&self) -> &str {\n-        &self[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ToOwned for str {\n-    type Owned = String;\n-    fn to_owned(&self) -> String {\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n-    }\n-\n-    fn clone_into(&self, target: &mut String) {\n-        let mut b = mem::replace(target, String::new()).into_bytes();\n-        self.as_bytes().clone_into(&mut b);\n-        *target = unsafe { String::from_utf8_unchecked(b) }\n-    }\n-}\n-\n-/// Methods for string slices.\n-#[lang = \"str\"]\n-#[cfg(not(test))]\n-impl str {\n-    /// Returns the length of `self`.\n-    ///\n-    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n-    /// it may not be what a human considers the length of the string.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let len = \"foo\".len();\n-    /// assert_eq!(3, len);\n-    ///\n-    /// let len = \"\u0192oo\".len(); // fancy f!\n-    /// assert_eq!(4, len);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        core_str::StrExt::len(self)\n-    }\n-\n-    /// Returns `true` if `self` has a length of zero bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"\";\n-    /// assert!(s.is_empty());\n-    ///\n-    /// let s = \"not empty\";\n-    /// assert!(!s.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self)\n-    }\n-\n-    /// Checks that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`) are\n-    /// considered to be\n-    /// boundaries.\n-    ///\n-    /// Returns `false` if `index` is greater than `self.len()`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n-    #[inline]\n-    pub fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(self, index)\n-    }\n-\n-    /// Converts a string slice to a byte slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bytes = \"bors\".as_bytes();\n-    /// assert_eq!(b\"bors\", bytes);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline(always)]\n-    pub fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self)\n-    }\n-\n-    /// Converts a mutable string slice to a mutable byte slice.\n-    #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n-    #[inline(always)]\n-    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        core_str::StrExt::as_bytes_mut(self)\n-    }\n-\n-    /// Converts a string slice to a raw pointer.\n-    ///\n-    /// As string slices are a slice of bytes, the raw pointer points to a\n-    /// [`u8`]. This pointer will be pointing to the first byte of the string\n-    /// slice.\n-    ///\n-    /// [`u8`]: primitive.u8.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Hello\";\n-    /// let ptr = s.as_ptr();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self)\n-    }\n-\n-    /// Returns a subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n-    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n-    /// assert!(v.get(1..).is_none());\n-    /// assert!(v.get(..8).is_none());\n-    /// assert!(v.get(..42).is_none());\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n-        core_str::StrExt::get(self, i)\n-    }\n-\n-    /// Returns a mutable subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n-    /// assert!(v.get_mut(1..).is_none());\n-    /// assert!(v.get_mut(..8).is_none());\n-    /// assert!(v.get_mut(..42).is_none());\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n-        core_str::StrExt::get_mut(self, i)\n-    }\n-\n-    /// Returns a unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        core_str::StrExt::get_unchecked(self, i)\n-    }\n-\n-    /// Returns a mutable, unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        core_str::StrExt::get_unchecked_mut(self, i)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`Index`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`Index`]: ops/trait.Index.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get a mutable string slice instead, see the\n-    /// [`slice_mut_unchecked`] method.\n-    ///\n-    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n-    /// }\n-    ///\n-    /// let s = \"Hello, world!\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(self, begin, end)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`IndexMut`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`IndexMut`]: ops/trait.IndexMut.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get an immutable string slice instead, see the\n-    /// [`slice_unchecked`] method.\n-    ///\n-    /// [`slice_unchecked`]: #method.slice_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n-    #[inline]\n-    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n-    }\n-\n-    /// Divide one string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get mutable string slices instead, see the [`split_at_mut`]\n-    /// method.\n-    ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Per Martin-L\u00f6f\";\n-    ///\n-    /// let (first, last) = s.split_at(3);\n-    ///\n-    /// assert_eq!(\"Per\", first);\n-    /// assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n-        core_str::StrExt::split_at(self, mid)\n-    }\n-\n-    /// Divide one mutable string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get immutable string slices instead, see the [`split_at`] method.\n-    ///\n-    /// [`split_at`]: #method.split_at\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n-    ///\n-    /// let (first, last) = s.split_at_mut(3);\n-    ///\n-    /// assert_eq!(\"Per\", first);\n-    /// assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n-        core_str::StrExt::split_at_mut(self, mid)\n-    }\n-\n-    /// Returns an iterator over the [`char`]s of a string slice.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns such an iterator.\n-    ///\n-    /// It's important to remember that [`char`] represents a Unicode Scalar\n-    /// Value, and may not match your idea of what a 'character' is. Iteration\n-    /// over grapheme clusters may be what you actually want.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.chars().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut chars = word.chars();\n-    ///\n-    /// assert_eq!(Some('g'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('d'), chars.next());\n-    /// assert_eq!(Some('b'), chars.next());\n-    /// assert_eq!(Some('y'), chars.next());\n-    /// assert_eq!(Some('e'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let y = \"y\u0306\";\n-    ///\n-    /// let mut chars = y.chars();\n-    ///\n-    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n-    /// assert_eq!(Some('\\u{0306}'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self)\n-    }\n-    /// Returns an iterator over the [`char`]s of a string slice, and their\n-    /// positions.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns an iterator of both\n-    /// these [`char`]s, as well as their byte positions.\n-    ///\n-    /// The iterator yields tuples. The position is first, the [`char`] is\n-    /// second.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.char_indices().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut char_indices = word.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'g')), char_indices.next());\n-    /// assert_eq!(Some((1, 'o')), char_indices.next());\n-    /// assert_eq!(Some((2, 'o')), char_indices.next());\n-    /// assert_eq!(Some((3, 'd')), char_indices.next());\n-    /// assert_eq!(Some((4, 'b')), char_indices.next());\n-    /// assert_eq!(Some((5, 'y')), char_indices.next());\n-    /// assert_eq!(Some((6, 'e')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let y = \"y\u0306\";\n-    ///\n-    /// let mut char_indices = y.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n-    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self)\n-    }\n-\n-    /// An iterator over the bytes of a string slice.\n-    ///\n-    /// As a string slice consists of a sequence of bytes, we can iterate\n-    /// through a string slice by byte. This method returns such an iterator.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut bytes = \"bors\".bytes();\n-    ///\n-    /// assert_eq!(Some(b'b'), bytes.next());\n-    /// assert_eq!(Some(b'o'), bytes.next());\n-    /// assert_eq!(Some(b'r'), bytes.next());\n-    /// assert_eq!(Some(b's'), bytes.next());\n-    ///\n-    /// assert_eq!(None, bytes.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self)\n-    }\n-\n-    /// Split a string slice by whitespace.\n-    ///\n-    /// The iterator returned will return string slices that are sub-slices of\n-    /// the original string slice, separated by any amount of whitespace.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut iter = \"A few words\".split_whitespace();\n-    ///\n-    /// assert_eq!(Some(\"A\"), iter.next());\n-    /// assert_eq!(Some(\"few\"), iter.next());\n-    /// assert_eq!(Some(\"words\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    ///\n-    /// All kinds of whitespace are considered:\n-    ///\n-    /// ```\n-    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n-    /// assert_eq!(Some(\"Mary\"), iter.next());\n-    /// assert_eq!(Some(\"had\"), iter.next());\n-    /// assert_eq!(Some(\"a\"), iter.next());\n-    /// assert_eq!(Some(\"little\"), iter.next());\n-    /// assert_eq!(Some(\"lamb\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-    #[inline]\n-    pub fn split_whitespace(&self) -> SplitWhitespace {\n-        UnicodeStr::split_whitespace(self)\n-    }\n-\n-    /// An iterator over the lines of a string, as string slices.\n-    ///\n-    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n-    /// a line feed (`\\r\\n`).\n-    ///\n-    /// The final line ending is optional.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    ///\n-    /// The final line ending isn't required:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self)\n-    }\n-\n-    /// An iterator over the lines of a string.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self)\n-    }\n-\n-    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-    pub fn encode_utf16(&self) -> EncodeUtf16 {\n-        EncodeUtf16 { encoder: Utf16Encoder::new(self[..].chars()) }\n-    }\n-\n-    /// Returns `true` if the given pattern matches a sub-slice of\n-    /// this string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.contains(\"nana\"));\n-    /// assert!(!bananas.contains(\"apples\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a prefix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.starts_with(\"bana\"));\n-    /// assert!(!bananas.starts_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::starts_with(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a suffix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.ends_with(\"anas\"));\n-    /// assert!(!bananas.ends_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::ends_with(self, pat)\n-    }\n-\n-    /// Returns the byte index of the first character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n-    /// ```\n-    ///\n-    /// More complex patterns with closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n-    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.find(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(self, pat)\n-    }\n-\n-    /// Returns the byte index of the last character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    /// ```\n-    ///\n-    /// More complex patterns with closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n-    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.rfind(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rfind(self, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit`] method can be used.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`rsplit`]: #method.rsplit\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    /// ```\n-    ///\n-    /// If a string contains multiple contiguous separators, you will end up\n-    /// with empty strings in the output:\n-    ///\n-    /// ```\n-    /// let x = \"||||a||b|c\".to_string();\n-    /// let d: Vec<_> = x.split('|').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators are separated by the empty string.\n-    ///\n-    /// ```\n-    /// let x = \"(///)\".to_string();\n-    /// let d: Vec<_> = x.split('/').collect();\n-    ///\n-    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n-    /// ```\n-    ///\n-    /// Separators at the start or end of a string are neighbored\n-    /// by empty strings.\n-    ///\n-    /// ```\n-    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n-    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n-    /// ```\n-    ///\n-    /// When the empty string is used as a separator, it separates\n-    /// every character in the string, along with the beginning\n-    /// and end of the string.\n-    ///\n-    /// ```\n-    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n-    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators can lead to possibly surprising behavior\n-    /// when whitespace is used as the separator. This code is correct:\n-    ///\n-    /// ```\n-    /// let x = \"    a  b c\".to_string();\n-    /// let d: Vec<_> = x.split(' ').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// It does _not_ give you:\n-    ///\n-    /// ```,ignore\n-    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Use [`split_whitespace`] for this behavior.\n-    ///\n-    /// [`split_whitespace`]: #method.split_whitespace\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        core_str::StrExt::split(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`split`] method can be used.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring\n-    /// is skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit_terminator`] method can be used.\n-    ///\n-    /// [`rsplit_terminator`]: #method.rsplit_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, [\"A\", \"B\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        core_str::StrExt::split_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a simple `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring is\n-    /// skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search, and it will be double ended if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// For iterating from the front, the [`split_terminator`] method can be\n-    /// used.\n-    ///\n-    /// [`split_terminator`]: #method.split_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n-    /// assert_eq!(v, [\"B\", \"A\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by a\n-    /// pattern, restricted to returning at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is\n-    /// not efficient to support.\n-    ///\n-    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n-    /// used.\n-    ///\n-    /// [`rsplitn`]: #method.rsplitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(self, n, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by a\n-    /// pattern, starting from the end of the string, restricted to returning\n-    /// at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is not\n-    /// efficient to support.\n-    ///\n-    /// For splitting from the front, the [`splitn`] method can be used.\n-    ///\n-    /// [`splitn`]: #method.splitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplitn(self, n, pat)\n-    }\n-\n-    /// An iterator over the matches of a pattern within the given string\n-    /// slice.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatches`] method can be used.\n-    ///\n-    /// [`rmatches`]: #method.rmatches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n-        core_str::StrExt::matches(self, pat)\n-    }\n-\n-    /// An iterator over the matches of a pattern within this string slice,\n-    /// yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`matches`] method can be used.\n-    ///\n-    /// [`matches`]: #method.matches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatches(self, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within this string\n-    /// slice as well as the index that the match starts at.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the first match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines\n-    /// if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatch_indices`] method can be used.\n-    ///\n-    /// [`rmatch_indices`]: #method.rmatch_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        core_str::StrExt::match_indices(self, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within `self`,\n-    /// yielded in reverse order along with the index of the match.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the last match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`match_indices`] method can be used.\n-    ///\n-    /// [`match_indices`]: #method.match_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatch_indices(self, pat)\n-    }\n-\n-    /// Returns a string slice with leading and trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\", s.trim());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim(&self) -> &str {\n-        UnicodeStr::trim(self)\n-    }\n-\n-    /// Returns a string slice with leading whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"  English\";\n-    /// assert!(Some('E') == s.trim_left().chars().next());\n-    ///\n-    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n-    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self)\n-    }\n-\n-    /// Returns a string slice with trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"English  \";\n-    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n-    ///\n-    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n-    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self)\n-    }\n-\n-    /// Returns a string slice with all prefixes and suffixes that match a\n-    /// pattern repeatedly removed.\n-    ///\n-    /// The pattern can be a [`char`] or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n-    {\n-        core_str::StrExt::trim_matches(self, pat)\n-    }\n-\n-    /// Returns a string slice with all prefixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        core_str::StrExt::trim_left_matches(self, pat)\n-    }\n-\n-    /// Returns a string slice with all suffixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::trim_right_matches(self, pat)\n-    }\n-\n-    /// Parses this string slice into another type.\n-    ///\n-    /// Because `parse` is so general, it can cause problems with type\n-    /// inference. As such, `parse` is one of the few times you'll see\n-    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n-    /// helps the inference algorithm understand specifically which type\n-    /// you're trying to parse into.\n-    ///\n-    /// `parse` can parse any type that implements the [`FromStr`] trait.\n-    ///\n-    /// [`FromStr`]: str/trait.FromStr.html\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will return [`Err`] if it's not possible to parse this string slice into\n-    /// the desired type.\n-    ///\n-    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n-    ///\n-    /// # Example\n-    ///\n-    /// Basic usage\n-    ///\n-    /// ```\n-    /// let four: u32 = \"4\".parse().unwrap();\n-    ///\n-    /// assert_eq!(4, four);\n-    /// ```\n-    ///\n-    /// Using the 'turbofish' instead of annotating `four`:\n-    ///\n-    /// ```\n-    /// let four = \"4\".parse::<u32>();\n-    ///\n-    /// assert_eq!(Ok(4), four);\n-    /// ```\n-    ///\n-    /// Failing to parse:\n-    ///\n-    /// ```\n-    /// let nope = \"j\".parse::<u32>();\n-    ///\n-    /// assert!(nope.is_err());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(self)\n-    }\n-\n-    /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n-    #[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n-    pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n-        self.into()\n-    }\n-\n-    /// Replaces all matches of a pattern with another string.\n-    ///\n-    /// `replace` creates a new [`String`], and copies the data from this string slice into it.\n-    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n-    /// replaces them with the replacement string slice.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    ///\n-    /// assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n-    /// ```\n-    ///\n-    /// When the pattern doesn't match:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n-        let mut result = String::new();\n-        let mut last_end = 0;\n-        for (start, part) in self.match_indices(from) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n-            result.push_str(to);\n-            last_end = start + part.len();\n-        }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n-        result\n-    }\n-\n-    /// Replaces first N matches of a pattern with another string.\n-    ///\n-    /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n-    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n-    /// replaces them with the replacement string slice at most `count` times.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"foo foo 123 foo\";\n-    /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n-    /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n-    /// assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n-    /// ```\n-    ///\n-    /// When the pattern doesn't match:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n-    /// ```\n-    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n-    pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n-        // Hope to reduce the times of re-allocation\n-        let mut result = String::with_capacity(32);\n-        let mut last_end = 0;\n-        for (start, part) in self.match_indices(pat).take(count) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n-            result.push_str(to);\n-            last_end = start + part.len();\n-        }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n-        result\n-    }\n-\n-    /// Returns the lowercase equivalent of this string slice, as a new [`String`].\n-    ///\n-    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n-    /// `Lowercase`.\n-    ///\n-    /// Since some characters can expand into multiple characters when changing\n-    /// the case, this function returns a [`String`] instead of modifying the\n-    /// parameter in-place.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"HELLO\";\n-    ///\n-    /// assert_eq!(\"hello\", s.to_lowercase());\n-    /// ```\n-    ///\n-    /// A tricky example, with sigma:\n-    ///\n-    /// ```\n-    /// let sigma = \"\u03a3\";\n-    ///\n-    /// assert_eq!(\"\u03c3\", sigma.to_lowercase());\n-    ///\n-    /// // but at the end of a word, it's \u03c2, not \u03c3:\n-    /// let odysseus = \"\u1f48\u0394\u03a5\u03a3\u03a3\u0395\u038e\u03a3\";\n-    ///\n-    /// assert_eq!(\"\u1f40\u03b4\u03c5\u03c3\u03c3\u03b5\u03cd\u03c2\", odysseus.to_lowercase());\n-    /// ```\n-    ///\n-    /// Languages without case are not changed:\n-    ///\n-    /// ```\n-    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n-    ///\n-    /// assert_eq!(new_year, new_year.to_lowercase());\n-    /// ```\n-    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n-    pub fn to_lowercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        for (i, c) in self[..].char_indices() {\n-            if c == '\u03a3' {\n-                // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n-                // This is the only conditional (contextual) but language-independent mapping\n-                // in `SpecialCasing.txt`,\n-                // so hard-code it rather than have a generic \"condition\" mechanism.\n-                // See https://github.com/rust-lang/rust/issues/26035\n-                map_uppercase_sigma(self, i, &mut s)\n-            } else {\n-                s.extend(c.to_lowercase());\n-            }\n-        }\n-        return s;\n-\n-        fn map_uppercase_sigma(from: &str, i: usize, to: &mut String) {\n-            // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n-            // for the definition of `Final_Sigma`.\n-            debug_assert!('\u03a3'.len_utf8() == 2);\n-            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n-                                !case_ignoreable_then_cased(from[i + 2..].chars());\n-            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n-        }\n-\n-        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n-            use std_unicode::derived_property::{Cased, Case_Ignorable};\n-            match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n-                Some(c) => Cased(c),\n-                None => false,\n-            }\n-        }\n-    }\n-\n-    /// Returns the uppercase equivalent of this string slice, as a new [`String`].\n-    ///\n-    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n-    /// `Uppercase`.\n-    ///\n-    /// Since some characters can expand into multiple characters when changing\n-    /// the case, this function returns a [`String`] instead of modifying the\n-    /// parameter in-place.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"hello\";\n-    ///\n-    /// assert_eq!(\"HELLO\", s.to_uppercase());\n-    /// ```\n-    ///\n-    /// Scripts without case are not changed:\n-    ///\n-    /// ```\n-    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n-    ///\n-    /// assert_eq!(new_year, new_year.to_uppercase());\n-    /// ```\n-    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n-    pub fn to_uppercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        s.extend(self.chars().flat_map(|c| c.to_uppercase()));\n-        return s;\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_debug`].\n-    ///\n-    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_debug(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_debug()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_default`].\n-    ///\n-    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_default(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_default()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_unicode`].\n-    ///\n-    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_unicode(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_unicode()).collect()\n-    }\n-\n-    /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    /// [`Box<str>`]: boxed/struct.Box.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let string = String::from(\"birthday gift\");\n-    /// let boxed_str = string.clone().into_boxed_str();\n-    ///\n-    /// assert_eq!(boxed_str.into_string(), string);\n-    /// ```\n-    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n-    pub fn into_string(self: Box<str>) -> String {\n-        unsafe {\n-            let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);\n-            String::from_utf8_unchecked(slice.into_vec())\n-        }\n-    }\n-\n-    /// Create a [`String`] by repeating a string `n` times.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n-    /// ```\n-    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n-    pub fn repeat(&self, n: usize) -> String {\n-        let mut s = String::with_capacity(self.len() * n);\n-        s.extend((0..n).map(|_| self));\n-        s\n-    }\n-}"}, {"sha": "61558034e63eb765912b6f75015a0017ed0bd549", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -31,7 +31,7 @@\n /// `Borrow` is very similar to, but different than, `AsRef`. See\n /// [the book][book] for more.\n ///\n-/// [book]: ../../book/borrow-and-asref.html\n+/// [book]: ../../book/first-edition/borrow-and-asref.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value."}, {"sha": "e75401f6ce031de718093fcb549c3019b31eba17", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -391,17 +391,17 @@ impl<T> Cell<T> {\n         }\n     }\n \n-    /// Replaces the contained value.\n+    /// Replaces the contained value, and returns it.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::cell::Cell;\n     ///\n-    /// let c = Cell::new(5);\n-    /// let old = c.replace(10);\n-    ///\n-    /// assert_eq!(5, old);\n+    /// let cell = Cell::new(5);\n+    /// assert_eq!(cell.get(), 5);\n+    /// assert_eq!(cell.replace(10), 5);\n+    /// assert_eq!(cell.get(), 10);\n     /// ```\n     #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n     pub fn replace(&self, val: T) -> T {"}, {"sha": "6f35d0417f18b1986f6db9042df62c09b625fa2b", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -443,6 +443,42 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n+\n+    /// Compares and returns the maximum of two values.\n+    ///\n+    /// Returns the second argument if the comparison determines them to be equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ord_max_min)]\n+    ///\n+    /// assert_eq!(2, 1.max(2));\n+    /// assert_eq!(2, 2.max(2));\n+    /// ```\n+    #[unstable(feature = \"ord_max_min\", issue = \"25663\")]\n+    fn max(self, other: Self) -> Self\n+    where Self: Sized {\n+        if other >= self { other } else { self }\n+    }\n+\n+    /// Compares and returns the minimum of two values.\n+    ///\n+    /// Returns the first argument if the comparison determines them to be equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ord_max_min)]\n+    ///\n+    /// assert_eq!(1, 1.min(2));\n+    /// assert_eq!(2, 2.min(2));\n+    /// ```\n+    #[unstable(feature = \"ord_max_min\", issue = \"25663\")]\n+    fn min(self, other: Self) -> Self\n+    where Self: Sized {\n+        if self <= other { self } else { other }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -678,6 +714,8 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n ///\n+/// Internally uses an alias to `Ord::min`.\n+///\n /// # Examples\n ///\n /// ```\n@@ -689,13 +727,15 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n-    if v1 <= v2 { v1 } else { v2 }\n+    v1.min(v2)\n }\n \n /// Compares and returns the maximum of two values.\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n ///\n+/// Internally uses an alias to `Ord::max`.\n+///\n /// # Examples\n ///\n /// ```\n@@ -707,7 +747,7 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n-    if v2 >= v1 { v2 } else { v1 }\n+    v1.max(v2)\n }\n \n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types"}, {"sha": "6f3c3863fae1d66a3bee7deb453e87427d4aa1e8", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -71,7 +71,7 @@ use str::FromStr;\n ///\n /// See [the book][book] for a more detailed comparison.\n ///\n-/// [book]: ../../book/borrow-and-asref.html\n+/// [book]: ../../book/first-edition/borrow-and-asref.html\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///\n /// **Note: this trait must not fail**. If the conversion can fail, use a\n@@ -305,7 +305,7 @@ pub trait Into<T>: Sized {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Into<U>`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n-/// [book]: ../../book/error-handling.html\n+/// [book]: ../../book/first-edition/error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {\n     /// Performs the conversion."}, {"sha": "3b304f4c479a02258b019a1fd513e741eb5cd19a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -99,7 +99,7 @@ use mem;\n #[allow(deprecated)]\n pub use self::sip::SipHasher;\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[allow(deprecated)]\n pub use self::sip::{SipHasher13, SipHasher24};\n "}, {"sha": "8188c15a2829cdf2dc798fa6338f487a6937db12", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1229,6 +1229,23 @@ extern \"rust-intrinsic\" {\n     /// ```\n     pub fn ctlz<T>(x: T) -> T;\n \n+    /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n+    /// given an `x` with value `0`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(core_intrinsics)]\n+    ///\n+    /// use std::intrinsics::ctlz_nonzero;\n+    ///\n+    /// let x = 0b0001_1100_u8;\n+    /// let num_leading = unsafe { ctlz_nonzero(x) };\n+    /// assert_eq!(num_leading, 3);\n+    /// ```\n+    #[cfg(not(stage0))]\n+    pub fn ctlz_nonzero<T>(x: T) -> T;\n+\n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n     ///\n     /// # Examples\n@@ -1256,6 +1273,23 @@ extern \"rust-intrinsic\" {\n     /// ```\n     pub fn cttz<T>(x: T) -> T;\n \n+    /// Like `cttz`, but extra-unsafe as it returns `undef` when\n+    /// given an `x` with value `0`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(core_intrinsics)]\n+    ///\n+    /// use std::intrinsics::cttz_nonzero;\n+    ///\n+    /// let x = 0b0011_1000_u8;\n+    /// let num_trailing = unsafe { cttz_nonzero(x) };\n+    /// assert_eq!(num_trailing, 3);\n+    /// ```\n+    #[cfg(not(stage0))]\n+    pub fn cttz_nonzero<T>(x: T) -> T;\n+\n     /// Reverses the bytes in an integer type `T`.\n     pub fn bswap<T>(x: T) -> T;\n "}, {"sha": "30d09e5453b370f7f5325fbff1b9538d8597d98d", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -262,7 +262,7 @@ pub trait Iterator {\n     /// Creates an iterator starting at the same point, but stepping by\n     /// the given amount at each iteration.\n     ///\n-    /// Note that it will always return the first element of the range,\n+    /// Note that it will always return the first element of the iterator,\n     /// regardless of the step given.\n     ///\n     /// # Panics"}, {"sha": "679cf3a9b23eea9eb38fd05aab601072e687fa3f", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -798,6 +798,23 @@ impl<I, T, E> Iterator for ResultShunt<I, E>\n impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     where T: Sum<U>,\n {\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n+    /// the sum of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This sums up every integer in a vector, rejecting the sum if a negative\n+    /// element is encountered:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2];\n+    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n+    ///     if x < 0 { Err(\"Negative element found\") }\n+    ///     else { Ok(x) }\n+    /// ).sum();\n+    /// assert_eq!(res, Ok(3));\n+    /// ```\n     fn sum<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n@@ -809,6 +826,9 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n     where T: Product<U>,\n {\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n+    /// the product of all elements is returned.\n     fn product<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n@@ -819,7 +839,7 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n /// An iterator that always continues to yield `None` when exhausted.\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed\n-/// to return [`None`] again. This trait is should be implemented by all iterators\n+/// to return [`None`] again. This trait should be implemented by all iterators\n /// that behave this way because it allows for some significant optimizations.\n ///\n /// Note: In general, you should not use `FusedIterator` in generic bounds if"}, {"sha": "dfe95d3a4d6b59c56e53e6eed243bf5a6eb1654d", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -54,7 +54,7 @@ macro_rules! panic {\n ///\n /// [`panic!`]: macro.panic.html\n /// [`debug_assert!`]: macro.debug_assert.html\n-/// [testing]: ../book/testing.html\n+/// [testing]: ../book/first-edition/testing.html\n ///\n /// # Examples\n ///\n@@ -554,7 +554,8 @@ macro_rules! unreachable {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! unimplemented {\n-    () => (panic!(\"not yet implemented\"))\n+    () => (panic!(\"not yet implemented\"));\n+    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n }\n \n /// Built-in macros to the compiler itself."}, {"sha": "3bed425943f78af8aa9fa21b31e344bf7c891793", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -85,7 +85,7 @@ impl<T: ?Sized> !Send for *mut T { }\n ///                         // be made into an object\n /// ```\n ///\n-/// [trait object]: ../../book/trait-objects.html\n+/// [trait object]: ../../book/first-edition/trait-objects.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n@@ -493,7 +493,7 @@ macro_rules! impls{\n /// types. We track the Rust type using a phantom type parameter on\n /// the struct `ExternalResource` which wraps a handle.\n ///\n-/// [FFI]: ../../book/ffi.html\n+/// [FFI]: ../../book/first-edition/ffi.html\n ///\n /// ```\n /// # #![allow(dead_code)]"}, {"sha": "3924034fea22d92e2212c9b23832f528b35ae384", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -109,7 +109,7 @@ pub use intrinsics::transmute;\n /// [`Clone`][clone]. You need the value's destructor to run only once,\n /// because a double `free` is undefined behavior.\n ///\n-/// An example is the definition of [`mem::swap`][swap] in this module:\n+/// An example is a possible implementation of [`mem::swap`][swap]:\n ///\n /// ```\n /// use std::mem;\n@@ -499,18 +499,59 @@ pub unsafe fn uninitialized<T>() -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n-        // Give ourselves some scratch space to work with\n-        let mut t: T = uninitialized();\n-\n-        // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping(&*x, &mut t, 1);\n-        ptr::copy_nonoverlapping(&*y, x, 1);\n-        ptr::copy_nonoverlapping(&t, y, 1);\n-\n-        // y and t now point to the same thing, but we need to completely\n-        // forget `t` because we do not want to run the destructor for `T`\n-        // on its value, which is still owned somewhere outside this function.\n-        forget(t);\n+        // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n+        // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n+        // Haswell E processors. LLVM is more able to optimize if we give a struct a\n+        // #[repr(simd)], even if we don't actually use this struct directly.\n+        //\n+        // FIXME repr(simd) broken on emscripten\n+        #[cfg_attr(not(target_os = \"emscripten\"), repr(simd))]\n+        struct Block(u64, u64, u64, u64);\n+        struct UnalignedBlock(u64, u64, u64, u64);\n+\n+        let block_size = size_of::<Block>();\n+\n+        // Get raw pointers to the bytes of x & y for easier manipulation\n+        let x = x as *mut T as *mut u8;\n+        let y = y as *mut T as *mut u8;\n+\n+        // Loop through x & y, copying them `Block` at a time\n+        // The optimizer should unroll the loop fully for most types\n+        // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n+        let len = size_of::<T>();\n+        let mut i = 0;\n+        while i + block_size <= len {\n+            // Create some uninitialized memory as scratch space\n+            // Declaring `t` here avoids aligning the stack when this loop is unused\n+            let mut t: Block = uninitialized();\n+            let t = &mut t as *mut _ as *mut u8;\n+            let x = x.offset(i as isize);\n+            let y = y.offset(i as isize);\n+\n+            // Swap a block of bytes of x & y, using t as a temporary buffer\n+            // This should be optimized into efficient SIMD operations where available\n+            ptr::copy_nonoverlapping(x, t, block_size);\n+            ptr::copy_nonoverlapping(y, x, block_size);\n+            ptr::copy_nonoverlapping(t, y, block_size);\n+            i += block_size;\n+        }\n+\n+\n+        if i < len {\n+            // Swap any remaining bytes, using aligned types to copy\n+            // where appropriate (this information is lost by conversion\n+            // to *mut u8, so restore it manually here)\n+            let mut t: UnalignedBlock = uninitialized();\n+            let rem = len - i;\n+\n+            let t = &mut t as *mut _ as *mut u8;\n+            let x = x.offset(i as isize);\n+            let y = y.offset(i as isize);\n+\n+            ptr::copy_nonoverlapping(x, t, rem);\n+            ptr::copy_nonoverlapping(y, x, rem);\n+            ptr::copy_nonoverlapping(t, y, rem);\n+        }\n     }\n }\n "}, {"sha": "cb28035682d650607409d522448243413a03630b", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -242,4 +242,32 @@ impl Float for f32 {\n         let value: f32 = consts::PI;\n         self * (value / 180.0f32)\n     }\n+\n+    /// Returns the maximum of the two numbers.\n+    #[inline]\n+    fn max(self, other: f32) -> f32 {\n+        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || self.is_nan() { other } else { self }) * 1.0\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    #[inline]\n+    fn min(self, other: f32) -> f32 {\n+        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || other.is_nan() { self } else { other }) * 1.0\n+    }\n }"}, {"sha": "ac6b1e67cd2785b17154e76062210bb6f6f76f8c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -242,4 +242,32 @@ impl Float for f64 {\n         let value: f64 = consts::PI;\n         self * (value / 180.0)\n     }\n+\n+    /// Returns the maximum of the two numbers.\n+    #[inline]\n+    fn max(self, other: f64) -> f64 {\n+        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || self.is_nan() { other } else { self }) * 1.0\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    #[inline]\n+    fn min(self, other: f64) -> f64 {\n+        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self < other || other.is_nan() { self } else { other }) * 1.0\n+    }\n }"}, {"sha": "cbd59ed3713776f84b6cf42129c11c8742dc2ab9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -15,7 +15,6 @@\n use convert::TryFrom;\n use fmt;\n use intrinsics;\n-use mem::size_of;\n use str::FromStr;\n \n /// Provides intentionally-wrapped arithmetic on `T`.\n@@ -1263,6 +1262,7 @@ macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr,\n      $ctpop:path,\n      $ctlz:path,\n+     $ctlz_nonzero:path,\n      $cttz:path,\n      $bswap:path,\n      $add_with_overflow:path,\n@@ -2176,8 +2176,33 @@ macro_rules! uint_impl {\n             (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n         }\n \n+        // Returns one less than next power of two.\n+        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n+        //\n+        // 8u8.one_less_than_next_power_of_two() == 7\n+        // 6u8.one_less_than_next_power_of_two() == 7\n+        //\n+        // This method cannot overflow, as in the `next_power_of_two`\n+        // overflow cases it instead ends up returning the maximum value\n+        // of the type, and can return 0 for 0.\n+        #[inline]\n+        fn one_less_than_next_power_of_two(self) -> Self {\n+            if self <= 1 { return 0; }\n+\n+            // Because `p > 0`, it cannot consist entirely of leading zeros.\n+            // That means the shift is always in-bounds, and some processors\n+            // (such as intel pre-haswell) have more efficient ctlz\n+            // intrinsics when the argument is non-zero.\n+            let p = self - 1;\n+            let z = unsafe { $ctlz_nonzero(p) };\n+            <$SelfT>::max_value() >> z\n+        }\n+\n         /// Returns the smallest power of two greater than or equal to `self`.\n-        /// Unspecified behavior on overflow.\n+        ///\n+        /// When return value overflows (i.e. `self > (1 << (N-1))` for type\n+        /// `uN`), it panics in debug mode and return value is wrapped to 0 in\n+        /// release mode (the only situation in which method can return 0).\n         ///\n         /// # Examples\n         ///\n@@ -2190,9 +2215,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn next_power_of_two(self) -> Self {\n-            let bits = size_of::<Self>() * 8;\n-            let one: Self = 1;\n-            one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n+            self.one_less_than_next_power_of_two() + 1\n         }\n \n         /// Returns the smallest power of two greater than or equal to `n`. If\n@@ -2210,21 +2233,22 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn checked_next_power_of_two(self) -> Option<Self> {\n-            let npot = self.next_power_of_two();\n-            if npot >= self {\n-                Some(npot)\n-            } else {\n-                None\n-            }\n+            self.one_less_than_next_power_of_two().checked_add(1)\n         }\n     }\n }\n \n+#[cfg(stage0)]\n+unsafe fn ctlz_nonzero<T>(x: T) -> T { intrinsics::ctlz(x) }\n+#[cfg(not(stage0))]\n+unsafe fn ctlz_nonzero<T>(x: T) -> T { intrinsics::ctlz_nonzero(x) }\n+\n #[lang = \"u8\"]\n impl u8 {\n     uint_impl! { u8, u8, 8,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2237,6 +2261,7 @@ impl u16 {\n     uint_impl! { u16, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2249,6 +2274,7 @@ impl u32 {\n     uint_impl! { u32, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2261,6 +2287,7 @@ impl u64 {\n     uint_impl! { u64, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2273,6 +2300,7 @@ impl u128 {\n     uint_impl! { u128, u128, 128,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2286,6 +2314,7 @@ impl usize {\n     uint_impl! { usize, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2298,6 +2327,7 @@ impl usize {\n     uint_impl! { usize, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2311,6 +2341,7 @@ impl usize {\n     uint_impl! { usize, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n+        ctlz_nonzero,\n         intrinsics::cttz,\n         intrinsics::bswap,\n         intrinsics::add_with_overflow,\n@@ -2428,6 +2459,13 @@ pub trait Float: Sized {\n     /// Convert degrees to radians.\n     #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_radians(self) -> Self;\n+\n+    /// Returns the maximum of the two numbers.\n+    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n+    fn max(self, other: Self) -> Self;\n+    /// Returns the minimum of the two numbers.\n+    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n+    fn min(self, other: Self) -> Self;\n }\n \n macro_rules! from_str_radix_int_impl {"}, {"sha": "a1de8fe76e2580cb79d2fcf1b166ee8aff237935", "filename": "src/libcore/ops.rs", "status": "removed", "additions": 0, "deletions": 3021, "changes": 3021, "blob_url": "https://github.com/rust-lang/rust/blob/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=1ec1b1f1eb1bd0ea1f9396ade1015d00f9149a1d"}, {"sha": "c6fb75f6acefc8bce4a6b2eb815e18ff92f8708a", "filename": "src/libcore/ops/arith.rs", "status": "added", "additions": 873, "deletions": 0, "changes": 873, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,873 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The addition operator `+`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `Add` trait, and\n+/// then demonstrates adding two `Point`s.\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl Add for Point {\n+///     type Output = Point;\n+///\n+///     fn add(self, other: Point) -> Point {\n+///         Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///                Point { x: 3, y: 3 });\n+/// }\n+/// ```\n+///\n+/// Here is an example of the same `Point` struct implementing the `Add` trait\n+/// using generics.\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// #[derive(Debug)]\n+/// struct Point<T> {\n+///     x: T,\n+///     y: T,\n+/// }\n+///\n+/// // Notice that the implementation uses the `Output` associated type\n+/// impl<T: Add<Output=T>> Add for Point<T> {\n+///     type Output = Point<T>;\n+///\n+///     fn add(self, other: Point<T>) -> Point<T> {\n+///         Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl<T: PartialEq> PartialEq for Point<T> {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///                Point { x: 3, y: 3 });\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime + Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n+#[lang = \"add\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\n+pub trait Add<RHS=Self> {\n+    /// The resulting type after applying the `+` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `+` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! add_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Add for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn add(self, other: $t) -> $t { self + other }\n+        }\n+\n+        forward_ref_binop! { impl Add, add for $t, $t }\n+    )*)\n+}\n+\n+add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The subtraction operator `-`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `Sub` trait, and\n+/// then demonstrates subtracting two `Point`s.\n+///\n+/// ```\n+/// use std::ops::Sub;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl Sub for Point {\n+///     type Output = Point;\n+///\n+///     fn sub(self, other: Point) -> Point {\n+///         Point {\n+///             x: self.x - other.x,\n+///             y: self.y - other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n+///                Point { x: 1, y: 0 });\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime - Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n+#[lang = \"sub\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\n+pub trait Sub<RHS=Self> {\n+    /// The resulting type after applying the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! sub_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Sub for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn sub(self, other: $t) -> $t { self - other }\n+        }\n+\n+        forward_ref_binop! { impl Sub, sub for $t, $t }\n+    )*)\n+}\n+\n+sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The multiplication operator `*`.\n+///\n+/// # Examples\n+///\n+/// Implementing a `Mul`tipliable rational number struct:\n+///\n+/// ```\n+/// use std::ops::Mul;\n+///\n+/// // The uniqueness of rational numbers in lowest terms is a consequence of\n+/// // the fundamental theorem of arithmetic.\n+/// #[derive(Eq)]\n+/// #[derive(PartialEq, Debug)]\n+/// struct Rational {\n+///     nominator: usize,\n+///     denominator: usize,\n+/// }\n+///\n+/// impl Rational {\n+///     fn new(nominator: usize, denominator: usize) -> Self {\n+///         if denominator == 0 {\n+///             panic!(\"Zero is an invalid denominator!\");\n+///         }\n+///\n+///         // Reduce to lowest terms by dividing by the greatest common\n+///         // divisor.\n+///         let gcd = gcd(nominator, denominator);\n+///         Rational {\n+///             nominator: nominator / gcd,\n+///             denominator: denominator / gcd,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl Mul for Rational {\n+///     // The multiplication of rational numbers is a closed operation.\n+///     type Output = Self;\n+///\n+///     fn mul(self, rhs: Self) -> Self {\n+///         let nominator = self.nominator * rhs.nominator;\n+///         let denominator = self.denominator * rhs.denominator;\n+///         Rational::new(nominator, denominator)\n+///     }\n+/// }\n+///\n+/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n+/// // divisor.\n+/// fn gcd(x: usize, y: usize) -> usize {\n+///     let mut x = x;\n+///     let mut y = y;\n+///     while y != 0 {\n+///         let t = y;\n+///         y = x % y;\n+///         x = t;\n+///     }\n+///     x\n+/// }\n+///\n+/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+/// assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n+///            Rational::new(1, 2));\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n+/// implementation which enables multiplication of vectors by scalars, as is\n+/// done in linear algebra.\n+///\n+/// ```\n+/// use std::ops::Mul;\n+///\n+/// struct Scalar {value: usize};\n+///\n+/// #[derive(Debug)]\n+/// struct Vector {value: Vec<usize>};\n+///\n+/// impl Mul<Vector> for Scalar {\n+///     type Output = Vector;\n+///\n+///     fn mul(self, rhs: Vector) -> Vector {\n+///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n+///     }\n+/// }\n+///\n+/// impl PartialEq<Vector> for Vector {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.value == other.value\n+///     }\n+/// }\n+///\n+/// let scalar = Scalar{value: 3};\n+/// let vector = Vector{value: vec![2, 4, 6]};\n+/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n+/// ```\n+#[lang = \"mul\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\n+pub trait Mul<RHS=Self> {\n+    /// The resulting type after applying the `*` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `*` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn mul(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! mul_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Mul for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn mul(self, other: $t) -> $t { self * other }\n+        }\n+\n+        forward_ref_binop! { impl Mul, mul for $t, $t }\n+    )*)\n+}\n+\n+mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The division operator `/`.\n+///\n+/// # Examples\n+///\n+/// Implementing a `Div`idable rational number struct:\n+///\n+/// ```\n+/// use std::ops::Div;\n+///\n+/// // The uniqueness of rational numbers in lowest terms is a consequence of\n+/// // the fundamental theorem of arithmetic.\n+/// #[derive(Eq)]\n+/// #[derive(PartialEq, Debug)]\n+/// struct Rational {\n+///     nominator: usize,\n+///     denominator: usize,\n+/// }\n+///\n+/// impl Rational {\n+///     fn new(nominator: usize, denominator: usize) -> Self {\n+///         if denominator == 0 {\n+///             panic!(\"Zero is an invalid denominator!\");\n+///         }\n+///\n+///         // Reduce to lowest terms by dividing by the greatest common\n+///         // divisor.\n+///         let gcd = gcd(nominator, denominator);\n+///         Rational {\n+///             nominator: nominator / gcd,\n+///             denominator: denominator / gcd,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl Div for Rational {\n+///     // The division of rational numbers is a closed operation.\n+///     type Output = Self;\n+///\n+///     fn div(self, rhs: Self) -> Self {\n+///         if rhs.nominator == 0 {\n+///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n+///         }\n+///\n+///         let nominator = self.nominator * rhs.denominator;\n+///         let denominator = self.denominator * rhs.nominator;\n+///         Rational::new(nominator, denominator)\n+///     }\n+/// }\n+///\n+/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n+/// // divisor.\n+/// fn gcd(x: usize, y: usize) -> usize {\n+///     let mut x = x;\n+///     let mut y = y;\n+///     while y != 0 {\n+///         let t = y;\n+///         y = x % y;\n+///         x = t;\n+///     }\n+///     x\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n+///                Rational::new(2, 3));\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n+/// implementation which enables division of vectors by scalars, as is done in\n+/// linear algebra.\n+///\n+/// ```\n+/// use std::ops::Div;\n+///\n+/// struct Scalar {value: f32};\n+///\n+/// #[derive(Debug)]\n+/// struct Vector {value: Vec<f32>};\n+///\n+/// impl Div<Scalar> for Vector {\n+///     type Output = Vector;\n+///\n+///     fn div(self, rhs: Scalar) -> Vector {\n+///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n+///     }\n+/// }\n+///\n+/// impl PartialEq<Vector> for Vector {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.value == other.value\n+///     }\n+/// }\n+///\n+/// let scalar = Scalar{value: 2f32};\n+/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n+/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n+/// ```\n+#[lang = \"div\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\n+pub trait Div<RHS=Self> {\n+    /// The resulting type after applying the `/` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `/` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn div(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! div_impl_integer {\n+    ($($t:ty)*) => ($(\n+        /// This operation rounds towards zero, truncating any\n+        /// fractional part of the exact result.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Div for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n+    )*)\n+}\n+\n+div_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! div_impl_float {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Div for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n+    )*)\n+}\n+\n+div_impl_float! { f32 f64 }\n+\n+/// The remainder operator `%`.\n+///\n+/// # Examples\n+///\n+/// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n+/// implemented, one can use the `%` operator to find out what the remaining\n+/// elements of the slice would be after splitting it into equal slices of a\n+/// given length.\n+///\n+/// ```\n+/// use std::ops::Rem;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SplitSlice<'a, T: 'a> {\n+///     slice: &'a [T],\n+/// }\n+///\n+/// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n+///     type Output = SplitSlice<'a, T>;\n+///\n+///     fn rem(self, modulus: usize) -> Self {\n+///         let len = self.slice.len();\n+///         let rem = len % modulus;\n+///         let start = len - rem;\n+///         SplitSlice {slice: &self.slice[start..]}\n+///     }\n+/// }\n+///\n+/// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n+/// // the remainder would be &[6, 7]\n+/// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n+///            SplitSlice { slice: &[6, 7] });\n+/// ```\n+#[lang = \"rem\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\n+pub trait Rem<RHS=Self> {\n+    /// The resulting type after applying the `%` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output = Self;\n+\n+    /// The method for the `%` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn rem(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! rem_impl_integer {\n+    ($($t:ty)*) => ($(\n+        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// result has the same sign as the left operand.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Rem for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    )*)\n+}\n+\n+rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+\n+macro_rules! rem_impl_float {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Rem for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    )*)\n+}\n+\n+rem_impl_float! { f32 f64 }\n+\n+/// The unary negation operator `-`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Neg` for `Sign`, which allows the use of `-` to\n+/// negate its value.\n+///\n+/// ```\n+/// use std::ops::Neg;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Sign {\n+///     Negative,\n+///     Zero,\n+///     Positive,\n+/// }\n+///\n+/// impl Neg for Sign {\n+///     type Output = Sign;\n+///\n+///     fn neg(self) -> Sign {\n+///         match self {\n+///             Sign::Negative => Sign::Positive,\n+///             Sign::Zero => Sign::Zero,\n+///             Sign::Positive => Sign::Negative,\n+///         }\n+///     }\n+/// }\n+///\n+/// // a negative positive is a negative\n+/// assert_eq!(-Sign::Positive, Sign::Negative);\n+/// // a double negative is a positive\n+/// assert_eq!(-Sign::Negative, Sign::Positive);\n+/// // zero is its own negation\n+/// assert_eq!(-Sign::Zero, Sign::Zero);\n+/// ```\n+#[lang = \"neg\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Neg {\n+    /// The resulting type after applying the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the unary `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn neg(self) -> Self::Output;\n+}\n+\n+\n+\n+macro_rules! neg_impl_core {\n+    ($id:ident => $body:expr, $($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Neg for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn neg(self) -> $t { let $id = self; $body }\n+        }\n+\n+        forward_ref_unop! { impl Neg, neg for $t }\n+    )*)\n+}\n+\n+macro_rules! neg_impl_numeric {\n+    ($($t:ty)*) => { neg_impl_core!{ x => -x, $($t)*} }\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! neg_impl_unsigned {\n+    ($($t:ty)*) => {\n+        neg_impl_core!{ x => {\n+            !x.wrapping_add(1)\n+        }, $($t)*} }\n+}\n+\n+// neg_impl_unsigned! { usize u8 u16 u32 u64 }\n+neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The addition assignment operator `+=`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `AddAssign`\n+/// trait, and then demonstrates add-assigning to a mutable `Point`.\n+///\n+/// ```\n+/// use std::ops::AddAssign;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl AddAssign for Point {\n+///     fn add_assign(&mut self, other: Point) {\n+///         *self = Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         };\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// let mut point = Point { x: 1, y: 0 };\n+/// point += Point { x: 2, y: 3 };\n+/// assert_eq!(point, Point { x: 3, y: 3 });\n+/// ```\n+#[lang = \"add_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\n+pub trait AddAssign<Rhs=Self> {\n+    /// The method for the `+=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn add_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! add_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl AddAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn add_assign(&mut self, other: $t) { *self += other }\n+        }\n+    )+)\n+}\n+\n+add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The subtraction assignment operator `-=`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `SubAssign`\n+/// trait, and then demonstrates sub-assigning to a mutable `Point`.\n+///\n+/// ```\n+/// use std::ops::SubAssign;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl SubAssign for Point {\n+///     fn sub_assign(&mut self, other: Point) {\n+///         *self = Point {\n+///             x: self.x - other.x,\n+///             y: self.y - other.y,\n+///         };\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// let mut point = Point { x: 3, y: 3 };\n+/// point -= Point { x: 2, y: 3 };\n+/// assert_eq!(point, Point {x: 1, y: 0});\n+/// ```\n+#[lang = \"sub_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\n+pub trait SubAssign<Rhs=Self> {\n+    /// The method for the `-=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn sub_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! sub_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl SubAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn sub_assign(&mut self, other: $t) { *self -= other }\n+        }\n+    )+)\n+}\n+\n+sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The multiplication assignment operator `*=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n+/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n+///\n+/// ```\n+/// use std::ops::MulAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl MulAssign for Foo {\n+///     fn mul_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Multiplying!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo *= Foo;\n+/// }\n+/// ```\n+#[lang = \"mul_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\n+pub trait MulAssign<Rhs=Self> {\n+    /// The method for the `*=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn mul_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! mul_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl MulAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn mul_assign(&mut self, other: $t) { *self *= other }\n+        }\n+    )+)\n+}\n+\n+mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The division assignment operator `/=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n+/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n+///\n+/// ```\n+/// use std::ops::DivAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl DivAssign for Foo {\n+///     fn div_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Dividing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo /= Foo;\n+/// }\n+/// ```\n+#[lang = \"div_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\n+pub trait DivAssign<Rhs=Self> {\n+    /// The method for the `/=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn div_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! div_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl DivAssign for $t {\n+            #[inline]\n+            fn div_assign(&mut self, other: $t) { *self /= other }\n+        }\n+    )+)\n+}\n+\n+div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The remainder assignment operator `%=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n+/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n+///\n+/// ```\n+/// use std::ops::RemAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl RemAssign for Foo {\n+///     fn rem_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Remainder-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo %= Foo;\n+/// }\n+/// ```\n+#[lang = \"rem_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\n+pub trait RemAssign<Rhs=Self> {\n+    /// The method for the `%=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn rem_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! rem_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl RemAssign for $t {\n+            #[inline]\n+            fn rem_assign(&mut self, other: $t) { *self %= other }\n+        }\n+    )+)\n+}\n+\n+rem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }"}, {"sha": "8743be3557cc4e31f793f4a6d570785de637761a", "filename": "src/libcore/ops/bit.rs", "status": "added", "additions": 839, "deletions": 0, "changes": 839, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,839 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The unary logical negation operator `!`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Not` for `Answer`, which enables the use of `!` to\n+/// invert its value.\n+///\n+/// ```\n+/// use std::ops::Not;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Answer {\n+///     Yes,\n+///     No,\n+/// }\n+///\n+/// impl Not for Answer {\n+///     type Output = Answer;\n+///\n+///     fn not(self) -> Answer {\n+///         match self {\n+///             Answer::Yes => Answer::No,\n+///             Answer::No => Answer::Yes\n+///         }\n+///     }\n+/// }\n+///\n+/// assert_eq!(!Answer::Yes, Answer::No);\n+/// assert_eq!(!Answer::No, Answer::Yes);\n+/// ```\n+#[lang = \"not\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Not {\n+    /// The resulting type after applying the `!` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the unary `!` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn not(self) -> Self::Output;\n+}\n+\n+macro_rules! not_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Not for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn not(self) -> $t { !self }\n+        }\n+\n+        forward_ref_unop! { impl Not, not for $t }\n+    )*)\n+}\n+\n+not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise AND operator `&`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitAnd;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitAnd for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a & b`\n+///     fn bitand(self, rhs: Self) -> Self {\n+///         Scalar(self.0 & rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitAnd;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitAnd for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitand(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, false, false, false]);\n+///     assert_eq!(bv1 & bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitand\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} & {RHS}`\"]\n+pub trait BitAnd<RHS=Self> {\n+    /// The resulting type after applying the `&` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `&` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitand(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitand_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitAnd for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitand(self, rhs: $t) -> $t { self & rhs }\n+        }\n+\n+        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n+    )*)\n+}\n+\n+bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise OR operator `|`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `|` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitOr;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitOr for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a | b`\n+///     fn bitor(self, rhs: Self) -> Self {\n+///         Scalar(self.0 | rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n+///     assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitOr` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitOr;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitOr for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitor(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, true, true, false]);\n+///     assert_eq!(bv1 | bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitor\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} | {RHS}`\"]\n+pub trait BitOr<RHS=Self> {\n+    /// The resulting type after applying the `|` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `|` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitor_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitOr for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitor(self, rhs: $t) -> $t { self | rhs }\n+        }\n+\n+        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n+    )*)\n+}\n+\n+bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise XOR operator `^`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `^` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitXor;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitXor for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n+///     fn bitxor(self, rhs: Self) -> Self {\n+///         Scalar(self.0 ^ rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n+///     assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n+///     assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitXor` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitXor;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitXor for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitxor(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter()\n+///                          .zip(rhs.iter())\n+///                          .map(|(x, y)| (*x || *y) && !(*x && *y))\n+///                          .collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![false, true, true, false]);\n+///     assert_eq!(bv1 ^ bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitxor\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} ^ {RHS}`\"]\n+pub trait BitXor<RHS=Self> {\n+    /// The resulting type after applying the `^` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `^` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitxor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitxor_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitXor for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitxor(self, other: $t) -> $t { self ^ other }\n+        }\n+\n+        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n+    )*)\n+}\n+\n+bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The left shift operator `<<`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Shl` that lifts the `<<` operation on integers to a\n+/// `Scalar` struct.\n+///\n+/// ```\n+/// use std::ops::Shl;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n+///\n+/// impl Shl<Scalar> for Scalar {\n+///     type Output = Self;\n+///\n+///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs << rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shl` that spins a vector leftward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shl;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shl<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shl(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n+///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n+/// }\n+/// ```\n+#[lang = \"shl\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} << {RHS}`\"]\n+pub trait Shl<RHS> {\n+    /// The resulting type after applying the `<<` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `<<` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn shl(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! shl_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shl<$f> for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shl(self, other: $f) -> $t {\n+                self << other\n+            }\n+        }\n+\n+        forward_ref_binop! { impl Shl, shl for $t, $f }\n+    )\n+}\n+\n+macro_rules! shl_impl_all {\n+    ($($t:ty)*) => ($(\n+        shl_impl! { $t, u8 }\n+        shl_impl! { $t, u16 }\n+        shl_impl! { $t, u32 }\n+        shl_impl! { $t, u64 }\n+        shl_impl! { $t, u128 }\n+        shl_impl! { $t, usize }\n+\n+        shl_impl! { $t, i8 }\n+        shl_impl! { $t, i16 }\n+        shl_impl! { $t, i32 }\n+        shl_impl! { $t, i64 }\n+        shl_impl! { $t, i128 }\n+        shl_impl! { $t, isize }\n+    )*)\n+}\n+\n+shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n+\n+/// The right shift operator `>>`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Shr` that lifts the `>>` operation on integers to a\n+/// `Scalar` struct.\n+///\n+/// ```\n+/// use std::ops::Shr;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n+///\n+/// impl Shr<Scalar> for Scalar {\n+///     type Output = Self;\n+///\n+///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs >> rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shr` that spins a vector rightward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shr;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shr<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shr(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n+///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n+/// }\n+/// ```\n+#[lang = \"shr\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} >> {RHS}`\"]\n+pub trait Shr<RHS> {\n+    /// The resulting type after applying the `>>` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `>>` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn shr(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! shr_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shr<$f> for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shr(self, other: $f) -> $t {\n+                self >> other\n+            }\n+        }\n+\n+        forward_ref_binop! { impl Shr, shr for $t, $f }\n+    )\n+}\n+\n+macro_rules! shr_impl_all {\n+    ($($t:ty)*) => ($(\n+        shr_impl! { $t, u8 }\n+        shr_impl! { $t, u16 }\n+        shr_impl! { $t, u32 }\n+        shr_impl! { $t, u64 }\n+        shr_impl! { $t, u128 }\n+        shr_impl! { $t, usize }\n+\n+        shr_impl! { $t, i8 }\n+        shr_impl! { $t, i16 }\n+        shr_impl! { $t, i32 }\n+        shr_impl! { $t, i64 }\n+        shr_impl! { $t, i128 }\n+        shr_impl! { $t, isize }\n+    )*)\n+}\n+\n+shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+/// The bitwise AND assignment operator `&=`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `&=` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitAndAssign;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitAndAssign for Scalar {\n+///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     fn bitand_assign(&mut self, rhs: Self) {\n+///         *self = Scalar(self.0 & rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut scalar = Scalar(true);\n+///     scalar &= Scalar(true);\n+///     assert_eq!(scalar, Scalar(true));\n+///\n+///     let mut scalar = Scalar(true);\n+///     scalar &= Scalar(false);\n+///     assert_eq!(scalar, Scalar(false));\n+///\n+///     let mut scalar = Scalar(false);\n+///     scalar &= Scalar(true);\n+///     assert_eq!(scalar, Scalar(false));\n+///\n+///     let mut scalar = Scalar(false);\n+///     scalar &= Scalar(false);\n+///     assert_eq!(scalar, Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitAndAssign` trait is implemented for a\n+/// `BooleanVector` struct.\n+///\n+/// ```\n+/// use std::ops::BitAndAssign;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitAndAssign for BooleanVector {\n+///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     fn bitand_assign(&mut self, rhs: Self) {\n+///         assert_eq!(self.0.len(), rhs.0.len());\n+///         *self = BooleanVector(self.0\n+///                                   .iter()\n+///                                   .zip(rhs.0.iter())\n+///                                   .map(|(x, y)| *x && *y)\n+///                                   .collect());\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut bv = BooleanVector(vec![true, true, false, false]);\n+///     bv &= BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, false, false, false]);\n+///     assert_eq!(bv, expected);\n+/// }\n+/// ```\n+#[lang = \"bitand_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} &= {Rhs}`\"]\n+pub trait BitAndAssign<Rhs=Self> {\n+    /// The method for the `&=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitand_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitand_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitAndAssign for $t {\n+            #[inline]\n+            fn bitand_assign(&mut self, other: $t) { *self &= other }\n+        }\n+    )+)\n+}\n+\n+bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise OR assignment operator `|=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n+/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n+///\n+/// ```\n+/// use std::ops::BitOrAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl BitOrAssign for Foo {\n+///     fn bitor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Or-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo |= Foo;\n+/// }\n+/// ```\n+#[lang = \"bitor_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} |= {Rhs}`\"]\n+pub trait BitOrAssign<Rhs=Self> {\n+    /// The method for the `|=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitor_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitOrAssign for $t {\n+            #[inline]\n+            fn bitor_assign(&mut self, other: $t) { *self |= other }\n+        }\n+    )+)\n+}\n+\n+bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise XOR assignment operator `^=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n+/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+///\n+/// ```\n+/// use std::ops::BitXorAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl BitXorAssign for Foo {\n+///     fn bitxor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Xor-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo ^= Foo;\n+/// }\n+/// ```\n+#[lang = \"bitxor_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} ^= {Rhs}`\"]\n+pub trait BitXorAssign<Rhs=Self> {\n+    /// The method for the `^=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitxor_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitxor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitXorAssign for $t {\n+            #[inline]\n+            fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n+        }\n+    )+)\n+}\n+\n+bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The left shift assignment operator `<<=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n+/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n+///\n+/// ```\n+/// use std::ops::ShlAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl ShlAssign<Foo> for Foo {\n+///     fn shl_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting left!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo <<= Foo;\n+/// }\n+/// ```\n+#[lang = \"shl_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} <<= {Rhs}`\"]\n+pub trait ShlAssign<Rhs> {\n+    /// The method for the `<<=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn shl_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! shl_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl ShlAssign<$f> for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self <<= other\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! shl_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shl_assign_impl! { $t, u8 }\n+        shl_assign_impl! { $t, u16 }\n+        shl_assign_impl! { $t, u32 }\n+        shl_assign_impl! { $t, u64 }\n+        shl_assign_impl! { $t, u128 }\n+        shl_assign_impl! { $t, usize }\n+\n+        shl_assign_impl! { $t, i8 }\n+        shl_assign_impl! { $t, i16 }\n+        shl_assign_impl! { $t, i32 }\n+        shl_assign_impl! { $t, i64 }\n+        shl_assign_impl! { $t, i128 }\n+        shl_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+/// The right shift assignment operator `>>=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n+/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n+///\n+/// ```\n+/// use std::ops::ShrAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl ShrAssign<Foo> for Foo {\n+///     fn shr_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting right!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo >>= Foo;\n+/// }\n+/// ```\n+#[lang = \"shr_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} >>= {Rhs}`\"]\n+pub trait ShrAssign<Rhs=Self> {\n+    /// The method for the `>>=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn shr_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! shr_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl ShrAssign<$f> for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self >>= other\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! shr_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shr_assign_impl! { $t, u8 }\n+        shr_assign_impl! { $t, u16 }\n+        shr_assign_impl! { $t, u32 }\n+        shr_assign_impl! { $t, u64 }\n+        shr_assign_impl! { $t, u128 }\n+        shr_assign_impl! { $t, usize }\n+\n+        shr_assign_impl! { $t, i8 }\n+        shr_assign_impl! { $t, i16 }\n+        shr_assign_impl! { $t, i32 }\n+        shr_assign_impl! { $t, i64 }\n+        shr_assign_impl! { $t, i128 }\n+        shr_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+shr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }"}, {"sha": "18cf20ac411dff9e28c2e53470344c2b46c9734b", "filename": "src/libcore/ops/deref.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The `Deref` trait is used to specify the functionality of dereferencing\n+/// operations, like `*v`.\n+///\n+/// `Deref` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/first-edition/deref-coercions.html\n+///\n+/// # Examples\n+///\n+/// A struct with a single field which is accessible via dereferencing the\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::Deref;\n+///\n+/// struct DerefExample<T> {\n+///     value: T\n+/// }\n+///\n+/// impl<T> Deref for DerefExample<T> {\n+///     type Target = T;\n+///\n+///     fn deref(&self) -> &T {\n+///         &self.value\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let x = DerefExample { value: 'a' };\n+///     assert_eq!('a', *x);\n+/// }\n+/// ```\n+#[lang = \"deref\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Deref {\n+    /// The resulting type after dereferencing\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Target: ?Sized;\n+\n+    /// The method called to dereference a value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Deref for &'a T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T { *self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Deref for &'a mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T { *self }\n+}\n+\n+/// The `DerefMut` trait is used to specify the functionality of dereferencing\n+/// mutably like `*v = 1;`\n+///\n+/// `DerefMut` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/first-edition/deref-coercions.html\n+///\n+/// # Examples\n+///\n+/// A struct with a single field which is modifiable via dereferencing the\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::{Deref, DerefMut};\n+///\n+/// struct DerefMutExample<T> {\n+///     value: T\n+/// }\n+///\n+/// impl<T> Deref for DerefMutExample<T> {\n+///     type Target = T;\n+///\n+///     fn deref(&self) -> &T {\n+///         &self.value\n+///     }\n+/// }\n+///\n+/// impl<T> DerefMut for DerefMutExample<T> {\n+///     fn deref_mut(&mut self) -> &mut T {\n+///         &mut self.value\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut x = DerefMutExample { value: 'a' };\n+///     *x = 'b';\n+///     assert_eq!('b', *x);\n+/// }\n+/// ```\n+#[lang = \"deref_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait DerefMut: Deref {\n+    /// The method called to mutably dereference a value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn deref_mut(&mut self) -> &mut Self::Target;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> DerefMut for &'a mut T {\n+    fn deref_mut(&mut self) -> &mut T { *self }\n+}"}, {"sha": "92f3cb256c8335f42ea4b233dcf54de9dcc84bd3", "filename": "src/libcore/ops/drop.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The `Drop` trait is used to run some code when a value goes out of scope.\n+/// This is sometimes called a 'destructor'.\n+///\n+/// When a value goes out of scope, if it implements this trait, it will have\n+/// its `drop` method called. Then any fields the value contains will also\n+/// be dropped recursively.\n+///\n+/// Because of the recursive dropping, you do not need to implement this trait\n+/// unless your type needs its own destructor logic.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n+/// goes out of scope, and therefore `main` prints `Dropping!`.\n+///\n+/// ```\n+/// struct HasDrop;\n+///\n+/// impl Drop for HasDrop {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = HasDrop;\n+/// }\n+/// ```\n+///\n+/// Showing the recursive nature of `Drop`. When `outer` goes out of scope, the\n+/// `drop` method will be called first for `Outer`, then for `Inner`. Therefore\n+/// `main` prints `Dropping Outer!` and then `Dropping Inner!`.\n+///\n+/// ```\n+/// struct Inner;\n+/// struct Outer(Inner);\n+///\n+/// impl Drop for Inner {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping Inner!\");\n+///     }\n+/// }\n+///\n+/// impl Drop for Outer {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping Outer!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = Outer(Inner);\n+/// }\n+/// ```\n+///\n+/// Because variables are dropped in the reverse order they are declared,\n+/// `main` will print `Declared second!` and then `Declared first!`.\n+///\n+/// ```\n+/// struct PrintOnDrop(&'static str);\n+///\n+/// fn main() {\n+///     let _first = PrintOnDrop(\"Declared first!\");\n+///     let _second = PrintOnDrop(\"Declared second!\");\n+/// }\n+/// ```\n+#[lang = \"drop\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Drop {\n+    /// A method called when the value goes out of scope.\n+    ///\n+    /// When this method has been called, `self` has not yet been deallocated.\n+    /// If it were, `self` would be a dangling reference.\n+    ///\n+    /// After this function is over, the memory of `self` will be deallocated.\n+    ///\n+    /// This function cannot be called explicitly. This is compiler error\n+    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n+    /// used to call the argument's `Drop` implementation.\n+    ///\n+    /// [E0040]: ../../error-index.html#E0040\n+    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n+    ///\n+    /// # Panics\n+    ///\n+    /// Given that a `panic!` will call `drop()` as it unwinds, any `panic!` in\n+    /// a `drop()` implementation will likely abort.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn drop(&mut self);\n+}"}, {"sha": "62bf69336a398ebdb6015319562fac3ccbb19f46", "filename": "src/libcore/ops/function.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A version of the call operator that takes an immutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures automatically implement this trait, which allows them to be\n+/// invoked. Note, however, that `Fn` takes an immutable reference to any\n+/// captured variables. To take a mutable capture, implement [`FnMut`], and to\n+/// consume the capture, implement [`FnOnce`].\n+///\n+/// [`FnMut`]: trait.FnMut.html\n+/// [`FnOnce`]: trait.FnOnce.html\n+///\n+/// ```\n+/// let square = |x| x * x;\n+/// assert_eq!(square(5), 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `Fn`\n+/// parameter (or a `FnMut` or `FnOnce` parameter, which are supertraits of\n+/// `Fn`).\n+///\n+/// ```\n+/// fn call_with_one<F>(func: F) -> usize\n+///     where F: Fn(usize) -> usize {\n+///     func(1)\n+/// }\n+///\n+/// let double = |x| x * 2;\n+/// assert_eq!(call_with_one(double), 2);\n+/// ```\n+#[lang = \"fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+pub trait Fn<Args> : FnMut<Args> {\n+    /// This is called when the call operator is used.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a mutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures that mutably capture variables automatically implement this trait,\n+/// which allows them to be invoked.\n+///\n+/// ```\n+/// let mut x = 5;\n+/// {\n+///     let mut square_x = || x *= x;\n+///     square_x();\n+/// }\n+/// assert_eq!(x, 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `FnMut`\n+/// parameter (or a `FnOnce` parameter, which is a supertrait of `FnMut`).\n+///\n+/// ```\n+/// fn do_twice<F>(mut func: F)\n+///     where F: FnMut()\n+/// {\n+///     func();\n+///     func();\n+/// }\n+///\n+/// let mut x: usize = 1;\n+/// {\n+///     let add_two_to_x = || x += 2;\n+///     do_twice(add_two_to_x);\n+/// }\n+///\n+/// assert_eq!(x, 5);\n+/// ```\n+#[lang = \"fn_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    /// This is called when the call operator is used.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a by-value receiver.\n+///\n+/// # Examples\n+///\n+/// By-value closures automatically implement this trait, which allows them to\n+/// be invoked.\n+///\n+/// ```\n+/// let x = 5;\n+/// let square_x = move || x * x;\n+/// assert_eq!(square_x(), 25);\n+/// ```\n+///\n+/// By-value Closures can also be passed to higher-level functions through a\n+/// `FnOnce` parameter.\n+///\n+/// ```\n+/// fn consume_with_relish<F>(func: F)\n+///     where F: FnOnce() -> String\n+/// {\n+///     // `func` consumes its captured variables, so it cannot be run more\n+///     // than once\n+///     println!(\"Consumed: {}\", func());\n+///\n+///     println!(\"Delicious!\");\n+///\n+///     // Attempting to invoke `func()` again will throw a `use of moved\n+///     // value` error for `func`\n+/// }\n+///\n+/// let x = String::from(\"x\");\n+/// let consume_and_return_x = move || x;\n+/// consume_with_relish(consume_and_return_x);\n+///\n+/// // `consume_and_return_x` can no longer be invoked at this point\n+/// ```\n+#[lang = \"fn_once\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+pub trait FnOnce<Args> {\n+    /// The returned type after the call operator is used.\n+    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+mod impls {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> Fn<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        type Output = F::Output;\n+\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        type Output = F::Output;\n+        extern \"rust-call\" fn call_once(mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+}"}, {"sha": "b16b956778744d29a9ee2642866ed0c1550e884b", "filename": "src/libcore/ops/index.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The `Index` trait is used to specify the functionality of indexing operations\n+/// like `container[index]` when used in an immutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n+/// but only when used as an immutable value. If a mutable value is requested,\n+/// [`IndexMut`] is used instead. This allows nice things such as\n+/// `let value = v[index]` if `value` implements [`Copy`].\n+///\n+/// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+///\n+/// # Examples\n+///\n+/// The following example implements `Index` on a read-only `NucleotideCount`\n+/// container, enabling individual counts to be retrieved with index syntax.\n+///\n+/// ```\n+/// use std::ops::Index;\n+///\n+/// enum Nucleotide {\n+///     A,\n+///     C,\n+///     G,\n+///     T,\n+/// }\n+///\n+/// struct NucleotideCount {\n+///     a: usize,\n+///     c: usize,\n+///     g: usize,\n+///     t: usize,\n+/// }\n+///\n+/// impl Index<Nucleotide> for NucleotideCount {\n+///     type Output = usize;\n+///\n+///     fn index(&self, nucleotide: Nucleotide) -> &usize {\n+///         match nucleotide {\n+///             Nucleotide::A => &self.a,\n+///             Nucleotide::C => &self.c,\n+///             Nucleotide::G => &self.g,\n+///             Nucleotide::T => &self.t,\n+///         }\n+///     }\n+/// }\n+///\n+/// let nucleotide_count = NucleotideCount {a: 14, c: 9, g: 10, t: 12};\n+/// assert_eq!(nucleotide_count[Nucleotide::A], 14);\n+/// assert_eq!(nucleotide_count[Nucleotide::C], 9);\n+/// assert_eq!(nucleotide_count[Nucleotide::G], 10);\n+/// assert_eq!(nucleotide_count[Nucleotide::T], 12);\n+/// ```\n+#[lang = \"index\"]\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Index<Idx: ?Sized> {\n+    /// The returned type after indexing\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output: ?Sized;\n+\n+    /// The method for the indexing (`container[index]`) operation\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+/// The `IndexMut` trait is used to specify the functionality of indexing\n+/// operations like `container[index]` when used in a mutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for\n+/// `*container.index_mut(index)`, but only when used as a mutable value. If\n+/// an immutable value is requested, the [`Index`] trait is used instead. This\n+/// allows nice things such as `v[index] = value` if `value` implements [`Copy`].\n+///\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+///\n+/// # Examples\n+///\n+/// A very simple implementation of a `Balance` struct that has two sides, where\n+/// each can be indexed mutably and immutably.\n+///\n+/// ```\n+/// use std::ops::{Index,IndexMut};\n+///\n+/// #[derive(Debug)]\n+/// enum Side {\n+///     Left,\n+///     Right,\n+/// }\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Weight {\n+///     Kilogram(f32),\n+///     Pound(f32),\n+/// }\n+///\n+/// struct Balance {\n+///     pub left: Weight,\n+///     pub right:Weight,\n+/// }\n+///\n+/// impl Index<Side> for Balance {\n+///     type Output = Weight;\n+///\n+///     fn index<'a>(&'a self, index: Side) -> &'a Weight {\n+///         println!(\"Accessing {:?}-side of balance immutably\", index);\n+///         match index {\n+///             Side::Left => &self.left,\n+///             Side::Right => &self.right,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl IndexMut<Side> for Balance {\n+///     fn index_mut<'a>(&'a mut self, index: Side) -> &'a mut Weight {\n+///         println!(\"Accessing {:?}-side of balance mutably\", index);\n+///         match index {\n+///             Side::Left => &mut self.left,\n+///             Side::Right => &mut self.right,\n+///         }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut balance = Balance {\n+///         right: Weight::Kilogram(2.5),\n+///         left: Weight::Pound(1.5),\n+///     };\n+///\n+///     // In this case balance[Side::Right] is sugar for\n+///     // *balance.index(Side::Right), since we are only reading\n+///     // balance[Side::Right], not writing it.\n+///     assert_eq!(balance[Side::Right],Weight::Kilogram(2.5));\n+///\n+///     // However in this case balance[Side::Left] is sugar for\n+///     // *balance.index_mut(Side::Left), since we are writing\n+///     // balance[Side::Left].\n+///     balance[Side::Left] = Weight::Kilogram(3.0);\n+/// }\n+/// ```\n+#[lang = \"index_mut\"]\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n+    /// The method for the mutable indexing (`container[index]`) operation\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n+}"}, {"sha": "4e0389e5de4eb24157a74afe4dfaab0cba30a03d", "filename": "src/libcore/ops/mod.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Overloadable operators.\n+//!\n+//! Implementing these traits allows you to overload certain operators.\n+//!\n+//! Some of these traits are imported by the prelude, so they are available in\n+//! every Rust program. Only operators backed by traits can be overloaded. For\n+//! example, the addition operator (`+`) can be overloaded through the [`Add`]\n+//! trait, but since the assignment operator (`=`) has no backing trait, there\n+//! is no way of overloading its semantics. Additionally, this module does not\n+//! provide any mechanism to create new operators. If traitless overloading or\n+//! custom operators are required, you should look toward macros or compiler\n+//! plugins to extend Rust's syntax.\n+//!\n+//! Note that the `&&` and `||` operators short-circuit, i.e. they only\n+//! evaluate their second operand if it contributes to the result. Since this\n+//! behavior is not enforceable by traits, `&&` and `||` are not supported as\n+//! overloadable operators.\n+//!\n+//! Many of the operators take their operands by value. In non-generic\n+//! contexts involving built-in types, this is usually not a problem.\n+//! However, using these operators in generic code, requires some\n+//! attention if values have to be reused as opposed to letting the operators\n+//! consume them. One option is to occasionally use [`clone`].\n+//! Another option is to rely on the types involved providing additional\n+//! operator implementations for references. For example, for a user-defined\n+//! type `T` which is supposed to support addition, it is probably a good\n+//! idea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n+//! [`Add<&T>`][`Add`] so that generic code can be written without unnecessary\n+//! cloning.\n+//!\n+//! # Examples\n+//!\n+//! This example creates a `Point` struct that implements [`Add`] and [`Sub`],\n+//! and then demonstrates adding and subtracting two `Point`s.\n+//!\n+//! ```rust\n+//! use std::ops::{Add, Sub};\n+//!\n+//! #[derive(Debug)]\n+//! struct Point {\n+//!     x: i32,\n+//!     y: i32,\n+//! }\n+//!\n+//! impl Add for Point {\n+//!     type Output = Point;\n+//!\n+//!     fn add(self, other: Point) -> Point {\n+//!         Point {x: self.x + other.x, y: self.y + other.y}\n+//!     }\n+//! }\n+//!\n+//! impl Sub for Point {\n+//!     type Output = Point;\n+//!\n+//!     fn sub(self, other: Point) -> Point {\n+//!         Point {x: self.x - other.x, y: self.y - other.y}\n+//!     }\n+//! }\n+//! fn main() {\n+//!     println!(\"{:?}\", Point {x: 1, y: 0} + Point {x: 2, y: 3});\n+//!     println!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3});\n+//! }\n+//! ```\n+//!\n+//! See the documentation for each trait for an example implementation.\n+//!\n+//! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n+//! invoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\n+//! self` and [`FnOnce`] takes `self`. These correspond to the three kinds of\n+//! methods that can be invoked on an instance: call-by-reference,\n+//! call-by-mutable-reference, and call-by-value. The most common use of these\n+//! traits is to act as bounds to higher-level functions that take functions or\n+//! closures as arguments.\n+//!\n+//! Taking a [`Fn`] as a parameter:\n+//!\n+//! ```rust\n+//! fn call_with_one<F>(func: F) -> usize\n+//!     where F: Fn(usize) -> usize\n+//! {\n+//!     func(1)\n+//! }\n+//!\n+//! let double = |x| x * 2;\n+//! assert_eq!(call_with_one(double), 2);\n+//! ```\n+//!\n+//! Taking a [`FnMut`] as a parameter:\n+//!\n+//! ```rust\n+//! fn do_twice<F>(mut func: F)\n+//!     where F: FnMut()\n+//! {\n+//!     func();\n+//!     func();\n+//! }\n+//!\n+//! let mut x: usize = 1;\n+//! {\n+//!     let add_two_to_x = || x += 2;\n+//!     do_twice(add_two_to_x);\n+//! }\n+//!\n+//! assert_eq!(x, 5);\n+//! ```\n+//!\n+//! Taking a [`FnOnce`] as a parameter:\n+//!\n+//! ```rust\n+//! fn consume_with_relish<F>(func: F)\n+//!     where F: FnOnce() -> String\n+//! {\n+//!     // `func` consumes its captured variables, so it cannot be run more\n+//!     // than once\n+//!     println!(\"Consumed: {}\", func());\n+//!\n+//!     println!(\"Delicious!\");\n+//!\n+//!     // Attempting to invoke `func()` again will throw a `use of moved\n+//!     // value` error for `func`\n+//! }\n+//!\n+//! let x = String::from(\"x\");\n+//! let consume_and_return_x = move || x;\n+//! consume_with_relish(consume_and_return_x);\n+//!\n+//! // `consume_and_return_x` can no longer be invoked at this point\n+//! ```\n+//!\n+//! [`Fn`]: trait.Fn.html\n+//! [`FnMut`]: trait.FnMut.html\n+//! [`FnOnce`]: trait.FnOnce.html\n+//! [`Add`]: trait.Add.html\n+//! [`Sub`]: trait.Sub.html\n+//! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+mod arith;\n+mod bit;\n+mod deref;\n+mod drop;\n+mod function;\n+mod index;\n+mod place;\n+mod range;\n+mod try;\n+mod unsize;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::bit::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::deref::{Deref, DerefMut};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::drop::Drop;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::function::{Fn, FnMut, FnOnce};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::index::{Index, IndexMut};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub use self::range::{RangeInclusive, RangeToInclusive};\n+\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+#[cfg(stage0)]\n+pub use self::try::Carrier;\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+pub use self::try::Try;\n+\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n+\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+pub use self::unsize::CoerceUnsized;"}, {"sha": "996a741c96f9372fc1b95e313317d8ce3a786b52", "filename": "src/libcore/ops/place.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Both `PLACE <- EXPR` and `box EXPR` desugar into expressions\n+/// that allocate an intermediate \"place\" that holds uninitialized\n+/// state.  The desugaring evaluates EXPR, and writes the result at\n+/// the address returned by the `pointer` method of this trait.\n+///\n+/// A `Place` can be thought of as a special representation for a\n+/// hypothetical `&uninit` reference (which Rust cannot currently\n+/// express directly). That is, it represents a pointer to\n+/// uninitialized storage.\n+///\n+/// The client is responsible for two steps: First, initializing the\n+/// payload (it can access its address via `pointer`). Second,\n+/// converting the agent to an instance of the owning pointer, via the\n+/// appropriate `finalize` method (see the `InPlace`.\n+///\n+/// If evaluating EXPR fails, then it is up to the destructor for the\n+/// implementation of Place to clean up any intermediate state\n+/// (e.g. deallocate box storage, pop a stack, etc).\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Place<Data: ?Sized> {\n+    /// Returns the address where the input value will be written.\n+    /// Note that the data at this address is generally uninitialized,\n+    /// and thus one should use `ptr::write` for initializing it.\n+    fn pointer(&mut self) -> *mut Data;\n+}\n+\n+/// Interface to implementations of  `PLACE <- EXPR`.\n+///\n+/// `PLACE <- EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let p = PLACE;\n+/// let mut place = Placer::make_place(p);\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     std::ptr::write(raw_place, value);\n+///     InPlace::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n+/// if the type of `PLACE` is `P`, then the final type of the whole\n+/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n+/// traits).\n+///\n+/// Values for types implementing this trait usually are transient\n+/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n+/// or `Copy`, since the `make_place` method takes `self` by value.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Placer<Data: ?Sized> {\n+    /// `Place` is the intermedate agent guarding the\n+    /// uninitialized state for `Data`.\n+    type Place: InPlace<Data>;\n+\n+    /// Creates a fresh place from `self`.\n+    fn make_place(self) -> Self::Place;\n+}\n+\n+/// Specialization of `Place` trait supporting `PLACE <- EXPR`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait InPlace<Data: ?Sized>: Place<Data> {\n+    /// `Owner` is the type of the end value of `PLACE <- EXPR`\n+    ///\n+    /// Note that when `PLACE <- EXPR` is solely used for\n+    /// side-effecting an existing data-structure,\n+    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n+    /// information at all (e.g. it can be the unit type `()` in that\n+    /// case).\n+    type Owner;\n+\n+    /// Converts self into the final value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// the returned instance of `Owner` and forgetting self.\n+    unsafe fn finalize(self) -> Self::Owner;\n+}\n+\n+/// Core trait for the `box EXPR` form.\n+///\n+/// `box EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let mut place = BoxPlace::make_place();\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     ::std::ptr::write(raw_place, value);\n+///     Boxed::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `box EXPR` is supplied from its surrounding\n+/// context; in the above expansion, the result type `T` is used\n+/// to determine which implementation of `Boxed` to use, and that\n+/// `<T as Boxed>` in turn dictates determines which\n+/// implementation of `BoxPlace` to use, namely:\n+/// `<<T as Boxed>::Place as BoxPlace>`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Boxed {\n+    /// The kind of data that is stored in this kind of box.\n+    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n+    /// The place that will negotiate the storage of the data.\n+    type Place: BoxPlace<Self::Data>;\n+\n+    /// Converts filled place into final owning value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// returned instance of `Self` and forgetting `filled`.\n+    unsafe fn finalize(filled: Self::Place) -> Self;\n+}\n+\n+/// Specialization of `Place` trait supporting `box EXPR`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n+    /// Creates a globally fresh place.\n+    fn make_place() -> Self;\n+}"}, {"sha": "70c35df87ddaf8d1aef329b7ff44a783d4a6623b", "filename": "src/libcore/ops/range.rs", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,366 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+\n+/// An unbounded range. Use `..` (two dots) for its shorthand.\n+///\n+/// Its primary use case is slicing index. It cannot serve as an iterator\n+/// because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `..` syntax is a `RangeFull`:\n+///\n+/// ```\n+/// assert_eq!((..), std::ops::RangeFull);\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in .. {\n+///    // ...\n+/// }\n+/// ```\n+///\n+/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n+///\n+/// ```\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeFull;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for RangeFull {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"..\")\n+    }\n+}\n+\n+/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n+/// Use `start..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3..6).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Range<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub start: Idx,\n+    /// The upper bound of the range (exclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub end: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..5).contains(2));\n+    ///     assert!(   (3..5).contains(3));\n+    ///     assert!(   (3..5).contains(4));\n+    ///     assert!( ! (3..5).contains(5));\n+    ///\n+    ///     assert!( ! (3..3).contains(3));\n+    ///     assert!( ! (3..2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item) && (item < self.end)\n+    }\n+}\n+\n+/// A range which is only bounded below: { x | start <= x }.\n+/// Use `start..` for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// Note: Currently, no overflow checking is done for the iterator\n+/// implementation; if you use an integer range and the integer overflows, it\n+/// might panic in debug mode or create an endless loop in release mode. This\n+/// overflow behavior might change in the future.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n+///     assert_eq!(2+3+4, (2..).take(3).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeFrom<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub start: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..\", self.start)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..).contains(2));\n+    ///     assert!(   (3..).contains(3));\n+    ///     assert!(   (3..).contains(1_000_000_000));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item)\n+    }\n+}\n+\n+/// A range which is only bounded above: { x | x < end }.\n+/// Use `..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `..{integer}` syntax is a `RangeTo`:\n+///\n+/// ```\n+/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ..5 {\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// When used as a slicing index, `RangeTo` produces a slice of all array\n+/// elements before the index indicated by `end`.\n+///\n+/// ```\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeTo<Idx> {\n+    /// The upper bound of the range (exclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub end: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"..{:?}\", self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!(   (..5).contains(-1_000_000_000));\n+    ///     assert!(   (..5).contains(4));\n+    ///     assert!( ! (..5).contains(5));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item < self.end)\n+    }\n+}\n+\n+/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n+/// Use `start...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// fn main() {\n+///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3...5).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ ...2], [0,1,2  ]);\n+///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeInclusive<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub start: Idx,\n+    /// The upper bound of the range (inclusive).\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!( ! (3...5).contains(2));\n+    ///     assert!(   (3...5).contains(3));\n+    ///     assert!(   (3...5).contains(4));\n+    ///     assert!(   (3...5).contains(5));\n+    ///     assert!( ! (3...5).contains(6));\n+    ///\n+    ///     assert!(   (3...3).contains(3));\n+    ///     assert!( ! (3...2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        self.start <= item && item <= self.end\n+    }\n+}\n+\n+/// An inclusive range which is only bounded above: { x | x <= end }.\n+/// Use `...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `...{integer}` syntax is a `RangeToInclusive`:\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ...5 {\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n+/// array elements up to and including the index indicated by `end`.\n+///\n+/// ```\n+/// #![feature(inclusive_range_syntax)]\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1...2], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeToInclusive<Idx> {\n+    /// The upper bound of the range (inclusive)\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"...{:?}\", self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!(   (...5).contains(-1_000_000_000));\n+    ///     assert!(   (...5).contains(5));\n+    ///     assert!( ! (...5).contains(6));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item <= self.end)\n+    }\n+}\n+\n+// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n+// because underflow would be possible with (..0).into()"}, {"sha": "cf75cf79fae6989f9667a10e1eb5eb5c33abded4", "filename": "src/libcore/ops/try.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// This trait has been superseded by the `Try` trait, but must remain\n+/// here as `?` is still lowered to it in stage0 .\n+#[cfg(stage0)]\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+pub trait Carrier {\n+    /// The type of the value when computation succeeds.\n+    type Success;\n+    /// The type of the value when computation errors out.\n+    type Error;\n+\n+    /// Create a `Carrier` from a success value.\n+    fn from_success(_: Self::Success) -> Self;\n+\n+    /// Create a `Carrier` from an error value.\n+    fn from_error(_: Self::Error) -> Self;\n+\n+    /// Translate this `Carrier` to another implementation of `Carrier` with the\n+    /// same associated types.\n+    fn translate<T>(self) -> T where T: Carrier<Success=Self::Success, Error=Self::Error>;\n+}\n+\n+#[cfg(stage0)]\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+impl<U, V> Carrier for Result<U, V> {\n+    type Success = U;\n+    type Error = V;\n+\n+    fn from_success(u: U) -> Result<U, V> {\n+        Ok(u)\n+    }\n+\n+    fn from_error(e: V) -> Result<U, V> {\n+        Err(e)\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=U, Error=V>\n+    {\n+        match self {\n+            Ok(u) => T::from_success(u),\n+            Err(e) => T::from_error(e),\n+        }\n+    }\n+}\n+\n+struct _DummyErrorType;\n+\n+impl Try for _DummyErrorType {\n+    type Ok = ();\n+    type Error = ();\n+\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn from_ok(_: ()) -> _DummyErrorType {\n+        _DummyErrorType\n+    }\n+\n+    fn from_error(_: ()) -> _DummyErrorType {\n+        _DummyErrorType\n+    }\n+}\n+\n+/// A trait for customizing the behaviour of the `?` operator.\n+///\n+/// A type implementing `Try` is one that has a canonical way to view it\n+/// in terms of a success/failure dichotomy.  This trait allows both\n+/// extracting those success or failure values from an existing instance and\n+/// creating a new instance from a success or failure value.\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+pub trait Try {\n+    /// The type of this value when viewed as successful.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    type Ok;\n+    /// The type of this value when viewed as failed.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    type Error;\n+\n+    /// Applies the \"?\" operator. A return of `Ok(t)` means that the\n+    /// execution should continue normally, and the result of `?` is the\n+    /// value `t`. A return of `Err(e)` means that execution should branch\n+    /// to the innermost enclosing `catch`, or return from the function.\n+    ///\n+    /// If an `Err(e)` result is returned, the value `e` will be \"wrapped\"\n+    /// in the return type of the enclosing scope (which must itself implement\n+    /// `Try`). Specifically, the value `X::from_error(From::from(e))`\n+    /// is returned, where `X` is the return type of the enclosing function.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error>;\n+\n+    /// Wrap an error value to construct the composite result. For example,\n+    /// `Result::Err(x)` and `Result::from_error(x)` are equivalent.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    fn from_error(v: Self::Error) -> Self;\n+\n+    /// Wrap an OK value to construct the composite result. For example,\n+    /// `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.\n+    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n+    fn from_ok(v: Self::Ok) -> Self;\n+}"}, {"sha": "1914216e9f08a97b78b36983db7444e4ef0989b6", "filename": "src/libcore/ops/unsize.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use marker::Unsize;\n+\n+/// Trait that indicates that this is a pointer or a wrapper for one,\n+/// where unsizing can be performed on the pointee.\n+///\n+/// See the [DST coercion RfC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce]\n+/// for more details.\n+///\n+/// For builtin pointer types, pointers to `T` will coerce to pointers to `U` if `T: Unsize<U>`\n+/// by converting from a thin pointer to a fat pointer.\n+///\n+/// For custom types, the coercion here works by coercing `Foo<T>` to `Foo<U>`\n+/// provided an impl of `CoerceUnsized<Foo<U>> for Foo<T>` exists.\n+/// Such an impl can only be written if `Foo<T>` has only a single non-phantomdata\n+/// field involving `T`. If the type of that field is `Bar<T>`, an implementation\n+/// of `CoerceUnsized<Bar<U>> for Bar<T>` must exist. The coercion will work by\n+/// by coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields\n+/// from `Foo<T>` to create a `Foo<U>`. This will effectively drill down to a pointer\n+/// field and coerce that.\n+///\n+/// Generally, for smart pointers you will implement\n+/// `CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized`, with an\n+/// optional `?Sized` bound on `T` itself. For wrapper types that directly embed `T`\n+/// like `Cell<T>` and `RefCell<T>`, you\n+/// can directly implement `CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>`.\n+/// This will let coercions of types like `Cell<Box<T>>` work.\n+///\n+/// [`Unsize`][unsize] is used to mark types which can be coerced to DSTs if behind\n+/// pointers. It is implemented automatically by the compiler.\n+///\n+/// [dst-coerce]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+/// [unsize]: ../marker/trait.Unsize.html\n+/// [nomicon-coerce]: ../../nomicon/coercions.html\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+#[lang=\"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {\n+    // Empty.\n+}\n+\n+// &mut T -> &mut U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+// &mut T -> &U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+// &mut T -> *mut U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+// &mut T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+\n+// &T -> &U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+// &T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+\n+// *mut T -> *mut U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+// *mut T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+\n+// *const T -> *const U\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}"}, {"sha": "88a93492de96257276348c3f1eda3a28f6d2ff01", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1060,12 +1060,9 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// checking for overflow:\n     ///\n     /// ```\n-    /// use std::u32;\n-    ///\n     /// let v = vec![1, 2];\n-    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|&x: &u32|\n-    ///     if x == u32::MAX { Err(\"Overflow!\") }\n-    ///     else { Ok(x + 1) }\n+    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|x: &u32|\n+    ///     x.checked_add(1).ok_or(\"Overflow!\")\n     /// ).collect();\n     /// assert!(res == Ok(vec![2, 3]));\n     /// ```\n@@ -1126,4 +1123,4 @@ impl<T,E> ops::Try for Result<T, E> {\n     fn from_error(v: E) -> Self {\n         Err(v)\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "624c3638df5cced4895d8d73bb1b3881fe2b6ca9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -1617,12 +1617,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeTo<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(0, index.end) }\n-            } else {\n-                super::slice_error_fail(self, 0, index.end)\n-            }\n+            index.index(self)\n         }\n     }\n \n@@ -1636,12 +1631,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeTo<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.end) {\n-                unsafe { self.slice_mut_unchecked(0, index.end) }\n-            } else {\n-                super::slice_error_fail(self, 0, index.end)\n-            }\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1657,12 +1647,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.start) {\n-                unsafe { self.slice_unchecked(index.start, self.len()) }\n-            } else {\n-                super::slice_error_fail(self, index.start, self.len())\n-            }\n+            index.index(self)\n         }\n     }\n \n@@ -1676,13 +1661,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.start) {\n-                let len = self.len();\n-                unsafe { self.slice_mut_unchecked(index.start, len) }\n-            } else {\n-                super::slice_error_fail(self, index.start, self.len())\n-            }\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1724,9 +1703,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index(index.start .. index.end+1)\n+            index.index(self)\n         }\n     }\n \n@@ -1738,9 +1715,7 @@ mod traits {\n \n         #[inline]\n         fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index(.. index.end+1)\n+            index.index(self)\n         }\n     }\n \n@@ -1750,9 +1725,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index_mut(index.start .. index.end+1)\n+            index.index_mut(self)\n         }\n     }\n     #[unstable(feature = \"inclusive_range\",\n@@ -1761,9 +1734,7 @@ mod traits {\n     impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n-            assert!(index.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n-            self.index_mut(.. index.end+1)\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1886,6 +1857,7 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.end) {\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n@@ -1932,6 +1904,7 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.start) {\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n@@ -1945,11 +1918,19 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            (self.start..self.end+1).get(slice)\n+            if let Some(end) = self.end.checked_add(1) {\n+                (self.start..end).get(slice)\n+            } else {\n+                None\n+            }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            (self.start..self.end+1).get_mut(slice)\n+            if let Some(end) = self.end.checked_add(1) {\n+                (self.start..end).get_mut(slice)\n+            } else {\n+                None\n+            }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n@@ -1961,10 +1942,14 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             (self.start..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             (self.start..self.end+1).index_mut(slice)\n         }\n     }\n@@ -1976,15 +1961,15 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if slice.is_char_boundary(self.end + 1) {\n+            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if slice.is_char_boundary(self.end + 1) {\n+            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -2002,11 +1987,15 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             let end = self.end + 1;\n             self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            assert!(self.end != usize::max_value(),\n+                \"attempted to index str up to maximum usize\");\n             if slice.is_char_boundary(self.end) {\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n@@ -2026,7 +2015,7 @@ mod traits {\n            issue = \"32110\")]\n pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n-    // libcollections, not here.\n+    // liballoc, not here.\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n@@ -2096,7 +2085,7 @@ pub trait StrExt {\n     fn is_char_boundary(&self, index: usize) -> bool;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_bytes(&self) -> &[u8];\n-    #[unstable(feature = \"str_mut_extras\", issue = \"0\")]\n+    #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n     unsafe fn as_bytes_mut(&mut self) -> &mut [u8];\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;"}, {"sha": "5a007285e48735657bf07308064636051e87b3ea", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -618,7 +618,10 @@ impl<'a, 'b> StrSearcher<'a, 'b> {\n }\n \n unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n-    fn haystack(&self) -> &'a str { self.haystack }\n+    #[inline]\n+    fn haystack(&self) -> &'a str {\n+        self.haystack\n+    }\n \n     #[inline]\n     fn next(&mut self) -> SearchStep {"}, {"sha": "8c5179f59932bba13ef4636260099ae16aabed1c", "filename": "src/libcore/tests/cmp.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcmp.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -28,6 +28,16 @@ fn test_mut_int_totalord() {\n     assert_eq!((&mut 12).cmp(&&mut -5), Greater);\n }\n \n+#[test]\n+fn test_ord_max_min() {\n+    assert_eq!(1.max(2), 2);\n+    assert_eq!(2.max(1), 2);\n+    assert_eq!(1.min(2), 1);\n+    assert_eq!(2.min(1), 1);\n+    assert_eq!(1.max(1), 1);\n+    assert_eq!(1.min(1), 1);\n+}\n+\n #[test]\n fn test_ordering_reverse() {\n     assert_eq!(Less.reverse(), Greater);"}, {"sha": "337f8aa31dc4603ee9a563c2a2f153a7b57ace6f", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -13,6 +13,7 @@\n #![feature(box_syntax)]\n #![feature(char_escape_debug)]\n #![feature(const_fn)]\n+#![feature(core_float)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]\n@@ -26,6 +27,7 @@\n #![feature(iter_rfind)]\n #![feature(libc)]\n #![feature(nonzero)]\n+#![feature(ord_max_min)]\n #![feature(rand)]\n #![feature(raw)]\n #![feature(sip_hash_13)]"}, {"sha": "9934e1dab9662696e07bc0fe6761f49522a826eb", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -33,6 +33,7 @@ macro_rules! test_literal {\n     })\n }\n \n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn ordinary() {\n     test_literal!(1.0);\n@@ -43,6 +44,7 @@ fn ordinary() {\n     test_literal!(2.2250738585072014e-308);\n }\n \n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn special_code_paths() {\n     test_literal!(36893488147419103229.0); // 2^65 - 3, triggers half-to-even with even significand"}, {"sha": "c9cd2bf5a9ae7db59ca89794468fc1e9c4c7333c", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -86,6 +86,7 @@ fn rounding_overflow() {\n     assert_eq!(rounded.k, adjusted_k + 1);\n }\n \n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn prev_float_monotonic() {\n     let mut x = 1.0;\n@@ -121,6 +122,7 @@ fn next_float_inf() {\n     assert_eq!(next_float(f64::INFINITY), f64::INFINITY);\n }\n \n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn next_prev_identity() {\n     for &x in &SOME_FLOATS {\n@@ -131,6 +133,7 @@ fn next_prev_identity() {\n     }\n }\n \n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn next_float_monotonic() {\n     let mut x = 0.49999999999999;"}, {"sha": "03772a765cc6a2ead15fd9346c866c675a5461b1", "filename": "src/libcore/tests/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -24,6 +24,7 @@ fn test_mul_pow10() {\n     }\n }\n \n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn shortest_sanity_test() {\n     f64_shortest_sanity_test(format_shortest);"}, {"sha": "17fb99bcc92249e3f889c5aec75d23f762ec604b", "filename": "src/libcore/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -38,6 +38,7 @@ fn test_max_pow10_no_more_than() {\n }\n \n \n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn shortest_sanity_test() {\n     f64_shortest_sanity_test(format_shortest);"}, {"sha": "f233b649a8f3c6bda621047a70bae2ff9ff88381", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -169,6 +169,7 @@ test_impl_from! { test_u16f64, u16, f64 }\n test_impl_from! { test_u32f64, u32, f64 }\n \n // Float -> Float\n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n #[test]\n fn test_f32f64() {\n     use core::f32;\n@@ -398,3 +399,57 @@ test_impl_try_from_signed_to_unsigned_err! { test_try_i32u16, i32, u16 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u8, i64, u8 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u16, i64, u16 }\n test_impl_try_from_signed_to_unsigned_err! { test_try_i64u32, i64, u32 }\n+\n+macro_rules! test_float {\n+    ($modname: ident, $fty: ty, $inf: expr, $neginf: expr, $nan: expr) => { mod $modname {\n+        use core::num::Float;\n+        // FIXME(nagisa): these tests should test for sign of -0.0\n+        #[test]\n+        fn min() {\n+            assert_eq!(0.0.min(0.0), 0.0);\n+            assert_eq!((-0.0).min(-0.0), -0.0);\n+            assert_eq!(9.0.min(9.0), 9.0);\n+            assert_eq!((-9.0).min(0.0), -9.0);\n+            assert_eq!(0.0.min(9.0), 0.0);\n+            assert_eq!((-0.0).min(-9.0), -9.0);\n+            assert_eq!($inf.min(9.0), 9.0);\n+            assert_eq!(9.0.min($inf), 9.0);\n+            assert_eq!($inf.min(-9.0), -9.0);\n+            assert_eq!((-9.0).min($inf), -9.0);\n+            assert_eq!($neginf.min(9.0), $neginf);\n+            assert_eq!(9.0.min($neginf), $neginf);\n+            assert_eq!($neginf.min(-9.0), $neginf);\n+            assert_eq!((-9.0).min($neginf), $neginf);\n+            assert_eq!($nan.min(9.0), 9.0);\n+            assert_eq!($nan.min(-9.0), -9.0);\n+            assert_eq!(9.0.min($nan), 9.0);\n+            assert_eq!((-9.0).min($nan), -9.0);\n+            assert!($nan.min($nan).is_nan());\n+        }\n+        #[test]\n+        fn max() {\n+            assert_eq!(0.0.max(0.0), 0.0);\n+            assert_eq!((-0.0).max(-0.0), -0.0);\n+            assert_eq!(9.0.max(9.0), 9.0);\n+            assert_eq!((-9.0).max(0.0), 0.0);\n+            assert_eq!(0.0.max(9.0), 9.0);\n+            assert_eq!((-0.0).max(-9.0), -0.0);\n+            assert_eq!($inf.max(9.0), $inf);\n+            assert_eq!(9.0.max($inf), $inf);\n+            assert_eq!($inf.max(-9.0), $inf);\n+            assert_eq!((-9.0).max($inf), $inf);\n+            assert_eq!($neginf.max(9.0), 9.0);\n+            assert_eq!(9.0.max($neginf), 9.0);\n+            assert_eq!($neginf.max(-9.0), -9.0);\n+            assert_eq!((-9.0).max($neginf), -9.0);\n+            assert_eq!($nan.max(9.0), 9.0);\n+            assert_eq!($nan.max(-9.0), -9.0);\n+            assert_eq!(9.0.max($nan), 9.0);\n+            assert_eq!((-9.0).max($nan), -9.0);\n+            assert!($nan.max($nan).is_nan());\n+        }\n+    } }\n+}\n+\n+test_float!(f32, f32, ::core::f32::INFINITY, ::core::f32::NEG_INFINITY, ::core::f32::NAN);\n+test_float!(f64, f64, ::core::f64::INFINITY, ::core::f64::NEG_INFINITY, ::core::f64::NAN);"}, {"sha": "967bfb6c99057e7a09714c5c4adc8e067868b6d1", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -26,7 +26,7 @@\n #![deny(warnings)]\n \n #![cfg_attr(stage0, feature(staged_api))]\n-#![feature(unicode)]\n+#![feature(rustc_private)]\n \n pub use self::Piece::*;\n pub use self::Position::*;"}, {"sha": "0c326ce3718435f6f4517275f1b7838e12b931b8", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -61,9 +61,11 @@ pub enum EHAction {\n \n pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n \n-pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext)\n+    -> Result<EHAction, ()>\n+{\n     if lsda.is_null() {\n-        return EHAction::None;\n+        return Ok(EHAction::None)\n     }\n \n     let func_start = context.func_start;\n@@ -72,7 +74,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n     let start_encoding = reader.read::<u8>();\n     // base address for landing pad offsets\n     let lpad_base = if start_encoding != DW_EH_PE_omit {\n-        read_encoded_pointer(&mut reader, context, start_encoding)\n+        read_encoded_pointer(&mut reader, context, start_encoding)?\n     } else {\n         func_start\n     };\n@@ -90,9 +92,9 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n \n     if !USING_SJLJ_EXCEPTIONS {\n         while reader.ptr < action_table {\n-            let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-            let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-            let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n+            let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n+            let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n             let cs_action = reader.read_uleb128();\n             // Callsite table is sorted by cs_start, so if we've passed the ip, we\n             // may stop searching.\n@@ -101,23 +103,23 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n             }\n             if ip < func_start + cs_start + cs_len {\n                 if cs_lpad == 0 {\n-                    return EHAction::None;\n+                    return Ok(EHAction::None)\n                 } else {\n                     let lpad = lpad_base + cs_lpad;\n-                    return interpret_cs_action(cs_action, lpad);\n+                    return Ok(interpret_cs_action(cs_action, lpad))\n                 }\n             }\n         }\n         // Ip is not present in the table.  This should not happen... but it does: issue #35011.\n         // So rather than returning EHAction::Terminate, we do this.\n-        EHAction::None\n+        Ok(EHAction::None)\n     } else {\n         // SjLj version:\n         // The \"IP\" is an index into the call-site table, with two exceptions:\n         // -1 means 'no-action', and 0 means 'terminate'.\n         match ip as isize {\n-            -1 => return EHAction::None,\n-            0 => return EHAction::Terminate,\n+            -1 => return Ok(EHAction::None),\n+            0 => return Ok(EHAction::Terminate),\n             _ => (),\n         }\n         let mut idx = ip;\n@@ -129,7 +131,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n                 // Can never have null landing pad for sjlj -- that would have\n                 // been indicated by a -1 call site index.\n                 let lpad = (cs_lpad + 1) as usize;\n-                return interpret_cs_action(cs_action, lpad);\n+                return Ok(interpret_cs_action(cs_action, lpad))\n             }\n         }\n     }\n@@ -144,21 +146,26 @@ fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n }\n \n #[inline]\n-fn round_up(unrounded: usize, align: usize) -> usize {\n-    assert!(align.is_power_of_two());\n-    (unrounded + align - 1) & !(align - 1)\n+fn round_up(unrounded: usize, align: usize) -> Result<usize, ()> {\n+    if align.is_power_of_two() {\n+        Ok((unrounded + align - 1) & !(align - 1))\n+    } else {\n+        Err(())\n+    }\n }\n \n unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n                                context: &EHContext,\n                                encoding: u8)\n-                               -> usize {\n-    assert!(encoding != DW_EH_PE_omit);\n+                               -> Result<usize, ()> {\n+    if encoding == DW_EH_PE_omit {\n+        return Err(())\n+    }\n \n     // DW_EH_PE_aligned implies it's an absolute pointer value\n     if encoding == DW_EH_PE_aligned {\n-        reader.ptr = round_up(reader.ptr as usize, mem::size_of::<usize>()) as *const u8;\n-        return reader.read::<usize>();\n+        reader.ptr = round_up(reader.ptr as usize, mem::size_of::<usize>())? as *const u8;\n+        return Ok(reader.read::<usize>())\n     }\n \n     let mut result = match encoding & 0x0F {\n@@ -171,25 +178,27 @@ unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n         DW_EH_PE_sdata2 => reader.read::<i16>() as usize,\n         DW_EH_PE_sdata4 => reader.read::<i32>() as usize,\n         DW_EH_PE_sdata8 => reader.read::<i64>() as usize,\n-        _ => panic!(),\n+        _ => return Err(()),\n     };\n \n     result += match encoding & 0x70 {\n         DW_EH_PE_absptr => 0,\n         // relative to address of the encoded value, despite the name\n         DW_EH_PE_pcrel => reader.ptr as usize,\n         DW_EH_PE_funcrel => {\n-            assert!(context.func_start != 0);\n+            if context.func_start == 0 {\n+                return Err(())\n+            }\n             context.func_start\n         }\n         DW_EH_PE_textrel => (*context.get_text_start)(),\n         DW_EH_PE_datarel => (*context.get_data_start)(),\n-        _ => panic!(),\n+        _ => return Err(()),\n     };\n \n     if encoding & DW_EH_PE_indirect != 0 {\n         result = *(result as *const usize);\n     }\n \n-    result\n+    Ok(result)\n }"}, {"sha": "aadbeb96b2d235a255c8981c445de957fb39223c", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -156,7 +156,10 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n     if version != 1 {\n         return uw::_URC_FATAL_PHASE1_ERROR;\n     }\n-    let eh_action = find_eh_action(context);\n+    let eh_action = match find_eh_action(context) {\n+        Ok(action) => action,\n+        Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n+    };\n     if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n         match eh_action {\n             EHAction::None |\n@@ -219,7 +222,10 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n     // bypassing DWARF compatibility functions.\n \n-    let eh_action = find_eh_action(context);\n+    let eh_action = match find_eh_action(context) {\n+        Ok(action) => action,\n+        Err(_) => return uw::_URC_FAILURE,\n+    };\n     if search_phase {\n         match eh_action {\n             EHAction::None |\n@@ -260,7 +266,9 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     }\n }\n \n-unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> EHAction {\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n+    -> Result<EHAction, ()>\n+{\n     let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n     let mut ip_before_instr: c_int = 0;\n     let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);"}, {"sha": "0a9fa7d9a80b44e637cb453dcc6df449a0c82847", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -128,9 +128,10 @@ unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n         get_data_start: &|| unimplemented!(),\n     };\n     match find_eh_action(dc.HandlerData, &eh_ctx) {\n-        EHAction::None => None,\n-        EHAction::Cleanup(lpad) |\n-        EHAction::Catch(lpad) => Some(lpad),\n-        EHAction::Terminate => intrinsics::abort(),\n+        Err(_) |\n+        Ok(EHAction::None) => None,\n+        Ok(EHAction::Cleanup(lpad)) |\n+        Ok(EHAction::Catch(lpad)) => Some(lpad),\n+        Ok(EHAction::Terminate) => intrinsics::abort(),\n     }\n }"}, {"sha": "f3d0521a2af6cc3811fc4c026faa37ceaf457c44", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -21,7 +21,7 @@\n //! This functionality is intended to be expanded over time as more surface\n //! area for macro authors is stabilized.\n //!\n-//! See [the book](../book/procedural-macros.html) for more.\n+//! See [the book](../book/first-edition/procedural-macros.html) for more.\n \n #![crate_name = \"proc_macro\"]\n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]"}, {"sha": "a60db3136797a5c646b9bb73bb4640639e5d5589", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+build = \"build.rs\"\n+name = \"profiler_builtins\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"profiler_builtins\"\n+path = \"lib.rs\"\n+test = false\n+bench = false\n+doc = false\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+\n+[build-dependencies]\n+gcc = \"0.3.50\""}, {"sha": "1ee284ff4dabffb38150401b1b99122fa3e820f3", "filename": "src/libprofiler_builtins/build.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Compiles the profiler part of the `compiler-rt` library.\n+//!\n+//! See the build.rs for libcompiler_builtins crate for details.\n+\n+extern crate gcc;\n+\n+use std::env;\n+use std::path::Path;\n+\n+fn main() {\n+    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n+    let cfg = &mut gcc::Config::new();\n+\n+    let mut profile_sources = vec![\"GCDAProfiling.c\",\n+                                   \"InstrProfiling.c\",\n+                                   \"InstrProfilingBuffer.c\",\n+                                   \"InstrProfilingFile.c\",\n+                                   \"InstrProfilingMerge.c\",\n+                                   \"InstrProfilingMergeFile.c\",\n+                                   \"InstrProfilingPlatformDarwin.c\",\n+                                   \"InstrProfilingPlatformLinux.c\",\n+                                   \"InstrProfilingPlatformOther.c\",\n+                                   \"InstrProfilingRuntime.cc\",\n+                                   \"InstrProfilingUtil.c\",\n+                                   \"InstrProfilingValue.c\",\n+                                   \"InstrProfilingWriter.c\"];\n+\n+    if target.contains(\"msvc\") {\n+        // Don't pull in extra libraries on MSVC\n+        cfg.flag(\"/Zl\");\n+        profile_sources.push(\"WindowsMMap.c\");\n+        cfg.define(\"strdup\", Some(\"_strdup\"));\n+        cfg.define(\"open\", Some(\"_open\"));\n+        cfg.define(\"fdopen\", Some(\"_fdopen\"));\n+    } else {\n+        // Turn off various features of gcc and such, mostly copying\n+        // compiler-rt's build system already\n+        cfg.flag(\"-fno-builtin\");\n+        cfg.flag(\"-fvisibility=hidden\");\n+        cfg.flag(\"-fomit-frame-pointer\");\n+        cfg.flag(\"-ffreestanding\");\n+        cfg.define(\"VISIBILITY_HIDDEN\", None);\n+    }\n+\n+    for src in profile_sources {\n+        cfg.file(Path::new(\"../compiler-rt/lib/profile\").join(src));\n+    }\n+\n+    cfg.compile(\"libprofiler-rt.a\");\n+}"}, {"sha": "087cc444185b896cdb7e723b6c7d95120594cdd8", "filename": "src/libprofiler_builtins/lib.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibprofiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibprofiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Flib.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![no_std]\n+#![cfg_attr(not(stage0), feature(profiler_runtime))]\n+#![cfg_attr(not(stage0), profiler_runtime)]\n+#![unstable(feature = \"profiler_runtime_lib\",\n+            reason = \"internal implementation detail of rustc right now\",\n+            issue = \"0\")]\n+#![crate_name = \"profiler_builtins\"]\n+#![crate_type = \"rlib\"]\n+#![allow(unused_features)]\n+#![feature(staged_api)]"}, {"sha": "c747c443b3a4ab76215e96853862963167836e28", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 4, "deletions": 133, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -18,7 +18,7 @@ one of three things:\n 1. HIR nodes (like `Hir(DefId)`) represent the HIR input itself.\n 2. Data nodes (like `ItemSignature(DefId)`) represent some computed\n    information about a particular item.\n-3. Procedure notes (like `CoherenceCheckImpl(DefId)`) represent some\n+3. Procedure nodes (like `CoherenceCheckTrait(DefId)`) represent some\n    procedure that is executing. Usually this procedure is\n    performing some kind of check for errors. You can think of them as\n    computed values where the value being computed is `()` (and the\n@@ -57,139 +57,10 @@ recompile that item for sure. But we need the dep tracking map to tell\n us what *else* we have to recompile. Shared state is anything that is\n used to communicate results from one item to another.\n \n-### Identifying the current task\n+### Identifying the current task, tracking reads/writes, etc\n \n-The dep graph always tracks a current task: this is basically the\n-`DepNode` that the compiler is computing right now. Typically it would\n-be a procedure node, but it can also be a data node (as noted above,\n-the two are kind of equivalent).\n-\n-You set the current task by calling `dep_graph.in_task(node)`. For example:\n-\n-```rust\n-let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n-```\n-\n-Now all the code until `_task` goes out of scope will be considered\n-part of the \"privacy task\".\n-\n-The tasks are maintained in a stack, so it is perfectly fine to nest\n-one task within another. Because pushing a task is considered to be\n-computing a value, when you nest a task `N2` inside of a task `N1`, we\n-automatically add an edge `N2 -> N1` (since `N1` presumably needed the\n-result of `N2` to complete):\n-\n-```rust\n-let _n1 = tcx.dep_graph.in_task(DepNode::N1);\n-let _n2 = tcx.dep_graph.in_task(DepNode::N2);\n-// this will result in an edge N1 -> n2\n-```\n-\n-### Ignore tasks\n-\n-Although it is rarely needed, you can also push a special \"ignore\"\n-task:\n-\n-```rust\n-let _ignore = tc.dep_graph.in_ignore();\n-```\n-\n-This will cause all read/write edges to be ignored until it goes out\n-of scope or until something else is pushed. For example, we could\n-suppress the edge between nested tasks like so:\n-\n-```rust\n-let _n1 = tcx.dep_graph.in_task(DepNode::N1);\n-let _ignore = tcx.dep_graph.in_ignore();\n-let _n2 = tcx.dep_graph.in_task(DepNode::N2);\n-// now no edge is added\n-```\n-\n-### Tracking reads and writes\n-\n-We need to identify what shared state is read/written by the current\n-task as it executes. The most fundamental way of doing that is to invoke\n-the `read` and `write` methods on `DepGraph`:\n-\n-```rust\n-// Adds an edge from DepNode::Hir(some_def_id) to the current task\n-tcx.dep_graph.read(DepNode::Hir(some_def_id))\n-\n-// Adds an edge from the current task to DepNode::ItemSignature(some_def_id)\n-tcx.dep_graph.write(DepNode::ItemSignature(some_def_id))\n-```\n-\n-However, you should rarely need to invoke those methods directly.\n-Instead, the idea is to *encapsulate* shared state into some API that\n-will invoke `read` and `write` automatically. The most common way to\n-do this is to use a `DepTrackingMap`, described in the next section,\n-but any sort of abstraction barrier will do. In general, the strategy\n-is that getting access to information implicitly adds an appropriate\n-`read`. So, for example, when you use the\n-`dep_graph::visit_all_items_in_krate` helper method, it will visit\n-each item `X`, start a task `Foo(X)` for that item, and automatically\n-add an edge `Hir(X) -> Foo(X)`. This edge is added because the code is\n-being given access to the HIR node for `X`, and hence it is expected\n-to read from it. Similarly, reading from the `tcache` map for item `X`\n-(which is a `DepTrackingMap`, described below) automatically invokes\n-`dep_graph.read(ItemSignature(X))`.\n-\n-**Note:** adding `Hir` nodes requires a bit of caution due to the\n-\"inlining\" that old trans and constant evaluation still use. See the\n-section on inlining below.\n-\n-To make this strategy work, a certain amount of indirection is\n-required. For example, modules in the HIR do not have direct pointers\n-to the items that they contain. Rather, they contain node-ids -- one\n-can then ask the HIR map for the item with a given node-id. This gives\n-us an opportunity to add an appropriate read edge.\n-\n-#### Explicit calls to read and write when starting a new subtask\n-\n-One time when you *may* need to call `read` and `write` directly is\n-when you push a new task onto the stack, either by calling `in_task`\n-as shown above or indirectly, such as with the `memoize` pattern\n-described below. In that case, any data that the task has access to\n-from the surrounding environment must be explicitly \"read\". For\n-example, in `librustc_typeck`, the collection code visits all items\n-and, among other things, starts a subtask producing its signature\n-(what follows is simplified pseudocode, of course):\n-\n-```rust\n-fn visit_item(item: &hir::Item) {\n-    // Here, current subtask is \"Collect(X)\", and an edge Hir(X) -> Collect(X)\n-    // has automatically been added by `visit_all_items_in_krate`.\n-    let sig = signature_of_item(item);\n-}\n-\n-fn signature_of_item(item: &hir::Item) {\n-    let def_id = tcx.map.local_def_id(item.id);\n-    let task = tcx.dep_graph.in_task(DepNode::ItemSignature(def_id));\n-    tcx.dep_graph.read(DepNode::Hir(def_id)); // <-- the interesting line\n-    ...\n-}\n-```\n-\n-Here you can see that, in `signature_of_item`, we started a subtask\n-corresponding to producing the `ItemSignature`. This subtask will read from\n-`item` -- but it gained access to `item` implicitly. This means that if it just\n-reads from `item`, there would be missing edges in the graph:\n-\n-    Hir(X) --+ // added by the explicit call to `read`\n-      |      |\n-      |      +---> ItemSignature(X) -> Collect(X)\n-      |                                 ^\n-      |                                 |\n-      +---------------------------------+ // added by `visit_all_items_in_krate`\n-\n-In particular, the edge from `Hir(X)` to `ItemSignature(X)` is only\n-present because we called `read` ourselves when entering the `ItemSignature(X)`\n-task.\n-\n-So, the rule of thumb: when entering a new task yourself, register\n-reads on any shared state that you inherit. (This actually comes up\n-fairly infrequently though: the main place you need caution is around\n-memoization.)\n+FIXME(#42293). This text needs to be rewritten for the new red-green\n+system, which doesn't fully exist yet.\n \n #### Dependency tracking map\n "}, {"sha": "e22552008d5a8578079cf7fd3955081ec715c006", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -12,7 +12,6 @@\n \n use super::dep_node::DepNode;\n use std::error::Error;\n-use std::fmt::Debug;\n \n /// A dep-node filter goes from a user-defined string to a query over\n /// nodes. Right now the format is like this:\n@@ -39,7 +38,7 @@ impl DepNodeFilter {\n     }\n \n     /// Tests whether `node` meets the filter, returning true if so.\n-    pub fn test<D: Clone + Debug>(&self, node: &DepNode<D>) -> bool {\n+    pub fn test(&self, node: &DepNode) -> bool {\n         let debug_str = format!(\"{:?}\", node);\n         self.text.split(\"&\")\n                  .map(|s| s.trim())\n@@ -67,10 +66,10 @@ impl EdgeFilter {\n         }\n     }\n \n-    pub fn test<D: Clone + Debug>(&self,\n-                                  source: &DepNode<D>,\n-                                  target: &DepNode<D>)\n-                                  -> bool {\n+    pub fn test(&self,\n+                source: &DepNode,\n+                target: &DepNode)\n+                -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }"}, {"sha": "92efeb7fd8629acf6f1e68577d8dbff8219804f0", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 555, "deletions": 269, "changes": 824, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -8,80 +8,380 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::CrateNum;\n-use std::fmt::Debug;\n-use std::sync::Arc;\n-\n-macro_rules! try_opt {\n-    ($e:expr) => (\n-        match $e {\n-            Some(r) => r,\n-            None => return None,\n+\n+//! This module defines the `DepNode` type which the compiler uses to represent\n+//! nodes in the dependency graph. A `DepNode` consists of a `DepKind` (which\n+//! specifies the kind of thing it represents, like a piece of HIR, MIR, etc)\n+//! and a `Fingerprint`, a 128 bit hash value the exact meaning of which\n+//! depends on the node's `DepKind`. Together, the kind and the fingerprint\n+//! fully identify a dependency node, even across multiple compilation sessions.\n+//! In other words, the value of the fingerprint does not depend on anything\n+//! that is specific to a given compilation session, like an unpredictable\n+//! interning key (e.g. NodeId, DefId, Symbol) or the numeric value of a\n+//! pointer. The concept behind this could be compared to how git commit hashes\n+//! uniquely identify a given commit and has a few advantages:\n+//!\n+//! * A `DepNode` can simply be serialized to disk and loaded in another session\n+//!   without the need to do any \"rebasing (like we have to do for Spans and\n+//!   NodeIds) or \"retracing\" like we had to do for `DefId` in earlier\n+//!   implementations of the dependency graph.\n+//! * A `Fingerprint` is just a bunch of bits, which allows `DepNode` to\n+//!   implement `Copy`, `Sync`, `Send`, `Freeze`, etc.\n+//! * Since we just have a bit pattern, `DepNode` can be mapped from disk into\n+//!   memory without any post-processing (e.g. \"abomination-style\" pointer\n+//!   reconstruction).\n+//! * Because a `DepNode` is self-contained, we can instantiate `DepNodes` that\n+//!   refer to things that do not exist anymore. In previous implementations\n+//!   `DepNode` contained a `DefId`. A `DepNode` referring to something that\n+//!   had been removed between the previous and the current compilation session\n+//!   could not be instantiated because the current compilation session\n+//!   contained no `DefId` for thing that had been removed.\n+//!\n+//! `DepNode` definition happens in the `define_dep_nodes!()` macro. This macro\n+//! defines the `DepKind` enum and a corresponding `DepConstructor` enum. The\n+//! `DepConstructor` enum links a `DepKind` to the parameters that are needed at\n+//! runtime in order to construct a valid `DepNode` fingerprint.\n+//!\n+//! Because the macro sees what parameters a given `DepKind` requires, it can\n+//! \"infer\" some properties for each kind of `DepNode`:\n+//!\n+//! * Whether a `DepNode` of a given kind has any parameters at all. Some\n+//!   `DepNode`s, like `Krate`, represent global concepts with only one value.\n+//! * Whether it is possible, in principle, to reconstruct a query key from a\n+//!   given `DepNode`. Many `DepKind`s only require a single `DefId` parameter,\n+//!   in which case it is possible to map the node's fingerprint back to the\n+//!   `DefId` it was computed from. In other cases, too much information gets\n+//!   lost during fingerprint computation.\n+//!\n+//! The `DepConstructor` enum, together with `DepNode::new()` ensures that only\n+//! valid `DepNode` instances can be constructed. For example, the API does not\n+//! allow for constructing parameterless `DepNode`s with anything other\n+//! than a zeroed out fingerprint. More generally speaking, it relieves the\n+//! user of the `DepNode` API of having to know how to compute the expected\n+//! fingerprint for a given set of node parameters.\n+\n+use hir::def_id::{CrateNum, DefId};\n+use hir::map::DefPathHash;\n+\n+use ich::Fingerprint;\n+use ty::TyCtxt;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+use ich::StableHashingContext;\n+use std::fmt;\n+use std::hash::Hash;\n+\n+// erase!() just makes tokens go away. It's used to specify which macro argument\n+// is repeated (i.e. which sub-expression of the macro we are in) but don't need\n+// to actually use any of the arguments.\n+macro_rules! erase {\n+    ($x:tt) => ({})\n+}\n+\n+macro_rules! define_dep_nodes {\n+    ($(\n+        $variant:ident $(( $($tuple_arg:tt),* ))*\n+                       $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n+      ,)*\n+    ) => (\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        pub enum DepKind {\n+            $($variant),*\n+        }\n+\n+        impl DepKind {\n+            #[allow(unreachable_code)]\n+            #[inline]\n+            pub fn can_reconstruct_query_key(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            // tuple args\n+                            $({\n+                                return <( $($tuple_arg,)* ) as DepNodeParams>\n+                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n+                            })*\n+\n+                            // struct args\n+                            $({\n+                                return <( $($struct_arg_ty,)* ) as DepNodeParams>\n+                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n+                            })*\n+\n+                            true\n+                        }\n+                    )*\n+                }\n+            }\n+\n+            #[allow(unreachable_code)]\n+            #[inline]\n+            pub fn has_params(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            // tuple args\n+                            $({\n+                                $(erase!($tuple_arg);)*\n+                                return true;\n+                            })*\n+\n+                            // struct args\n+                            $({\n+                                $(erase!($struct_arg_name);)*\n+                                return true;\n+                            })*\n+\n+                            false\n+                        }\n+                    )*\n+                }\n+            }\n+        }\n+\n+        pub enum DepConstructor {\n+            $(\n+                $variant $(( $($tuple_arg),* ))*\n+                         $({ $($struct_arg_name : $struct_arg_ty),* })*\n+            ),*\n         }\n-    )\n+\n+        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        pub struct DepNode {\n+            pub kind: DepKind,\n+            pub hash: Fingerprint,\n+        }\n+\n+        impl DepNode {\n+            #[allow(unreachable_code, non_snake_case)]\n+            pub fn new(tcx: TyCtxt, dep: DepConstructor) -> DepNode {\n+                match dep {\n+                    $(\n+                        DepConstructor :: $variant $(( $($tuple_arg),* ))*\n+                                                   $({ $($struct_arg_name),* })*\n+                            =>\n+                        {\n+                            // tuple args\n+                            $({\n+                                let tupled_args = ( $($tuple_arg,)* );\n+                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n+                                                                         tcx);\n+                                let dep_node = DepNode {\n+                                    kind: DepKind::$variant,\n+                                    hash\n+                                };\n+\n+                                if cfg!(debug_assertions) &&\n+                                   !dep_node.kind.can_reconstruct_query_key() &&\n+                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                {\n+                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                        tupled_args.to_debug_str(tcx)\n+                                    });\n+                                }\n+\n+                                return dep_node;\n+                            })*\n+\n+                            // struct args\n+                            $({\n+                                let tupled_args = ( $($struct_arg_name,)* );\n+                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n+                                                                         tcx);\n+                                let dep_node = DepNode {\n+                                    kind: DepKind::$variant,\n+                                    hash\n+                                };\n+\n+                                if cfg!(debug_assertions) &&\n+                                   !dep_node.kind.can_reconstruct_query_key() &&\n+                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                {\n+                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                        tupled_args.to_debug_str(tcx)\n+                                    });\n+                                }\n+\n+                                return dep_node;\n+                            })*\n+\n+                            DepNode {\n+                                kind: DepKind::$variant,\n+                                hash: Fingerprint::zero(),\n+                            }\n+                        }\n+                    )*\n+                }\n+            }\n+\n+            /// Construct a DepNode from the given DepKind and DefPathHash. This\n+            /// method will assert that the given DepKind actually requires a\n+            /// single DefId/DefPathHash parameter.\n+            #[inline]\n+            pub fn from_def_path_hash(kind: DepKind,\n+                                      def_path_hash: DefPathHash)\n+                                      -> DepNode {\n+                assert!(kind.can_reconstruct_query_key() && kind.has_params());\n+                DepNode {\n+                    kind,\n+                    hash: def_path_hash.0,\n+                }\n+            }\n+\n+            /// Create a new, parameterless DepNode. This method will assert\n+            /// that the DepNode corresponding to the given DepKind actually\n+            /// does not require any parameters.\n+            #[inline]\n+            pub fn new_no_params(kind: DepKind) -> DepNode {\n+                assert!(!kind.has_params());\n+                DepNode {\n+                    kind,\n+                    hash: Fingerprint::zero(),\n+                }\n+            }\n+\n+            /// Extract the DefId corresponding to this DepNode. This will work\n+            /// if two conditions are met:\n+            ///\n+            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+            /// 2. the item that the DefPath refers to exists in the current tcx.\n+            ///\n+            /// Condition (1) is determined by the DepKind variant of the\n+            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+            /// refers to something from the previous compilation session that\n+            /// has been removed.\n+            #[inline]\n+            pub fn extract_def_id(&self, tcx: TyCtxt) -> Option<DefId> {\n+                if self.kind.can_reconstruct_query_key() {\n+                    let def_path_hash = DefPathHash(self.hash);\n+                    if let Some(ref def_path_map) = tcx.def_path_hash_to_def_id.as_ref() {\n+                        def_path_map.get(&def_path_hash).cloned()\n+                    } else {\n+                       None\n+                    }\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            /// Used in testing\n+            pub fn from_label_string(label: &str,\n+                                     def_path_hash: DefPathHash)\n+                                     -> Result<DepNode, ()> {\n+                let kind = match label {\n+                    $(\n+                        stringify!($variant) => DepKind::$variant,\n+                    )*\n+                    _ => return Err(()),\n+                };\n+\n+                if !kind.can_reconstruct_query_key() {\n+                    return Err(());\n+                }\n+\n+                if kind.has_params() {\n+                    Ok(def_path_hash.to_dep_node(kind))\n+                } else {\n+                    Ok(DepNode::new_no_params(kind))\n+                }\n+            }\n+        }\n+    );\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub enum DepNode<D: Clone + Debug> {\n-    // The `D` type is \"how definitions are identified\".\n-    // During compilation, it is always `DefId`, but when serializing\n-    // it is mapped to `DefPath`.\n-\n-    /// Represents the `Krate` as a whole (the `hir::Krate` value) (as\n-    /// distinct from the krate module). This is basically a hash of\n-    /// the entire krate, so if you read from `Krate` (e.g., by calling\n-    /// `tcx.hir.krate()`), we will have to assume that any change\n-    /// means that you need to be recompiled. This is because the\n-    /// `Krate` value gives you access to all other items. To avoid\n-    /// this fate, do not call `tcx.hir.krate()`; instead, prefer\n-    /// wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n-    /// suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n-    /// access to the krate, but you must remember to add suitable\n-    /// edges yourself for the individual items that you read.\n-    Krate,\n+impl fmt::Debug for DepNode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind)?;\n+\n+        if !self.kind.has_params() {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"(\")?;\n+\n+        ::ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_id) = self.extract_def_id(tcx) {\n+                    write!(f, \"{}\", tcx.item_path_str(def_id))?;\n+                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n+                    write!(f, \"{}\", s)?;\n+                } else {\n+                    write!(f, \"{:?}\", self.hash)?;\n+                }\n+            } else {\n+                write!(f, \"{:?}\", self.hash)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        write!(f, \")\")\n+    }\n+}\n+\n+\n+impl DefPathHash {\n+    #[inline]\n+    pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n+        DepNode::from_def_path_hash(kind, self)\n+    }\n+}\n+\n+impl DefId {\n+    #[inline]\n+    pub fn to_dep_node(self, tcx: TyCtxt, kind: DepKind) -> DepNode {\n+        DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n+    }\n+}\n \n-    /// Represents the HIR node with the given node-id\n-    Hir(D),\n+define_dep_nodes!(\n+    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n+    // distinct from the krate module). This is basically a hash of\n+    // the entire krate, so if you read from `Krate` (e.g., by calling\n+    // `tcx.hir.krate()`), we will have to assume that any change\n+    // means that you need to be recompiled. This is because the\n+    // `Krate` value gives you access to all other items. To avoid\n+    // this fate, do not call `tcx.hir.krate()`; instead, prefer\n+    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n+    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n+    // access to the krate, but you must remember to add suitable\n+    // edges yourself for the individual items that you read.\n+    Krate,\n \n-    /// Represents the body of a function or method. The def-id is that of the\n-    /// function/method.\n-    HirBody(D),\n+    // Represents the HIR node with the given node-id\n+    Hir(DefId),\n \n-    /// Represents the metadata for a given HIR node, typically found\n-    /// in an extern crate.\n-    MetaData(D),\n+    // Represents the body of a function or method. The def-id is that of the\n+    // function/method.\n+    HirBody(DefId),\n \n-    /// Represents some piece of metadata global to its crate.\n-    GlobalMetaData(D, GlobalMetaDataKind),\n+    // Represents the metadata for a given HIR node, typically found\n+    // in an extern crate.\n+    MetaData(DefId),\n \n-    /// Represents some artifact that we save to disk. Note that these\n-    /// do not have a def-id as part of their identifier.\n-    WorkProduct(Arc<WorkProductId>),\n+    // Represents some artifact that we save to disk. Note that these\n+    // do not have a def-id as part of their identifier.\n+    WorkProduct(WorkProductId),\n \n     // Represents different phases in the compiler.\n-    RegionMaps(D),\n+    RegionMaps(DefId),\n     Coherence,\n     Resolve,\n-    CoherenceCheckTrait(D),\n-    CoherenceCheckImpl(D),\n-    CoherenceOverlapCheck(D),\n-    CoherenceOverlapCheckSpecial(D),\n-    Variance,\n+    CoherenceCheckTrait(DefId),\n     PrivacyAccessLevels(CrateNum),\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR.\n-    MirKrate,\n-    Mir(D),\n-    MirShim(Vec<D>),\n+    Mir(DefId),\n+    MirShim(DefIdList),\n \n     BorrowCheckKrate,\n-    BorrowCheck(D),\n-    RvalueCheck(D),\n+    BorrowCheck(DefId),\n+    RvalueCheck(DefId),\n     Reachability,\n     MirKeys,\n-    LateLintCheck,\n-    TransCrateItem(D),\n     TransWriteMetadata,\n     CrateVariances,\n \n@@ -90,38 +390,38 @@ pub enum DepNode<D: Clone + Debug> {\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n     // predicates for an item wind up in `ItemSignature`).\n-    AssociatedItems(D),\n-    ItemSignature(D),\n-    ItemVarianceConstraints(D),\n-    ItemVariances(D),\n-    IsForeignItem(D),\n-    TypeParamPredicates((D, D)),\n-    SizedConstraint(D),\n-    DtorckConstraint(D),\n-    AdtDestructor(D),\n-    AssociatedItemDefIds(D),\n-    InherentImpls(D),\n+    AssociatedItems(DefId),\n+    ItemSignature(DefId),\n+    ItemVarianceConstraints(DefId),\n+    ItemVariances(DefId),\n+    IsConstFn(DefId),\n+    IsForeignItem(DefId),\n+    TypeParamPredicates { item_id: DefId, param_id: DefId },\n+    SizedConstraint(DefId),\n+    DtorckConstraint(DefId),\n+    AdtDestructor(DefId),\n+    AssociatedItemDefIds(DefId),\n+    InherentImpls(DefId),\n     TypeckBodiesKrate,\n-    TypeckTables(D),\n-    UsedTraitImports(D),\n-    ConstEval(D),\n-    SymbolName(D),\n-    SpecializationGraph(D),\n-    ObjectSafety(D),\n-    IsCopy(D),\n-    IsSized(D),\n-    IsFreeze(D),\n-    NeedsDrop(D),\n-    Layout(D),\n-\n-    /// The set of impls for a given trait. Ultimately, it would be\n-    /// nice to get more fine-grained here (e.g., to include a\n-    /// simplified type), but we can't do that until we restructure the\n-    /// HIR to distinguish the *header* of an impl from its body.  This\n-    /// is because changes to the header may change the self-type of\n-    /// the impl and hence would require us to be more conservative\n-    /// than changes in the impl body.\n-    TraitImpls(D),\n+    TypeckTables(DefId),\n+    ConstEval(DefId),\n+    SymbolName(DefId),\n+    SpecializationGraph(DefId),\n+    ObjectSafety(DefId),\n+    IsCopy(DefId),\n+    IsSized(DefId),\n+    IsFreeze(DefId),\n+    NeedsDrop(DefId),\n+    Layout(DefId),\n+\n+    // The set of impls for a given trait. Ultimately, it would be\n+    // nice to get more fine-grained here (e.g., to include a\n+    // simplified type), but we can't do that until we restructure the\n+    // HIR to distinguish the *header* of an impl from its body.  This\n+    // is because changes to the header may change the self-type of\n+    // the impl and hence would require us to be more conservative\n+    // than changes in the impl body.\n+    TraitImpls(DefId),\n \n     AllLocalTraitImpls,\n \n@@ -130,185 +430,151 @@ pub enum DepNode<D: Clone + Debug> {\n     // Otherwise the write into the map would be incorrectly\n     // attributed to the first task that happened to fill the cache,\n     // which would yield an overly conservative dep-graph.\n-    TraitItems(D),\n-    ReprHints(D),\n-\n-    /// Trait selection cache is a little funny. Given a trait\n-    /// reference like `Foo: SomeTrait<Bar>`, there could be\n-    /// arbitrarily many def-ids to map on in there (e.g., `Foo`,\n-    /// `SomeTrait`, `Bar`). We could have a vector of them, but it\n-    /// requires heap-allocation, and trait sel in general can be a\n-    /// surprisingly hot path. So instead we pick two def-ids: the\n-    /// trait def-id, and the first def-id in the input types. If there\n-    /// is no def-id in the input types, then we use the trait def-id\n-    /// again. So for example:\n-    ///\n-    /// - `i32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    /// - `u32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    /// - `Clone: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    /// - `Vec<i32>: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Vec }`\n-    /// - `String: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: String }`\n-    /// - `Foo: Trait<Bar>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    /// - `Foo: Trait<i32>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    /// - `(Foo, Bar): Trait` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    /// - `i32: Trait<Foo>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    ///\n-    /// You can see that we map many trait refs to the same\n-    /// trait-select node.  This is not a problem, it just means\n-    /// imprecision in our dep-graph tracking.  The important thing is\n-    /// that for any given trait-ref, we always map to the **same**\n-    /// trait-select node.\n-    TraitSelect { trait_def_id: D, input_def_id: D },\n-\n-    /// For proj. cache, we just keep a list of all def-ids, since it is\n-    /// not a hotspot.\n-    ProjectionCache { def_ids: Vec<D> },\n-\n-    ParamEnv(D),\n-    DescribeDef(D),\n-    DefSpan(D),\n-    Stability(D),\n-    Deprecation(D),\n-    ItemBodyNestedBodies(D),\n-    ConstIsRvaluePromotableToStatic(D),\n-    ImplParent(D),\n-    TraitOfItem(D),\n-    IsExportedSymbol(D),\n-    IsMirAvailable(D),\n-    ItemAttrs(D),\n-    FnArgNames(D),\n+    TraitItems(DefId),\n+    ReprHints(DefId),\n+\n+    // Trait selection cache is a little funny. Given a trait\n+    // reference like `Foo: SomeTrait<Bar>`, there could be\n+    // arbitrarily many def-ids to map on in there (e.g., `Foo`,\n+    // `SomeTrait`, `Bar`). We could have a vector of them, but it\n+    // requires heap-allocation, and trait sel in general can be a\n+    // surprisingly hot path. So instead we pick two def-ids: the\n+    // trait def-id, and the first def-id in the input types. If there\n+    // is no def-id in the input types, then we use the trait def-id\n+    // again. So for example:\n+    //\n+    // - `i32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `u32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Clone: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Vec<i32>: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Vec }`\n+    // - `String: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: String }`\n+    // - `Foo: Trait<Bar>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `Foo: Trait<i32>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `(Foo, Bar): Trait` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `i32: Trait<Foo>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    //\n+    // You can see that we map many trait refs to the same\n+    // trait-select node.  This is not a problem, it just means\n+    // imprecision in our dep-graph tracking.  The important thing is\n+    // that for any given trait-ref, we always map to the **same**\n+    // trait-select node.\n+    TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n+\n+    // For proj. cache, we just keep a list of all def-ids, since it is\n+    // not a hotspot.\n+    ProjectionCache { def_ids: DefIdList },\n+\n+    ParamEnv(DefId),\n+    DescribeDef(DefId),\n+    DefSpan(DefId),\n+    Stability(DefId),\n+    Deprecation(DefId),\n+    ItemBodyNestedBodies(DefId),\n+    ConstIsRvaluePromotableToStatic(DefId),\n+    ImplParent(DefId),\n+    TraitOfItem(DefId),\n+    IsExportedSymbol(DefId),\n+    IsMirAvailable(DefId),\n+    ItemAttrs(DefId),\n+    FnArgNames(DefId),\n+    DylibDepFormats(DefId),\n+    IsAllocator(DefId),\n+    IsPanicRuntime(DefId),\n+    ExternCrate(DefId),\n+);\n+\n+trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n+    fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint;\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String;\n }\n \n-impl<D: Clone + Debug> DepNode<D> {\n-    /// Used in testing\n-    pub fn from_label_string(label: &str, data: D) -> Result<DepNode<D>, ()> {\n-        macro_rules! check {\n-            ($($name:ident,)*) => {\n-                match label {\n-                    $(stringify!($name) => Ok(DepNode::$name(data)),)*\n-                    _ => Err(())\n-                }\n-            }\n-        }\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + fmt::Debug\n+{\n+    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n-        if label == \"Krate\" {\n-            // special case\n-            return Ok(DepNode::Krate);\n-        }\n+    default fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+        let mut hcx = StableHashingContext::new(tcx);\n+        let mut hasher = StableHasher::new();\n+\n+        self.hash_stable(&mut hcx, &mut hasher);\n \n-        check! {\n-            BorrowCheck,\n-            Hir,\n-            HirBody,\n-            TransCrateItem,\n-            AssociatedItems,\n-            ItemSignature,\n-            ItemVariances,\n-            IsForeignItem,\n-            AssociatedItemDefIds,\n-            InherentImpls,\n-            TypeckTables,\n-            UsedTraitImports,\n-            TraitImpls,\n-            ReprHints,\n+        hasher.finish()\n+    }\n+\n+    default fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        tcx.def_path_hash(self.0).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        tcx.item_path_str(self.0)\n+    }\n+}\n+\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    // We actually would not need to specialize the implementation of this\n+    // method but it's faster to combine the hashes than to instantiate a full\n+    // hashing context and stable-hashing state.\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let (def_id_0, def_id_1) = *self;\n+\n+        let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n+        let def_path_hash_1 = tcx.def_path_hash(def_id_1);\n+\n+        def_path_hash_0.0.combine(def_path_hash_1.0)\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        let (def_id_0, def_id_1) = *self;\n+\n+        format!(\"({}, {})\",\n+                tcx.def_path(def_id_0).to_string(tcx),\n+                tcx.def_path(def_id_1).to_string(tcx))\n+    }\n+}\n+\n+\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIdList,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    // We actually would not need to specialize the implementation of this\n+    // method but it's faster to combine the hashes than to instantiate a full\n+    // hashing context and stable-hashing state.\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let mut fingerprint = Fingerprint::zero();\n+\n+        for &def_id in self.0.iter() {\n+            let def_path_hash = tcx.def_path_hash(def_id);\n+            fingerprint = fingerprint.combine(def_path_hash.0);\n         }\n+\n+        fingerprint\n     }\n \n-    pub fn map_def<E, OP>(&self, mut op: OP) -> Option<DepNode<E>>\n-        where OP: FnMut(&D) -> Option<E>, E: Clone + Debug\n-    {\n-        use self::DepNode::*;\n-\n-        match *self {\n-            Krate => Some(Krate),\n-            BorrowCheckKrate => Some(BorrowCheckKrate),\n-            MirKrate => Some(MirKrate),\n-            TypeckBodiesKrate => Some(TypeckBodiesKrate),\n-            Coherence => Some(Coherence),\n-            CrateVariances => Some(CrateVariances),\n-            Resolve => Some(Resolve),\n-            Variance => Some(Variance),\n-            PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n-            Reachability => Some(Reachability),\n-            MirKeys => Some(MirKeys),\n-            LateLintCheck => Some(LateLintCheck),\n-            TransWriteMetadata => Some(TransWriteMetadata),\n-\n-            // work product names do not need to be mapped, because\n-            // they are always absolute.\n-            WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n-\n-            IsCopy(ref d) => op(d).map(IsCopy),\n-            IsSized(ref d) => op(d).map(IsSized),\n-            IsFreeze(ref d) => op(d).map(IsFreeze),\n-            NeedsDrop(ref d) => op(d).map(NeedsDrop),\n-            Layout(ref d) => op(d).map(Layout),\n-            Hir(ref d) => op(d).map(Hir),\n-            HirBody(ref d) => op(d).map(HirBody),\n-            MetaData(ref d) => op(d).map(MetaData),\n-            CoherenceCheckTrait(ref d) => op(d).map(CoherenceCheckTrait),\n-            CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n-            CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n-            CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n-            Mir(ref d) => op(d).map(Mir),\n-            MirShim(ref def_ids) => {\n-                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n-                def_ids.map(MirShim)\n-            }\n-            BorrowCheck(ref d) => op(d).map(BorrowCheck),\n-            RegionMaps(ref d) => op(d).map(RegionMaps),\n-            RvalueCheck(ref d) => op(d).map(RvalueCheck),\n-            TransCrateItem(ref d) => op(d).map(TransCrateItem),\n-            AssociatedItems(ref d) => op(d).map(AssociatedItems),\n-            ItemSignature(ref d) => op(d).map(ItemSignature),\n-            ItemVariances(ref d) => op(d).map(ItemVariances),\n-            ItemVarianceConstraints(ref d) => op(d).map(ItemVarianceConstraints),\n-            IsForeignItem(ref d) => op(d).map(IsForeignItem),\n-            TypeParamPredicates((ref item, ref param)) => {\n-                Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n-            }\n-            SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            DtorckConstraint(ref d) => op(d).map(DtorckConstraint),\n-            AdtDestructor(ref d) => op(d).map(AdtDestructor),\n-            AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n-            InherentImpls(ref d) => op(d).map(InherentImpls),\n-            TypeckTables(ref d) => op(d).map(TypeckTables),\n-            UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n-            ConstEval(ref d) => op(d).map(ConstEval),\n-            SymbolName(ref d) => op(d).map(SymbolName),\n-            SpecializationGraph(ref d) => op(d).map(SpecializationGraph),\n-            ObjectSafety(ref d) => op(d).map(ObjectSafety),\n-            TraitImpls(ref d) => op(d).map(TraitImpls),\n-            AllLocalTraitImpls => Some(AllLocalTraitImpls),\n-            TraitItems(ref d) => op(d).map(TraitItems),\n-            ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect { ref trait_def_id, ref input_def_id } => {\n-                op(trait_def_id).and_then(|trait_def_id| {\n-                    op(input_def_id).and_then(|input_def_id| {\n-                        Some(TraitSelect { trait_def_id: trait_def_id,\n-                                           input_def_id: input_def_id })\n-                    })\n-                })\n-            }\n-            ProjectionCache { ref def_ids } => {\n-                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n-                def_ids.map(|d| ProjectionCache { def_ids: d })\n-            }\n-            ParamEnv(ref d) => op(d).map(ParamEnv),\n-            DescribeDef(ref d) => op(d).map(DescribeDef),\n-            DefSpan(ref d) => op(d).map(DefSpan),\n-            Stability(ref d) => op(d).map(Stability),\n-            Deprecation(ref d) => op(d).map(Deprecation),\n-            ItemAttrs(ref d) => op(d).map(ItemAttrs),\n-            FnArgNames(ref d) => op(d).map(FnArgNames),\n-            ImplParent(ref d) => op(d).map(ImplParent),\n-            TraitOfItem(ref d) => op(d).map(TraitOfItem),\n-            IsExportedSymbol(ref d) => op(d).map(IsExportedSymbol),\n-            ItemBodyNestedBodies(ref d) => op(d).map(ItemBodyNestedBodies),\n-            ConstIsRvaluePromotableToStatic(ref d) => op(d).map(ConstIsRvaluePromotableToStatic),\n-            IsMirAvailable(ref d) => op(d).map(IsMirAvailable),\n-            GlobalMetaData(ref d, kind) => op(d).map(|d| GlobalMetaData(d, kind)),\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        use std::fmt::Write;\n+\n+        let mut s = String::new();\n+        write!(&mut s, \"[\").unwrap();\n+\n+        for &def_id in self.0.iter() {\n+            write!(&mut s, \"{}\", tcx.def_path(def_id).to_string(tcx)).unwrap();\n         }\n+\n+        write!(&mut s, \"]\").unwrap();\n+\n+        s\n     }\n }\n \n@@ -317,18 +583,38 @@ impl<D: Clone + Debug> DepNode<D> {\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct WorkProductId(pub String);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable)]\n+pub struct WorkProductId {\n+    hash: Fingerprint\n+}\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub enum GlobalMetaDataKind {\n-    Krate,\n-    CrateDeps,\n-    DylibDependencyFormats,\n-    LangItems,\n-    LangItemsMissing,\n-    NativeLibraries,\n-    CodeMap,\n-    Impls,\n-    ExportedSymbols,\n+impl WorkProductId {\n+    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n+        let mut hasher = StableHasher::new();\n+        cgu_name.len().hash(&mut hasher);\n+        cgu_name.hash(&mut hasher);\n+        WorkProductId {\n+            hash: hasher.finish()\n+        }\n+    }\n+\n+    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n+        WorkProductId {\n+            hash: fingerprint\n+        }\n+    }\n+\n+    pub fn to_dep_node(self) -> DepNode {\n+        DepNode {\n+            kind: DepKind::WorkProduct,\n+            hash: self.hash,\n+        }\n+    }\n }\n+\n+impl_stable_hash_for!(struct ::dep_graph::WorkProductId {\n+    hash\n+});\n+\n+type DefIdList = Vec<DefId>;"}, {"sha": "43f8d6b938dab68ef582571879e817a87c0079a3", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n-use std::ops::Index;\n use std::hash::Hash;\n use std::marker::PhantomData;\n+use ty::TyCtxt;\n use util::common::MemoizationMap;\n \n use super::{DepNode, DepGraph};\n@@ -30,7 +29,7 @@ pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n pub trait DepTrackingMapConfig {\n     type Key: Eq + Hash + Clone;\n     type Value: Clone;\n-    fn to_dep_node(key: &Self::Key) -> DepNode<DefId>;\n+    fn to_dep_node(tcx: TyCtxt, key: &Self::Key) -> DepNode;\n }\n \n impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n@@ -44,18 +43,18 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n \n     /// Registers a (synthetic) read from the key `k`. Usually this\n     /// is invoked automatically by `get`.\n-    fn read(&self, k: &M::Key) {\n-        let dep_node = M::to_dep_node(k);\n+    fn read(&self, tcx: TyCtxt, k: &M::Key) {\n+        let dep_node = M::to_dep_node(tcx, k);\n         self.graph.read(dep_node);\n     }\n \n-    pub fn get(&self, k: &M::Key) -> Option<&M::Value> {\n-        self.read(k);\n+    pub fn get(&self, tcx: TyCtxt, k: &M::Key) -> Option<&M::Value> {\n+        self.read(tcx, k);\n         self.map.get(k)\n     }\n \n-    pub fn contains_key(&self, k: &M::Key) -> bool {\n-        self.read(k);\n+    pub fn contains_key(&self, tcx: TyCtxt, k: &M::Key) -> bool {\n+        self.read(tcx, k);\n         self.map.contains_key(k)\n     }\n \n@@ -99,32 +98,22 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// The key is the line marked `(*)`: the closure implicitly\n     /// accesses the body of the item `item`, so we register a read\n     /// from `Hir(item_def_id)`.\n-    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n+    fn memoize<OP>(&self, tcx: TyCtxt, key: M::Key, op: OP) -> M::Value\n         where OP: FnOnce() -> M::Value\n     {\n         let graph;\n         {\n             let this = self.borrow();\n             if let Some(result) = this.map.get(&key) {\n-                this.read(&key);\n+                this.read(tcx, &key);\n                 return result.clone();\n             }\n             graph = this.graph.clone();\n         }\n \n-        let _task = graph.in_task(M::to_dep_node(&key));\n+        let _task = graph.in_task(M::to_dep_node(tcx, &key));\n         let result = op();\n         self.borrow_mut().map.insert(key, result.clone());\n         result\n     }\n }\n-\n-impl<'k, M: DepTrackingMapConfig> Index<&'k M::Key> for DepTrackingMap<M> {\n-    type Output = M::Value;\n-\n-    #[inline]\n-    fn index(&self, k: &'k M::Key) -> &M::Value {\n-        self.get(k).unwrap()\n-    }\n-}\n-"}, {"sha": "a323e44d0d4271537dd56d7c25c88784fdf1a1ce", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -9,13 +9,11 @@\n // except according to those terms.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use std::fmt::Debug;\n-use std::hash::Hash;\n use super::{DepGraphQuery, DepNode};\n \n-pub struct DepGraphEdges<D: Clone + Debug + Eq + Hash> {\n-    nodes: Vec<DepNode<D>>,\n-    indices: FxHashMap<DepNode<D>, IdIndex>,\n+pub struct DepGraphEdges {\n+    nodes: Vec<DepNode>,\n+    indices: FxHashMap<DepNode, IdIndex>,\n     edges: FxHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n }\n@@ -42,8 +40,8 @@ enum OpenNode {\n     Ignore,\n }\n \n-impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n-    pub fn new() -> DepGraphEdges<D> {\n+impl DepGraphEdges {\n+    pub fn new() -> DepGraphEdges {\n         DepGraphEdges {\n             nodes: vec![],\n             indices: FxHashMap(),\n@@ -52,12 +50,12 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         }\n     }\n \n-    fn id(&self, index: IdIndex) -> DepNode<D> {\n+    fn id(&self, index: IdIndex) -> DepNode {\n         self.nodes[index.index()].clone()\n     }\n \n     /// Creates a node for `id` in the graph.\n-    fn make_node(&mut self, id: DepNode<D>) -> IdIndex {\n+    fn make_node(&mut self, id: DepNode) -> IdIndex {\n         if let Some(&i) = self.indices.get(&id) {\n             return i;\n         }\n@@ -82,7 +80,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         assert_eq!(popped_node, OpenNode::Ignore);\n     }\n \n-    pub fn push_task(&mut self, key: DepNode<D>) {\n+    pub fn push_task(&mut self, key: DepNode) {\n         let top_node = self.current_node();\n \n         let new_node = self.make_node(key);\n@@ -95,7 +93,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         }\n     }\n \n-    pub fn pop_task(&mut self, key: DepNode<D>) {\n+    pub fn pop_task(&mut self, key: DepNode) {\n         let popped_node = self.open_nodes.pop().unwrap();\n         assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n     }\n@@ -105,7 +103,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     /// effect. Note that *reading* from tracked state is harmless if\n     /// you are not in a task; what is bad is *writing* to tracked\n     /// state (and leaking data that you read into a tracked task).\n-    pub fn read(&mut self, v: DepNode<D>) {\n+    pub fn read(&mut self, v: DepNode) {\n         if self.current_node().is_some() {\n             let source = self.make_node(v);\n             self.add_edge_from_current_node(|current| (source, current))\n@@ -115,7 +113,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     /// Indicates that the current task `C` writes `v` by adding an\n     /// edge from `C` to `v`. If there is no current task, panics. If\n     /// you want to suppress this edge, use `ignore`.\n-    pub fn write(&mut self, v: DepNode<D>) {\n+    pub fn write(&mut self, v: DepNode) {\n         let target = self.make_node(v);\n         self.add_edge_from_current_node(|current| (current, target))\n     }\n@@ -159,7 +157,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         }\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<D> {\n+    pub fn query(&self) -> DepGraphQuery {\n         let edges: Vec<_> = self.edges.iter()\n                                       .map(|&(i, j)| (self.id(i), self.id(j)))\n                                       .collect();"}, {"sha": "e48e61d803510468d1c2b622034254246b078e5a", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n-use std::sync::Arc;\n \n use super::dep_node::{DepNode, WorkProductId};\n use super::query::DepGraphQuery;\n@@ -35,10 +33,12 @@ struct DepGraphData {\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n-    previous_work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    previous_work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n \n     /// Work-products that we generate in this run.\n-    work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n+\n+    dep_node_debug: RefCell<FxHashMap<DepNode, String>>,\n }\n \n impl DepGraph {\n@@ -48,6 +48,7 @@ impl DepGraph {\n                 thread: DepGraphThreadData::new(enabled),\n                 previous_work_products: RefCell::new(FxHashMap()),\n                 work_products: RefCell::new(FxHashMap()),\n+                dep_node_debug: RefCell::new(FxHashMap()),\n             })\n         }\n     }\n@@ -58,15 +59,15 @@ impl DepGraph {\n         self.data.thread.is_fully_enabled()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<DefId> {\n+    pub fn query(&self) -> DepGraphQuery {\n         self.data.thread.query()\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n         raii::IgnoreTask::new(&self.data.thread)\n     }\n \n-    pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> Option<raii::DepTask<'graph>> {\n+    pub fn in_task<'graph>(&'graph self, key: DepNode) -> Option<raii::DepTask<'graph>> {\n         raii::DepTask::new(&self.data.thread, key)\n     }\n \n@@ -104,14 +105,14 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [README]: README.md\n-    pub fn with_task<C, A, R>(&self, key: DepNode<DefId>, cx: C, arg: A, task: fn(C, A) -> R) -> R\n+    pub fn with_task<C, A, R>(&self, key: DepNode, cx: C, arg: A, task: fn(C, A) -> R) -> R\n         where C: DepGraphSafe, A: DepGraphSafe\n     {\n         let _task = self.in_task(key);\n         task(cx, arg)\n     }\n \n-    pub fn read(&self, v: DepNode<DefId>) {\n+    pub fn read(&self, v: DepNode) {\n         if self.data.thread.is_enqueue_enabled() {\n             self.data.thread.enqueue(DepMessage::Read(v));\n         }\n@@ -120,7 +121,7 @@ impl DepGraph {\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory).\n-    pub fn insert_previous_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+    pub fn insert_previous_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n         self.data.previous_work_products.borrow_mut()\n                                         .insert(v.clone(), data);\n@@ -129,31 +130,47 @@ impl DepGraph {\n     /// Indicates that we created the given work-product in this run\n     /// for `v`. This record will be preserved and loaded in the next\n     /// run.\n-    pub fn insert_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+    pub fn insert_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_work_product({:?}, {:?})\", v, data);\n         self.data.work_products.borrow_mut()\n                                .insert(v.clone(), data);\n     }\n \n     /// Check whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n-    pub fn previous_work_product(&self, v: &Arc<WorkProductId>) -> Option<WorkProduct> {\n+    pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {\n         self.data.previous_work_products.borrow()\n                                         .get(v)\n                                         .cloned()\n     }\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n-    pub fn work_products(&self) -> Ref<FxHashMap<Arc<WorkProductId>, WorkProduct>> {\n+    pub fn work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n         self.data.work_products.borrow()\n     }\n \n     /// Access the map of work-products created during the cached run. Only\n     /// used during saving of the dep-graph.\n-    pub fn previous_work_products(&self) -> Ref<FxHashMap<Arc<WorkProductId>, WorkProduct>> {\n+    pub fn previous_work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n         self.data.previous_work_products.borrow()\n     }\n+\n+    #[inline(always)]\n+    pub(super) fn register_dep_node_debug_str<F>(&self,\n+                                                 dep_node: DepNode,\n+                                                 debug_str_gen: F)\n+        where F: FnOnce() -> String\n+    {\n+        let mut dep_node_debug = self.data.dep_node_debug.borrow_mut();\n+\n+        dep_node_debug.entry(dep_node)\n+                      .or_insert_with(debug_str_gen);\n+    }\n+\n+    pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n+        self.data.dep_node_debug.borrow().get(&dep_node).cloned()\n+    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the"}, {"sha": "92b05f6a6558ee8bf0678d3ce7b44f447e715286", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -22,10 +22,11 @@ mod thread;\n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n pub use self::dep_node::WorkProductId;\n-pub use self::dep_node::GlobalMetaDataKind;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n pub use self::raii::DepTask;\n+\n+pub use self::dep_node::{DepKind, DepConstructor};"}, {"sha": "116c527bf46d5430d7b88a1a8fff9cfef4df8598", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -10,20 +10,18 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n-use std::fmt::Debug;\n-use std::hash::Hash;\n \n use super::DepNode;\n \n-pub struct DepGraphQuery<D: Clone + Debug + Hash + Eq> {\n-    pub graph: Graph<DepNode<D>, ()>,\n-    pub indices: FxHashMap<DepNode<D>, NodeIndex>,\n+pub struct DepGraphQuery {\n+    pub graph: Graph<DepNode, ()>,\n+    pub indices: FxHashMap<DepNode, NodeIndex>,\n }\n \n-impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n-    pub fn new(nodes: &[DepNode<D>],\n-               edges: &[(DepNode<D>, DepNode<D>)])\n-               -> DepGraphQuery<D> {\n+impl DepGraphQuery {\n+    pub fn new(nodes: &[DepNode],\n+               edges: &[(DepNode, DepNode)])\n+               -> DepGraphQuery {\n         let mut graph = Graph::new();\n         let mut indices = FxHashMap();\n         for node in nodes {\n@@ -43,18 +41,18 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n         }\n     }\n \n-    pub fn contains_node(&self, node: &DepNode<D>) -> bool {\n+    pub fn contains_node(&self, node: &DepNode) -> bool {\n         self.indices.contains_key(&node)\n     }\n \n-    pub fn nodes(&self) -> Vec<&DepNode<D>> {\n+    pub fn nodes(&self) -> Vec<&DepNode> {\n         self.graph.all_nodes()\n                   .iter()\n                   .map(|n| &n.data)\n                   .collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(&DepNode<D>,&DepNode<D>)> {\n+    pub fn edges(&self) -> Vec<(&DepNode,&DepNode)> {\n         self.graph.all_edges()\n                   .iter()\n                   .map(|edge| (edge.source(), edge.target()))\n@@ -63,7 +61,7 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n                   .collect()\n     }\n \n-    fn reachable_nodes(&self, node: &DepNode<D>, direction: Direction) -> Vec<&DepNode<D>> {\n+    fn reachable_nodes(&self, node: &DepNode, direction: Direction) -> Vec<&DepNode> {\n         if let Some(&index) = self.indices.get(node) {\n             self.graph.depth_traverse(index, direction)\n                       .map(|s| self.graph.node_data(s))\n@@ -75,17 +73,17 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n+    pub fn transitive_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n         self.reachable_nodes(node, OUTGOING)\n     }\n \n     /// All nodes that can reach `node`.\n-    pub fn transitive_predecessors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n+    pub fn transitive_predecessors(&self, node: &DepNode) -> Vec<&DepNode> {\n         self.reachable_nodes(node, INCOMING)\n     }\n \n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n+    pub fn immediate_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index)\n                       .map(|s| self.graph.node_data(s))"}, {"sha": "b45f5de802714b1bc1e9518d334585b0f69e5749", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::DefId;\n use super::DepNode;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n pub struct DepTask<'graph> {\n     data: &'graph DepGraphThreadData,\n-    key: Option<DepNode<DefId>>,\n+    key: Option<DepNode>,\n }\n \n impl<'graph> DepTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData, key: DepNode<DefId>)\n+    pub fn new(data: &'graph DepGraphThreadData, key: DepNode)\n                -> Option<DepTask<'graph>> {\n         if data.is_enqueue_enabled() {\n             data.enqueue(DepMessage::PushTask(key.clone()));"}, {"sha": "8808ea5948da8b46669b9b52759b83326db55a28", "filename": "src/librustc/dep_graph/shadow.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -26,7 +26,6 @@\n //! specify an edge filter to be applied to each edge as it is\n //! created.  See `./README.md` for details.\n \n-use hir::def_id::DefId;\n use std::cell::RefCell;\n use std::env;\n \n@@ -36,7 +35,7 @@ use super::debug::EdgeFilter;\n \n pub struct ShadowGraph {\n     // if you push None onto the stack, that corresponds to an Ignore\n-    stack: RefCell<Vec<Option<DepNode<DefId>>>>,\n+    stack: RefCell<Vec<Option<DepNode>>>,\n     forbidden_edge: Option<EdgeFilter>,\n }\n \n@@ -114,8 +113,8 @@ impl ShadowGraph {\n     }\n \n     fn check_edge(&self,\n-                  source: Option<Option<&DepNode<DefId>>>,\n-                  target: Option<Option<&DepNode<DefId>>>) {\n+                  source: Option<Option<&DepNode>>,\n+                  target: Option<Option<&DepNode>>) {\n         assert!(ENABLED);\n         match (source, target) {\n             // cannot happen, one side is always Some(Some(_))\n@@ -141,9 +140,9 @@ impl ShadowGraph {\n \n // Do a little juggling: we get back a reference to an option at the\n // top of the stack, convert it to an optional reference.\n-fn top<'s>(stack: &'s Vec<Option<DepNode<DefId>>>) -> Option<Option<&'s DepNode<DefId>>> {\n+fn top<'s>(stack: &'s Vec<Option<DepNode>>) -> Option<Option<&'s DepNode>> {\n     stack.last()\n-        .map(|n: &'s Option<DepNode<DefId>>| -> Option<&'s DepNode<DefId>> {\n+        .map(|n: &'s Option<DepNode>| -> Option<&'s DepNode> {\n             // (*)\n             // (*) type annotation just there to clarify what would\n             // otherwise be some *really* obscure code"}, {"sha": "ad0abfe26f45f7c6e6a78c9311e5e9dfa0faf71b", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -18,7 +18,6 @@\n //! to accumulate more messages. This way we only ever have two vectors\n //! allocated (and both have a fairly large capacity).\n \n-use hir::def_id::DefId;\n use rustc_data_structures::veccell::VecCell;\n use std::sync::mpsc::{self, Sender, Receiver};\n use std::thread;\n@@ -30,10 +29,10 @@ use super::shadow::ShadowGraph;\n \n #[derive(Debug)]\n pub enum DepMessage {\n-    Read(DepNode<DefId>),\n-    Write(DepNode<DefId>),\n-    PushTask(DepNode<DefId>),\n-    PopTask(DepNode<DefId>),\n+    Read(DepNode),\n+    Write(DepNode),\n+    PushTask(DepNode),\n+    PopTask(DepNode),\n     PushIgnore,\n     PopIgnore,\n     Query,\n@@ -63,7 +62,7 @@ pub struct DepGraphThreadData {\n     swap_out: Sender<Vec<DepMessage>>,\n \n     // where to receive query results\n-    query_in: Receiver<DepGraphQuery<DefId>>,\n+    query_in: Receiver<DepGraphQuery>,\n }\n \n const INITIAL_CAPACITY: usize = 2048;\n@@ -120,7 +119,7 @@ impl DepGraphThreadData {\n         self.swap_out.send(old_messages).unwrap();\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<DefId> {\n+    pub fn query(&self) -> DepGraphQuery {\n         assert!(self.is_fully_enabled(), \"should never query if not fully enabled\");\n         self.enqueue(DepMessage::Query);\n         self.swap();\n@@ -151,7 +150,7 @@ impl DepGraphThreadData {\n /// Definition of the depgraph thread.\n pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n             swap_out: Sender<Vec<DepMessage>>,\n-            query_out: Sender<DepGraphQuery<DefId>>) {\n+            query_out: Sender<DepGraphQuery>) {\n     let mut edges = DepGraphEdges::new();\n \n     // the compiler thread always expects a fresh buffer to be"}, {"sha": "28fb96aa203242834cff1125c5bee3dd041c2632", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -405,7 +405,7 @@ impl Quux for Foo { }\n Lifetime elision in implementation headers was part of the lifetime elision\n RFC. It is, however, [currently unimplemented][iss15872].\n \n-[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n+[book-le]: https://doc.rust-lang.org/nightly/book/first-edition/lifetimes.html#lifetime-elision\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n@@ -501,7 +501,7 @@ fn main() {\n }\n ```\n \n-See also https://doc.rust-lang.org/book/unsafe.html\n+See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n \"##,\n \n // This shouldn't really ever trigger since the repeated value error comes first\n@@ -666,7 +666,7 @@ attributes:\n #![no_std]\n ```\n \n-See also https://doc.rust-lang.org/book/no-stdlib.html\n+See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n \"##,\n \n E0261: r##\"\n@@ -1779,7 +1779,7 @@ fn main() {\n ```\n \n To understand better how closures work in Rust, read:\n-https://doc.rust-lang.org/book/closures.html\n+https://doc.rust-lang.org/book/first-edition/closures.html\n \"##,\n \n E0580: r##\""}, {"sha": "3034242b59408dbc8363ace84eb98fa8337c7f96", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! This module implements some validity checks for attributes.\n+//! In particular it verifies that `#[inline]` and `#[repr]` attributes are\n+//! attached to items that actually support them and if there are\n+//! conflicts between multiple such attributes attached to the same\n+//! item.\n+\n use session::Session;\n \n use syntax::ast;\n@@ -40,6 +46,18 @@ struct CheckAttrVisitor<'a> {\n }\n \n impl<'a> CheckAttrVisitor<'a> {\n+    /// Check any attribute.\n+    fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n+        if let Some(name) = attr.name() {\n+            match &*name.as_str() {\n+                \"inline\" => self.check_inline(attr, target),\n+                \"repr\" => self.check_repr(attr, target),\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    /// Check if an `#[inline]` is applied to a function.\n     fn check_inline(&self, attr: &ast::Attribute, target: Target) {\n         if target != Target::Fn {\n             struct_span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\")\n@@ -48,6 +66,7 @@ impl<'a> CheckAttrVisitor<'a> {\n         }\n     }\n \n+    /// Check if an `#[repr]` attr is valid.\n     fn check_repr(&self, attr: &ast::Attribute, target: Target) {\n         let words = match attr.meta_item_list() {\n             Some(words) => words,\n@@ -135,16 +154,6 @@ impl<'a> CheckAttrVisitor<'a> {\n                              \"conflicting packed and align representation hints\").emit();\n         }\n     }\n-\n-    fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n-        if let Some(name) = attr.name() {\n-            match &*name.as_str() {\n-                \"inline\" => self.check_inline(attr, target),\n-                \"repr\" => self.check_repr(attr, target),\n-                _ => (),\n-            }\n-        }\n-    }\n }\n \n impl<'a> Visitor<'a> for CheckAttrVisitor<'a> {"}, {"sha": "95a27f065999c21bf00def7fdcf1acacc2ef5f6d", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -58,6 +58,8 @@ impl CrateNum {\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n+\n+    pub fn as_def_id(&self) -> DefId { DefId { krate: *self, index: CRATE_DEF_INDEX } }\n }\n \n impl fmt::Display for CrateNum {"}, {"sha": "3d77381e2e930020f076cf3ddfd2a58f76071c98", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -2686,7 +2686,7 @@ impl<'a> LoweringContext<'a> {\n         let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n-            let def_path_data = DefPathData::Binding(Ident::with_empty_ctxt(name));\n+            let def_path_data = DefPathData::Binding(name);\n             let def_index = defs\n                 .create_def_with_parent(parent_def, id, def_path_data, REGULAR_SPACE, Mark::root());\n             DefId::local(def_index)"}, {"sha": "7fbefa5788b2608a90a5d0488fe50b9199d7984c", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -15,6 +15,7 @@ use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::symbol::keywords;\n+use syntax::symbol::Symbol;\n \n use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n@@ -103,14 +104,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 DefPathData::Impl,\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.modern()),\n+                DefPathData::TypeNs(i.ident.name),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.modern()),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.name),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.modern()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.modern()),\n+                DefPathData::ValueNs(i.ident.name),\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(ref view_path) => {\n@@ -138,13 +139,13 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.modern()),\n+                                            DefPathData::EnumVariant(v.node.name.name),\n                                             REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n-                                let ident = field.ident.map(Ident::modern)\n-                                    .unwrap_or_else(|| Ident::from_str(&index.to_string()));\n-                                this.create_def(field.id, DefPathData::Field(ident), REGULAR_SPACE);\n+                                let name = field.ident.map(|ident| ident.name)\n+                                    .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n+                                this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -162,9 +163,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n-                        let ident = field.ident.map(Ident::modern)\n-                            .unwrap_or_else(|| Ident::from_str(&index.to_string()));\n-                        this.create_def(field.id, DefPathData::Field(ident), REGULAR_SPACE);\n+                        let name = field.ident.map(|ident| ident.name)\n+                            .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n+                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -175,7 +176,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.modern()),\n+                                  DefPathData::ValueNs(foreign_item.ident.name),\n                                   REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n@@ -186,7 +187,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.ident.modern()),\n+                            DefPathData::TypeParam(ty_param.ident.name),\n                             REGULAR_SPACE);\n         }\n \n@@ -196,8 +197,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.modern()),\n-            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.modern()),\n+                DefPathData::ValueNs(ti.ident.name),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n@@ -214,8 +215,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.modern()),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.modern()),\n+                DefPathData::ValueNs(ii.ident.name),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n@@ -236,7 +237,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n             PatKind::Ident(_, id, _) => {\n                 let def = self.create_def(pat.id,\n-                                          DefPathData::Binding(id.node.modern()),\n+                                          DefPathData::Binding(id.node.name),\n                                           REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n@@ -281,7 +282,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n         self.create_def(def.lifetime.id,\n-                        DefPathData::LifetimeDef(def.lifetime.ident.modern()),\n+                        DefPathData::LifetimeDef(def.lifetime.ident.name),\n                         REGULAR_SPACE);\n     }\n "}, {"sha": "c969aef675ff9e0a162ad8410cc074d80da72625", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 163, "deletions": 64, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -15,16 +15,17 @@\n //! expressions) that are mostly just leftovers.\n \n use hir;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n+                  CRATE_DEF_INDEX};\n use ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::Hash;\n-use syntax::ast::{self, Ident};\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ast;\n+use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n@@ -247,7 +248,39 @@ impl DefKey {\n         // and the special \"root_parent\" below.\n         0u8.hash(&mut hasher);\n         parent_hash.hash(&mut hasher);\n-        self.disambiguated_data.hash(&mut hasher);\n+\n+        let DisambiguatedDefPathData {\n+            ref data,\n+            disambiguator,\n+        } = self.disambiguated_data;\n+\n+        ::std::mem::discriminant(data).hash(&mut hasher);\n+        match *data {\n+            DefPathData::TypeNs(name) |\n+            DefPathData::ValueNs(name) |\n+            DefPathData::Module(name) |\n+            DefPathData::MacroDef(name) |\n+            DefPathData::TypeParam(name) |\n+            DefPathData::LifetimeDef(name) |\n+            DefPathData::EnumVariant(name) |\n+            DefPathData::Binding(name) |\n+            DefPathData::Field(name) |\n+            DefPathData::GlobalMetaData(name) => {\n+                (*name.as_str()).hash(&mut hasher);\n+            }\n+\n+            DefPathData::Impl |\n+            DefPathData::CrateRoot |\n+            DefPathData::Misc |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor |\n+            DefPathData::Initializer |\n+            DefPathData::ImplTrait |\n+            DefPathData::Typeof => {}\n+        };\n+\n+        disambiguator.hash(&mut hasher);\n+\n         DefPathHash(hasher.finish())\n     }\n \n@@ -353,7 +386,7 @@ impl DefPath {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n@@ -367,35 +400,40 @@ pub enum DefPathData {\n     /// An impl\n     Impl,\n     /// Something in the type NS\n-    TypeNs(Ident),\n+    TypeNs(Symbol),\n     /// Something in the value NS\n-    ValueNs(Ident),\n+    ValueNs(Symbol),\n     /// A module declaration\n-    Module(Ident),\n+    Module(Symbol),\n     /// A macro rule\n-    MacroDef(Ident),\n+    MacroDef(Symbol),\n     /// A closure expression\n     ClosureExpr,\n \n     // Subportions of items\n     /// A type parameter (generic parameter)\n-    TypeParam(Ident),\n+    TypeParam(Symbol),\n     /// A lifetime definition\n-    LifetimeDef(Ident),\n+    LifetimeDef(Symbol),\n     /// A variant of a enum\n-    EnumVariant(Ident),\n+    EnumVariant(Symbol),\n     /// A struct field\n-    Field(Ident),\n+    Field(Symbol),\n     /// Implicit ctor for a tuple-like struct\n     StructCtor,\n     /// Initializer for a const\n     Initializer,\n     /// Pattern binding\n-    Binding(Ident),\n+    Binding(Symbol),\n     /// An `impl Trait` type node.\n     ImplTrait,\n     /// A `typeof` type node.\n     Typeof,\n+\n+    /// GlobalMetaData identifies a piece of crate metadata that is global to\n+    /// a whole crate (as opposed to just one item). GlobalMetaData components\n+    /// are only supposed to show up right below the crate root.\n+    GlobalMetaData(Symbol)\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -427,8 +465,8 @@ impl Definitions {\n \n     /// Get the number of definitions.\n     pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n-        (self.def_index_to_node[DefIndexAddressSpace::Low.index()].len(),\n-         self.def_index_to_node[DefIndexAddressSpace::High.index()].len())\n+        (self.table.index_to_key[DefIndexAddressSpace::Low.index()].len(),\n+         self.table.index_to_key[DefIndexAddressSpace::High.index()].len())\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n@@ -469,7 +507,12 @@ impl Definitions {\n         if def_id.krate == LOCAL_CRATE {\n             let space_index = def_id.index.address_space().index();\n             let array_index = def_id.index.as_array_index();\n-            Some(self.def_index_to_node[space_index][array_index])\n+            let node_id = self.def_index_to_node[space_index][array_index];\n+            if node_id != ast::DUMMY_NODE_ID {\n+                Some(node_id)\n+            } else {\n+                None\n+            }\n         } else {\n             None\n         }\n@@ -498,12 +541,16 @@ impl Definitions {\n \n         // Create the definition.\n         let address_space = super::ITEM_LIKE_SPACE;\n-        let index = self.table.allocate(key, def_path_hash, address_space);\n+        let root_index = self.table.allocate(key, def_path_hash, address_space);\n+        assert_eq!(root_index, CRATE_DEF_INDEX);\n         assert!(self.def_index_to_node[address_space.index()].is_empty());\n         self.def_index_to_node[address_space.index()].push(ast::CRATE_NODE_ID);\n-        self.node_to_def_index.insert(ast::CRATE_NODE_ID, index);\n+        self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n \n-        index\n+        // Allocate some other DefIndices that always must exist.\n+        GlobalMetaDataKind::allocate_def_indices(self);\n+\n+        root_index\n     }\n \n     /// Add a definition with a parent definition.\n@@ -550,13 +597,19 @@ impl Definitions {\n         assert_eq!(index.as_array_index(),\n                    self.def_index_to_node[address_space.index()].len());\n         self.def_index_to_node[address_space.index()].push(node_id);\n+\n+        // Some things for which we allocate DefIndices don't correspond to\n+        // anything in the AST, so they don't have a NodeId. For these cases\n+        // we don't need a mapping from NodeId to DefIndex.\n+        if node_id != ast::DUMMY_NODE_ID {\n+            debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n+            self.node_to_def_index.insert(node_id, index);\n+        }\n+\n         if expansion.is_modern() {\n             self.expansions.insert(index, expansion);\n         }\n \n-        debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n-        self.node_to_def_index.insert(node_id, index);\n-\n         index\n     }\n \n@@ -583,18 +636,19 @@ impl Definitions {\n }\n \n impl DefPathData {\n-    pub fn get_opt_ident(&self) -> Option<Ident> {\n+    pub fn get_opt_name(&self) -> Option<Symbol> {\n         use self::DefPathData::*;\n         match *self {\n-            TypeNs(ident) |\n-            ValueNs(ident) |\n-            Module(ident) |\n-            MacroDef(ident) |\n-            TypeParam(ident) |\n-            LifetimeDef(ident) |\n-            EnumVariant(ident) |\n-            Binding(ident) |\n-            Field(ident) => Some(ident),\n+            TypeNs(name) |\n+            ValueNs(name) |\n+            Module(name) |\n+            MacroDef(name) |\n+            TypeParam(name) |\n+            LifetimeDef(name) |\n+            EnumVariant(name) |\n+            Binding(name) |\n+            Field(name) |\n+            GlobalMetaData(name) => Some(name),\n \n             Impl |\n             CrateRoot |\n@@ -607,23 +661,20 @@ impl DefPathData {\n         }\n     }\n \n-    pub fn get_opt_name(&self) -> Option<ast::Name> {\n-        self.get_opt_ident().map(|ident| ident.name)\n-    }\n-\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         let s = match *self {\n-            TypeNs(ident) |\n-            ValueNs(ident) |\n-            Module(ident) |\n-            MacroDef(ident) |\n-            TypeParam(ident) |\n-            LifetimeDef(ident) |\n-            EnumVariant(ident) |\n-            Binding(ident) |\n-            Field(ident) => {\n-                return ident.name.as_str();\n+            TypeNs(name) |\n+            ValueNs(name) |\n+            Module(name) |\n+            MacroDef(name) |\n+            TypeParam(name) |\n+            LifetimeDef(name) |\n+            EnumVariant(name) |\n+            Binding(name) |\n+            Field(name) |\n+            GlobalMetaData(name) => {\n+                return name.as_str();\n             }\n \n             // note that this does not show up in user printouts\n@@ -646,24 +697,72 @@ impl DefPathData {\n     }\n }\n \n-impl Eq for DefPathData {}\n-impl PartialEq for DefPathData {\n-    fn eq(&self, other: &DefPathData) -> bool {\n-        ::std::mem::discriminant(self) == ::std::mem::discriminant(other) &&\n-        self.get_opt_ident() == other.get_opt_ident()\n-    }\n-}\n+// We define the GlobalMetaDataKind enum with this macro because we want to\n+// make sure that we exhaustively iterate over all variants when registering\n+// the corresponding DefIndices in the DefTable.\n+macro_rules! define_global_metadata_kind {\n+    (pub enum GlobalMetaDataKind {\n+        $($variant:ident),*\n+    }) => (\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        pub enum GlobalMetaDataKind {\n+            $($variant),*\n+        }\n \n-impl ::std::hash::Hash for DefPathData {\n-    fn hash<H: ::std::hash::Hasher>(&self, hasher: &mut H) {\n-        ::std::mem::discriminant(self).hash(hasher);\n-        if let Some(ident) = self.get_opt_ident() {\n-            if ident.ctxt == SyntaxContext::empty() && ident.name == ident.name.interned() {\n-                ident.name.as_str().hash(hasher)\n-            } else {\n-                // FIXME(jseyfried) implement stable hashing for idents with macros 2.0 hygiene info\n-                ident.hash(hasher)\n+        impl GlobalMetaDataKind {\n+            fn allocate_def_indices(definitions: &mut Definitions) {\n+                $({\n+                    let instance = GlobalMetaDataKind::$variant;\n+                    definitions.create_def_with_parent(\n+                        CRATE_DEF_INDEX,\n+                        ast::DUMMY_NODE_ID,\n+                        DefPathData::GlobalMetaData(instance.name()),\n+                        DefIndexAddressSpace::High,\n+                        Mark::root()\n+                    );\n+\n+                    // Make sure calling def_index does not crash.\n+                    instance.def_index(&definitions.table);\n+                })*\n+            }\n+\n+            pub fn def_index(&self, def_path_table: &DefPathTable) -> DefIndex {\n+                let def_key = DefKey {\n+                    parent: Some(CRATE_DEF_INDEX),\n+                    disambiguated_data: DisambiguatedDefPathData {\n+                        data: DefPathData::GlobalMetaData(self.name()),\n+                        disambiguator: 0,\n+                    }\n+                };\n+\n+                def_path_table.key_to_index[&def_key]\n+            }\n+\n+            fn name(&self) -> Symbol {\n+\n+                let string = match *self {\n+                    $(\n+                        GlobalMetaDataKind::$variant => {\n+                            concat!(\"{{GlobalMetaData::\", stringify!($variant), \"}}\")\n+                        }\n+                    )*\n+                };\n+\n+                Symbol::intern(string)\n             }\n         }\n-    }\n+    )\n }\n+\n+define_global_metadata_kind!(pub enum GlobalMetaDataKind {\n+    Krate,\n+    CrateDeps,\n+    DylibDependencyFormats,\n+    LangItems,\n+    LangItemsMissing,\n+    NativeLibraries,\n+    CodeMap,\n+    Impls,\n+    ExportedSymbols\n+});"}, {"sha": "a1875cd46a0cb85932408b67796861d2c989d3bb", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -15,7 +15,7 @@ pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, DefPathHash};\n \n-use dep_graph::{DepGraph, DepNode};\n+use dep_graph::{DepGraph, DepNode, DepKind};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex, DefIndexAddressSpace};\n \n@@ -235,7 +235,7 @@ impl Forest {\n     }\n \n     pub fn krate<'hir>(&'hir self) -> &'hir Crate {\n-        self.dep_graph.read(DepNode::Krate);\n+        self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n         &self.krate\n     }\n }\n@@ -280,7 +280,7 @@ impl<'hir> Map<'hir> {\n         self.dep_graph.read(self.dep_node(id));\n     }\n \n-    fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n+    fn dep_node(&self, id0: NodeId) -> DepNode {\n         let mut id = id0;\n         let mut last_expr = None;\n         loop {\n@@ -289,14 +289,16 @@ impl<'hir> Map<'hir> {\n                 EntryItem(..) |\n                 EntryTraitItem(..) |\n                 EntryImplItem(..) => {\n+                    let def_index = self.definitions.opt_def_index(id).unwrap();\n+                    let def_path_hash = self.definitions.def_path_hash(def_index);\n+\n                     if let Some(last_id) = last_expr {\n                         // The body may have a separate dep node\n                         if entry.is_body_owner(last_id) {\n-                            let def_id = self.local_def_id(id);\n-                            return DepNode::HirBody(def_id);\n+                            return def_path_hash.to_dep_node(DepKind::HirBody);\n                         }\n                     }\n-                    return DepNode::Hir(self.local_def_id(id));\n+                    return def_path_hash.to_dep_node(DepKind::Hir);\n                 }\n \n                 EntryVariant(p, v) => {\n@@ -305,8 +307,9 @@ impl<'hir> Map<'hir> {\n                     if last_expr.is_some() {\n                         if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n                             // The enum parent holds both Hir and HirBody nodes.\n-                            let def_id = self.local_def_id(id);\n-                            return DepNode::HirBody(def_id);\n+                            let def_index = self.definitions.opt_def_index(id).unwrap();\n+                            let def_path_hash = self.definitions.def_path_hash(def_index);\n+                            return def_path_hash.to_dep_node(DepKind::HirBody);\n                         }\n                     }\n                 }\n@@ -331,16 +334,20 @@ impl<'hir> Map<'hir> {\n                 }\n \n                 RootCrate => {\n-                    return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n+                    let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n+                    return def_path_hash.to_dep_node(DepKind::Hir);\n                 }\n \n                 NotPresent =>\n                     // Some nodes, notably macro definitions, are not\n                     // present in the map for whatever reason, but\n                     // they *do* have def-ids. So if we encounter an\n                     // empty hole, check for that case.\n-                    return self.opt_local_def_id(id)\n-                               .map(|def_id| DepNode::Hir(def_id))\n+                    return self.definitions.opt_def_index(id)\n+                               .map(|def_index| {\n+                                    let def_path_hash = self.definitions.def_path_hash(def_index);\n+                                    def_path_hash.to_dep_node(DepKind::Hir)\n+                                })\n                                .unwrap_or_else(|| {\n                                    bug!(\"Walking parents from `{}` \\\n                                          led to `NotPresent` at `{}`\",\n@@ -497,15 +504,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n-        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n+        self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     pub fn trait_default_impl(&self, trait_did: DefId) -> Option<NodeId> {\n-        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n+        self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -520,8 +527,9 @@ impl<'hir> Map<'hir> {\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n     pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n-        let crate_root_def_id = DefId::local(CRATE_DEF_INDEX);\n-        self.dep_graph.read(DepNode::Hir(crate_root_def_id));\n+        let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n+\n+        self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n         &self.forest.krate.attrs\n     }\n \n@@ -754,11 +762,8 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_inlined_body(&self, def_id: DefId) -> Option<&'hir Body> {\n-        self.inlined_bodies.borrow().get(&def_id).map(|&body| {\n-            self.dep_graph.read(DepNode::MetaData(def_id));\n-            body\n-        })\n+    pub fn get_inlined_body_untracked(&self, def_id: DefId) -> Option<&'hir Body> {\n+        self.inlined_bodies.borrow().get(&def_id).cloned()\n     }\n \n     pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'hir Body {"}, {"sha": "bf47b9bb9d43d5e3b800c46e3efcc1cc7ab6ae3b", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -29,8 +29,8 @@ pub struct CachingCodemapView<'tcx> {\n     time_stamp: usize,\n }\n \n-impl<'tcx> CachingCodemapView<'tcx> {\n-    pub fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachingCodemapView<'tcx> {\n+impl<'gcx> CachingCodemapView<'gcx> {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CachingCodemapView<'gcx> {\n         let codemap = tcx.sess.codemap();\n         let files = codemap.files();\n         let first_file = files[0].clone();"}, {"sha": "2391b61253aa98883a2e9778bfe3c3971e17f8f1", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -31,9 +31,20 @@ impl Fingerprint {\n         self.0\n     }\n \n+    #[inline]\n+    pub fn combine(self, other: Fingerprint) -> Fingerprint {\n+        // See https://stackoverflow.com/a/27952689 on why this function is\n+        // implemented this way.\n+        Fingerprint(\n+            self.0.wrapping_mul(3).wrapping_add(other.0),\n+            self.1.wrapping_mul(3).wrapping_add(other.1)\n+        )\n+    }\n+\n     pub fn to_hex(&self) -> String {\n         format!(\"{:x}{:x}\", self.0, self.1)\n     }\n+\n }\n \n impl ::std::fmt::Display for Fingerprint {"}, {"sha": "2784a7bd024f66553512dd5563979f7b424bb54f", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -33,9 +33,9 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n-pub struct StableHashingContext<'a, 'tcx: 'a> {\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    codemap: CachingCodemapView<'tcx>,\n+pub struct StableHashingContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n+    codemap: CachingCodemapView<'gcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n     overflow_checks_enabled: bool,\n@@ -51,9 +51,9 @@ pub enum NodeIdHashingMode {\n     HashTraitsInScope,\n }\n \n-impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n \n-    pub fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n         let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n         let check_overflow_initial = tcx.sess.overflow_checks();\n \n@@ -111,7 +111,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> ty::TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'tcx> {\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'gcx> {\n         &mut self.codemap\n     }\n \n@@ -195,9 +195,9 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::NodeId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use syntax_pos::Pos;\n \n@@ -305,15 +305,16 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                        hasher: &mut StableHasher<W>,\n-                                                        map: &HashMap<K, V, R>,\n-                                                        extract_stable_key: F)\n+pub fn hash_stable_hashmap<'a, 'gcx, 'tcx, K, V, R, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &HashMap<K, V, R>,\n+    extract_stable_key: F)\n     where K: Eq + std_hash::Hash,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n           R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = map.keys()\n@@ -327,14 +328,15 @@ pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingC\n     }\n }\n \n-pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                     hasher: &mut StableHasher<W>,\n-                                                     set: &HashSet<K, R>,\n-                                                     extract_stable_key: F)\n+pub fn hash_stable_hashset<'a, 'tcx, 'gcx, K, R, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    set: &HashSet<K, R>,\n+    extract_stable_key: F)\n     where K: Eq + std_hash::Hash,\n           R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = set.iter()\n@@ -344,10 +346,11 @@ pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingCont\n     keys.hash_stable(hcx, hasher);\n }\n \n-pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                           hasher: &mut StableHasher<W>,\n-                                           map: &NodeMap<V>)\n-    where V: HashStable<StableHashingContext<'a, 'tcx>>,\n+pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &NodeMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n           W: StableHasherResult,\n {\n     hash_stable_hashmap(hcx, hasher, map, |hcx, node_id| {\n@@ -356,14 +359,15 @@ pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 't\n }\n \n \n-pub fn hash_stable_btreemap<'a, 'tcx, K, V, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                      hasher: &mut StableHasher<W>,\n-                                                      map: &BTreeMap<K, V>,\n-                                                      extract_stable_key: F)\n+pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &BTreeMap<K, V>,\n+    extract_stable_key: F)\n     where K: Eq + Ord,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = map.keys()"}, {"sha": "7f7a545df9605da37ab88757eab3ce2eab01557d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 65, "deletions": 49, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -12,7 +12,7 @@\n //! types in no particular order.\n \n use hir;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n use ich::{StableHashingContext, NodeIdHashingMode};\n use std::mem;\n \n@@ -21,20 +21,20 @@ use syntax::ast;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for DefId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::HirId {\n             owner,\n@@ -46,6 +46,19 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n     }\n }\n \n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateNum {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.def_path_hash(DefId {\n+            krate: *self,\n+            index: CRATE_DEF_INDEX\n+        }).hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n // The following implementations of HashStable for ItemId, TraitItemId, and\n@@ -55,9 +68,9 @@ impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -69,9 +82,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -83,9 +96,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -215,9 +228,9 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Ty {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::TySlice(..)       |\n@@ -299,9 +312,9 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitRef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n@@ -338,9 +351,9 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n@@ -386,9 +399,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Pat {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::PatKind::Wild        |\n@@ -529,9 +542,9 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Expr {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n@@ -652,9 +665,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::MatchSource {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -703,9 +716,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -716,9 +729,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n@@ -749,9 +762,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n@@ -781,9 +794,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -802,9 +815,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Defaultness {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -823,9 +836,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Mod {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -878,9 +891,9 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Item {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::ItemExternCrate(..) |\n@@ -961,9 +974,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::AssociatedItemKind {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -1008,9 +1022,9 @@ impl_stable_hash_for!(struct hir::Body {\n     value\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::BodyId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         if hcx.hash_bodies() {\n             hcx.tcx().hir.body(*self).hash_stable(hcx, hasher);\n@@ -1024,9 +1038,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::GlobalAsm {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -1037,9 +1051,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::GlobalAsm {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::InlineAsm {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1114,10 +1128,11 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIndex {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         DefId::local(*self).hash_stable(hcx, hasher);\n     }\n@@ -1129,9 +1144,10 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::lang_items::LangItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }"}, {"sha": "cb017b7f8864da797d3c7e1e31a529d83a82f251", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -32,10 +32,11 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Terminator<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::Terminator<'tcx> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Terminator {\n             ref kind,\n@@ -72,59 +73,61 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Terminator<'t\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Local {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::BasicBlock {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Field {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::VisibilityScope {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Promoted {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::TerminatorKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -182,9 +185,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKin\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::AssertMessage<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -202,9 +206,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::StatementKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -221,6 +226,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind\n             mir::StatementKind::StorageDead(ref lvalue) => {\n                 lvalue.hash_stable(hcx, hasher);\n             }\n+            mir::StatementKind::EndRegion(ref extents) => {\n+                extents.hash_stable(hcx, hasher);\n+            }\n             mir::StatementKind::Nop => {}\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 asm.hash_stable(hcx, hasher);\n@@ -231,9 +239,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -250,12 +258,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx>\n     }\n }\n \n-impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection<'tcx, B, V>\n-    where B: HashStable<StableHashingContext<'a, 'tcx>>,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, B, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::Projection<'tcx, B, V>\n+    where B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -267,11 +276,12 @@ impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Project\n     }\n }\n \n-impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::ProjectionElem<'tcx, V>\n-    where V: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::ProjectionElem<'tcx, V>\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -302,9 +312,9 @@ impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Operand<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -319,9 +329,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx>\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Rvalue<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Rvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -379,9 +389,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AggregateKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::AggregateKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -435,9 +446,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Literal<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Literal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "b9cc3b5fb937fe1927ecba066a1e2d5f4940b3dd", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -27,20 +27,21 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::symbol::InternedString {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::syntax::symbol::InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Name {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n@@ -82,9 +83,10 @@ impl_stable_hash_for!(enum ::syntax::abi::Abi {\n impl_stable_hash_for!(struct ::syntax::attr::Deprecation { since, note });\n impl_stable_hash_for!(struct ::syntax::attr::Stability { level, feature, rustc_depr });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::attr::StabilityLevel {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -135,9 +137,9 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Some attributes are always ignored during hashing.\n         let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n@@ -155,9 +157,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -184,9 +186,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenTree {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -205,18 +208,19 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::Token\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenStream {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n-                                               hcx: &mut StableHashingContext<'a, 'tcx>,\n+fn hash_token<'a, 'gcx, 'tcx, W: StableHasherResult>(token: &token::Token,\n+                                               hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                                hasher: &mut StableHasher<W>,\n                                                error_reporting_span: Span) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n@@ -322,16 +326,18 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for FileMap {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             ref name,\n             name_was_remapped,\n             crate_of_origin,\n             // Do not hash the source as it is not encoded\n             src: _,\n+            src_hash,\n+            external_src: _,\n             start_pos,\n             end_pos: _,\n             ref lines,\n@@ -346,6 +352,8 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for FileMap {\n             index: CRATE_DEF_INDEX,\n         }.hash_stable(hcx, hasher);\n \n+        src_hash.hash_stable(hcx, hasher);\n+\n         // We only hash the relative position within this filemap\n         let lines = lines.borrow();\n         lines.len().hash_stable(hcx, hasher);"}, {"sha": "4e78d79ef87378e8d1376a1f4a5b368d7fe7facb", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8446a2333ca7a22a594a24e3eb541cf5265792/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4b8446a2333ca7a22a594a24e3eb541cf5265792", "patch": "@@ -19,27 +19,30 @@ use std::mem;\n use syntax_pos::symbol::InternedString;\n use ty;\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for &'tcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>> {\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for &'tcx ty::Slice<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::subst::Kind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_type().hash_stable(hcx, hasher);\n         self.as_region().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -72,9 +75,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::AutoBorrow<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::adjustment::AutoBorrow<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -89,9 +93,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Au\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Adjust<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::adjustment::Adjust<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -122,9 +127,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::UpvarCapture<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -143,11 +149,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.tcx().anonymize_late_bound_regions(self).0.hash_stable(hcx, hasher);\n     }\n@@ -166,12 +172,13 @@ impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'a, 'tcx, A, B> HashStable<StableHashingContext<'a, 'tcx>> for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'a, 'tcx>>,\n-          B: HashStable<StableHashingContext<'a, 'tcx>>,\n+impl<'a, 'gcx, 'tcx, A, B> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::OutlivesPredicate<A, B>\n+    where A: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -183,9 +190,9 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { trait_ref, item_def_id });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Predicate<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -221,9 +228,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -248,10 +255,10 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for ::middle::const_val::ConstVal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal;\n \n@@ -324,9 +331,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -350,9 +357,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionParameterDef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -379,12 +387,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n });\n \n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -427,10 +435,11 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::region::CodeExtent\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::region::CodeExtent;\n \n@@ -472,10 +481,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeVariants<'tcx>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::TypeVariants<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -563,10 +573,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::ExistentialPredicate<'tcx>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::ExistentialPredicate<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -595,9 +606,10 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::TypeckTables<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n             ref type_dependent_defs,"}]}