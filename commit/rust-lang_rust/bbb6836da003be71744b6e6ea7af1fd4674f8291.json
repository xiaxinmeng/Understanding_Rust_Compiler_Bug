{"sha": "bbb6836da003be71744b6e6ea7af1fd4674f8291", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYjY4MzZkYTAwM2JlNzE3NDRiNmU2ZWE3YWYxZmQ0Njc0ZjgyOTE=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-03-13T23:40:25Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-03-13T23:40:25Z"}, "message": "Merge branch 'master' into recursive-elseif\n\nConflicts:\n\n\tsrc/comp/middle/typeck.rs", "tree": {"sha": "fc7780f767666cced8406818806216bee3863c91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc7780f767666cced8406818806216bee3863c91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb6836da003be71744b6e6ea7af1fd4674f8291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb6836da003be71744b6e6ea7af1fd4674f8291", "html_url": "https://github.com/rust-lang/rust/commit/bbb6836da003be71744b6e6ea7af1fd4674f8291", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb6836da003be71744b6e6ea7af1fd4674f8291/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a662944a4d87c6d82299a181996ba14170b2ebb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a662944a4d87c6d82299a181996ba14170b2ebb", "html_url": "https://github.com/rust-lang/rust/commit/2a662944a4d87c6d82299a181996ba14170b2ebb"}, {"sha": "fdc22ef1a1cef77dedb9c0429c746a81688a5979", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdc22ef1a1cef77dedb9c0429c746a81688a5979", "html_url": "https://github.com/rust-lang/rust/commit/fdc22ef1a1cef77dedb9c0429c746a81688a5979"}], "stats": {"total": 2813, "additions": 1854, "deletions": 959}, "files": [{"sha": "43b6619334def1cc88ddead5656e95b5b3cd4e4a", "filename": "src/Makefile", "status": "modified", "additions": 56, "deletions": 34, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -34,6 +34,7 @@ DSYMUTIL := true\n \n ifeq ($(CFG_OSTYPE), FreeBSD)\n   CFG_RUNTIME := librustrt.so\n+  CFG_SUPPORT := librustllvm.so\n   CFG_STDLIB := libstd.so\n   CFG_GCC_CFLAGS += -fPIC -march=i686 -I/usr/local/include\n   CFG_GCC_LINK_FLAGS += -shared -fPIC -lpthread -lrt\n@@ -47,6 +48,7 @@ endif\n \n ifeq ($(CFG_OSTYPE), Linux)\n   CFG_RUNTIME := librustrt.so\n+  CFG_SUPPORT := librustllvm.so\n   CFG_STDLIB := libstd.so\n   CFG_GCC_CFLAGS += -fPIC -march=i686\n   CFG_GCC_LINK_FLAGS += -shared -fPIC -ldl -lpthread -lrt\n@@ -60,6 +62,7 @@ endif\n \n ifeq ($(CFG_OSTYPE), Darwin)\n   CFG_RUNTIME := librustrt.dylib\n+  CFG_SUPPORT := librustllvm.dylib\n   CFG_STDLIB := libstd.dylib\n   CFG_UNIXY := 1\n   CFG_GCC_LINK_FLAGS += -dynamiclib -lpthread\n@@ -85,8 +88,8 @@ ifdef CFG_WINDOWSY\n     CFG_NATIVE := 1\n   endif\n   CFG_RUNTIME := rustrt.dll\n+  CFG_SUPPORT := rustllvm.dll\n   CFG_STDLIB := std.dll\n-  CFG_OBJ_SUFFIX := .o\n   CFG_EXE_SUFFIX := .exe\n   CFG_BOOT := ./rustboot.exe\n   CFG_RUSTC := ./rustc.exe\n@@ -101,20 +104,19 @@ ifdef CFG_UNIXY\n   CFG_INFO := $(info cfg: unix-y environment)\n   CFG_BOOT := ./rustboot\n   CFG_RUSTC := ./rustc\n-  CFG_OBJ_SUFFIX := .o\n   CFG_RUN_TARG = LD_LIBRARY_PATH=. $(CFG_VALGRIND) $(1)\n   CFG_GCC := 1\n   ifdef MINGW_CROSS\n     CFG_INFO := $(info cfg: mingw-cross)\n     CFG_GCC_CROSS := i586-mingw32msvc-\n     CFG_BOOT_FLAGS += -t win32-x86-pe\n     CFG_RUNTIME := rustrt.dll\n+    CFG_SUPPORT := rustllvm.dll\n     CFG_STDLIB := std.dll\n     CFG_RUSTC := ./rustc.exe\n     ifdef CFG_VALGRIND\n       CFG_VALGRIND += wine\n     endif\n-    CFG_OBJ_SUFFIX := .o\n     CFG_EXE_SUFFIX := .exe\n     CFG_GCC_CFLAGS := -march=i686\n     CFG_GCC_LINK_FLAGS := -shared\n@@ -182,7 +184,7 @@ endif\n ifneq ($(CFG_LLVM_CONFIG),)\n   CFG_LLVM_VERSION := $(shell $(CFG_LLVM_CONFIG) --version)\n   $(info cfg: found llvm-config at $(CFG_LLVM_CONFIG))\n-  CFG_LLVM_ALLOWED_VERSIONS := 2.8svn 2.8 2.9svn\n+  CFG_LLVM_ALLOWED_VERSIONS := 2.8svn 2.8 2.9svn 3.0svn\n   ifneq ($(findstring $(CFG_LLVM_VERSION),$(CFG_LLVM_ALLOWED_VERSIONS)),)\n     $(info cfg: using LLVM version $(CFG_LLVM_VERSION))\n   else\n@@ -196,6 +198,10 @@ ifdef CFG_LLVM_CONFIG\n   LLC := \"$(shell $(CFG_LLVM_CONFIG) --bindir)/llc\"\n   CFG_LLC_CFLAGS := -march=x86\n   LLVM-DIS := \"$(shell $(CFG_LLVM_CONFIG) --bindir)/llvm-dis\"\n+  CFG_LLVM_INCDIR := $(shell $(CFG_LLVM_CONFIG) --includedir)\n+  CFG_LLVM_CXXFLAGS := $(shell $(CFG_LLVM_CONFIG) --cxxflags)\n+  CFG_LLVM_LDFLAGS := $(shell $(CFG_LLVM_CONFIG) --ldflags)\n+  CFG_LLVM_LIBS := $(shell $(CFG_LLVM_CONFIG) --libs)\n endif\n \n MKFILES := Makefile\n@@ -302,15 +308,22 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/test/rust_test_util.h\n \n RUNTIME_INCS := -Irt/isaac -Irt/uthash\n-RUNTIME_OBJS := $(RUNTIME_CS:.cpp=$(CFG_OBJ_SUFFIX))\n-RUNTIME_LIBS := $(CFG_RUNTIME_LIBS)\n+RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o)\n+\n+SUPPORT_CS := llvmext/Object.cpp\n+\n+SUPPORT_HDR := llvmext/include/llvm-c/Object.h\n+\n+SUPPORT_INCS := -iquote $(CFG_LLVM_INCDIR) -iquote llvmext/include\n+SUPPORT_OBJS := $(SUPPORT_CS:.cpp=.o)\n+SUPPORT_LIBS := $(CFG_LLVM_LDFLAGS) $(CFG_LLVM_LIBS)\n \n STDLIB_CRATE := lib/std.rc\n STDLIB_INPUTS := $(wildcard lib/*.rc lib/*.rs lib/*/*.rs)\n COMPILER_CRATE := comp/rustc.rc\n-COMPILER_INPUTS := $(wildcard comp/*.rc comp/*.rs comp/*/*.rs)\n+COMPILER_INPUTS := $(wildcard comp/rustc.rc comp/*.rs comp/*/*.rs)\n \n-GENERATED := boot/fe/lexer.ml boot/util/version.ml\n+GENERATED := boot/fe/lexer.ml boot/util/version.ml glue.o\n \n all: $(CFG_RUSTC) $(MKFILES) $(GENERATED)\n \n@@ -325,14 +338,24 @@ $(CFG_RUNTIME): $(RUNTIME_OBJS) $(MKFILES) $(RUNTIME_HDR)\n \t@$(call CFG_ECHO, compile: $<)\n \t$(CFG_QUIET)$(call CFG_LINK_C, $@) $(RUNTIME_OBJS)\n \n+$(CFG_SUPPORT): $(SUPPORT_OBJS) $(MKFILES) $(SUPPORT_HDR)\n+\t@$(call CFG_ECHO, compile: $<)\n+\t$(CFG_QUIET)$(call CFG_LINK_C, $@ $(CFG_LLVM_LDFLAGS) $(CFG_LLVM_LIBS)) \\\n+\t\t$(SUPPORT_OBJS)\n+\n $(CFG_STDLIB): $(STDLIB_CRATE) $(CFG_BOOT) $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n \t$(BOOT) -shared -o $@ $(STDLIB_CRATE)\n \n-%$(CFG_OBJ_SUFFIX): %.cpp $(MKFILES)\n+rt/%.o: rt/%.cpp $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n \t$(CFG_QUIET)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n \n+llvmext/%.o: llvmext/%.cpp $(MKFILES)\n+\t@$(call CFG_ECHO, compile: $<)\n+\t$(CFG_QUIET)$(call CFG_COMPILE_C, $@, $(CFG_LLVM_CXXFLAGS) \\\n+\t\t$(SUPPORT_INCS)) $<\n+\n ifdef CFG_NATIVE\n $(CFG_BOOT): $(BOOT_CMXS) $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n@@ -363,13 +386,18 @@ endif\n # Main compiler targets and rules\n ######################################################################\n \n-$(CFG_RUSTC): $(COMPILER_INPUTS) $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n+$(CFG_RUSTC): $(COMPILER_INPUTS) $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB) \\\n+\t\t$(CFG_SUPPORT)\n \t@$(call CFG_ECHO, compile: $<)\n \t$(BOOT) -minimal -o $@ $<\n \t$(CFG_QUIET)chmod 0755 $@\n \n+glue.bc: $(CFG_RUSTC) $(CFG_RUNTIME) $(CFG_STDLIB)\n+\t@$(call CFG_ECHO, generate: $@)\n+\t$(RUSTC) -o $@ -glue\n+\n self: $(CFG_RUSTC)\n-\t@$(call CFG_ECHO, compile: $<)\n+\t@$(call CFG_ECHO, compile: $(COMPILER_CRATE))\n \t$(RUSTC) $(COMPILER_CRATE)\n \n \n@@ -402,19 +430,23 @@ TEST_XFAILS_BOOT :=  $(TASK_XFAILS) \\\n                     $(NOMINAL_TAG_XFAILS) \\\n                     $(CONST_TAG_XFAILS) \\\n                     test/run-pass/arith-unsigned.rs \\\n+                    test/run-pass/box-compare.rs \\\n                     test/run-pass/child-outlives-parent.rs \\\n                     test/run-pass/clone-with-exterior.rs \\\n                     test/run-pass/constrained-type.rs \\\n                     test/run-pass/destructor-ordering.rs \\\n                     test/run-pass/obj-as.rs \\\n                     test/run-pass/vec-slice.rs \\\n                     test/run-pass/fn-lval.rs \\\n+                    test/run-pass/generic-bind-2.rs \\\n                     test/run-pass/generic-fn-box.rs \\\n                     test/run-pass/generic-tup.rs \\\n                     test/run-pass/iter-ret.rs \\\n+                    test/run-pass/leak-tag-copy.rs \\\n                     test/run-pass/lib-io.rs \\\n                     test/run-pass/mlist-cycle.rs \\\n                     test/run-pass/obj-as.rs \\\n+                    test/run-pass/seq-compare.rs \\\n                     test/run-pass/task-comm.rs \\\n                     test/run-pass/task-comm-3.rs \\\n                     test/run-pass/vec-slice.rs \\\n@@ -439,24 +471,11 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         basic-1.rs \\\n                         basic-2.rs \\\n                         basic.rs \\\n-                        bind-obj-ctor.rs \\\n                         child-outlives-parent.rs \\\n                         clone-with-exterior.rs \\\n                         comm.rs \\\n                         constrained-type.rs \\\n                         destructor-ordering.rs \\\n-                        drop-parametric-closure-with-bound-box.rs \\\n-                        export-non-interference.rs \\\n-                        foreach-nested-2.rs \\\n-                        foreach-nested.rs \\\n-                        foreach-put-structured.rs \\\n-                        foreach-simple-outer-slot.rs \\\n-                        generic-fn-twice.rs \\\n-                        generic-iter-frame.rs \\\n-                        generic-recursive-tag.rs \\\n-                        generic-tag-alt.rs \\\n-                        generic-tag-values.rs \\\n-                        iter-range.rs \\\n                         iter-ret.rs \\\n                         lazychan.rs \\\n                         lib-bitv.rs \\\n@@ -478,7 +497,6 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         mutable-alias-vec.rs \\\n                         obj-as.rs \\\n                         obj-dtor.rs \\\n-                        obj-return-polytypes.rs \\\n                         pred.rs \\\n                         preempt.rs \\\n                         rt-circular-buffer.rs \\\n@@ -511,13 +529,11 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         threads.rs \\\n                         type-sizes.rs \\\n                         typestate-cfg-nesting.rs \\\n-                        use-import-export.rs \\\n                         user.rs \\\n                         utf8.rs \\\n                         vec-alloc-append.rs \\\n                         vec-append.rs \\\n                         vec-slice.rs \\\n-                        while-prelude-drop.rs \\\n                         while-with-break.rs \\\n                         yield.rs \\\n                         yield2.rs \\\n@@ -764,9 +780,9 @@ test/bench/shootout/%.boot$(CFG_EXE_SUFFIX): \\\n \t@$(call CFG_ECHO, assemble [llvm]: $<)\n \t$(CFG_QUIET)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n \n-%.rustc$(CFG_EXE_SUFFIX): %.o $(CFG_RUNTIME)\n+%.rustc$(CFG_EXE_SUFFIX): %.o $(CFG_RUNTIME) glue.o\n \t@$(call CFG_ECHO, link [llvm]: $<)\n-\t$(CFG_QUIET)gcc $(CFG_GCC_CFLAGS) -o $@ $< -L. -lrustrt\n+\t$(CFG_QUIET)gcc $(CFG_GCC_CFLAGS) glue.o -o $@ $< -L. -lrustrt\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise.\n@@ -803,7 +819,7 @@ C_DEPFILES := $(RUNTIME_CS:%.cpp=%.d)\n %.d: %.cpp $(MKFILES)\n \t@$(call CFG_ECHO, dep: $<)\n \t$(CFG_QUIET)$(call CFG_DEPEND_C, $@ \\\n-      $(patsubst %.cpp, %$(CFG_OBJ_SUFFIX), $<), \\\n+      $(patsubst %.cpp, %.o, $<), \\\n       $(RUNTIME_INCS)) $< $(CFG_PATH_MUNGE) >$@.tmp \\\n       && mv $@.tmp $@\n \n@@ -826,9 +842,15 @@ RUSTBOOT_PROBE := $(wildcard $(CFG_BOOT))\n ifneq ($(RUSTBOOT_PROBE),)\n CFG_INFO := $(info cfg: using built $(CFG_BOOT) for rust deps)\n STDLIB_DEPFILE := $(CFG_STDLIB).d\n+RUSTC_DEPFILE := $(CFG_RUSTC).d\n CRATE_DEPFILES := $(ALL_TEST_CRATES:%.rc=%.d) $(STDLIB_DEPFILE)\n \n-$(STDLIB_DEPFILE): $(STDLIB_CRATE) $(MKFILES) $(CFG_BOOT)\n+$(STDLIB_DEPFILE): $(STDLIB_CRATE) $(MKFILES) $(CFG_BOOT) $(STDLIB_INPUTS)\n+\t@$(call CFG_ECHO, dep: $<)\n+\t$(BOOT) -shared -rdeps $< $(CFG_PATH_MUNGE) >$@.tmp \\\n+    && mv $@.tmp $@\n+\n+$(RUSTC_DEPFILE): $(STDLIB_CRATE) $(MKFILES) $(CFG_BOOT) $(COMPILER_INPUTS)\n \t@$(call CFG_ECHO, dep: $<)\n \t$(BOOT) -shared -rdeps $< $(CFG_PATH_MUNGE) >$@.tmp \\\n     && mv $@.tmp $@\n@@ -920,12 +942,12 @@ clean:\n \t$(CFG_QUIET)rm -f $(ML_DEPFILES:%.d=%.d.tmp)\n \t$(CFG_QUIET)rm -f $(C_DEPFILES:%.d=%.d.tmp)\n \t$(CFG_QUIET)rm -f $(CRATE_DEPFILES:%.d=%.d.tmp)\n-\t$(CFG_QUIET)rm -f $(GENERATED)\n+\t$(CFG_QUIET)rm -f $(GENERATED) glue.bc glue.s\n \t$(CFG_QUIET)rm -f $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n \t$(CFG_QUIET)rm -Rf $(PKG_NAME)-*.tar.gz dist\n-\t$(CFG_QUIET)rm -f $(foreach ext,cmx cmi cmo cma o a d exe,\\\n+\t$(CFG_QUIET)rm -f $(foreach ext,cmx cmi cmo cma bc o a d exe,\\\n                         $(wildcard boot/*/*.$(ext) boot/*/*/*.$(ext)))\n-\t$(CFG_QUIET)rm -Rf $(foreach ext,out llvm x86 boot rustc o s exe dSYM,\\\n+\t$(CFG_QUIET)rm -Rf $(foreach ext,out llvm x86 boot rustc bc o s exe dSYM,\\\n                         $(wildcard test/*/*.$(ext)))\n \n "}, {"sha": "023e1e1df203bb81cb2188e4f406177ace00c59f", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -80,7 +80,7 @@ let general_code_alignment = 16;;\n let tydesc_field_first_param = 0;;\n let tydesc_field_size = 1;;\n let tydesc_field_align = 2;;\n-let tydesc_field_copy_glue = 3;;\n+let tydesc_field_take_glue = 3;;\n let tydesc_field_drop_glue = 4;;\n let tydesc_field_free_glue = 5;;\n let tydesc_field_sever_glue = 6;;"}, {"sha": "ddcbc9afd70770fec34c23b1cd04576ada889c7a", "filename": "src/boot/driver/main.ml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,11 +1,6 @@\n \n open Common;;\n \n-let _ =\n-  Gc.set { (Gc.get()) with\n-             Gc.space_overhead = 400; }\n-;;\n-\n let (targ:Common.target) =\n   match Sys.os_type with\n "}, {"sha": "3419bb3469849eca02705807046933fd2af27a67", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -20,7 +20,7 @@ type glue =\n   | GLUE_yield\n   | GLUE_exit_main_task\n   | GLUE_exit_task\n-  | GLUE_copy of Ast.ty           (* One-level copy.                    *)\n+  | GLUE_take of Ast.ty           (* One-level refcounts++.             *)\n   | GLUE_drop of Ast.ty           (* De-initialize local memory.        *)\n   | GLUE_free of Ast.ty           (* Drop body + free() box ptr.        *)\n   | GLUE_sever of Ast.ty          (* Null all box state slots.          *)\n@@ -2776,7 +2776,7 @@ let glue_str (cx:ctxt) (g:glue) : string =\n     | GLUE_yield -> \"glue$yield\"\n     | GLUE_exit_main_task -> \"glue$exit_main_task\"\n     | GLUE_exit_task -> \"glue$exit_task\"\n-    | GLUE_copy ty -> \"glue$copy$\" ^ (ty_str cx ty)\n+    | GLUE_take ty -> \"glue$take$\" ^ (ty_str cx ty)\n     | GLUE_drop ty -> \"glue$drop$\" ^ (ty_str cx ty)\n     | GLUE_free ty -> \"glue$free$\" ^ (ty_str cx ty)\n     | GLUE_sever ty -> \"glue$sever$\" ^ (ty_str cx ty)"}, {"sha": "17dbe3ea263b3b594074a99def512494b674b1f6", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 74, "deletions": 98, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1355,7 +1355,7 @@ let trans_visitor\n                    Asm.WORD (word_ty_mach, Asm.IMM 0L);\n                    Asm.WORD (word_ty_mach, Asm.IMM sz);\n                    Asm.WORD (word_ty_mach, Asm.IMM align);\n-                   fix (get_copy_glue t);\n+                   fix (get_take_glue t);\n                    fix (get_drop_glue t);\n                    begin\n                      match ty_mem_ctrl cx t with\n@@ -2022,34 +2022,18 @@ let trans_visitor\n       get_typed_mem_glue g fty inner\n \n \n-  and get_copy_glue\n+  and get_take_glue\n       (ty:Ast.ty)\n       : fixup =\n     let ty = get_genericized_ty ty in\n     let arg_ty_params_alias = 0 in\n     let arg_src_alias = 1 in\n-    let arg_initflag = 2 in\n \n-    let g = GLUE_copy ty in\n-    let inner (out_ptr:Il.cell) (args:Il.cell) =\n-      let dst = deref out_ptr in\n+    let g = GLUE_take ty in\n+    let inner (_:Il.cell) (args:Il.cell) =\n       let ty_params = deref (get_element_ptr args arg_ty_params_alias) in\n       let src = deref (get_element_ptr args arg_src_alias) in\n-\n-      (* Translate copy code for the dst-initializing and\n-       * dst-non-initializing cases and branch accordingly. *)\n-      let initflag = get_element_ptr args arg_initflag in\n-      let jmps = trans_compare_simple Il.JNE (Il.Cell initflag) one in\n-\n-        trans_copy_ty_full true ty_params true dst ty src ty;\n-\n-        let skip_noninit_jmp = mark() in\n-          emit (Il.jmp Il.JMP Il.CodeNone);\n-          List.iter patch jmps;\n-\n-          trans_copy_ty_full true ty_params false dst ty src ty;\n-\n-          patch skip_noninit_jmp;\n+        trans_take_ty true ty_params src ty;\n     in\n     let ty_params_ptr = ty_params_covering ty in\n     let fty =\n@@ -2186,17 +2170,23 @@ let trans_visitor\n               get_tydesc_params ty_params_cell elt_td_ptr_cell\n             in\n \n-            let initflag = Il.Reg (force_to_reg one) in\n-\n+              (* Take all *)\n               copy_loop dst_buf src_buf (Il.Cell fill) (Il.Cell elt_sz)\n                 begin\n-                  fun dptr sptr ->\n+                  fun _ sptr ->\n                     trans_call_dynamic_glue\n                       elt_td_ptr_cell\n-                      Abi.tydesc_field_copy_glue\n-                      (Some (deref dptr))\n-                      [| ty_params_ptr; sptr; initflag |]\n+                      Abi.tydesc_field_take_glue\n                       None\n+                      [| ty_params_ptr; sptr |]\n+                      None;\n+                end;\n+\n+              (* Memcpy all *)\n+              copy_loop dst_buf src_buf (Il.Cell fill) one\n+                begin\n+                  fun dptr sptr ->\n+                    mov (deref dptr) (Il.Cell (deref sptr))\n                 end;\n \n               (* Set the new vec's fill to the original vec's fill *)\n@@ -3734,17 +3724,58 @@ let trans_visitor\n       end\n       tys\n \n-  and trans_copy_ty\n+  and trans_take_ty\n+      (force_inline:bool)\n       (ty_params:Il.cell)\n-      (initializing:bool)\n-      (dst:Il.cell) (dst_ty:Ast.ty)\n-      (src:Il.cell) (src_ty:Ast.ty)\n+      (v:Il.cell)\n+      (ty:Ast.ty)\n       : unit =\n-    trans_copy_ty_full\n-      false ty_params initializing dst dst_ty src src_ty\n+    let ty = strip_mutable_or_constrained_ty ty in\n+    match ty_mem_ctrl cx ty with\n+        MEM_rc_opaque | MEM_gc | MEM_rc_struct -> incr_refcount v\n+      | _ ->\n+          begin\n+            match ty with\n+                Ast.TY_fn _\n+              | Ast.TY_obj _ ->\n+                  let binding =\n+                    get_element_ptr v Abi.binding_field_bound_data\n+                  in\n+                  let null_jmp = null_check binding in\n+                    incr_refcount binding;\n+                    patch null_jmp\n \n-  and trans_copy_ty_full\n-      (force_inline:bool)\n+              | Ast.TY_param (i, _) ->\n+                  aliasing false v\n+                    begin\n+                      fun v ->\n+                        let td = get_ty_param ty_params i in\n+                        let ty_params_ptr = get_tydesc_params ty_params td in\n+                          trans_call_dynamic_glue\n+                            td Abi.tydesc_field_take_glue\n+                            None\n+                            [| ty_params_ptr; v; |]\n+                            None\n+                    end\n+\n+              | Ast.TY_rec _\n+              | Ast.TY_tag _\n+              | Ast.TY_tup _ ->\n+                  if force_inline\n+                  then\n+                    iter_ty_parts ty_params v ty\n+                      (trans_take_ty force_inline ty_params)\n+                  else\n+                    trans_call_static_glue\n+                      (code_fixup_to_ptr_operand (get_take_glue ty))\n+                      None\n+                      [| alias ty_params; alias v; |]\n+                      None\n+\n+              | _ -> ()\n+          end\n+\n+  and trans_copy_ty\n       (ty_params:Il.cell)\n       (initializing:bool)\n       (dst:Il.cell) (dst_ty:Ast.ty)\n@@ -3789,7 +3820,7 @@ let trans_visitor\n               | _ ->\n                   (* Heavyweight copy: duplicate 1 level of the referent. *)\n                   anno \"heavy\";\n-                  trans_copy_ty_heavy force_inline ty_params initializing\n+                  trans_copy_ty_heavy ty_params initializing\n                     dst dst_ty src src_ty\n         end\n \n@@ -3821,7 +3852,6 @@ let trans_visitor\n    *)\n \n   and trans_copy_ty_heavy\n-      (force_inline:bool)\n       (ty_params:Il.cell)\n       (initializing:bool)\n       (dst:Il.cell) (dst_ty:Ast.ty)\n@@ -3863,68 +3893,14 @@ let trans_visitor\n                       (ty_sz cx ty)));\n               mov dst (Il.Cell src)\n \n-          | Ast.TY_param (i, _) ->\n-              iflog\n-                (fun _ -> annotate\n-                   (Printf.sprintf \"copy_ty: parametric copy %#d\" i));\n-              let initflag = Il.Reg (force_to_reg one) in\n-              aliasing false src\n-                begin\n-                  fun src ->\n-                    let td = get_ty_param ty_params i in\n-                    let ty_params_ptr = get_tydesc_params ty_params td in\n-                      trans_call_dynamic_glue\n-                        td Abi.tydesc_field_copy_glue\n-                        (Some dst)\n-                        [| ty_params_ptr; src; initflag |]\n-                        None\n-                end\n-\n-          | Ast.TY_fn _\n-          | Ast.TY_obj _ ->\n-              begin\n-                let src_item =\n-                  get_element_ptr src Abi.binding_field_dispatch\n-                in\n-                let dst_item =\n-                  get_element_ptr dst Abi.binding_field_dispatch\n-                in\n-                let src_binding =\n-                  get_element_ptr src Abi.binding_field_bound_data\n-                in\n-                let dst_binding =\n-                  get_element_ptr dst Abi.binding_field_bound_data\n-                in\n-                  mov dst_item (Il.Cell src_item);\n-                  mov dst_binding zero;\n-                  let null_jmp = null_check src_binding in\n-                    (* Copy if we have a src binding. *)\n-                    (* FIXME (issue #58): this is completely wrong, call\n-                     * through to the binding's self-copy fptr. For now\n-                     * this only works by accident.\n-                     *)\n-                    trans_copy_ty ty_params true\n-                      dst_binding (Ast.TY_box Ast.TY_int)\n-                      src_binding (Ast.TY_box Ast.TY_int);\n-                    patch null_jmp\n-              end\n-\n           | _ ->\n-              if force_inline || should_inline_structure_helpers ty\n-              then\n-                iter_ty_parts_full ty_params dst src ty\n-                  (fun dst src ty ->\n-                     trans_copy_ty ty_params true\n-                       dst ty src ty)\n-              else\n-                let initflag = Il.Reg (force_to_reg one) in\n-                  trans_call_static_glue\n-                    (code_fixup_to_ptr_operand (get_copy_glue ty))\n-                    (Some dst)\n-                    [| alias ty_params;\n-                       alias src;\n-                       initflag |]\n-                    None\n+              trans_take_ty false ty_params src ty;\n+              if not initializing\n+              then drop_ty ty_params dst ty;\n+              let sz = ty_sz_with_ty_params ty_params ty in\n+                copy_loop dst src sz (imm 1L)\n+                  (fun dptr sptr ->\n+                     mov (deref dptr) (Il.Cell (deref sptr)))\n \n \n   and trans_copy"}, {"sha": "0ed79db453cbbe80fda9f653eec57b97618b04a9", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -25,22 +25,39 @@ fn restore_callee_saves() -> vec[str] {\n             \"popl  %ebp\");\n }\n \n-fn load_esp_from_rust_sp() -> vec[str] {\n+fn load_esp_from_rust_sp_first_arg() -> vec[str] {\n     ret vec(\"movl  \" + wstr(abi.task_field_rust_sp) + \"(%ecx), %esp\");\n }\n \n-fn load_esp_from_runtime_sp() -> vec[str] {\n+fn load_esp_from_runtime_sp_first_arg() -> vec[str] {\n     ret vec(\"movl  \" + wstr(abi.task_field_runtime_sp) + \"(%ecx), %esp\");\n }\n \n-fn store_esp_to_rust_sp() -> vec[str] {\n+fn store_esp_to_rust_sp_first_arg() -> vec[str] {\n     ret vec(\"movl  %esp, \" + wstr(abi.task_field_rust_sp) + \"(%ecx)\");\n }\n \n-fn store_esp_to_runtime_sp() -> vec[str] {\n+fn store_esp_to_runtime_sp_first_arg() -> vec[str] {\n     ret vec(\"movl  %esp, \" + wstr(abi.task_field_runtime_sp) + \"(%ecx)\");\n }\n \n+fn load_esp_from_rust_sp_second_arg() -> vec[str] {\n+    ret vec(\"movl  \" + wstr(abi.task_field_rust_sp) + \"(%edx), %esp\");\n+}\n+\n+fn load_esp_from_runtime_sp_second_arg() -> vec[str] {\n+    ret vec(\"movl  \" + wstr(abi.task_field_runtime_sp) + \"(%edx), %esp\");\n+}\n+\n+fn store_esp_to_rust_sp_second_arg() -> vec[str] {\n+    ret vec(\"movl  %esp, \" + wstr(abi.task_field_rust_sp) + \"(%edx)\");\n+}\n+\n+fn store_esp_to_runtime_sp_second_arg() -> vec[str] {\n+    ret vec(\"movl  %esp, \" + wstr(abi.task_field_runtime_sp) + \"(%edx)\");\n+}\n+\n+\n /*\n  * This is a bit of glue-code. It should be emitted once per\n  * compilation unit.\n@@ -61,8 +78,8 @@ fn store_esp_to_runtime_sp() -> vec[str] {\n fn rust_activate_glue() -> vec[str] {\n     ret vec(\"movl  4(%esp), %ecx    # ecx = rust_task\")\n         + save_callee_saves()\n-        + store_esp_to_runtime_sp()\n-        + load_esp_from_rust_sp()\n+        + store_esp_to_runtime_sp_first_arg()\n+        + load_esp_from_rust_sp_first_arg()\n \n         /*\n          * There are two paths we can arrive at this code from:\n@@ -154,10 +171,10 @@ fn rust_activate_glue() -> vec[str] {\n \n fn rust_yield_glue() -> vec[str] {\n     ret vec(\"movl  0(%esp), %ecx    # ecx = rust_task\")\n-        + load_esp_from_rust_sp()\n+        + load_esp_from_rust_sp_first_arg()\n         + save_callee_saves()\n-        + store_esp_to_rust_sp()\n-        + load_esp_from_runtime_sp()\n+        + store_esp_to_rust_sp_first_arg()\n+        + load_esp_from_runtime_sp_first_arg()\n         + restore_callee_saves()\n         + vec(\"ret\");\n }\n@@ -175,8 +192,11 @@ fn upcall_glue(int n_args) -> vec[str] {\n      */\n \n     fn copy_arg(uint i) -> str {\n-        auto src_off = wstr(5 + (i as int));\n-        auto dst_off = wstr(1 + (i as int));\n+        if (i == 0u) {\n+            ret \"movl  %edx, (%esp)\";\n+        }\n+        auto src_off = wstr(4 + (i as int));\n+        auto dst_off = wstr(0 + (i as int));\n         auto m = vec(\"movl  \" + src_off + \"(%ebp),%eax\",\n                      \"movl  %eax,\" + dst_off + \"(%esp)\");\n         ret _str.connect(m, \"\\n\\t\");\n@@ -189,20 +209,19 @@ fn upcall_glue(int n_args) -> vec[str] {\n \n         + vec(\"movl  %esp, %ebp     # ebp = rust_sp\")\n \n-        + store_esp_to_rust_sp()\n-        + load_esp_from_runtime_sp()\n+        + store_esp_to_rust_sp_second_arg()\n+        + load_esp_from_runtime_sp_second_arg()\n \n         + vec(\"subl  $\" + wstr(n_args + 1) + \", %esp   # esp -= args\",\n-              \"andl  $~0xf, %esp    # align esp down\",\n-              \"movl  %ecx, (%esp)   # arg[0] = rust_task \")\n+              \"andl  $~0xf, %esp    # align esp down\")\n \n-        + _vec.init_fn[str](carg, n_args as uint)\n+        + _vec.init_fn[str](carg, (n_args + 1) as uint)\n \n-        +  vec(\"movl  %ecx, %edi     # save task from ecx to edi\",\n-               \"call  *%edx          # call *%edx\",\n-               \"movl  %edi, %ecx     # restore edi-saved task to ecx\")\n+        +  vec(\"movl  %edx, %edi     # save task from edx to edi\",\n+               \"call  *%ecx          # call *%ecx\",\n+               \"movl  %edi, %edx     # restore edi-saved task to edx\")\n \n-        + load_esp_from_rust_sp()\n+        + load_esp_from_rust_sp_second_arg()\n         + restore_callee_saves()\n         + vec(\"ret\");\n \n@@ -254,6 +273,16 @@ fn get_module_asm() -> str {\n     ret _str.connect(glues, \"\\n\\n\");\n }\n \n+fn get_meta_sect_name() -> str {\n+    if (_str.eq(target_os(), \"macos\")) {\n+        ret \"__DATA,__note.rustc\";\n+    }\n+    if (_str.eq(target_os(), \"win32\")) {\n+        ret \".note.rustc\";\n+    }\n+    ret \".note.rustc\";\n+}\n+\n fn get_data_layout() -> str {\n     if (_str.eq(target_os(), \"macos\")) {\n       ret \"e-p:32:32-f64:32:64-i64:32:64-f80:128:128-n8:16:32\";"}, {"sha": "00d41fff42d8ef95548198baf382e063e77efe8e", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -54,7 +54,8 @@ impure fn compile_input(session.session sess,\n                         eval.env env,\n                         str input, str output,\n                         bool shared) {\n-    auto p = parser.new_parser(sess, env, 0, input);\n+    auto def = tup(0, 0);\n+    auto p = parser.new_parser(sess, env, def, input);\n     auto crate = parse_input(sess, p, input);\n     crate = resolve.resolve_crate(sess, crate);\n     crate = typeck.check_crate(sess, crate);\n@@ -64,9 +65,10 @@ impure fn compile_input(session.session sess,\n impure fn pretty_print_input(session.session sess,\n                              eval.env env,\n                              str input) {\n-    auto p = front.parser.new_parser(sess, env, 0, input);\n+    auto def = tup(0, 0);\n+    auto p = front.parser.new_parser(sess, env, def, input);\n     auto crate = front.parser.parse_crate_from_source_file(p);\n-    pretty.pprust.print_ast(crate.node.module);\n+    pretty.pprust.print_ast(crate.node.module, std.io.stdout_writer());\n }\n \n fn warn_wrong_compiler() {\n@@ -82,6 +84,7 @@ fn usage(session.session sess, str argv0) {\n     log \"\";\n     log \"    -o <filename>      write output to <filename>\";\n     log \"    -nowarn            suppress wrong-compiler warning\";\n+    log \"    -glue              generate glue.bc file\";\n     log \"    -shared            compile a shared-library crate\";\n     log \"    -pp                pretty-print the input instead of compiling\";\n     log \"    -h                 display this message\";\n@@ -111,6 +114,7 @@ impure fn main(vec[str] args) {\n     let bool do_warn = true;\n     let bool shared = false;\n     let bool pretty = false;\n+    let bool glue = false;\n \n     auto i = 1u;\n     auto len = _vec.len[str](args);\n@@ -121,6 +125,8 @@ impure fn main(vec[str] args) {\n         if (_str.byte_len(arg) > 0u && arg.(0) == '-' as u8) {\n             if (_str.eq(arg, \"-nowarn\")) {\n                 do_warn = false;\n+            } else if (_str.eq(arg, \"-glue\")) {\n+                glue = true;\n             } else if (_str.eq(arg, \"-shared\")) {\n                 shared = true;\n             } else if (_str.eq(arg, \"-pp\")) {\n@@ -157,6 +163,18 @@ impure fn main(vec[str] args) {\n         warn_wrong_compiler();\n     }\n \n+    if (glue) {\n+        alt (output_file) {\n+            case (none[str]) {\n+                middle.trans.make_common_glue(\"glue.bc\");\n+            }\n+            case (some[str](?s)) {\n+                middle.trans.make_common_glue(s);\n+            }\n+        }\n+        ret;\n+    }\n+\n     alt (input_file) {\n         case (none[str]) {\n             usage(sess, args.(0));"}, {"sha": "59a928be88a8624aa5e7a95d6e15ea4153d60345", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -21,17 +21,19 @@ type ty_param = rec(ident ident, def_id id);\n // Annotations added during successive passes.\n tag ann {\n     ann_none;\n-    ann_type(@middle.ty.t);\n+    ann_type(@middle.ty.t, option.t[vec[@middle.ty.t]] /* ty param substs */);\n }\n \n tag def {\n     def_fn(def_id);\n     def_obj(def_id);\n     def_obj_field(def_id);\n     def_mod(def_id);\n+    def_native_mod(def_id);\n     def_const(def_id);\n     def_arg(def_id);\n     def_local(def_id);\n+    def_upvar(def_id);\n     def_variant(def_id /* tag */, def_id /* variant */);\n     def_ty(def_id);\n     def_ty_arg(def_id);\n@@ -42,7 +44,8 @@ tag def {\n }\n \n type crate = spanned[crate_];\n-type crate_ = rec(_mod module);\n+type crate_ = rec(vec[@crate_directive] directives,\n+                  _mod module);\n \n tag crate_directive_ {\n     cdir_expr(@expr);\n@@ -64,9 +67,15 @@ type meta_item = spanned[meta_item_];\n type meta_item_ = rec(ident name, str value);\n \n type block = spanned[block_];\n+type block_index = hashmap[ident, block_index_entry];\n+tag block_index_entry {\n+    bie_item(@item);\n+    bie_local(@local);\n+    bie_tag_variant(@item /* tag item */, uint /* variant index */);\n+}\n type block_ = rec(vec[@stmt] stmts,\n                   option.t[@expr] expr,\n-                  hashmap[ident,uint] index);\n+                  hashmap[ident,block_index_entry] index);\n \n type variant_def = tup(def_id /* tag */, def_id /* variant */);\n \n@@ -427,6 +436,44 @@ fn index_native_view_item(native_mod_index index, @view_item it) {\n     }\n }\n \n+fn index_stmt(block_index index, @stmt s) {\n+    alt (s.node) {\n+        case (ast.stmt_decl(?d)) {\n+            alt (d.node) {\n+                case (ast.decl_local(?loc)) {\n+                    index.insert(loc.ident, ast.bie_local(loc));\n+                }\n+                case (ast.decl_item(?it)) {\n+                    alt (it.node) {\n+                        case (ast.item_fn(?i, _, _, _, _)) {\n+                            index.insert(i, ast.bie_item(it));\n+                        }\n+                        case (ast.item_mod(?i, _, _)) {\n+                            index.insert(i, ast.bie_item(it));\n+                        }\n+                        case (ast.item_ty(?i, _, _, _, _)) {\n+                            index.insert(i, ast.bie_item(it));\n+                        }\n+                        case (ast.item_tag(?i, ?variants, _, _)) {\n+                            index.insert(i, ast.bie_item(it));\n+                            let uint vid = 0u;\n+                            for (ast.variant v in variants) {\n+                                auto t = ast.bie_tag_variant(it, vid);\n+                                index.insert(v.name, t);\n+                                vid += 1u;\n+                            }\n+                        }\n+                        case (ast.item_obj(?i, _, _, _, _)) {\n+                            index.insert(i, ast.bie_item(it));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        case (_) { /* fall through */ }\n+    }\n+}\n+\n fn is_call_expr(@expr e) -> bool {\n     alt (e.node) {\n         case (expr_call(_, _, _)) {"}, {"sha": "21a764df061410b203ee73a1e99d5d292a5107e8", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -42,7 +42,7 @@ fn val_is_bool(val v) -> bool {\n \n fn val_is_int(val v) -> bool {\n     alt (v) {\n-        case (val_bool(_)) { ret true; }\n+        case (val_int(_)) { ret true; }\n         case (_) { }\n     }\n     ret false;\n@@ -386,9 +386,12 @@ impure fn eval_crate_directive(parser p,\n \n             auto full_path = prefix + std.os.path_sep() + file_path;\n \n-            auto p0 = new_parser(p.get_session(), e, 0, full_path);\n+            auto start_id = p.next_def_id();\n+            auto p0 = new_parser(p.get_session(), e, start_id, full_path);\n             auto m0 = parse_mod_items(p0, token.EOF);\n-            auto im = ast.item_mod(id, m0, p.next_def_id());\n+            auto next_id = p0.next_def_id();\n+            p.set_def(next_id._1);\n+            auto im = ast.item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span, cdir.span, im);\n             ast.index_item(index, i);\n             append[@ast.item](items, i);"}, {"sha": "653e45a1ebf076a0e29f12b9e822fc77ab97162c", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -35,12 +35,13 @@ state type parser =\n           fn get_session() -> session.session;\n           fn get_span() -> common.span;\n           fn next_def_id() -> ast.def_id;\n+          fn set_def(ast.def_num);\n           fn get_prec_table() -> vec[op_spec];\n     };\n \n impure fn new_parser(session.session sess,\n                      eval.env env,\n-                     ast.crate_num crate,\n+                     ast.def_id initial_def,\n                      str path) -> parser {\n     state obj stdio_parser(session.session sess,\n                            eval.env env,\n@@ -94,6 +95,10 @@ impure fn new_parser(session.session sess,\n                 ret tup(crate, def);\n             }\n \n+            fn set_def(ast.def_num d) {\n+                def = d;\n+            }\n+\n             fn get_file_type() -> file_type {\n                 ret ftype;\n             }\n@@ -114,8 +119,8 @@ impure fn new_parser(session.session sess,\n     auto rdr = lexer.new_reader(srdr, path);\n     auto npos = rdr.get_curr_pos();\n     ret stdio_parser(sess, env, ftype, lexer.next_token(rdr),\n-                     npos, npos, 0, UNRESTRICTED, crate, rdr,\n-                     prec_table());\n+                     npos, npos, initial_def._1, UNRESTRICTED, initial_def._0,\n+                     rdr, prec_table());\n }\n \n impure fn unexpected(parser p, token.token t) {\n@@ -1465,39 +1470,9 @@ impure fn parse_source_stmt(parser p) -> @ast.stmt {\n }\n \n fn index_block(vec[@ast.stmt] stmts, option.t[@ast.expr] expr) -> ast.block_ {\n-    auto index = new_str_hash[uint]();\n-    auto u = 0u;\n+    auto index = new_str_hash[ast.block_index_entry]();\n     for (@ast.stmt s in stmts) {\n-        alt (s.node) {\n-            case (ast.stmt_decl(?d)) {\n-                alt (d.node) {\n-                    case (ast.decl_local(?loc)) {\n-                        index.insert(loc.ident, u);\n-                    }\n-                    case (ast.decl_item(?it)) {\n-                        alt (it.node) {\n-                            case (ast.item_fn(?i, _, _, _, _)) {\n-                                index.insert(i, u);\n-                            }\n-                            case (ast.item_mod(?i, _, _)) {\n-                                index.insert(i, u);\n-                            }\n-                            case (ast.item_ty(?i, _, _, _, _)) {\n-                                index.insert(i, u);\n-                            }\n-                            case (ast.item_tag(?i, _, _, _)) {\n-                                index.insert(i, u);\n-                            }\n-                            case (ast.item_obj(?i, _, _, _, _)) {\n-                                index.insert(i, u);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            case (_) { /* fall through */ }\n-        }\n-        u += 1u;\n+        ast.index_stmt(index, s);\n     }\n     ret rec(stmts=stmts, expr=expr, index=index);\n }\n@@ -2261,7 +2236,9 @@ impure fn parse_crate_from_source_file(parser p) -> @ast.crate {\n     auto lo = p.get_span();\n     auto hi = lo;\n     auto m = parse_mod_items(p, token.EOF);\n-    ret @spanned(lo, hi, rec(module=m));\n+    let vec[@ast.crate_directive] cdirs = vec();\n+    ret @spanned(lo, hi, rec(directives=cdirs,\n+                             module=m));\n }\n \n // Logic for parsing crate files (.rc)\n@@ -2276,8 +2253,6 @@ impure fn parse_crate_directive(parser p) -> ast.crate_directive\n     auto hi = lo;\n     alt (p.peek()) {\n         case (token.AUTH) {\n-            // FIXME: currently dropping auth clauses on the floor,\n-            // as there is no effect-checking pass.\n             p.bump();\n             auto n = parse_path(p, GREEDY);\n             expect(p, token.EQ);\n@@ -2288,8 +2263,6 @@ impure fn parse_crate_directive(parser p) -> ast.crate_directive\n         }\n \n         case (token.META) {\n-            // FIXME: currently dropping meta clauses on the floor,\n-            // as there is no crate metadata system\n             p.bump();\n             auto mis = parse_meta(p);\n             hi = p.get_span();\n@@ -2398,7 +2371,8 @@ impure fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n                                                cdirs, prefix);\n     hi = p.get_span();\n     expect(p, token.EOF);\n-    ret @spanned(lo, hi, rec(module=m));\n+    ret @spanned(lo, hi, rec(directives=cdirs,\n+                             module=m));\n }\n \n "}, {"sha": "2fd58126cee9f12abe24dafdd5f3904b9465a28c", "filename": "src/comp/front/pretty.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2a662944a4d87c6d82299a181996ba14170b2ebb/src%2Fcomp%2Ffront%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a662944a4d87c6d82299a181996ba14170b2ebb/src%2Fcomp%2Ffront%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fpretty.rs?ref=2a662944a4d87c6d82299a181996ba14170b2ebb", "patch": "@@ -1,87 +0,0 @@\n-import std._int;\n-import std._str;\n-import std._uint;\n-import std._vec;\n-\n-export print_expr;\n-\n-// FIXME this is superseded by ../pretty/pprust.rs. can it be dropped?\n-\n-fn unknown() -> str {\n-    ret \"<unknown ast node>\";\n-}\n-\n-fn print_expr(@ast.expr expr) -> str {\n-    alt (expr.node) {\n-        case (ast.expr_lit(?lit, _)) {\n-            ret print_lit(lit);\n-        }\n-        case (ast.expr_binary(?op, ?lhs, ?rhs, _)) {\n-            ret print_expr_binary(op, lhs, rhs);\n-        }\n-        case (ast.expr_call(?path, ?args, _)) {\n-            ret print_expr_call(path, args);\n-        }\n-        case (ast.expr_path(?path, _, _)) {\n-            ret print_path(path);\n-        }\n-        case (_) {\n-            ret unknown();\n-        }\n-    }\n-}\n-\n-fn print_lit(@ast.lit lit) -> str {\n-    alt (lit.node) {\n-        case (ast.lit_str(?s)) {\n-            ret \"\\\"\" + s + \"\\\"\";\n-        }\n-        case (ast.lit_int(?i)) {\n-            ret _int.to_str(i, 10u);\n-        }\n-        case (ast.lit_uint(?u)) {\n-            ret _uint.to_str(u, 10u);\n-        }\n-        case (_) {\n-            ret unknown();\n-        }\n-    }\n-}\n-\n-fn print_expr_binary(ast.binop op, @ast.expr lhs, @ast.expr rhs) -> str {\n-    alt (op) {\n-        case (ast.add) {\n-            auto l = print_expr(lhs);\n-            auto r = print_expr(rhs);\n-            ret l + \" + \" + r;\n-        }\n-    }\n-}\n-\n-fn print_expr_call(@ast.expr path_expr, vec[@ast.expr] args) -> str {\n-    auto s = print_expr(path_expr);\n-\n-    s += \"(\";\n-    fn print_expr_ref(&@ast.expr e) -> str { ret print_expr(e); }\n-    auto mapfn = print_expr_ref;\n-    auto argstrs = _vec.map[@ast.expr, str](mapfn, args);\n-    s += _str.connect(argstrs, \", \");\n-    s += \")\";\n-\n-    ret s;\n-}\n-\n-fn print_path(ast.path path) -> str {\n-    ret _str.connect(path.node.idents, \".\");\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "bbe6f84172bcd371bb3193313cf8c801ca8dd57b", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -253,6 +253,8 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, ident i, vec[ident] idents,\n          def_id id, option.t[def]) -> @view_item) fold_view_item_import,\n \n+     (fn(&ENV e, &span sp, ident i) -> @view_item) fold_view_item_export,\n+\n      // Additional nodes.\n      (fn(&ENV e, &span sp,\n          &ast.block_) -> block)                   fold_block,\n@@ -270,6 +272,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &ast.native_mod m) -> ast.native_mod) fold_native_mod,\n \n      (fn(&ENV e, &span sp,\n+         vec[@ast.crate_directive] cdirs,\n          &ast._mod m) -> @ast.crate)              fold_crate,\n \n      (fn(&ENV e,\n@@ -451,11 +454,14 @@ fn fold_pat[ENV](&ENV env, ast_fold[ENV] fld, @ast.pat p) -> @ast.pat {\n             ret fld.fold_pat_bind(env_, p.span, id, did, t);\n         }\n         case (ast.pat_tag(?path, ?pats, ?d, ?t)) {\n+            auto ppath = fold_path(env, fld, path);\n+\n             let vec[@ast.pat] ppats = vec();\n             for (@ast.pat pat in pats) {\n                 ppats += vec(fold_pat(env_, fld, pat));\n             }\n-            ret fld.fold_pat_tag(env_, p.span, path, ppats, d, t);\n+\n+            ret fld.fold_pat_tag(env_, p.span, ppath, ppats, d, t);\n         }\n     }\n }\n@@ -718,6 +724,7 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n \n fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n \n+    auto index = new_str_hash[ast.block_index_entry]();\n     let ENV env_ = fld.update_env_for_block(env, blk);\n \n     if (!fld.keep_going(env_)) {\n@@ -726,7 +733,9 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n \n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in blk.node.stmts) {\n-        append[@ast.stmt](stmts, fold_stmt[ENV](env_, fld, s));\n+        auto new_stmt = fold_stmt[ENV](env_, fld, s);\n+        append[@ast.stmt](stmts, new_stmt);\n+        ast.index_stmt(index, new_stmt);\n     }\n \n     auto expr = none[@ast.expr];\n@@ -739,8 +748,7 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n         }\n     }\n \n-    // FIXME: should we reindex?\n-    ret respan(blk.span, rec(stmts=stmts, expr=expr, index=blk.node.index));\n+    ret respan(blk.span, rec(stmts=stmts, expr=expr, index=index));\n }\n \n fn fold_arm[ENV](&ENV env, ast_fold[ENV] fld, &arm a) -> arm {\n@@ -838,6 +846,10 @@ fn fold_view_item[ENV](&ENV env, ast_fold[ENV] fld, @view_item vi)\n             ret fld.fold_view_item_import(env_, vi.span, def_ident, idents,\n                                           def_id, target_def);\n         }\n+\n+        case (ast.view_item_export(?def_ident)) {\n+            ret fld.fold_view_item_export(env_, vi.span, def_ident);\n+        }\n     }\n \n     fail;\n@@ -969,9 +981,12 @@ fn fold_native_mod[ENV](&ENV e, ast_fold[ENV] fld,\n }\n \n fn fold_crate[ENV](&ENV env, ast_fold[ENV] fld, @ast.crate c) -> @ast.crate {\n+    // FIXME: possibly fold the directives so you process any expressions\n+    // within them? Not clear. After front/eval.rs, nothing else should look\n+    // at crate directives.\n     let ENV env_ = fld.update_env_for_crate(env, c);\n     let ast._mod m = fold_mod[ENV](env_, fld, c.node.module);\n-    ret fld.fold_crate(env_, c.span, m);\n+    ret fld.fold_crate(env_, c.span, c.node.directives, m);\n }\n \n //// Identity folds.\n@@ -1324,6 +1339,11 @@ fn identity_fold_view_item_import[ENV](&ENV e, &span sp, ident i,\n     ret @respan(sp, ast.view_item_import(i, is, id, target_def));\n }\n \n+fn identity_fold_view_item_export[ENV](&ENV e, &span sp, ident i)\n+    -> @view_item {\n+    ret @respan(sp, ast.view_item_export(i));\n+}\n+\n // Additional identities.\n \n fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n@@ -1353,8 +1373,10 @@ fn identity_fold_native_mod[ENV](&ENV e,\n     ret m;\n }\n \n-fn identity_fold_crate[ENV](&ENV e, &span sp, &ast._mod m) -> @ast.crate {\n-    ret @respan(sp, rec(module=m));\n+fn identity_fold_crate[ENV](&ENV e, &span sp,\n+                            vec[@ast.crate_directive] cdirs,\n+                            &ast._mod m) -> @ast.crate {\n+    ret @respan(sp, rec(directives=cdirs, module=m));\n }\n \n fn identity_fold_obj[ENV](&ENV e,\n@@ -1501,13 +1523,15 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n              bind identity_fold_view_item_use[ENV](_,_,_,_,_),\n          fold_view_item_import =\n              bind identity_fold_view_item_import[ENV](_,_,_,_,_,_),\n+         fold_view_item_export =\n+             bind identity_fold_view_item_export[ENV](_,_,_),\n \n          fold_block = bind identity_fold_block[ENV](_,_,_),\n          fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n          fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_),\n          fold_mod = bind identity_fold_mod[ENV](_,_),\n          fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n-         fold_crate = bind identity_fold_crate[ENV](_,_,_),\n+         fold_crate = bind identity_fold_crate[ENV](_,_,_,_),\n          fold_obj = bind identity_fold_obj[ENV](_,_,_,_),\n \n          update_env_for_crate = bind identity_update_env_for_crate[ENV](_,_),"}, {"sha": "433d7147024b4f193f483a79c69ad32e0f27d2b2", "filename": "src/comp/middle/metadata.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,29 @@\n+import std._str;\n+import front.ast;\n+import middle.trans;\n+import back.x86;\n+\n+import lib.llvm.llvm;\n+import lib.llvm.llvm.ValueRef;\n+import lib.llvm.False;\n+\n+// Returns a Plain Old LLVM String.\n+fn C_postr(str s) -> ValueRef {\n+    ret llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n+}\n+\n+fn collect_meta_directives(@trans.crate_ctxt cx, @ast.crate crate)\n+        -> ValueRef {\n+    ret C_postr(\"Hello world!\");    // TODO\n+}\n+\n+fn write_metadata(@trans.crate_ctxt cx, @ast.crate crate) {\n+    auto llmeta = collect_meta_directives(cx, crate);\n+\n+    auto llconst = trans.C_struct(vec(llmeta));\n+    auto llglobal = llvm.LLVMAddGlobal(cx.llmod, trans.val_ty(llconst),\n+                                       _str.buf(\"rust_metadata\"));\n+    llvm.LLVMSetInitializer(llglobal, llconst);\n+    llvm.LLVMSetSection(llglobal, _str.buf(x86.get_meta_sect_name()));\n+}\n+"}, {"sha": "1079489e96b65edff3018d20afb7a3c06d23bd1a", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -71,6 +71,13 @@ fn unwrap_def(def_wrap d) -> def {\n                 }\n             }\n         }\n+        case (def_wrap_native_mod(?m)) {\n+            alt (m.node) {\n+                case (ast.item_native_mod(_, _, ?id)) {\n+                    ret ast.def_native_mod(id);\n+                }\n+            }\n+        }\n         case (def_wrap_other(?d)) {\n             ret d;\n         }\n@@ -335,6 +342,40 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n         ret none[def_wrap];\n     }\n \n+    fn found_tag(@ast.item item, uint variant_idx) -> def_wrap {\n+        alt (item.node) {\n+            case (ast.item_tag(_, ?variants, _, ?tid)) {\n+                auto vid = variants.(variant_idx).id;\n+                auto t = ast.def_variant(tid, vid);\n+                ret def_wrap_other(t);\n+            }\n+            case (_) {\n+                log \"tag item not actually a tag\";\n+                fail;\n+            }\n+        }\n+    }\n+\n+    fn check_block(ast.ident i, &ast.block_ b) -> option.t[def_wrap] {\n+        alt (b.index.find(i)) {\n+            case (some[ast.block_index_entry](?ix)) {\n+                alt(ix) {\n+                    case (ast.bie_item(?it)) {\n+                        ret some(found_def_item(it));\n+                    }\n+                    case (ast.bie_local(?l)) {\n+                        auto t = ast.def_local(l.id);\n+                        ret some(def_wrap_other(t));\n+                    }\n+                    case (ast.bie_tag_variant(?item, ?variant_idx)) {\n+                        ret some(found_tag(item, variant_idx));\n+                    }\n+                }\n+            }\n+            case (_) { ret none[def_wrap]; }\n+        }\n+    }\n+\n     fn in_scope(ast.ident i, &scope s) -> option.t[def_wrap] {\n         alt (s) {\n \n@@ -361,7 +402,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n                             }\n                         }\n                     }\n-                    case (ast.item_tag(_, _, ?ty_params, _)) {\n+                    case (ast.item_tag(_, ?variants, ?ty_params, ?tag_id)) {\n                         for (ast.ty_param tp in ty_params) {\n                             if (_str.eq(tp.ident, i)) {\n                                 auto t = ast.def_ty_arg(tp.id);\n@@ -407,13 +448,7 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             }\n \n             case (scope_block(?b)) {\n-                alt (b.node.index.find(i)) {\n-                    case (some[uint](?ix)) {\n-                        auto x = found_decl_stmt(b.node.stmts.(ix));\n-                        ret some(x);\n-                    }\n-                    case (_) { /* fall through */  }\n-                }\n+                ret check_block(i, b.node);\n             }\n \n             case (scope_arm(?a)) {"}, {"sha": "6dcfb5c0a04fd60283d6a225eb16639e201735f4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 725, "deletions": 264, "changes": 989, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -98,6 +98,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n+                         hashmap[ast.def_id, ValueRef] llupvars,\n                          hashmap[ast.def_id, ValueRef] lltydescs,\n                          @crate_ctxt ccx);\n \n@@ -387,6 +388,10 @@ fn T_closure_ptr(type_names tn,\n                  TypeRef lltarget_ty,\n                  TypeRef llbindings_ty,\n                  uint n_ty_params) -> TypeRef {\n+\n+    // NB: keep this in sync with code in trans_bind; we're making\n+    // an LLVM typeref structure that has the same \"shape\" as the ty.t\n+    // it constructs.\n     ret T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc(tn)),\n                                  lltarget_ty,\n                                  llbindings_ty,\n@@ -499,7 +504,8 @@ fn type_of_fn_full(@crate_ctxt cx,\n                    ast.proto proto,\n                    option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n-                   @ty.t output) -> TypeRef {\n+                   @ty.t output,\n+                   uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n \n     // Arg 0: Output pointer.\n@@ -525,10 +531,6 @@ fn type_of_fn_full(@crate_ctxt cx,\n \n     // Args >3: ty params, if not acquired via capture...\n     if (obj_self == none[TypeRef]) {\n-        auto ty_param_count =\n-            ty.count_ty_params(plain_ty(ty.ty_fn(proto,\n-                                                 inputs,\n-                                                 output)));\n         auto i = 0u;\n         while (i < ty_param_count) {\n             atys += T_ptr(T_tydesc(cx.tn));\n@@ -543,7 +545,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n         atys += T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n-                                          plain_ty(ty.ty_nil)));\n+                                          plain_ty(ty.ty_nil), 0u));\n     }\n \n     // ... then explicit args.\n@@ -554,8 +556,11 @@ fn type_of_fn_full(@crate_ctxt cx,\n \n fn type_of_fn(@crate_ctxt cx,\n               ast.proto proto,\n-              vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n-    ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output);\n+              vec[ty.arg] inputs,\n+              @ty.t output,\n+              uint ty_param_count) -> TypeRef {\n+    ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output,\n+                        ty_param_count);\n }\n \n fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n@@ -630,7 +635,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n             llty = T_struct(tys);\n         }\n         case (ty.ty_fn(?proto, ?args, ?out)) {\n-            llty = T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out));\n+            llty = T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out, 0u));\n         }\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n             llty = T_fn_pair(cx.tn, type_of_native_fn(cx, abi, args, out));\n@@ -644,7 +649,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n                 let TypeRef mty =\n                     type_of_fn_full(cx, m.proto,\n                                     some[TypeRef](self_ty),\n-                                    m.inputs, m.output);\n+                                    m.inputs, m.output, 0u);\n                 mtys += T_ptr(mty);\n             }\n             let TypeRef vtbl = T_struct(mtys);\n@@ -827,38 +832,51 @@ fn decl_upcall_glue(ModuleRef llmod, type_names tn, uint _n) -> ValueRef {\n     let int n = _n as int;\n     let str s = abi.upcall_glue_name(n);\n     let vec[TypeRef] args =\n-        vec(T_taskptr(tn), // taskptr\n-            T_int())     // callee\n+        vec(T_int(),     // callee\n+            T_int()) // taskptr\n         + _vec.init_elt[TypeRef](T_int(), n as uint);\n \n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n \n-fn get_upcall(@crate_ctxt cx, str name, int n_args) -> ValueRef {\n-    if (cx.upcalls.contains_key(name)) {\n-        ret cx.upcalls.get(name);\n+fn get_upcall(&hashmap[str, ValueRef] upcalls,\n+              type_names tn, ModuleRef llmod,\n+              str name, int n_args) -> ValueRef {\n+    if (upcalls.contains_key(name)) {\n+        ret upcalls.get(name);\n     }\n-    auto inputs = vec(T_taskptr(cx.tn));\n+    auto inputs = vec(T_taskptr(tn));\n     inputs += _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n-    auto f = decl_cdecl_fn(cx.llmod, name, T_fn(inputs, output));\n-    cx.upcalls.insert(name, f);\n+    auto f = decl_cdecl_fn(llmod, name, T_fn(inputs, output));\n+    upcalls.insert(name, f);\n     ret f;\n }\n \n fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n+    auto cxx = cx.fcx.ccx;\n+    auto t = trans_upcall2(cx.build, cxx.glues, cx.fcx.lltaskptr,\n+                           cxx.upcalls, cxx.tn, cxx.llmod, name, args);\n+    ret res(cx, t);\n+}\n+\n+fn trans_upcall2(builder b, @glue_fns glues, ValueRef lltaskptr,\n+                 &hashmap[str, ValueRef] upcalls,\n+                 type_names tn, ModuleRef llmod, str name,\n+                 vec[ValueRef] args) -> ValueRef {\n     let int n = _vec.len[ValueRef](args) as int;\n-    let ValueRef llupcall = get_upcall(cx.fcx.ccx, name, n);\n+    let ValueRef llupcall = get_upcall(upcalls, tn, llmod, name, n);\n     llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n \n-    let ValueRef llglue = cx.fcx.ccx.glues.upcall_glues.(n);\n-    let vec[ValueRef] call_args = vec(cx.fcx.lltaskptr, llupcall);\n+    let ValueRef llglue = glues.upcall_glues.(n);\n+    let vec[ValueRef] call_args = vec(llupcall);\n+    call_args += b.PtrToInt(lltaskptr, T_int());\n \n     for (ValueRef a in args) {\n-        call_args += cx.build.ZExtOrBitCast(a, T_int());\n+        call_args += b.ZExtOrBitCast(a, T_int());\n     }\n \n-    ret res(cx, cx.build.FastCall(llglue, call_args));\n+    ret b.FastCall(llglue, call_args);\n }\n \n fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n@@ -885,6 +903,11 @@ fn umax(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n     ret cx.build.Select(cond, b, a);\n }\n \n+fn umin(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n+    auto cond = cx.build.ICmp(lib.llvm.LLVMIntULT, a, b);\n+    ret cx.build.Select(cond, a, b);\n+}\n+\n fn align_to(@block_ctxt cx, ValueRef off, ValueRef align) -> ValueRef {\n     auto mask = cx.build.Sub(align, C_int(1));\n     auto bumped = cx.build.Add(off, mask);\n@@ -942,13 +965,19 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n         }\n     }\n \n+    // Pull the type parameters out of the corresponding tag item.\n+    let vec[ast.ty_param] ty_params = tag_ty_params(cx, tid);\n+\n     // Compute max(variant sizes).\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n     for (ast.variant variant in variants) {\n         let vec[@ty.t] tys = variant_types(cx, variant);\n         auto tup_ty = ty.plain_ty(ty.ty_tup(tys));\n \n+        // Perform any type parameter substitutions.\n+        tup_ty = ty.substitute_ty_params(ty_params, subtys, tup_ty);\n+\n         // Here we possibly do a recursive call.\n         auto this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n \n@@ -1009,9 +1038,17 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             let ValueRef max_size = bcx.build.Alloca(T_int());\n             bcx.build.Store(C_int(0), max_size);\n \n+            auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n             auto variants = tag_variants(bcx.fcx.ccx, tid);\n             for (ast.variant variant in variants) {\n-                let vec[@ty.t] tys = variant_types(bcx.fcx.ccx, variant);\n+                // Perform type substitution on the raw variant types.\n+                let vec[@ty.t] raw_tys = variant_types(bcx.fcx.ccx, variant);\n+                let vec[@ty.t] tys = vec();\n+                for (@ty.t raw_ty in raw_tys) {\n+                    auto t = ty.substitute_ty_params(ty_params, tps, raw_ty);\n+                    tys += vec(t);\n+                }\n+\n                 auto rslt = align_elements(bcx, tys);\n                 bcx = rslt.bcx;\n \n@@ -1053,6 +1090,9 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n             }\n             ret res(bcx, a);\n         }\n+        case (ty.ty_tag(_, _)) {\n+            ret res(cx, C_int(1)); // FIXME: stub\n+        }\n     }\n }\n \n@@ -1163,18 +1203,27 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n // This function uses GEP_tup_like() above and automatically performs casts as\n // appropriate. @llblobptr is the data part of a tag value; its actual type is\n // meaningless, as it will be cast away.\n-fn GEP_tag(@block_ctxt cx, ValueRef llblobptr, &ast.variant variant, int ix)\n+fn GEP_tag(@block_ctxt cx,\n+           ValueRef llblobptr,\n+           &ast.def_id tag_id,\n+           &ast.def_id variant_id,\n+           vec[@ty.t] ty_substs,\n+           int ix)\n         -> result {\n+    auto ty_params = tag_ty_params(cx.fcx.ccx, tag_id);\n+    auto variant = tag_variant_with_id(cx.fcx.ccx, tag_id, variant_id);\n+\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n     auto arg_tys = arg_tys_of_fn(variant.ann);\n     auto elem_ty = ty.plain_ty(ty.ty_nil);  // typestate infelicity\n     auto i = 0;\n     let vec[@ty.t] true_arg_tys = vec();\n     for (ty.arg a in arg_tys) {\n-        true_arg_tys += vec(a.ty);\n+        auto arg_ty = ty.substitute_ty_params(ty_params, ty_substs, a.ty);\n+        true_arg_tys += vec(arg_ty);\n         if (i == ix) {\n-            elem_ty = a.ty;\n+            elem_ty = arg_ty;\n         }\n \n         i += 1;\n@@ -1685,11 +1734,15 @@ fn variant_types(@crate_ctxt cx, &ast.variant v) -> vec[@ty.t] {\n     ret tys;\n }\n \n-fn type_of_variant(@crate_ctxt cx, &ast.variant v) -> TypeRef {\n+fn type_of_variant(@crate_ctxt cx,\n+                   &ast.variant v,\n+                   vec[ast.ty_param] ty_params,\n+                   vec[@ty.t] ty_param_substs) -> TypeRef {\n     let vec[TypeRef] lltys = vec();\n     auto tys = variant_types(cx, v);\n     for (@ty.t typ in tys) {\n-        lltys += vec(type_of(cx, typ));\n+        auto typ2 = ty.substitute_ty_params(ty_params, ty_param_substs, typ);\n+        lltys += vec(type_of(cx, typ2));\n     }\n     ret T_struct(lltys);\n }\n@@ -1712,6 +1765,25 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[ast.variant] {\n     fail;   // not reached\n }\n \n+// Returns the tag variant with the given ID.\n+fn tag_variant_with_id(@crate_ctxt cx,\n+                       &ast.def_id tag_id,\n+                       &ast.def_id variant_id) -> ast.variant {\n+    auto variants = tag_variants(cx, tag_id);\n+\n+    auto i = 0u;\n+    while (i < _vec.len[ast.variant](variants)) {\n+        auto variant = variants.(i);\n+        if (common.def_eq(variant.id, variant_id)) {\n+            ret variant;\n+        }\n+        i += 1u;\n+    }\n+\n+    log \"tag_variant_with_id(): no variant exists with that ID\";\n+    fail;\n+}\n+\n // Returns a new plain tag type of the given ID with no type parameters. Don't\n // use this function in new code; it's a hack to keep things working for now.\n fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n@@ -1720,7 +1792,7 @@ fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n }\n \n \n-type val_fn = fn(@block_ctxt cx, ValueRef v) -> result;\n+type val_pair_fn = fn(@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n \n type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, @ty.t t) -> result;\n \n@@ -1805,12 +1877,21 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             auto variants = tag_variants(cx.fcx.ccx, tid);\n             auto n_variants = _vec.len[ast.variant](variants);\n \n-            auto lldiscrim_a_ptr = cx.build.GEP(av, vec(C_int(0), C_int(0)));\n-            auto llunion_a_ptr = cx.build.GEP(av, vec(C_int(0), C_int(1)));\n+            // Cast the tags to types we can GEP into.\n+            auto lltagty = T_opaque_tag_ptr(cx.fcx.ccx.tn);\n+            auto av_tag = cx.build.PointerCast(av, lltagty);\n+            auto bv_tag = cx.build.PointerCast(bv, lltagty);\n+\n+            auto lldiscrim_a_ptr = cx.build.GEP(av_tag,\n+                                                vec(C_int(0), C_int(0)));\n+            auto llunion_a_ptr = cx.build.GEP(av_tag,\n+                                              vec(C_int(0), C_int(1)));\n             auto lldiscrim_a = cx.build.Load(lldiscrim_a_ptr);\n \n-            auto lldiscrim_b_ptr = cx.build.GEP(bv, vec(C_int(0), C_int(0)));\n-            auto llunion_b_ptr = cx.build.GEP(bv, vec(C_int(0), C_int(1)));\n+            auto lldiscrim_b_ptr = cx.build.GEP(bv_tag,\n+                                                vec(C_int(0), C_int(0)));\n+            auto llunion_b_ptr = cx.build.GEP(bv_tag,\n+                                              vec(C_int(0), C_int(1)));\n             auto lldiscrim_b = cx.build.Load(lldiscrim_b_ptr);\n \n             // NB: we must hit the discriminant first so that structural\n@@ -1827,6 +1908,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n \n             auto next_cx = new_sub_block_ctxt(bcx, \"tag-iter-next\");\n \n+            auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n+\n             auto i = 0u;\n             for (ast.variant variant in variants) {\n                 auto variant_cx = new_sub_block_ctxt(bcx,\n@@ -1836,7 +1919,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n \n                 if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n                     // N-ary variant.\n-                    auto llvarty = type_of_variant(bcx.fcx.ccx, variants.(i));\n+                    auto llvarty = type_of_variant(bcx.fcx.ccx, variants.(i),\n+                                                   ty_params, tps);\n \n                     auto fn_ty = ty.ann_to_type(variants.(i).ann);\n                     alt (fn_ty.struct) {\n@@ -1847,8 +1931,6 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                             auto llvarp_b = variant_cx.build.\n                                 TruncOrBitCast(llunion_b_ptr, T_ptr(llvarty));\n \n-                            auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n-\n                             auto j = 0u;\n                             for (ty.arg a in args) {\n                                 auto v = vec(C_int(0), C_int(j as int));\n@@ -1923,13 +2005,15 @@ fn iter_structural_ty_full(@block_ctxt cx,\n \n // Iterates through a pointer range, until the src* hits the src_lim*.\n fn iter_sequence_raw(@block_ctxt cx,\n+                     ValueRef dst,     // elt*\n                      ValueRef src,     // elt*\n                      ValueRef src_lim, // elt*\n                      ValueRef elt_sz,\n-                     val_fn f) -> result {\n+                     val_pair_fn f) -> result {\n \n     auto bcx = cx;\n \n+    let ValueRef dst_int = vp2i(bcx, dst);\n     let ValueRef src_int = vp2i(bcx, src);\n     let ValueRef src_lim_int = vp2i(bcx, src_lim);\n \n@@ -1939,6 +2023,8 @@ fn iter_sequence_raw(@block_ctxt cx,\n \n     bcx.build.Br(cond_cx.llbb);\n \n+    let ValueRef dst_curr = cond_cx.build.Phi(T_int(),\n+                                              vec(dst_int), vec(bcx.llbb));\n     let ValueRef src_curr = cond_cx.build.Phi(T_int(),\n                                               vec(src_int), vec(bcx.llbb));\n \n@@ -1947,14 +2033,18 @@ fn iter_sequence_raw(@block_ctxt cx,\n \n     cond_cx.build.CondBr(end_test, body_cx.llbb, next_cx.llbb);\n \n+    auto dst_curr_ptr = vi2p(body_cx, dst_curr, T_ptr(T_i8()));\n     auto src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(T_i8()));\n \n-    auto body_res = f(body_cx, src_curr_ptr);\n+    auto body_res = f(body_cx, dst_curr_ptr, src_curr_ptr);\n     body_cx = body_res.bcx;\n \n+    auto dst_next = body_cx.build.Add(dst_curr, elt_sz);\n     auto src_next = body_cx.build.Add(src_curr, elt_sz);\n     body_cx.build.Br(cond_cx.llbb);\n \n+    cond_cx.build.AddIncomingToPhi(dst_curr, vec(dst_next),\n+                                   vec(body_cx.llbb));\n     cond_cx.build.AddIncomingToPhi(src_curr, vec(src_next),\n                                    vec(body_cx.llbb));\n \n@@ -1970,15 +2060,16 @@ fn iter_sequence_inner(@block_ctxt cx,\n     fn adaptor_fn(val_and_ty_fn f,\n                   @ty.t elt_ty,\n                   @block_ctxt cx,\n-                  ValueRef v) -> result {\n+                  ValueRef dst,\n+                  ValueRef src) -> result {\n         auto llty = type_of(cx.fcx.ccx, elt_ty);\n-        auto p = cx.build.PointerCast(v, T_ptr(llty));\n+        auto p = cx.build.PointerCast(src, T_ptr(llty));\n         ret f(cx, load_scalar_or_boxed(cx, p, elt_ty), elt_ty);\n     }\n \n     auto elt_sz = size_of(cx, elt_ty);\n-    be iter_sequence_raw(elt_sz.bcx, src, src_lim, elt_sz.val,\n-                         bind adaptor_fn(f, elt_ty, _, _));\n+    be iter_sequence_raw(elt_sz.bcx, src, src, src_lim, elt_sz.val,\n+                         bind adaptor_fn(f, elt_ty, _, _, _));\n }\n \n \n@@ -2222,12 +2313,30 @@ fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @ty.t {\n         case (ast.ann_none) {\n             cx.sess.bug(\"missing type annotation\");\n         }\n-        case (ast.ann_type(?t)) {\n+        case (ast.ann_type(?t, _)) {\n             ret target_type(cx, t);\n         }\n     }\n }\n \n+fn node_ann_ty_params(&ast.ann a) -> vec[@ty.t] {\n+    alt (a) {\n+        case (ast.ann_none) {\n+            log \"missing type annotation\";\n+            fail;\n+        }\n+        case (ast.ann_type(_, ?tps_opt)) {\n+            alt (tps_opt) {\n+                case (none[vec[@ty.t]]) {\n+                    log \"type annotation has no ty params\";\n+                    fail;\n+                }\n+                case (some[vec[@ty.t]](?tps)) { ret tps; }\n+            }\n+        }\n+    }\n+}\n+\n fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n     ret type_of(cx, node_ann_type(cx, a));\n }\n@@ -2296,13 +2405,27 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n     fail;\n }\n \n-fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n-                 ValueRef lhs, ValueRef rhs) -> result {\n+fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n+                 ValueRef lhs0, ValueRef rhs0) -> result {\n+\n+    auto cx = cx0;\n+\n+    auto lhs_r = autoderef(cx, lhs0, t0);\n+    auto lhs = lhs_r.val;\n+    cx = lhs_r.bcx;\n+\n+    auto rhs_r = autoderef(cx, rhs0, t0);\n+    auto rhs = rhs_r.val;\n+    cx = rhs_r.bcx;\n+\n+    auto t = autoderefed_ty(t0);\n \n     if (ty.type_is_scalar(t)) {\n         ret res(cx, trans_scalar_compare(cx, op, t, lhs, rhs));\n \n-    } else if (ty.type_is_structural(t)) {\n+    } else if (ty.type_is_structural(t)\n+               || ty.type_is_sequence(t)) {\n+\n         auto scx = new_sub_block_ctxt(cx, \"structural compare start\");\n         auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n         cx.build.Br(scx.llbb);\n@@ -2333,28 +2456,52 @@ fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n \n         auto flag = scx.build.Alloca(T_i1());\n \n-        alt (op) {\n-            // ==, <= and >= default to true if they find == all the way.\n-            case (ast.eq) { scx.build.Store(C_integral(1, T_i1()), flag); }\n-            case (ast.le) { scx.build.Store(C_integral(1, T_i1()), flag); }\n-            case (ast.ge) { scx.build.Store(C_integral(1, T_i1()), flag); }\n-            case (_) {\n-                // ==, <= and >= default to false if they find == all the way.\n-                scx.build.Store(C_integral(0, T_i1()), flag);\n+        if (ty.type_is_sequence(t)) {\n+\n+            // If we hit == all the way through the minimum-shared-length\n+            // section, default to judging the relative sequence lengths.\n+            auto len_cmp =\n+                trans_integral_compare(scx, op, plain_ty(ty.ty_uint),\n+                                       vec_fill(scx, lhs),\n+                                       vec_fill(scx, rhs));\n+            scx.build.Store(len_cmp, flag);\n+\n+        } else {\n+            auto T = C_integral(1, T_i1());\n+            auto F = C_integral(0, T_i1());\n+\n+            alt (op) {\n+                // ==, <= and >= default to true if they find == all the way.\n+                case (ast.eq) { scx.build.Store(T, flag); }\n+                case (ast.le) { scx.build.Store(T, flag); }\n+                case (ast.ge) { scx.build.Store(T, flag); }\n+                case (_) {\n+                    // < > default to false if they find == all the way.\n+                    scx.build.Store(F, flag);\n+                }\n+\n             }\n         }\n \n         fn inner(@block_ctxt last_cx,\n+                 bool load_inner,\n                  ValueRef flag,\n                  ast.binop op,\n                  @block_ctxt cx,\n-                 ValueRef av,\n-                 ValueRef bv,\n+                 ValueRef av0,\n+                 ValueRef bv0,\n                  @ty.t t) -> result {\n \n             auto cnt_cx = new_sub_block_ctxt(cx, \"continue comparison\");\n             auto stop_cx = new_sub_block_ctxt(cx, \"stop comparison\");\n \n+            auto av = av0;\n+            auto bv = bv0;\n+            if (load_inner) {\n+                av = load_scalar_or_boxed(cx, av, t);\n+                bv = load_scalar_or_boxed(cx, bv, t);\n+            }\n+\n             // First 'eq' comparison: if so, continue to next elts.\n             auto eq_r = trans_compare(cx, ast.eq, t, av, bv);\n             eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n@@ -2366,16 +2513,32 @@ fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n             ret res(cnt_cx, C_nil());\n         }\n \n-        auto r = iter_structural_ty_full(scx, lhs, rhs, t,\n-                                         bind inner(next, flag, op,\n-                                                    _, _, _, _));\n+        auto r;\n+        if (ty.type_is_structural(t)) {\n+            r = iter_structural_ty_full(scx, lhs, rhs, t,\n+                                        bind inner(next, false, flag, op,\n+                                                   _, _, _, _));\n+        } else {\n+            auto lhs_p0 = vec_p0(scx, lhs);\n+            auto rhs_p0 = vec_p0(scx, rhs);\n+            auto min_len = umin(scx, vec_fill(scx, lhs), vec_fill(scx, rhs));\n+            auto rhs_lim = scx.build.GEP(rhs_p0, vec(min_len));\n+            auto elt_ty = ty.sequence_element_type(t);\n+            auto elt_llsz_r = size_of(scx, elt_ty);\n+            scx = elt_llsz_r.bcx;\n+            r = iter_sequence_raw(scx, lhs, rhs, rhs_lim,\n+                                  elt_llsz_r.val,\n+                                  bind inner(next, true, flag, op,\n+                                             _, _, _, elt_ty));\n+        }\n \n         r.bcx.build.Br(next.llbb);\n         auto v = next.build.Load(flag);\n         ret res(next, v);\n \n+\n     } else {\n-        // FIXME: compare vec, str, box?\n+        // FIXME: compare obj, fn by pointer?\n         cx.fcx.ccx.sess.unimpl(\"type in trans_compare\");\n         ret res(cx, C_bool(false));\n     }\n@@ -2732,6 +2895,62 @@ fn trans_for(@block_ctxt cx,\n                       bind inner(_, local, _, _, body));\n }\n \n+\n+// Iterator translation\n+\n+// Searches through a block for all references to locals or upvars in this\n+// frame and returns the list of definition IDs thus found.\n+fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n+        -> vec[ast.def_id] {\n+    type env = @rec(\n+        mutable vec[ast.def_id] refs,\n+        hashmap[ast.def_id,()] decls\n+    );\n+\n+    fn fold_expr_path(&env e, &common.span sp, &ast.path p,\n+                      &option.t[ast.def] d, ast.ann a) -> @ast.expr {\n+        alt (option.get[ast.def](d)) {\n+            case (ast.def_arg(?did))    { e.refs += vec(did);   }\n+            case (ast.def_local(?did))  { e.refs += vec(did);   }\n+            case (ast.def_upvar(?did))  { e.refs += vec(did);   }\n+            case (_)                    { /* ignore */          }\n+        }\n+\n+        ret @fold.respan[ast.expr_](sp, ast.expr_path(p, d, a));\n+    }\n+\n+    fn fold_decl_local(&env e, &common.span sp, @ast.local local)\n+            -> @ast.decl {\n+        e.decls.insert(local.id, ());\n+        ret @fold.respan[ast.decl_](sp, ast.decl_local(local));\n+    }\n+\n+    auto fep = fold_expr_path;\n+    auto fdl = fold_decl_local;\n+    auto fld = @rec(\n+        fold_expr_path=fep,\n+        fold_decl_local=fdl\n+        with *fold.new_identity_fold[env]()\n+    );\n+\n+    let vec[ast.def_id] refs = vec();\n+    let hashmap[ast.def_id,()] decls = new_def_hash[()]();\n+    decls.insert(initial_decl, ());\n+    let env e = @rec(mutable refs=refs, decls=decls);\n+\n+    fold.fold_block[env](e, fld, bloc);\n+\n+    // Calculate (refs - decls). This is the set of captured upvars.\n+    let vec[ast.def_id] result = vec();\n+    for (ast.def_id ref_id in e.refs) {\n+        if (!decls.contains_key(ref_id)) {\n+            result += vec(ref_id);\n+        }\n+    }\n+\n+    ret result;\n+}\n+\n fn trans_for_each(@block_ctxt cx,\n                   @ast.decl decl,\n                   @ast.expr seq,\n@@ -2763,19 +2982,63 @@ fn trans_for_each(@block_ctxt cx,\n     // escape. This could be determined upstream, and probably ought\n     // to be so, eventualy. For first cut, skip this. Null env.\n \n-    auto env_ty = T_opaque_closure_ptr(cx.fcx.ccx.tn);\n-\n-\n-    // Step 2: Declare foreach body function.\n-\n     // FIXME: possibly support alias-mode here?\n     auto decl_ty = plain_ty(ty.ty_nil);\n+    auto decl_id;\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n             decl_ty = node_ann_type(cx.fcx.ccx, local.ann);\n+            decl_id = local.id;\n         }\n     }\n \n+    auto upvars = collect_upvars(cx, body, decl_id);\n+    auto upvar_count = _vec.len[ast.def_id](upvars);\n+\n+    auto llbindingsptr;\n+    if (upvar_count > 0u) {\n+        // Gather up the upvars.\n+        let vec[ValueRef] llbindings = vec();\n+        let vec[TypeRef] llbindingtys = vec();\n+        for (ast.def_id did in upvars) {\n+            auto llbinding;\n+            alt (cx.fcx.lllocals.find(did)) {\n+                case (none[ValueRef]) {\n+                    llbinding = cx.fcx.llupvars.get(did);\n+                }\n+                case (some[ValueRef](?llval)) { llbinding = llval; }\n+            }\n+            llbindings += vec(llbinding);\n+            llbindingtys += vec(val_ty(llbinding));\n+        }\n+\n+        // Create an array of bindings and copy in aliases to the upvars.\n+        llbindingsptr = cx.build.Alloca(T_struct(llbindingtys));\n+        auto i = 0u;\n+        while (i < upvar_count) {\n+            auto llbindingptr = cx.build.GEP(llbindingsptr,\n+                                             vec(C_int(0), C_int(i as int)));\n+            cx.build.Store(llbindings.(i), llbindingptr);\n+            i += 1u;\n+        }\n+    } else {\n+        // Null bindings.\n+        llbindingsptr = C_null(T_ptr(T_i8()));\n+    }\n+\n+    // Create an environment and populate it with the bindings.\n+    auto llenvptrty = T_closure_ptr(cx.fcx.ccx.tn, T_ptr(T_nil()),\n+                                    val_ty(llbindingsptr), 0u);\n+    auto llenvptr = cx.build.Alloca(llvm.LLVMGetElementType(llenvptrty));\n+\n+    auto llbindingsptrptr = cx.build.GEP(llenvptr,\n+                                         vec(C_int(0),\n+                                             C_int(abi.box_rc_field_body),\n+                                             C_int(2)));\n+    cx.build.Store(llbindingsptr, llbindingsptrptr);\n+\n+    // Step 2: Declare foreach body function.\n+\n     let str s =\n         cx.fcx.ccx.names.next(\"_rust_foreach\")\n         + sep() + cx.fcx.ccx.path;\n@@ -2789,7 +3052,7 @@ fn trans_for_each(@block_ctxt cx,\n     auto iter_body_llty = type_of_fn_full(cx.fcx.ccx, ast.proto_fn,\n                                           none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=decl_ty)),\n-                                          plain_ty(ty.ty_nil));\n+                                          plain_ty(ty.ty_nil), 0u);\n \n     let ValueRef lliterbody = decl_fastcall_fn(cx.fcx.ccx.llmod,\n                                                s, iter_body_llty);\n@@ -2800,7 +3063,30 @@ fn trans_for_each(@block_ctxt cx,\n     auto fcx = new_fn_ctxt(cx.fcx.ccx, lliterbody);\n     auto bcx = new_top_block_ctxt(fcx);\n \n-    // FIXME: populate lllocals from llenv here.\n+    // Populate the upvars from the environment.\n+    auto llremoteenvptr = bcx.build.PointerCast(fcx.llenv, llenvptrty);\n+    auto llremotebindingsptrptr = bcx.build.GEP(llremoteenvptr,\n+        vec(C_int(0), C_int(abi.box_rc_field_body), C_int(2)));\n+    auto llremotebindingsptr = bcx.build.Load(llremotebindingsptrptr);\n+\n+    auto i = 0u;\n+    while (i < upvar_count) {\n+        auto upvar_id = upvars.(i);\n+        auto llupvarptrptr = bcx.build.GEP(llremotebindingsptr,\n+                                           vec(C_int(0), C_int(i as int)));\n+        auto llupvarptr = bcx.build.Load(llupvarptrptr);\n+        fcx.llupvars.insert(upvar_id, llupvarptr);\n+\n+        i += 1u;\n+    }\n+\n+    // Treat the loop variable as an upvar as well. We copy it to an alloca\n+    // as usual.\n+    auto lllvar = llvm.LLVMGetParam(fcx.llfn, 3u);\n+    auto lllvarptr = bcx.build.Alloca(val_ty(lllvar));\n+    bcx.build.Store(lllvar, lllvarptr);\n+    fcx.llupvars.insert(decl_id, lllvarptr);\n+\n     auto res = trans_block(bcx, body);\n     res.bcx.build.RetVoid();\n \n@@ -2818,6 +3104,12 @@ fn trans_for_each(@block_ctxt cx,\n                                               C_int(abi.fn_field_code)));\n             cx.build.Store(lliterbody, code_cell);\n \n+            auto env_cell = cx.build.GEP(pair, vec(C_int(0),\n+                                                   C_int(abi.fn_field_box)));\n+            auto llenvblobptr = cx.build.PointerCast(llenvptr,\n+                T_opaque_closure_ptr(cx.fcx.ccx.tn));\n+            cx.build.Store(llenvblobptr, env_cell);\n+\n             // log \"lliterbody: \" + val_str(cx.fcx.ccx.tn, lliterbody);\n             ret trans_call(cx, f,\n                            some[ValueRef](cx.build.Load(pair)),\n@@ -2840,9 +3132,9 @@ fn trans_while(@block_ctxt cx, @ast.expr cond,\n     auto cond_res = trans_expr(cond_cx, cond);\n \n     body_res.bcx.build.Br(cond_cx.llbb);\n-    cond_res.bcx.build.CondBr(cond_res.val,\n-                              body_cx.llbb,\n-                              next_cx.llbb);\n+\n+    auto cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n+    cond_bcx.build.CondBr(cond_res.val, body_cx.llbb, next_cx.llbb);\n \n     cx.build.Br(cond_cx.llbb);\n     ret res(next_cx, C_nil());\n@@ -2866,23 +3158,6 @@ fn trans_do_while(@block_ctxt cx, &ast.block body,\n \n // Pattern matching translation\n \n-// Returns a pointer to the union part of the LLVM representation of a tag\n-// type, cast to the appropriate type.\n-fn get_pat_union_ptr(@block_ctxt cx, vec[@ast.pat] subpats, ValueRef llval)\n-    -> ValueRef {\n-    auto llblobptr = cx.build.GEP(llval, vec(C_int(0), C_int(1)));\n-\n-    // Generate the union type.\n-    let vec[TypeRef] llsubpattys = vec();\n-    for (@ast.pat subpat in subpats) {\n-        llsubpattys += vec(type_of(cx.fcx.ccx, pat_ty(subpat)));\n-    }\n-\n-    // Recursively check subpatterns.\n-    auto llunionty = T_struct(llsubpattys);\n-    ret cx.build.TruncOrBitCast(llblobptr, T_ptr(llunionty));\n-}\n-\n fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                    @block_ctxt next_cx) -> result {\n     alt (pat.node) {\n@@ -2900,8 +3175,12 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n         }\n \n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n-            auto lltagptr = cx.build.GEP(llval, vec(C_int(0), C_int(0)));\n-            auto lltag = cx.build.Load(lltagptr);\n+            auto lltagptr = cx.build.PointerCast(llval,\n+                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+\n+            auto lldiscrimptr = cx.build.GEP(lltagptr,\n+                                             vec(C_int(0), C_int(0)));\n+            auto lldiscrim = cx.build.Load(lldiscrimptr);\n \n             auto vdef = option.get[ast.variant_def](vdef_opt);\n             auto variant_id = vdef._1;\n@@ -2920,18 +3199,22 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n             auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n \n-            auto lleq = cx.build.ICmp(lib.llvm.LLVMIntEQ, lltag,\n+            auto lleq = cx.build.ICmp(lib.llvm.LLVMIntEQ, lldiscrim,\n                                       C_int(variant_tag));\n             cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n \n+            auto ty_params = node_ann_ty_params(ann);\n+\n             if (_vec.len[@ast.pat](subpats) > 0u) {\n-                auto llunionptr = get_pat_union_ptr(matched_cx, subpats,\n-                                                    llval);\n+                auto llblobptr = matched_cx.build.GEP(lltagptr,\n+                    vec(C_int(0), C_int(1)));\n                 auto i = 0;\n                 for (@ast.pat subpat in subpats) {\n-                    auto llsubvalptr = matched_cx.build.GEP(llunionptr,\n-                                                            vec(C_int(0),\n-                                                                C_int(i)));\n+                    auto rslt = GEP_tag(matched_cx, llblobptr, vdef._0,\n+                                        vdef._1, ty_params, i);\n+                    auto llsubvalptr = rslt.val;\n+                    matched_cx = rslt.bcx;\n+\n                     auto llsubval = load_scalar_or_boxed(matched_cx,\n                                                          llsubvalptr,\n                                                          pat_ty(subpat));\n@@ -2955,25 +3238,38 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n         case (ast.pat_lit(_, _)) { ret res(cx, llval); }\n         case (ast.pat_bind(?id, ?def_id, ?ann)) {\n             auto ty = node_ann_type(cx.fcx.ccx, ann);\n-            auto llty = type_of(cx.fcx.ccx, ty);\n \n-            auto dst = cx.build.Alloca(llty);\n+            auto rslt = alloc_ty(cx, ty);\n+            auto dst = rslt.val;\n+            auto bcx = rslt.bcx;\n+\n             llvm.LLVMSetValueName(dst, _str.buf(id));\n-            cx.fcx.lllocals.insert(def_id, dst);\n-            cx.cleanups += clean(bind drop_slot(_, dst, ty));\n+            bcx.fcx.lllocals.insert(def_id, dst);\n+            bcx.cleanups += clean(bind drop_slot(_, dst, ty));\n \n-            ret copy_ty(cx, INIT, dst, llval, ty);\n+            ret copy_ty(bcx, INIT, dst, llval, ty);\n         }\n-        case (ast.pat_tag(_, ?subpats, _, _)) {\n+        case (ast.pat_tag(_, ?subpats, ?vdef_opt, ?ann)) {\n             if (_vec.len[@ast.pat](subpats) == 0u) { ret res(cx, llval); }\n \n-            auto llunionptr = get_pat_union_ptr(cx, subpats, llval);\n+            // Get the appropriate variant for this tag.\n+            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto variant = tag_variant_with_id(cx.fcx.ccx, vdef._0, vdef._1);\n+\n+            auto lltagptr = cx.build.PointerCast(llval,\n+                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+            auto llblobptr = cx.build.GEP(lltagptr, vec(C_int(0), C_int(1)));\n+\n+            auto ty_param_substs = node_ann_ty_params(ann);\n \n             auto this_cx = cx;\n             auto i = 0;\n             for (@ast.pat subpat in subpats) {\n-                auto llsubvalptr = this_cx.build.GEP(llunionptr,\n-                                                     vec(C_int(0), C_int(i)));\n+                auto rslt = GEP_tag(this_cx, llblobptr, vdef._0, vdef._1,\n+                                    ty_param_substs, i);\n+                this_cx = rslt.bcx;\n+                auto llsubvalptr = rslt.val;\n+\n                 auto llsubval = load_scalar_or_boxed(this_cx, llsubvalptr,\n                                                      pat_ty(subpat));\n                 auto subpat_res = trans_pat_binding(this_cx, subpat,\n@@ -3052,8 +3348,19 @@ fn lval_generic_fn(@block_ctxt cx,\n \n     check (cx.fcx.ccx.fn_pairs.contains_key(fn_id));\n     auto lv = lval_val(cx, cx.fcx.ccx.fn_pairs.get(fn_id));\n-    auto monoty = node_ann_type(cx.fcx.ccx, ann);\n-    auto tys = ty.resolve_ty_params(tpt, monoty);\n+\n+    auto monoty;\n+    auto tys;\n+    alt (ann) {\n+        case (ast.ann_none) {\n+            cx.fcx.ccx.sess.bug(\"no type annotation for path!\");\n+            fail;\n+        }\n+        case (ast.ann_type(?monoty_, ?tps)) {\n+            monoty = monoty_;\n+            tys = option.get[vec[@ty.t]](tps);\n+        }\n+    }\n \n     if (_vec.len[@ty.t](tys) != 0u) {\n         auto bcx = cx;\n@@ -3082,8 +3389,15 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     ret lval_mem(cx, cx.fcx.llargs.get(did));\n                 }\n                 case (ast.def_local(?did)) {\n-                    check (cx.fcx.lllocals.contains_key(did));\n-                    ret lval_mem(cx, cx.fcx.lllocals.get(did));\n+                    alt (cx.fcx.lllocals.find(did)) {\n+                        case (none[ValueRef]) {\n+                            check (cx.fcx.llupvars.contains_key(did));\n+                            ret lval_mem(cx, cx.fcx.llupvars.get(did));\n+                        }\n+                        case (some[ValueRef](?llval)) {\n+                            ret lval_mem(cx, llval);\n+                        }\n+                    }\n                 }\n                 case (ast.def_binding(?did)) {\n                     check (cx.fcx.lllocals.contains_key(did));\n@@ -3215,7 +3529,6 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n         ix_val = ix.val;\n     }\n \n-    auto llunit_ty = node_type(cx.fcx.ccx, ann);\n     auto unit_sz = size_of(bcx, node_ann_type(cx.fcx.ccx, ann));\n     bcx = unit_sz.bcx;\n \n@@ -3295,7 +3608,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                     @ty.t incoming_fty,\n                     @ty.t outgoing_fty,\n                     vec[option.t[@ast.expr]] args,\n-                    TypeRef llclosure_ty,\n+                    @ty.t closure_ty,\n                     vec[@ty.t] bound_tys,\n                     uint ty_param_count) -> ValueRef {\n     // Construct a thunk-call with signature incoming_fty, and that copies\n@@ -3308,27 +3621,21 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     auto fcx = new_fn_ctxt(cx, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n \n-    auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ty);\n-\n-    auto llbody = bcx.build.GEP(llclosure,\n-                                vec(C_int(0),\n-                                    C_int(abi.box_rc_field_body)));\n-\n-    auto lltarget = bcx.build.GEP(llbody,\n-                                  vec(C_int(0),\n-                                      C_int(abi.closure_elt_target)));\n-\n-    auto llbound = bcx.build.GEP(llbody,\n-                                 vec(C_int(0),\n-                                     C_int(abi.closure_elt_bindings)));\n+    auto llclosure_ptr_ty = type_of(cx, plain_ty(ty.ty_box(closure_ty)));\n+    auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n-    auto lltargetclosure = bcx.build.GEP(lltarget,\n+    auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n+                                 vec(0,\n+                                     abi.box_rc_field_body,\n+                                     abi.closure_elt_target));\n+    bcx = lltarget.bcx;\n+    auto lltargetclosure = bcx.build.GEP(lltarget.val,\n                                          vec(C_int(0),\n                                              C_int(abi.fn_field_box)));\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n \n     auto outgoing_ret_ty = ty.ty_fn_ret(outgoing_fty);\n-    auto outgoing_arg_tys = ty.ty_fn_args(outgoing_fty);\n+    auto outgoing_args = ty.ty_fn_args(outgoing_fty);\n \n     auto llretptr = fcx.llretptr;\n     if (ty.type_has_dynamic_size(outgoing_ret_ty)) {\n@@ -3343,51 +3650,84 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     let uint i = 0u;\n     while (i < ty_param_count) {\n         auto lltyparam_ptr =\n-            bcx.build.GEP(llbody, vec(C_int(0),\n-                                      C_int(abi.closure_elt_ty_params),\n-                                      C_int(i as int)));\n-        llargs += vec(bcx.build.Load(lltyparam_ptr));\n+            GEP_tup_like(bcx, closure_ty, llclosure,\n+                         vec(0,\n+                             abi.box_rc_field_body,\n+                             abi.closure_elt_ty_params,\n+                             (i as int)));\n+        bcx = lltyparam_ptr.bcx;\n+        llargs += vec(bcx.build.Load(lltyparam_ptr.val));\n         i += 1u;\n     }\n \n-    let uint a = 2u + i;    // retptr, task ptr, env come first\n+    let uint a = 3u;    // retptr, task ptr, env come first\n     let int b = 0;\n     let uint outgoing_arg_index = 0u;\n+    let vec[TypeRef] llout_arg_tys =\n+        type_of_explicit_args(cx, outgoing_args);\n+\n     for (option.t[@ast.expr] arg in args) {\n+\n+        auto out_arg = outgoing_args.(outgoing_arg_index);\n+        auto llout_arg_ty = llout_arg_tys.(outgoing_arg_index);\n+\n         alt (arg) {\n \n             // Arg provided at binding time; thunk copies it from closure.\n             case (some[@ast.expr](_)) {\n-                let ValueRef bound_arg = bcx.build.GEP(llbound,\n-                                                       vec(C_int(0),\n-                                                           C_int(b)));\n-                // FIXME: possibly support passing aliases someday.\n-                llargs += bcx.build.Load(bound_arg);\n+                auto bound_arg =\n+                    GEP_tup_like(bcx, closure_ty, llclosure,\n+                                 vec(0,\n+                                     abi.box_rc_field_body,\n+                                     abi.closure_elt_bindings,\n+                                     b));\n+\n+                bcx = bound_arg.bcx;\n+                auto val = bound_arg.val;\n+\n+                if (out_arg.mode == ast.val) {\n+                    val = bcx.build.Load(val);\n+                } else if (ty.count_ty_params(out_arg.ty) > 0u) {\n+                    check (out_arg.mode == ast.alias);\n+                    val = bcx.build.PointerCast(val, llout_arg_ty);\n+                }\n+\n+                llargs += val;\n                 b += 1;\n             }\n \n             // Arg will be provided when the thunk is invoked.\n             case (none[@ast.expr]) {\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n-                if (ty.type_has_dynamic_size(outgoing_arg_tys.\n-                        (outgoing_arg_index).ty)) {\n-                    // Cast to a generic typaram pointer in order to make a\n-                    // type-compatible call.\n+\n+                if (ty.count_ty_params(out_arg.ty) > 0u) {\n+                    check (out_arg.mode == ast.alias);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n-                                                       T_typaram_ptr(cx.tn));\n+                                                       llout_arg_ty);\n                 }\n+\n                 llargs += passed_arg;\n                 a += 1u;\n             }\n         }\n \n-        outgoing_arg_index += 0u;\n+        outgoing_arg_index += 1u;\n     }\n \n     // FIXME: turn this call + ret into a tail call.\n-    auto lltargetfn = bcx.build.GEP(lltarget,\n+    auto lltargetfn = bcx.build.GEP(lltarget.val,\n                                     vec(C_int(0),\n                                         C_int(abi.fn_field_code)));\n+\n+    // Cast the outgoing function to the appropriate type (see the comments in\n+    // trans_bind below for why this is necessary).\n+    auto lltargetty = type_of_fn(bcx.fcx.ccx,\n+                                 ty.ty_fn_proto(outgoing_fty),\n+                                 outgoing_args,\n+                                 outgoing_ret_ty,\n+                                 ty_param_count);\n+    lltargetfn = bcx.build.PointerCast(lltargetfn, T_ptr(T_ptr(lltargetty)));\n+\n     lltargetfn = bcx.build.Load(lltargetfn);\n \n     auto r = bcx.build.FastCall(lltargetfn, llargs);\n@@ -3452,21 +3792,26 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 i += 1u;\n             }\n \n-            // Get the type of the bound function.\n-            let TypeRef lltarget_ty = type_of(bcx.fcx.ccx, outgoing_fty);\n-\n             // Synthesize a closure type.\n             let @ty.t bindings_ty = plain_ty(ty.ty_tup(bound_tys));\n-            let TypeRef llbindings_ty = type_of(bcx.fcx.ccx, bindings_ty);\n-            let TypeRef llclosure_ty = T_closure_ptr(cx.fcx.ccx.tn,\n-                                                     lltarget_ty,\n-                                                     llbindings_ty,\n-                                                     ty_param_count);\n-\n-            // Malloc a box for the body.\n-            // FIXME: this isn't generic-safe\n-            auto r = trans_raw_malloc(bcx, llclosure_ty,\n-                llsize_of(llvm.LLVMGetElementType(llclosure_ty)));\n+\n+            // NB: keep this in sync with T_closure_ptr; we're making\n+            // a ty.t structure that has the same \"shape\" as the LLVM type\n+            // it constructs.\n+            let @ty.t tydesc_ty = plain_ty(ty.ty_type);\n+\n+            let vec[@ty.t] captured_tys =\n+                _vec.init_elt[@ty.t](tydesc_ty, ty_param_count);\n+\n+            let vec[@ty.t] closure_tys =\n+                vec(tydesc_ty,\n+                    outgoing_fty,\n+                    bindings_ty,\n+                    plain_ty(ty.ty_tup(captured_tys)));\n+\n+            let @ty.t closure_ty = plain_ty(ty.ty_tup(closure_tys));\n+\n+            auto r = trans_malloc_boxed(bcx, closure_ty);\n             auto box = r.val;\n             bcx = r.bcx;\n             auto rc = bcx.build.GEP(box,\n@@ -3487,12 +3832,26 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             bcx = bindings_tydesc.bcx;\n             bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n \n+            // Determine the LLVM type for the outgoing function type. This\n+            // may be different from the type returned by trans_malloc_boxed()\n+            // since we have more information than that function does;\n+            // specifically, we know how many type descriptors the outgoing\n+            // function has, which type_of() doesn't, as only we know which\n+            // item the function refers to.\n+            auto llfnty = type_of_fn(bcx.fcx.ccx,\n+                                     ty.ty_fn_proto(outgoing_fty),\n+                                     ty.ty_fn_args(outgoing_fty),\n+                                     ty.ty_fn_ret(outgoing_fty),\n+                                     ty_param_count);\n+            auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.ccx.tn, llfnty));\n+\n             // Store thunk-target.\n             auto bound_target =\n                 bcx.build.GEP(closure,\n                               vec(C_int(0),\n                                   C_int(abi.closure_elt_target)));\n             auto src = bcx.build.Load(f_res.res.val);\n+            bound_target = bcx.build.PointerCast(bound_target, llclosurety);\n             bcx.build.Store(src, bound_target);\n \n             // Copy expr values into boxed bindings.\n@@ -3525,6 +3884,8 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                         bcx.build.Store(td, ty_param_slot);\n                         i += 1;\n                     }\n+\n+                    outgoing_fty = ginfo.item_type;\n                 }\n             }\n \n@@ -3534,9 +3895,10 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                                                C_int(abi.fn_field_code)));\n \n             let @ty.t pair_ty = node_ann_type(cx.fcx.ccx, ann);\n+\n             let ValueRef llthunk =\n                 trans_bind_thunk(cx.fcx.ccx, pair_ty, outgoing_fty,\n-                                 args, llclosure_ty, bound_tys,\n+                                 args, closure_ty, bound_tys,\n                                  ty_param_count);\n \n             bcx.build.Store(llthunk, pair_code);\n@@ -3824,7 +4186,27 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n         bcx = src_res.bcx;\n         auto dst_res = GEP_tup_like(bcx, pseudo_tup_ty, body, vec(0, i));\n         bcx = dst_res.bcx;\n-        bcx = copy_ty(bcx, INIT, dst_res.val, src_res.val, unit_ty).bcx;\n+\n+        // Cast the destination type to the source type. This is needed to\n+        // make tags work, for a subtle combination of reasons:\n+        //\n+        // (1) \"dst_res\" above is derived from \"body\", which is in turn\n+        //     derived from \"vec_val\".\n+        // (2) \"vec_val\" has the LLVM type \"llty\".\n+        // (3) \"llty\" is the result of calling type_of() on a vector type.\n+        // (4) For tags, type_of() returns a different type depending on\n+        //     on whether the tag is behind a box or not. Vector types are\n+        //     considered boxes.\n+        // (5) \"src_res\" is derived from \"unit_ty\", which is not behind a box.\n+\n+        auto dst_val;\n+        if (!ty.type_has_dynamic_size(unit_ty)) {\n+            dst_val = bcx.build.PointerCast(dst_res.val, T_ptr(llunit_ty));\n+        } else {\n+            dst_val = dst_res.val;\n+        }\n+\n+        bcx = copy_ty(bcx, INIT, dst_val, src_res.val, unit_ty).bcx;\n         i += 1;\n     }\n     auto fill = bcx.build.GEP(vec_val,\n@@ -4108,10 +4490,19 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n         case (none[@ast.expr]) { }\n         case (some[@ast.expr](?x)) {\n             auto r = trans_expr(bcx, x);\n-            llargs += r.val;\n+\n+            auto llarg = r.val;\n             bcx = r.bcx;\n+            if (ty.type_is_structural(ty.expr_ty(x))) {\n+                // Until here we've been treating structures by pointer; we\n+                // are now passing it as an arg, so need to load it.\n+                llarg = bcx.build.Load(llarg);\n+            }\n+\n+            llargs += llarg;\n         }\n     }\n+\n     ret res(bcx, bcx.build.FastCall(llcallee, llargs));\n }\n \n@@ -4369,6 +4760,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n     let hashmap[ast.def_id, ValueRef] llargs = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] llobjfields = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n+    let hashmap[ast.def_id, ValueRef] llupvars = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] lltydescs = new_def_hash[ValueRef]();\n \n     ret @rec(llfn=llfndecl,\n@@ -4380,6 +4772,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n              llargs=llargs,\n              llobjfields=llobjfields,\n              lllocals=lllocals,\n+             llupvars=llupvars,\n              lltydescs=lltydescs,\n              ccx=cx);\n }\n@@ -4619,7 +5012,8 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx, proto,\n                                          some[TypeRef](self_ty),\n-                                         inputs, output);\n+                                         inputs, output,\n+                                         _vec.len[ast.ty_param](ty_params));\n             }\n         }\n \n@@ -4792,6 +5186,11 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n                               none[TypeRef], ret_ty_of_fn(variant.ann),\n                               fn_args, ty_params);\n \n+    let vec[@ty.t] ty_param_substs = vec();\n+    for (ast.ty_param tp in ty_params) {\n+        ty_param_substs += vec(plain_ty(ty.ty_param(tp.id)));\n+    }\n+\n     auto bcx = new_top_block_ctxt(fcx);\n \n     auto arg_tys = arg_tys_of_fn(variant.ann);\n@@ -4810,7 +5209,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n \n     i = 0u;\n     for (ast.variant_arg va in variant.args) {\n-        auto rslt = GEP_tag(bcx, llblobptr, variant, i as int);\n+        auto rslt = GEP_tag(bcx, llblobptr, tag_id, variant.id,\n+                            ty_param_substs, i as int);\n         bcx = rslt.bcx;\n         auto lldestptr = rslt.val;\n \n@@ -4822,7 +5222,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n \n         auto arg_ty = arg_tys.(i).ty;\n         auto llargval;\n-        if (ty.type_is_structural(arg_ty)) {\n+        if (ty.type_is_structural(arg_ty) ||\n+                ty.type_has_dynamic_size(arg_ty)) {\n             llargval = llargptr;\n         } else {\n             llargval = bcx.build.Load(llargptr);\n@@ -4918,11 +5319,23 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n fn decl_fn_and_pair(@crate_ctxt cx,\n                     str kind,\n                     str name,\n+                    vec[ast.ty_param] ty_params,\n                     &ast.ann ann,\n                     ast.def_id id) {\n \n-    auto llpairty = node_type(cx, ann);\n-    auto llfty = get_pair_fn_ty(llpairty);\n+    auto llfty;\n+    auto llpairty;\n+    alt (node_ann_type(cx, ann).struct) {\n+        case (ty.ty_fn(?proto, ?inputs, ?output)) {\n+            llfty = type_of_fn(cx, proto, inputs, output,\n+                               _vec.len[ast.ty_param](ty_params));\n+            llpairty = T_fn_pair(cx.tn, llfty);\n+        }\n+        case (_) {\n+            cx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type?!\");\n+            fail;\n+        }\n+    }\n \n     // Declare the function itself.\n     let str s = cx.names.next(\"_rust_\" + kind) + sep() + name;\n@@ -4951,11 +5364,29 @@ fn register_fn_pair(@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n     cx.fn_pairs.insert(id, gvar);\n }\n \n-fn native_fn_wrapper_type(@crate_ctxt cx, &ast.ann ann) -> TypeRef {\n+// Returns the number of type parameters that the given native function has.\n+fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n+    auto count;\n+    auto native_item = cx.native_items.get(id);\n+    alt (native_item.node) {\n+        case (ast.native_item_ty(_,_)) {\n+            cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \" +\n+                        \"actually a fn?!\");\n+            fail;\n+        }\n+        case (ast.native_item_fn(_, _, ?tps, _, _)) {\n+            count = _vec.len[ast.ty_param](tps);\n+        }\n+    }\n+    ret count;\n+}\n+\n+fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, &ast.ann ann)\n+        -> TypeRef {\n     auto x = node_ann_type(cx, ann);\n     alt (x.struct) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n-            ret type_of_fn(cx, ast.proto_fn, args, out);\n+            ret type_of_fn(cx, ast.proto_fn, args, out, ty_param_count);\n         }\n     }\n     fail;\n@@ -4965,8 +5396,10 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n                            str name,\n                            &ast.ann ann,\n                            ast.def_id id) {\n+    auto num_ty_param = native_fn_ty_param_count(cx, id);\n+\n     // Declare the wrapper.\n-    auto wrapper_type = native_fn_wrapper_type(cx, ann);\n+    auto wrapper_type = native_fn_wrapper_type(cx, num_ty_param, ann);\n     let str s = cx.names.next(\"_rust_wrapper\") + sep() + name;\n     let ValueRef wrapper_fn = decl_fastcall_fn(cx.llmod, s, wrapper_type);\n \n@@ -4991,7 +5424,6 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     alt (abi) {\n         case (ast.native_abi_rust) {\n             call_args += vec(fcx.lltaskptr);\n-            auto num_ty_param = ty.count_ty_params(plain_ty(fn_type.struct));\n             for each (uint i in _uint.range(0u, num_ty_param)) {\n                 auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n                 check (llarg as int != 0);\n@@ -5009,6 +5441,7 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n         call_args += vec(llarg);\n         arg_n += 1u;\n     }\n+\n     auto r = bcx.build.Call(function, call_args);\n     bcx.build.Store(r, fcx.llretptr);\n     bcx.build.RetVoid();\n@@ -5030,16 +5463,16 @@ fn collect_native_item(&@crate_ctxt cx, @ast.native_item i) -> @crate_ctxt {\n fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n \n     alt (i.node) {\n-        case (ast.item_fn(?name, ?f, _, ?fid, ?ann)) {\n+        case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             cx.items.insert(fid, i);\n             if (! cx.obj_methods.contains_key(fid)) {\n-                decl_fn_and_pair(cx, \"fn\", name, ann, fid);\n+                decl_fn_and_pair(cx, \"fn\", name, tps, ann, fid);\n             }\n         }\n \n-        case (ast.item_obj(?name, ?ob, _, ?oid, ?ann)) {\n+        case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             cx.items.insert(oid, i);\n-            decl_fn_and_pair(cx, \"obj_ctor\", name, ann, oid);\n+            decl_fn_and_pair(cx, \"obj_ctor\", name, tps, ann, oid);\n             for (@ast.method m in ob.methods) {\n                 cx.obj_methods.insert(m.node.id, ());\n             }\n@@ -5079,11 +5512,11 @@ fn collect_tag_ctor(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n \n     alt (i.node) {\n \n-        case (ast.item_tag(_, ?variants, _, _)) {\n+        case (ast.item_tag(_, ?variants, ?tps, _)) {\n             for (ast.variant variant in variants) {\n                 if (_vec.len[ast.variant_arg](variant.args) != 0u) {\n                     decl_fn_and_pair(cx, \"tag\", variant.name,\n-                                     variant.ann, variant.id);\n+                                     tps, variant.ann, variant.id);\n                 }\n             }\n         }\n@@ -5176,27 +5609,21 @@ fn i2p(ValueRef v, TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntToPtr(v, t);\n }\n \n-fn trans_exit_task_glue(@crate_ctxt cx) {\n+fn trans_exit_task_glue(@glue_fns glues,\n+                        &hashmap[str, ValueRef] upcalls,\n+                        type_names tn, ModuleRef llmod) {\n     let vec[TypeRef] T_args = vec();\n     let vec[ValueRef] V_args = vec();\n \n-    auto llfn = cx.glues.exit_task_glue;\n+    auto llfn = glues.exit_task_glue;\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 3u);\n-    auto fcx = @rec(llfn=llfn,\n-                    lltaskptr=lltaskptr,\n-                    llenv=C_null(T_opaque_closure_ptr(cx.tn)),\n-                    llretptr=C_null(T_ptr(T_nil())),\n-                    mutable llself=none[ValueRef],\n-                    mutable lliterbody=none[ValueRef],\n-                    llargs=new_def_hash[ValueRef](),\n-                    llobjfields=new_def_hash[ValueRef](),\n-                    lllocals=new_def_hash[ValueRef](),\n-                    lltydescs=new_def_hash[ValueRef](),\n-                    ccx=cx);\n \n-    auto bcx = new_top_block_ctxt(fcx);\n-    trans_upcall(bcx, \"upcall_exit\", V_args);\n-    bcx.build.RetVoid();\n+    auto entrybb = llvm.LLVMAppendBasicBlock(llfn, _str.buf(\"entry\"));\n+    auto build = new_builder(entrybb);\n+\n+    trans_upcall2(build, glues, lltaskptr,\n+                  upcalls, tn, llmod, \"upcall_exit\", V_args);\n+    build.RetVoid();\n }\n \n fn create_typedefs(@crate_ctxt cx) {\n@@ -5205,22 +5632,22 @@ fn create_typedefs(@crate_ctxt cx) {\n     llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n-fn create_crate_constant(@crate_ctxt cx) {\n+fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n \n-    let ValueRef crate_addr = p2i(cx.crate_ptr);\n+    let ValueRef crate_addr = p2i(crate_ptr);\n \n     let ValueRef activate_glue_off =\n-        llvm.LLVMConstSub(p2i(cx.glues.activate_glue), crate_addr);\n+        llvm.LLVMConstSub(p2i(glues.activate_glue), crate_addr);\n \n     let ValueRef yield_glue_off =\n-        llvm.LLVMConstSub(p2i(cx.glues.yield_glue), crate_addr);\n+        llvm.LLVMConstSub(p2i(glues.yield_glue), crate_addr);\n \n     let ValueRef exit_task_glue_off =\n-        llvm.LLVMConstSub(p2i(cx.glues.exit_task_glue), crate_addr);\n+        llvm.LLVMConstSub(p2i(glues.exit_task_glue), crate_addr);\n \n     let ValueRef crate_val =\n         C_struct(vec(C_null(T_int()),     // ptrdiff_t image_base_off\n-                     p2i(cx.crate_ptr),   // uintptr_t self_addr\n+                     p2i(crate_ptr),   // uintptr_t self_addr\n                      C_null(T_int()),     // ptrdiff_t debug_abbrev_off\n                      C_null(T_int()),     // size_t debug_abbrev_sz\n                      C_null(T_int()),     // ptrdiff_t debug_info_off\n@@ -5236,7 +5663,7 @@ fn create_crate_constant(@crate_ctxt cx) {\n                      C_int(abi.abi_x86_rustc_fastcall) // uintptr_t abi_tag\n                      ));\n \n-    llvm.LLVMSetInitializer(cx.crate_ptr, crate_val);\n+    llvm.LLVMSetInitializer(crate_ptr, crate_val);\n }\n \n fn find_main_fn(@crate_ctxt cx) -> ValueRef {\n@@ -5338,26 +5765,28 @@ fn check_module(ModuleRef llmod) {\n     // TODO: run the linter here also, once there are llvm-c bindings for it.\n }\n \n-fn make_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n+fn decl_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n     auto ty = T_fn(vec(T_taskptr(tn), T_ptr(T_i8())), T_void());\n-    auto fun = decl_fastcall_fn(llmod, abi.no_op_type_glue_name(), ty);\n+    ret decl_fastcall_fn(llmod, abi.no_op_type_glue_name(), ty);\n+}\n+\n+fn make_no_op_type_glue(ValueRef fun) {\n     auto bb_name = _str.buf(\"_rust_no_op_type_glue_bb\");\n     auto llbb = llvm.LLVMAppendBasicBlock(fun, bb_name);\n     new_builder(llbb).RetVoid();\n-    ret fun;\n }\n \n-fn make_memcpy_glue(ModuleRef llmod) -> ValueRef {\n-\n-    // We're not using the LLVM memcpy intrinsic. It appears to call through\n-    // to the platform memcpy in some cases, which is not terribly safe to run\n-    // on a rust stack.\n-\n+fn decl_memcpy_glue(ModuleRef llmod) -> ValueRef {\n     auto p8 = T_ptr(T_i8());\n \n     auto ty = T_fn(vec(p8, p8, T_int()), T_void());\n-    auto fun = decl_fastcall_fn(llmod, abi.memcpy_glue_name(), ty);\n+    ret decl_fastcall_fn(llmod, abi.memcpy_glue_name(), ty);\n+}\n \n+fn make_memcpy_glue(ValueRef fun) {\n+    // We're not using the LLVM memcpy intrinsic. It appears to call through\n+    // to the platform memcpy in some cases, which is not terribly safe to run\n+    // on a rust stack.\n     auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n     auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n     auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n@@ -5389,18 +5818,18 @@ fn make_memcpy_glue(ModuleRef llmod) -> ValueRef {\n     // End block\n     auto eb = new_builder(endbb);\n     eb.RetVoid();\n-    ret fun;\n }\n \n-fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n-\n-    // We're not using the LLVM memset intrinsic. Same as with memcpy.\n-\n+fn decl_bzero_glue(ModuleRef llmod) -> ValueRef {\n     auto p8 = T_ptr(T_i8());\n \n     auto ty = T_fn(vec(p8, T_int()), T_void());\n-    auto fun = decl_fastcall_fn(llmod, abi.bzero_glue_name(), ty);\n+    ret decl_fastcall_fn(llmod, abi.bzero_glue_name(), ty);\n+}\n \n+fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n+    // We're not using the LLVM memset intrinsic. Same as with memcpy.\n+    auto fun = decl_bzero_glue(llmod);\n     auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n     auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n     auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n@@ -5465,6 +5894,45 @@ fn make_vec_append_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n     ret llfn;\n }\n \n+\n+fn vec_fill(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+    ret bcx.build.Load(bcx.build.GEP(v, vec(C_int(0),\n+                                            C_int(abi.vec_elt_fill))));\n+}\n+\n+fn put_vec_fill(@block_ctxt bcx, ValueRef v, ValueRef fill) -> ValueRef {\n+    ret bcx.build.Store(fill,\n+                        bcx.build.GEP(v,\n+                                      vec(C_int(0),\n+                                          C_int(abi.vec_elt_fill))));\n+}\n+\n+fn vec_fill_adjusted(@block_ctxt bcx, ValueRef v,\n+                     ValueRef skipnull) -> ValueRef {\n+    auto f = bcx.build.Load(bcx.build.GEP(v,\n+                                          vec(C_int(0),\n+                                              C_int(abi.vec_elt_fill))));\n+    ret bcx.build.Select(skipnull, bcx.build.Sub(f, C_int(1)), f);\n+}\n+\n+fn vec_p0(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+    auto p = bcx.build.GEP(v, vec(C_int(0),\n+                                  C_int(abi.vec_elt_data)));\n+    ret bcx.build.PointerCast(p, T_ptr(T_i8()));\n+}\n+\n+\n+fn vec_p1(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+    auto len = vec_fill(bcx, v);\n+    ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n+}\n+\n+fn vec_p1_adjusted(@block_ctxt bcx, ValueRef v,\n+                   ValueRef skipnull) -> ValueRef {\n+    auto len = vec_fill_adjusted(bcx, v, skipnull);\n+    ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n+}\n+\n fn trans_vec_append_glue(@crate_ctxt cx) {\n \n     auto llfn = cx.glues.vec_append_glue;\n@@ -5485,6 +5953,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n+                    llupvars=new_def_hash[ValueRef](),\n                     lltydescs=new_def_hash[ValueRef](),\n                     ccx=cx);\n \n@@ -5495,45 +5964,6 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n     // First the dst vec needs to grow to accommodate the src vec.\n     // To do this we have to figure out how many bytes to add.\n \n-    fn vec_fill(@block_ctxt bcx, ValueRef v) -> ValueRef {\n-        ret bcx.build.Load(bcx.build.GEP(v, vec(C_int(0),\n-                                                C_int(abi.vec_elt_fill))));\n-    }\n-\n-    fn put_vec_fill(@block_ctxt bcx, ValueRef v, ValueRef fill) -> ValueRef {\n-        ret bcx.build.Store(fill,\n-                            bcx.build.GEP(v,\n-                                          vec(C_int(0),\n-                                              C_int(abi.vec_elt_fill))));\n-    }\n-\n-    fn vec_fill_adjusted(@block_ctxt bcx, ValueRef v,\n-                         ValueRef skipnull) -> ValueRef {\n-        auto f = bcx.build.Load(bcx.build.GEP(v,\n-                                              vec(C_int(0),\n-                                                  C_int(abi.vec_elt_fill))));\n-        ret bcx.build.Select(skipnull, bcx.build.Sub(f, C_int(1)), f);\n-    }\n-\n-    fn vec_p0(@block_ctxt bcx, ValueRef v) -> ValueRef {\n-        auto p = bcx.build.GEP(v, vec(C_int(0),\n-                                      C_int(abi.vec_elt_data)));\n-        ret bcx.build.PointerCast(p, T_ptr(T_i8()));\n-    }\n-\n-\n-    fn vec_p1(@block_ctxt bcx, ValueRef v) -> ValueRef {\n-        auto len = vec_fill(bcx, v);\n-        ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n-    }\n-\n-    fn vec_p1_adjusted(@block_ctxt bcx, ValueRef v,\n-                       ValueRef skipnull) -> ValueRef {\n-        auto len = vec_fill_adjusted(bcx, v, skipnull);\n-        ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n-    }\n-\n-\n     auto llcopy_dst_ptr = bcx.build.Alloca(T_int());\n     auto llnew_vec_res =\n         trans_upcall(bcx, \"upcall_vec_grow\",\n@@ -5575,16 +6005,17 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                                            C_int(abi.tydesc_field_size))));\n \n         fn take_one(ValueRef elt_tydesc,\n-                    @block_ctxt cx, ValueRef v) -> result {\n-            call_tydesc_glue_full(cx, v,\n+                    @block_ctxt cx,\n+                    ValueRef dst, ValueRef src) -> result {\n+            call_tydesc_glue_full(cx, src,\n                                   elt_tydesc,\n                                   abi.tydesc_field_take_glue_off);\n-            ret res(cx, v);\n+            ret res(cx, src);\n         }\n \n-        auto bcx = iter_sequence_raw(cx, src, src_lim,\n+        auto bcx = iter_sequence_raw(cx, dst, src, src_lim,\n                                      elt_llsz, bind take_one(elt_tydesc,\n-                                                             _, _)).bcx;\n+                                                             _, _, _)).bcx;\n \n         ret call_memcpy(bcx, dst, src, n_bytes);\n     }\n@@ -5644,14 +6075,16 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n              upcall_glues =\n              _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, _),\n                                     abi.n_upcall_glues as uint),\n-             no_op_type_glue = make_no_op_type_glue(llmod, tn),\n-             memcpy_glue = make_memcpy_glue(llmod),\n-             bzero_glue = make_bzero_glue(llmod),\n+             no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n+             memcpy_glue = decl_memcpy_glue(llmod),\n+             bzero_glue = decl_bzero_glue(llmod),\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n }\n \n-fn trans_crate(session.session sess, @ast.crate crate, str output,\n-               bool shared) {\n+fn make_common_glue(str output) {\n+    // FIXME: part of this is repetitive and is probably a good idea\n+    // to autogen it, but things like the memcpy implementation are not\n+    // and it might be better to just check in a .ll file.\n     auto llmod =\n         llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n                                                llvm.LLVMGetGlobalContext());\n@@ -5663,8 +6096,35 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     let ValueRef crate_ptr =\n         llvm.LLVMAddGlobal(llmod, T_crate(tn), _str.buf(\"rust_crate\"));\n \n+    auto intrinsics = declare_intrinsics(llmod);\n+\n     llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n \n+    auto glues = make_glues(llmod, tn);\n+    create_crate_constant(crate_ptr, glues);\n+    make_memcpy_glue(glues.memcpy_glue);\n+\n+    trans_exit_task_glue(glues, new_str_hash[ValueRef](), tn, llmod);\n+\n+    check_module(llmod);\n+\n+    llvm.LLVMWriteBitcodeToFile(llmod, _str.buf(output));\n+    llvm.LLVMDisposeModule(llmod);\n+}\n+\n+fn trans_crate(session.session sess, @ast.crate crate, str output,\n+               bool shared) {\n+    auto llmod =\n+        llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n+                                               llvm.LLVMGetGlobalContext());\n+\n+    llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n+    llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n+    auto td = mk_target_data(x86.get_data_layout());\n+    auto tn = mk_type_names();\n+    let ValueRef crate_ptr =\n+        llvm.LLVMAddGlobal(llmod, T_crate(tn), _str.buf(\"rust_crate\"));\n+\n     auto intrinsics = declare_intrinsics(llmod);\n \n     auto glues = make_glues(llmod, tn);\n@@ -5705,13 +6165,14 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     trans_constants(cx, crate);\n \n     trans_mod(cx, crate.node.module);\n-    trans_exit_task_glue(cx);\n     trans_vec_append_glue(cx);\n-    create_crate_constant(cx);\n     if (!shared) {\n         trans_main_fn(cx, cx.crate_ptr);\n     }\n \n+    // Translate the metadata.\n+    middle.metadata.write_metadata(cx, crate);\n+\n     check_module(llmod);\n \n     llvm.LLVMWriteBitcodeToFile(llmod, _str.buf(output));"}, {"sha": "0a161810e0203b008ce529d9f15361261c4d8d4d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 83, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -81,96 +81,17 @@ tag unify_result {\n \n // Stringification\n \n-fn ast_ty_to_str(&@ast.ty ty) -> str {\n-\n-    fn ast_fn_input_to_str(&rec(ast.mode mode, @ast.ty ty) input) -> str {\n-        auto s;\n-        if (mode_is_alias(input.mode)) {\n-            s = \"&\";\n-        } else {\n-            s = \"\";\n-        }\n-\n-        ret s + ast_ty_to_str(input.ty);\n-    }\n-\n-    fn ast_ty_field_to_str(&ast.ty_field f) -> str {\n-        ret ast_ty_to_str(f.ty) + \" \" + f.ident;\n-    }\n-\n-    auto s;\n-    alt (ty.node) {\n-        case (ast.ty_nil)          { s = \"()\";                            }\n-        case (ast.ty_bool)         { s = \"bool\";                          }\n-        case (ast.ty_int)          { s = \"int\";                           }\n-        case (ast.ty_uint)         { s = \"uint\";                          }\n-        case (ast.ty_machine(?tm)) { s = common.ty_mach_to_str(tm);       }\n-        case (ast.ty_char)         { s = \"char\";                          }\n-        case (ast.ty_str)          { s = \"str\";                           }\n-        case (ast.ty_box(?t))      { s = \"@\" + ast_ty_to_str(t);          }\n-        case (ast.ty_vec(?t))      { s = \"vec[\" + ast_ty_to_str(t) + \"]\"; }\n-        case (ast.ty_type)         { s = \"type\";                          }\n-\n-        case (ast.ty_tup(?elts)) {\n-            auto f = ast_ty_to_str;\n-            s = \"tup(\";\n-            s += _str.connect(_vec.map[@ast.ty,str](f, elts), \",\");\n-            s += \")\";\n-        }\n-\n-        case (ast.ty_rec(?fields)) {\n-            auto f = ast_ty_field_to_str;\n-            s = \"rec(\";\n-            s += _str.connect(_vec.map[ast.ty_field,str](f, fields), \",\");\n-            s += \")\";\n-        }\n-\n-        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n-            auto f = ast_fn_input_to_str;\n-            if (proto == ast.proto_fn) {\n-                s = \"fn(\";\n-            } else {\n-                s = \"iter(\";\n-            }\n-            auto is = _vec.map[rec(ast.mode mode, @ast.ty ty),str](f, inputs);\n-            s += _str.connect(is, \", \");\n-            s += \")\";\n-\n-            if (output.node != ast.ty_nil) {\n-                s += \" -> \" + ast_ty_to_str(output);\n-            }\n-        }\n-\n-        case (ast.ty_path(?path, _)) {\n-            s = path_to_str(path);\n-        }\n-\n-        case (ast.ty_mutable(?t)) {\n-            s = \"mutable \" + ast_ty_to_str(t);\n-        }\n-\n-\n-        case (_) {\n-            fail;   // FIXME: typestate bug\n-        }\n-    }\n-\n-    ret s;\n-}\n-\n fn path_to_str(&ast.path pth) -> str {\n     auto result = _str.connect(pth.node.idents,  \".\");\n     if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n-        auto f = ast_ty_to_str;\n+        auto f = pretty.pprust.ty_to_str;\n         result += \"[\";\n         result += _str.connect(_vec.map[@ast.ty,str](f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;\n }\n \n-// FIXME use the pretty-printer for this once it has a concept of an\n-// abstract stream\n fn ty_to_str(&@t typ) -> str {\n \n     fn fn_input_to_str(&rec(ast.mode mode, @t ty) input) -> str {\n@@ -452,6 +373,14 @@ fn get_element_type(@t ty, uint i) -> @t {\n     fail;\n }\n \n+fn type_is_box(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_box(_)) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n fn type_is_boxed(@t ty) -> bool {\n     alt (ty.struct) {\n         case (ty_str) { ret true; }\n@@ -596,10 +525,10 @@ fn eq_ty(&@t a, &@t b) -> bool {\n fn ann_to_type(&ast.ann ann) -> @t {\n     alt (ann) {\n         case (ast.ann_none) {\n-            // shouldn't happen, but can until the typechecker is complete\n-            ret plain_ty(ty_var(-1));    // FIXME: broken, broken, broken\n+            log \"ann_to_type() called on node with no type\";\n+            fail;\n         }\n-        case (ast.ann_type(?ty)) {\n+        case (ast.ann_type(?ty, _)) {\n             ret ty;\n         }\n     }"}, {"sha": "b2f371c5f9e273656ba865be1946e3ea285d2f41", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 379, "deletions": 190, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -39,10 +39,12 @@ tag any_item {\n }\n \n type ty_item_table = hashmap[ast.def_id,any_item];\n+type ty_param_table = hashmap[ast.def_id,vec[ast.def_id]];\n \n type crate_ctxt = rec(session.session sess,\n                       @ty_table item_types,\n                       @ty_item_table item_items,\n+                      @ty_param_table item_ty_params,\n                       vec[ast.obj_field] obj_fields,\n                       mutable int next_var_id);\n \n@@ -83,59 +85,187 @@ fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n // expression.\n fn substitute_ty_params(&@crate_ctxt ccx,\n                         @ty.t typ,\n-                        vec[@ast.ty] supplied,\n+                        vec[ast.def_id] ty_params,\n+                        vec[@ty.t] supplied,\n                         &span sp) -> @ty.t {\n     state obj ty_substituter(@crate_ctxt ccx,\n-                             @mutable uint i,\n-                             vec[@ast.ty] supplied,\n-                             @hashmap[int,@ty.t] substs) {\n+                             vec[ast.def_id] ty_params,\n+                             vec[@ty.t] supplied) {\n         fn fold_simple_ty(@ty.t typ) -> @ty.t {\n             alt (typ.struct) {\n-                case (ty.ty_var(?vid)) {\n-                    alt (substs.find(vid)) {\n-                        case (some[@ty.t](?resolved_ty)) {\n-                            ret resolved_ty;\n-                        }\n-                        case (none[@ty.t]) {\n-                            if (i >= _vec.len[@ast.ty](supplied)) {\n-                                // Just leave it as an unresolved parameter\n-                                // for now. (We will error out later.)\n-                                ret typ;\n-                            }\n-\n-                            auto result = ast_ty_to_ty_crate(ccx,\n-                                                             supplied.(*i));\n-                            *i += 1u;\n-                            substs.insert(vid, result);\n-                            ret result;\n-                        }\n+                case (ty.ty_param(?pid)) {\n+                    // Find the index of the type parameter.\n+                    auto ty_param_len = _vec.len[ast.def_id](ty_params);\n+                    auto i = 0u;\n+                    while (i < ty_param_len &&\n+                            !common.def_eq(pid, ty_params.(i))) {\n+                        i += 1u;\n                     }\n+                    if (i == ty_param_len) {\n+                        log \"substitute_ty_params(): \" +\n+                            \"no ty param for param id!\";\n+                        fail;\n+                    }\n+\n+                    // Substitute it in.\n+                    ret supplied.(i);\n                 }\n                 case (_) { ret typ; }\n             }\n         }\n     }\n \n-    fn hash_int(&int x) -> uint { ret x as uint; }\n-    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n-    auto hasher = hash_int;\n-    auto eqer = eq_int;\n-    auto substs = @map.mk_hashmap[int,@ty.t](hasher, eqer);\n-\n-    auto subst_count = @mutable 0u;\n-    auto substituter = ty_substituter(ccx, subst_count, supplied, substs);\n-\n-    auto result = ty.fold_ty(substituter, typ);\n-\n-    auto supplied_len = _vec.len[@ast.ty](supplied);\n-    if ((*subst_count) != supplied_len) {\n-        ccx.sess.span_err(sp, \"expected \" + _uint.to_str(*subst_count, 10u) +\n+    auto ty_param_len = _vec.len[ast.def_id](ty_params);\n+    auto supplied_len = _vec.len[@ty.t](supplied);\n+    if (ty_param_len != supplied_len) {\n+        ccx.sess.span_err(sp, \"expected \" + _uint.to_str(ty_param_len, 10u) +\n                           \" type parameter(s) but found \" +\n                           _uint.to_str(supplied_len, 10u) + \" parameter(s)\");\n         fail;\n     }\n \n-    ret result;\n+    auto substituter = ty_substituter(ccx, ty_params, supplied);\n+    ret ty.fold_ty(substituter, typ);\n+}\n+\n+type ty_params_opt_and_ty = tup(option.t[vec[ast.def_id]], @ty.t);\n+\n+// Returns the type parameters and the type for the given definition.\n+fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n+        -> ty_params_opt_and_ty {\n+    alt (defn) {\n+        case (ast.def_arg(?id)) {\n+            check (fcx.locals.contains_key(id));\n+            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n+        }\n+        case (ast.def_local(?id)) {\n+            auto t;\n+            alt (fcx.locals.find(id)) {\n+                case (some[@ty.t](?t1)) { t = t1; }\n+                case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n+            }\n+            ret tup(none[vec[ast.def_id]], t);\n+        }\n+        case (ast.def_obj_field(?id)) {\n+            check (fcx.locals.contains_key(id));\n+            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n+        }\n+        case (ast.def_fn(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n+                    fcx.ccx.item_types.get(id));\n+        }\n+        case (ast.def_native_fn(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n+                    fcx.ccx.item_types.get(id));\n+        }\n+        case (ast.def_const(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            ret tup(none[vec[ast.def_id]], fcx.ccx.item_types.get(id));\n+        }\n+        case (ast.def_variant(?tag_id, ?variant_id)) {\n+            check (fcx.ccx.item_types.contains_key(variant_id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(tag_id)),\n+                    fcx.ccx.item_types.get(variant_id));\n+        }\n+        case (ast.def_binding(?id)) {\n+            check (fcx.locals.contains_key(id));\n+            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n+        }\n+        case (ast.def_obj(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n+                    fcx.ccx.item_types.get(id));\n+        }\n+\n+        case (ast.def_mod(_)) {\n+            // Hopefully part of a path.\n+            // TODO: return a type that's more poisonous, perhaps?\n+            ret tup(none[vec[ast.def_id]], plain_ty(ty.ty_nil));\n+        }\n+\n+        case (_) {\n+            // FIXME: handle other names.\n+            fcx.ccx.sess.unimpl(\"definition variant\");\n+            fail;\n+        }\n+    }\n+}\n+\n+// Instantiates the given path, which must refer to an item with the given\n+// type parameters and type.\n+fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_params_opt_and_ty tpt,\n+        &span sp) -> ast.ann {\n+    auto ty_params = tpt._0;\n+    auto t = tpt._1;\n+\n+    auto ty_substs_opt;\n+    auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n+    if (ty_substs_len > 0u) {\n+        let vec[@ty.t] ty_substs = vec();\n+        auto i = 0u;\n+        while (i < ty_substs_len) {\n+            ty_substs += vec(ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i)));\n+            i += 1u;\n+        }\n+        ty_substs_opt = some[vec[@ty.t]](ty_substs);\n+\n+        alt (ty_params) {\n+            case (none[vec[ast.def_id]]) {\n+                fcx.ccx.sess.span_err(sp, \"this kind of item may not take \" +\n+                                          \"type parameters\");\n+                fail;\n+            }\n+            case (some[vec[ast.def_id]](?tps)) {\n+                t = substitute_ty_params(fcx.ccx, t, tps, ty_substs, sp);\n+            }\n+        }\n+    } else {\n+        ty_substs_opt = none[vec[@ty.t]];\n+\n+        alt (ty_params) {\n+            case (none[vec[ast.def_id]]) {  /* nothing */ }\n+            case (some[vec[ast.def_id]](_)) {\n+                // We will acquire the type parameters through\n+                // unification.\n+                t = generalize_ty(fcx.ccx, t);\n+            }\n+        }\n+    }\n+\n+    ret ast.ann_type(t, ty_substs_opt);\n+}\n+\n+// Returns the type parameters and polytype of an item, if it's an item that\n+// supports type parameters.\n+fn ty_params_for_item(@crate_ctxt ccx, &ast.def d)\n+        -> option.t[ty.ty_params_and_ty] {\n+    auto params_id;\n+    auto types_id;\n+    alt (d) {\n+        case (ast.def_fn(?id))          { params_id = id; types_id = id; }\n+        case (ast.def_obj(?id))         { params_id = id; types_id = id; }\n+        case (ast.def_obj_field(_))     { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_mod(_))           { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_const(_))         { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_arg(_))           { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_local(_))         { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_variant(?tid, ?vid)) {\n+            params_id = tid;\n+            types_id = vid;\n+        }\n+        case (ast.def_ty(_))            { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_ty_arg(_))        { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_binding(_))       { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_use(_))           { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_native_ty(_))     { ret none[ty.ty_params_and_ty]; }\n+        case (ast.def_native_fn(?id))   { params_id = id; types_id = id; }\n+    }\n+\n+    auto tps = ccx.item_ty_params.get(params_id);\n+    auto polyty = ccx.item_types.get(types_id);\n+    ret some[ty.ty_params_and_ty](tup(tps, polyty));\n }\n \n // Parses the programmer's textual representation of a type into our internal\n@@ -356,7 +486,7 @@ fn ty_of_native_fn_decl(@ty_item_table id_to_ty_item,\n }\n \n fn collect_item_types(session.session sess, @ast.crate crate)\n-    -> tup(@ast.crate, @ty_table, @ty_item_table) {\n+    -> tup(@ast.crate, @ty_table, @ty_item_table, @ty_param_table) {\n \n     fn getter(@ty_item_table id_to_ty_item,\n               @ty_table item_to_ty,\n@@ -550,7 +680,10 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n             item_to_ty.insert(variant.id, result_ty);\n \n-            auto variant_t = rec(ann=ast.ann_type(result_ty) with variant);\n+            auto variant_t = rec(\n+                ann=ast.ann_type(result_ty, none[vec[@ty.t]])\n+                with variant\n+            );\n             result += vec(variant_t);\n         }\n \n@@ -600,16 +733,29 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n     // Second pass: translate the types of all items.\n     let @ty_table item_to_ty = @common.new_def_hash[@ty.t]();\n+    auto item_ty_params = @common.new_def_hash[vec[ast.def_id]]();\n \n     type env = rec(session.session sess,\n                    @ty_item_table id_to_ty_item,\n                    @ty_table item_to_ty,\n+                   @ty_param_table item_ty_params,\n                    ast.native_abi abi);\n     let @env e = @rec(sess=sess,\n                       id_to_ty_item=id_to_ty_item,\n                       item_to_ty=item_to_ty,\n+                      item_ty_params=item_ty_params,\n                       abi=ast.native_abi_cdecl);\n \n+    // Inserts the given type parameters into the type parameter table of the\n+    // environment.\n+    fn collect_ty_params(&@env e, &ast.def_id id, vec[ast.ty_param] tps) {\n+        let vec[ast.def_id] result = vec();\n+        for (ast.ty_param tp in tps) {\n+            result += vec(tp.id);\n+        }\n+        e.item_ty_params.insert(id, result);\n+    }\n+\n     fn convert(&@env e, @ast.item i) -> @env {\n         auto abi = e.abi;\n         alt (i.node) {\n@@ -638,29 +784,33 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                        @ast.ty t, @ast.expr ex,\n                        ast.def_id id, ast.ann a) -> @ast.item {\n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.item_const(i, t, ex, id,\n-                                   ast.ann_type(ty));\n+                                   ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n     fn fold_item_fn(&@env e, &span sp, ast.ident i,\n                     &ast._fn f, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n+        collect_ty_params(e, id, ty_params);\n+\n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.item_fn(i, f, ty_params, id,\n-                                ast.ann_type(ty));\n+                                ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n     fn fold_native_item_fn(&@env e, &span sp, ast.ident i,\n                            &ast.fn_decl d, vec[ast.ty_param] ty_params,\n                            ast.def_id id, ast.ann a) -> @ast.native_item {\n+        collect_ty_params(e, id, ty_params);\n+\n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.native_item_fn(i, d, ty_params, id,\n-                                       ast.ann_type(ty));\n+                                       ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.native_item_](sp, item);\n     }\n \n@@ -688,6 +838,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn fold_item_obj(&@env e, &span sp, ast.ident i,\n                     &ast._obj ob, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n+        collect_ty_params(e, id, ty_params);\n+\n         check (e.item_to_ty.contains_key(id));\n         auto t = e.item_to_ty.get(id);\n         let vec[method] meth_tys = get_ctor_obj_methods(t);\n@@ -704,39 +856,49 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             auto meth_tfn = plain_ty(ty.ty_fn(meth_ty.proto,\n                                               meth_ty.inputs,\n                                               meth_ty.output));\n-            m_ = rec(ann=ast.ann_type(meth_tfn) with meth.node);\n+            m_ = rec(\n+                ann=ast.ann_type(meth_tfn, none[vec[@ty.t]])\n+                with meth.node\n+            );\n             m = @rec(node=m_ with *meth);\n             append[@ast.method](methods, m);\n         }\n         auto g = bind getter(e.id_to_ty_item, e.item_to_ty, _);\n         for (ast.obj_field fld in ob.fields) {\n             let @ty.t fty = ast_ty_to_ty(g, fld.ty);\n-            let ast.obj_field f = rec(ann=ast.ann_type(fty) with fld);\n+            let ast.obj_field f = rec(\n+                ann=ast.ann_type(fty, none[vec[@ty.t]])\n+                with fld\n+            );\n             append[ast.obj_field](fields, f);\n         }\n \n         auto ob_ = rec(methods = methods,\n                        fields = fields\n                        with ob);\n         auto item = ast.item_obj(i, ob_, ty_params, id,\n-                                 ast.ann_type(t));\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n     fn fold_item_ty(&@env e, &span sp, ast.ident i,\n                     @ast.ty t, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n+        collect_ty_params(e, id, ty_params);\n+\n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.item_ty(i, t, ty_params, id,\n-                                ast.ann_type(ty));\n+                                ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n     fn fold_item_tag(&@env e, &span sp, ast.ident i,\n                      vec[ast.variant] variants,\n                      vec[ast.ty_param] ty_params,\n                      ast.def_id id) -> @ast.item {\n+        collect_ty_params(e, id, ty_params);\n+\n         auto variants_t = get_tag_variant_types(e.id_to_ty_item,\n                                                 e.item_to_ty,\n                                                 id,\n@@ -758,7 +920,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n              fold_item_tag   = bind fold_item_tag(_,_,_,_,_,_)\n              with *fld_2);\n     auto crate_ = fold.fold_crate[@env](e, fld_2, crate);\n-    ret tup(crate_, item_to_ty, id_to_ty_item);\n+    ret tup(crate_, item_to_ty, id_to_ty_item, item_ty_params);\n }\n \n fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n@@ -895,29 +1057,40 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n     alt (pat.node) {\n         case (ast.pat_wild(?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_wild(ast.ann_type(t));\n+            p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.pat_lit(?lit, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_lit(lit, ast.ann_type(t));\n+            p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.pat_bind(?id, ?did, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n             fcx.locals.insert(did, t);\n-            p_1 = ast.pat_bind(id, did, ast.ann_type(t));\n+            p_1 = ast.pat_bind(id, did, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n \n+            // Figure out the type parameters of the tag.\n+            auto tag_id = option.get[ast.variant_def](vdef_opt)._0;\n+            auto ty_params = fcx.ccx.item_ty_params.get(tag_id);\n+\n+            // Take the type parameters out of the expected type.\n+            auto ty_param_substs;\n+            alt (t.struct) {\n+                case (ty.ty_tag(_, ?tps)) { ty_param_substs = tps; }\n+                case (_) {\n+                    log \"demand_pat(): expected type for tag pat isn't \" +\n+                        \"actually a tag?!\";\n+                    fail;\n+                }\n+            }\n+            auto tps_opt = some[vec[@ty.t]](ty_param_substs);\n+\n             // The type of the tag isn't enough; we also have to get the type\n             // of the variant, which is either a tag type in the case of\n             // nullary variants or a function type in the case of n-ary\n             // variants.\n-            //\n-            // TODO: When we have type-parametric tags, this will get a little\n-            // trickier. Basically, we have to instantiate the variant type we\n-            // acquire here with the type parameters provided to us by\n-            // \"expected\".\n \n             auto vdef = option.get[ast.variant_def](vdef_opt);\n             auto variant_ty = fcx.ccx.item_types.get(vdef._1);\n@@ -927,18 +1100,23 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n                 case (ty.ty_tag(_, _)) {\n                     // Nullary tag variant.\n                     check (subpats_len == 0u);\n-                    p_1 = ast.pat_tag(id, subpats, vdef_opt, ast.ann_type(t));\n+                    p_1 = ast.pat_tag(id, subpats, vdef_opt,\n+                                      ast.ann_type(t, tps_opt));\n                 }\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n+                    // N-ary tag variant.\n                     let vec[@ast.pat] new_subpats = vec();\n                     auto i = 0u;\n                     for (arg a in args) {\n-                        auto new_subpat = demand_pat(fcx, a.ty, subpats.(i));\n+                        auto subpat_ty = substitute_ty_params(fcx.ccx, a.ty,\n+                            ty_params, ty_param_substs, pat.span);\n+                        auto new_subpat = demand_pat(fcx, subpat_ty,\n+                                                     subpats.(i));\n                         new_subpats += vec(new_subpat);\n                         i += 1u;\n                     }\n                     p_1 = ast.pat_tag(id, new_subpats, vdef_opt,\n-                                      ast.ann_type(tag_ty));\n+                                      ast.ann_type(tag_ty, tps_opt));\n                 }\n             }\n         }\n@@ -977,7 +1155,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_vec(es_1, ast.ann_type(t));\n+            e_1 = ast.expr_vec(es_1, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_tup(?es_0, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n@@ -996,7 +1174,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_tup(elts_1, ast.ann_type(t));\n+            e_1 = ast.expr_tup(elts_1, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1049,37 +1227,41 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_rec(fields_1, base_1, ast.ann_type(t));\n+            e_1 = ast.expr_rec(fields_1, base_1,\n+                               ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_bind(?sube, ?es, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_bind(sube, es, ast.ann_type(t));\n+            e_1 = ast.expr_bind(sube, es, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_call(?sube, ?es, ?ann)) {\n             // NB: we call 'demand_full' and pass in adk only in cases where\n             // e is an expression that could *possibly* produce a box; things\n             // like expr_binary or expr_bind can't, so there's no need.\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_call(sube, es, ast.ann_type(t));\n+            e_1 = ast.expr_call(sube, es, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_binary(bop, lhs, rhs, ast.ann_type(t));\n+            e_1 = ast.expr_binary(bop, lhs, rhs,\n+                                  ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_unary(?uop, ?sube, ?ann)) {\n             // See note in expr_unary for why we're calling demand_full.\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_unary(uop, sube, ast.ann_type(t));\n+            e_1 = ast.expr_unary(uop, sube,\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_lit(?lit, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_lit(lit, ast.ann_type(t));\n+            e_1 = ast.expr_lit(lit, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_cast(sube, ast_ty, ast.ann_type(t));\n+            e_1 = ast.expr_cast(sube, ast_ty,\n+                                ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n@@ -1094,62 +1276,102 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     else_1 = some[@ast.expr](e_1);\n                 }\n             }\n-            e_1 = ast.expr_if(cond, then_1, else_1, ast.ann_type(t));\n+            e_1 = ast.expr_if(cond, then_1, else_1,\n+                              ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for(decl, seq, bloc, ast.ann_type(t));\n+            e_1 = ast.expr_for(decl, seq, bloc,\n+                               ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for_each(decl, seq, bloc, ast.ann_type(t));\n+            e_1 = ast.expr_for_each(decl, seq, bloc,\n+                                    ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_while(?cond, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_while(cond, bloc, ast.ann_type(t));\n+            e_1 = ast.expr_while(cond, bloc,\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_do_while(bloc, cond, ast.ann_type(t));\n+            e_1 = ast.expr_do_while(bloc, cond,\n+                                    ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_block(?bloc, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_block(bloc, ast.ann_type(t));\n+            e_1 = ast.expr_block(bloc, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign(lhs_1, rhs_1, ast.ann_type(t));\n+            e_1 = ast.expr_assign(lhs_1, rhs_1,\n+                                  ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, ast.ann_type(t));\n+            e_1 = ast.expr_assign_op(op, lhs_1, rhs_1,\n+                                     ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t));\n+            e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_index(?base, ?index, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_index(base, index, ast.ann_type(t));\n+            e_1 = ast.expr_index(base, index,\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_path(?pth, ?d, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_path(pth, d, ast.ann_type(t));\n+\n+            // Fill in the type parameter substitutions if they weren't\n+            // provided by the programmer.\n+            auto ty_params_opt;\n+            alt (ann) {\n+                case (ast.ann_none) {\n+                    log \"demand_expr(): no type annotation for path expr; \" +\n+                        \"did you pass it to check_expr() first?\";\n+                    fail;\n+                }\n+                case (ast.ann_type(_, ?tps_opt)) {\n+                    alt (tps_opt) {\n+                        case (none[vec[@ty.t]]) {\n+                            auto defn = option.get[ast.def](d);\n+                            alt (ty_params_for_item(fcx.ccx, defn)) {\n+                                case (none[ty.ty_params_and_ty]) {\n+                                    ty_params_opt = none[vec[@ty.t]];\n+                                }\n+                                case (some[ty.ty_params_and_ty](?tpt)) {\n+                                    auto tps = ty.resolve_ty_params(tpt, t);\n+                                    ty_params_opt = some[vec[@ty.t]](tps);\n+                                }\n+                            }\n+                        }\n+                        case (some[vec[@ty.t]](?tps)) {\n+                            ty_params_opt = some[vec[@ty.t]](tps);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            e_1 = ast.expr_path(pth, d, ast.ann_type(t, ty_params_opt));\n         }\n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_ext(p, args, body, expanded, ast.ann_type(t));\n+            e_1 = ast.expr_ext(p, args, body, expanded,\n+                               ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_fail) { e_1 = e.node; }\n         case (ast.expr_log(_)) { e_1 = e.node; }\n@@ -1192,7 +1414,10 @@ fn writeback_local(&@fn_ctxt fcx, &span sp, @ast.local local)\n                               + local.ident);\n     }\n     auto local_ty = fcx.locals.get(local.id);\n-    auto local_wb = @rec(ann=ast.ann_type(local_ty) with *local);\n+    auto local_wb = @rec(\n+        ann=ast.ann_type(local_ty, none[vec[@ty.t]])\n+        with *local\n+    );\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n \n@@ -1224,20 +1449,28 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast.pat_wild(_)) {\n-            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx.ccx)));\n+            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx.ccx),\n+                                                none[vec[@ty.t]]));\n         }\n         case (ast.pat_lit(?lt, _)) {\n-            new_pat = ast.pat_lit(lt, ast.ann_type(check_lit(lt)));\n+            new_pat = ast.pat_lit(lt, ast.ann_type(check_lit(lt),\n+                                                   none[vec[@ty.t]]));\n         }\n         case (ast.pat_bind(?id, ?def_id, _)) {\n-            auto ann = ast.ann_type(next_ty_var(fcx.ccx));\n+            auto ann = ast.ann_type(next_ty_var(fcx.ccx), none[vec[@ty.t]]);\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n         case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n             auto t = fcx.ccx.item_types.get(vdef._1);\n             auto len = _vec.len[ast.ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n+\n+            auto ty_params = fcx.ccx.item_ty_params.get(vdef._0);\n+            auto tag_ty = fcx.ccx.item_types.get(vdef._0);\n+            auto tpt = tup(some(ty_params), tag_ty);\n+            auto ann = instantiate_path(fcx, p, tpt, pat.span);\n+\n             alt (t.struct) {\n                 // N-ary variants have function types.\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n@@ -1247,8 +1480,9 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                         // TODO: pluralize properly\n                         auto err_msg = \"tag type \" + last_id + \" has \" +\n                                        _uint.to_str(subpats_len, 10u) +\n-                                       \" fields, but this pattern has \" +\n-                                       _uint.to_str(arg_len, 10u) + \" fields\";\n+                                       \" field(s), but this pattern has \" +\n+                                       _uint.to_str(arg_len, 10u) +\n+                                       \" field(s)\";\n \n                         fcx.ccx.sess.span_err(pat.span, err_msg);\n                         fail;   // TODO: recover\n@@ -1259,29 +1493,24 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                         new_subpats += vec(check_pat(fcx, subpat));\n                     }\n \n-                    auto ann = ast.ann_type(tag_ty);\n                     new_pat = ast.pat_tag(p, new_subpats, vdef_opt, ann);\n                 }\n \n                 // Nullary variants have tag types.\n                 case (ty.ty_tag(?tid, _)) {\n-                    // TODO: ty params\n-\n                     auto subpats_len = _vec.len[@ast.pat](subpats);\n                     if (subpats_len > 0u) {\n                         // TODO: pluralize properly\n                         auto err_msg = \"tag type \" + last_id +\n-                                       \" has no fields,\" +\n+                                       \" has no field(s),\" +\n                                        \" but this pattern has \" +\n                                        _uint.to_str(subpats_len, 10u) +\n-                                       \" fields\";\n+                                       \" field(s)\";\n \n                         fcx.ccx.sess.span_err(pat.span, err_msg);\n                         fail;   // TODO: recover\n                     }\n \n-                    let vec[@ty.t] tys = vec(); // FIXME\n-                    auto ann = ast.ann_type(plain_ty(ty.ty_tag(tid, tys)));\n                     new_pat = ast.pat_tag(p, subpats, vdef_opt, ann);\n                 }\n             }\n@@ -1378,9 +1607,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n-            auto ty = check_lit(lit);\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_lit(lit, ast.ann_type(ty)));\n+            auto typ = check_lit(lit);\n+            auto ann = ast.ann_type(typ, none[vec[@ty.t]]);\n+            ret @fold.respan[ast.expr_](expr.span, ast.expr_lit(lit, ann));\n         }\n \n \n@@ -1406,9 +1635,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ast.gt) { t = plain_ty(ty.ty_bool); }\n                 case (_) { /* fall through */ }\n             }\n+\n+            auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_binary(binop, lhs_1, rhs_1,\n-                                                        ast.ann_type(t)));\n+                                                        ann));\n         }\n \n \n@@ -1435,84 +1666,29 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n                 case (_) { oper_t = strip_boxes(oper_t); }\n             }\n+\n+            auto ann = ast.ann_type(oper_t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_unary(unop, oper_1,\n-                                                       ast.ann_type(oper_t)));\n+                                        ast.expr_unary(unop, oper_1, ann));\n         }\n \n         case (ast.expr_path(?pth, ?defopt, _)) {\n             auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n-            alt (option.get[ast.def](defopt)) {\n-                case (ast.def_arg(?id)) {\n-                    check (fcx.locals.contains_key(id));\n-                    t = fcx.locals.get(id);\n-                }\n-                case (ast.def_local(?id)) {\n-                    alt (fcx.locals.find(id)) {\n-                        case (some[@ty.t](?t1)) { t = t1; }\n-                        case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n-                    }\n-                }\n-                case (ast.def_obj_field(?id)) {\n-                    check (fcx.locals.contains_key(id));\n-                    t = fcx.locals.get(id);\n-                }\n-                case (ast.def_fn(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n-                }\n-                case (ast.def_native_fn(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n-                }\n-                case (ast.def_const(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = fcx.ccx.item_types.get(id);\n-                }\n-                case (ast.def_variant(_, ?variant_id)) {\n-                    check (fcx.ccx.item_types.contains_key(variant_id));\n-                    t = generalize_ty(fcx.ccx,\n-                                      fcx.ccx.item_types.get(variant_id));\n-                }\n-                case (ast.def_binding(?id)) {\n-                    check (fcx.locals.contains_key(id));\n-                    t = fcx.locals.get(id);\n-                }\n-                case (ast.def_obj(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n-                }\n-\n-                case (ast.def_mod(_)) {\n-                    // Hopefully part of a path.\n-                }\n-\n-                case (_) {\n-                    // FIXME: handle other names.\n-                    fcx.ccx.sess.unimpl(\"definition variant for: \"\n-                                        + _str.connect(pth.node.idents, \".\"));\n-                    fail;\n-                }\n-            }\n-\n-            // Substitute type parameters if the user provided some.\n-            if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n-                t = substitute_ty_params(fcx.ccx, t, pth.node.types,\n-                                         expr.span);\n-            }\n-\n+            auto defn = option.get[ast.def](defopt);\n+            auto tpt = ty_params_and_ty_for_def(fcx, defn);\n+            auto ann = instantiate_path(fcx, pth, tpt, expr.span);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_path(pth, defopt,\n-                                                      ast.ann_type(t)));\n+                                        ast.expr_path(pth, defopt, ann));\n         }\n \n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, _)) {\n             auto exp_ = check_expr(fcx, expanded);\n             auto t = expr_ty(exp_);\n+            auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_ext(p, args, body, exp_,\n-                                                     ast.ann_type(t)));\n+                                                     ann));\n         }\n \n         case (ast.expr_fail) {\n@@ -1591,7 +1767,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n \n-            auto ann = ast.ann_type(rhs_t0);\n+            auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_assign(lhs_1, rhs_1, ann));\n         }\n@@ -1605,7 +1781,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n \n-            auto ann = ast.ann_type(rhs_t0);\n+            auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_assign_op(op, lhs_1, rhs_1,\n                                                            ann));\n@@ -1635,9 +1811,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto thn_1 = demand_block(fcx, elsopt_t, thn_0);\n \n+            auto ann = ast.ann_type(elsopt_t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_if(cond_1, thn_1, elsopt_1,\n-                                                    ast.ann_type(elsopt_t)));\n+                                        ast.expr_if(cond_1, thn_1,\n+                                                    elsopt_1, ann));\n         }\n \n         case (ast.expr_for(?decl, ?seq, ?body, _)) {\n@@ -1648,7 +1825,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n@@ -1659,7 +1836,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n@@ -1670,7 +1847,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n@@ -1680,7 +1857,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(block_ty(body_1));\n+            auto ann = ast.ann_type(block_ty(body_1), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_do_while(body_1, cond_1,\n                                                           ann));\n@@ -1730,7 +1907,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto expr_1 = demand_expr(fcx, pattern_ty, expr_0);\n \n-            auto ann = ast.ann_type(result_ty);\n+            auto ann = ast.ann_type(result_ty, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_alt(expr_1, arms_1, ann));\n         }\n@@ -1740,10 +1917,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast.expr](?expr)) {\n-                    ann = ast.ann_type(expr_ty(expr));\n+                    ann = ast.ann_type(expr_ty(expr), none[vec[@ty.t]]);\n                 }\n                 case (none[@ast.expr]) {\n-                    ann = ast.ann_type(plain_ty(ty.ty_nil));\n+                    ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n                 }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -1783,9 +1960,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n \n             auto t_1 = plain_ty(ty.ty_fn(proto_1, arg_tys_1, rt_1));\n+            auto ann = ast.ann_type(t_1, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(result._0, result._1,\n-                                                      ast.ann_type(t_1)));\n+                                                      ann));\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n@@ -1814,9 +1992,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n+            auto ann = ast.ann_type(rt_1, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_call(result._0, args_1,\n-                                                      ast.ann_type(rt_1)));\n+                                                      ann));\n         }\n \n         case (ast.expr_cast(?e, ?t, _)) {\n@@ -1831,9 +2010,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                       + \" as \"\n                                       +  ty_to_str(t_1));\n             }\n+\n+            auto ann = ast.ann_type(t_1, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_cast(e_1, t,\n-                                                      ast.ann_type(t_1)));\n+                                        ast.expr_cast(e_1, t, ann));\n         }\n \n         case (ast.expr_vec(?args, _)) {\n@@ -1856,7 +2036,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 demand(fcx, expr.span, t, expr_t);\n                 append[@ast.expr](args_1,expr_1);\n             }\n-            auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, ann));\n         }\n@@ -1875,14 +2055,21 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 append[@ty.t](elts_t, expr_t);\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)),\n+                                    none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n \n         case (ast.expr_rec(?fields, ?base, _)) {\n \n-            auto base_1 = base;\n+            auto base_1;\n+            alt (base) {\n+                case (none[@ast.expr]) { base_1 = none[@ast.expr]; }\n+                case (some[@ast.expr](?b_0)) {\n+                    base_1 = some[@ast.expr](check_expr(fcx, b_0));\n+                }\n+            }\n \n             let vec[ast.field] fields_1 = vec();\n             let vec[field] fields_t = vec();\n@@ -1901,7 +2088,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             alt (base) {\n                 case (none[@ast.expr]) {\n-                    ann = ast.ann_type(plain_ty(ty.ty_rec(fields_t)));\n+                    ann = ast.ann_type(plain_ty(ty.ty_rec(fields_t)),\n+                                       none[vec[@ty.t]]);\n                 }\n \n                 case (some[@ast.expr](?bexpr)) {\n@@ -1921,7 +2109,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         }\n                     }\n \n-                    ann = ast.ann_type(bexpr_t);\n+                    ann = ast.ann_type(bexpr_t, none[vec[@ty.t]]);\n \n                     for (ty.field f in fields_t) {\n                         auto found = false;\n@@ -1956,7 +2144,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = ast.ann_type(args.(ix));\n+                    auto ann = ast.ann_type(args.(ix), none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -1970,7 +2158,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = ast.ann_type(fields.(ix).ty);\n+                    auto ann = ast.ann_type(fields.(ix).ty, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -1987,7 +2175,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     auto meth = methods.(ix);\n                     auto t = plain_ty(ty.ty_fn(meth.proto,\n                                                meth.inputs, meth.output));\n-                    auto ann = ast.ann_type(t);\n+                    auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2017,7 +2205,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto ann = ast.ann_type(t);\n+                    auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2031,7 +2219,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              + ty_to_str(idx_t));\n                     }\n                     auto t = ty.ty_machine(common.ty_u8);\n-                    auto ann = ast.ann_type(plain_ty(t));\n+                    auto ann = ast.ann_type(plain_ty(t), none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2206,7 +2394,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n     auto fn_sty = ty.ty_fn(f.proto, inputs, output_ty);\n-    auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n+    auto fn_ann = ast.ann_type(plain_ty(fn_sty), none[vec[@ty.t]]);\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);\n@@ -2231,6 +2419,7 @@ fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto ccx = @rec(sess=sess,\n                     item_types=result._1,\n                     item_items=result._2,\n+                    item_ty_params=result._3,\n                     obj_fields=fields,\n                     mutable next_var_id=0);\n "}, {"sha": "d3145180282757509d134e4cf8c1f53750371654", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -17,17 +17,19 @@ type context = rec(contexttype tp, uint indent);\n \n type ps = @rec(mutable vec[context] context,\n                uint width,\n+               io.writer out,\n                mutable vec[token] buffered,\n                mutable uint scandepth,\n                mutable uint bufferedcol,\n                mutable uint col,\n                mutable bool start_of_line);\n \n-fn mkstate(uint width) -> ps {\n+fn mkstate(io.writer out, uint width) -> ps {\n   let vec[context] stack = vec(rec(tp=cx_v, indent=0u));\n   let vec[token] buff = vec();\n   ret @rec(mutable context=stack,\n            width=width,\n+           out=out,\n            mutable buffered=buff,\n            mutable scandepth=0u,\n            mutable bufferedcol=0u,\n@@ -46,10 +48,22 @@ impure fn pop_context(ps p) {\n }\n \n impure fn add_token(ps p, token tok) {\n-  if (p.scandepth == 0u) {do_token(p, tok);}\n+  if (p.width == 0u) {direct_token(p, tok);}\n+  else if (p.scandepth == 0u) {do_token(p, tok);}\n   else {buffer_token(p, tok);}\n }\n \n+impure fn direct_token(ps p, token tok) {\n+  alt (tok) {\n+    case (brk(?sz)) {\n+      while (sz > 0u) {p.out.write_str(\" \"); sz -= 1u;}\n+    }\n+    case (word(?w)) {p.out.write_str(w);}\n+    case (cword(?w)) {p.out.write_str(w);}\n+    case (_) {}\n+  }\n+}\n+\n impure fn buffer_token(ps p, token tok) {\n   p.buffered += vec(tok);\n   p.bufferedcol += token_size(tok);\n@@ -101,14 +115,13 @@ impure fn finish_block_scan(ps p, contexttype tp) {\n \n impure fn finish_break_scan(ps p) {\n   if (p.bufferedcol > p.width) {\n-    write_str(\"\\n\");\n-    p.col = 0u;\n+    line_break(p);\n   }\n   else {\n     auto width;\n     alt (p.buffered.(0)) {case(brk(?w)) {width = w;}}\n     auto i = 0u;\n-    while (i < width) {write_str(\" \"); i+=1u;}\n+    while (i < width) {p.out.write_str(\" \"); i+=1u;}\n     p.col += width;\n   }\n   p.scandepth = 0u;\n@@ -142,20 +155,18 @@ impure fn do_token(ps p, token tok) {\n           start_scan(p, tok);\n         }\n         case (cx_v) {\n-          write_str(\"\\n\");\n-          p.col = 0u;\n-          p.start_of_line = true;\n+          line_break(p);\n         }\n       }\n     }\n     case (word(?w)) {\n       before_print(p, false);\n-      write_str(w);\n+      p.out.write_str(w);\n       p.col += _str.byte_len(w); // TODO char_len\n     }\n     case (cword(?w)) {\n       before_print(p, true);\n-      write_str(w);\n+      p.out.write_str(w);\n       p.col += _str.byte_len(w); // TODO char_len\n     }\n     case (open(?tp, ?indent)) {\n@@ -170,21 +181,23 @@ impure fn do_token(ps p, token tok) {\n   }\n }\n \n+impure fn line_break(ps p) {\n+  p.out.write_str(\"\\n\");\n+  p.col = 0u;\n+  p.start_of_line = true;\n+}\n+\n impure fn before_print(ps p, bool closing) {\n   if (p.start_of_line) {\n     p.start_of_line = false;\n     auto ind;\n     if (closing) {ind = base_indent(p);}\n     else {ind = cur_context(p).indent;}\n     p.col = ind;\n-    while (ind > 0u) {write_str(\" \"); ind -= 1u;}\n+    while (ind > 0u) {p.out.write_str(\" \"); ind -= 1u;}\n   }\n }\n \n-fn write_str(str s) {\n-  io.writefd(1, _str.bytes(s));\n-}\n-\n fn token_size(token tok) -> uint {\n   alt (tok) {\n     case (brk(?sz)) {ret sz;}"}, {"sha": "2b64b8e41696e4b9cda4f3f08c6707959debecde", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -11,13 +11,19 @@ import foo = std.io;\n const uint indent_unit = 2u;\n const int as_prec = 5;\n \n-impure fn print_ast(ast._mod _mod) {\n-  auto s = pp.mkstate(80u);\n+impure fn print_ast(ast._mod _mod, std.io.writer out) {\n+  auto s = pp.mkstate(out, 80u);\n   for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n   line(s);\n   for (@ast.item item in _mod.items) {print_item(s, item);}\n }\n \n+fn ty_to_str(&@ast.ty ty) -> str {\n+  auto writer = std.io.string_writer();\n+  print_type(pp.mkstate(writer.get_writer(), 0u), ty);\n+  ret writer.get_str();\n+}\n+\n impure fn hbox(ps s) {\n   pp.hbox(s, indent_unit);\n }\n@@ -85,24 +91,21 @@ impure fn print_type(ps s, @ast.ty ty) {\n       commasep[ast.ty_field](s, fields, f);\n       pclose(s);\n     }\n-    case (ast.ty_fn(?proto,?inputs,?output)) {\n-      if (proto == ast.proto_fn) {wrd(s, \"fn\");}\n-      else {wrd(s, \"iter\");}\n-      popen(s);\n-      impure fn print_arg(ps s, ast.ty_arg input) {\n-        if (middle.ty.mode_is_alias(input.mode)) {wrd(s, \"&\");}\n-        print_type(s, input.ty);\n-      }\n-      auto f = print_arg;\n-      commasep[ast.ty_arg](s, inputs, f);\n-      pclose(s);\n-      if (output.node != ast.ty_nil) {\n-        space(s);\n+    case (ast.ty_obj(?methods)) {\n+      wrd1(s, \"obj\");\n+      bopen(s);\n+      for (ast.ty_method m in methods) {\n         hbox(s);\n-        wrd1(s, \"->\");\n-        print_type(s, output);\n+        print_ty_fn(s, m.proto, option.some[str](m.ident),\n+                    m.inputs, m.output);\n+        wrd(s, \";\");\n         end(s);\n+        line(s);\n       }\n+      bclose(s);\n+    }\n+    case (ast.ty_fn(?proto,?inputs,?output)) {\n+      print_ty_fn(s, proto, option.none[str], inputs, output);\n     }\n     case (ast.ty_path(?path,_)) {\n       print_path(s, path);\n@@ -376,6 +379,7 @@ impure fn print_expr(ps s, @ast.expr expr) {\n           wrd1(s, \"else\");\n           print_expr(s, _else);\n         }\n+        case (_) { /* fall through */ }\n       }\n     }\n     case (ast.expr_while(?test,?block,_)) {\n@@ -503,8 +507,16 @@ impure fn print_expr(ps s, @ast.expr expr) {\n       wrd1(s, \"check\");\n       print_expr(s, expr);\n     }\n-    case (_) {wrd(s, \"X\");}\n-    // TODO expr_ext(path, vec[@expr], option.t[@expr], @expr, ann);\n+    case (ast.expr_ext(?path, ?args, ?body, _, _)) {\n+      wrd(s, \"#\");\n+      print_path(s, path);\n+      if (_vec.len[@ast.expr](args) > 0u) {\n+        popen(s);\n+        commasep[@ast.expr](s, args, pe);\n+        pclose(s);\n+      }\n+      // TODO: extension 'body'\n+    }\n   }\n   end(s);\n }\n@@ -706,3 +718,28 @@ fn escape_str(str st, char to_escape) -> str {\n impure fn print_string(ps s, str st) {\n   wrd(s, \"\\\"\"); wrd(s, escape_str(st, '\"')); wrd(s, \"\\\"\");\n }\n+\n+impure fn print_ty_fn(ps s, ast.proto proto, option.t[str] id,\n+                      vec[ast.ty_arg] inputs, @ast.ty output) {\n+  if (proto == ast.proto_fn) {wrd(s, \"fn\");}\n+  else {wrd(s, \"iter\");}\n+  alt (id) {\n+    case (option.some[str](?id)) {space(s); wrd(s, id);}\n+    case (_) {}\n+  }\n+  popen(s);\n+  impure fn print_arg(ps s, ast.ty_arg input) {\n+    if (middle.ty.mode_is_alias(input.mode)) {wrd(s, \"&\");}\n+    print_type(s, input.ty);\n+  }\n+  auto f = print_arg;\n+  commasep[ast.ty_arg](s, inputs, f);\n+  pclose(s);\n+  if (output.node != ast.ty_nil) {\n+    space(s);\n+    hbox(s);\n+    wrd1(s, \"->\");\n+    print_type(s, output);\n+    end(s);\n+  }\n+}"}, {"sha": "006aca62b0e851c8892b3d0e27eed12c2f43c1a3", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -8,13 +8,13 @@ mod front {\n     mod extfmt;\n     mod lexer;\n     mod parser;\n-    mod pretty;\n     mod token;\n     mod eval;\n }\n \n mod middle {\n     mod fold;\n+    mod metadata;\n     mod resolve;\n     mod trans;\n     mod ty;\n@@ -41,10 +41,12 @@ mod util {\n }\n \n auth driver.rustc.main = impure;\n+auth middle.metadata = unsafe;\n auth middle.trans = unsafe;\n auth middle.trans.copy_args_to_allocas = impure;\n auth middle.trans.trans_block = impure;\n auth lib.llvm = unsafe;\n+auth pretty.pprust = impure;\n \n mod lib {\n     alt (target_os) {"}, {"sha": "63ec2c692b12f82e0ae1624712f143137da74540", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -46,6 +46,10 @@ fn new_str_hash[V]() -> std.map.hashmap[str,V] {\n     ret std.map.mk_hashmap[str,V](hasher, eqer);\n }\n \n+fn def_eq(&ast.def_id a, &ast.def_id b) -> bool {\n+    ret a._0 == b._0 && a._1 == b._1;\n+}\n+\n fn new_def_hash[V]() -> std.map.hashmap[ast.def_id,V] {\n \n     fn hash(&ast.def_id d) -> uint {\n@@ -55,12 +59,8 @@ fn new_def_hash[V]() -> std.map.hashmap[ast.def_id,V] {\n         ret u;\n     }\n \n-    fn eq(&ast.def_id a, &ast.def_id b) -> bool {\n-        ret a._0 == b._0 && a._1 == b._1;\n-    }\n-\n     let std.map.hashfn[ast.def_id] hasher = hash;\n-    let std.map.eqfn[ast.def_id] eqer = eq;\n+    let std.map.eqfn[ast.def_id] eqer = def_eq;\n     ret std.map.mk_hashmap[ast.def_id,V](hasher, eqer);\n }\n "}, {"sha": "ee660f013b226726c62c9d73c6c85674eefb7a86", "filename": "src/lib/_int.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,4 +1,3 @@\n-import std.sys;\n \n fn add(int x, int y) -> int { ret x + y; }\n fn sub(int x, int y) -> int { ret x - y; }"}, {"sha": "3f45334924d8aee46404028da78d9b1e6b0ef816", "filename": "src/lib/_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,6 +1,6 @@\n import rustrt.sbuf;\n \n-import std._vec.rustrt.vbuf;\n+import _vec.rustrt.vbuf;\n \n native \"rust\" mod rustrt {\n     type sbuf;"}, {"sha": "ceee9c774789b9d63561153278952a9efa4edc3f", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,4 +1,3 @@\n-import std.sys;\n \n fn add(uint x, uint y) -> uint { ret x + y; }\n fn sub(uint x, uint y) -> uint { ret x - y; }"}, {"sha": "680c8884f6d1987d95b3fe6c22ab2f1e06cca2f6", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,5 +1,4 @@\n import vbuf = rustrt.vbuf;\n-import std.option;\n \n type operator2[T,U,V] = fn(&T, &U) -> V;\n "}, {"sha": "2322c693b4d19b0da56ef06bc783a3205ec2348e", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,7 +1,3 @@\n-import std._uint;\n-import std._int;\n-import std._vec;\n-\n // FIXME: With recursive object types, we could implement binary methods like\n //        union, intersection, and difference. At that point, we could write\n //        an optimizing version of this module that produces a different obj"}, {"sha": "b63f363e702796fa4156cc4f72ce52bbfe4fa085", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -5,8 +5,6 @@\n  * logging.\n  */\n \n-import std._vec;\n-\n // FIXME: handle 64-bit case.\n const uint const_refcount = 0x7bad_face_u;\n "}, {"sha": "776f82e99fe8fe9e4a303cedfc32d592224c65a4", "filename": "src/lib/deque.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -2,10 +2,6 @@\n  * A deque, for fun.  Untested as of yet.  Likely buggy.\n  */\n \n-import std.option;\n-import std._vec;\n-import std._int;\n-\n type t[T] = obj {\n             fn size() -> uint;\n "}, {"sha": "34c4a98d9ac4d7c1e8f065eb3b5aef30372c9ff6", "filename": "src/lib/io.rs", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,7 +1,4 @@\n-import std.os.libc;\n-import std._str;\n-import std._vec;\n-\n+import os.libc;\n \n type stdio_reader = state obj {\n                           fn getc() -> int;\n@@ -91,35 +88,29 @@ tag fileflag {\n     truncate;\n }\n \n-fn writefd(int fd, vec[u8] v) {\n-    auto len = _vec.len[u8](v);\n-    auto count = 0u;\n-    auto vbuf;\n-    while (count < len) {\n-        vbuf = _vec.buf_off[u8](v, count);\n-        auto nout = os.libc.write(fd, vbuf, len);\n-        if (nout < 0) {\n-            log \"error dumping buffer\";\n-            log sys.rustrt.last_os_error();\n-            fail;\n+state obj fd_buf_writer(int fd, bool must_close) {\n+    fn write(vec[u8] v) {\n+        auto len = _vec.len[u8](v);\n+        auto count = 0u;\n+        auto vbuf;\n+        while (count < len) {\n+            vbuf = _vec.buf_off[u8](v, count);\n+            auto nout = os.libc.write(fd, vbuf, len);\n+            if (nout < 0) {\n+                log \"error dumping buffer\";\n+                log sys.rustrt.last_os_error();\n+                fail;\n+            }\n+            count += nout as uint;\n         }\n-        count += nout as uint;\n     }\n-}\n-\n-fn new_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n-\n-    state obj fd_buf_writer(int fd) {\n \n-        fn write(vec[u8] v) {\n-            writefd(fd, v);\n-        }\n-\n-        drop {\n-            os.libc.close(fd);\n-        }\n+    drop {\n+        if (must_close) {os.libc.close(fd);}\n     }\n+}\n \n+fn file_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n     let int fflags =\n         os.libc_constants.O_WRONLY() |\n         os.libc_constants.O_BINARY();\n@@ -142,26 +133,58 @@ fn new_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n         log sys.rustrt.last_os_error();\n         fail;\n     }\n-    ret fd_buf_writer(fd);\n+    ret fd_buf_writer(fd, true);\n }\n \n type writer =\n     state obj {\n-          fn write_str(str s);\n-          fn write_int(int n);\n-          fn write_uint(uint n);\n+          impure fn write_str(str s);\n+          impure fn write_int(int n);\n+          impure fn write_uint(uint n);\n     };\n \n-fn file_writer(str path,\n-               vec[fileflag] flags)\n-    -> writer\n-{\n-    state obj fw(buf_writer out) {\n-        fn write_str(str s)   { out.write(_str.bytes(s)); }\n-        fn write_int(int n)   { out.write(_str.bytes(_int.to_str(n, 10u))); }\n-        fn write_uint(uint n) { out.write(_str.bytes(_uint.to_str(n, 10u))); }\n+state obj new_writer(buf_writer out) {\n+    impure fn write_str(str s) {\n+        out.write(_str.bytes(s));\n+    }\n+    impure fn write_int(int n) {\n+        out.write(_str.bytes(_int.to_str(n, 10u)));\n+    }\n+    impure fn write_uint(uint n) {\n+        out.write(_str.bytes(_uint.to_str(n, 10u)));\n+    }\n+}\n+\n+fn file_writer(str path, vec[fileflag] flags) -> writer {\n+    ret new_writer(file_buf_writer(path, flags));\n+}\n+\n+// FIXME it would be great if this could be a const named stdout\n+fn stdout_writer() -> writer {\n+    ret new_writer(fd_buf_writer(1, false));\n+}\n+\n+type str_writer =\n+    state obj {\n+          fn get_writer() -> writer;\n+          fn get_str() -> str;\n+    };\n+\n+type str_buf = @rec(mutable str buf);\n+\n+// TODO awkward! it's not possible to implement a writer with an extra method\n+fn string_writer() -> str_writer {\n+    auto buf = @rec(mutable buf = \"\");\n+    state obj str_writer_writer(str_buf buf) {\n+        impure fn write_str(str s)   { buf.buf += s; }\n+        impure fn write_int(int n)   { buf.buf += _int.to_str(n, 10u); }\n+        impure fn write_uint(uint n) { buf.buf += _uint.to_str(n, 10u); }\n+    }\n+    state obj str_writer_wrap(writer wr, str_buf buf) {\n+        fn get_writer() -> writer {ret wr;}\n+        fn get_str() -> str {ret buf.buf;}\n     }\n-    ret fw(new_buf_writer(path, flags));\n+    ret str_writer_wrap(str_writer_writer(buf), buf);\n }\n \n //"}, {"sha": "58c2cded6e642ea8e3496c9f9c2d04ef92f431e2", "filename": "src/lib/list.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -1,5 +1,3 @@\n-\n-import std.option;\n import option.some;\n import option.none;\n "}, {"sha": "29e9ba5d6915f9d9d1aa9fc1c55b8f29e8c4fedf", "filename": "src/lib/map.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -3,12 +3,6 @@\n  * use, but useful as a stress test for rustboot.\n  */\n \n-import std._int;\n-import std.sys;\n-import std.option;\n-import std._vec;\n-\n-\n type hashfn[K] = fn(&K) -> uint;\n type eqfn[K] = fn(&K, &K) -> bool;\n "}, {"sha": "a57ea894cdfb80f77e7084f7516fb4fdaa1b11f0", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -4,9 +4,6 @@\n  * point this will want to be rewritten.\n  */\n \n-import std._vec;\n-import std._str;\n-\n export sha1;\n export mk_sha1;\n "}, {"sha": "f390870fb330556e0a0b3671c06ce4b519a01544", "filename": "src/llvmext/Object.cpp", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fllvmext%2FObject.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fllvmext%2FObject.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvmext%2FObject.cpp?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,55 @@\n+//===- Object.cpp - C bindings to the object file library--------*- C++ -*-===//\n+//\n+//                     The LLVM Compiler Infrastructure\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines the C bindings to the file-format-independent object\n+// library.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm-c/Object.h\"\n+\n+using namespace llvm;\n+using namespace object;\n+\n+LLVMObjectFileRef LLVMCreateObjectFile(const char *ObjectPath) {\n+  StringRef SR(ObjectPath);\n+  return wrap(ObjectFile::createObjectFile(SR));\n+}\n+\n+void LLVMDisposeObjectFile(LLVMObjectFileRef ObjectFile) {\n+  delete unwrap(ObjectFile);\n+}\n+\n+LLVMSectionIteratorRef LLVMGetSections(LLVMObjectFileRef ObjectFile) {\n+  ObjectFile::section_iterator SI = unwrap(ObjectFile)->begin_sections();\n+  return wrap(new ObjectFile::section_iterator(SI));\n+}\n+\n+void LLVMDisposeSectionIterator(LLVMSectionIteratorRef SI) {\n+  delete unwrap(SI);\n+}\n+\n+void LLVMMoveToNextSection(LLVMSectionIteratorRef SI) {\n+  ObjectFile::section_iterator UnwrappedSI = *unwrap(SI);\n+  ++UnwrappedSI;\n+}\n+\n+const char *LLVMGetSectionName(LLVMSectionIteratorRef SI) {\n+  return (*unwrap(SI))->getName().data();\n+}\n+\n+uint64_t LLVMGetSectionSize(LLVMSectionIteratorRef SI) {\n+  return (*unwrap(SI))->getSize();\n+}\n+\n+const char *LLVMGetSectionContents(LLVMSectionIteratorRef SI) {\n+  return (*unwrap(SI))->getContents().data();\n+}\n+"}, {"sha": "31495f22c0a5044d3db2c95b567cafd4542c53c8", "filename": "src/llvmext/README", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fllvmext%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fllvmext%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvmext%2FREADME?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,3 @@\n+This directory currently contains some LLVM support code. This will generally\n+be sent upstream to LLVM in time; for now it lives here.\n+"}, {"sha": "a65a2352aa0a17aa47e9336107f1d9bb4a6b6ebd", "filename": "src/llvmext/include/llvm-c/Object.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fllvmext%2Finclude%2Fllvm-c%2FObject.h", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Fllvmext%2Finclude%2Fllvm-c%2FObject.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvmext%2Finclude%2Fllvm-c%2FObject.h?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,75 @@\n+/*===-- llvm-c/Object.h - Object Lib C Iface --------------------*- C++ -*-===*/\n+/*                                                                            */\n+/*                     The LLVM Compiler Infrastructure                       */\n+/*                                                                            */\n+/* This file is distributed under the University of Illinois Open Source      */\n+/* License. See LICENSE.TXT for details.                                      */\n+/*                                                                            */\n+/*===----------------------------------------------------------------------===*/\n+/*                                                                            */\n+/* This header declares the C interface to libLLVMObject.a, which             */\n+/* implements object file reading and writing.                                */\n+/*                                                                            */\n+/* Many exotic languages can interoperate with C code but have a harder time  */\n+/* with C++ due to name mangling. So in addition to C, this interface enables */\n+/* tools written in such languages.                                           */\n+/*                                                                            */\n+/*===----------------------------------------------------------------------===*/\n+\n+#ifndef LLVM_C_OBJECT_H\n+#define LLVM_C_OBJECT_H\n+\n+#include \"llvm-c/Core.h\"\n+#include \"llvm/Config/llvm-config.h\"\n+\n+#ifdef __cplusplus\n+#include \"llvm/Object/ObjectFile.h\"\n+\n+extern \"C\" {\n+#endif\n+\n+\n+typedef struct LLVMOpaqueObjectFile *LLVMObjectFileRef;\n+\n+typedef struct LLVMOpaqueSectionIterator *LLVMSectionIteratorRef;\n+\n+LLVMObjectFileRef LLVMCreateObjectFile(const char *ObjectPath);\n+void LLVMDisposeObjectFile(LLVMObjectFileRef ObjectFile);\n+\n+LLVMSectionIteratorRef LLVMGetSections(LLVMObjectFileRef ObjectFile);\n+void LLVMDisposeSectionIterator(LLVMSectionIteratorRef SI);\n+void LLVMMoveToNextSection(LLVMSectionIteratorRef SI);\n+const char *LLVMGetSectionName(LLVMSectionIteratorRef SI);\n+uint64_t LLVMGetSectionSize(LLVMSectionIteratorRef SI);\n+const char *LLVMGetSectionContents(LLVMSectionIteratorRef SI);\n+\n+\n+#ifdef __cplusplus\n+}\n+\n+namespace llvm {\n+  namespace object {\n+    inline ObjectFile *unwrap(LLVMObjectFileRef OF) {\n+      return reinterpret_cast<ObjectFile*>(OF);\n+    }\n+\n+    inline LLVMObjectFileRef wrap(const ObjectFile *OF) {\n+      return reinterpret_cast<LLVMObjectFileRef>(const_cast<ObjectFile*>(OF));\n+    }\n+\n+    inline ObjectFile::section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n+      return reinterpret_cast<ObjectFile::section_iterator*>(SI);\n+    }\n+\n+    inline LLVMSectionIteratorRef\n+    wrap(const ObjectFile::section_iterator *SI) {\n+      return reinterpret_cast<LLVMSectionIteratorRef>\n+        (const_cast<ObjectFile::section_iterator*>(SI));\n+    }\n+  }\n+}\n+\n+#endif /* defined(__cplusplus) */\n+\n+#endif\n+"}, {"sha": "5115d5109a9da01b987b1940cacc72397dff7a78", "filename": "src/test/run-pass/box-compare.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+  check (@1 < @3);\n+  check (@@\"hello \" > @@\"hello\");\n+  check (@@@\"hello\" != @@@\"there\");\n+}\n\\ No newline at end of file"}, {"sha": "95a8cab48cc15b6de67fbace48cb2236a43e8b9a", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,10 @@\n+fn id[T](&T t) -> T {\n+  ret t;\n+}\n+\n+fn main() {\n+  auto t = tup(1,2,3,4,5,6,7);\n+  check (t._5 == 6);\n+  auto f0 = bind id[tup(int,int,int,int,int,int,int)](t);\n+  check (f0()._5 == 6);\n+}"}, {"sha": "ef1275e3cecd6ebae893c7201dcfe5ccbe078f50", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -3,6 +3,8 @@ fn id[T](&T t) -> T {\n }\n \n fn main() {\n-  auto f = bind id[int](_);\n-  check (f(10) == 10);\n+  auto t = tup(1,2,3,4,5,6,7);\n+  check (t._5 == 6);\n+  auto f1 = bind id[tup(int,int,int,int,int,int,int)](_);\n+  check (f1(t)._5 == 6);\n }"}, {"sha": "9b19eec7388e3d5f9a8699e5746abc0a225b0105", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -2,7 +2,7 @@ tag foo[T] {\n   arm(T);\n }\n \n-fn altfoo[T](foo[T] f) {\n+fn altfoo[T](&foo[T] f) {\n   auto hit = false;\n   alt (f) {\n     case (arm[T](?x)) {"}, {"sha": "63e2e195285b1f1fd3be85aa4a9bc6c328177048", "filename": "src/test/run-pass/generic-tag-local.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-tag-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fgeneric-tag-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-local.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,8 @@\n+tag clam[T] {\n+    a(T);\n+}\n+\n+fn main() {\n+    auto c = a(3);\n+}\n+"}, {"sha": "25d87c6e874939a0b0b2a9dc92ea98e9e0d72509", "filename": "src/test/run-pass/leak-tag-copy.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fleak-tag-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fleak-tag-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fleak-tag-copy.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,9 @@\n+tag t {\n+  a;\n+  b(@int);\n+}\n+\n+fn main() {\n+  auto x = b(@10);\n+  x = a;\n+}\n\\ No newline at end of file"}, {"sha": "b3fe570193d6b2fa3607499bca56fef6ec092c11", "filename": "src/test/run-pass/seq-compare.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,15 @@\n+fn main() {\n+  check (\"hello\" < \"hellr\");\n+  check (\"hello \" > \"hello\");\n+  check (\"hello\" != \"there\");\n+\n+  check (vec(1,2,3,4) > vec(1,2,3));\n+  check (vec(1,2,3) < vec(1,2,3,4));\n+  check (vec(1,2,4,4) > vec(1,2,3,4));\n+  check (vec(1,2,3,4) < vec(1,2,4,4));\n+  check (vec(1,2,3) <= vec(1,2,3));\n+  check (vec(1,2,3) <= vec(1,2,3,3));\n+  check (vec(1,2,3,4) > vec(1,2,3));\n+  check (vec(1,2,3) == vec(1,2,3));\n+  check (vec(1,2,3) != vec(1,1,3));\n+}\n\\ No newline at end of file"}, {"sha": "85db5c7c168affac6fc98ad329093281465ad3b4", "filename": "src/test/run-pass/simple-generic-alt.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fsimple-generic-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fsimple-generic-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimple-generic-alt.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,11 @@\n+tag clam[T] {\n+    a(T);\n+}\n+\n+fn main() {\n+    auto c = a(2);\n+    alt (c) {\n+        case (a[int](_)) {}\n+    }\n+}\n+"}, {"sha": "ba6a3242737cc82edaefb3e4c5f03ae8d53bf9c9", "filename": "src/test/run-pass/simple-generic-tag.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fsimple-generic-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb6836da003be71744b6e6ea7af1fd4674f8291/src%2Ftest%2Frun-pass%2Fsimple-generic-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimple-generic-tag.rs?ref=bbb6836da003be71744b6e6ea7af1fd4674f8291", "patch": "@@ -0,0 +1,7 @@\n+tag clam[T] {\n+    a(T);\n+}\n+\n+fn main() {\n+}\n+"}]}