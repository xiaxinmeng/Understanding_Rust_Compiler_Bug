{"sha": "fbad0204e477537e350963014af936b1646d6d7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYWQwMjA0ZTQ3NzUzN2UzNTA5NjMwMTRhZjkzNmIxNjQ2ZDZkN2E=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-01-09T18:35:48Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-01-09T18:35:48Z"}, "message": "Merge pull request #1470 from grahame/grahame\n\nadd new read_chars method, fix bug in read_char", "tree": {"sha": "96e808eafe33c4ccc633750a402ad648934cde90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96e808eafe33c4ccc633750a402ad648934cde90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbad0204e477537e350963014af936b1646d6d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbad0204e477537e350963014af936b1646d6d7a", "html_url": "https://github.com/rust-lang/rust/commit/fbad0204e477537e350963014af936b1646d6d7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbad0204e477537e350963014af936b1646d6d7a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b20e8c88b356cd83ad265e47ed1575e1b40ab45", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b20e8c88b356cd83ad265e47ed1575e1b40ab45", "html_url": "https://github.com/rust-lang/rust/commit/6b20e8c88b356cd83ad265e47ed1575e1b40ab45"}, {"sha": "ba694775f5ea61c9b29e318bbe2e4d942adb39ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba694775f5ea61c9b29e318bbe2e4d942adb39ad", "html_url": "https://github.com/rust-lang/rust/commit/ba694775f5ea61c9b29e318bbe2e4d942adb39ad"}], "stats": {"total": 131, "additions": 111, "deletions": 20}, "files": [{"sha": "63f014005dd9cca35f6f0df197dc17e4c6831234", "filename": "src/libstd/io.rs", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fbad0204e477537e350963014af936b1646d6d7a/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbad0204e477537e350963014af936b1646d6d7a/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=fbad0204e477537e350963014af936b1646d6d7a", "patch": "@@ -50,6 +50,7 @@ type reader =\n         fn unread_byte(int);\n         fn read_bytes(uint) -> [u8];\n         fn read_char() -> char;\n+        fn read_chars(uint) -> [char];\n         fn eof() -> bool;\n         fn read_line() -> str;\n         fn read_c_str() -> str;\n@@ -101,29 +102,71 @@ obj new_reader(rdr: buf_reader) {\n     fn read_byte() -> int { ret rdr.read_byte(); }\n     fn unread_byte(byte: int) { ret rdr.unread_byte(byte); }\n     fn read_bytes(len: uint) -> [u8] { ret rdr.read(len); }\n+    fn read_chars(n: uint) -> [char] {\n+        // returns the (consumed offset, n_req), appends characters to &chars\n+        fn chars_from_buf(buf: [u8], &chars: [char]) -> (uint, uint) {\n+            let i = 0u;\n+            while i < vec::len(buf) {\n+                let b0 = buf[i];\n+                let w = str::utf8_char_width(b0);\n+                let end = i + w;\n+                i += 1u;\n+                assert (w > 0u);\n+                if w == 1u {\n+                    chars += [ b0 as char ];\n+                    cont;\n+                }\n+                // can't satisfy this char with the existing data\n+                if end > vec::len(buf) {\n+                    ret (i - 1u, end - vec::len(buf));\n+                }\n+                let val = 0u;\n+                while i < end {\n+                    let next = buf[i] as int;\n+                    i += 1u;\n+                    assert (next > -1);\n+                    assert (next & 192 == 128);\n+                    val <<= 6u;\n+                    val += next & 63 as uint;\n+                }\n+                // See str::char_at\n+                val += (b0 << (w + 1u as u8) as uint)\n+                    << (w - 1u) * 6u - w - 1u;\n+                chars += [ val as char ];\n+            }\n+            ret (i, 0u);\n+        }\n+        let buf: [u8] = [];\n+        let chars: [char] = [];\n+        // might need more bytes, but reading n will never over-read\n+        let nbread = n;\n+        while nbread > 0u {\n+            let data = self.read_bytes(nbread);\n+            if vec::len(data) == 0u {\n+                // eof - FIXME should we do something if\n+                // we're split in a unicode char?\n+                break;\n+            }\n+            buf += data;\n+            let (offset, nbreq) = chars_from_buf(buf, chars);\n+            let ncreq = n - vec::len(chars);\n+            // again we either know we need a certain number of bytes\n+            // to complete a character, or we make sure we don't\n+            // over-read by reading 1-byte per char needed\n+            nbread = if ncreq > nbreq { ncreq } else { nbreq };\n+            if nbread > 0u {\n+                buf = vec::slice(buf, offset, vec::len(buf));\n+            }\n+        }\n+        ret chars;\n+    }\n     fn read_char() -> char {\n-        let c0 = rdr.read_byte();\n-        if c0 == -1 {\n+        let c = self.read_chars(1u);\n+        if vec::len(c) == 0u {\n             ret -1 as char; // FIXME will this stay valid?\n-\n         }\n-        let b0 = c0 as u8;\n-        let w = str::utf8_char_width(b0);\n-        assert (w > 0u);\n-        if w == 1u { ret b0 as char; }\n-        let val = 0u;\n-        while w > 1u {\n-            w -= 1u;\n-            let next = rdr.read_byte();\n-            assert (next > -1);\n-            assert (next & 192 == 128);\n-            val <<= 6u;\n-            val += next & 63 as uint;\n-        }\n-        // See str::char_at\n-\n-        val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n-        ret val as char;\n+        assert(vec::len(c) == 1u);\n+        ret c[0];\n     }\n     fn eof() -> bool { ret rdr.eof(); }\n     fn read_line() -> str {"}, {"sha": "23c18acef0d8eea505b0ae05dc95a5cc7dd059dc", "filename": "src/test/stdtest/io.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fbad0204e477537e350963014af936b1646d6d7a/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbad0204e477537e350963014af936b1646d6d7a/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=fbad0204e477537e350963014af936b1646d6d7a", "patch": "@@ -23,6 +23,54 @@ fn test_simple() {\n     assert (str::eq(frood, frood2));\n }\n \n+#[test]\n+fn test_readchars_empty() {\n+    let inp : io::reader = io::string_reader(\"\");\n+    let res : [char] = inp.read_chars(128u);\n+    assert(vec::len(res) == 0u);\n+}\n+\n+#[test]\n+fn test_readchars_wide() {\n+    let wide_test = \"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n+    let ivals : [int] = [\n+        29983, 38152, 30340, 27748,\n+        21273, 20999, 32905, 27748,\n+        104, 101, 108, 108, 111,\n+        29983, 38152, 30340, 27748,\n+        21273, 20999, 32905, 27748];\n+    fn check_read_ln(len : uint, s: str, ivals: [int]) {\n+        let inp : io::reader = io::string_reader(s);\n+        let res : [char] = inp.read_chars(len);\n+        if (len <= vec::len(ivals)) {\n+            assert(vec::len(res) == len);\n+        }\n+        assert(vec::slice(ivals, 0u, vec::len(res)) ==\n+               vec::map(res, {|x| x as int}));\n+    }\n+    let i = 0u;\n+    while i < 8u {\n+        check_read_ln(i, wide_test, ivals);\n+        i += 1u;\n+    }\n+    // check a long read for good measure\n+    check_read_ln(128u, wide_test, ivals);\n+}\n+\n+#[test]\n+fn test_readchar() {\n+    let inp : io::reader = io::string_reader(\"\u751f\");\n+    let res : char = inp.read_char();\n+    assert(res as int == 29983);\n+}\n+\n+#[test]\n+fn test_readchar_empty() {\n+    let inp : io::reader = io::string_reader(\"\");\n+    let res : char = inp.read_char();\n+    assert(res as int == -1);\n+}\n+\n #[test]\n fn file_reader_not_exist() {\n     alt io::file_reader(\"not a file\") {"}]}