{"sha": "ef71df106b957eb84c1f028240ba8e85b614d043", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNzFkZjEwNmI5NTdlYjg0YzFmMDI4MjQwYmE4ZTg1YjYxNGQwNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-27T02:38:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-27T02:38:50Z"}, "message": "Auto merge of #71600 - Dylan-DPC:rollup-7tvzi9n, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #68716 (Stabilize `Span::mixed_site`)\n - #71263 (Remove unused abs_path method from rustc_span::source_map::FileLoader)\n - #71409 (Point at the return type on `.into()` failure caused by `?`)\n - #71419 (add message for resolution failure because wrong namespace)\n - #71438 (Tweak some suggestions in `rustc_resolve`)\n - #71589 (remove Unique::from for shared pointer types)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "01ecd1395ad020e1f69435278418196d4ada5ebf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01ecd1395ad020e1f69435278418196d4ada5ebf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef71df106b957eb84c1f028240ba8e85b614d043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef71df106b957eb84c1f028240ba8e85b614d043", "html_url": "https://github.com/rust-lang/rust/commit/ef71df106b957eb84c1f028240ba8e85b614d043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef71df106b957eb84c1f028240ba8e85b614d043/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5794e779a62aa1208311ac8b4f9603cad8f31912", "url": "https://api.github.com/repos/rust-lang/rust/commits/5794e779a62aa1208311ac8b4f9603cad8f31912", "html_url": "https://github.com/rust-lang/rust/commit/5794e779a62aa1208311ac8b4f9603cad8f31912"}, {"sha": "cddbed00032080b947542307249fa141331887be", "url": "https://api.github.com/repos/rust-lang/rust/commits/cddbed00032080b947542307249fa141331887be", "html_url": "https://github.com/rust-lang/rust/commit/cddbed00032080b947542307249fa141331887be"}], "stats": {"total": 324, "additions": 206, "deletions": 118}, "files": [{"sha": "5569c293e2f6605e50ba1e0f7250188b19d4337a", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -131,7 +131,7 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(ptr) }\n+        BoxedNode { ptr: Unique::new_unchecked(ptr.as_ptr()) }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {"}, {"sha": "ca165b61e26a7da30b2c3e210992a2d8412e4d9a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -151,7 +151,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n \n             let memory = alloc.alloc(layout, init).unwrap_or_else(|_| handle_alloc_error(layout));\n             Self {\n-                ptr: memory.ptr.cast().into(),\n+                ptr: unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) },\n                 cap: Self::capacity_from_bytes(memory.size),\n                 alloc,\n             }\n@@ -469,7 +469,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     fn set_memory(&mut self, memory: MemoryBlock) {\n-        self.ptr = memory.ptr.cast().into();\n+        self.ptr = unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) };\n         self.cap = Self::capacity_from_bytes(memory.size);\n     }\n "}, {"sha": "d93dc1f32623187bb8ffe2fd8c51e171091526e1", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -3,7 +3,6 @@ use crate::fmt;\n use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n-use crate::ptr::NonNull;\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -171,19 +170,3 @@ impl<T: ?Sized> From<&mut T> for Unique<T> {\n         unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n     }\n }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: ?Sized> From<&T> for Unique<T> {\n-    #[inline]\n-    fn from(reference: &T) -> Self {\n-        unsafe { Unique { pointer: reference as *const T, _marker: PhantomData } }\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: ?Sized> From<NonNull<T>> for Unique<T> {\n-    #[inline]\n-    fn from(p: NonNull<T>) -> Self {\n-        unsafe { Unique::new_unchecked(p.as_ptr()) }\n-    }\n-}"}, {"sha": "31bc61263abe682deb801863cf340a806fc244a5", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -303,7 +303,7 @@ impl Span {\n     /// definition site (local variables, labels, `$crate`) and sometimes at the macro\n     /// call site (everything else).\n     /// The span location is taken from the call-site.\n-    #[unstable(feature = \"proc_macro_mixed_site\", issue = \"65049\")]\n+    #[stable(feature = \"proc_macro_mixed_site\", since = \"1.45.0\")]\n     pub fn mixed_site() -> Span {\n         Span(bridge::client::Span::mixed_site())\n     }"}, {"sha": "f6213189d9443fbf98715e19a4fb9fb88cdc72fc", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -383,7 +383,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         has_self_arg\n     }\n \n-    fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n+    fn followed_by_brace(&self, span: Span) -> (bool, Option<Span>) {\n         // HACK(estebank): find a better way to figure out that this was a\n         // parser issue where a struct literal is being used on an expression\n         // where a brace being opened means a block is being started. Look\n@@ -406,18 +406,15 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n             _ => false,\n         };\n         // In case this could be a struct literal that needs to be surrounded\n-        // by parenthesis, find the appropriate span.\n+        // by parentheses, find the appropriate span.\n         let mut i = 0;\n         let mut closing_brace = None;\n         loop {\n             sp = sm.next_point(sp);\n             match sm.span_to_snippet(sp) {\n                 Ok(ref snippet) => {\n                     if snippet == \"}\" {\n-                        let sp = span.to(sp);\n-                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                            closing_brace = Some((sp, snippet));\n-                        }\n+                        closing_brace = Some(span.to(sp));\n                         break;\n                     }\n                 }\n@@ -479,17 +476,23 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                     suggested = path_sep(err, &parent);\n                 }\n                 PathSource::Expr(None) if followed_by_brace => {\n-                    if let Some((sp, snippet)) = closing_brace {\n-                        err.span_suggestion(\n-                            sp,\n-                            \"surround the struct literal with parenthesis\",\n-                            format!(\"({})\", snippet),\n+                    if let Some(sp) = closing_brace {\n+                        err.multipart_suggestion(\n+                            \"surround the struct literal with parentheses\",\n+                            vec![\n+                                (sp.shrink_to_lo(), \"(\".to_string()),\n+                                (sp.shrink_to_hi(), \")\".to_string()),\n+                            ],\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n                         err.span_label(\n-                            span, // Note the parenthesis surrounding the suggestion below\n-                            format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n+                            span, // Note the parentheses surrounding the suggestion below\n+                            format!(\n+                                \"you might want to surround a struct literal with parentheses: \\\n+                                 `({} {{ /* fields */ }})`?\",\n+                                path_str\n+                            ),\n                         );\n                     }\n                     suggested = true;\n@@ -516,10 +519,16 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                     err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n                 }\n             }\n-            (Res::Def(DefKind::TyAlias, _), PathSource::Trait(_)) => {\n+            (Res::Def(DefKind::TyAlias, def_id), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n                 if nightly_options::is_nightly_build() {\n-                    err.note(\"did you mean to use a trait alias?\");\n+                    let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n+                               `type` alias\";\n+                    if let Some(span) = self.r.definitions.opt_span(def_id) {\n+                        err.span_help(span, msg);\n+                    } else {\n+                        err.help(msg);\n+                    }\n                 }\n             }\n             (Res::Def(DefKind::Mod, _), PathSource::Expr(Some(parent))) => {"}, {"sha": "d84edbe3ad77b0378b70c07c737e5322be8805fc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 83, "deletions": 45, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -2066,52 +2066,64 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n \n-            let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(\n-                    module,\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    record_used,\n-                    path_span,\n-                )\n-            } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n-                let scopes = ScopeSet::All(ns, opt_ns.is_none());\n-                self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    scopes,\n-                    parent_scope,\n-                    record_used,\n-                    record_used,\n-                    path_span,\n-                )\n-            } else {\n-                let record_used_id =\n-                    if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n-                match self.resolve_ident_in_lexical_scope(\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    record_used_id,\n-                    path_span,\n-                    &ribs.unwrap()[ns],\n-                ) {\n-                    // we found a locally-imported or available item/module\n-                    Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                    // we found a local variable or type param\n-                    Some(LexicalScopeBinding::Res(res))\n-                        if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n-                    {\n-                        record_segment_res(self, res);\n-                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                            res,\n-                            path.len() - 1,\n-                        ));\n+            enum FindBindingResult<'a> {\n+                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n+                PathResult(PathResult<'a>),\n+            }\n+            let find_binding_in_ns = |this: &mut Self, ns| {\n+                let binding = if let Some(module) = module {\n+                    this.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        record_used,\n+                        path_span,\n+                    )\n+                } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n+                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n+                    this.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        record_used,\n+                        record_used,\n+                        path_span,\n+                    )\n+                } else {\n+                    let record_used_id = if record_used {\n+                        crate_lint.node_id().or(Some(CRATE_NODE_ID))\n+                    } else {\n+                        None\n+                    };\n+                    match this.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        record_used_id,\n+                        path_span,\n+                        &ribs.unwrap()[ns],\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                        // we found a local variable or type param\n+                        Some(LexicalScopeBinding::Res(res))\n+                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n+                        {\n+                            record_segment_res(this, res);\n+                            return FindBindingResult::PathResult(PathResult::NonModule(\n+                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n+                            ));\n+                        }\n+                        _ => Err(Determinacy::determined(record_used)),\n                     }\n-                    _ => Err(Determinacy::determined(record_used)),\n-                }\n+                };\n+                FindBindingResult::Binding(binding)\n+            };\n+            let binding = match find_binding_in_ns(self, ns) {\n+                FindBindingResult::PathResult(x) => return x,\n+                FindBindingResult::Binding(binding) => binding,\n             };\n-\n             match binding {\n                 Ok(binding) => {\n                     if i == 1 {\n@@ -2201,7 +2213,33 @@ impl<'a> Resolver<'a> {\n                     } else if i == 0 {\n                         (format!(\"use of undeclared type or module `{}`\", ident), None)\n                     } else {\n-                        (format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident), None)\n+                        let mut msg =\n+                            format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident);\n+                        if ns == TypeNS || ns == ValueNS {\n+                            let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n+                            if let FindBindingResult::Binding(Ok(binding)) =\n+                                find_binding_in_ns(self, ns_to_try)\n+                            {\n+                                let mut found = |what| {\n+                                    msg = format!(\n+                                        \"expected {}, found {} `{}` in `{}`\",\n+                                        ns.descr(),\n+                                        what,\n+                                        ident,\n+                                        path[i - 1].ident\n+                                    )\n+                                };\n+                                if binding.module().is_some() {\n+                                    found(\"module\")\n+                                } else {\n+                                    match binding.res() {\n+                                        def::Res::<NodeId>::Def(kind, id) => found(kind.descr(id)),\n+                                        _ => found(ns_to_try.descr()),\n+                                    }\n+                                }\n+                            };\n+                        }\n+                        (msg, None)\n                     };\n                     return PathResult::Failed {\n                         span: ident.span,"}, {"sha": "d27aae0d6ed9b4e87d33a8af62489746005e70b5", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -20,7 +20,6 @@ use std::path::{Path, PathBuf};\n use std::sync::atomic::Ordering;\n \n use log::debug;\n-use std::env;\n use std::fs;\n use std::io;\n \n@@ -64,9 +63,6 @@ pub trait FileLoader {\n     /// Query the existence of a file.\n     fn file_exists(&self, path: &Path) -> bool;\n \n-    /// Returns an absolute path to a file, if possible.\n-    fn abs_path(&self, path: &Path) -> Option<PathBuf>;\n-\n     /// Read the contents of an UTF-8 file into memory.\n     fn read_file(&self, path: &Path) -> io::Result<String>;\n }\n@@ -79,14 +75,6 @@ impl FileLoader for RealFileLoader {\n         fs::metadata(path).is_ok()\n     }\n \n-    fn abs_path(&self, path: &Path) -> Option<PathBuf> {\n-        if path.is_absolute() {\n-            Some(path.to_path_buf())\n-        } else {\n-            env::current_dir().ok().map(|cwd| cwd.join(path))\n-        }\n-    }\n-\n     fn read_file(&self, path: &Path) -> io::Result<String> {\n         fs::read_to_string(path)\n     }"}, {"sha": "35eb5d73adac6cb25a9cbebf0835842fb7000d2e", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -317,20 +317,30 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 .starts_with(\"std::convert::From<std::option::NoneError\");\n                         let should_convert_result_to_option = format!(\"{}\", trait_ref)\n                             .starts_with(\"<std::option::NoneError as std::convert::From<\");\n-                        if is_try && is_from && should_convert_option_to_result {\n-                            err.span_suggestion_verbose(\n-                                span.shrink_to_lo(),\n-                                \"consider converting the `Option<T>` into a `Result<T, _>` using `Option::ok_or` or `Option::ok_or_else`\",\n-                                \".ok_or_else(|| /* error value */)\".to_string(),\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        } else if is_try && is_from && should_convert_result_to_option {\n-                            err.span_suggestion_verbose(\n-                                span.shrink_to_lo(),\n-                                \"consider converting the `Result<T, _>` into an `Option<T>` using `Result::ok`\",\n-                                \".ok()\".to_string(),\n-                                Applicability::MachineApplicable,\n-                            );\n+                        if is_try && is_from {\n+                            if should_convert_option_to_result {\n+                                err.span_suggestion_verbose(\n+                                    span.shrink_to_lo(),\n+                                    \"consider converting the `Option<T>` into a `Result<T, _>` \\\n+                                     using `Option::ok_or` or `Option::ok_or_else`\",\n+                                    \".ok_or_else(|| /* error value */)\".to_string(),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            } else if should_convert_result_to_option {\n+                                err.span_suggestion_verbose(\n+                                    span.shrink_to_lo(),\n+                                    \"consider converting the `Result<T, _>` into an `Option<T>` \\\n+                                     using `Result::ok`\",\n+                                    \".ok()\".to_string(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                            if let Some(ret_span) = self.return_type_span(obligation) {\n+                                err.span_label(\n+                                    ret_span,\n+                                    &format!(\"expected `{}` because of this\", trait_ref.self_ty()),\n+                                );\n+                            }\n                         }\n \n                         let explanation ="}, {"sha": "a927013e25f5f101d3a3ce40ffaf72e71bd7bcdc", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -84,6 +84,8 @@ pub trait InferCtxtExt<'tcx> {\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     );\n \n+    fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span>;\n+\n     fn suggest_impl_trait(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -761,6 +763,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span> {\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let sig = match hir.find(parent_node) {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, ..), .. })) => sig,\n+            _ => return None,\n+        };\n+\n+        if let hir::FnRetTy::Return(ret_ty) = sig.decl.output { Some(ret_ty.span) } else { None }\n+    }\n+\n     /// If all conditions are met to identify a returned `dyn Trait`, suggest using `impl Trait` if\n     /// applicable and signal that the error has been expanded appropriately and needs to be\n     /// emitted."}, {"sha": "de2ffc2e5dc1d0e1e704c139262e638096c120d3", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -4,7 +4,11 @@ error[E0404]: expected trait, found type alias `Bar`\n LL | impl Bar for Baz { }\n    |      ^^^ type aliases cannot be used as traits\n    |\n-   = note: did you mean to use a trait alias?\n+help: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n+  --> $DIR/two_files_data.rs:5:1\n+   |\n+LL | type Bar = dyn Foo;\n+   | ^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d4860394259b7e1aeac169d0d628c8926c42cac2", "filename": "src/test/ui/error-codes/E0423.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -45,9 +45,12 @@ error[E0423]: expected value, found struct `T`\n   --> $DIR/E0423.rs:14:8\n    |\n LL |     if T {} == T {} { println!(\"Ok\"); }\n-   |        ^---\n-   |        |\n-   |        help: surround the struct literal with parenthesis: `(T {})`\n+   |        ^\n+   |\n+help: surround the struct literal with parentheses\n+   |\n+LL |     if (T {}) == T {} { println!(\"Ok\"); }\n+   |        ^    ^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "af272633f210d4d80e0abaf415d1a930fbb5f1bb", "filename": "src/test/ui/issues/issue-32709.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fissues%2Fissue-32709.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fissues%2Fissue-32709.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32709.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -1,6 +1,8 @@\n error[E0277]: `?` couldn't convert the error to `()`\n   --> $DIR/issue-32709.rs:4:11\n    |\n+LL | fn a() -> Result<i32, ()> {\n+   |           --------------- expected `()` because of this\n LL |     Err(5)?;\n    |           ^ the trait `std::convert::From<{integer}>` is not implemented for `()`\n    |"}, {"sha": "6266112c3a86c0526309d415d2c7a7de3388ae48", "filename": "src/test/ui/issues/issue-71406.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -0,0 +1,6 @@\n+use std::sync::mpsc;\n+\n+fn main() {\n+    let (tx, rx) = mpsc::channel::new(1);\n+    //~^ ERROR expected type, found function `channel` in `mpsc`\n+}"}, {"sha": "918163b60947309b5a55fb0ecd87c2c695d86f9c", "filename": "src/test/ui/issues/issue-71406.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: expected type, found function `channel` in `mpsc`\n+  --> $DIR/issue-71406.rs:4:26\n+   |\n+LL |     let (tx, rx) = mpsc::channel::new(1);\n+   |                          ^^^^^^^ expected type, found function `channel` in `mpsc`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "5fa06778389d9754c056948f3b04b1a0e42ff6ee", "filename": "src/test/ui/option-to-result.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Foption-to-result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Foption-to-result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foption-to-result.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: `?` couldn't convert the error to `()`\n   --> $DIR/option-to-result.rs:5:6\n    |\n+LL | fn test_result() -> Result<(),()> {\n+   |                     ------------- expected `()` because of this\n+LL |     let a:Option<()> = Some(());\n LL |     a?;\n    |      ^ the trait `std::convert::From<std::option::NoneError>` is not implemented for `()`\n    |\n@@ -14,6 +17,9 @@ LL |     a.ok_or_else(|| /* error value */)?;\n error[E0277]: `?` couldn't convert the error to `std::option::NoneError`\n   --> $DIR/option-to-result.rs:11:6\n    |\n+LL | fn test_option() -> Option<i32>{\n+   |                     ----------- expected `std::option::NoneError` because of this\n+LL |     let a:Result<i32, i32> = Ok(5);\n LL |     a?;\n    |      ^ the trait `std::convert::From<i32>` is not implemented for `std::option::NoneError`\n    |"}, {"sha": "c63006e7a407d3ac96b11402ba4f3557e49e29d9", "filename": "src/test/ui/proc-macro/auxiliary/mixed-site-span.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmixed-site-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmixed-site-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmixed-site-span.rs?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -2,7 +2,6 @@\n // no-prefer-dynamic\n \n #![feature(proc_macro_hygiene)]\n-#![feature(proc_macro_mixed_site)]\n #![feature(proc_macro_quote)]\n \n #![crate_type = \"proc-macro\"]"}, {"sha": "16436a9accc8574951e3477f18b7d2274c12c071", "filename": "src/test/ui/resolve/issue-3907.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -4,7 +4,11 @@ error[E0404]: expected trait, found type alias `Foo`\n LL | impl Foo for S {\n    |      ^^^ type aliases cannot be used as traits\n    |\n-   = note: did you mean to use a trait alias?\n+help: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n+  --> $DIR/issue-3907.rs:5:1\n+   |\n+LL | type Foo = dyn issue_3907::Foo;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: possible better candidate is found in another module, you can import it into scope\n    |\n LL | use issue_3907::Foo;"}, {"sha": "41dff2fe542053054c3052affd941957cb735c47", "filename": "src/test/ui/resolve/issue-5035.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -16,7 +16,11 @@ LL | impl K for isize {}\n    |      type aliases cannot be used as traits\n    |      help: a trait with a similar name exists: `I`\n    |\n-   = note: did you mean to use a trait alias?\n+help: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n+  --> $DIR/issue-5035.rs:2:1\n+   |\n+LL | type K = dyn I;\n+   | ^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2974d08eb23b1976545bc2c6abfa2bfe86195c5d", "filename": "src/test/ui/resolve/unboxed-closure-sugar-nonexistent-trait.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -10,7 +10,11 @@ error[E0404]: expected trait, found type alias `Typedef`\n LL | fn g<F:Typedef(isize) -> isize>(x: F) {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ type aliases cannot be used as traits\n    |\n-   = note: did you mean to use a trait alias?\n+help: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n+  --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:4:1\n+   |\n+LL | type Typedef = isize;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4cd1169cc1bb81b261620a2fc56aa17c4910b0ce", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -46,9 +46,12 @@ error[E0423]: expected value, found struct variant `E::V`\n   --> $DIR/struct-literal-variant-in-if.rs:10:13\n    |\n LL |     if x == E::V { field } {}\n-   |             ^^^^----------\n-   |             |\n-   |             help: surround the struct literal with parenthesis: `(E::V { field })`\n+   |             ^^^^\n+   |\n+help: surround the struct literal with parentheses\n+   |\n+LL |     if x == (E::V { field }) {}\n+   |             ^              ^\n \n error[E0308]: mismatched types\n   --> $DIR/struct-literal-variant-in-if.rs:10:20"}, {"sha": "33ca58bf7feb17e366cf284b0d5bb98216d63069", "filename": "src/test/ui/try-on-option.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Ftry-on-option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef71df106b957eb84c1f028240ba8e85b614d043/src%2Ftest%2Fui%2Ftry-on-option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-on-option.stderr?ref=ef71df106b957eb84c1f028240ba8e85b614d043", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: `?` couldn't convert the error to `()`\n   --> $DIR/try-on-option.rs:7:6\n    |\n+LL | fn foo() -> Result<u32, ()> {\n+   |             --------------- expected `()` because of this\n+LL |     let x: Option<u32> = None;\n LL |     x?;\n    |      ^ the trait `std::convert::From<std::option::NoneError>` is not implemented for `()`\n    |"}]}