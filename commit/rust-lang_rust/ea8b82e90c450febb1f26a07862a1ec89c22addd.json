{"sha": "ea8b82e90c450febb1f26a07862a1ec89c22addd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhOGI4MmU5MGM0NTBmZWJiMWYyNmEwNzg2MmExZWM4OWMyMmFkZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T21:23:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T21:23:02Z"}, "message": "Auto merge of #23376 - eddyb:die-tydesc-die, r=nikomatsakis\n\nFinal remnant of reflection is gone. Also, virtual `Trait` destructors are no longer tied to `Box`.\r\nThat means they can be used to drop any instance of the type (used in libarena to replace TyDesc).\r\n\r\nThis is [breaking-change] for direct users of intrinsics:\r\n* use `intrinsics::type_name::<T>()` instead of `(*intrinsics::get_tydesc::<T>()).name`\r\n* the only way to get the destructor is from a trait object's vtable (see libarena changes)\r\n\r\nr? @pcwalton f? @dotdash", "tree": {"sha": "ba4c1da25278a56c52803f1b49c844b7a91b5b90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba4c1da25278a56c52803f1b49c844b7a91b5b90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea8b82e90c450febb1f26a07862a1ec89c22addd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea8b82e90c450febb1f26a07862a1ec89c22addd", "html_url": "https://github.com/rust-lang/rust/commit/ea8b82e90c450febb1f26a07862a1ec89c22addd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea8b82e90c450febb1f26a07862a1ec89c22addd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfac337daab9b86971bcb3db61382ac44f94621c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfac337daab9b86971bcb3db61382ac44f94621c", "html_url": "https://github.com/rust-lang/rust/commit/bfac337daab9b86971bcb3db61382ac44f94621c"}, {"sha": "e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "html_url": "https://github.com/rust-lang/rust/commit/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf"}], "stats": {"total": 705, "additions": 177, "deletions": 528}, "files": [{"sha": "fb858344b85d595c7f4746818df71e8217c8a9c7", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -42,8 +42,9 @@ extern crate alloc;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n+#[cfg(stage0)] // SNAP 270a677\n+use std::intrinsics::{get_tydesc, TyDesc};\n use std::marker;\n use std::mem;\n #[cfg(stage0)]\n@@ -186,6 +187,27 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n     ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n+// HACK(eddyb) TyDesc replacement using a trait object vtable.\n+// This could be replaced in the future with a custom DST layout,\n+// or `&'static (drop_glue, size, align)` created by a `const fn`.\n+#[cfg(not(stage0))] // SNAP 270a677\n+struct TyDesc {\n+    drop_glue: fn(*const i8),\n+    size: usize,\n+    align: usize\n+}\n+\n+#[cfg(not(stage0))] // SNAP 270a677\n+unsafe fn get_tydesc<T>() -> *const TyDesc {\n+    use std::raw::TraitObject;\n+\n+    let ptr = &*(1 as *const T);\n+\n+    // Can use any trait that is implemented for all types.\n+    let obj = mem::transmute::<&marker::MarkerTrait, TraitObject>(ptr);\n+    obj.vtable as *const TyDesc\n+}\n+\n impl<'longer_than_self> Arena<'longer_than_self> {\n     fn chunk_size(&self) -> usize {\n         self.copy_head.borrow().capacity()"}, {"sha": "ead5da92bd90197b990e47bac0a11e2e613cbfaa", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -44,10 +44,12 @@\n \n use marker::Sized;\n \n+#[cfg(stage0)] // SNAP 270a677\n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n #[derive(Copy)]\n+#[cfg(stage0)] // SNAP 270a677\n pub struct TyDesc {\n     // sizeof(T)\n     pub size: usize,\n@@ -197,8 +199,13 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> usize;\n \n     /// Get a static pointer to a type descriptor.\n+    #[cfg(stage0)] // SNAP 270a677\n     pub fn get_tydesc<T: ?Sized>() -> *const TyDesc;\n \n+    /// Gets a static string slice containing the name of a type.\n+    #[cfg(not(stage0))] // SNAP 270a677\n+    pub fn type_name<T: ?Sized>() -> &'static str;\n+\n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in."}, {"sha": "73d31a1f6201d6c3a0baa006778cc13d89b8fdac", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -316,9 +316,6 @@ lets_do_this! {\n \n     StartFnLangItem,                 \"start\",                   start_fn;\n \n-    TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n-    OpaqueStructLangItem,            \"opaque\",                  opaque;\n-\n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n \n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;"}, {"sha": "3d70d95ef1476ff2bcd2b1c8bfb2a9614b625700", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -47,8 +47,7 @@ use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n-use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n-use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n+use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -723,7 +722,6 @@ pub struct ctxt<'tcx> {\n     pub object_cast_map: ObjectCastMap<'tcx>,\n \n     pub map: ast_map::Map<'tcx>,\n-    pub intrinsic_defs: RefCell<DefIdMap<Ty<'tcx>>>,\n     pub freevars: RefCell<FreevarMap>,\n     pub tcache: RefCell<DefIdMap<TypeScheme<'tcx>>>,\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n@@ -2575,7 +2573,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         super_predicates: RefCell::new(DefIdMap()),\n         object_cast_map: RefCell::new(NodeMap()),\n         map: map,\n-        intrinsic_defs: RefCell::new(DefIdMap()),\n         freevars: freevars,\n         tcache: RefCell::new(DefIdMap()),\n         rcache: RefCell::new(FnvHashMap()),\n@@ -5951,13 +5948,6 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n         .collect()\n }\n \n-pub fn get_tydesc_ty<'tcx>(tcx: &ctxt<'tcx>) -> Result<Ty<'tcx>, String> {\n-    tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n-        tcx.intrinsic_defs.borrow().get(&tydesc_lang_item).cloned()\n-            .expect(\"Failed to resolve TyDesc\")\n-    })\n-}\n-\n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),"}, {"sha": "bd9313ee9b01378f02292b2801c129d78c33a892", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -660,7 +660,7 @@ fn bind_subslice_pat(bcx: Block,\n                      offset_right: uint) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n-    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty));\n     let vec_datum = match_datum(val, vec_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n \n@@ -669,7 +669,7 @@ fn bind_subslice_pat(bcx: Block,\n     let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n                                 bcx.tcx().mk_region(ty::ReStatic),\n-                                ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n+                                ty::mt {ty: unit_ty, mutbl: ast::MutImmutable});\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n           GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));"}, {"sha": "5f2803835d5d3b67d32af8d38adb910706f13ecd", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -57,8 +57,7 @@ use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan};\n use trans::common::{node_id_type, return_type_is_void};\n-use trans::common::{tydesc_info, type_is_immediate};\n-use trans::common::{type_is_zero_size, val_ty};\n+use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n use trans::common;\n use trans::consts;\n use trans::context::SharedCrateContext;\n@@ -90,7 +89,6 @@ use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::mem;\n-use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n@@ -392,22 +390,6 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-// Type descriptor and type glue stuff\n-\n-pub fn get_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            t: Ty<'tcx>) -> Rc<tydesc_info<'tcx>> {\n-    match ccx.tydescs().borrow().get(&t) {\n-        Some(inf) => return inf.clone(),\n-        _ => { }\n-    }\n-\n-    ccx.stats().n_static_tydescs.set(ccx.stats().n_static_tydescs.get() + 1);\n-    let inf = Rc::new(glue::declare_tydesc(ccx, t));\n-\n-    ccx.tydescs().borrow_mut().insert(t, inf.clone());\n-    inf\n-}\n-\n #[allow(dead_code)] // useful\n pub fn set_optimize_for_size(f: ValueRef) {\n     llvm::SetFunctionAttribute(f, llvm::OptimizeForSizeAttribute)\n@@ -702,6 +684,10 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n+      ty::ty_vec(_, None) | ty::ty_str => {\n+        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n+      }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for (i, arg) in args.iter().enumerate() {\n@@ -3133,7 +3119,6 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     }\n \n     for ccx in shared_ccx.iter() {\n-        glue::emit_tydescs(&ccx);\n         if ccx.sess().opts.debuginfo != NoDebugInfo {\n             debuginfo::finalize(&ccx);\n         }\n@@ -3145,7 +3130,6 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n-        println!(\"n_static_tydescs: {}\", stats.n_static_tydescs.get());\n         println!(\"n_glues_created: {}\", stats.n_glues_created.get());\n         println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n         println!(\"n_real_glues: {}\", stats.n_real_glues.get());"}, {"sha": "941ac5d627f3b5a88ea6e0ff228151a8b8f092ee", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -316,15 +316,6 @@ pub fn gensym_name(name: &str) -> PathElem {\n     PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n }\n \n-#[derive(Copy)]\n-pub struct tydesc_info<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub tydesc: ValueRef,\n-    pub size: ValueRef,\n-    pub align: ValueRef,\n-    pub name: ValueRef,\n-}\n-\n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n *"}, {"sha": "9d2b20f288a791fbea17f68416880da66611a2a1", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -314,7 +314,6 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     let info =\n                         expr::unsized_info(\n                             cx, k, e.id, ty, param_substs,\n-                            |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t),\n                             || const_get_elt(cx, llconst, &[abi::FAT_PTR_EXTRA as u32]));\n \n                     let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);"}, {"sha": "6614d538971ddc1c7cc8a74bc9abff22841d24b1", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -18,7 +18,7 @@ use middle::traits;\n use trans::adt;\n use trans::base;\n use trans::builder::Builder;\n-use trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n+use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n@@ -38,7 +38,6 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct Stats {\n-    pub n_static_tydescs: Cell<uint>,\n     pub n_glues_created: Cell<uint>,\n     pub n_null_glues: Cell<uint>,\n     pub n_real_glues: Cell<uint>,\n@@ -89,10 +88,6 @@ pub struct LocalCrateContext<'tcx> {\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    tydescs: RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>>,\n-    /// Set when running emit_tydescs to enforce that no more tydescs are\n-    /// created.\n-    finished_tydescs: Cell<bool>,\n     /// Track mapping of external ids to local items imported for inlining\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n@@ -102,7 +97,7 @@ pub struct LocalCrateContext<'tcx> {\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -264,7 +259,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             stats: Stats {\n-                n_static_tydescs: Cell::new(0),\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n                 n_real_glues: Cell::new(0),\n@@ -399,8 +393,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n-                tydescs: RefCell::new(FnvHashMap()),\n-                finished_tydescs: Cell::new(false),\n                 external: RefCell::new(DefIdMap()),\n                 external_srcs: RefCell::new(NodeMap()),\n                 monomorphized: RefCell::new(FnvHashMap()),\n@@ -442,8 +434,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 str_slice_ty.set_struct_body(&[Type::i8p(&ccx), ccx.int_type()], false);\n                 ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n \n-                ccx.tn().associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n-\n                 if ccx.sess().count_llvm_insns() {\n                     base::init_insn_ctxt()\n                 }\n@@ -519,10 +509,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.builder.b\n     }\n \n-    pub fn tydesc_type(&self) -> Type {\n-        self.local.tn.find_type(\"tydesc\").unwrap()\n-    }\n-\n     pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n         if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n             return v;\n@@ -590,14 +576,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.drop_glues\n     }\n \n-    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>> {\n-        &self.local.tydescs\n-    }\n-\n-    pub fn finished_tydescs<'a>(&'a self) -> &'a Cell<bool> {\n-        &self.local.finished_tydescs\n-    }\n-\n     pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n         &self.local.external\n     }\n@@ -614,8 +592,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>),\n-                                                            ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n         &self.local.vtables\n     }\n "}, {"sha": "6de67754f11622879f29c80e3dc5af536bf112fa", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -288,64 +288,47 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n // Retrieve the information we are losing (making dynamic) in an unsizing\n // adjustment.\n //\n-// When making a dtor, we need to do different things depending on the\n-// ownership of the object.. mk_ty is a function for turning `unadjusted_ty`\n-// into a type to be destructed. If we want to end up with a Box pointer,\n-// then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n-// borrowed reference then it should be T -> &T.\n-//\n // The `unadjusted_val` argument is a bit funny. It is intended\n // for use in an upcast, where the new vtable for an object will\n // be drived from the old one. Hence it is a pointer to the fat\n // pointer.\n-pub fn unsized_info_bcx<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                       kind: &ty::UnsizeKind<'tcx>,\n-                                       id: ast::NodeId,\n-                                       unadjusted_ty: Ty<'tcx>,\n-                                       unadjusted_val: ValueRef, // see above (*)\n-                                       param_substs: &'tcx subst::Substs<'tcx>,\n-                                       mk_ty: F)\n-                                       -> ValueRef\n-    where F: FnOnce(Ty<'tcx>) -> Ty<'tcx>\n-{\n+pub fn unsized_info_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    kind: &ty::UnsizeKind<'tcx>,\n+                                    id: ast::NodeId,\n+                                    unadjusted_ty: Ty<'tcx>,\n+                                    unadjusted_val: ValueRef, // see above (*)\n+                                    param_substs: &'tcx subst::Substs<'tcx>)\n+                                    -> ValueRef {\n     unsized_info(\n         bcx.ccx(),\n         kind,\n         id,\n         unadjusted_ty,\n         param_substs,\n-        mk_ty,\n         || Load(bcx, GEPi(bcx, unadjusted_val, &[0, abi::FAT_PTR_EXTRA])))\n }\n \n // Same as `unsize_info_bcx`, but does not require a bcx -- instead it\n // takes an extra closure to compute the upcast vtable.\n-pub fn unsized_info<'ccx, 'tcx, MK_TY, MK_UPCAST_VTABLE>(\n+pub fn unsized_info<'ccx, 'tcx, MK_UPCAST_VTABLE>(\n     ccx: &CrateContext<'ccx, 'tcx>,\n     kind: &ty::UnsizeKind<'tcx>,\n     id: ast::NodeId,\n     unadjusted_ty: Ty<'tcx>,\n     param_substs: &'tcx subst::Substs<'tcx>,\n-    mk_ty: MK_TY,\n     mk_upcast_vtable: MK_UPCAST_VTABLE) // see notes above\n     -> ValueRef\n-    where MK_TY: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n-          MK_UPCAST_VTABLE: FnOnce() -> ValueRef,\n+    where MK_UPCAST_VTABLE: FnOnce() -> ValueRef\n {\n-    // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n-    fn identity<T>(t: T) -> T { t }\n-\n     debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n            kind, id, unadjusted_ty.repr(ccx.tcx()));\n     match kind {\n         &ty::UnsizeLength(len) => C_uint(ccx, len),\n         &ty::UnsizeStruct(box ref k, tp_index) => match unadjusted_ty.sty {\n             ty::ty_struct(_, ref substs) => {\n                 let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                // The dtor for a field treats it like a value, so mk_ty\n-                // should just be the identity function.\n                 unsized_info(ccx, k, id, ty_substs[tp_index], param_substs,\n-                             identity, mk_upcast_vtable)\n+                             mk_upcast_vtable)\n             }\n             _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n                                          unadjusted_ty.repr(ccx.tcx())))\n@@ -359,8 +342,7 @@ pub fn unsized_info<'ccx, 'tcx, MK_TY, MK_UPCAST_VTABLE>(\n             let trait_ref = monomorphize::apply_param_substs(ccx.tcx(),\n                                                              param_substs,\n                                                              &trait_ref);\n-            let box_ty = mk_ty(unadjusted_ty);\n-            consts::ptrcast(meth::get_vtable(ccx, box_ty, trait_ref, param_substs),\n+            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }\n         &ty::UnsizeUpcast(_) => {\n@@ -498,8 +480,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n         debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n \n-        let info = unsized_info_bcx(bcx, k, expr.id, datum_ty, datum.val, bcx.fcx.param_substs,\n-                                    |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n+        let info = unsized_info_bcx(bcx, k, expr.id, datum_ty, datum.val, bcx.fcx.param_substs);\n \n         // Arrange cleanup\n         let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n@@ -590,8 +571,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n         bcx = datum.store_to(bcx, base);\n \n-        let info = unsized_info_bcx(bcx, k, expr.id, unboxed_ty, base, bcx.fcx.param_substs,\n-                                    |t| ty::mk_uniq(tcx, t));\n+        let info = unsized_info_bcx(bcx, k, expr.id, unboxed_ty, base, bcx.fcx.param_substs);\n         Store(bcx, info, get_len(bcx, scratch.val));\n \n         DatumBlock::new(bcx, scratch.to_expr_datum())\n@@ -888,10 +868,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n-            let vt =\n-                tvec::vec_types(bcx,\n-                                ty::sequence_element_type(bcx.tcx(),\n-                                                          base_datum.ty));\n+            let unit_ty = ty::sequence_element_type(bcx.tcx(), base_datum.ty);\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n@@ -916,8 +893,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                      len)\n             });\n             let elt = InBoundsGEP(bcx, base, &[ix_val]);\n-            let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n-            Datum::new(elt, vt.unit_ty, LvalueExpr)\n+            let elt = PointerCast(bcx, elt, type_of::type_of(ccx, unit_ty).ptr_to());\n+            Datum::new(elt, unit_ty, LvalueExpr)\n         }\n     };\n "}, {"sha": "b2de8435f641bd5c4e8d6340ba27379805ee4a43", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 71, "deletions": 213, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -10,12 +10,12 @@\n \n //!\n //\n-// Code relating to taking, dropping, etc as well as type descriptors.\n+// Code relating to drop glue.\n \n \n use back::abi;\n use back::link::*;\n-use llvm::{ValueRef, True, get_param};\n+use llvm::{ValueRef, get_param};\n use llvm;\n use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n@@ -26,24 +26,20 @@ use trans::build::*;\n use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n-use trans::consts;\n use trans::common::*;\n use trans::datum;\n use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::machine::*;\n-use trans::tvec;\n use trans::type_::Type;\n-use trans::type_of::{self, type_of, sizing_type_of, align_of};\n+use trans::type_of::{type_of, sizing_type_of, align_of};\n use middle::ty::{self, Ty};\n use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n \n use arena::TypedArena;\n use libc::c_uint;\n-use std::ffi::CString;\n use syntax::ast;\n-use syntax::parse::token;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                            v: ValueRef,\n@@ -178,31 +174,46 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let llfnty = Type::glue_fn(ccx, llty);\n \n-    let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n-        Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, &old_sym[..], llfnty, ty::mk_nil(ccx.tcx()));\n-            (glue, None)\n-        },\n-        None => {\n-            let (sym, glue) = declare_generic_glue(ccx, t, llfnty, \"drop\");\n-            (glue, Some(sym))\n-        },\n+    // To avoid infinite recursion, don't `make_drop_glue` until after we've\n+    // added the entry to the `drop_glues` cache.\n+    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&t) {\n+        let llfn = decl_cdecl_fn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n+        ccx.drop_glues().borrow_mut().insert(t, llfn);\n+        return llfn;\n     };\n \n-    ccx.drop_glues().borrow_mut().insert(t, glue);\n+    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n+    let llfn = decl_cdecl_fn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx()));\n+    note_unique_llvm_symbol(ccx, fn_nm.clone());\n+    ccx.available_drop_glues().borrow_mut().insert(t, fn_nm);\n \n-    // To avoid infinite recursion, don't `make_drop_glue` until after we've\n-    // added the entry to the `drop_glues` cache.\n-    match new_sym {\n-        Some(sym) => {\n-            ccx.available_drop_glues().borrow_mut().insert(t, sym);\n-            // We're creating a new drop glue, so also generate a body.\n-            make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n-        },\n-        None => {},\n-    }\n+    let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n+\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n+                      empty_substs, None, &arena);\n+\n+    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+\n+    update_linkage(ccx, llfn, None, OriginalTranslation);\n+\n+    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n+    // All glue functions take values passed *by alias*; this is a\n+    // requirement since in many contexts glue is invoked indirectly and\n+    // the caller has no idea if it's dealing with something that can be\n+    // passed by value.\n+    //\n+    // llfn is expected be declared to take a parameter of the appropriate\n+    // type, so we don't need to explicitly cast the function parameter.\n \n-    glue\n+    let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n+    let bcx = make_drop_glue(bcx, llrawptr0, t);\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n+\n+    llfn\n }\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n@@ -386,51 +397,34 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n     let _icx = push_ctxt(\"make_drop_glue\");\n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n-            match content_ty.sty {\n-                ty::ty_vec(ty, None) => {\n-                    tvec::make_drop_glue_unboxed(bcx, v0, ty, true)\n-                }\n-                ty::ty_str => {\n-                    let unit_ty = ty::sequence_element_type(bcx.tcx(), content_ty);\n-                    tvec::make_drop_glue_unboxed(bcx, v0, unit_ty, true)\n-                }\n-                ty::ty_trait(..) => {\n-                    let lluniquevalue = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-                    // Only drop the value when it is non-null\n-                    let concrete_ptr = Load(bcx, lluniquevalue);\n-                    with_cond(bcx, IsNotNull(bcx, concrete_ptr), |bcx| {\n-                        let dtor_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n-                        let dtor = Load(bcx, dtor_ptr);\n-                        Call(bcx,\n-                             dtor,\n-                             &[PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n-                             None,\n-                             DebugLoc::None);\n-                        bcx\n-                    })\n-                }\n-                ty::ty_struct(..) if !type_is_sized(bcx.tcx(), content_ty) => {\n-                    let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-                    let llbox = Load(bcx, llval);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n-                        let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n-                        let info = Load(bcx, info);\n-                        let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+            if !type_is_sized(bcx.tcx(), content_ty) {\n+                let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n+                let llbox = Load(bcx, llval);\n+                let not_null = IsNotNull(bcx, llbox);\n+                with_cond(bcx, not_null, |bcx| {\n+                    let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n+                    let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n+                    let info = Load(bcx, info);\n+                    let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+\n+                    // `Box<ZeroSizeType>` does not allocate.\n+                    let needs_free = ICmp(bcx,\n+                                          llvm::IntNE,\n+                                          llsize,\n+                                          C_uint(bcx.ccx(), 0u64),\n+                                          DebugLoc::None);\n+                    with_cond(bcx, needs_free, |bcx| {\n                         trans_exchange_free_dyn(bcx, llbox, llsize, llalign, DebugLoc::None)\n                     })\n-                }\n-                _ => {\n-                    assert!(type_is_sized(bcx.tcx(), content_ty));\n-                    let llval = v0;\n-                    let llbox = Load(bcx, llval);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n-                        trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n-                    })\n-                }\n+                })\n+            } else {\n+                let llval = v0;\n+                let llbox = Load(bcx, llval);\n+                let not_null = IsNotNull(bcx, llbox);\n+                with_cond(bcx, not_null, |bcx| {\n+                    let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n+                    trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n+                })\n             }\n         }\n         ty::ty_struct(did, substs) | ty::ty_enum(did, substs) => {\n@@ -462,34 +456,19 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n             }\n         }\n-        ty::ty_closure(..) => {\n-            iter_structural_ty(bcx,\n-                               v0,\n-                               t,\n-                               |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n-        }\n         ty::ty_trait(..) => {\n-            // No need to do a null check here (as opposed to the Box<trait case\n-            // above), because this happens for a trait field in an unsized\n-            // struct. If anything is null, it is the whole struct and we won't\n-            // get here.\n-            let lluniquevalue = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-            let dtor_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n-            let dtor = Load(bcx, dtor_ptr);\n+            let data_ptr = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n+            let vtable_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n+            let dtor = Load(bcx, vtable_ptr);\n             Call(bcx,\n                  dtor,\n-                 &[PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n+                 &[PointerCast(bcx, Load(bcx, data_ptr), Type::i8p(bcx.ccx()))],\n                  None,\n                  DebugLoc::None);\n             bcx\n-        },\n-        ty::ty_vec(_, None) | ty::ty_str => {\n-            let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n-            tvec::make_drop_glue_unboxed(bcx, v0, unit_ty, false)\n-        },\n+        }\n         _ => {\n-            assert!(type_is_sized(bcx.tcx(), t));\n-            if bcx.fcx.type_needs_drop(t) && ty::type_is_structural(t) {\n+            if bcx.fcx.type_needs_drop(t) {\n                 iter_structural_ty(bcx,\n                                    v0,\n                                    t,\n@@ -500,124 +479,3 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         }\n     }\n }\n-\n-// Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n-                                -> tydesc_info<'tcx> {\n-    // If emit_tydescs already ran, then we shouldn't be creating any new\n-    // tydescs.\n-    assert!(!ccx.finished_tydescs().get());\n-\n-    // This really shouldn't be like this, size/align will be wrong for\n-    // unsized types (i.e. [T] will have the size/align of T).\n-    // But we need it until we split this out into a \"type name\" intrinsic.\n-    let llty = type_of::in_memory_type_of(ccx, t);\n-\n-    if ccx.sess().count_type_sizes() {\n-        println!(\"{}\\t{}\", llsize_of_real(ccx, llty),\n-                 ppaux::ty_to_string(ccx.tcx(), t));\n-    }\n-\n-    let llsize = llsize_of(ccx, llty);\n-    let llalign = llalign_of(ccx, llty);\n-    let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n-    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n-    let buf = CString::new(name.clone()).unwrap();\n-    let gvar = unsafe {\n-        llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(),\n-                            buf.as_ptr())\n-    };\n-    note_unique_llvm_symbol(ccx, name);\n-\n-    let ty_name = token::intern_and_get_ident(\n-        &ppaux::ty_to_string(ccx.tcx(), t));\n-    let ty_name = C_str_slice(ccx, ty_name);\n-\n-    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    tydesc_info {\n-        ty: t,\n-        tydesc: gvar,\n-        size: llsize,\n-        align: llalign,\n-        name: ty_name,\n-    }\n-}\n-\n-fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                                  llfnty: Type, name: &str) -> (String, ValueRef) {\n-    let _icx = push_ctxt(\"declare_generic_glue\");\n-    let fn_nm = mangle_internal_name_by_type_and_seq(\n-        ccx,\n-        t,\n-        &format!(\"glue_{}\", name));\n-    let llfn = decl_cdecl_fn(ccx, &fn_nm[..], llfnty, ty::mk_nil(ccx.tcx()));\n-    note_unique_llvm_symbol(ccx, fn_nm.clone());\n-    return (fn_nm, llfn);\n-}\n-\n-fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n-                                  t: Ty<'tcx>,\n-                                  llfn: ValueRef,\n-                                  helper: F,\n-                                  name: &str)\n-                                  -> ValueRef where\n-    F: for<'blk> FnOnce(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n-{\n-    let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n-    let _s = StatRecorder::new(ccx, glue_name);\n-\n-    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n-                      empty_substs, None, &arena);\n-\n-    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n-\n-    update_linkage(ccx, llfn, None, OriginalTranslation);\n-\n-    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n-    // All glue functions take values passed *by alias*; this is a\n-    // requirement since in many contexts glue is invoked indirectly and\n-    // the caller has no idea if it's dealing with something that can be\n-    // passed by value.\n-    //\n-    // llfn is expected be declared to take a parameter of the appropriate\n-    // type, so we don't need to explicitly cast the function parameter.\n-\n-    let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n-    let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n-\n-    llfn\n-}\n-\n-pub fn emit_tydescs(ccx: &CrateContext) {\n-    let _icx = push_ctxt(\"emit_tydescs\");\n-    // As of this point, allow no more tydescs to be created.\n-    ccx.finished_tydescs().set(true);\n-    let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    for (_, ti) in &*ccx.tydescs().borrow() {\n-        // Each of the glue functions needs to be cast to a generic type\n-        // before being put into the tydesc because we only have a singleton\n-        // tydesc type. Then we'll recast each function to its real type when\n-        // calling it.\n-        let drop_glue = consts::ptrcast(get_drop_glue(ccx, ti.ty), glue_fn_ty);\n-        ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() + 1);\n-\n-        let tydesc = C_named_struct(ccx.tydesc_type(),\n-                                    &[ti.size, // size\n-                                      ti.align, // align\n-                                      drop_glue, // drop_glue\n-                                      ti.name]); // name\n-\n-        unsafe {\n-            let gvar = ti.tydesc;\n-            llvm::LLVMSetInitializer(gvar, tydesc);\n-            llvm::LLVMSetGlobalConstant(gvar, True);\n-            llvm::SetLinkage(gvar, llvm::InternalLinkage);\n-        }\n-    };\n-}"}, {"sha": "69ca9a5e81cbc81b933e4ac5ed62022cdb261787", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -347,15 +347,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx = src.store_to(bcx, llargs[0]);\n             C_nil(ccx)\n         }\n-        (_, \"get_tydesc\") => {\n+        (_, \"type_name\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let static_ti = get_tydesc(ccx, tp_ty);\n-\n-            // FIXME (#3730): ideally this shouldn't need a cast,\n-            // but there's a circularity between translating rust types to llvm\n-            // types and having a tydesc type available. So I can't directly access\n-            // the llvm type of intrinsic::TyDesc struct.\n-            PointerCast(bcx, static_ti.tydesc, llret_ty)\n+            let ty_name = token::intern_and_get_ident(&ty_to_string(ccx.tcx(), tp_ty));\n+            C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n             let hash = ty::hash_crate_independent("}, {"sha": "9b17c4f8baac9818afe039966f0767c88757ed13", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -12,9 +12,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use llvm;\n-use llvm::{ValueRef};\n-use llvm::False;\n+use llvm::{self, ValueRef};\n use trans::common::*;\n \n use trans::type_::Type;\n@@ -101,16 +99,6 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n     }\n }\n \n-// Returns the \"default\" alignment of t, which is calculated by casting\n-// null to a record containing a single-bit followed by a t value, then\n-// doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n-pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n-    unsafe {\n-        return llvm::LLVMConstIntCast(\n-            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type().to_ref(), False);\n-    }\n-}\n-\n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n     unsafe {\n         return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),"}, {"sha": "3f67c211f8c658043347fc670f003ba7445c4aef", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -680,25 +680,19 @@ pub fn trans_object_shim<'a, 'tcx>(\n ///\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n-/// `trait_ref` would map `T:Trait`, but `box_ty` would be\n-/// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n-/// This will hopefully change now that DST is underway.\n+/// `trait_ref` would map `T:Trait`.\n pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            box_ty: Ty<'tcx>,\n                             trait_ref: ty::PolyTraitRef<'tcx>,\n                             param_substs: &'tcx subst::Substs<'tcx>)\n                             -> ValueRef\n {\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n-    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n-           box_ty.repr(tcx),\n-           trait_ref.repr(tcx));\n+    debug!(\"get_vtable(trait_ref={})\", trait_ref.repr(tcx));\n \n     // Check the cache.\n-    let cache_key = (box_ty, trait_ref.clone());\n-    match ccx.vtables().borrow().get(&cache_key) {\n+    match ccx.vtables().borrow().get(&trait_ref) {\n         Some(&val) => { return val }\n         None => { }\n     }\n@@ -755,15 +749,15 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let components: Vec<_> = vec![\n         // Generate a destructor for the vtable.\n-        glue::get_drop_glue(ccx, box_ty),\n+        glue::get_drop_glue(ccx, trait_ref.self_ty()),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n     ].into_iter().chain(methods).collect();\n \n     let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false),\n                                  \"vtable\", trait_ref.def_id().node);\n \n-    ccx.vtables().borrow_mut().insert(cache_key, vtable);\n+    ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n     vtable\n }\n \n@@ -842,16 +836,15 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_trait_cast: trait_ref={}\",\n            trait_ref.repr(bcx.tcx()));\n \n-    let datum_ty = datum.ty;\n-    let llbox_ty = type_of(bcx.ccx(), datum_ty);\n+    let llty = type_of(bcx.ccx(), datum.ty);\n \n     // Store the pointer into the first half of pair.\n     let llboxdest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]);\n-    let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n+    let llboxdest = PointerCast(bcx, llboxdest, llty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let vtable = get_vtable(bcx.ccx(), datum_ty, trait_ref, bcx.fcx.param_substs);\n+    let vtable = get_vtable(bcx.ccx(), trait_ref, bcx.fcx.param_substs);\n     let llvtabledest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "6a35a1a55b6f7cd9ecabc842d432b08e8421ea0e", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 26, "deletions": 97, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -24,8 +24,6 @@ use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::expr::{Dest, Ignore, SaveIn};\n use trans::expr;\n-use trans::glue;\n-use trans::machine;\n use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n@@ -35,79 +33,17 @@ use util::ppaux::ty_to_string;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-fn get_len(bcx: Block, vptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::get_lenl\");\n-    Load(bcx, expr::get_len(bcx, vptr))\n-}\n-\n-fn get_dataptr(bcx: Block, vptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::get_dataptr\");\n-    Load(bcx, expr::get_dataptr(bcx, vptr))\n-}\n-\n-pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          vptr: ValueRef,\n-                                          unit_ty: Ty<'tcx>,\n-                                          should_deallocate: bool)\n-                                          -> Block<'blk, 'tcx> {\n-    let not_null = IsNotNull(bcx, vptr);\n-    with_cond(bcx, not_null, |bcx| {\n-        let ccx = bcx.ccx();\n-        let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n-\n-        let dataptr = get_dataptr(bcx, vptr);\n-        let bcx = if bcx.fcx.type_needs_drop(unit_ty) {\n-            let len = get_len(bcx, vptr);\n-            iter_vec_raw(bcx,\n-                         dataptr,\n-                         unit_ty,\n-                         len,\n-                         |bb, vv, tt| glue::drop_ty(bb, vv, tt, DebugLoc::None))\n-        } else {\n-            bcx\n-        };\n-\n-        if should_deallocate {\n-            let llty = type_of::type_of(ccx, unit_ty);\n-            let unit_size = llsize_of_alloc(ccx, llty);\n-            if unit_size != 0 {\n-                let len = get_len(bcx, vptr);\n-                let not_empty = ICmp(bcx,\n-                                     llvm::IntNE,\n-                                     len,\n-                                     C_uint(ccx, 0_u32),\n-                                     DebugLoc::None);\n-                with_cond(bcx, not_empty, |bcx| {\n-                    let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n-                    let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n-                    glue::trans_exchange_free_dyn(bcx,\n-                                                  dataptr,\n-                                                  size,\n-                                                  llalign,\n-                                                  DebugLoc::None)\n-                })\n-            } else {\n-                bcx\n-            }\n-        } else {\n-            bcx\n-        }\n-    })\n-}\n-\n #[derive(Copy)]\n-pub struct VecTypes<'tcx> {\n-    pub unit_ty: Ty<'tcx>,\n-    pub llunit_ty: Type,\n-    pub llunit_alloc_size: u64\n+struct VecTypes<'tcx> {\n+    unit_ty: Ty<'tcx>,\n+    llunit_ty: Type\n }\n \n impl<'tcx> VecTypes<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"VecTypes {{unit_ty={}, llunit_ty={}, llunit_alloc_size={}}}\",\n+        format!(\"VecTypes {{unit_ty={}, llunit_ty={}}}\",\n                 ty_to_string(ccx.tcx(), self.unit_ty),\n-                ccx.tn().type_to_string(self.llunit_ty),\n-                self.llunit_alloc_size)\n+                ccx.tn().type_to_string(self.llunit_ty))\n     }\n }\n \n@@ -221,12 +157,12 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 vt: &VecTypes<'tcx>,\n-                                 vstore_expr: &ast::Expr,\n-                                 content_expr: &ast::Expr,\n-                                 dest: Dest)\n-                                 -> Block<'blk, 'tcx> {\n+fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             vt: &VecTypes<'tcx>,\n+                             vstore_expr: &ast::Expr,\n+                             content_expr: &ast::Expr,\n+                             dest: Dest)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -315,28 +251,21 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       vec_expr: &ast::Expr)\n-                                       -> VecTypes<'tcx> {\n+fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, vec_expr: &ast::Expr)\n+                                   -> VecTypes<'tcx> {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n }\n \n-pub fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             unit_ty: Ty<'tcx>)\n-                             -> VecTypes<'tcx> {\n-    let ccx = bcx.ccx();\n-    let llunit_ty = type_of::type_of(ccx, unit_ty);\n-    let llunit_alloc_size = llsize_of_alloc(ccx, llunit_ty);\n-\n+fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, unit_ty: Ty<'tcx>)\n+                         -> VecTypes<'tcx> {\n     VecTypes {\n         unit_ty: unit_ty,\n-        llunit_ty: llunit_ty,\n-        llunit_alloc_size: llunit_alloc_size\n+        llunit_ty: type_of::type_of(bcx.ccx(), unit_ty)\n     }\n }\n \n-pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n+fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -401,12 +330,12 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                     data_ptr: ValueRef,\n-                                     vt: &VecTypes<'tcx>,\n-                                     count: ValueRef,\n-                                     f: F)\n-                                     -> Block<'blk, 'tcx> where\n+fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                data_ptr: ValueRef,\n+                                vt: &VecTypes<'tcx>,\n+                                count: ValueRef,\n+                                f: F)\n+                                -> Block<'blk, 'tcx> where\n     F: FnOnce(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n@@ -426,7 +355,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     let bcx = loop_bcx;\n \n-    let lleltptr = if vt.llunit_alloc_size == 0 {\n+    let lleltptr = if llsize_of_alloc(bcx.ccx(), vt.llunit_ty) == 0 {\n         data_ptr\n     } else {\n         InBoundsGEP(bcx, data_ptr, &[loop_counter])\n@@ -454,7 +383,7 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     let vt = vec_types(bcx, unit_ty);\n \n-    if vt.llunit_alloc_size == 0 {\n+    if llsize_of_alloc(bcx.ccx(), vt.llunit_ty) == 0 {\n         // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n         iter_vec_loop(bcx, data_ptr, &vt, len, f)\n     } else {\n@@ -471,7 +400,7 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n-        let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n+        let body_bcx = f(body_bcx, data_ptr, unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n                                                &[C_int(bcx.ccx(), 1)]),\n                          body_bcx.llbb);"}, {"sha": "dcb57fd9cdebd8ebd0406cac204ed6f70dad255b", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -175,41 +175,10 @@ impl Type {\n         Type::array(&Type::i8p(ccx).ptr_to(), 1)\n     }\n \n-    pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n-        match cx.tn().find_type(\"glue_fn\") {\n-            Some(ty) => return ty,\n-            None => ()\n-        }\n-\n-        let ty = Type::glue_fn(cx, Type::i8p(cx));\n-        cx.tn().associate_type(\"glue_fn\", &ty);\n-\n-        ty\n-    }\n-\n     pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n         Type::func(&[t], &Type::void(ccx))\n     }\n \n-    pub fn tydesc(ccx: &CrateContext, str_slice_ty: Type) -> Type {\n-        let mut tydesc = Type::named_struct(ccx, \"tydesc\");\n-        let glue_fn_ty = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to();\n-\n-        let int_ty = Type::int(ccx);\n-\n-        // Must mirror:\n-        //\n-        // std::unstable::intrinsics::TyDesc\n-\n-        let elems = [int_ty,     // size\n-                     int_ty,     // align\n-                     glue_fn_ty, // drop\n-                     str_slice_ty]; // name\n-        tydesc.set_struct_body(&elems, false);\n-\n-        tydesc\n-    }\n-\n     pub fn array(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n     }"}, {"sha": "de0978bc40957d74847252720f644695a16d5294", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -5347,17 +5347,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n             \"owns_managed\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n-            \"get_tydesc\" => {\n-              let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n-                  Ok(t) => t,\n-                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[..]); }\n-              };\n-              let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n-                  ty: tydesc_ty,\n-                  mutbl: ast::MutImmutable\n-              });\n-              (1, Vec::new(), td_ptr)\n-            }\n+            \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),\n+                                                             ast::MutImmutable)),\n             \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n             \"offset\" => {\n               (1,"}, {"sha": "97cc3ac7c48a78aa2a79c1051be851fbf0e93b5e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -102,15 +102,6 @@ use syntax::visit;\n pub fn collect_item_types(tcx: &ty::ctxt) {\n     let ccx = &CrateCtxt { tcx: tcx, stack: RefCell::new(Vec::new()) };\n \n-    match ccx.tcx.lang_items.ty_desc() {\n-        Some(id) => { collect_intrinsic_type(ccx, id); }\n-        None => {}\n-    }\n-    match ccx.tcx.lang_items.opaque() {\n-        Some(id) => { collect_intrinsic_type(ccx, id); }\n-        None => {}\n-    }\n-\n     let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n     visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n \n@@ -152,15 +143,6 @@ enum AstConvRequest {\n     GetTypeParameterBounds(ast::NodeId),\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Zeroth phase: collect types of intrinsics\n-\n-fn collect_intrinsic_type(ccx: &CrateCtxt,\n-                          lang_item: ast::DefId) {\n-    let ty::TypeScheme { ty, .. } = type_scheme_of_def_id(ccx, lang_item);\n-    ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // First phase: just collect *trait definitions* -- basically, the set\n // of type parameters and supertraits. This is information we need to"}, {"sha": "e53fe3c44a28e8dd3b3513690093a22a35494960", "filename": "src/test/run-pass/issue-21058.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21058.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -13,17 +13,17 @@ struct NT(str);\n struct DST { a: u32, b: str }\n \n fn main() {\n-    // get_tydesc should support unsized types\n+    // type_name should support unsized types\n     assert_eq!(unsafe {(\n         // Slice\n-        (*std::intrinsics::get_tydesc::<[u8]>()).name,\n+        std::intrinsics::type_name::<[u8]>(),\n         // str\n-        (*std::intrinsics::get_tydesc::<str>()).name,\n+        std::intrinsics::type_name::<str>(),\n         // Trait\n-        (*std::intrinsics::get_tydesc::<Copy>()).name,\n+        std::intrinsics::type_name::<Copy>(),\n         // Newtype\n-        (*std::intrinsics::get_tydesc::<NT>()).name,\n+        std::intrinsics::type_name::<NT>(),\n         // DST\n-        (*std::intrinsics::get_tydesc::<DST>()).name\n+        std::intrinsics::type_name::<DST>()\n     )}, (\"[u8]\", \"str\", \"core::marker::Copy\", \"NT\", \"DST\"));\n }"}, {"sha": "2e7717fcfe15463e2bce6f36b2570dfd184c95a2", "filename": "src/test/run-pass/tydesc-name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8b82e90c450febb1f26a07862a1ec89c22addd/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftydesc-name.rs?ref=ea8b82e90c450febb1f26a07862a1ec89c22addd", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n \n-use std::intrinsics::get_tydesc;\n+use std::intrinsics::type_name;\n \n struct Foo<T> {\n     x: T\n }\n \n pub fn main() {\n     unsafe {\n-        assert_eq!((*get_tydesc::<int>()).name, \"isize\");\n-        assert_eq!((*get_tydesc::<Foo<uint>>()).name, \"Foo<usize>\");\n+        assert_eq!(type_name::<int>(), \"isize\");\n+        assert_eq!(type_name::<Foo<uint>>(), \"Foo<usize>\");\n     }\n }"}]}