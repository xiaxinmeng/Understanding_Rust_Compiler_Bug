{"sha": "dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYWRhMjZmNWIxZDgzYzRlNTFkOWJkZjBjNzMwNGVkNDk3YTYzYzY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-04T15:46:46Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-11T20:35:02Z"}, "message": "MIR-borrowck: Big fix to `fn check_if_path_is_moved`.\n\nFix #44833 (a very specific instance of a very broad bug).\n\nIn `check_if_path_is_moved(L)`, check nearest prefix of L with\nMovePath, and suffixes of L with MovePaths.\n\nOver the course of review, ariel pointed out a number of issues that\nled to this version of the commit:\n\n1. Looking solely at supporting prefixes does not suffice: it\n   overlooks checking if the path was ever actually initialized in the\n   first place. So you need to be willing to consider non-supporting\n   prefixes.  Once you are looking at all prefixes, you *could* just\n   look at the local that forms the base of the projection, but to\n   handle partial initialization (which still needs to be formally\n   specified), this code instead looks at the nearest prefix of L that\n   has an associated MovePath (which, in the limit, will end up being\n   a local).\n\n2. You also need to consider the suffixes of the given Lvalue, due to\n   how dataflow is representing partial moves of individual fields out\n   of struct values.\n\n3. (There was originally a third search, but ariel pointed out that\n   the first and third could be folded into one.)\n\nAlso includes some drive-by refactorings to simplify some method\nsignatures and prefer `for _ in _` over `loop { }` (at least when it\ncomes semi-naturally).", "tree": {"sha": "e5b06a45d7d4b2ed5868bc1745a276565e26c90e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5b06a45d7d4b2ed5868bc1745a276565e26c90e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6", "html_url": "https://github.com/rust-lang/rust/commit/dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f578dfad0dd5d43b28eff71a7e857d10c3f55fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f578dfad0dd5d43b28eff71a7e857d10c3f55fe", "html_url": "https://github.com/rust-lang/rust/commit/5f578dfad0dd5d43b28eff71a7e857d10c3f55fe"}], "stats": {"total": 151, "additions": 139, "deletions": 12}, "files": [{"sha": "7e18de27489b3f4de0c036d8caad79aa8e68019f", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 139, "deletions": 12, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=dcada26f5b1d83c4e51d9bdf0c7304ed497a63c6", "patch": "@@ -586,7 +586,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                                 context: Context,\n                                                 (lvalue, span): (&Lvalue<'gcx>, Span),\n                                                 flow_state: &InProgress<'b, 'gcx>) {\n-        let move_data = flow_state.inits.base_results.operator().move_data();\n+        let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n         let mut l = lvalue;\n@@ -611,7 +611,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n \n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n             if flow_state.inits.curr_state.contains(&mpi) {\n                 // may already be assigned before reaching this statement;\n                 // report error.\n@@ -642,29 +642,115 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         let lvalue = self.base_path(lvalue_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let move_data = maybe_uninits.base_results.operator().move_data();\n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n-            if maybe_uninits.curr_state.contains(&mpi) {\n-                // find and report move(s) that could cause this to be uninitialized\n+\n+        // Bad scenarios:\n+        //\n+        // 1. Move of `a.b.c`, use of `a.b.c`\n+        // 2. Move of `a.b.c`, use of `a.b.c.d` (without first reinitializing `a.b.c.d`)\n+        // 3. Move of `a.b.c`, use of `a` or `a.b`\n+        // 4. Uninitialized `(a.b.c: &_)`, use of `*a.b.c`; note that with\n+        //    partial initialization support, one might have `a.x`\n+        //    initialized but not `a.b`.\n+        //\n+        // OK scenarios:\n+        //\n+        // 5. Move of `a.b.c`, use of `a.b.d`\n+        // 6. Uninitialized `a.x`, initialized `a.b`, use of `a.b`\n+        // 7. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`\n+        //    must have been initialized for the use to be sound.\n+        // 8. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n+\n+        // The dataflow tracks shallow prefixes distinctly (that is,\n+        // field-accesses on P distinctly from P itself), in order to\n+        // track substructure initialization separately from the whole\n+        // structure.\n+        //\n+        // E.g., when looking at (*a.b.c).d, if the closest prefix for\n+        // which we have a MovePath is `a.b`, then that means that the\n+        // initialization state of `a.b` is all we need to inspect to\n+        // know if `a.b.c` is valid (and from that we infer that the\n+        // dereference and `.d` access is also valid, since we assume\n+        // `a.b.c` is assigned a reference to a initialized and\n+        // well-formed record structure.)\n+\n+        // Therefore, if we seek out the *closest* prefix for which we\n+        // have a MovePath, that should capture the initialization\n+        // state for the lvalue scenario.\n+        //\n+        // This code covers scenarios 1, 2, and 4.\n+\n+        debug!(\"check_if_path_is_moved part1 lvalue: {:?}\", lvalue);\n+        match self.move_path_closest_to(lvalue) {\n+            Ok(mpi) => {\n+                if maybe_uninits.curr_state.contains(&mpi) {\n+                    self.report_use_of_moved(context, desired_action, lvalue_span);\n+                    return; // don't bother finding other problems.\n+                }\n+            }\n+            Err(NoMovePathFound::ReachedStatic) => {\n+                // Okay: we do not build MoveData for static variables\n+            }\n+\n+            // Only query longest prefix with a MovePath, not further\n+            // ancestors; dataflow recurs on children when parents\n+            // move (to support partial (re)inits).\n+            //\n+            // (I.e. querying parents breaks scenario 8; but may want\n+            // to do such a query based on partial-init feature-gate.)\n+        }\n+\n+        // A move of any shallow suffix of `lvalue` also interferes\n+        // with an attempt to use `lvalue`. This is scenario 3 above.\n+        //\n+        // (Distinct from handling of scenarios 1+2+4 above because\n+        // `lvalue` does not interfere with suffixes of its prefixes,\n+        // e.g. `a.b.c` does not interfere with `a.b.d`)\n+\n+        debug!(\"check_if_path_is_moved part2 lvalue: {:?}\", lvalue);\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n+            if let Some(_) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved(context, desired_action, lvalue_span);\n-            } else {\n-                // sanity check: initialized on *some* path, right?\n-                assert!(flow_state.inits.curr_state.contains(&mpi));\n+                return; // don't bother finding other problems.\n             }\n         }\n     }\n \n+    /// Currently MoveData does not store entries for all lvalues in\n+    /// the input MIR. For example it will currently filter out\n+    /// lvalues that are Copy; thus we do not track lvalues of shared\n+    /// reference type. This routine will walk up an lvalue along its\n+    /// prefixes, searching for a foundational lvalue that *is*\n+    /// tracked in the MoveData.\n+    ///\n+    /// An Err result includes a tag indicated why the search failed.\n+    /// Currenly this can only occur if the lvalue is built off of a\n+    /// static variable, as we do not track those in the MoveData.\n+    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'gcx>)\n+                            -> Result<MovePathIndex, NoMovePathFound>\n+    {\n+        let mut last_prefix = lvalue;\n+        for prefix in self.prefixes(lvalue, PrefixSet::All) {\n+            if let Some(mpi) = self.move_path_for_lvalue(prefix) {\n+                return Ok(mpi);\n+            }\n+            last_prefix = prefix;\n+        }\n+        match *last_prefix {\n+            Lvalue::Local(_) => panic!(\"should have move path for every Local\"),\n+            Lvalue::Projection(_) => panic!(\"PrefixSet::All meant dont stop for Projection\"),\n+            Lvalue::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n+        }\n+    }\n+\n     fn move_path_for_lvalue(&mut self,\n-                            _context: Context,\n-                            move_data: &MoveData<'gcx>,\n                             lvalue: &Lvalue<'gcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `lvalue` (which means there is nothing\n         // that borrowck tracks for its analysis).\n \n-        match move_data.rev_lookup.find(lvalue) {\n+        match self.move_data.rev_lookup.find(lvalue) {\n             LookupResult::Parent(_) => None,\n             LookupResult::Exact(mpi) => Some(mpi),\n         }\n@@ -733,6 +819,11 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum NoMovePathFound {\n+    ReachedStatic,\n+}\n+\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n@@ -846,12 +937,19 @@ mod prefixes {\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n     pub(super) enum PrefixSet {\n+        /// Doesn't stop until it returns the base case (a Local or\n+        /// Static prefix).\n         All,\n+        /// Stops at any dereference.\n         Shallow,\n+        /// Stops at the deref of a shared reference.\n         Supporting,\n     }\n \n     impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        /// Returns an iterator over the prefixes of `lvalue`\n+        /// (inclusive) from longest to smallest, potentially\n+        /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes<'d>(&self,\n                                    lvalue: &'d Lvalue<'gcx>,\n                                    kind: PrefixSet)\n@@ -1266,6 +1364,35 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     }\n }\n \n+impl<'b, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>> {\n+    fn has_any_child_of(&self, mpi: MovePathIndex) -> Option<MovePathIndex> {\n+        let move_data = self.base_results.operator().move_data();\n+\n+        let mut todo = vec![mpi];\n+        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n+        while let Some(mpi) = todo.pop() {\n+            if self.curr_state.contains(&mpi) {\n+                return Some(mpi);\n+            }\n+            let move_path = &move_data.move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+            if push_siblings {\n+                if let Some(sibling) = move_path.next_sibling {\n+                    todo.push(sibling);\n+                }\n+            } else {\n+                // after we've processed the original `mpi`, we should\n+                // always traverse the siblings of any of its\n+                // children.\n+                push_siblings = true;\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n     fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n         self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)"}]}