{"sha": "5f65331b3eff0a66a695127ec890638bb67e039f", "node_id": "C_kwDOAAsO6NoAKDVmNjUzMzFiM2VmZjBhNjZhNjk1MTI3ZWM4OTA2MzhiYjY3ZTAzOWY", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-05-22T15:04:49Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-05-25T16:13:17Z"}, "message": "suggest constraining dyn trait in impl in NLL", "tree": {"sha": "4625952919f398665a98b63e108c098dbf6d8699", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4625952919f398665a98b63e108c098dbf6d8699"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f65331b3eff0a66a695127ec890638bb67e039f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f65331b3eff0a66a695127ec890638bb67e039f", "html_url": "https://github.com/rust-lang/rust/commit/5f65331b3eff0a66a695127ec890638bb67e039f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f65331b3eff0a66a695127ec890638bb67e039f/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1072d2a9a514f11166eaf334140d33d257a120e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1072d2a9a514f11166eaf334140d33d257a120e", "html_url": "https://github.com/rust-lang/rust/commit/c1072d2a9a514f11166eaf334140d33d257a120e"}], "stats": {"total": 236, "additions": 208, "deletions": 28}, "files": [{"sha": "9d81330745fe2a15ab3c93832321cc05d0575e5b", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=5f65331b3eff0a66a695127ec890638bb67e039f", "patch": "@@ -161,7 +161,7 @@ impl OutlivesSuggestionBuilder {\n     pub(crate) fn intermediate_suggestion(\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'_>,\n         diag: &mut Diagnostic,\n     ) {\n         // Emit an intermediate note."}, {"sha": "a637f0613d1724db80223a515c182d4ace068130", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 195, "deletions": 26, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=5f65331b3eff0a66a695127ec890638bb67e039f", "patch": "@@ -1,19 +1,26 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{self as hir, Item, ItemKind, Node};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n-        NiceRegionError,\n+        HirTraitObjectVisitor, NiceRegionError, TraitObjectVisitor,\n     },\n     error_reporting::unexpected_hidden_region_diagnostic,\n     NllRegionVariableOrigin, RelateParamBound,\n };\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::Region;\n+use rustc_middle::ty::TypeVisitor;\n use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::sym;\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n@@ -27,7 +34,7 @@ use crate::{\n     MirBorrowckCtxt,\n };\n \n-impl ConstraintDescription for ConstraintCategory {\n+impl<'tcx> ConstraintDescription for ConstraintCategory<'tcx> {\n     fn description(&self) -> &'static str {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n@@ -37,7 +44,7 @@ impl ConstraintDescription for ConstraintCategory {\n             ConstraintCategory::UseAsConst => \"using this value as a constant \",\n             ConstraintCategory::UseAsStatic => \"using this value as a static \",\n             ConstraintCategory::Cast => \"cast \",\n-            ConstraintCategory::CallArgument => \"argument \",\n+            ConstraintCategory::CallArgument(_) => \"argument \",\n             ConstraintCategory::TypeAnnotation => \"type annotation \",\n             ConstraintCategory::ClosureBounds => \"closure body \",\n             ConstraintCategory::SizedBound => \"proving this value is `Sized` \",\n@@ -101,15 +108,15 @@ pub(crate) enum RegionErrorKind<'tcx> {\n \n /// Information about the various region constraints involved in a borrow checker error.\n #[derive(Clone, Debug)]\n-pub struct ErrorConstraintInfo {\n+pub struct ErrorConstraintInfo<'tcx> {\n     // fr: outlived_fr\n     pub(super) fr: RegionVid,\n     pub(super) fr_is_local: bool,\n     pub(super) outlived_fr: RegionVid,\n     pub(super) outlived_fr_is_local: bool,\n \n     // Category and span for best blame constraint\n-    pub(super) category: ConstraintCategory,\n+    pub(super) category: ConstraintCategory<'tcx>,\n     pub(super) span: Span,\n }\n \n@@ -256,6 +263,70 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlives_suggestion.add_suggestion(self);\n     }\n \n+    fn get_impl_ident_and_self_ty_from_trait(\n+        &self,\n+        def_id: DefId,\n+        trait_objects: &FxHashSet<DefId>,\n+    ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n+        let tcx = self.infcx.tcx;\n+        match tcx.hir().get_if_local(def_id) {\n+            Some(Node::ImplItem(impl_item)) => {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                    Some(Node::Item(Item {\n+                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                        ..\n+                    })) => Some((impl_item.ident, self_ty)),\n+                    _ => None,\n+                }\n+            }\n+            Some(Node::TraitItem(trait_item)) => {\n+                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n+                match tcx.hir().find_by_def_id(trait_did) {\n+                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n+                        // The method being called is defined in the `trait`, but the `'static`\n+                        // obligation comes from the `impl`. Find that `impl` so that we can point\n+                        // at it in the suggestion.\n+                        let trait_did = trait_did.to_def_id();\n+                        match tcx\n+                            .hir()\n+                            .trait_impls(trait_did)\n+                            .iter()\n+                            .filter_map(|&impl_did| {\n+                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n+                                    Some(Node::Item(Item {\n+                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                                        ..\n+                                    })) if trait_objects.iter().all(|did| {\n+                                        // FIXME: we should check `self_ty` against the receiver\n+                                        // type in the `UnifyReceiver` context, but for now, use\n+                                        // this imperfect proxy. This will fail if there are\n+                                        // multiple `impl`s for the same trait like\n+                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                                        // In that case, only the first one will get suggestions.\n+                                        let mut traits = vec![];\n+                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                                        hir_v.visit_ty(self_ty);\n+                                        !traits.is_empty()\n+                                    }) =>\n+                                    {\n+                                        Some(self_ty)\n+                                    }\n+                                    _ => None,\n+                                }\n+                            })\n+                            .next()\n+                        {\n+                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n+                            _ => None,\n+                        }\n+                    }\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -279,6 +350,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             });\n \n         debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n+\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let nice = NiceRegionError::new_from_span(self.infcx, cause.span, o, f);\n@@ -312,7 +384,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.report_fnmut_error(&errci, kind)\n             }\n             (ConstraintCategory::Assignment, true, false)\n-            | (ConstraintCategory::CallArgument, true, false) => {\n+            | (ConstraintCategory::CallArgument(_), true, false) => {\n                 let mut db = self.report_escaping_data_error(&errci);\n \n                 outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n@@ -405,7 +477,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n         kind: ReturnConstraint,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n@@ -486,7 +558,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n@@ -548,24 +620,28 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Only show an extra note if we can find an 'error region' for both of the region\n         // variables. This avoids showing a noisy note that just mentions 'synthetic' regions\n         // that don't help the user understand the error.\n-        if self.to_error_region(errci.fr).is_some()\n-            && self.to_error_region(errci.outlived_fr).is_some()\n-        {\n-            let fr_region_name = self.give_region_a_name(errci.fr).unwrap();\n-            fr_region_name.highlight_region_name(&mut diag);\n-            let outlived_fr_region_name = self.give_region_a_name(errci.outlived_fr).unwrap();\n-            outlived_fr_region_name.highlight_region_name(&mut diag);\n+        match (self.to_error_region(errci.fr), self.to_error_region(errci.outlived_fr)) {\n+            (Some(f), Some(o)) => {\n+                self.maybe_suggest_constrain_dyn_trait_impl(&mut diag, f, o, category);\n \n-            diag.span_label(\n-                *span,\n-                format!(\n-                    \"{}requires that `{}` must outlive `{}`\",\n-                    category.description(),\n-                    fr_region_name,\n-                    outlived_fr_region_name,\n-                ),\n-            );\n+                let fr_region_name = self.give_region_a_name(errci.fr).unwrap();\n+                fr_region_name.highlight_region_name(&mut diag);\n+                let outlived_fr_region_name = self.give_region_a_name(errci.outlived_fr).unwrap();\n+                outlived_fr_region_name.highlight_region_name(&mut diag);\n+\n+                diag.span_label(\n+                    *span,\n+                    format!(\n+                        \"{}requires that `{}` must outlive `{}`\",\n+                        category.description(),\n+                        fr_region_name,\n+                        outlived_fr_region_name,\n+                    ),\n+                );\n+            }\n+            _ => {}\n         }\n+\n         diag\n     }\n \n@@ -586,7 +662,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo {\n             fr,\n@@ -699,6 +775,99 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn maybe_suggest_constrain_dyn_trait_impl(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        f: Region<'tcx>,\n+        o: Region<'tcx>,\n+        category: &ConstraintCategory<'tcx>,\n+    ) {\n+        if !o.is_static() {\n+            return;\n+        }\n+\n+        let tcx = self.infcx.tcx;\n+\n+        let instance = if let ConstraintCategory::CallArgument(Some((fn_did, substs))) = category {\n+            debug!(?fn_did, ?substs);\n+\n+            // Only suggest this on function calls, not closures\n+            let ty = tcx.type_of(fn_did);\n+            debug!(\"ty: {:?}, ty.kind: {:?}\", ty, ty.kind());\n+            if let ty::Closure(_, _) = ty.kind() {\n+                return;\n+            }\n+\n+            if let Ok(Some(instance)) = ty::Instance::resolve(\n+                tcx,\n+                self.param_env,\n+                *fn_did,\n+                self.infcx.resolve_vars_if_possible(substs),\n+            ) {\n+                instance\n+            } else {\n+                return;\n+            }\n+        } else {\n+            return;\n+        };\n+\n+        let param = match find_param_with_region(tcx, f, o) {\n+            Some(param) => param,\n+            None => return,\n+        };\n+        debug!(?param);\n+\n+        let mut visitor = TraitObjectVisitor(FxHashSet::default());\n+        visitor.visit_ty(param.param_ty);\n+\n+        if let Some((ident, self_ty)) =\n+            self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &visitor.0)\n+        {\n+            self.suggest_constrain_dyn_trait_in_impl(diag, &visitor.0, ident, self_ty)\n+        } else {\n+            return;\n+        };\n+    }\n+\n+    #[instrument(skip(self, err), level = \"debug\")]\n+    fn suggest_constrain_dyn_trait_in_impl(\n+        &self,\n+        err: &mut Diagnostic,\n+        found_dids: &FxHashSet<DefId>,\n+        ident: Ident,\n+        self_ty: &hir::Ty<'_>,\n+    ) -> bool {\n+        debug!(\"err: {:#?}\", err);\n+        let mut suggested = false;\n+        for found_did in found_dids {\n+            let mut traits = vec![];\n+            let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n+            hir_v.visit_ty(&self_ty);\n+            debug!(\"trait spans found: {:?}\", traits);\n+            for span in &traits {\n+                let mut multi_span: MultiSpan = vec![*span].into();\n+                multi_span.push_span_label(\n+                    *span,\n+                    \"this has an implicit `'static` lifetime requirement\".to_string(),\n+                );\n+                multi_span.push_span_label(\n+                    ident.span,\n+                    \"calling this method introduces the `impl`'s 'static` requirement\".to_string(),\n+                );\n+                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider relaxing the implicit `'static` requirement\",\n+                    \" + '_\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                suggested = true;\n+            }\n+        }\n+        suggested\n+    }\n+\n     fn suggest_adding_lifetime_params(\n         &self,\n         diag: &mut Diagnostic,"}, {"sha": "2cff12e3c8b839465f08e2daa30e932411fd64b5", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=5f65331b3eff0a66a695127ec890638bb67e039f", "patch": "@@ -938,7 +938,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n \n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    crate closure_bounds_mapping:\n+    pub(crate) closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n \n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,"}, {"sha": "96b57b6cd2055e33d646e077fc51ace1c76d5063", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65331b3eff0a66a695127ec890638bb67e039f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=5f65331b3eff0a66a695127ec890638bb67e039f", "patch": "@@ -34,6 +34,7 @@ pub struct AnonymousParamInfo<'tcx> {\n // i32, which is the type of y but with the anonymous region replaced\n // with 'a, the corresponding bound region and is_first which is true if\n // the hir::Param is the first parameter in the function declaration.\n+#[instrument(skip(tcx), level = \"debug\")]\n pub fn find_param_with_region<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     anon_region: Region<'tcx>,\n@@ -51,9 +52,19 @@ pub fn find_param_with_region<'tcx>(\n     let hir_id = hir.local_def_id_to_hir_id(id.as_local()?);\n     let body_id = hir.maybe_body_owned_by(hir_id)?;\n     let body = hir.body(body_id);\n+\n+    // Don't perform this on closures\n+    match hir.get(hir_id) {\n+        hir::Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n+            return None;\n+        }\n+        _ => {}\n+    }\n+\n     let owner_id = hir.body_owner(body_id);\n     let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n     let poly_fn_sig = tcx.fn_sig(id);\n+\n     let fn_sig = tcx.liberate_late_bound_regions(id, poly_fn_sig);\n     body.params\n         .iter()"}]}