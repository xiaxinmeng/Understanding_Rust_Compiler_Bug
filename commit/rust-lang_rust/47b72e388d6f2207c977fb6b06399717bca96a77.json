{"sha": "47b72e388d6f2207c977fb6b06399717bca96a77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YjcyZTM4OGQ2ZjIyMDdjOTc3ZmI2YjA2Mzk5NzE3YmNhOTZhNzc=", "commit": {"author": {"name": "Renato Zannon", "email": "renato@rrsz.com.br", "date": "2014-06-10T03:41:44Z"}, "committer": {"name": "Renato Zannon", "email": "renato@rrsz.com.br", "date": "2014-06-10T03:41:44Z"}, "message": "Remove & -> &mut transmute from TypedArena", "tree": {"sha": "b66a86ff09567df7abc0a94d8fc7ff1b833fcf44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b66a86ff09567df7abc0a94d8fc7ff1b833fcf44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47b72e388d6f2207c977fb6b06399717bca96a77", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47b72e388d6f2207c977fb6b06399717bca96a77", "html_url": "https://github.com/rust-lang/rust/commit/47b72e388d6f2207c977fb6b06399717bca96a77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47b72e388d6f2207c977fb6b06399717bca96a77/comments", "author": {"login": "renato-zannon", "id": 486508, "node_id": "MDQ6VXNlcjQ4NjUwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/486508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/renato-zannon", "html_url": "https://github.com/renato-zannon", "followers_url": "https://api.github.com/users/renato-zannon/followers", "following_url": "https://api.github.com/users/renato-zannon/following{/other_user}", "gists_url": "https://api.github.com/users/renato-zannon/gists{/gist_id}", "starred_url": "https://api.github.com/users/renato-zannon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/renato-zannon/subscriptions", "organizations_url": "https://api.github.com/users/renato-zannon/orgs", "repos_url": "https://api.github.com/users/renato-zannon/repos", "events_url": "https://api.github.com/users/renato-zannon/events{/privacy}", "received_events_url": "https://api.github.com/users/renato-zannon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "renato-zannon", "id": 486508, "node_id": "MDQ6VXNlcjQ4NjUwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/486508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/renato-zannon", "html_url": "https://github.com/renato-zannon", "followers_url": "https://api.github.com/users/renato-zannon/followers", "following_url": "https://api.github.com/users/renato-zannon/following{/other_user}", "gists_url": "https://api.github.com/users/renato-zannon/gists{/gist_id}", "starred_url": "https://api.github.com/users/renato-zannon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/renato-zannon/subscriptions", "organizations_url": "https://api.github.com/users/renato-zannon/orgs", "repos_url": "https://api.github.com/users/renato-zannon/repos", "events_url": "https://api.github.com/users/renato-zannon/events{/privacy}", "received_events_url": "https://api.github.com/users/renato-zannon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a535cfb1f04953e2307b0a2d1b3ddcfdf348009f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f", "html_url": "https://github.com/rust-lang/rust/commit/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f"}], "stats": {"total": 50, "additions": 25, "deletions": 25}, "files": [{"sha": "996369cbf6d7d90f6c52c60110194c039d8952c1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/47b72e388d6f2207c977fb6b06399717bca96a77/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b72e388d6f2207c977fb6b06399717bca96a77/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=47b72e388d6f2207c977fb6b06399717bca96a77", "patch": "@@ -345,19 +345,20 @@ fn test_arena_destructors_fail() {\n /// run again for these objects.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n-    ptr: *T,\n+    ptr: Cell<*T>,\n \n     /// A pointer to the end of the allocated area. When this pointer is\n     /// reached, a new chunk is allocated.\n-    end: *T,\n+    end: Cell<*T>,\n \n     /// A pointer to the first arena segment.\n-    first: Option<Box<TypedArenaChunk<T>>>,\n+    first: RefCell<TypedArenaChunkRef<T>>,\n }\n+type TypedArenaChunkRef<T> = Option<Box<TypedArenaChunk<T>>>;\n \n struct TypedArenaChunk<T> {\n     /// Pointer to the next arena segment.\n-    next: Option<Box<TypedArenaChunk<T>>>,\n+    next: TypedArenaChunkRef<T>,\n \n     /// The number of elements that this chunk can hold.\n     capacity: uint,\n@@ -443,53 +444,52 @@ impl<T> TypedArena<T> {\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n         let chunk = TypedArenaChunk::<T>::new(None, capacity);\n         TypedArena {\n-            ptr: chunk.start() as *T,\n-            end: chunk.end() as *T,\n-            first: Some(chunk),\n+            ptr: Cell::new(chunk.start() as *T),\n+            end: Cell::new(chunk.end() as *T),\n+            first: RefCell::new(Some(chunk)),\n         }\n     }\n \n     /// Allocates an object in the TypedArena, returning a reference to it.\n     #[inline]\n     pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n-        unsafe {\n-            // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n-            let this: &mut TypedArena<T> = mem::transmute::<&_, &mut _>(self);\n-            if this.ptr == this.end {\n-                this.grow()\n-            }\n+        if self.ptr == self.end {\n+            self.grow()\n+        }\n \n-            let ptr: &'a mut T = mem::transmute(this.ptr);\n+        let ptr: &'a T = unsafe {\n+            let ptr: &'a mut T = mem::transmute(self.ptr);\n             ptr::write(ptr, object);\n-            this.ptr = this.ptr.offset(1);\n-            let ptr: &'a T = ptr;\n+            self.ptr.set(self.ptr.get().offset(1));\n             ptr\n-        }\n+        };\n+\n+        ptr\n     }\n \n     /// Grows the arena.\n     #[inline(never)]\n-    fn grow(&mut self) {\n-        let chunk = self.first.take_unwrap();\n+    fn grow(&self) {\n+        let chunk = self.first.borrow_mut().take_unwrap();\n         let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n         let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n-        self.ptr = chunk.start() as *T;\n-        self.end = chunk.end() as *T;\n-        self.first = Some(chunk)\n+        self.ptr.set(chunk.start() as *T);\n+        self.end.set(chunk.end() as *T);\n+        *self.first.borrow_mut() = Some(chunk)\n     }\n }\n \n #[unsafe_destructor]\n impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         // Determine how much was filled.\n-        let start = self.first.get_ref().start() as uint;\n-        let end = self.ptr as uint;\n+        let start = self.first.borrow().get_ref().start() as uint;\n+        let end = self.ptr.get() as uint;\n         let diff = (end - start) / mem::size_of::<T>();\n \n         // Pass that to the `destroy` method.\n         unsafe {\n-            self.first.get_mut_ref().destroy(diff)\n+            self.first.borrow_mut().get_mut_ref().destroy(diff)\n         }\n     }\n }"}]}