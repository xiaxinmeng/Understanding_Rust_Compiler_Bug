{"sha": "279844ce9fc64969d1c048335214627ab50237a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OTg0NGNlOWZjNjQ5NjlkMWMwNDgzMzUyMTQ2MjdhYjUwMjM3YTA=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-27T21:51:25Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-28T17:47:28Z"}, "message": "Atomic reference counting for tasks.", "tree": {"sha": "40156df61bc5df2bb3c1f1839f4afd65052db7e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40156df61bc5df2bb3c1f1839f4afd65052db7e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/279844ce9fc64969d1c048335214627ab50237a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/279844ce9fc64969d1c048335214627ab50237a0", "html_url": "https://github.com/rust-lang/rust/commit/279844ce9fc64969d1c048335214627ab50237a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/279844ce9fc64969d1c048335214627ab50237a0/comments", "author": null, "committer": null, "parents": [{"sha": "a5fe66e7065c0e91064f3a818ea901ecfb499b70", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fe66e7065c0e91064f3a818ea901ecfb499b70", "html_url": "https://github.com/rust-lang/rust/commit/a5fe66e7065c0e91064f3a818ea901ecfb499b70"}], "stats": {"total": 120, "additions": 43, "deletions": 77}, "files": [{"sha": "44924218e570a5ae9304287339a16a5db71be289", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -4,7 +4,7 @@\n // NB: please do not commit code with this uncommented. It's\n // hugely expensive and should only be used as a last resort.\n //\n-// #define TRACK_ALLOCATIONS\n+#define TRACK_ALLOCATIONS\n \n #define MAGIC 0xbadc0ffe\n "}, {"sha": "dc6ea0fefdf37a7a992d48de266b4538683ad9f1", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -60,7 +60,7 @@ void rust_chan::disassociate() {\n         //     \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n         //     this, port->referent());\n         --this->ref_count;\n-        --this->task->ref_count;\n+        task->deref();\n         this->task = NULL;\n         port->referent()->chans.swap_delete(this);\n     }\n@@ -109,22 +109,10 @@ void rust_chan::send(void *sptr) {\n     return;\n }\n \n-rust_chan *rust_chan::clone(maybe_proxy<rust_task> *target) {\n+rust_chan *rust_chan::clone(rust_task *target) {\n     size_t unit_sz = buffer.unit_sz;\n     maybe_proxy<rust_port> *port = this->port;\n-    rust_task *target_task = NULL;\n-    if (target->is_proxy() == false) {\n-        port = this->port;\n-        target_task = target->referent();\n-    } else {\n-        rust_handle<rust_port> *handle =\n-            task->sched->kernel->get_port_handle(port->as_referent());\n-        maybe_proxy<rust_port> *proxy = new rust_proxy<rust_port> (handle);\n-        DLOG(task->sched, mem, \"new proxy: \" PTR, proxy);\n-        port = proxy;\n-        target_task = target->as_proxy()->handle()->referent();\n-    }\n-    return new (target_task->kernel, \"cloned chan\")\n+    return new (target->kernel, \"cloned chan\")\n         rust_chan(kernel, port, unit_sz);\n }\n "}, {"sha": "68cdd31b3cc927beeb9f5c9083da18393180c316", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -22,7 +22,7 @@ class rust_chan : public kernel_owned<rust_chan>,\n \n     void send(void *sptr);\n \n-    rust_chan *clone(maybe_proxy<rust_task> *target);\n+    rust_chan *clone(rust_task *target);\n \n     // Called whenever the channel's ref count drops to zero.\n     void destroy();"}, {"sha": "f8001a17193b1d4f8377fba554a725c0971f74c2", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -61,8 +61,8 @@ void notify_message::process() {\n         break;\n     case JOIN: {\n         if (task->dead() == false) {\n-            rust_proxy<rust_task> *proxy = new rust_proxy<rust_task>(_source);\n-            task->tasks_waiting_to_join.append(proxy);\n+            // FIXME: this should be dead code.\n+            assert(false);\n         } else {\n             send(WAKEUP, \"wakeup\", _target, _source);\n         }"}, {"sha": "245ee3d5fce706697206153127457a5f15cbaadb", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -89,14 +89,14 @@ rust_scheduler::reap_dead_tasks(int id) {\n         rust_task *task = dead_tasks[i];\n         task->lock.lock();\n         // Make sure this task isn't still running somewhere else...\n-        if (task->ref_count == 0 && task->can_schedule(id)) {\n+        if (task->can_schedule(id)) {\n             I(this, task->tasks_waiting_to_join.is_empty());\n             dead_tasks.remove(task);\n             DLOG(this, task,\n                 \"deleting unreferenced dead task %s @0x%\" PRIxPTR,\n                 task->name, task);\n             task->lock.unlock();\n-            delete task;\n+            task->deref();\n             sync::decrement(kernel->live_tasks);\n             kernel->wakeup_schedulers();\n             continue;\n@@ -174,9 +174,8 @@ rust_scheduler::log_state() {\n     if (!dead_tasks.is_empty()) {\n         log(NULL, log_note, \"dead tasks:\");\n         for (size_t i = 0; i < dead_tasks.length(); i++) {\n-            log(NULL, log_note, \"\\t task: %s 0x%\" PRIxPTR \", ref_count: %d\",\n-                dead_tasks[i]->name, dead_tasks[i],\n-                dead_tasks[i]->ref_count);\n+            log(NULL, log_note, \"\\t task: %s 0x%\" PRIxPTR,\n+                dead_tasks[i]->name, dead_tasks[i]);\n         }\n     }\n }\n@@ -225,15 +224,13 @@ rust_scheduler::start_main_loop() {\n         I(this, scheduled_task->running());\n \n         DLOG(this, task,\n-            \"activating task %s 0x%\" PRIxPTR\n-            \", sp=0x%\" PRIxPTR\n-            \", ref_count=%d\"\n-            \", state: %s\",\n-            scheduled_task->name,\n-            (uintptr_t)scheduled_task,\n-            scheduled_task->rust_sp,\n-            scheduled_task->ref_count,\n-            scheduled_task->state->name);\n+             \"activating task %s 0x%\" PRIxPTR\n+             \", sp=0x%\" PRIxPTR\n+             \", state: %s\",\n+             scheduled_task->name,\n+             (uintptr_t)scheduled_task,\n+             scheduled_task->rust_sp,\n+             scheduled_task->state->name);\n \n         interrupt_flag = 0;\n "}, {"sha": "a144879cc040b28a4c378990c517de3b51079c47", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -64,7 +64,7 @@ size_t const callee_save_fp = 0;\n \n rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n                      rust_task *spawner, const char *name) :\n-    maybe_proxy<rust_task>(this),\n+    ref_count(1),\n     stk(NULL),\n     runtime_sp(0),\n     rust_sp(0),\n@@ -92,10 +92,6 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n \n     stk = new_stk(this, 0);\n     rust_sp = stk->limit;\n-\n-    if (spawner == NULL) {\n-        ref_count = 0;\n-    }\n }\n \n rust_task::~rust_task()\n@@ -131,10 +127,6 @@ void task_start_wrapper(spawn_args *a)\n \n     LOG(task, task, \"task exited with value %d\", rval);\n \n-\n-    LOG(task, task, \"task ref_count: %d\", task->ref_count);\n-    A(task->sched, task->ref_count >= 0,\n-      \"Task ref_count should not be negative on exit!\");\n     task->die();\n     task->lock.lock();\n     task->notify_tasks_waiting_to_join();\n@@ -263,17 +255,10 @@ rust_task::notify_tasks_waiting_to_join() {\n     while (tasks_waiting_to_join.is_empty() == false) {\n         LOG(this, task, \"notify_tasks_waiting_to_join: %d\",\n             tasks_waiting_to_join.size());\n-        maybe_proxy<rust_task> *waiting_task = 0;\n+        rust_task *waiting_task = 0;\n         tasks_waiting_to_join.pop(&waiting_task);\n-        if (waiting_task->is_proxy()) {\n-            notify_message::send(notify_message::WAKEUP, \"wakeup\",\n-                get_handle(), waiting_task->as_proxy()->handle());\n-            delete waiting_task;\n-        } else {\n-            rust_task *task = waiting_task->referent();\n-            if (task->blocked() == true) {\n-                task->wakeup(this);\n-            }\n+        if (waiting_task->blocked() == true) {\n+            waiting_task->wakeup(this);\n         }\n     }\n }"}, {"sha": "8b55c0028a97217b96f7702ad5d5eabf164edc7d", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -34,10 +34,19 @@ struct gc_alloc {\n     }\n };\n \n+\n struct\n-rust_task : public maybe_proxy<rust_task>,\n-            public kernel_owned<rust_task>\n+rust_task : public kernel_owned<rust_task>, rust_cond\n {\n+    // This block could be pulled out into something like a\n+    // RUST_ATOMIC_REFCOUNTED macro.\n+private:\n+    intptr_t ref_count;\n+public:\n+    void ref() { sync::increment(ref_count); }\n+    void deref() { if(0 == sync::decrement(ref_count)) { delete this; } }\n+\n+\n     // Fields known to the compiler.\n     stk_seg *stk;\n     uintptr_t runtime_sp;      // Runtime sp while task running.\n@@ -69,7 +78,7 @@ rust_task : public maybe_proxy<rust_task>,\n     uintptr_t* rendezvous_ptr;\n \n     // List of tasks waiting for this task to finish.\n-    array_list<maybe_proxy<rust_task> *> tasks_waiting_to_join;\n+    array_list<rust_task *> tasks_waiting_to_join;\n \n     rust_handle<rust_task> *handle;\n "}, {"sha": "794bbc9c2443aec166f996e2035af584aeff6180", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/279844ce9fc64969d1c048335214627ab50237a0/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=279844ce9fc64969d1c048335214627ab50237a0", "patch": "@@ -6,12 +6,10 @@\n #define LOG_UPCALL_ENTRY(task)                            \\\n     LOG(task, upcall,                                     \\\n         \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n-        \" retpc: x%\" PRIxPTR                              \\\n-        \" ref_count: %d\",                                 \\\n+        \" retpc: x%\" PRIxPTR,                             \\\n         __FUNCTION__,                                     \\\n         (task)->name, (task),                             \\\n-        __builtin_return_address(0),                      \\\n-        (task->ref_count));\n+        __builtin_return_address(0));\n #else\n #define LOG_UPCALL_ENTRY(task)                            \\\n     LOG(task, upcall, \"> UPCALL task: %s @x%\" PRIxPTR,    \\\n@@ -114,8 +112,8 @@ upcall_del_port(rust_task *task, rust_port *port) {\n     I(task->sched, !port->ref_count);\n     delete port;\n \n-    // FIXME: We shouldn't ever directly manipulate the ref count.\n-    --task->ref_count;\n+    // FIXME: this should happen in the port.\n+    task->deref();\n }\n \n /**\n@@ -162,7 +160,7 @@ void upcall_del_chan(rust_task *task, rust_chan *chan) {\n  * has its own copy of the channel.\n  */\n extern \"C\" CDECL rust_chan *\n-upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n+upcall_clone_chan(rust_task *task, rust_task *target,\n                   rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n     return chan->clone(target);\n@@ -247,18 +245,10 @@ upcall_fail(rust_task *task,\n  * Called whenever a task's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_kill(rust_task *task, maybe_proxy<rust_task> *target) {\n+upcall_kill(rust_task *task, rust_task *target) {\n     LOG_UPCALL_ENTRY(task);\n \n-    if (target->is_proxy()) {\n-        notify_message::\n-        send(notify_message::KILL, \"kill\", task->get_handle(),\n-             target->as_proxy()->handle());\n-        // The proxy ref_count dropped to zero, delete it here.\n-        delete target->as_proxy();\n-    } else {\n-        target->referent()->kill();\n-    }\n+    target->kill();\n }\n \n /**\n@@ -267,9 +257,6 @@ upcall_kill(rust_task *task, maybe_proxy<rust_task> *target) {\n extern \"C\" CDECL void\n upcall_exit(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n-    LOG(task, task, \"task ref_count: %d\", task->ref_count);\n-    A(task->sched, task->ref_count >= 0,\n-      \"Task ref_count should not be negative on exit!\");\n     task->die();\n     task->notify_tasks_waiting_to_join();\n     task->yield(1);\n@@ -544,6 +531,7 @@ upcall_new_task(rust_task *spawner, rust_vec *name) {\n     scoped_lock with(spawner->sched->lock);\n     rust_task *task =\n         spawner->kernel->create_task(spawner, (const char *)name->data);\n+    task->ref();\n     return task;\n }\n \n@@ -559,8 +547,7 @@ extern \"C\" CDECL void\n upcall_drop_task(rust_task *task, rust_task *target) {\n     LOG_UPCALL_ENTRY(task);\n     if(target) {\n-        //target->deref();\n-        --target->ref_count;\n+        target->deref();\n     }\n }\n "}]}