{"sha": "940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MGQxYWUyZjNiMWNiYThjZmQ4NThhYjNhNTRkNjQwOGI1M2IwMzM=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-02-06T04:05:30Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-02-08T01:08:35Z"}, "message": "remove type descriptors from proc and @T\n\nThis also drops support for the managed pointer POISON_ON_FREE feature\nas it's not worth adding back the support for it. After a snapshot, the\nleftovers can be removed.", "tree": {"sha": "c1060d4799cecaca94f31f6b1cae8bc9aa66a170", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1060d4799cecaca94f31f6b1cae8bc9aa66a170"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "html_url": "https://github.com/rust-lang/rust/commit/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56565eb129018a708445afcd6ea14f5b51cf27e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/56565eb129018a708445afcd6ea14f5b51cf27e5", "html_url": "https://github.com/rust-lang/rust/commit/56565eb129018a708445afcd6ea14f5b51cf27e5"}], "stats": {"total": 213, "additions": 171, "deletions": 42}, "files": [{"sha": "d877a468cf099d900f46d031d6a55092e7d69b6d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -352,7 +352,6 @@ pub fn malloc_raw_dyn<'a>(\n     if heap == heap_exchange {\n         let llty_value = type_of::type_of(ccx, t);\n \n-\n         // Allocate space:\n         let r = callee::trans_lang_call(\n             bcx,\n@@ -375,17 +374,18 @@ pub fn malloc_raw_dyn<'a>(\n         // Grab the TypeRef type of box_ptr_ty.\n         let box_ptr_ty = ty::mk_box(bcx.tcx(), t);\n         let llty = type_of(ccx, box_ptr_ty);\n+        let llalign = C_uint(ccx, llalign_of_min(ccx, llty) as uint);\n \n         // Get the tydesc for the body:\n         let static_ti = get_tydesc(ccx, t);\n         glue::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n \n         // Allocate space:\n-        let tydesc = PointerCast(bcx, static_ti.tydesc, Type::i8p());\n+        let drop_glue = static_ti.drop_glue.get().unwrap();\n         let r = callee::trans_lang_call(\n             bcx,\n             langcall,\n-            [tydesc, size],\n+            [PointerCast(bcx, drop_glue, Type::glue_fn(Type::i8p()).ptr_to()), size, llalign],\n             None);\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n     }"}, {"sha": "7bbbf4f99059f1ef1a1c32344066a61edbb4f4e1", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -1779,7 +1779,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"tydesc\",\n+            name: ~\"drop_glue\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -1824,7 +1824,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n                           -> bool {\n         member_llvm_types.len() == 5 &&\n         member_llvm_types[0] == cx.int_type &&\n-        member_llvm_types[1] == cx.tydesc_type.ptr_to() &&\n+        member_llvm_types[1] == Type::generic_glue_fn(cx).ptr_to() &&\n         member_llvm_types[2] == Type::i8().ptr_to() &&\n         member_llvm_types[3] == Type::i8().ptr_to() &&\n         member_llvm_types[4] == content_llvm_type"}, {"sha": "c1fb1fc1589ee56ed43e614d51cf80a99cb783c6", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -355,9 +355,9 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n             // Only drop the value when it is non-null\n             with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n-                let lldtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n-                let lldtor = Load(bcx, lldtor_ptr);\n-                Call(bcx, lldtor, [PointerCast(bcx, lluniquevalue, Type::i8p())], []);\n+                let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+                let dtor = Load(bcx, dtor_ptr);\n+                Call(bcx, dtor, [PointerCast(bcx, lluniquevalue, Type::i8p())], []);\n                 bcx\n             })\n         }\n@@ -367,18 +367,12 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             let env_ptr_ty = Type::at_box(ccx, Type::i8()).ptr_to();\n             let env = PointerCast(bcx, env, env_ptr_ty);\n             with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n-                // Load the type descr found in the env\n-                let lltydescty = ccx.tydesc_type.ptr_to();\n-                let tydescptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n-                let tydesc = Load(bcx, tydescptr);\n-                let tydesc = PointerCast(bcx, tydesc, lltydescty);\n-\n-                // Drop the tuple data then free the descriptor\n+                let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n+                let dtor = Load(bcx, dtor_ptr);\n                 let cdata = GEPi(bcx, env, [0u, abi::box_field_body]);\n-                call_tydesc_glue_full(bcx, cdata, tydesc,\n-                                      abi::tydesc_field_drop_glue, None);\n+                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p())], []);\n \n-                // Free the ty descr (if necc) and the env itself\n+                // Free the environment itself\n                 trans_exchange_free(bcx, env)\n             })\n         }"}, {"sha": "804486c415976e04783eb827156b54002ecd4d42", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -238,7 +238,7 @@ impl Type {\n     // The box pointed to by @T.\n     pub fn at_box(ctx: &CrateContext, ty: Type) -> Type {\n         Type::struct_([\n-            ctx.int_type, ctx.tydesc_type.ptr_to(),\n+            ctx.int_type, Type::glue_fn(Type::i8p()).ptr_to(),\n             Type::i8p(), Type::i8p(), ty\n         ], false)\n     }"}, {"sha": "a43dca949703043b538f9a1ae73bc103f84c9dd6", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -11,11 +11,8 @@\n #[doc(hidden)];\n \n use ptr;\n-use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n-type DropGlue<'a> = 'a |**TyDesc, *u8|;\n-\n static RC_IMMORTAL : uint = 0x77777777;\n \n /*\n@@ -24,11 +21,6 @@ static RC_IMMORTAL : uint = 0x77777777;\n  * This runs at task death to free all boxes.\n  */\n \n-struct AnnihilateStats {\n-    n_total_boxes: uint,\n-    n_bytes_freed: uint\n-}\n-\n unsafe fn each_live_alloc(read_next_before: bool,\n                           f: |alloc: *mut raw::Box<()>| -> bool)\n                           -> bool {\n@@ -65,21 +57,18 @@ fn debug_mem() -> bool {\n }\n \n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n+#[cfg(stage0)]\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n-    use mem;\n \n-    let mut stats = AnnihilateStats {\n-        n_total_boxes: 0,\n-        n_bytes_freed: 0\n-    };\n+    let mut n_total_boxes = 0u;\n \n     // Pass 1: Make all boxes immortal.\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n     each_live_alloc(true, |alloc| {\n-        stats.n_total_boxes += 1;\n+        n_total_boxes += 1;\n         (*alloc).ref_count = RC_IMMORTAL;\n         true\n     });\n@@ -103,18 +92,58 @@ pub unsafe fn annihilate() {\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n     each_live_alloc(true, |alloc| {\n-        stats.n_bytes_freed +=\n-            (*((*alloc).type_desc)).size\n-            + mem::size_of::<raw::Box<()>>();\n         local_free(alloc as *u8);\n         true\n     });\n \n     if debug_mem() {\n         // We do logging here w/o allocation.\n-        debug!(\"annihilator stats:\\n  \\\n-                       total boxes: {}\\n  \\\n-                       bytes freed: {}\",\n-                stats.n_total_boxes, stats.n_bytes_freed);\n+        debug!(\"total boxes annihilated: {}\", n_total_boxes);\n+    }\n+}\n+\n+/// Destroys all managed memory (i.e. @ boxes) held by the current task.\n+#[cfg(not(stage0))]\n+pub unsafe fn annihilate() {\n+    use rt::local_heap::local_free;\n+\n+    let mut n_total_boxes = 0u;\n+\n+    // Pass 1: Make all boxes immortal.\n+    //\n+    // In this pass, nothing gets freed, so it does not matter whether\n+    // we read the next field before or after the callback.\n+    each_live_alloc(true, |alloc| {\n+        n_total_boxes += 1;\n+        (*alloc).ref_count = RC_IMMORTAL;\n+        true\n+    });\n+\n+    // Pass 2: Drop all boxes.\n+    //\n+    // In this pass, unique-managed boxes may get freed, but not\n+    // managed boxes, so we must read the `next` field *after* the\n+    // callback, as the original value may have been freed.\n+    each_live_alloc(false, |alloc| {\n+        let drop_glue = (*alloc).drop_glue;\n+        let data = &mut (*alloc).data as *mut ();\n+        drop_glue(data as *mut u8);\n+        true\n+    });\n+\n+    // Pass 3: Free all boxes.\n+    //\n+    // In this pass, managed boxes may get freed (but not\n+    // unique-managed boxes, though I think that none of those are\n+    // left), so we must read the `next` field before, since it will\n+    // not be valid after.\n+    each_live_alloc(true, |alloc| {\n+        local_free(alloc as *u8);\n+        true\n+    });\n+\n+    if debug_mem() {\n+        // We do logging here w/o allocation.\n+        debug!(\"total boxes annihilated: {}\", n_total_boxes);\n     }\n }"}, {"sha": "571ed77592fcc7a0a94415f5c922174b19222b7a", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -10,6 +10,8 @@\n \n //! Runtime environment settings\n \n+// NOTE: remove `POISON_ON_FREE` after a snapshot\n+\n use from_str::from_str;\n use option::{Some, None};\n use os;"}, {"sha": "2f553585f38ce67b0b3fac4e50be4a1d53213b64", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -10,7 +10,9 @@\n \n use libc::{c_void, size_t, free, malloc, realloc};\n use ptr::{RawPtr, mut_null};\n-use unstable::intrinsics::{TyDesc, abort};\n+#[cfg(stage0)]\n+use unstable::intrinsics::TyDesc;\n+use unstable::intrinsics::abort;\n use unstable::raw;\n use mem::size_of;\n \n@@ -73,14 +75,23 @@ pub unsafe fn exchange_malloc(size: uint) -> *u8 {\n }\n \n // FIXME: #7496\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n #[lang=\"closure_exchange_malloc\"]\n #[inline]\n pub unsafe fn closure_exchange_malloc_(td: *u8, size: uint) -> *u8 {\n     closure_exchange_malloc(td, size)\n }\n \n+// FIXME: #7496\n+#[cfg(not(test), not(stage0))]\n+#[lang=\"closure_exchange_malloc\"]\n #[inline]\n+pub unsafe fn closure_exchange_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    closure_exchange_malloc(drop_glue, size, align)\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n pub unsafe fn closure_exchange_malloc(td: *u8, size: uint) -> *u8 {\n     let td = td as *TyDesc;\n     let size = size;\n@@ -96,6 +107,18 @@ pub unsafe fn closure_exchange_malloc(td: *u8, size: uint) -> *u8 {\n     alloc as *u8\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+pub unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    let total_size = get_box_size(size, align);\n+    let p = malloc_raw(total_size);\n+\n+    let alloc = p as *mut raw::Box<()>;\n+    (*alloc).drop_glue = drop_glue;\n+\n+    alloc as *u8\n+}\n+\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler.\n #[cfg(not(test))]"}, {"sha": "3bee9e48b602ed7c8cf81360a921ee8c406a9864", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -21,6 +21,7 @@ use rt::env;\n use rt::global_heap;\n use rt::local::Local;\n use rt::task::Task;\n+#[cfg(stage0)]\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n use vec::ImmutableVector;\n@@ -60,6 +61,7 @@ impl LocalHeap {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn alloc(&mut self, td: *TyDesc, size: uint) -> *mut Box {\n         let total_size = global_heap::get_box_size(size, unsafe { (*td).align });\n         let alloc = self.memory_region.malloc(total_size);\n@@ -80,6 +82,28 @@ impl LocalHeap {\n         return alloc;\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box {\n+        let total_size = global_heap::get_box_size(size, align);\n+        let alloc = self.memory_region.malloc(total_size);\n+        {\n+            // Make sure that we can't use `mybox` outside of this scope\n+            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n+            // Clear out this box, and move it to the front of the live\n+            // allocations list\n+            mybox.drop_glue = drop_glue;\n+            mybox.ref_count = 1;\n+            mybox.prev = ptr::mut_null();\n+            mybox.next = self.live_allocs;\n+            if !self.live_allocs.is_null() {\n+                unsafe { (*self.live_allocs).prev = alloc; }\n+            }\n+            self.live_allocs = alloc;\n+        }\n+        return alloc;\n+    }\n+\n     #[inline]\n     pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box {\n         // Make sure that we can't use `mybox` outside of this scope\n@@ -102,6 +126,7 @@ impl LocalHeap {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn free(&mut self, alloc: *mut Box) {\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n@@ -133,6 +158,28 @@ impl LocalHeap {\n \n         self.memory_region.free(alloc);\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn free(&mut self, alloc: *mut Box) {\n+        {\n+            // Make sure that we can't use `mybox` outside of this scope\n+            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n+\n+            // Unlink it from the linked list\n+            if !mybox.prev.is_null() {\n+                unsafe { (*mybox.prev).next = mybox.next; }\n+            }\n+            if !mybox.next.is_null() {\n+                unsafe { (*mybox.next).prev = mybox.prev; }\n+            }\n+            if self.live_allocs == alloc {\n+                self.live_allocs = mybox.next;\n+            }\n+        }\n+\n+        self.memory_region.free(alloc);\n+    }\n }\n \n impl Drop for LocalHeap {\n@@ -292,6 +339,7 @@ impl Drop for MemoryRegion {\n }\n \n #[inline]\n+#[cfg(stage0)]\n pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     // FIXME: Unsafe borrow for speed. Lame.\n     let task: Option<*mut Task> = Local::try_unsafe_borrow();\n@@ -303,6 +351,19 @@ pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     }\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    // FIXME: Unsafe borrow for speed. Lame.\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task {\n+        Some(task) => {\n+            (*task).heap.alloc(drop_glue, size, align) as *u8\n+        }\n+        None => rtabort!(\"local malloc outside of task\")\n+    }\n+}\n+\n // A little compatibility function\n #[inline]\n pub unsafe fn local_free(ptr: *u8) {"}, {"sha": "a85f26720bf179df02b923d650ef2fad6f40e6a7", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -27,11 +27,19 @@ pub fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n }\n \n #[lang=\"malloc\"]\n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     ::rt::local_heap::local_malloc(td, size)\n }\n \n+#[lang=\"malloc\"]\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    ::rt::local_heap::local_malloc(drop_glue, size, align)\n+}\n+\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead."}, {"sha": "8f5f8ea806f94519712430f96fc70c36e1a443ef", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n \n use cast;\n+#[cfg(stage0)]\n use unstable::intrinsics::TyDesc;\n \n /// The representation of a Rust managed box\n+#[cfg(stage0)]\n pub struct Box<T> {\n     ref_count: uint,\n     type_desc: *TyDesc,\n@@ -20,6 +22,16 @@ pub struct Box<T> {\n     data: T\n }\n \n+/// The representation of a Rust managed box\n+#[cfg(not(stage0))]\n+pub struct Box<T> {\n+    ref_count: uint,\n+    drop_glue: fn(ptr: *mut u8),\n+    prev: *mut Box<T>,\n+    next: *mut Box<T>,\n+    data: T\n+}\n+\n /// The representation of a Rust vector\n pub struct Vec<T> {\n     fill: uint,"}]}