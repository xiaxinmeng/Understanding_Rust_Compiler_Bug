{"sha": "18d8acf41d21c19eedcb732d161ae943c438fd57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZDhhY2Y0MWQyMWMxOWVlZGNiNzMyZDE2MWFlOTQzYzQzOGZkNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-17T22:16:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-17T22:16:11Z"}, "message": "Auto merge of #45853 - nikomatsakis:chalk-simplify-hr-lub-glb, r=arielb1\n\nSimplify higher-ranked LUB/GLB\n\nThis is a better version of https://github.com/rust-lang/rust/pull/44211. It still makes higher-ranked LUB/GLB into a hard equality test, however, it does try to identify that something changed and issue a notice to the user. I wroteup https://github.com/rust-lang/rust/issues/45852 as a tracking issue for this change.\n\nCurrently, this moves straight to a hard-error, on the basis that the crater run in #44211 saw no impact. It might be good to retest -- or perhaps to try for a warning period. Trying to do the latter in a precise way would be somewhat painful, but an imprecise way might suffice -- that is, we could issue warning *whenever* a LUB/GLB operation succeeds that will later fail, even if it doesn't ultimately impact the type check. I could experiment with this.\n\n~~I am *mildly* wary about landing this independently of other code that moves to a universe-based system. In particular, I was nervous that this change would make coherence accepts new pairs of impls that will later be errors. I have the code for the universe-based approach available, I hope to open an PR and run some tests on its impact very shortly.~~ @arielb1 points out that I was being silly.\n\nr? @arielb1", "tree": {"sha": "d0ea741999f6186f0926448d7a6812a58c8cd38c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0ea741999f6186f0926448d7a6812a58c8cd38c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18d8acf41d21c19eedcb732d161ae943c438fd57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18d8acf41d21c19eedcb732d161ae943c438fd57", "html_url": "https://github.com/rust-lang/rust/commit/18d8acf41d21c19eedcb732d161ae943c438fd57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18d8acf41d21c19eedcb732d161ae943c438fd57/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aabfed5e0c84211005c1cb2ecec2206a574a5146", "url": "https://api.github.com/repos/rust-lang/rust/commits/aabfed5e0c84211005c1cb2ecec2206a574a5146", "html_url": "https://github.com/rust-lang/rust/commit/aabfed5e0c84211005c1cb2ecec2206a574a5146"}, {"sha": "9877fa048d66e7181a87de889768a67ea5ea3cd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9877fa048d66e7181a87de889768a67ea5ea3cd4", "html_url": "https://github.com/rust-lang/rust/commit/9877fa048d66e7181a87de889768a67ea5ea3cd4"}], "stats": {"total": 458, "additions": 232, "deletions": 226}, "files": [{"sha": "4f36193e197d9fdd887e769f26dce6ab5e03bc6e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -762,16 +762,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.note_error_origin(diag, &cause);\n         self.check_and_note_conflicting_crates(diag, terr, span);\n         self.tcx.note_and_explain_type_err(diag, terr, span);\n+\n+        // It reads better to have the error origin as the final\n+        // thing.\n+        self.note_error_origin(diag, &cause);\n     }\n \n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n                                          terr: &TypeError<'tcx>)\n                                          -> DiagnosticBuilder<'tcx>\n     {\n+        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\",\n+               trace,\n+               terr);\n+\n         let span = trace.cause.span;\n         let failure_str = trace.cause.as_failure_str();\n         let mut diag = match trace.cause.code {"}, {"sha": "fd14e0e40e234985629e587307fa0083faa4b86d", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -15,6 +15,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n+use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n@@ -74,7 +75,32 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_glb(a, b, self.a_is_expected)\n+        debug!(\"binders(a={:?}, b={:?})\", a, b);\n+        let was_error = self.infcx().probe(|_snapshot| {\n+            // Subtle: use a fresh combine-fields here because we recover\n+            // from Err. Doing otherwise could propagate obligations out\n+            // through our `self.obligations` field.\n+            self.infcx()\n+                .combine_fields(self.fields.trace.clone(), self.fields.param_env)\n+                .higher_ranked_glb(a, b, self.a_is_expected)\n+                .is_err()\n+        });\n+        debug!(\"binders: was_error={:?}\", was_error);\n+\n+        // When higher-ranked types are involved, computing the LUB is\n+        // very challenging, switch to invariance. This is obviously\n+        // overly conservative but works ok in practice.\n+        match self.relate_with_variance(ty::Variance::Invariant, a, b) {\n+            Ok(_) => Ok(a.clone()),\n+            Err(err) => {\n+                debug!(\"binders: error occurred, was_error={:?}\", was_error);\n+                if !was_error {\n+                    Err(TypeError::OldStyleLUB(Box::new(err)))\n+                } else {\n+                    Err(err)\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "57e237fb9137f5ef50c0c05379ac0b2c1ec152c1", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -19,6 +19,7 @@ use super::{CombinedSnapshot,\n use super::combine::CombineFields;\n use super::region_constraints::{TaintDirections};\n \n+use std::collections::BTreeMap;\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -246,7 +247,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n                                              r0: ty::Region<'tcx>)\n                                              -> ty::Region<'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n@@ -342,7 +343,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n                                              r0: ty::Region<'tcx>)\n@@ -411,7 +412,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                      a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n                                       r: ty::Region<'tcx>) -> ty::Region<'tcx>\n         {\n             for (a_br, a_r) in a_map {\n@@ -434,7 +435,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n+                           map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {"}, {"sha": "55c7eef607bbe41fc6a7d7e31f6b379d8d2d7afe", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -15,6 +15,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n+use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n@@ -74,7 +75,32 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_lub(a, b, self.a_is_expected)\n+        debug!(\"binders(a={:?}, b={:?})\", a, b);\n+        let was_error = self.infcx().probe(|_snapshot| {\n+            // Subtle: use a fresh combine-fields here because we recover\n+            // from Err. Doing otherwise could propagate obligations out\n+            // through our `self.obligations` field.\n+            self.infcx()\n+                .combine_fields(self.fields.trace.clone(), self.fields.param_env)\n+                .higher_ranked_lub(a, b, self.a_is_expected)\n+                .is_err()\n+        });\n+        debug!(\"binders: was_error={:?}\", was_error);\n+\n+        // When higher-ranked types are involved, computing the LUB is\n+        // very challenging, switch to invariance. This is obviously\n+        // overly conservative but works ok in practice.\n+        match self.relate_with_variance(ty::Variance::Invariant, a, b) {\n+            Ok(_) => Ok(a.clone()),\n+            Err(err) => {\n+                debug!(\"binders: error occurred, was_error={:?}\", was_error);\n+                if !was_error {\n+                    Err(TypeError::OldStyleLUB(Box::new(err)))\n+                } else {\n+                    Err(err)\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "4f923f0b249d6e43b8850a53bddd4dc1e4105a7d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -31,6 +31,7 @@ use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n+use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -184,7 +185,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, ty::Region<'tcx>>;\n+pub type SkolemizationMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n@@ -1384,7 +1385,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions("}, {"sha": "228ca76ed9a7ac0648d9837e1c79a6a7c07dfb75", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -54,6 +54,8 @@ pub enum TypeError<'tcx> {\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n+\n+    OldStyleLUB(Box<TypeError<'tcx>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -170,6 +172,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 report_maybe_different(f, format!(\"trait `{}`\", values.expected),\n                                        format!(\"trait `{}`\", values.found))\n             }\n+            OldStyleLUB(ref err) => {\n+                write!(f, \"{}\", err)\n+            }\n         }\n     }\n }\n@@ -293,6 +298,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 db.span_note(found.origin_span,\n                              \"...that also applies to the same type variable here\");\n             }\n+            OldStyleLUB(err) => {\n+                db.note(\"this was previously accepted by the compiler but has been phased out\");\n+                db.note(\"for more information, see https://github.com/rust-lang/rust/issues/45852\");\n+\n+                self.note_and_explain_type_err(db, &err, sp);\n+            }\n             _ => {}\n         }\n     }"}, {"sha": "bee119992230f379446c257149ce823e1b8f5f93", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -43,7 +43,8 @@ use middle::const_val::ConstVal;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use std::collections::BTreeMap;\n+use util::nodemap::FxHashSet;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n@@ -324,14 +325,14 @@ struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n-    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>\n+    map: BTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FxHashMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T : TypeFoldable<'tcx>,\n     {\n@@ -438,7 +439,7 @@ impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n             tcx,\n             current_depth: 1,\n             fld_r,\n-            map: FxHashMap()\n+            map: BTreeMap::default()\n         }\n     }\n }"}, {"sha": "e5c24b4fcf92139bfc129928e65a3c28437adcb4", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -428,7 +428,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             TyParamDefaultMismatch(ref x) => {\n                 return tcx.lift(x).map(TyParamDefaultMismatch)\n             }\n-            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n+            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n+            OldStyleLUB(ref x) => return tcx.lift(x).map(OldStyleLUB),\n         })\n     }\n }\n@@ -1174,6 +1175,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             Sorts(x) => Sorts(x.fold_with(folder)),\n             TyParamDefaultMismatch(ref x) => TyParamDefaultMismatch(x.fold_with(folder)),\n             ExistentialMismatch(x) => ExistentialMismatch(x.fold_with(folder)),\n+            OldStyleLUB(ref x) => OldStyleLUB(x.fold_with(folder)),\n         }\n     }\n \n@@ -1191,6 +1193,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n                 b.visit_with(visitor)\n             },\n             Sorts(x) => x.visit_with(visitor),\n+            OldStyleLUB(ref x) => x.visit_with(visitor),\n             TyParamDefaultMismatch(ref x) => x.visit_with(visitor),\n             ExistentialMismatch(x) => x.visit_with(visitor),\n             Mismatch |"}, {"sha": "78ce959e5c94e03e1e1f5c3e01cf39291f196c64", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -353,28 +353,10 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n-    pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_static,\n-                                  self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_empty(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_empty,\n-                                  self.tcx().types.isize)\n-    }\n-\n     pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n         self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(t1, t2)\n     }\n \n-    pub fn lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n-        self.infcx.at(&ObligationCause::dummy(), self.param_env).lub(t1, t2)\n-    }\n-\n-    pub fn glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n-        self.infcx.at(&ObligationCause::dummy(), self.param_env).glb(t1, t2)\n-    }\n-\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n@@ -399,37 +381,6 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Checks that `LUB(t1,t2) == t_lub`\n-    pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub(t1, t2) {\n-            Ok(InferOk { obligations, value: t }) => {\n-                // None of these tests should require nested obligations:\n-                assert!(obligations.is_empty());\n-\n-                self.assert_eq(t, t_lub);\n-            }\n-            Err(ref e) => panic!(\"unexpected error in LUB: {}\", e),\n-        }\n-    }\n-\n-    /// Checks that `GLB(t1,t2) == t_glb`\n-    pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n-        debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n-        match self.glb(t1, t2) {\n-            Err(e) => panic!(\"unexpected error computing LUB: {:?}\", e),\n-            Ok(InferOk { obligations, value: t }) => {\n-                // None of these tests should require nested obligations:\n-                assert!(obligations.is_empty());\n-\n-                self.assert_eq(t, t_glb);\n-\n-                // sanity check for good measure:\n-                self.assert_subtype(t, t1);\n-                self.assert_subtype(t, t2);\n-            }\n-        }\n-    }\n }\n \n #[test]\n@@ -508,169 +459,6 @@ fn sub_free_bound_false_infer() {\n     })\n }\n \n-#[test]\n-fn lub_free_bound_infer() {\n-    //! Test result of:\n-    //!\n-    //!     LUB(fn(_#1), for<'b> fn(&'b isize))\n-    //!\n-    //! This should yield `fn(&'_ isize)`. We check\n-    //! that it yields `fn(&'x isize)` for some free `'x`,\n-    //! anyhow.\n-\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n-    });\n-}\n-\n-#[test]\n-fn lub_bound_bound() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_bound_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_bound_static() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_bound_bound_inverse_order() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n-                      env.t_fn(&[t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n-                      env.t_fn(&[t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n-    })\n-}\n-\n-#[test]\n-fn lub_free_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        let t_rptr_free2 = env.t_rptr_free(2);\n-        let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_returning_scope() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_scope10 = env.t_rptr_scope(10);\n-        let t_rptr_scope11 = env.t_rptr_scope(11);\n-        let t_rptr_empty = env.t_rptr_empty();\n-        env.check_lub(env.t_fn(&[t_rptr_scope10], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_scope11], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_empty], env.tcx().types.isize));\n-    });\n-}\n-\n-#[test]\n-fn glb_free_free_with_common_scope() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        let t_rptr_free2 = env.t_rptr_free(2);\n-        let t_rptr_scope = env.t_rptr_scope(1);\n-        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_scope], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_bound() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_free_infer() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n-\n-        // compute GLB(fn(_) -> isize, for<'b> fn(&'b isize) -> isize),\n-        // which should yield for<'b> fn(&'b isize) -> isize\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_infer1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-\n-        // as a side-effect, computing GLB should unify `_` with\n-        // `&'_ isize`\n-        let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n-        match t_resolve1.sty {\n-            ty::TyRef(..) => {}\n-            _ => {\n-                panic!(\"t_resolve1={:?}\", t_resolve1);\n-            }\n-        }\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_static() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n /// Test substituting a bound region into a function, which introduces another level of binding.\n /// This requires adjusting the Debruijn index.\n #[test]"}, {"sha": "6b9bd67f9a5a4a0d7617dfe9c0b2441662e31159", "filename": "src/test/run-pass/lub-glb-with-unbound-infer-var.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Frun-pass%2Flub-glb-with-unbound-infer-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Frun-pass%2Flub-glb-with-unbound-infer-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flub-glb-with-unbound-infer-var.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for a specific corner case: when we compute the LUB of two fn\n+// types and their parameters have unbound variables. In that case, we\n+// wind up relating those two variables. This was causing an ICE in an\n+// in-progress PR.\n+\n+fn main() {\n+    let a_f: fn(_) = |_| ();\n+    let b_f: fn(_) = |_| ();\n+    let c_f = match 22 {\n+        0 => a_f,\n+        _ => b_f,\n+    };\n+    c_f(4);\n+}"}, {"sha": "85c90bb375fc7a57a25a2b6cf686aba76a7eeb73", "filename": "src/test/ui/lub-glb/old-lub-glb-hr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we give a note when the old LUB/GLB algorithm would have\n+// succeeded but the new code (which is stricter) gives an error.\n+\n+fn foo(\n+    x: fn(&u8, &u8),\n+    y: for<'a> fn(&'a u8, &'a u8),\n+) {\n+    let z = match 22 {\n+        0 => x,\n+        _ => y,\n+    };\n+}\n+\n+fn bar(\n+    x: fn(&u8, &u8),\n+    y: for<'a> fn(&'a u8, &'a u8),\n+) {\n+    let z = match 22 {\n+        // No error with an explicit cast:\n+        0 => x as for<'a> fn(&'a u8, &'a u8),\n+        _ => y,\n+    };\n+}\n+\n+fn main() {\n+}"}, {"sha": "4a310a5e6b29685b3f0230bf43fb1e41f4754e49", "filename": "src/test/ui/lub-glb/old-lub-glb-hr.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: match arms have incompatible types\n+  --> $DIR/old-lub-glb-hr.rs:18:13\n+   |\n+18 |       let z = match 22 {\n+   |  _____________^\n+19 | |         0 => x,\n+20 | |         _ => y,\n+21 | |     };\n+   | |_____^ expected bound lifetime parameter, found concrete lifetime\n+   |\n+   = note: expected type `for<'r, 's> fn(&'r u8, &'s u8)`\n+              found type `for<'a> fn(&'a u8, &'a u8)`\n+   = note: this was previously accepted by the compiler but has been phased out\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/45852\n+note: match arm with an incompatible type\n+  --> $DIR/old-lub-glb-hr.rs:20:14\n+   |\n+20 |         _ => y,\n+   |              ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7cf89b68be197534198de2d574a515e32bfb8f5d", "filename": "src/test/ui/lub-glb/old-lub-glb-object.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we give a note when the old LUB/GLB algorithm would have\n+// succeeded but the new code (which is stricter) gives an error.\n+\n+trait Foo<T, U> { }\n+\n+fn foo(\n+    x: &for<'a, 'b> Foo<&'a u8, &'b u8>,\n+    y: &for<'a> Foo<&'a u8, &'a u8>,\n+) {\n+    let z = match 22 {\n+        0 => x,\n+        _ => y,\n+    };\n+}\n+\n+fn bar(\n+    x: &for<'a, 'b> Foo<&'a u8, &'b u8>,\n+    y: &for<'a> Foo<&'a u8, &'a u8>,\n+) {\n+    // Accepted with explicit case:\n+    let z = match 22 {\n+        0 => x as &for<'a> Foo<&'a u8, &'a u8>,\n+        _ => y,\n+    };\n+}\n+\n+fn main() {\n+}"}, {"sha": "a1077f40bf561082d8936d7cb29aef27a0f142cb", "filename": "src/test/ui/lub-glb/old-lub-glb-object.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18d8acf41d21c19eedcb732d161ae943c438fd57/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr?ref=18d8acf41d21c19eedcb732d161ae943c438fd57", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: match arms have incompatible types\n+  --> $DIR/old-lub-glb-object.rs:20:13\n+   |\n+20 |       let z = match 22 {\n+   |  _____________^\n+21 | |         0 => x,\n+22 | |         _ => y,\n+23 | |     };\n+   | |_____^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |\n+   = note: expected type `&for<'a, 'b> Foo<&'a u8, &'b u8>`\n+              found type `&for<'a> Foo<&'a u8, &'a u8>`\n+   = note: this was previously accepted by the compiler but has been phased out\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/45852\n+note: match arm with an incompatible type\n+  --> $DIR/old-lub-glb-object.rs:22:14\n+   |\n+22 |         _ => y,\n+   |              ^\n+\n+error: aborting due to previous error\n+"}]}