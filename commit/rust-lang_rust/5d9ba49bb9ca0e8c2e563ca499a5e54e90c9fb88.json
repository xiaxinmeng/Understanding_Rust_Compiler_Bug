{"sha": "5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "node_id": "C_kwDOAAsO6NoAKDVkOWJhNDliYjljYTBlOGMyZTU2M2NhNDk5YTVlNTRlOTBjOWZiODg", "commit": {"author": {"name": "Yoshiki Matsuda", "email": "myskjp@gmail.com", "date": "2022-04-24T14:49:04Z"}, "committer": {"name": "Yoshiki Matsuda", "email": "myskjp@gmail.com", "date": "2022-07-02T13:51:40Z"}, "message": "move encode_and_write_metadata to rustc_metadata::fs", "tree": {"sha": "b4f690f4d2d58ca5246de185b8c2d4c0bb8f353d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4f690f4d2d58ca5246de185b8c2d4c0bb8f353d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "html_url": "https://github.com/rust-lang/rust/commit/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/comments", "author": {"login": "m-ysk", "id": 47472854, "node_id": "MDQ6VXNlcjQ3NDcyODU0", "avatar_url": "https://avatars.githubusercontent.com/u/47472854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ysk", "html_url": "https://github.com/m-ysk", "followers_url": "https://api.github.com/users/m-ysk/followers", "following_url": "https://api.github.com/users/m-ysk/following{/other_user}", "gists_url": "https://api.github.com/users/m-ysk/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ysk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ysk/subscriptions", "organizations_url": "https://api.github.com/users/m-ysk/orgs", "repos_url": "https://api.github.com/users/m-ysk/repos", "events_url": "https://api.github.com/users/m-ysk/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ysk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ysk", "id": 47472854, "node_id": "MDQ6VXNlcjQ3NDcyODU0", "avatar_url": "https://avatars.githubusercontent.com/u/47472854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ysk", "html_url": "https://github.com/m-ysk", "followers_url": "https://api.github.com/users/m-ysk/followers", "following_url": "https://api.github.com/users/m-ysk/following{/other_user}", "gists_url": "https://api.github.com/users/m-ysk/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ysk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ysk/subscriptions", "organizations_url": "https://api.github.com/users/m-ysk/orgs", "repos_url": "https://api.github.com/users/m-ysk/repos", "events_url": "https://api.github.com/users/m-ysk/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ysk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "709a78226b12025385976bdafa6d7793ec8a4a5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/709a78226b12025385976bdafa6d7793ec8a4a5b", "html_url": "https://github.com/rust-lang/rust/commit/709a78226b12025385976bdafa6d7793ec8a4a5b"}], "stats": {"total": 168, "additions": 95, "deletions": 73}, "files": [{"sha": "dd9e4bd9a5f175144516409f6799ad50c6350469", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "patch": "@@ -3982,7 +3982,6 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"rustc_typeck\",\n  \"smallvec\",\n- \"tempfile\",\n  \"tracing\",\n  \"winapi\",\n ]\n@@ -4092,6 +4091,7 @@ dependencies = [\n  \"rustc_type_ir\",\n  \"smallvec\",\n  \"snap\",\n+ \"tempfile\",\n  \"tracing\",\n ]\n "}, {"sha": "1ecbc876c8d8a121f0e8c149c571ee57107e39d5", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "patch": "@@ -46,7 +46,6 @@ rustc_query_impl = { path = \"../rustc_query_impl\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n-tempfile = \"3.2\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\""}, {"sha": "2504030783815749697adf956fceb82ead2adbcf", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 4, "deletions": 70, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "patch": "@@ -8,16 +8,13 @@ use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n-use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n-use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n+use rustc_hir::def_id::StableCrateId;\n use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n use rustc_lint::{EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n-use rustc_metadata::fs::emit_metadata;\n-use rustc_metadata::{encode_metadata, EncodedMetadata};\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n@@ -30,14 +27,13 @@ use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn};\n-use rustc_session::output::{filename_for_input, filename_for_metadata};\n+use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::FileName;\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n-use tempfile::Builder as TempFileBuilder;\n use tracing::{info, warn};\n \n use std::any::Any;\n@@ -1030,69 +1026,6 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n     Ok(())\n }\n \n-fn encode_and_write_metadata(\n-    tcx: TyCtxt<'_>,\n-    outputs: &OutputFilenames,\n-) -> (EncodedMetadata, bool) {\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed,\n-    }\n-\n-    let metadata_kind = tcx\n-        .sess\n-        .crate_types()\n-        .iter()\n-        .map(|ty| match *ty {\n-            CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,\n-\n-            CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n-        })\n-        .max()\n-        .unwrap_or(MetadataKind::None);\n-\n-    let metadata = match metadata_kind {\n-        MetadataKind::None => EncodedMetadata::new(),\n-        MetadataKind::Uncompressed | MetadataKind::Compressed => encode_metadata(tcx),\n-    };\n-\n-    let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n-\n-    let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n-    if need_metadata_file {\n-        let crate_name = tcx.crate_name(LOCAL_CRATE);\n-        let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with an `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n-        let metadata_filename = emit_metadata(tcx.sess, metadata.raw_data(), &metadata_tmpdir);\n-        if let Err(e) = util::non_durable_rename(&metadata_filename, &out_filename) {\n-            tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n-        }\n-        if tcx.sess.opts.json_artifact_notifications {\n-            tcx.sess\n-                .parse_sess\n-                .span_diagnostic\n-                .emit_artifact_notification(&out_filename, \"metadata\");\n-        }\n-    }\n-\n-    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n-\n-    (metadata, need_metadata_module)\n-}\n-\n /// Runs the codegen backend, after which the AST and analysis can\n /// be discarded.\n pub fn start_codegen<'tcx>(\n@@ -1102,7 +1035,8 @@ pub fn start_codegen<'tcx>(\n ) -> Box<dyn Any> {\n     info!(\"Pre-codegen\\n{:?}\", tcx.debug_stats());\n \n-    let (metadata, need_metadata_module) = encode_and_write_metadata(tcx, outputs);\n+    let (metadata, need_metadata_module) =\n+        rustc_metadata::fs::encode_and_write_metadata(tcx, outputs);\n \n     let codegen = tcx.sess.time(\"codegen_crate\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)"}, {"sha": "2c5db9d8b2765eab5ad0f4628ebe1e872692a656", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "patch": "@@ -12,6 +12,7 @@ odht = { version = \"0.3.1\", features = [\"nightly\"] }\n snap = \"1\"\n tracing = \"0.1\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+tempfile = \"3.2\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "b66f37d5d611ddf639bba25cfd93369ecaeb256a", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "patch": "@@ -1,8 +1,15 @@\n+use crate::{encode_metadata, EncodedMetadata};\n+\n use rustc_data_structures::temp_dir::MaybeTempDir;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::{CrateType, OutputFilenames, OutputType};\n+use rustc_session::output::filename_for_metadata;\n use rustc_session::Session;\n+use tempfile::Builder as TempFileBuilder;\n \n use std::fs;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n // FIXME(eddyb) maybe include the crate name in this?\n pub const METADATA_FILENAME: &str = \"lib.rmeta\";\n@@ -22,3 +29,84 @@ pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) ->\n \n     out_filename\n }\n+\n+pub fn encode_and_write_metadata(\n+    tcx: TyCtxt<'_>,\n+    outputs: &OutputFilenames,\n+) -> (EncodedMetadata, bool) {\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    enum MetadataKind {\n+        None,\n+        Uncompressed,\n+        Compressed,\n+    }\n+\n+    let metadata_kind = tcx\n+        .sess\n+        .crate_types()\n+        .iter()\n+        .map(|ty| match *ty {\n+            CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,\n+\n+            CrateType::Rlib => MetadataKind::Uncompressed,\n+\n+            CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n+        })\n+        .max()\n+        .unwrap_or(MetadataKind::None);\n+\n+    let metadata = match metadata_kind {\n+        MetadataKind::None => EncodedMetadata::new(),\n+        MetadataKind::Uncompressed | MetadataKind::Compressed => encode_metadata(tcx),\n+    };\n+\n+    let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n+\n+    let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n+    if need_metadata_file {\n+        let crate_name = tcx.crate_name(LOCAL_CRATE);\n+        let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n+        // To avoid races with another rustc process scanning the output directory,\n+        // we need to write the file somewhere else and atomically move it to its\n+        // final destination, with an `fs::rename` call. In order for the rename to\n+        // always succeed, the temporary file needs to be on the same filesystem,\n+        // which is why we create it inside the output directory specifically.\n+        let metadata_tmpdir = TempFileBuilder::new()\n+            .prefix(\"rmeta\")\n+            .tempdir_in(out_filename.parent().unwrap())\n+            .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+        let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n+        let metadata_filename = emit_metadata(tcx.sess, metadata.raw_data(), &metadata_tmpdir);\n+        if let Err(e) = non_durable_rename(&metadata_filename, &out_filename) {\n+            tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+        }\n+        if tcx.sess.opts.json_artifact_notifications {\n+            tcx.sess\n+                .parse_sess\n+                .span_diagnostic\n+                .emit_artifact_notification(&out_filename, \"metadata\");\n+        }\n+    }\n+\n+    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n+\n+    (metadata, need_metadata_module)\n+}\n+\n+#[cfg(not(target_os = \"linux\"))]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    std::fs::rename(src, dst)\n+}\n+\n+/// This function attempts to bypass the auto_da_alloc heuristic implemented by some filesystems\n+/// such as btrfs and ext4. When renaming over a file that already exists then they will \"helpfully\"\n+/// write back the source file before committing the rename in case a developer forgot some of\n+/// the fsyncs in the open/write/fsync(file)/rename/fsync(dir) dance for atomic file updates.\n+///\n+/// To avoid triggering this heuristic we delete the destination first, if it exists.\n+/// The cost of an extra syscall is much lower than getting descheduled for the sync IO.\n+#[cfg(target_os = \"linux\")]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    let _ = std::fs::remove_file(dst);\n+    std::fs::rename(src, dst)\n+}"}]}