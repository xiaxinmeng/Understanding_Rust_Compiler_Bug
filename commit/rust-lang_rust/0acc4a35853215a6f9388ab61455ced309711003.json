{"sha": "0acc4a35853215a6f9388ab61455ced309711003", "node_id": "C_kwDOAAsO6NoAKDBhY2M0YTM1ODUzMjE1YTZmOTM4OGFiNjE0NTVjZWQzMDk3MTEwMDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T03:15:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T03:15:28Z"}, "message": "Auto merge of #96652 - notriddle:notriddle/self, r=GuillaumeGomez\n\nrustdoc: include impl generics / self in search index\n\nFixes #92205", "tree": {"sha": "e2c2230f1a825fdcdf7851da329715fd7e0b00fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2c2230f1a825fdcdf7851da329715fd7e0b00fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0acc4a35853215a6f9388ab61455ced309711003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0acc4a35853215a6f9388ab61455ced309711003", "html_url": "https://github.com/rust-lang/rust/commit/0acc4a35853215a6f9388ab61455ced309711003", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0acc4a35853215a6f9388ab61455ced309711003/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84288ed6d5307ed44a0f78e2f1ee55fbadf4e978", "url": "https://api.github.com/repos/rust-lang/rust/commits/84288ed6d5307ed44a0f78e2f1ee55fbadf4e978", "html_url": "https://github.com/rust-lang/rust/commit/84288ed6d5307ed44a0f78e2f1ee55fbadf4e978"}, {"sha": "718269aab8adf85c9ceacf91421ec135d97a3bfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/718269aab8adf85c9ceacf91421ec135d97a3bfa", "html_url": "https://github.com/rust-lang/rust/commit/718269aab8adf85c9ceacf91421ec135d97a3bfa"}], "stats": {"total": 313, "additions": 251, "deletions": 62}, "files": [{"sha": "1e434458dcef55627a909d4dfe69bf7358ddb755", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0acc4a35853215a6f9388ab61455ced309711003/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0acc4a35853215a6f9388ab61455ced309711003/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0acc4a35853215a6f9388ab61455ced309711003", "patch": "@@ -1410,6 +1410,12 @@ pub(crate) struct Generics {\n     pub(crate) where_predicates: Vec<WherePredicate>,\n }\n \n+impl Generics {\n+    pub(crate) fn is_empty(&self) -> bool {\n+        self.params.is_empty() && self.where_predicates.is_empty()\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub(crate) struct Function {\n     pub(crate) decl: FnDecl,"}, {"sha": "d7276a427c468a49cebd2c22a74bd440cf13d0cb", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 98, "deletions": 46, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/0acc4a35853215a6f9388ab61455ced309711003/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0acc4a35853215a6f9388ab61455ced309711003/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=0acc4a35853215a6f9388ab61455ced309711003", "patch": "@@ -94,8 +94,7 @@ pub(crate) struct Cache {\n \n     // Private fields only used when initially crawling a crate to build a cache\n     stack: Vec<Symbol>,\n-    parent_stack: Vec<DefId>,\n-    parent_is_trait_impl: bool,\n+    parent_stack: Vec<ParentStackItem>,\n     stripped_mod: bool,\n \n     pub(crate) search_index: Vec<IndexItem>,\n@@ -105,7 +104,7 @@ pub(crate) struct Cache {\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    pub(crate) orphan_impl_items: Vec<(DefId, clean::Item)>,\n+    pub(crate) orphan_impl_items: Vec<OrphanImplItem>,\n \n     // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n     // even though the trait itself is not exported. This can happen if a trait\n@@ -261,7 +260,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::AssocTypeItem(..)\n-                    if self.cache.parent_is_trait_impl =>\n+                    if self\n+                        .cache\n+                        .parent_stack\n+                        .last()\n+                        .map_or(false, |parent| parent.is_trait_impl()) =>\n                 {\n                     // skip associated items in trait impls\n                     ((None, None), false)\n@@ -272,7 +275,14 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.cache.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(\n+                            self.cache\n+                                .parent_stack\n+                                .last()\n+                                .expect(\"parent_stack is empty\")\n+                                .item_id()\n+                                .expect_def_id(),\n+                        ),\n                         Some(&self.cache.stack[..self.cache.stack.len() - 1]),\n                     ),\n                     false,\n@@ -282,16 +292,19 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         ((None, None), false)\n                     } else {\n                         let last = self.cache.parent_stack.last().expect(\"parent_stack is empty 2\");\n-                        let did = *last;\n-                        let path = match self.cache.paths.get(&did) {\n+                        let did = match &*last {\n+                            ParentStackItem::Impl { for_, .. } => for_.def_id(&self.cache),\n+                            ParentStackItem::Type(item_id) => item_id.as_def_id(),\n+                        };\n+                        let path = match did.and_then(|did| self.cache.paths.get(&did)) {\n                             // The current stack not necessarily has correlation\n                             // for where the type was defined. On the other\n                             // hand, `paths` always has the right\n                             // information if present.\n                             Some(&(ref fqp, _)) => Some(&fqp[..fqp.len() - 1]),\n                             None => None,\n                         };\n-                        ((Some(*last), path), true)\n+                        ((did, path), true)\n                     }\n                 }\n                 _ => ((None, Some(&*self.cache.stack)), false),\n@@ -315,15 +328,25 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc,\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_function_type_for_search(&item, self.tcx, self.cache),\n+                            search_type: get_function_type_for_search(\n+                                &item,\n+                                self.tcx,\n+                                clean_impl_generics(self.cache.parent_stack.last()).as_ref(),\n+                                self.cache,\n+                            ),\n                             aliases: item.attrs.get_doc_aliases(),\n                         });\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n                     // We have a parent, but we don't know where they're\n                     // defined yet. Wait for later to index this item.\n-                    self.cache.orphan_impl_items.push((parent, item.clone()));\n+                    let impl_generics = clean_impl_generics(self.cache.parent_stack.last());\n+                    self.cache.orphan_impl_items.push(OrphanImplItem {\n+                        parent,\n+                        item: item.clone(),\n+                        impl_generics,\n+                    });\n                 }\n                 _ => {}\n             }\n@@ -398,51 +421,23 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             }\n         }\n \n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.cache.parent_is_trait_impl;\n-        let parent_pushed = match *item.kind {\n+        // Maintain the parent stack.\n+        let (item, parent_pushed) = match *item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n-            | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.item_id.expect_def_id());\n-                self.cache.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.cache.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::Type::Path { ref path } => {\n-                        self.cache.parent_stack.push(path.def_id());\n-                        true\n-                    }\n-                    clean::DynTrait(ref bounds, _)\n-                    | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n-                        self.cache.parent_stack.push(bounds[0].trait_.def_id());\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t\n-                            .primitive_type()\n-                            .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.cache.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n+            | clean::VariantItem(..)\n+            | clean::ImplItem(..) => {\n+                self.cache.parent_stack.push(ParentStackItem::new(&item));\n+                (self.fold_item_recur(item), true)\n             }\n-            _ => false,\n+            _ => (self.fold_item_recur(item), false),\n         };\n \n         // Once we've recursively found all the generics, hoard off all the\n         // implementations elsewhere.\n-        let item = self.fold_item_recur(item);\n         let ret = if let clean::Item { kind: box clean::ImplItem(ref i), .. } = item {\n             // Figure out the id of this impl. This may map to a\n             // primitive rather than always to a struct/enum.\n@@ -511,7 +506,64 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             self.cache.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n         self.cache.stripped_mod = orig_stripped_mod;\n-        self.cache.parent_is_trait_impl = orig_parent_is_trait_impl;\n         ret\n     }\n }\n+\n+pub(crate) struct OrphanImplItem {\n+    pub(crate) parent: DefId,\n+    pub(crate) item: clean::Item,\n+    pub(crate) impl_generics: Option<(clean::Type, clean::Generics)>,\n+}\n+\n+/// Information about trait and type parents is tracked while traversing the item tree to build\n+/// the cache.\n+///\n+/// We don't just store `Item` in there, because `Item` contains the list of children being\n+/// traversed and it would be wasteful to clone all that. We also need the item id, so just\n+/// storing `ItemKind` won't work, either.\n+enum ParentStackItem {\n+    Impl {\n+        for_: clean::Type,\n+        trait_: Option<clean::Path>,\n+        generics: clean::Generics,\n+        kind: clean::ImplKind,\n+        item_id: ItemId,\n+    },\n+    Type(ItemId),\n+}\n+\n+impl ParentStackItem {\n+    fn new(item: &clean::Item) -> Self {\n+        match &*item.kind {\n+            clean::ItemKind::ImplItem(clean::Impl { for_, trait_, generics, kind, .. }) => {\n+                ParentStackItem::Impl {\n+                    for_: for_.clone(),\n+                    trait_: trait_.clone(),\n+                    generics: generics.clone(),\n+                    kind: kind.clone(),\n+                    item_id: item.item_id,\n+                }\n+            }\n+            _ => ParentStackItem::Type(item.item_id),\n+        }\n+    }\n+    fn is_trait_impl(&self) -> bool {\n+        matches!(self, ParentStackItem::Impl { trait_: Some(..), .. })\n+    }\n+    fn item_id(&self) -> ItemId {\n+        match self {\n+            ParentStackItem::Impl { item_id, .. } => *item_id,\n+            ParentStackItem::Type(item_id) => *item_id,\n+        }\n+    }\n+}\n+\n+fn clean_impl_generics(item: Option<&ParentStackItem>) -> Option<(clean::Type, clean::Generics)> {\n+    if let Some(ParentStackItem::Impl { for_, generics, kind: clean::ImplKind::Normal, .. }) = item\n+    {\n+        Some((for_.clone(), generics.clone()))\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "25c70f0808c6d1e687b41f4c45df7a6237027a71", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0acc4a35853215a6f9388ab61455ced309711003/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0acc4a35853215a6f9388ab61455ced309711003/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=0acc4a35853215a6f9388ab61455ced309711003", "patch": "@@ -8,7 +8,7 @@ use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n use crate::clean::types::{FnRetTy, Function, GenericBound, Generics, Type, WherePredicate};\n-use crate::formats::cache::Cache;\n+use crate::formats::cache::{Cache, OrphanImplItem};\n use crate::formats::item_type::ItemType;\n use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n@@ -25,8 +25,8 @@ pub(crate) fn build_index<'tcx>(\n \n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n-    for &(did, ref item) in &cache.orphan_impl_items {\n-        if let Some(&(ref fqp, _)) = cache.paths.get(&did) {\n+    for &OrphanImplItem { parent, ref item, ref impl_generics } in &cache.orphan_impl_items {\n+        if let Some(&(ref fqp, _)) = cache.paths.get(&parent) {\n             let desc = item\n                 .doc_value()\n                 .map_or_else(String::new, |s| short_markdown_summary(&s, &item.link_names(cache)));\n@@ -35,9 +35,9 @@ pub(crate) fn build_index<'tcx>(\n                 name: item.name.unwrap().to_string(),\n                 path: join_with_double_colon(&fqp[..fqp.len() - 1]),\n                 desc,\n-                parent: Some(did),\n+                parent: Some(parent),\n                 parent_idx: None,\n-                search_type: get_function_type_for_search(item, tcx, cache),\n+                search_type: get_function_type_for_search(item, tcx, impl_generics.as_ref(), cache),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -192,12 +192,13 @@ pub(crate) fn build_index<'tcx>(\n pub(crate) fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n+    impl_generics: Option<&(clean::Type, clean::Generics)>,\n     cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n     let (mut inputs, mut output) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx, cache),\n-        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx, cache),\n-        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx, cache),\n+        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx, impl_generics, cache),\n+        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx, impl_generics, cache),\n+        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx, impl_generics, cache),\n         _ => return None,\n     };\n \n@@ -247,9 +248,10 @@ fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n /// Important note: It goes through generics recursively. So if you have\n /// `T: Option<Result<(), ()>>`, it'll go into `Option` and then into `Result`.\n #[instrument(level = \"trace\", skip(tcx, res, cache))]\n-fn add_generics_and_bounds_as_types<'tcx>(\n+fn add_generics_and_bounds_as_types<'tcx, 'a>(\n+    self_: Option<&'a Type>,\n     generics: &Generics,\n-    arg: &Type,\n+    arg: &'a Type,\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n     res: &mut Vec<TypeWithKind>,\n@@ -334,6 +336,17 @@ fn add_generics_and_bounds_as_types<'tcx>(\n         return;\n     }\n \n+    // First, check if it's \"Self\".\n+    let arg = if let Some(self_) = self_ {\n+        match &*arg {\n+            Type::BorrowedRef { type_, .. } if type_.is_self_type() => self_,\n+            type_ if type_.is_self_type() => self_,\n+            arg => arg,\n+        }\n+    } else {\n+        arg\n+    };\n+\n     // If this argument is a type parameter and not a trait bound or a type, we need to look\n     // for its bounds.\n     if let Type::Generic(arg_s) = *arg {\n@@ -350,6 +363,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n                         match &param_def.kind {\n                             clean::GenericParamDefKind::Type { default: Some(ty), .. } => {\n                                 add_generics_and_bounds_as_types(\n+                                    self_,\n                                     generics,\n                                     ty,\n                                     tcx,\n@@ -372,6 +386,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n                 if let Some(path) = bound.get_trait_path() {\n                     let ty = Type::Path { path };\n                     add_generics_and_bounds_as_types(\n+                        self_,\n                         generics,\n                         &ty,\n                         tcx,\n@@ -393,6 +408,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n         if let Some(arg_generics) = arg.generics() {\n             for gen in arg_generics.iter() {\n                 add_generics_and_bounds_as_types(\n+                    self_,\n                     generics,\n                     gen,\n                     tcx,\n@@ -413,18 +429,33 @@ fn add_generics_and_bounds_as_types<'tcx>(\n fn get_fn_inputs_and_outputs<'tcx>(\n     func: &Function,\n     tcx: TyCtxt<'tcx>,\n+    impl_generics: Option<&(clean::Type, clean::Generics)>,\n     cache: &Cache,\n ) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n     let decl = &func.decl;\n-    let generics = &func.generics;\n+\n+    let combined_generics;\n+    let (self_, generics) = if let Some(&(ref impl_self, ref impl_generics)) = impl_generics {\n+        match (impl_generics.is_empty(), func.generics.is_empty()) {\n+            (true, _) => (Some(impl_self), &func.generics),\n+            (_, true) => (Some(impl_self), impl_generics),\n+            (false, false) => {\n+                let mut params = func.generics.params.clone();\n+                params.extend(impl_generics.params.clone());\n+                let mut where_predicates = func.generics.where_predicates.clone();\n+                where_predicates.extend(impl_generics.where_predicates.clone());\n+                combined_generics = clean::Generics { params, where_predicates };\n+                (Some(impl_self), &combined_generics)\n+            }\n+        }\n+    } else {\n+        (None, &func.generics)\n+    };\n \n     let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n-        if arg.type_.is_self_type() {\n-            continue;\n-        }\n         let mut args = Vec::new();\n-        add_generics_and_bounds_as_types(generics, &arg.type_, tcx, 0, &mut args, cache);\n+        add_generics_and_bounds_as_types(self_, generics, &arg.type_, tcx, 0, &mut args, cache);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n@@ -437,7 +468,15 @@ fn get_fn_inputs_and_outputs<'tcx>(\n     let mut ret_types = Vec::new();\n     match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            add_generics_and_bounds_as_types(generics, return_type, tcx, 0, &mut ret_types, cache);\n+            add_generics_and_bounds_as_types(\n+                self_,\n+                generics,\n+                return_type,\n+                tcx,\n+                0,\n+                &mut ret_types,\n+                cache,\n+            );\n             if ret_types.is_empty() {\n                 if let Some(kind) = return_type.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n                     ret_types.push(TypeWithKind::from((get_index_type(return_type, vec![]), kind)));"}, {"sha": "bb6e0041db5f23b38e6ce7d2998dc54617a5b05a", "filename": "src/test/rustdoc-js/generics-impl.js", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0acc4a35853215a6f9388ab61455ced309711003/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.js", "raw_url": "https://github.com/rust-lang/rust/raw/0acc4a35853215a6f9388ab61455ced309711003/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.js?ref=0acc4a35853215a6f9388ab61455ced309711003", "patch": "@@ -0,0 +1,57 @@\n+// exact-check\n+\n+const QUERY = [\n+    'Aaaaaaa -> u32',\n+    'Aaaaaaa -> bool',\n+    'Aaaaaaa -> usize',\n+    'Read -> u64',\n+    'bool -> u64',\n+    'Ddddddd -> u64',\n+    '-> Ddddddd'\n+];\n+\n+const EXPECTED = [\n+    {\n+        // Aaaaaaa -> u32\n+        'others': [\n+            { 'path': 'generics_impl::Aaaaaaa', 'name': 'bbbbbbb' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> bool\n+        'others': [\n+            { 'path': 'generics_impl::Aaaaaaa', 'name': 'ccccccc' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> usize\n+        'others': [\n+            { 'path': 'generics_impl::Aaaaaaa', 'name': 'read' },\n+        ],\n+    },\n+    {\n+        // Read -> u64\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'eeeeeee' },\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'ggggggg' },\n+        ],\n+    },\n+    {\n+        // bool -> u64\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'fffffff' },\n+        ],\n+    },\n+    {\n+        // Ddddddd -> u64\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'ggggggg' },\n+        ],\n+    },\n+    {\n+        // -> Ddddddd\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'hhhhhhh' },\n+        ],\n+    },\n+];"}, {"sha": "696218021d5afa9d26e4fa3a488c3d672a6c1cdc", "filename": "src/test/rustdoc-js/generics-impl.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0acc4a35853215a6f9388ab61455ced309711003/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0acc4a35853215a6f9388ab61455ced309711003/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.rs?ref=0acc4a35853215a6f9388ab61455ced309711003", "patch": "@@ -0,0 +1,35 @@\n+use std::io::{Result as IoResult, Read};\n+\n+pub struct Aaaaaaa;\n+\n+impl Aaaaaaa {\n+    pub fn bbbbbbb(self) -> u32 {\n+        1\n+    }\n+    pub fn ccccccc(&self) -> bool {\n+        true\n+    }\n+}\n+\n+impl Read for Aaaaaaa {\n+    fn read(&mut self, out: &mut [u8]) -> IoResult<usize> {\n+        Ok(out.len())\n+    }\n+}\n+\n+pub struct Ddddddd<T>(T);\n+\n+impl<T: Read> Ddddddd<T> {\n+    pub fn eeeeeee(_: T) -> u64 {\n+        1\n+    }\n+    pub fn fffffff(_: bool) -> u64 {\n+        1\n+    }\n+    pub fn ggggggg(self) -> u64 {\n+        1\n+    }\n+    pub fn hhhhhhh() -> Self where T: Default {\n+        Ddddddd(T::default())\n+    }\n+}"}]}