{"sha": "8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2", "node_id": "C_kwDOAAsO6NoAKDhkYTlhODIzY2JhZGZiYjkzYjhhOWU1MTlmZjNiNWUwMzk4OWRjYjI", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2021-12-27T23:13:03Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2021-12-28T05:39:21Z"}, "message": "cache test item names", "tree": {"sha": "abc81272f9b5f16a73c9069147110bb842a74bf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abc81272f9b5f16a73c9069147110bb842a74bf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2", "html_url": "https://github.com/rust-lang/rust/commit/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb7b6beca30b46de26933d19b27324966aac0878", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb7b6beca30b46de26933d19b27324966aac0878", "html_url": "https://github.com/rust-lang/rust/commit/bb7b6beca30b46de26933d19b27324966aac0878"}], "stats": {"total": 70, "additions": 42, "deletions": 28}, "files": [{"sha": "266bf19bd6f017a858bd8a523fe7c5e1ade07220", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2", "patch": "@@ -1,8 +1,9 @@\n #![feature(box_patterns)]\n+#![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n #![feature(let_else)]\n+#![feature(once_cell)]\n #![feature(rustc_private)]\n-#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]\n@@ -60,9 +61,12 @@ pub use self::hir_utils::{both, count_eq, eq_expr_value, over, SpanlessEq, Spanl\n \n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n+use std::lazy::SyncOnceCell;\n+use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, LitKind};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -87,6 +91,7 @@ use rustc_middle::ty::binding::BindingMode;\n use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n@@ -2132,26 +2137,25 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     false\n }\n \n-struct VisitConstTestStruct<'tcx> {\n+struct TestItemNamesVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     names: Vec<Symbol>,\n-    found: bool,\n }\n-impl<'hir> ItemLikeVisitor<'hir> for VisitConstTestStruct<'hir> {\n+\n+impl<'hir> ItemLikeVisitor<'hir> for TestItemNamesVisitor<'hir> {\n     fn visit_item(&mut self, item: &Item<'_>) {\n         if let ItemKind::Const(ty, _body) = item.kind {\n             if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n                 // We could also check for the type name `test::TestDescAndFn`\n-                // and the `#[rustc_test_marker]` attribute?\n                 if let Res::Def(DefKind::Struct, _) = path.res {\n                     let has_test_marker = self\n                         .tcx\n                         .hir()\n                         .attrs(item.hir_id())\n                         .iter()\n                         .any(|a| a.has_name(sym::rustc_test_marker));\n-                    if has_test_marker && self.names.contains(&item.ident.name) {\n-                        self.found = true;\n+                    if has_test_marker {\n+                        self.names.push(item.ident.name);\n                     }\n                 }\n             }\n@@ -2162,32 +2166,42 @@ impl<'hir> ItemLikeVisitor<'hir> for VisitConstTestStruct<'hir> {\n     fn visit_foreign_item(&mut self, _: &ForeignItem<'_>) {}\n }\n \n+static TEST_ITEM_NAMES_CACHE: SyncOnceCell<Mutex<FxHashMap<LocalDefId, Vec<Symbol>>>> = SyncOnceCell::new();\n+\n+fn with_test_item_names(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(&[Symbol]) -> bool) -> bool {\n+    let cache = TEST_ITEM_NAMES_CACHE.get_or_init(|| Mutex::new(FxHashMap::default()));\n+    let mut map: MutexGuard<'_, FxHashMap<LocalDefId, Vec<Symbol>>> = cache.lock().unwrap();\n+    match map.entry(module) {\n+        Entry::Occupied(entry) => f(entry.get()),\n+        Entry::Vacant(entry) => {\n+            let mut visitor = TestItemNamesVisitor { tcx, names: Vec::new() };\n+            tcx.hir().visit_item_likes_in_module(module, &mut visitor);\n+            visitor.names.sort_unstable();\n+            f(&*entry.insert(visitor.names))\n+        },\n+    }\n+}\n+\n /// Checks if the function containing the given `HirId` is a `#[test]` function\n ///\n /// Note: If you use this function, please add a `#[test]` case in `tests/ui_test`.\n pub fn is_in_test_function(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n-    let names: Vec<_> = tcx\n-        .hir()\n-        .parent_iter(id)\n-        // Since you can nest functions we need to collect all until we leave\n-        // function scope\n-        .filter_map(|(_id, node)| {\n-            if let Node::Item(item) = node {\n-                if let ItemKind::Fn(_, _, _) = item.kind {\n-                    return Some(item.ident.name);\n+    with_test_item_names(tcx, tcx.parent_module(id), |names| {\n+        tcx.hir()\n+            .parent_iter(id)\n+            // Since you can nest functions we need to collect all until we leave\n+            // function scope\n+            .any(|(_id, node)| {\n+                if let Node::Item(item) = node {\n+                    if let ItemKind::Fn(_, _, _) = item.kind {\n+                        // Note that we have sorted the item names in the visitor,\n+                        // so the binary_search gets the same as `contains`, but faster.\n+                        return names.binary_search(&item.ident.name).is_ok();\n+                    }\n                 }\n-            }\n-            None\n-        })\n-        .collect();\n-    let parent_mod = tcx.parent_module(id);\n-    let mut vis = VisitConstTestStruct {\n-        tcx,\n-        names,\n-        found: false,\n-    };\n-    tcx.hir().visit_item_likes_in_module(parent_mod, &mut vis);\n-    vis.found\n+                false\n+            })\n+    })\n }\n \n /// Checks whether item either has `test` attribute applied, or"}]}