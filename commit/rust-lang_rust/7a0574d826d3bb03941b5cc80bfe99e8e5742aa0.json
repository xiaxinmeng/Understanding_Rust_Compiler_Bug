{"sha": "7a0574d826d3bb03941b5cc80bfe99e8e5742aa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMDU3NGQ4MjZkM2JiMDM5NDFiNWNjODBiZmU5OWU4ZTU3NDJhYTA=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-05-31T17:26:08Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-07-08T21:55:58Z"}, "message": "PR Feedback: Don't put SSA-only types in `CValue`s", "tree": {"sha": "c2a13ea17eb67c4605272e0e092586ddfc017c13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2a13ea17eb67c4605272e0e092586ddfc017c13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0", "html_url": "https://github.com/rust-lang/rust/commit/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea8d9aefdaa92526018c0de76090fb35c545faa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea8d9aefdaa92526018c0de76090fb35c545faa9", "html_url": "https://github.com/rust-lang/rust/commit/ea8d9aefdaa92526018c0de76090fb35c545faa9"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "31f7e0d4e37b1aae622523e1a44f3089c084570f", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=7a0574d826d3bb03941b5cc80bfe99e8e5742aa0", "patch": "@@ -1132,14 +1132,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let is_eq_value =\n                 if size == Size::ZERO {\n                     // No bytes means they're trivially equal\n-                    fx.bcx.ins().bconst(types::B1, true)\n+                    fx.bcx.ins().iconst(types::I8, 1)\n                 } else if let Some(clty) = type_by_size(size) {\n                     // Can't use `trusted` for these loads; they could be unaligned.\n                     let mut flags = MemFlags::new();\n                     flags.set_notrap();\n                     let lhs_val = fx.bcx.ins().load(clty, flags, lhs_ref, 0);\n                     let rhs_val = fx.bcx.ins().load(clty, flags, rhs_ref, 0);\n-                    fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val)\n+                    let eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val);\n+                    fx.bcx.ins().bint(types::I8, eq)\n                 } else {\n                     // Just call `memcmp` (like slices do in core) when the\n                     // size is too large or it's not a power-of-two.\n@@ -1150,7 +1151,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                     let returns = vec![AbiParam::new(types::I32)];\n                     let args = &[lhs_ref, rhs_ref, bytes_val];\n                     let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];\n-                    fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0)\n+                    let eq = fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0);\n+                    fx.bcx.ins().bint(types::I8, eq)\n                 };\n             ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n         };"}, {"sha": "ae8ccc626b47089e09a8f75672c9893659ef21fa", "filename": "src/value_and_place.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0574d826d3bb03941b5cc80bfe99e8e5742aa0/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=7a0574d826d3bb03941b5cc80bfe99e8e5742aa0", "patch": "@@ -437,12 +437,6 @@ impl<'tcx> CPlace<'tcx> {\n                 | (types::F32, types::I32)\n                 | (types::I64, types::F64)\n                 | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n-\n-                // Widen an abstract SSA boolean to something that can be stored in memory\n-                (types::B1, types::I8 | types::I16 | types::I32 | types::I64 | types::I128) => {\n-                    fx.bcx.ins().bint(dst_ty, data)\n-                }\n-\n                 _ if src_ty.is_vector() && dst_ty.is_vector() => {\n                     fx.bcx.ins().raw_bitcast(dst_ty, data)\n                 }\n@@ -459,6 +453,10 @@ impl<'tcx> CPlace<'tcx> {\n                     ptr.store(fx, data, MemFlags::trusted());\n                     ptr.load(fx, dst_ty, MemFlags::trusted())\n                 }\n+\n+                // `CValue`s should never contain SSA-only types, so if you ended\n+                // up here having seen an error like `B1 -> I8`, then before\n+                // calling `write_cvalue` you need to add a `bint` instruction.\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n             //fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));"}]}