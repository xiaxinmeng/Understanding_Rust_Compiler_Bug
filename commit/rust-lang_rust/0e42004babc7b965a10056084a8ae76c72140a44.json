{"sha": "0e42004babc7b965a10056084a8ae76c72140a44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNDIwMDRiYWJjN2I5NjVhMTAwNTYwODRhOGFlNzZjNzIxNDBhNDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-17T03:17:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-17T03:18:18Z"}, "message": "introduce an owned kind for data that contains no borrowed ptrs", "tree": {"sha": "dd0484f1854d0c059b61516ee42812f16751fd94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd0484f1854d0c059b61516ee42812f16751fd94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e42004babc7b965a10056084a8ae76c72140a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e42004babc7b965a10056084a8ae76c72140a44", "html_url": "https://github.com/rust-lang/rust/commit/0e42004babc7b965a10056084a8ae76c72140a44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e42004babc7b965a10056084a8ae76c72140a44/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d809336d0f5f4efa11336878736aeefe1fbae895", "url": "https://api.github.com/repos/rust-lang/rust/commits/d809336d0f5f4efa11336878736aeefe1fbae895", "html_url": "https://github.com/rust-lang/rust/commit/d809336d0f5f4efa11336878736aeefe1fbae895"}], "stats": {"total": 387, "additions": 245, "deletions": 142}, "files": [{"sha": "0e70a58b33b1e4650ca8d295aad6d1d72070e877", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -62,6 +62,7 @@ enum ty_param_bound {\n     bound_copy,\n     bound_send,\n     bound_const,\n+    bound_owned,\n     bound_trait(@ty),\n }\n "}, {"sha": "53bb9510acdeac1c19603e448a9be417755d85f7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -135,7 +135,7 @@ fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n \n fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n     alt tpb {\n-      bound_copy | bound_send | bound_const { tpb }\n+      bound_copy | bound_send | bound_const | bound_owned { tpb }\n       bound_trait(ty) { bound_trait(fld.fold_ty(ty)) }\n     }\n }"}, {"sha": "dcc8f7430cab251a99bbaf217ce832273486af8a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -16,7 +16,8 @@ import dvec::{dvec, extensions};\n import vec::{push};\n import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n-             bound_copy, bound_send, bound_trait, box, by_copy, by_move,\n+             bound_copy, bound_send, bound_trait, bound_owned,\n+             box, by_copy, by_move,\n              by_mutbl_ref, by_ref, by_val, capture_clause, capture_item,\n              carg_base, carg_ident, cdir_dir_mod, cdir_src_mod,\n              cdir_view_item, checked_expr, claimed_expr, class_immutable,\n@@ -1935,12 +1936,16 @@ class parser {\n         let ident = self.parse_ident();\n         if self.eat(token::COLON) {\n             while self.token != token::COMMA && self.token != token::GT {\n-                if self.eat_keyword(~\"send\") { push(bounds, bound_send); }\n-                else if self.eat_keyword(~\"copy\") { push(bounds, bound_copy) }\n+                if self.eat_keyword(~\"send\") {\n+                    push(bounds, bound_send); }\n+                else if self.eat_keyword(~\"copy\") {\n+                    push(bounds, bound_copy) }\n                 else if self.eat_keyword(~\"const\") {\n-                    push(bounds, bound_const)\n-                }\n-                else { push(bounds, bound_trait(self.parse_ty(false))); }\n+                    push(bounds, bound_const);\n+                } else if self.eat_keyword(~\"owned\") {\n+                    push(bounds, bound_owned);\n+                } else {\n+                    push(bounds, bound_trait(self.parse_ty(false))); }\n             }\n         }\n         ret {ident: ident, id: self.get_id(), bounds: @bounds};"}, {"sha": "949b078d8f0bf6b29b73eaf5997f7114f2c5081a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -313,7 +313,7 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n         ~\"if\", ~\"iface\", ~\"impl\", ~\"import\",\n         ~\"let\", ~\"log\", ~\"loop\",\n         ~\"mod\", ~\"mut\",\n-        ~\"new\",\n+        ~\"new\", ~\"owned\",\n         ~\"pure\", ~\"ret\",\n         ~\"true\", ~\"trait\", ~\"type\",\n         ~\"unchecked\", ~\"unsafe\","}, {"sha": "937a46a05d394c01d26bb0ee4da1b7b240229d75", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -1377,6 +1377,7 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n               ast::bound_copy { word(s.s, ~\"copy\"); }\n               ast::bound_send { word(s.s, ~\"send\"); }\n               ast::bound_const { word(s.s, ~\"const\"); }\n+              ast::bound_owned { word(s.s, ~\"owned\"); }\n               ast::bound_trait(t) { print_type(s, t); }\n             }\n         }"}, {"sha": "b6822186b25525fb73b139e9c34b2463e5a8e0bd", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -246,7 +246,7 @@ fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n         for vec::each(*tp.bounds) |bound| {\n             alt bound {\n               bound_trait(t) { v.visit_ty(t, e, v); }\n-              bound_copy | bound_send | bound_const { }\n+              bound_copy | bound_send | bound_const | bound_owned { }\n             }\n         }\n     }"}, {"sha": "d6084d308d31e75e7f04bb268ef73a489c933caf", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -417,6 +417,7 @@ fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'K' { ty::bound_const }\n+          'O' { ty::bound_owned }\n           'I' { ty::bound_trait(parse_ty(st, conv)) }\n           '.' { break; }\n         });"}, {"sha": "99e8f1cb611382d5255f6888218c7f0c1ea4ea59", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -350,6 +350,7 @@ fn enc_bounds(w: io::writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n           ty::bound_send { w.write_char('S'); }\n           ty::bound_copy { w.write_char('C'); }\n           ty::bound_const { w.write_char('K'); }\n+          ty::bound_owned { w.write_char('O'); }\n           ty::bound_trait(tp) {\n             w.write_char('I');\n             enc_ty(w, cx, tp);"}, {"sha": "7c7b5eb49f71ca5978d423a9bc7b2a5effe445ab", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -1,8 +1,7 @@\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n-import ty::{kind, kind_sendable, kind_copyable, kind_noncopyable, kind_const,\n-           operators};\n+import ty::{kind, kind_copyable, kind_noncopyable, kind_const, operators};\n import driver::session::session;\n import std::map::hashmap;\n import util::ppaux::{ty_to_str, tys_to_str};\n@@ -21,6 +20,7 @@ import lint::{non_implicitly_copyable_typarams,implicit_copies};\n //  copy: Things that can be copied.\n //  const: Things thare are deeply immutable. They are guaranteed never to\n //    change, and can be safely shared without copying between tasks.\n+//  owned: Things that do not contain borrowed pointers.\n //\n // Send includes scalar types as well as classes and unique types containing\n // only sendable types.\n@@ -41,15 +41,21 @@ import lint::{non_implicitly_copyable_typarams,implicit_copies};\n \n fn kind_to_str(k: kind) -> ~str {\n     let mut kinds = ~[];\n+\n     if ty::kind_lteq(kind_const(), k) {\n         vec::push(kinds, ~\"const\");\n     }\n+\n     if ty::kind_can_be_copied(k) {\n         vec::push(kinds, ~\"copy\");\n     }\n+\n     if ty::kind_can_be_sent(k) {\n         vec::push(kinds, ~\"send\");\n+    } else if ty::kind_is_owned(k) {\n+        vec::push(kinds, ~\"owned\");\n     }\n+\n     str::connect(kinds, ~\" \")\n }\n \n@@ -93,8 +99,8 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     fn check_for_uniq(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n                       is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be sendable, regardless of whether it is\n-        // moved in or copied in\n-        check_send(cx, var_t, sp);\n+        // moved in or copied in.  Note that send implies owned.\n+        if !check_send(cx, var_t, sp) { ret; }\n \n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n@@ -108,6 +114,9 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n \n     fn check_for_box(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n                      is_move: bool, var_t: ty::t, sp: span) {\n+        // all captured data must be owned\n+        if !check_owned(cx, var_t, sp) { ret; }\n+\n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n         if !is_move { check_copy(cx, id, var_t, sp, is_implicit); }\n@@ -422,9 +431,21 @@ fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n     }\n }\n \n-fn check_send(cx: ctx, ty: ty::t, sp: span) {\n+fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n     if !ty::kind_can_be_sent(ty::type_kind(cx.tcx, ty)) {\n         cx.tcx.sess.span_err(sp, ~\"not a sendable value\");\n+        false\n+    } else {\n+        true\n+    }\n+}\n+\n+fn check_owned(cx: ctx, ty: ty::t, sp: span) -> bool {\n+    if !ty::kind_is_owned(ty::type_kind(cx.tcx, ty)) {\n+        cx.tcx.sess.span_err(sp, ~\"not an owned value\");\n+        false\n+    } else {\n+        true\n     }\n }\n "}, {"sha": "7a021549b92717efa1720d7cab24ba422288b730", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -4,6 +4,7 @@ import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n import middle::lint::{error, ignore, level, unused_imports, warn};\n import syntax::ast::{_mod, arm, blk, bound_const, bound_copy, bound_trait};\n+import syntax::ast::{bound_owned};\n import syntax::ast::{bound_send, capture_clause, class_ctor, class_dtor};\n import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n@@ -3181,7 +3182,7 @@ class Resolver {\n         for type_parameters.each |type_parameter| {\n             for (*type_parameter.bounds).each |bound| {\n                 alt bound {\n-                    bound_copy | bound_send | bound_const {\n+                    bound_copy | bound_send | bound_const | bound_owned {\n                         // Nothing to do.\n                     }\n                     bound_trait(interface_type) {"}, {"sha": "256c3b0dd11b7ad3684a3af59ac28dd8ca7b2864", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -1373,23 +1373,23 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n     let tcx = cx.tcx();\n     let mut cx = cx;\n     if ty::type_is_scalar(t) {\n-        if src.kind == owned { src_val = Load(cx, src_val); }\n+        if src.kind == lv_owned { src_val = Load(cx, src_val); }\n         Store(cx, src_val, dst);\n         ret cx;\n     } else if ty::type_is_nil(t) || ty::type_is_bot(t) {\n         ret cx;\n     } else if ty::type_is_boxed(t) || ty::type_is_unique(t) {\n-        if src.kind == owned { src_val = Load(cx, src_val); }\n+        if src.kind == lv_owned { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n-        if src.kind == owned { ret zero_mem(cx, src.val, t); }\n+        if src.kind == lv_owned { ret zero_mem(cx, src.val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n         ret cx;\n     } else if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         memmove_ty(cx, dst, src_val, t);\n-        if src.kind == owned { ret zero_mem(cx, src_val, t); }\n+        if src.kind == lv_owned { ret zero_mem(cx, src_val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n         ret cx;\n@@ -1403,8 +1403,8 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n     -> block {\n     let _icx = cx.insn_ctxt(~\"trans_temp_expr\");\n     // Lvals in memory are not temporaries. Copy them.\n-    if src.kind != temporary && !last_use {\n-        let v = if src.kind == owned {\n+    if src.kind != lv_temporary && !last_use {\n+        let v = if src.kind == lv_owned {\n                     load_if_immediate(cx, src.val, t)\n                 } else {\n                     src.val\n@@ -1518,7 +1518,7 @@ fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n     let mut {bcx, val, kind} = trans_temp_lval(cx, e);\n     let ety = expr_ty(cx, e);\n     let is_immediate = ty::type_is_immediate(ety);\n-    if (kind == temporary && is_immediate) || kind == owned_imm {\n+    if (kind == lv_temporary && is_immediate) || kind == lv_owned_imm {\n         val = do_spill(bcx, val, ety);\n     }\n     ret store_in_dest(bcx, val, dest);\n@@ -1696,7 +1696,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     let _icx = bcx.insn_ctxt(~\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n-    assert (lhs_res.kind == owned);\n+    assert (lhs_res.kind == lv_owned);\n \n     // A user-defined operator method\n     alt bcx.ccx().maps.method_map.find(ex.id) {\n@@ -1720,7 +1720,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n             arg_exprs(~[src]), save_in(target));\n \n         ret move_val(bcx, DROP_EXISTING, lhs_res.val,\n-                     {bcx: bcx, val: target, kind: owned},\n+                     {bcx: bcx, val: target, kind: lv_owned},\n                      dty);\n       }\n       _ {}\n@@ -1947,9 +1947,9 @@ fn trans_loop(cx:block, body: ast::blk) -> block {\n }\n \n enum lval_kind {\n-    temporary, //< Temporary value passed by value if of immediate type\n-    owned,     //< Non-temporary value passed by pointer\n-    owned_imm, //< Non-temporary value passed by value\n+    lv_temporary, //< Temporary value passed by value if of immediate type\n+    lv_owned,     //< Non-temporary value passed by pointer\n+    lv_owned_imm, //< Non-temporary value passed by value\n }\n type local_var_result = {val: ValueRef, kind: lval_kind};\n type lval_result = {bcx: block, val: ValueRef, kind: lval_kind};\n@@ -1972,10 +1972,10 @@ fn lval_from_local_var(bcx: block, r: local_var_result) -> lval_result {\n }\n \n fn lval_owned(bcx: block, val: ValueRef) -> lval_result {\n-    ret {bcx: bcx, val: val, kind: owned};\n+    ret {bcx: bcx, val: val, kind: lv_owned};\n }\n fn lval_temp(bcx: block, val: ValueRef) -> lval_result {\n-    ret {bcx: bcx, val: val, kind: temporary};\n+    ret {bcx: bcx, val: val, kind: lv_temporary};\n }\n \n fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n@@ -2355,7 +2355,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n             val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n                 ccx, node_id_type(bcx, id))));\n         }\n-        ret {bcx: bcx, val: val, kind: owned, env: null_env};\n+        ret {bcx: bcx, val: val, kind: lv_owned, env: null_env};\n     }\n \n     let mut val = if fn_id.crate == ast::local_crate {\n@@ -2376,15 +2376,15 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n           ast::extern_fn {\n             // Extern functions are just opaque pointers\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));\n-            ret lval_no_env(bcx, val, owned_imm);\n+            ret lval_no_env(bcx, val, lv_owned_imm);\n           }\n           _ { /* fall through */ }\n         }\n       }\n       _ { /* fall through */ }\n     }\n \n-    ret {bcx: bcx, val: val, kind: owned, env: null_env};\n+    ret {bcx: bcx, val: val, kind: lv_owned, env: null_env};\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -2415,15 +2415,15 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n                   id: ast::node_id) -> local_var_result {\n         alt table.find(id) {\n-          some(local_mem(v)) { {val: v, kind: owned} }\n-          some(local_imm(v)) { {val: v, kind: owned_imm} }\n+          some(local_mem(v)) { {val: v, kind: lv_owned} }\n+          some(local_imm(v)) { {val: v, kind: lv_owned_imm} }\n           r { fail(~\"take_local: internal error\"); }\n         }\n     }\n     alt def {\n       ast::def_upvar(nid, _, _) {\n         assert (cx.fcx.llupvars.contains_key(nid));\n-        ret { val: cx.fcx.llupvars.get(nid), kind: owned };\n+        ret { val: cx.fcx.llupvars.get(nid), kind: lv_owned };\n       }\n       ast::def_arg(nid, _) {\n         assert (cx.fcx.llargs.contains_key(nid));\n@@ -2439,7 +2439,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n           none { cx.sess().bug(~\"trans_local_var: reference to self \\\n                                  out of context\"); }\n         };\n-        ret {val: slf, kind: owned};\n+        ret {val: slf, kind: lv_owned};\n       }\n       _ {\n         cx.sess().unimpl(#fmt(\"unsupported def type in trans_local_def: %?\",\n@@ -2478,16 +2478,17 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);\n             let lldiscrim = Load(cx, lldiscrim_gv);\n             Store(cx, lldiscrim, lldiscrimptr);\n-            ret lval_no_env(cx, llenumptr, temporary);\n+            ret lval_no_env(cx, llenumptr, lv_temporary);\n         }\n       }\n       ast::def_const(did) {\n         if did.crate == ast::local_crate {\n-            ret lval_no_env(cx, get_item_val(ccx, did.node), owned);\n+            ret lval_no_env(cx, get_item_val(ccx, did.node), lv_owned);\n         } else {\n             let tp = node_id_type(cx, id);\n             let val = trans_external_path(ccx, did, tp);\n-            ret lval_no_env(cx, load_if_immediate(cx, val, tp), owned_imm);\n+            ret lval_no_env(cx, load_if_immediate(cx, val, tp),\n+                            lv_owned_imm);\n         }\n       }\n       _ {\n@@ -2538,7 +2539,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n     }\n     else { GEPi(bcx, val, ~[0u, ix]) };\n \n-    ret {bcx: bcx, val: val, kind: owned};\n+    ret {bcx: bcx, val: val, kind: lv_owned};\n }\n \n \n@@ -2717,7 +2718,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, sp: span) -> lval_result {\n         let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n         let llfn = create_real_fn_pair(c.bcx, llfnty, c.val,\n                                        null_env_ptr(c.bcx));\n-        {bcx: c.bcx, val: llfn, kind: temporary}\n+        {bcx: c.bcx, val: llfn, kind: lv_temporary}\n       }\n     }\n }\n@@ -2863,7 +2864,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n           ast::expr_loop_body(blk) {\n             let scratch = alloc_ty(cx, expr_ty(cx, blk));\n             let bcx = trans_loop_body(cx, e, ret_flag, save_in(scratch));\n-            {bcx: bcx, val: scratch, kind: temporary}\n+            {bcx: bcx, val: scratch, kind: lv_temporary}\n           }\n         }\n       }\n@@ -2881,7 +2882,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n       let {bcx, val} = lval_result_to_result(lv, e_ty);\n       let {bcx, val, ty: e_ty} =\n           autoderef(bcx, e.id, val, e_ty, derefs);\n-      {lv: {bcx: bcx, val: val, kind: temporary},\n+      {lv: {bcx: bcx, val: val, kind: lv_temporary},\n        e_ty: e_ty}\n     };\n \n@@ -2904,14 +2905,14 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         alt arg_mode {\n           ast::by_ref | ast::by_mutbl_ref {\n             // Ensure that the value is spilled into memory:\n-            if lv.kind != owned && ty::type_is_immediate(e_ty) {\n+            if lv.kind != lv_owned && ty::type_is_immediate(e_ty) {\n                 val = do_spill_noroot(bcx, val);\n             }\n           }\n \n           ast::by_val {\n             // Ensure that the value is not spilled into memory:\n-            if lv.kind == owned || !ty::type_is_immediate(e_ty) {\n+            if lv.kind == lv_owned || !ty::type_is_immediate(e_ty) {\n                 val = Load(bcx, val);\n             }\n           }\n@@ -2921,15 +2922,15 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n             let alloc = alloc_ty(bcx, arg.ty);\n             let move_out = arg_mode == ast::by_move ||\n                 ccx.maps.last_use_map.contains_key(e.id);\n-            if lv.kind == temporary { revoke_clean(bcx, val); }\n-            if lv.kind == owned || !ty::type_is_immediate(arg.ty) {\n+            if lv.kind == lv_temporary { revoke_clean(bcx, val); }\n+            if lv.kind == lv_owned || !ty::type_is_immediate(arg.ty) {\n                 memmove_ty(bcx, alloc, val, arg.ty);\n                 if move_out && ty::type_needs_drop(ccx.tcx, arg.ty) {\n                     bcx = zero_mem(bcx, val, arg.ty);\n                 }\n             } else { Store(bcx, val, alloc); }\n             val = alloc;\n-            if lv.kind != temporary && !move_out {\n+            if lv.kind != lv_temporary && !move_out {\n                 bcx = take_ty(bcx, val, arg.ty);\n             }\n \n@@ -2977,9 +2978,9 @@ fn adapt_borrowed_value(lv: lval_result,\n       ty::ty_estr(_) | ty::ty_evec(_, _) {\n         let ccx = bcx.ccx();\n         let val = alt lv.kind {\n-          temporary { lv.val }\n-          owned { load_if_immediate(bcx, lv.val, e_ty) }\n-          owned_imm { lv.val }\n+          lv_temporary { lv.val }\n+          lv_owned { load_if_immediate(bcx, lv.val, e_ty) }\n+          lv_owned_imm { lv.val }\n         };\n \n         let unit_ty = ty::sequence_element_type(ccx.tcx, e_ty);\n@@ -3150,7 +3151,7 @@ fn trans_call_inner(\n           }\n           is_closure {\n             // It's a closure. Have to fetch the elements\n-            if f_res.kind == owned {\n+            if f_res.kind == lv_owned {\n                 faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n             }\n             let pair = faddr;\n@@ -3418,17 +3419,17 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n         let ty = expr_ty(bcx, e);\n         if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n             bcx = trans_expr(bcx, e, ignore);\n-            ret {bcx: bcx, val: C_nil(), kind: temporary};\n+            ret {bcx: bcx, val: C_nil(), kind: lv_temporary};\n         } else if ty::type_is_immediate(ty) {\n             let cell = empty_dest_cell();\n             bcx = trans_expr(bcx, e, by_val(cell));\n             add_clean_temp(bcx, *cell, ty);\n-            ret {bcx: bcx, val: *cell, kind: temporary};\n+            ret {bcx: bcx, val: *cell, kind: lv_temporary};\n         } else {\n             let scratch = alloc_ty(bcx, ty);\n             let bcx = trans_expr_save_in(bcx, e, scratch);\n             add_clean_temp(bcx, scratch, ty);\n-            ret {bcx: bcx, val: scratch, kind: temporary};\n+            ret {bcx: bcx, val: scratch, kind: lv_temporary};\n         }\n     }\n }\n@@ -3442,9 +3443,9 @@ fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n \n fn load_value_from_lval_result(lv: lval_result, ty: ty::t) -> ValueRef {\n     alt lv.kind {\n-      temporary { lv.val }\n-      owned { load_if_immediate(lv.bcx, lv.val, ty) }\n-      owned_imm { lv.val }\n+      lv_temporary { lv.val }\n+      lv_owned { load_if_immediate(lv.bcx, lv.val, ty) }\n+      lv_owned_imm { lv.val }\n     }\n }\n \n@@ -3521,7 +3522,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n \n         let _icx = bcx.insn_ctxt(~\"root_value_expr\");\n         add_root_cleanup(bcx, scope_id, root_loc, ty);\n-        let lv = {bcx: bcx, val: root_loc, kind: owned};\n+        let lv = {bcx: bcx, val: root_loc, kind: lv_owned};\n         lval_result_to_dps(lv, ty, false, dest)\n       }\n     };\n@@ -3647,7 +3648,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             assert dest == ignore;\n             let src_r = trans_temp_lval(bcx, src);\n             let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n-            assert kind == owned;\n+            assert kind == lv_owned;\n             let is_last_use =\n                 bcx.ccx().maps.last_use_map.contains_key(src.id);\n             ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n@@ -3658,14 +3659,14 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             assert dest == ignore;\n             let src_r = trans_temp_lval(bcx, src);\n             let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n-            assert kind == owned;\n+            assert kind == lv_owned;\n             ret move_val(bcx, DROP_EXISTING, addr, src_r,\n                          expr_ty(bcx, src));\n           }\n           ast::expr_swap(dst, src) {\n             assert dest == ignore;\n             let lhs_res = trans_lval(bcx, dst);\n-            assert lhs_res.kind == owned;\n+            assert lhs_res.kind == lv_owned;\n             let rhs_res = trans_lval(lhs_res.bcx, src);\n             let t = expr_ty(bcx, src);\n             let tmp_alloc = alloc_ty(rhs_res.bcx, t);\n@@ -3728,7 +3729,7 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let last_use_map = bcx.ccx().maps.last_use_map;\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n-    let last_use = (lv.kind == owned && last_use_map.contains_key(e.id));\n+    let last_use = (lv.kind == lv_owned && last_use_map.contains_key(e.id));\n     #debug[\"is last use (%s) = %b, %d\", expr_to_str(e), last_use,\n            lv.kind as int];\n     lval_result_to_dps(lv, ty, last_use, dest)\n@@ -3740,7 +3741,7 @@ fn lval_result_to_dps(lv: lval_result, ty: ty::t,\n     let ccx = bcx.ccx();\n     alt dest {\n       by_val(cell) {\n-        if kind == temporary {\n+        if kind == lv_temporary {\n             revoke_clean(bcx, val);\n             *cell = val;\n         } else if last_use {\n@@ -3749,7 +3750,7 @@ fn lval_result_to_dps(lv: lval_result, ty: ty::t,\n                 bcx = zero_mem(bcx, val, ty);\n             }\n         } else {\n-            if kind == owned { val = Load(bcx, val); }\n+            if kind == lv_owned { val = Load(bcx, val); }\n             let {bcx: cx, val} = take_ty_immediate(bcx, val, ty);\n             *cell = val;\n             bcx = cx;\n@@ -4788,7 +4789,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n   // Translate the body of the ctor\n   bcx = trans_block(bcx_top, body, ignore);\n-  let lval_res = {bcx: bcx, val: selfptr, kind: owned};\n+  let lval_res = {bcx: bcx, val: selfptr, kind: lv_owned};\n   // Generate the return expression\n   bcx = store_temp_expr(bcx, INIT, fcx.llretptr, lval_res,\n                         rslt_ty, true);"}, {"sha": "dfeecabeb10849543db91fee1817e514d5a2d344", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -216,31 +216,31 @@ fn store_environment(bcx: block,\n         let bound_data = GEPi(bcx, llbox,\n              ~[0u, abi::box_field_body, i]);\n         alt bv {\n-          env_copy(val, ty, owned) {\n+          env_copy(val, ty, lv_owned) {\n             let val1 = load_if_immediate(bcx, val, ty);\n             bcx = base::copy_val(bcx, INIT, bound_data, val1, ty);\n           }\n-          env_copy(val, ty, owned_imm) {\n+          env_copy(val, ty, lv_owned_imm) {\n             bcx = base::copy_val(bcx, INIT, bound_data, val, ty);\n           }\n-          env_copy(_, _, temporary) {\n+          env_copy(_, _, lv_temporary) {\n             fail ~\"cannot capture temporary upvar\";\n           }\n           env_move(val, ty, kind) {\n             let src = {bcx:bcx, val:val, kind:kind};\n             bcx = move_val(bcx, INIT, bound_data, src, ty);\n           }\n-          env_ref(val, ty, owned) {\n+          env_ref(val, ty, lv_owned) {\n             #debug[\"> storing %s into %s\",\n                    val_str(bcx.ccx().tn, val),\n                    val_str(bcx.ccx().tn, bound_data)];\n             Store(bcx, val, bound_data);\n           }\n-          env_ref(val, ty, owned_imm) {\n+          env_ref(val, ty, lv_owned_imm) {\n             let addr = do_spill_noroot(bcx, val);\n             Store(bcx, addr, bound_data);\n           }\n-          env_ref(_, _, temporary) {\n+          env_ref(_, _, lv_temporary) {\n             fail ~\"cannot capture temporary upvar\";\n           }\n         }\n@@ -289,7 +289,7 @@ fn build_closure(bcx0: block,\n             vec::push(env_vals, env_move(lv.val, ty, lv.kind));\n           }\n           capture::cap_drop {\n-            assert lv.kind == owned;\n+            assert lv.kind == lv_owned;\n             bcx = drop_ty(bcx, lv.val, ty);\n             bcx = zero_mem(bcx, lv.val, ty);\n           }\n@@ -303,9 +303,9 @@ fn build_closure(bcx0: block,\n         let nil_ret = PointerCast(bcx, our_ret, T_ptr(T_nil()));\n         vec::push(env_vals,\n                   env_ref(flagptr,\n-                          ty::mk_mut_ptr(tcx, ty::mk_bool(tcx)), owned));\n+                          ty::mk_mut_ptr(tcx, ty::mk_bool(tcx)), lv_owned));\n         vec::push(env_vals,\n-                  env_ref(nil_ret, ty::mk_nil_ptr(tcx), owned));\n+                  env_ref(nil_ret, ty::mk_nil_ptr(tcx), lv_owned));\n     }\n     ret store_environment(bcx, env_vals, ck);\n }"}, {"sha": "21ffefc545616b3a90f63a9b3c62d600ded3e516", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -881,7 +881,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         let tp_ty = substs.tys[0];\n         let src = {bcx: bcx,\n                    val: get_param(decl, first_real_arg + 1u),\n-                   kind: owned };\n+                   kind: lv_owned};\n         bcx = move_val(bcx, DROP_EXISTING,\n                        get_param(decl, first_real_arg),\n                        src,\n@@ -891,7 +891,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         let tp_ty = substs.tys[0];\n         let src = {bcx: bcx,\n                    val: get_param(decl, first_real_arg + 1u),\n-                   kind: owned };\n+                   kind: lv_owned};\n         bcx = move_val(bcx, INIT,\n                        get_param(decl, first_real_arg),\n                        src,\n@@ -982,7 +982,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                                |bcx| lval_no_env(\n                                    bcx,\n                                    get_param(decl, first_real_arg),\n-                                   temporary),\n+                                   lv_temporary),\n                                arg_vals(~[frameaddress_val]), ignore);\n       }\n     }"}, {"sha": "5fc1b204e0ea12ff0fc6f81cd6dc86e83c46427a", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -162,7 +162,7 @@ fn trans_trait_callee(bcx: block, val: ValueRef,\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, ~[0u, n_method]));\n-    {bcx: bcx, val: mptr, kind: owned, env: env}\n+    {bcx: bcx, val: mptr, kind: lv_owned, env: env}\n }\n \n fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)"}, {"sha": "0ff07554505cc189c80a7b30612ff002a69b7d0e", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 102, "deletions": 52, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -107,9 +107,10 @@ export tbox_has_flag;\n export ty_var_id;\n export ty_to_def_id;\n export ty_fn_args;\n-export kind, kind_implicitly_copyable, kind_sendable, kind_copyable;\n+export kind, kind_implicitly_copyable, kind_send_copy, kind_copyable;\n export kind_noncopyable, kind_const;\n export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n+export kind_is_owned;\n export proto_kind, kind_lteq, type_kind;\n export operators;\n export type_err, terr_vstore_kind;\n@@ -144,7 +145,8 @@ export closure_kind;\n export ck_block;\n export ck_box;\n export ck_uniq;\n-export param_bound, param_bounds, bound_copy, bound_send, bound_trait;\n+export param_bound, param_bounds, bound_copy, bound_owned;\n+export bound_send, bound_trait;\n export param_bounds_to_kind;\n export default_arg_mode_for_ty;\n export item_path;\n@@ -409,6 +411,7 @@ enum type_err {\n \n enum param_bound {\n     bound_copy,\n+    bound_owned,\n     bound_send,\n     bound_const,\n     bound_trait(t),\n@@ -451,8 +454,15 @@ fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n           bound_copy {\n             kind = raise_kind(kind, kind_implicitly_copyable());\n           }\n-          bound_send { kind = raise_kind(kind, kind_send_only()); }\n-          bound_const { kind = raise_kind(kind, kind_const()); }\n+          bound_owned {\n+            kind = raise_kind(kind, kind_owned());\n+          }\n+          bound_send {\n+            kind = raise_kind(kind, kind_send_only() | kind_owned());\n+          }\n+          bound_const {\n+            kind = raise_kind(kind, kind_const());\n+          }\n           bound_trait(_) {}\n         }\n     }\n@@ -1303,11 +1313,20 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n enum kind { kind_(u32) }\n \n-// *ALL* implicitly copiable things must be copiable\n-const KIND_MASK_COPY     : u32 = 0b00000000000000000000000000000001u32;\n-const KIND_MASK_SEND     : u32 = 0b00000000000000000000000000000010u32;\n-const KIND_MASK_CONST    : u32 = 0b00000000000000000000000000000100u32;\n-const KIND_MASK_IMPLICIT : u32 = 0b00000000000000000000000000001000u32;\n+/// can be copied (implicitly or explicitly)\n+const KIND_MASK_COPY     : u32 = 0b00000000000000000000000000000001_u32;\n+\n+/// can be sent: no shared box, borrowed ptr (must imply OWNED)\n+const KIND_MASK_SEND     : u32 = 0b00000000000000000000000000000010_u32;\n+\n+/// is owned (no borrowed ptrs)\n+const KIND_MASK_OWNED    : u32 = 0b00000000000000000000000000000100_u32;\n+\n+/// is deeply immutable\n+const KIND_MASK_CONST    : u32 = 0b00000000000000000000000000001000_u32;\n+\n+/// can be implicitly copied (must imply COPY)\n+const KIND_MASK_IMPLICIT : u32 = 0b00000000000000000000000000010000_u32;\n \n fn kind_noncopyable() -> kind {\n     kind_(0u32)\n@@ -1325,7 +1344,7 @@ fn kind_implicitly_sendable() -> kind {\n     kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY | KIND_MASK_SEND)\n }\n \n-fn kind_sendable() -> kind {\n+fn kind_send_copy() -> kind {\n     kind_(KIND_MASK_COPY | KIND_MASK_SEND)\n }\n \n@@ -1337,6 +1356,10 @@ fn kind_const() -> kind {\n     kind_(KIND_MASK_CONST)\n }\n \n+fn kind_owned() -> kind {\n+    kind_(KIND_MASK_OWNED)\n+}\n+\n fn kind_top() -> kind {\n     kind_(0xffffffffu32)\n }\n@@ -1349,6 +1372,14 @@ fn remove_implicit(k: kind) -> kind {\n     k - kind_(KIND_MASK_IMPLICIT)\n }\n \n+fn remove_send(k: kind) -> kind {\n+    k - kind_(KIND_MASK_SEND)\n+}\n+\n+fn remove_owned_send(k: kind) -> kind {\n+    k - kind_(KIND_MASK_OWNED) - kind_(KIND_MASK_SEND)\n+}\n+\n fn remove_copyable(k: kind) -> kind {\n     k - kind_(KIND_MASK_COPY)\n }\n@@ -1371,24 +1402,29 @@ impl operators for kind {\n // against the kind constants, as we may modify the kind hierarchy in the\n // future.\n pure fn kind_can_be_implicitly_copied(k: kind) -> bool {\n-    *k & KIND_MASK_IMPLICIT != 0u32\n+    *k & KIND_MASK_IMPLICIT == KIND_MASK_IMPLICIT\n }\n \n pure fn kind_can_be_copied(k: kind) -> bool {\n-    *k & KIND_MASK_COPY != 0u32\n+    *k & KIND_MASK_COPY == KIND_MASK_COPY\n }\n \n pure fn kind_can_be_sent(k: kind) -> bool {\n-    *k & KIND_MASK_SEND != 0u32\n+    *k & KIND_MASK_SEND == KIND_MASK_SEND\n+}\n+\n+pure fn kind_is_owned(k: kind) -> bool {\n+    *k & KIND_MASK_OWNED == KIND_MASK_OWNED\n }\n \n fn proto_kind(p: proto) -> kind {\n     alt p {\n       ast::proto_any { kind_noncopyable() }\n       ast::proto_block { kind_noncopyable() }\n-      ast::proto_box { kind_implicitly_copyable() }\n-      ast::proto_uniq { kind_sendable() }\n-      ast::proto_bare { kind_implicitly_sendable() | kind_const() }\n+      ast::proto_box { kind_implicitly_copyable() | kind_owned() }\n+      ast::proto_uniq { kind_send_copy() | kind_owned() }\n+      ast::proto_bare { kind_implicitly_sendable() | kind_const() |\n+                           kind_owned() }\n     }\n }\n \n@@ -1408,16 +1444,16 @@ fn raise_kind(a: kind, b: kind) -> kind {\n fn test_kinds() {\n     // The kind \"lattice\" is defined by the subset operation on the\n     // set of permitted operations.\n-    assert kind_lteq(kind_sendable(), kind_sendable());\n-    assert kind_lteq(kind_copyable(), kind_sendable());\n+    assert kind_lteq(kind_send_copy(), kind_send_copy());\n+    assert kind_lteq(kind_copyable(), kind_send_copy());\n     assert kind_lteq(kind_copyable(), kind_copyable());\n-    assert kind_lteq(kind_noncopyable(), kind_sendable());\n+    assert kind_lteq(kind_noncopyable(), kind_send_copy());\n     assert kind_lteq(kind_noncopyable(), kind_copyable());\n     assert kind_lteq(kind_noncopyable(), kind_noncopyable());\n     assert kind_lteq(kind_copyable(), kind_implicitly_copyable());\n     assert kind_lteq(kind_copyable(), kind_implicitly_sendable());\n-    assert kind_lteq(kind_sendable(), kind_implicitly_sendable());\n-    assert !kind_lteq(kind_sendable(), kind_implicitly_copyable());\n+    assert kind_lteq(kind_send_copy(), kind_implicitly_sendable());\n+    assert !kind_lteq(kind_send_copy(), kind_implicitly_copyable());\n     assert !kind_lteq(kind_copyable(), kind_send_only());\n }\n \n@@ -1447,66 +1483,73 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     cx.kind_cache.insert(ty, kind_top());\n \n     let result = alt get(ty).struct {\n-      // Scalar and unique types are sendable\n+      // Scalar and unique types are sendable, constant, and owned\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_ptr(_) { kind_implicitly_sendable() | kind_const() }\n+      ty_ptr(_) {\n+        kind_implicitly_sendable() | kind_const() | kind_owned()\n+      }\n+\n       // Implicit copyability of strs is configurable\n       ty_estr(vstore_uniq) {\n         if cx.vecs_implicitly_copyable {\n-            kind_implicitly_sendable() | kind_const()\n-        } else { kind_sendable() | kind_const() }\n+            kind_implicitly_sendable() | kind_const() | kind_owned()\n+        } else {\n+            kind_send_copy() | kind_const() | kind_owned()\n+        }\n       }\n+\n+      // functions depend on the protocol\n       ty_fn(f) { proto_kind(f.proto) }\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n       ty_box(tm) {\n-        if tm.mutbl == ast::m_mutbl {\n-            kind_implicitly_copyable()\n-        }\n-        else {\n-            let k = type_kind(cx, tm.ty);\n-            if kind_lteq(kind_const(), k) {\n-                kind_implicitly_copyable() | kind_const()\n-            }\n-            else { kind_implicitly_copyable() }\n-        }\n+        remove_send(mutable_type_kind(cx, tm) | kind_implicitly_copyable())\n       }\n-      ty_trait(_, _) { kind_implicitly_copyable() }\n+\n+      // Iface instances are (for now) like shared boxes, basically\n+      ty_trait(_, _) { kind_implicitly_copyable() | kind_owned() }\n+\n+      // Region pointers are copyable but NOT owned nor sendable\n       ty_rptr(_, _) { kind_implicitly_copyable() }\n \n       // Unique boxes and vecs have the kind of their contained type,\n       // but unique boxes can't be implicitly copyable.\n-      ty_uniq(tm) {\n-        remove_implicit(mutable_type_kind(cx, tm))\n-      }\n+      ty_uniq(tm) { remove_implicit(mutable_type_kind(cx, tm)) }\n+\n       // Implicit copyability of vecs is configurable\n       ty_evec(tm, vstore_uniq) {\n           if cx.vecs_implicitly_copyable {\n               mutable_type_kind(cx, tm)\n-          } else { remove_implicit(mutable_type_kind(cx, tm)) }\n+          } else {\n+              remove_implicit(mutable_type_kind(cx, tm))\n+          }\n       }\n \n       // Slices, refcounted evecs are copyable; uniques depend on the their\n       // contained type, but aren't implicitly copyable.  Fixed vectors have\n       // the kind of the element they contain, taking mutability into account.\n-      ty_evec(tm, vstore_box) |\n+      ty_evec(tm, vstore_box) {\n+        remove_send(kind_implicitly_copyable() | mutable_type_kind(cx, tm))\n+      }\n       ty_evec(tm, vstore_slice(_)) {\n-        if kind_lteq(kind_const(), type_kind(cx, tm.ty)) {\n-            kind_implicitly_copyable() | kind_const()\n-        }\n-        else {\n-            kind_implicitly_copyable()\n-        }\n+        remove_owned_send(kind_implicitly_copyable() |\n+                          mutable_type_kind(cx, tm))\n       }\n       ty_evec(tm, vstore_fixed(_)) {\n         mutable_type_kind(cx, tm)\n       }\n \n       // All estrs are copyable; uniques and interiors are sendable.\n-      ty_estr(vstore_box) |\n-      ty_estr(vstore_slice(_)) { kind_implicitly_copyable() | kind_const() }\n-      ty_estr(vstore_fixed(_)) { kind_implicitly_sendable() | kind_const() }\n+      ty_estr(vstore_box) {\n+        kind_implicitly_copyable() | kind_const() | kind_owned()\n+      }\n+      ty_estr(vstore_slice(_)) {\n+        kind_implicitly_copyable() | kind_const()\n+      }\n+      ty_estr(vstore_fixed(_)) {\n+        kind_implicitly_sendable() | kind_const() | kind_owned()\n+      }\n \n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n@@ -1516,6 +1559,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         }\n         lowest\n       }\n+\n       ty_class(did, substs) {\n         // Classes are sendable if all their fields are sendable,\n         // likewise for copyable...\n@@ -1532,18 +1576,20 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         }\n         lowest\n       }\n+\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         let mut lowest = kind_top();\n         for tys.each |ty| { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n+\n       // Enums lower to the lowest of their variants.\n       ty_enum(did, substs) {\n         let mut lowest = kind_top();\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 0u {\n-            lowest = kind_send_only();\n+            lowest = kind_send_only() | kind_owned();\n         } else {\n             for vec::each(*variants) |variant| {\n                 for variant.args.each |aty| {\n@@ -1556,11 +1602,15 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         }\n         lowest\n       }\n+\n       ty_param(_, did) {\n         param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n-      // FIXME (#2663): is self ever const?\n+\n+      // self is a special type parameter that can only appear in ifaces; it\n+      // is never bounded in any way, hence it has the bottom kind.\n       ty_self { kind_noncopyable() }\n+\n       ty_var(_) | ty_var_integral(_) {\n         cx.sess.bug(~\"Asked to compute kind of a type variable\");\n       }"}, {"sha": "05290d176aeb77a505c780d36812871d8b750a8a", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -169,7 +169,8 @@ class lookup {\n         let bounds = tcx.ty_param_bounds.get(did.node);\n         for vec::each(*bounds) |bound| {\n             let (iid, bound_substs) = alt bound {\n-              ty::bound_copy | ty::bound_send | ty::bound_const {\n+              ty::bound_copy | ty::bound_send | ty::bound_const |\n+              ty::bound_owned {\n                 again; /* ok */\n               }\n               ty::bound_trait(bound_t) {"}, {"sha": "e38b1a39e13381c092fb555249cd036b1d9c2ff0", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -68,7 +68,8 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n         let mut n_bound = 0u;\n         for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n             alt bound {\n-              ty::bound_send | ty::bound_copy | ty::bound_const {\n+              ty::bound_send | ty::bound_copy | ty::bound_const |\n+              ty::bound_owned {\n                 /* ignore */\n               }\n               ty::bound_trait(ity) {"}, {"sha": "0f4eb6d2e8203049530d0371b68d7848c518dcd1", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -572,6 +572,7 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n               ast::bound_send { ~[ty::bound_send] }\n               ast::bound_copy { ~[ty::bound_copy] }\n               ast::bound_const { ~[ty::bound_const] }\n+              ast::bound_owned { ~[ty::bound_owned] }\n               ast::bound_trait(t) {\n                 let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n                 alt ty::get(ity).struct {"}, {"sha": "4d433939b37feb353753182ce4dab92460544087", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -57,7 +57,6 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n         }\n       }\n       none {\n-        // FIXME(#2586)\n         #fmt[\"<unknown-%d>\", node_id]\n       }\n       _ { cx.sess.bug("}, {"sha": "f8688ee2bd27309aa24119fe3e1ce0b7e77303bf", "filename": "src/test/compile-fail/block-arg-used-as-lambda-with-illegal-cap.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -1,11 +1,9 @@\n-// error-pattern: copying a noncopyable value\n-\n fn to_lambda1(f: fn@(uint) -> uint) -> fn@(uint) -> uint {\n     ret f;\n }\n \n fn to_lambda2(b: fn(uint) -> uint) -> fn@(uint) -> uint {\n-    ret to_lambda1({|x| b(x)});\n+    ret to_lambda1({|x| b(x)}); //~ ERROR not an owned value\n }\n \n fn main() {"}, {"sha": "c13cc37f4b7e1063b1fa3c62ddb13c3b172be7e6", "filename": "src/test/compile-fail/cap-clause-illegal-cap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -1,6 +1,8 @@\n // error-pattern: copying a noncopyable value\n \n-fn to_lambda2(b: fn(uint) -> uint) -> fn@(uint) -> uint {\n+class foo { let x: int; new(x: int) { self.x = x; } drop { } }\n+\n+fn to_lambda2(b: foo) -> fn@(uint) -> uint {\n     // test case where copy clause specifies a value that is not used\n     // in fn@ body, but value is illegal to copy:\n     ret fn@(u: uint, copy b) -> uint { 22u };"}, {"sha": "7392d3183fe7c6b330e10b39521c2824b80ec646", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -0,0 +1,19 @@\n+fn copy1<T: copy>(t: T) -> fn@() -> T {\n+    fn@() -> T { t } //~ ERROR not an owned value\n+}\n+\n+fn copy2<T: copy owned>(t: T) -> fn@() -> T {\n+    fn@() -> T { t }\n+}\n+\n+fn main() {\n+    let x = &3;\n+    copy2(&x); //~ ERROR instantiating a type parameter with an incompatible type\n+\n+    copy2(@3);\n+    copy2(@&x); //~ ERROR instantiating a type parameter with an incompatible type\n+\n+    copy2(fn@() {});\n+    copy2(fn~() {}); //~ WARNING instantiating copy type parameter with a not implicitly copyable type\n+    copy2(fn&() {}); //~ ERROR instantiating a type parameter with an incompatible type\n+}"}, {"sha": "04f07001810c802e3f584637d8d57c87dfbf480b", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -2,7 +2,7 @@ type pair<A,B> = {\n     a: A, b: B\n };\n \n-fn f<A:copy>(a: A, b: u16) -> fn@() -> (A, u16) {\n+fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n     fn@() -> (A, u16) { (a, b) }\n }\n "}, {"sha": "20f4a8055e84adb77dff7f90c20039e0078cf658", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -6,7 +6,7 @@ type pair<A,B> = {\n     a: A, b: B\n };\n \n-fn f<A:copy>(a: A, b: u16) -> fn@() -> (A, u16) {\n+fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n     fn@() -> (A, u16) { (a, b) }\n }\n "}, {"sha": "029af017f654d4f15b11a6ffd9ffc3645a21fc3b", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e42004babc7b965a10056084a8ae76c72140a44/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=0e42004babc7b965a10056084a8ae76c72140a44", "patch": "@@ -1,8 +1,8 @@\n-fn fix_help<A, B: send>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A: owned, B: send>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n     ret f({|a|fix_help(f, a)}, x);\n }\n \n-fn fix<A, B: send>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n+fn fix<A: owned, B: send>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n     ret {|a|fix_help(f, a)};\n }\n "}]}