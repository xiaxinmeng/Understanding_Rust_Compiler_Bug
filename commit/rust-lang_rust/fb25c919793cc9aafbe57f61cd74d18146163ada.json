{"sha": "fb25c919793cc9aafbe57f61cd74d18146163ada", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMjVjOTE5NzkzY2M5YWFmYmU1N2Y2MWNkNzRkMTgxNDYxNjNhZGE=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2020-01-03T15:30:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-08T14:21:54Z"}, "message": "Adds a way to limits reference search by StructLiteral", "tree": {"sha": "ec7d616010741522ac4718ff472e8fc6307b2d24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec7d616010741522ac4718ff472e8fc6307b2d24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb25c919793cc9aafbe57f61cd74d18146163ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb25c919793cc9aafbe57f61cd74d18146163ada", "html_url": "https://github.com/rust-lang/rust/commit/fb25c919793cc9aafbe57f61cd74d18146163ada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb25c919793cc9aafbe57f61cd74d18146163ada/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d8f2bd822c1e9384ef547c781ccc26a6dec63e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8f2bd822c1e9384ef547c781ccc26a6dec63e2", "html_url": "https://github.com/rust-lang/rust/commit/5d8f2bd822c1e9384ef547c781ccc26a6dec63e2"}], "stats": {"total": 118, "additions": 100, "deletions": 18}, "files": [{"sha": "a0226b1bcc0720377e6d0c27344821936511748a", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 84, "deletions": 11, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fb25c919793cc9aafbe57f61cd74d18146163ada/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb25c919793cc9aafbe57f61cd74d18146163ada/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=fb25c919793cc9aafbe57f61cd74d18146163ada", "patch": "@@ -18,7 +18,10 @@ use hir::InFile;\n use once_cell::unsync::Lazy;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_prof::profile;\n-use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode, TextUnit};\n+use ra_syntax::{\n+    algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, TextUnit,\n+    TokenAtOffset,\n+};\n \n use crate::{\n     db::RootDatabase, display::ToNav, FilePosition, FileRange, NavigationTarget, RangeInfo,\n@@ -35,15 +38,28 @@ pub use self::search_scope::SearchScope;\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     declaration: NavigationTarget,\n-    references: Vec<FileRange>,\n+    declaration_kind: ReferenceKind,\n+    references: Vec<Reference>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Reference {\n+    pub file_range: FileRange,\n+    pub kind: ReferenceKind,\n+}\n+\n+#[derive(Debug, Clone, PartialEq)]\n+pub enum ReferenceKind {\n+    StructLiteral,\n+    Other,\n }\n \n impl ReferenceSearchResult {\n     pub fn declaration(&self) -> &NavigationTarget {\n         &self.declaration\n     }\n \n-    pub fn references(&self) -> &[FileRange] {\n+    pub fn references(&self) -> &[Reference] {\n         &self.references\n     }\n \n@@ -58,24 +74,43 @@ impl ReferenceSearchResult {\n // allow turning ReferenceSearchResult into an iterator\n // over FileRanges\n impl IntoIterator for ReferenceSearchResult {\n-    type Item = FileRange;\n-    type IntoIter = std::vec::IntoIter<FileRange>;\n+    type Item = Reference;\n+    type IntoIter = std::vec::IntoIter<Reference>;\n \n     fn into_iter(mut self) -> Self::IntoIter {\n         let mut v = Vec::with_capacity(self.len());\n-        v.push(FileRange { file_id: self.declaration.file_id(), range: self.declaration.range() });\n+        v.push(Reference {\n+            file_range: FileRange {\n+                file_id: self.declaration.file_id(),\n+                range: self.declaration.range(),\n+            },\n+            kind: self.declaration_kind,\n+        });\n         v.append(&mut self.references);\n         v.into_iter()\n     }\n }\n \n pub(crate) fn find_all_refs(\n     db: &RootDatabase,\n-    position: FilePosition,\n+    mut position: FilePosition,\n     search_scope: Option<SearchScope>,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n     let parse = db.parse(position.file_id);\n     let syntax = parse.tree().syntax().clone();\n+\n+    let token = syntax.token_at_offset(position.offset);\n+    let mut search_kind = ReferenceKind::Other;\n+\n+    if let TokenAtOffset::Between(ref left, ref right) = token {\n+        if (right.kind() == SyntaxKind::L_CURLY || right.kind() == SyntaxKind::L_PAREN)\n+            && left.kind() != SyntaxKind::IDENT\n+        {\n+            position = FilePosition { offset: left.text_range().start(), ..position };\n+            search_kind = ReferenceKind::StructLiteral;\n+        }\n+    }\n+\n     let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n \n     let declaration = match def.kind {\n@@ -96,9 +131,15 @@ pub(crate) fn find_all_refs(\n         }\n     };\n \n-    let references = process_definition(db, def, name, search_scope);\n+    let references = process_definition(db, def, name, search_scope)\n+        .into_iter()\n+        .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n+        .collect();\n \n-    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n+    Some(RangeInfo::new(\n+        range,\n+        ReferenceSearchResult { declaration, references, declaration_kind: ReferenceKind::Other },\n+    ))\n }\n \n fn find_name<'a>(\n@@ -122,7 +163,7 @@ fn process_definition(\n     def: NameDefinition,\n     name: String,\n     scope: SearchScope,\n-) -> Vec<FileRange> {\n+) -> Vec<Reference> {\n     let _p = profile(\"process_definition\");\n \n     let pat = name.as_str();\n@@ -146,7 +187,21 @@ fn process_definition(\n                 }\n                 if let Some(d) = classify_name_ref(db, InFile::new(file_id.into(), &name_ref)) {\n                     if d == def {\n-                        refs.push(FileRange { file_id, range });\n+                        let kind = if name_ref\n+                            .syntax()\n+                            .ancestors()\n+                            .find_map(ast::RecordLit::cast)\n+                            .and_then(|l| l.path())\n+                            .and_then(|p| p.segment())\n+                            .and_then(|p| p.name_ref())\n+                            .map(|n| n == name_ref)\n+                            .unwrap_or(false)\n+                        {\n+                            ReferenceKind::StructLiteral\n+                        } else {\n+                            ReferenceKind::Other\n+                        };\n+                        refs.push(Reference { file_range: FileRange { file_id, range }, kind });\n                     }\n                 }\n             }\n@@ -162,6 +217,24 @@ mod tests {\n         ReferenceSearchResult, SearchScope,\n     };\n \n+    #[test]\n+    fn test_struct_literal() {\n+        let code = r#\"\n+    struct Foo <|>{\n+        a: i32,\n+    }\n+    impl Foo {\n+        fn f() -> i32 { 42 }\n+    }    \n+    fn main() {\n+        let f: Foo;\n+        f = Foo {a: Foo::f()};\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n     #[test]\n     fn test_find_all_refs_for_local() {\n         let code = r#\""}, {"sha": "e02985dcd81725298c835d1f52e3f49ff8023f25", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb25c919793cc9aafbe57f61cd74d18146163ada/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb25c919793cc9aafbe57f61cd74d18146163ada/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=fb25c919793cc9aafbe57f61cd74d18146163ada", "patch": "@@ -110,7 +110,13 @@ fn rename_reference(\n \n     let edit = refs\n         .into_iter()\n-        .map(|range| source_edit_from_file_id_range(range.file_id, range.range, new_name))\n+        .map(|reference| {\n+            source_edit_from_file_id_range(\n+                reference.file_range.file_id,\n+                reference.file_range.range,\n+                new_name,\n+            )\n+        })\n         .collect::<Vec<_>>();\n \n     if edit.is_empty() {"}, {"sha": "c8f52eb0e704901d932776f4d5d59488b38fbcdf", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb25c919793cc9aafbe57f61cd74d18146163ada/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb25c919793cc9aafbe57f61cd74d18146163ada/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=fb25c919793cc9aafbe57f61cd74d18146163ada", "patch": "@@ -531,17 +531,17 @@ pub fn handle_references(\n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n             .filter_map(|r| {\n-                let line_index = world.analysis().file_line_index(r.file_id).ok()?;\n-                to_location(r.file_id, r.range, &world, &line_index).ok()\n+                let line_index = world.analysis().file_line_index(r.file_range.file_id).ok()?;\n+                to_location(r.file_range.file_id, r.file_range.range, &world, &line_index).ok()\n             })\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n             .filter_map(|r| {\n-                let line_index = world.analysis().file_line_index(r.file_id).ok()?;\n-                to_location(r.file_id, r.range, &world, &line_index).ok()\n+                let line_index = world.analysis().file_line_index(r.file_range.file_id).ok()?;\n+                to_location(r.file_range.file_id, r.file_range.range, &world, &line_index).ok()\n             })\n             .collect()\n     };\n@@ -830,8 +830,11 @@ pub fn handle_document_highlight(\n \n     Ok(Some(\n         refs.into_iter()\n-            .filter(|r| r.file_id == file_id)\n-            .map(|r| DocumentHighlight { range: r.range.conv_with(&line_index), kind: None })\n+            .filter(|r| r.file_range.file_id == file_id)\n+            .map(|r| DocumentHighlight {\n+                range: r.file_range.range.conv_with(&line_index),\n+                kind: None,\n+            })\n             .collect(),\n     ))\n }"}]}