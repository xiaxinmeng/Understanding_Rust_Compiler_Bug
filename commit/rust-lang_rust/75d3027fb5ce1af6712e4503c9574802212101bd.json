{"sha": "75d3027fb5ce1af6712e4503c9574802212101bd", "node_id": "C_kwDOAAsO6NoAKDc1ZDMwMjdmYjVjZTFhZjY3MTJlNDUwM2M5NTc0ODAyMjEyMTAxYmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-30T14:16:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-30T14:16:57Z"}, "message": "Auto merge of #102484 - beetrees:duration-debug-bug-fix, r=scottmcm\n\nFix integer overflow in `format!(\"{:.0?}\", Duration::MAX)`\n\nCurrently `format!(\"{:.0?}\", Duration::MAX)` causes an integer overflow in the `Duration` `Debug` impl ([playground link](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=67675c6895bdb2e37ee727f0ed7622b2)). This is because the carry from the rounding of the fractional_part into the integer_part will cause the integer_part to overflow as it is already `u64::MAX`. This PR uses a larger integer type to avoid that issue, and adds a test for the correct behaviour.", "tree": {"sha": "3d5e1220422011356bf844bdc5e89561514b1774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d5e1220422011356bf844bdc5e89561514b1774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75d3027fb5ce1af6712e4503c9574802212101bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75d3027fb5ce1af6712e4503c9574802212101bd", "html_url": "https://github.com/rust-lang/rust/commit/75d3027fb5ce1af6712e4503c9574802212101bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75d3027fb5ce1af6712e4503c9574802212101bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f914b82a754c6d85c0a909ab152f5b611defef73", "url": "https://api.github.com/repos/rust-lang/rust/commits/f914b82a754c6d85c0a909ab152f5b611defef73", "html_url": "https://github.com/rust-lang/rust/commit/f914b82a754c6d85c0a909ab152f5b611defef73"}, {"sha": "e409ce2159e97514178633771dfd9eb05fc4327f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e409ce2159e97514178633771dfd9eb05fc4327f", "html_url": "https://github.com/rust-lang/rust/commit/e409ce2159e97514178633771dfd9eb05fc4327f"}], "stats": {"total": 63, "additions": 52, "deletions": 11}, "files": [{"sha": "1d0c51c3c8368fb69b4fd22127945a155dc11015", "filename": "library/core/src/time.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/75d3027fb5ce1af6712e4503c9574802212101bd/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d3027fb5ce1af6712e4503c9574802212101bd/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=75d3027fb5ce1af6712e4503c9574802212101bd", "patch": "@@ -1043,7 +1043,7 @@ impl fmt::Debug for Duration {\n         /// to the formatter's `width`, if specified.\n         fn fmt_decimal(\n             f: &mut fmt::Formatter<'_>,\n-            mut integer_part: u64,\n+            integer_part: u64,\n             mut fractional_part: u32,\n             mut divisor: u32,\n             prefix: &str,\n@@ -1075,7 +1075,7 @@ impl fmt::Debug for Duration {\n             // normal floating point numbers. However, we only need to do work\n             // when rounding up. This happens if the first digit of the\n             // remaining ones is >= 5.\n-            if fractional_part > 0 && fractional_part >= divisor * 5 {\n+            let integer_part = if fractional_part > 0 && fractional_part >= divisor * 5 {\n                 // Round up the number contained in the buffer. We go through\n                 // the buffer backwards and keep track of the carry.\n                 let mut rev_pos = pos;\n@@ -1099,9 +1099,18 @@ impl fmt::Debug for Duration {\n                 // the whole buffer to '0's and need to increment the integer\n                 // part.\n                 if carry {\n-                    integer_part += 1;\n+                    // If `integer_part == u64::MAX` and precision < 9, any\n+                    // carry of the overflow during rounding of the\n+                    // `fractional_part` into the `integer_part` will cause the\n+                    // `integer_part` itself to overflow. Avoid this by using an\n+                    // `Option<u64>`, with `None` representing `u64::MAX + 1`.\n+                    integer_part.checked_add(1)\n+                } else {\n+                    Some(integer_part)\n                 }\n-            }\n+            } else {\n+                Some(integer_part)\n+            };\n \n             // Determine the end of the buffer: if precision is set, we just\n             // use as many digits from the buffer (capped to 9). If it isn't\n@@ -1111,7 +1120,12 @@ impl fmt::Debug for Duration {\n             // This closure emits the formatted duration without emitting any\n             // padding (padding is calculated below).\n             let emit_without_padding = |f: &mut fmt::Formatter<'_>| {\n-                write!(f, \"{}{}\", prefix, integer_part)?;\n+                if let Some(integer_part) = integer_part {\n+                    write!(f, \"{}{}\", prefix, integer_part)?;\n+                } else {\n+                    // u64::MAX + 1 == 18446744073709551616\n+                    write!(f, \"{}18446744073709551616\", prefix)?;\n+                }\n \n                 // Write the decimal point and the fractional part (if any).\n                 if end > 0 {\n@@ -1141,12 +1155,17 @@ impl fmt::Debug for Duration {\n                     // 2. The postfix: can be \"\u00b5s\" so we have to count UTF8 characters.\n                     let mut actual_w = prefix.len() + postfix.chars().count();\n                     // 3. The integer part:\n-                    if let Some(log) = integer_part.checked_ilog10() {\n-                        // integer_part is > 0, so has length log10(x)+1\n-                        actual_w += 1 + log as usize;\n+                    if let Some(integer_part) = integer_part {\n+                        if let Some(log) = integer_part.checked_ilog10() {\n+                            // integer_part is > 0, so has length log10(x)+1\n+                            actual_w += 1 + log as usize;\n+                        } else {\n+                            // integer_part is 0, so has length 1.\n+                            actual_w += 1;\n+                        }\n                     } else {\n-                        // integer_part is 0, so has length 1.\n-                        actual_w += 1;\n+                        // integer_part is u64::MAX + 1, so has length 20\n+                        actual_w += 20;\n                     }\n                     // 4. The fractional part (if any):\n                     if end > 0 {"}, {"sha": "697bf33a8b0daeba0ac2177b9e7a8185bbc16ea1", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75d3027fb5ce1af6712e4503c9574802212101bd/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d3027fb5ce1af6712e4503c9574802212101bd/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=75d3027fb5ce1af6712e4503c9574802212101bd", "patch": "@@ -197,9 +197,31 @@ fn correct_sum() {\n #[test]\n fn debug_formatting_extreme_values() {\n     assert_eq!(\n-        format!(\"{:?}\", Duration::new(18_446_744_073_709_551_615, 123_456_789)),\n+        format!(\"{:?}\", Duration::new(u64::MAX, 123_456_789)),\n         \"18446744073709551615.123456789s\"\n     );\n+    assert_eq!(format!(\"{:.0?}\", Duration::MAX), \"18446744073709551616s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(u64::MAX, 500_000_000)), \"18446744073709551616s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(u64::MAX, 499_999_999)), \"18446744073709551615s\");\n+    assert_eq!(\n+        format!(\"{:.3?}\", Duration::new(u64::MAX, 999_500_000)),\n+        \"18446744073709551616.000s\"\n+    );\n+    assert_eq!(\n+        format!(\"{:.3?}\", Duration::new(u64::MAX, 999_499_999)),\n+        \"18446744073709551615.999s\"\n+    );\n+    assert_eq!(\n+        format!(\"{:.8?}\", Duration::new(u64::MAX, 999_999_995)),\n+        \"18446744073709551616.00000000s\"\n+    );\n+    assert_eq!(\n+        format!(\"{:.8?}\", Duration::new(u64::MAX, 999_999_994)),\n+        \"18446744073709551615.99999999s\"\n+    );\n+    assert_eq!(format!(\"{:21.0?}\", Duration::MAX), \"18446744073709551616s\");\n+    assert_eq!(format!(\"{:22.0?}\", Duration::MAX), \"18446744073709551616s \");\n+    assert_eq!(format!(\"{:24.0?}\", Duration::MAX), \"18446744073709551616s   \");\n }\n \n #[test]"}]}