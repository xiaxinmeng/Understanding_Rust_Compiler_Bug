{"sha": "18bfe2a66beb79f912f8d1e344dda5f054cdd9c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YmZlMmE2NmJlYjc5ZjkxMmY4ZDFlMzQ0ZGRhNWYwNTRjZGQ5YzM=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-10-07T21:07:04Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-13T21:38:27Z"}, "message": "move copy specialization tests to their own module", "tree": {"sha": "53d2832fd0d9751b06619ad99d683a0d9e4320fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53d2832fd0d9751b06619ad99d683a0d9e4320fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3", "html_url": "https://github.com/rust-lang/rust/commit/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5d2722afea902e89e44062765733c4800b7d21", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5d2722afea902e89e44062765733c4800b7d21", "html_url": "https://github.com/rust-lang/rust/commit/7f5d2722afea902e89e44062765733c4800b7d21"}], "stats": {"total": 363, "additions": 182, "deletions": 181}, "files": [{"sha": "db47ba97fe4b63ff8a8456ac6baf29ce7a328d9a", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=18bfe2a66beb79f912f8d1e344dda5f054cdd9c3", "patch": "@@ -1,6 +1,9 @@\n use crate::io::{self, ErrorKind, Read, Write};\n use crate::mem::MaybeUninit;\n \n+#[cfg(all(test, unix))]\n+mod tests;\n+\n /// Copies the entire contents of a reader into a writer.\n ///\n /// This function will continuously read data from `reader` and then"}, {"sha": "fcff5fa934d1c23b40a82fba168121e990408b50", "filename": "library/std/src/io/copy/tests.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3/library%2Fstd%2Fsrc%2Fio%2Fcopy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3/library%2Fstd%2Fsrc%2Fio%2Fcopy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy%2Ftests.rs?ref=18bfe2a66beb79f912f8d1e344dda5f054cdd9c3", "patch": "@@ -0,0 +1,179 @@\n+use crate::env::temp_dir;\n+use crate::fs::OpenOptions;\n+use crate::io;\n+use crate::io::Result;\n+use crate::io::SeekFrom;\n+use crate::io::{BufRead, Read, Seek, Write};\n+use crate::os::unix::io::AsRawFd;\n+\n+#[test]\n+fn copy_specialization() -> Result<()> {\n+    use crate::io::{BufReader, BufWriter};\n+\n+    let path = crate::env::temp_dir();\n+    let source_path = path.join(\"copy-spec.source\");\n+    let sink_path = path.join(\"copy-spec.sink\");\n+\n+    let result: Result<()> = try {\n+        let mut source = crate::fs::OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(true)\n+            .truncate(true)\n+            .open(&source_path)?;\n+        source.write_all(b\"abcdefghiklmnopqr\")?;\n+        source.seek(SeekFrom::Start(8))?;\n+        let mut source = BufReader::with_capacity(8, source.take(5));\n+        source.fill_buf()?;\n+        assert_eq!(source.buffer(), b\"iklmn\");\n+        source.get_mut().set_limit(6);\n+        source.get_mut().get_mut().seek(SeekFrom::Start(1))?; // \"bcdefg\"\n+        let mut source = source.take(10); // \"iklmnbcdef\"\n+\n+        let mut sink = crate::fs::OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(true)\n+            .truncate(true)\n+            .open(&sink_path)?;\n+        sink.write_all(b\"000000\")?;\n+        let mut sink = BufWriter::with_capacity(5, sink);\n+        sink.write_all(b\"wxyz\")?;\n+        assert_eq!(sink.buffer(), b\"wxyz\");\n+\n+        let copied = crate::io::copy(&mut source, &mut sink)?;\n+        assert_eq!(copied, 10);\n+        assert_eq!(sink.buffer().len(), 0);\n+\n+        let mut sink = sink.into_inner()?;\n+        sink.seek(SeekFrom::Start(0))?;\n+        let mut copied = Vec::new();\n+        sink.read_to_end(&mut copied)?;\n+        assert_eq!(&copied, b\"000000wxyziklmnbcdef\");\n+    };\n+\n+    let rm1 = crate::fs::remove_file(source_path);\n+    let rm2 = crate::fs::remove_file(sink_path);\n+\n+    result.and(rm1).and(rm2)\n+}\n+\n+#[bench]\n+fn bench_file_to_file_copy(b: &mut test::Bencher) {\n+    const BYTES: usize = 128 * 1024;\n+    let src_path = temp_dir().join(\"file-copy-bench-src\");\n+    let mut src = crate::fs::OpenOptions::new()\n+        .create(true)\n+        .truncate(true)\n+        .read(true)\n+        .write(true)\n+        .open(src_path)\n+        .unwrap();\n+    src.write(&vec![0u8; BYTES]).unwrap();\n+\n+    let sink_path = temp_dir().join(\"file-copy-bench-sink\");\n+    let mut sink = crate::fs::OpenOptions::new()\n+        .create(true)\n+        .truncate(true)\n+        .write(true)\n+        .open(sink_path)\n+        .unwrap();\n+\n+    b.bytes = BYTES as u64;\n+    b.iter(|| {\n+        src.seek(SeekFrom::Start(0)).unwrap();\n+        sink.seek(SeekFrom::Start(0)).unwrap();\n+        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n+    });\n+}\n+\n+#[bench]\n+fn bench_file_to_socket_copy(b: &mut test::Bencher) {\n+    const BYTES: usize = 128 * 1024;\n+    let src_path = temp_dir().join(\"pipe-copy-bench-src\");\n+    let mut src = OpenOptions::new()\n+        .create(true)\n+        .truncate(true)\n+        .read(true)\n+        .write(true)\n+        .open(src_path)\n+        .unwrap();\n+    src.write(&vec![0u8; BYTES]).unwrap();\n+\n+    let sink_drainer = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n+    let mut sink = crate::net::TcpStream::connect(sink_drainer.local_addr().unwrap()).unwrap();\n+    let mut sink_drainer = sink_drainer.accept().unwrap().0;\n+\n+    crate::thread::spawn(move || {\n+        let mut sink_buf = vec![0u8; 1024 * 1024];\n+        loop {\n+            sink_drainer.read(&mut sink_buf[..]).unwrap();\n+        }\n+    });\n+\n+    b.bytes = BYTES as u64;\n+    b.iter(|| {\n+        src.seek(SeekFrom::Start(0)).unwrap();\n+        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n+    });\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+#[bench]\n+fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n+    use crate::io::ErrorKind;\n+    use crate::process::{ChildStdin, ChildStdout};\n+    use crate::sys_common::FromInner;\n+\n+    let (read_end, write_end) = crate::sys::pipe::anon_pipe().unwrap();\n+\n+    let mut read_end = ChildStdout::from_inner(read_end);\n+    let write_end = ChildStdin::from_inner(write_end);\n+\n+    let acceptor = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n+    let mut remote_end = crate::net::TcpStream::connect(acceptor.local_addr().unwrap()).unwrap();\n+\n+    let local_end = crate::sync::Arc::new(acceptor.accept().unwrap().0);\n+\n+    crate::thread::spawn(move || {\n+        let mut sink_buf = vec![0u8; 1024 * 1024];\n+        remote_end.set_nonblocking(true).unwrap();\n+        loop {\n+            match remote_end.write(&mut sink_buf[..]) {\n+                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n+                Ok(_) => {}\n+                err => {\n+                    err.expect(\"write failed\");\n+                }\n+            };\n+            match remote_end.read(&mut sink_buf[..]) {\n+                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n+                Ok(_) => {}\n+                err => {\n+                    err.expect(\"read failed\");\n+                }\n+            };\n+        }\n+    });\n+\n+    let local_source = local_end.clone();\n+    crate::thread::spawn(move || {\n+        loop {\n+            crate::sys::fs::sendfile_splice(\n+                crate::sys::fs::SpliceMode::Splice,\n+                local_source.as_raw_fd(),\n+                write_end.as_raw_fd(),\n+                u64::MAX,\n+            );\n+        }\n+    });\n+\n+    const BYTES: usize = 128 * 1024;\n+    b.bytes = BYTES as u64;\n+    b.iter(|| {\n+        assert_eq!(\n+            BYTES as u64,\n+            io::copy(&mut (&mut read_end).take(BYTES as u64), &mut &*local_end).unwrap()\n+        );\n+    });\n+}"}, {"sha": "f176c2f088cb314e850d11057fbd3f4f120b5773", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe2a66beb79f912f8d1e344dda5f054cdd9c3/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=18bfe2a66beb79f912f8d1e344dda5f054cdd9c3", "patch": "@@ -1,15 +1,8 @@\n use super::{repeat, Cursor, SeekFrom};\n use crate::cmp::{self, min};\n-use crate::env::temp_dir;\n-#[cfg(unix)]\n-use crate::fs::OpenOptions;\n-#[cfg(unix)]\n-use crate::io::Result;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::io::{BufRead, Read, Seek, Write};\n use crate::ops::Deref;\n-#[cfg(unix)]\n-use crate::os::unix::io::AsRawFd;\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n@@ -499,177 +492,3 @@ fn test_write_all_vectored() {\n         }\n     }\n }\n-\n-#[test]\n-#[cfg(unix)]\n-fn copy_specialization() -> Result<()> {\n-    use crate::io::{BufReader, BufWriter};\n-\n-    let path = crate::env::temp_dir();\n-    let source_path = path.join(\"copy-spec.source\");\n-    let sink_path = path.join(\"copy-spec.sink\");\n-\n-    let result: Result<()> = try {\n-        let mut source = crate::fs::OpenOptions::new()\n-            .read(true)\n-            .write(true)\n-            .create(true)\n-            .truncate(true)\n-            .open(&source_path)?;\n-        source.write_all(b\"abcdefghiklmnopqr\")?;\n-        source.seek(SeekFrom::Start(8))?;\n-        let mut source = BufReader::with_capacity(8, source.take(5));\n-        source.fill_buf()?;\n-        assert_eq!(source.buffer(), b\"iklmn\");\n-        source.get_mut().set_limit(6);\n-        source.get_mut().get_mut().seek(SeekFrom::Start(1))?; // \"bcdefg\"\n-        let mut source = source.take(10); // \"iklmnbcdef\"\n-\n-        let mut sink = crate::fs::OpenOptions::new()\n-            .read(true)\n-            .write(true)\n-            .create(true)\n-            .truncate(true)\n-            .open(&sink_path)?;\n-        sink.write_all(b\"000000\")?;\n-        let mut sink = BufWriter::with_capacity(5, sink);\n-        sink.write_all(b\"wxyz\")?;\n-        assert_eq!(sink.buffer(), b\"wxyz\");\n-\n-        let copied = crate::io::copy(&mut source, &mut sink)?;\n-        assert_eq!(copied, 10);\n-        assert_eq!(sink.buffer().len(), 0);\n-\n-        let mut sink = sink.into_inner()?;\n-        sink.seek(SeekFrom::Start(0))?;\n-        let mut copied = Vec::new();\n-        sink.read_to_end(&mut copied)?;\n-        assert_eq!(&copied, b\"000000wxyziklmnbcdef\");\n-    };\n-\n-    let rm1 = crate::fs::remove_file(source_path);\n-    let rm2 = crate::fs::remove_file(sink_path);\n-\n-    result.and(rm1).and(rm2)\n-}\n-\n-#[bench]\n-fn bench_file_to_file_copy(b: &mut test::Bencher) {\n-    const BYTES: usize = 128 * 1024;\n-    let src_path = temp_dir().join(\"file-copy-bench-src\");\n-    let mut src = crate::fs::OpenOptions::new()\n-        .create(true)\n-        .truncate(true)\n-        .read(true)\n-        .write(true)\n-        .open(src_path)\n-        .unwrap();\n-    src.write(&vec![0u8; BYTES]).unwrap();\n-\n-    let sink_path = temp_dir().join(\"file-copy-bench-sink\");\n-    let mut sink = crate::fs::OpenOptions::new()\n-        .create(true)\n-        .truncate(true)\n-        .write(true)\n-        .open(sink_path)\n-        .unwrap();\n-\n-    b.bytes = BYTES as u64;\n-    b.iter(|| {\n-        src.seek(SeekFrom::Start(0)).unwrap();\n-        sink.seek(SeekFrom::Start(0)).unwrap();\n-        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n-    });\n-}\n-\n-#[cfg(unix)]\n-#[bench]\n-fn bench_file_to_socket_copy(b: &mut test::Bencher) {\n-    const BYTES: usize = 128 * 1024;\n-    let src_path = temp_dir().join(\"pipe-copy-bench-src\");\n-    let mut src = OpenOptions::new()\n-        .create(true)\n-        .truncate(true)\n-        .read(true)\n-        .write(true)\n-        .open(src_path)\n-        .unwrap();\n-    src.write(&vec![0u8; BYTES]).unwrap();\n-\n-    let sink_drainer = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n-    let mut sink = crate::net::TcpStream::connect(sink_drainer.local_addr().unwrap()).unwrap();\n-    let mut sink_drainer = sink_drainer.accept().unwrap().0;\n-\n-    crate::thread::spawn(move || {\n-        let mut sink_buf = vec![0u8; 1024 * 1024];\n-        loop {\n-            sink_drainer.read(&mut sink_buf[..]).unwrap();\n-        }\n-    });\n-\n-    b.bytes = BYTES as u64;\n-    b.iter(|| {\n-        src.seek(SeekFrom::Start(0)).unwrap();\n-        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n-    });\n-}\n-\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-#[bench]\n-fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n-    use crate::io::ErrorKind;\n-    use crate::process::{ChildStdin, ChildStdout};\n-    use crate::sys_common::FromInner;\n-\n-    let (read_end, write_end) = crate::sys::pipe::anon_pipe().unwrap();\n-\n-    let mut read_end = ChildStdout::from_inner(read_end);\n-    let write_end = ChildStdin::from_inner(write_end);\n-\n-    let acceptor = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n-    let mut remote_end = crate::net::TcpStream::connect(acceptor.local_addr().unwrap()).unwrap();\n-\n-    let local_end = crate::sync::Arc::new(acceptor.accept().unwrap().0);\n-\n-    crate::thread::spawn(move || {\n-        let mut sink_buf = vec![0u8; 1024 * 1024];\n-        remote_end.set_nonblocking(true).unwrap();\n-        loop {\n-            match remote_end.write(&mut sink_buf[..]) {\n-                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n-                Ok(_) => {}\n-                err => {\n-                    err.expect(\"write failed\");\n-                }\n-            };\n-            match remote_end.read(&mut sink_buf[..]) {\n-                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n-                Ok(_) => {}\n-                err => {\n-                    err.expect(\"read failed\");\n-                }\n-            };\n-        }\n-    });\n-\n-    let local_source = local_end.clone();\n-    crate::thread::spawn(move || {\n-        loop {\n-            crate::sys::fs::sendfile_splice(\n-                crate::sys::fs::SpliceMode::Splice,\n-                local_source.as_raw_fd(),\n-                write_end.as_raw_fd(),\n-                u64::MAX,\n-            );\n-        }\n-    });\n-\n-    const BYTES: usize = 128 * 1024;\n-    b.bytes = BYTES as u64;\n-    b.iter(|| {\n-        assert_eq!(\n-            BYTES as u64,\n-            io::copy(&mut (&mut read_end).take(BYTES as u64), &mut &*local_end).unwrap()\n-        );\n-    });\n-}"}]}