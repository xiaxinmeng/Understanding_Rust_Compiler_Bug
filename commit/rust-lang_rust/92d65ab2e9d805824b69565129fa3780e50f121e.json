{"sha": "92d65ab2e9d805824b69565129fa3780e50f121e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZDY1YWIyZTlkODA1ODI0YjY5NTY1MTI5ZmEzNzgwZTUwZjEyMWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-04T15:48:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T20:23:33Z"}, "message": "Rename various things to \"implications\"", "tree": {"sha": "c7836f23cda5807cd6eb3b0d1f9a5ea240f6f4c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7836f23cda5807cd6eb3b0d1f9a5ea240f6f4c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92d65ab2e9d805824b69565129fa3780e50f121e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92d65ab2e9d805824b69565129fa3780e50f121e", "html_url": "https://github.com/rust-lang/rust/commit/92d65ab2e9d805824b69565129fa3780e50f121e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92d65ab2e9d805824b69565129fa3780e50f121e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df92fe3c964492a22a2c81896b951ef649438e3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/df92fe3c964492a22a2c81896b951ef649438e3b", "html_url": "https://github.com/rust-lang/rust/commit/df92fe3c964492a22a2c81896b951ef649438e3b"}], "stats": {"total": 82, "additions": 36, "deletions": 46}, "files": [{"sha": "5c4ca97ec8e494c680ac074d598c56f393b232e3", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/92d65ab2e9d805824b69565129fa3780e50f121e/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d65ab2e9d805824b69565129fa3780e50f121e/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=92d65ab2e9d805824b69565129fa3780e50f121e", "patch": "@@ -10,8 +10,6 @@\n \n // #![warn(deprecated_mode)]\n \n-pub use self::WfConstraint::*;\n-\n use astconv::object_region_bounds;\n use middle::infer::GenericKind;\n use middle::subst::{ParamSpace, Subst, Substs};\n@@ -24,37 +22,37 @@ use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n-pub enum WfConstraint<'tcx> {\n-    RegionSubRegionConstraint(Option<Ty<'tcx>>, ty::Region, ty::Region),\n-    RegionSubGenericConstraint(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n+pub enum Implication<'tcx> {\n+    RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n+    RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n }\n \n-struct Wf<'a, 'tcx: 'a> {\n+struct Implicator<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n-    out: Vec<WfConstraint<'tcx>>,\n+    out: Vec<Implication<'tcx>>,\n }\n \n /// This routine computes the well-formedness constraints that must hold for the type `ty` to\n /// appear in a context with lifetime `outer_region`\n-pub fn region_wf_constraints<'tcx>(\n+pub fn implications<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     ty: Ty<'tcx>,\n     outer_region: ty::Region)\n-    -> Vec<WfConstraint<'tcx>>\n+    -> Vec<Implication<'tcx>>\n {\n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n-    let mut wf = Wf { tcx: tcx,\n+    let mut wf = Implicator { tcx: tcx,\n                       stack: stack,\n                       out: Vec::new() };\n     wf.accumulate_from_ty(ty);\n     wf.out\n }\n \n-impl<'a, 'tcx> Wf<'a, 'tcx> {\n+impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n-        debug!(\"Wf::accumulate_from_ty(ty={})\",\n+        debug!(\"accumulate_from_ty(ty={})\",\n                ty.repr(self.tcx));\n \n         match ty.sty {\n@@ -197,7 +195,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                                   opt_ty: Option<Ty<'tcx>>,\n                                   r_a: ty::Region,\n                                   r_b: ty::Region) {\n-        self.out.push(RegionSubRegionConstraint(opt_ty, r_a, r_b));\n+        self.out.push(Implication::RegionSubRegion(opt_ty, r_a, r_b));\n     }\n \n     /// Pushes a constraint that `param_ty` must outlive the top region on the stack.\n@@ -211,7 +209,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     fn push_projection_constraint_from_top(&mut self,\n                                            projection_ty: &ty::ProjectionTy<'tcx>) {\n         let &(region, opt_ty) = self.stack.last().unwrap();\n-        self.out.push(RegionSubGenericConstraint(\n+        self.out.push(Implication::RegionSubGeneric(\n             opt_ty, region, GenericKind::Projection(projection_ty.clone())));\n     }\n \n@@ -220,7 +218,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                              region: ty::Region,\n                              opt_ty: Option<Ty<'tcx>>,\n                              param_ty: ty::ParamTy) {\n-        self.out.push(RegionSubGenericConstraint(\n+        self.out.push(Implication::RegionSubGeneric(\n             opt_ty, region, GenericKind::Param(param_ty)));\n     }\n \n@@ -372,22 +370,22 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         for &r_d in &required_region_bounds {\n             // Each of these is an instance of the `'c <= 'b`\n             // constraint above\n-            self.out.push(RegionSubRegionConstraint(Some(ty), r_d, r_c));\n+            self.out.push(Implication::RegionSubRegion(Some(ty), r_d, r_c));\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for WfConstraint<'tcx> {\n+impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            RegionSubRegionConstraint(_, ref r_a, ref r_b) => {\n-                format!(\"RegionSubRegionConstraint({}, {})\",\n+            Implication::RegionSubRegion(_, ref r_a, ref r_b) => {\n+                format!(\"RegionSubRegion({}, {})\",\n                         r_a.repr(tcx),\n                         r_b.repr(tcx))\n             }\n \n-            RegionSubGenericConstraint(_, ref r, ref p) => {\n-                format!(\"RegionSubGenericConstraint({}, {})\",\n+            Implication::RegionSubGeneric(_, ref r, ref p) => {\n+                format!(\"RegionSubGeneric({}, {})\",\n                         r.repr(tcx),\n                         p.repr(tcx))\n             }"}, {"sha": "72ea0961e05e999c7c1e5331f0cdfcd7430c7df5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/92d65ab2e9d805824b69565129fa3780e50f121e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d65ab2e9d805824b69565129fa3780e50f121e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=92d65ab2e9d805824b69565129fa3780e50f121e", "patch": "@@ -335,25 +335,21 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n-            let constraints =\n-                implicator::region_wf_constraints(\n-                    tcx,\n-                    ty,\n-                    body_scope);\n-            for constraint in &constraints {\n-                debug!(\"constraint: {}\", constraint.repr(tcx));\n-                match *constraint {\n-                    implicator::RegionSubRegionConstraint(_,\n+            let implications = implicator::implications(tcx, ty, body_scope);\n+            for implication in implications {\n+                debug!(\"implication: {}\", implication.repr(tcx));\n+                match implication {\n+                    implicator::Implication::RegionSubRegion(_,\n                                               ty::ReFree(free_a),\n                                               ty::ReFree(free_b)) => {\n                         tcx.region_maps.relate_free_regions(free_a, free_b);\n                     }\n-                    implicator::RegionSubRegionConstraint(_,\n+                    implicator::Implication::RegionSubRegion(_,\n                                               ty::ReFree(free_a),\n                                               ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n-                    implicator::RegionSubRegionConstraint(..) => {\n+                    implicator::Implication::RegionSubRegion(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n@@ -364,8 +360,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         // relationship that arises here, but\n                         // presently we do not.)\n                     }\n-                    implicator::RegionSubGenericConstraint(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGenericConstraint: {} <= {}\",\n+                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n+                        debug!(\"RegionSubGeneric: {} <= {}\",\n                                r_a.repr(tcx), generic_b.repr(tcx));\n \n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n@@ -1481,25 +1477,21 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            ty.repr(rcx.tcx()),\n            region.repr(rcx.tcx()));\n \n-    let constraints =\n-        implicator::region_wf_constraints(\n-            rcx.tcx(),\n-            ty,\n-            region);\n-    for constraint in &constraints {\n-        debug!(\"constraint: {}\", constraint.repr(rcx.tcx()));\n-        match *constraint {\n-            implicator::RegionSubRegionConstraint(None, r_a, r_b) => {\n+    let implications = implicator::implications(rcx.tcx(), ty, region);\n+    for implication in implications {\n+        debug!(\"implication: {}\", implication.repr(rcx.tcx()));\n+        match implication {\n+            implicator::Implication::RegionSubRegion(None, r_a, r_b) => {\n                 rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n             }\n-            implicator::RegionSubRegionConstraint(Some(ty), r_a, r_b) => {\n+            implicator::Implication::RegionSubRegion(Some(ty), r_a, r_b) => {\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 rcx.fcx.mk_subr(o1, r_a, r_b);\n             }\n-            implicator::RegionSubGenericConstraint(None, r_a, ref generic_b) => {\n+            implicator::Implication::RegionSubGeneric(None, r_a, ref generic_b) => {\n                 generic_must_outlive(rcx, origin.clone(), r_a, generic_b);\n             }\n-            implicator::RegionSubGenericConstraint(Some(ty), r_a, ref generic_b) => {\n+            implicator::Implication::RegionSubGeneric(Some(ty), r_a, ref generic_b) => {\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 generic_must_outlive(rcx, o1, r_a, generic_b);\n             }"}]}