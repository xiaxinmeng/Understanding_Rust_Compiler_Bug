{"sha": "97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZjBhOWVmOGQzYTU2M2VlYWUxOTY2ZmY1NTQ5NDAwNzgzZDhlMWY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-25T18:28:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-25T18:28:08Z"}, "message": "Rollup merge of #70226 - RalfJung:checked, r=oli-obk\n\nuse checked casts and arithmetic in Miri engine\n\nThis is unfortunately pretty annoying because we have to cast back and forth between `u64` and `usize` more often that should be necessary, and that cast is considered fallible.\n\nFor example, should [this](https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/interpret/value/enum.ConstValue.html) really be `usize`?\n\nAlso, `LayoutDetails` uses `usize` for field indices, but in Miri we use `u64` to be able to also handle array indexing. Maybe methods like `mplace_field` should be suitably generalized to accept both `u64` and `usize`?\n\nr? @oli-obk Cc @eddyb", "tree": {"sha": "7a59fa534aabe9993c1f11ba6136d4f550bb2fdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a59fa534aabe9993c1f11ba6136d4f550bb2fdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJee6K4CRBK7hj4Ov3rIwAAdHIIAEShOGZoLcLXiud4bPNY6erf\n5OEkVqeVOakqYeuwWhdGtVmMgnZeclkdfb/7QVydKYR5/lquXhO5Bko7Q6EvE3Nw\n/l0re7Xpx0NMcylNXkuVk0huHqYumc5evAugnJJnJnz+DqjnfkqCCl0ry1kGCoCh\nPw0BZnTvqUEMaA6tnTOtV/meR90W+QlQj8dAvkmMg//dpei6gQMunWB2lCX8Hu61\n6TJmw2SVGrfkeA95kk/V9xE3dBcPnjkh1TxGUPz+VvqSKEv92Oeu1U49c3gKRqPe\n15a3gEea5dWJ/Xhtg9NL2dTCC8TPqPrSf+yoIQ652vIQaS0daFN25gfs7HGf2po=\n=aa9U\n-----END PGP SIGNATURE-----\n", "payload": "tree 7a59fa534aabe9993c1f11ba6136d4f550bb2fdf\nparent 3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8\nparent 7400955e941a3958b1560f2cb0b7648535d2f9d0\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585160888 +0100\ncommitter GitHub <noreply@github.com> 1585160888 +0100\n\nRollup merge of #70226 - RalfJung:checked, r=oli-obk\n\nuse checked casts and arithmetic in Miri engine\n\nThis is unfortunately pretty annoying because we have to cast back and forth between `u64` and `usize` more often that should be necessary, and that cast is considered fallible.\n\nFor example, should [this](https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/interpret/value/enum.ConstValue.html) really be `usize`?\n\nAlso, `LayoutDetails` uses `usize` for field indices, but in Miri we use `u64` to be able to also handle array indexing. Maybe methods like `mplace_field` should be suitably generalized to accept both `u64` and `usize`?\n\nr? @oli-obk Cc @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "html_url": "https://github.com/rust-lang/rust/commit/97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "html_url": "https://github.com/rust-lang/rust/commit/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8"}, {"sha": "7400955e941a3958b1560f2cb0b7648535d2f9d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7400955e941a3958b1560f2cb0b7648535d2f9d0", "html_url": "https://github.com/rust-lang/rust/commit/7400955e941a3958b1560f2cb0b7648535d2f9d0"}], "stats": {"total": 617, "additions": 337, "deletions": 280}, "files": [{"sha": "26b9e1be2f5d4542d1896f3e77fe6098356c3b1e", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,18 +1,20 @@\n //! The virtual memory representation of the MIR interpreter.\n \n+use std::borrow::Cow;\n+use std::convert::TryFrom;\n+use std::iter;\n+use std::ops::{Deref, DerefMut, Range};\n+\n+use rustc_ast::ast::Mutability;\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n+\n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUndef,\n };\n \n use crate::ty::layout::{Align, Size};\n \n-use rustc_ast::ast::Mutability;\n-use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_target::abi::HasDataLayout;\n-use std::borrow::Cow;\n-use std::iter;\n-use std::ops::{Deref, DerefMut, Range};\n-\n // NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n // `src/librustc_mir/interpret/snapshot.rs`.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -90,7 +92,7 @@ impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let size = Size::from_bytes(bytes.len() as u64);\n+        let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n@@ -107,9 +109,8 @@ impl<Tag> Allocation<Tag> {\n     }\n \n     pub fn undef(size: Size, align: Align) -> Self {\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n-            bytes: vec![0; size.bytes() as usize],\n+            bytes: vec![0; size.bytes_usize()],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n             size,\n@@ -152,7 +153,7 @@ impl Allocation<(), ()> {\n /// Raw accessors. Provide access to otherwise private bytes.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     pub fn len(&self) -> usize {\n-        self.size.bytes() as usize\n+        self.size.bytes_usize()\n     }\n \n     /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n@@ -183,20 +184,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     #[inline]\n     fn check_bounds(&self, offset: Size, size: Size) -> Range<usize> {\n         let end = offset + size; // This does overflow checking.\n-        assert_eq!(\n-            end.bytes() as usize as u64,\n-            end.bytes(),\n-            \"cannot handle this access on this host architecture\"\n-        );\n-        let end = end.bytes() as usize;\n+        let end = usize::try_from(end.bytes()).expect(\"access too big for this host architecture\");\n         assert!(\n             end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n             offset.bytes(),\n             size.bytes(),\n             self.len()\n         );\n-        (offset.bytes() as usize)..end\n+        offset.bytes_usize()..end\n     }\n \n     /// The last argument controls whether we error out when there are undefined\n@@ -294,11 +290,10 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n+        let offset = ptr.offset.bytes_usize();\n         Ok(match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n-                let size_with_null = Size::from_bytes((size + 1) as u64);\n+                let size_with_null = Size::from_bytes(size) + Size::from_bytes(1);\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result, so we do subslicing.\n@@ -343,7 +338,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let (lower, upper) = src.size_hint();\n         let len = upper.expect(\"can only write bounded iterators\");\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len as u64))?;\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {\n@@ -386,7 +381,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         } else {\n             match self.relocations.get(&ptr.offset) {\n                 Some(&(tag, alloc_id)) => {\n-                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits as u64), tag);\n+                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n                     return Ok(ScalarMaybeUndef::Scalar(ptr.into()));\n                 }\n                 None => {}\n@@ -433,7 +428,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         };\n \n         let bytes = match val.to_bits_or_ptr(type_size, cx) {\n-            Err(val) => val.offset.bytes() as u128,\n+            Err(val) => u128::from(val.offset.bytes()),\n             Ok(data) => data,\n         };\n \n@@ -524,7 +519,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n             )\n         };\n         let start = ptr.offset;\n-        let end = start + size;\n+        let end = start + size; // `Size` addition\n \n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n@@ -563,7 +558,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     #[inline]\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.undef_mask\n-            .is_range_defined(ptr.offset, ptr.offset + size)\n+            .is_range_defined(ptr.offset, ptr.offset + size) // `Size` addition\n             .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n \n@@ -643,7 +638,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         if defined.ranges.len() <= 1 {\n             self.undef_mask.set_range_inbounds(\n                 dest.offset,\n-                dest.offset + size * repeat,\n+                dest.offset + size * repeat, // `Size` operations\n                 defined.initial,\n             );\n             return;\n@@ -721,10 +716,10 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         for i in 0..length {\n             new_relocations.extend(relocations.iter().map(|&(offset, reloc)| {\n                 // compute offset for current repetition\n-                let dest_offset = dest.offset + (i * size);\n+                let dest_offset = dest.offset + size * i; // `Size` operations\n                 (\n                     // shift offsets from source allocation to destination allocation\n-                    offset + dest_offset - src.offset,\n+                    (offset + dest_offset) - src.offset, // `Size` operations\n                     reloc,\n                 )\n             }));\n@@ -861,18 +856,18 @@ impl UndefMask {\n         if amount.bytes() == 0 {\n             return;\n         }\n-        let unused_trailing_bits = self.blocks.len() as u64 * Self::BLOCK_SIZE - self.len.bytes();\n+        let unused_trailing_bits =\n+            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n         if amount.bytes() > unused_trailing_bits {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n-            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n                 // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n-                iter::repeat(0).take(additional_blocks as usize),\n+                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n             );\n         }\n         let start = self.len;\n         self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state);\n+        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n     }\n }\n \n@@ -881,7 +876,5 @@ fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n     let a = bits / UndefMask::BLOCK_SIZE;\n     let b = bits % UndefMask::BLOCK_SIZE;\n-    assert_eq!(a as usize as u64, a);\n-    assert_eq!(b as usize as u64, b);\n-    (a as usize, b as usize)\n+    (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n }"}, {"sha": "10c3a06da081063be927307c4606c897325c08b2", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -95,6 +95,27 @@ mod pointer;\n mod queries;\n mod value;\n \n+use std::convert::TryFrom;\n+use std::fmt;\n+use std::io;\n+use std::num::NonZeroU32;\n+use std::sync::atomic::{AtomicU32, Ordering};\n+\n+use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{HashMapExt, Lock};\n+use rustc_data_structures::tiny_list::TinyList;\n+use rustc_hir::def_id::DefId;\n+use rustc_macros::HashStable;\n+use rustc_serialize::{Decodable, Encodable, Encoder};\n+\n+use crate::mir;\n+use crate::ty::codec::TyDecoder;\n+use crate::ty::layout::{self, Size};\n+use crate::ty::subst::GenericArgKind;\n+use crate::ty::{self, Instance, Ty, TyCtxt};\n+\n pub use self::error::{\n     struct_error, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled, FrameInfo,\n     InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n@@ -107,24 +128,6 @@ pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n pub use self::pointer::{CheckInAllocMsg, Pointer, PointerArithmetic};\n \n-use crate::mir;\n-use crate::ty::codec::TyDecoder;\n-use crate::ty::layout::{self, Size};\n-use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, Instance, Ty, TyCtxt};\n-use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n-use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{HashMapExt, Lock};\n-use rustc_data_structures::tiny_list::TinyList;\n-use rustc_hir::def_id::DefId;\n-use rustc_macros::HashStable;\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n-use std::fmt;\n-use std::io;\n-use std::num::NonZeroU32;\n-use std::sync::atomic::{AtomicU32, Ordering};\n-\n /// Uniquely identifies one of the following:\n /// - A constant\n /// - A static\n@@ -264,8 +267,8 @@ impl<'s> AllocDecodingSession<'s> {\n         D: TyDecoder<'tcx>,\n     {\n         // Read the index of the allocation.\n-        let idx = decoder.read_u32()? as usize;\n-        let pos = self.state.data_offsets[idx] as usize;\n+        let idx = usize::try_from(decoder.read_u32()?).unwrap();\n+        let pos = usize::try_from(self.state.data_offsets[idx]).unwrap();\n \n         // Decode the `AllocDiscriminant` now so that we know if we have to reserve an\n         // `AllocId`."}, {"sha": "3f841cfb3300326addce2ef4de00ed112433a5db", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -62,9 +62,9 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     /// This should be called by all the other methods before returning!\n     #[inline]\n     fn truncate_to_ptr(&self, (val, over): (u64, bool)) -> (u64, bool) {\n-        let val = val as u128;\n+        let val = u128::from(val);\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n-        ((val % max_ptr_plus_1) as u64, over || val >= max_ptr_plus_1)\n+        (u64::try_from(val % max_ptr_plus_1).unwrap(), over || val >= max_ptr_plus_1)\n     }\n \n     #[inline]\n@@ -73,17 +73,16 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n         self.truncate_to_ptr(res)\n     }\n \n-    // Overflow checking only works properly on the range from -u64 to +u64.\n     #[inline]\n-    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n-        // FIXME: is it possible to over/underflow here?\n+    fn overflowing_signed_offset(&self, val: u64, i: i64) -> (u64, bool) {\n         if i < 0 {\n             // Trickery to ensure that `i64::MIN` works fine: compute `n = -i`.\n             // This formula only works for true negative values; it overflows for zero!\n             let n = u64::MAX - (i as u64) + 1;\n             let res = val.overflowing_sub(n);\n             self.truncate_to_ptr(res)\n         } else {\n+            // `i >= 0`, so the cast is safe.\n             self.overflowing_offset(val, i as u64)\n         }\n     }\n@@ -96,7 +95,7 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n \n     #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n+        let (res, over) = self.overflowing_signed_offset(val, i);\n         if over { throw_ub!(PointerArithOverflow) } else { Ok(res) }\n     }\n }\n@@ -189,14 +188,14 @@ impl<'tcx, Tag> Pointer<Tag> {\n     }\n \n     #[inline]\n-    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n+    pub fn overflowing_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n     #[inline(always)]\n     pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n-        self.overflowing_signed_offset(i128::from(i), cx).0\n+        self.overflowing_signed_offset(i, cx).0\n     }\n \n     #[inline(always)]"}, {"sha": "706cf1cd09a79048898f42c97586f78f9630a55d", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,9 +1,12 @@\n+use std::convert::TryFrom;\n+use std::fmt;\n+\n use rustc_apfloat::{\n     ieee::{Double, Single},\n     Float,\n };\n use rustc_macros::HashStable;\n-use std::fmt;\n+use rustc_target::abi::TargetDataLayout;\n \n use crate::ty::{\n     layout::{HasDataLayout, Size},\n@@ -156,7 +159,7 @@ impl Scalar<()> {\n     #[inline(always)]\n     fn check_data(data: u128, size: u8) {\n         debug_assert_eq!(\n-            truncate(data, Size::from_bytes(size as u64)),\n+            truncate(data, Size::from_bytes(u64::from(size))),\n             data,\n             \"Scalar value {:#x} exceeds size of {} bytes\",\n             data,\n@@ -198,55 +201,54 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Raw { data: 0, size: 0 }\n     }\n \n-    #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        let dl = cx.data_layout();\n+    #[inline(always)]\n+    fn ptr_op(\n+        self,\n+        dl: &TargetDataLayout,\n+        f_int: impl FnOnce(u64) -> InterpResult<'tcx, u64>,\n+        f_ptr: impl FnOnce(Pointer<Tag>) -> InterpResult<'tcx, Pointer<Tag>>,\n+    ) -> InterpResult<'tcx, Self> {\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Ok(Scalar::Raw { data: dl.offset(data as u64, i.bytes())? as u128, size })\n+                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n+                Ok(Scalar::Raw { data: u128::from(f_int(u64::try_from(data).unwrap())?), size })\n             }\n-            Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => Ok(Scalar::Ptr(f_ptr(ptr)?)),\n         }\n     }\n \n+    #[inline]\n+    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n+        let dl = cx.data_layout();\n+        self.ptr_op(dl, |int| dl.offset(int, i.bytes()), |ptr| ptr.offset(i, dl))\n+    }\n+\n     #[inline]\n     pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Raw { data: dl.overflowing_offset(data as u64, i.bytes()).0 as u128, size }\n-            }\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_offset(i, dl)),\n-        }\n+        self.ptr_op(\n+            dl,\n+            |int| Ok(dl.overflowing_offset(int, i.bytes()).0),\n+            |ptr| Ok(ptr.wrapping_offset(i, dl)),\n+        )\n+        .unwrap()\n     }\n \n     #[inline]\n     pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n         let dl = cx.data_layout();\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size().bytes());\n-                Ok(Scalar::Raw { data: dl.signed_offset(data as u64, i)? as u128, size })\n-            }\n-            Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n-        }\n+        self.ptr_op(dl, |int| dl.signed_offset(int, i), |ptr| ptr.signed_offset(i, dl))\n     }\n \n     #[inline]\n     pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Raw {\n-                    data: dl.overflowing_signed_offset(data as u64, i128::from(i)).0 as u128,\n-                    size,\n-                }\n-            }\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, dl)),\n-        }\n+        self.ptr_op(\n+            dl,\n+            |int| Ok(dl.overflowing_signed_offset(int, i).0),\n+            |ptr| Ok(ptr.wrapping_signed_offset(i, dl)),\n+        )\n+        .unwrap()\n     }\n \n     #[inline]\n@@ -281,25 +283,25 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn from_u8(i: u8) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 1 }\n+        Scalar::Raw { data: i.into(), size: 1 }\n     }\n \n     #[inline]\n     pub fn from_u16(i: u16) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 2 }\n+        Scalar::Raw { data: i.into(), size: 2 }\n     }\n \n     #[inline]\n     pub fn from_u32(i: u32) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 4 }\n+        Scalar::Raw { data: i.into(), size: 4 }\n     }\n \n     #[inline]\n     pub fn from_u64(i: u64) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 8 }\n+        Scalar::Raw { data: i.into(), size: 8 }\n     }\n \n     #[inline]\n@@ -376,7 +378,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n+                assert_eq!(target_size.bytes(), u64::from(size));\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n@@ -394,7 +396,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n+                assert_eq!(target_size.bytes(), u64::from(size));\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n@@ -458,27 +460,27 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     /// Converts the scalar to produce an `u8`. Fails if the scalar is a pointer.\n     pub fn to_u8(self) -> InterpResult<'static, u8> {\n-        self.to_unsigned_with_bit_width(8).map(|v| v as u8)\n+        self.to_unsigned_with_bit_width(8).map(|v| u8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u16`. Fails if the scalar is a pointer.\n     pub fn to_u16(self) -> InterpResult<'static, u16> {\n-        self.to_unsigned_with_bit_width(16).map(|v| v as u16)\n+        self.to_unsigned_with_bit_width(16).map(|v| u16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u32`. Fails if the scalar is a pointer.\n     pub fn to_u32(self) -> InterpResult<'static, u32> {\n-        self.to_unsigned_with_bit_width(32).map(|v| v as u32)\n+        self.to_unsigned_with_bit_width(32).map(|v| u32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u64`. Fails if the scalar is a pointer.\n     pub fn to_u64(self) -> InterpResult<'static, u64> {\n-        self.to_unsigned_with_bit_width(64).map(|v| v as u64)\n+        self.to_unsigned_with_bit_width(64).map(|v| u64::try_from(v).unwrap())\n     }\n \n     pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        Ok(b as u64)\n+        Ok(u64::try_from(b).unwrap())\n     }\n \n     #[inline]\n@@ -490,41 +492,41 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     /// Converts the scalar to produce an `i8`. Fails if the scalar is a pointer.\n     pub fn to_i8(self) -> InterpResult<'static, i8> {\n-        self.to_signed_with_bit_width(8).map(|v| v as i8)\n+        self.to_signed_with_bit_width(8).map(|v| i8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i16`. Fails if the scalar is a pointer.\n     pub fn to_i16(self) -> InterpResult<'static, i16> {\n-        self.to_signed_with_bit_width(16).map(|v| v as i16)\n+        self.to_signed_with_bit_width(16).map(|v| i16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i32`. Fails if the scalar is a pointer.\n     pub fn to_i32(self) -> InterpResult<'static, i32> {\n-        self.to_signed_with_bit_width(32).map(|v| v as i32)\n+        self.to_signed_with_bit_width(32).map(|v| i32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i64`. Fails if the scalar is a pointer.\n     pub fn to_i64(self) -> InterpResult<'static, i64> {\n-        self.to_signed_with_bit_width(64).map(|v| v as i64)\n+        self.to_signed_with_bit_width(64).map(|v| i64::try_from(v).unwrap())\n     }\n \n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n         let sz = cx.data_layout().pointer_size;\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        Ok(b as i64)\n+        Ok(i64::try_from(b).unwrap())\n     }\n \n     #[inline]\n     pub fn to_f32(self) -> InterpResult<'static, Single> {\n         // Going through `u32` to check size and truncation.\n-        Ok(Single::from_bits(self.to_u32()? as u128))\n+        Ok(Single::from_bits(self.to_u32()?.into()))\n     }\n \n     #[inline]\n     pub fn to_f64(self) -> InterpResult<'static, Double> {\n         // Going through `u64` to check size and truncation.\n-        Ok(Double::from_bits(self.to_u64()? as u128))\n+        Ok(Double::from_bits(self.to_u64()?.into()))\n     }\n }\n \n@@ -671,8 +673,8 @@ pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) ->\n         data.get_bytes(\n             cx,\n             // invent a pointer, only the offset is relevant anyway\n-            Pointer::new(AllocId(0), Size::from_bytes(start as u64)),\n-            Size::from_bytes(len as u64),\n+            Pointer::new(AllocId(0), Size::from_bytes(start)),\n+            Size::from_bytes(len),\n         )\n         .unwrap_or_else(|err| bug!(\"const slice is invalid: {:?}\", err))\n     } else {"}, {"sha": "b1626d95eb3e88bd25fa3ced6e717bc5e19ec08b", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -981,7 +981,7 @@ pub trait PrettyPrinter<'tcx>:\n                     .alloc_map\n                     .lock()\n                     .unwrap_memory(ptr.alloc_id)\n-                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data as u64))\n+                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n                     .unwrap();\n                 p!(pretty_print_byte_str(byte_str));\n             }\n@@ -1169,7 +1169,7 @@ pub trait PrettyPrinter<'tcx>:\n             (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n                 let n = n.val.try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n-                let n = Size::from_bytes(n as u64);\n+                let n = Size::from_bytes(n);\n                 let ptr = Pointer::new(AllocId(0), offset);\n \n                 let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();"}, {"sha": "3e7fb0e73bffee6a5caefaf9e80fe2c359248dae", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1614,7 +1614,7 @@ impl FloatTy {\n         }\n     }\n \n-    pub fn bit_width(self) -> usize {\n+    pub fn bit_width(self) -> u64 {\n         match self {\n             FloatTy::F32 => 32,\n             FloatTy::F64 => 64,\n@@ -1663,7 +1663,7 @@ impl IntTy {\n         format!(\"{}{}\", val as u128, self.name_str())\n     }\n \n-    pub fn bit_width(&self) -> Option<usize> {\n+    pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             IntTy::Isize => return None,\n             IntTy::I8 => 8,\n@@ -1725,7 +1725,7 @@ impl UintTy {\n         format!(\"{}{}\", val, self.name_str())\n     }\n \n-    pub fn bit_width(&self) -> Option<usize> {\n+    pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             UintTy::Usize => return None,\n             UintTy::U8 => 8,"}, {"sha": "bc25b9496d9b59905368f59efa2125809374e280", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1172,8 +1172,8 @@ fn generic_simd_intrinsic(\n         let m_len = match in_ty.kind {\n             // Note that this `.unwrap()` crashes for isize/usize, that's sort\n             // of intentional as there's not currently a use case for that.\n-            ty::Int(i) => i.bit_width().unwrap() as u64,\n-            ty::Uint(i) => i.bit_width().unwrap() as u64,\n+            ty::Int(i) => i.bit_width().unwrap(),\n+            ty::Uint(i) => i.bit_width().unwrap(),\n             _ => return_error!(\"`{}` is not an integral type\", in_ty),\n         };\n         require_simd!(arg_tys[1], \"argument\");\n@@ -1354,20 +1354,18 @@ fn generic_simd_intrinsic(\n         // trailing bits.\n         let expected_int_bits = in_len.max(8);\n         match ret_ty.kind {\n-            ty::Uint(i) if i.bit_width() == Some(expected_int_bits as usize) => (),\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => (),\n             _ => return_error!(\"bitmask `{}`, expected `u{}`\", ret_ty, expected_int_bits),\n         }\n \n         // Integer vector <i{in_bitwidth} x in_len>:\n         let (i_xn, in_elem_bitwidth) = match in_elem.kind {\n-            ty::Int(i) => (\n-                args[0].immediate(),\n-                i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits() as _),\n-            ),\n-            ty::Uint(i) => (\n-                args[0].immediate(),\n-                i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits() as _),\n-            ),\n+            ty::Int(i) => {\n+                (args[0].immediate(), i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits()))\n+            }\n+            ty::Uint(i) => {\n+                (args[0].immediate(), i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits()))\n+            }\n             _ => return_error!(\n                 \"vector argument `{}`'s element type `{}`, expected integer element type\",\n                 in_ty,\n@@ -1378,16 +1376,16 @@ fn generic_simd_intrinsic(\n         // Shift the MSB to the right by \"in_elem_bitwidth - 1\" into the first bit position.\n         let shift_indices =\n             vec![\n-                bx.cx.const_int(bx.type_ix(in_elem_bitwidth as _), (in_elem_bitwidth - 1) as _);\n+                bx.cx.const_int(bx.type_ix(in_elem_bitwidth), (in_elem_bitwidth - 1) as _);\n                 in_len as _\n             ];\n         let i_xn_msb = bx.lshr(i_xn, bx.const_vector(shift_indices.as_slice()));\n         // Truncate vector to an <i1 x N>\n-        let i1xn = bx.trunc(i_xn_msb, bx.type_vector(bx.type_i1(), in_len as _));\n+        let i1xn = bx.trunc(i_xn_msb, bx.type_vector(bx.type_i1(), in_len));\n         // Bitcast <i1 x N> to iN:\n-        let i_ = bx.bitcast(i1xn, bx.type_ix(in_len as _));\n+        let i_ = bx.bitcast(i1xn, bx.type_ix(in_len));\n         // Zero-extend iN to the bitmask type:\n-        return Ok(bx.zext(i_, bx.type_ix(expected_int_bits as _)));\n+        return Ok(bx.zext(i_, bx.type_ix(expected_int_bits)));\n     }\n \n     fn simd_simple_float_intrinsic(\n@@ -2099,7 +2097,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n     match ty.kind {\n         ty::Int(t) => Some((\n             match t {\n-                ast::IntTy::Isize => cx.tcx.sess.target.ptr_width as u64,\n+                ast::IntTy::Isize => u64::from(cx.tcx.sess.target.ptr_width),\n                 ast::IntTy::I8 => 8,\n                 ast::IntTy::I16 => 16,\n                 ast::IntTy::I32 => 32,\n@@ -2110,7 +2108,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n         )),\n         ty::Uint(t) => Some((\n             match t {\n-                ast::UintTy::Usize => cx.tcx.sess.target.ptr_width as u64,\n+                ast::UintTy::Usize => u64::from(cx.tcx.sess.target.ptr_width),\n                 ast::UintTy::U8 => 8,\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,\n@@ -2127,7 +2125,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n // Returns None if the type is not a float\n fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n     match ty.kind {\n-        ty::Float(t) => Some(t.bit_width() as u64),\n+        ty::Float(t) => Some(t.bit_width()),\n         _ => None,\n     }\n }"}, {"sha": "5bb30d03d9f8d6997682daddb126c74aa2ba41fc", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 };\n                 let a = Scalar::from(Pointer::new(\n                     bx.tcx().alloc_map.lock().create_memory_alloc(data),\n-                    Size::from_bytes(start as u64),\n+                    Size::from_bytes(start),\n                 ));\n                 let a_llval = bx.scalar_to_backend(\n                     a,"}, {"sha": "6e7e6f9d34526277f6c6a68cf87f776d62602497", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,5 +1,7 @@\n // Not in interpret to make sure we do not use private implementation details\n \n+use std::convert::TryFrom;\n+\n use rustc::mir;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, TyCtxt};\n@@ -37,7 +39,7 @@ pub(crate) fn const_field<'tcx>(\n         Some(variant) => ecx.operand_downcast(op, variant).unwrap(),\n     };\n     // then project\n-    let field = ecx.operand_field(down, field.index() as u64).unwrap();\n+    let field = ecx.operand_field(down, field.index()).unwrap();\n     // and finally move back to the const world, always normalizing because\n     // this is not called for statics.\n     op_to_const(&ecx, field)\n@@ -68,10 +70,11 @@ pub(crate) fn destructure_const<'tcx>(\n \n     let variant = ecx.read_discriminant(op).unwrap().1;\n \n+    // We go to `usize` as we cannot allocate anything bigger anyway.\n     let field_count = match val.ty.kind {\n-        ty::Array(_, len) => len.eval_usize(tcx, param_env),\n-        ty::Adt(def, _) => def.variants[variant].fields.len() as u64,\n-        ty::Tuple(substs) => substs.len() as u64,\n+        ty::Array(_, len) => usize::try_from(len.eval_usize(tcx, param_env)).unwrap(),\n+        ty::Adt(def, _) => def.variants[variant].fields.len(),\n+        ty::Tuple(substs) => substs.len(),\n         _ => bug!(\"cannot destructure constant {:?}\", val),\n     };\n "}, {"sha": "f7327825ca4b76be26a6a59975bd46b5b57f0f6c", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::ty::adjustment::PointerCast;\n use rustc::ty::layout::{self, Size, TyLayout};\n use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n@@ -206,8 +208,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Char => {\n                 // `u8` to `char` cast\n-                assert_eq!(v as u8 as u128, v);\n-                Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n+                Ok(Scalar::from_uint(u8::try_from(v).unwrap(), Size::from_bytes(4)))\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n@@ -227,16 +228,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match dest_ty.kind {\n             // float -> uint\n             Uint(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = f.to_u128(width).value;\n+                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let v = f.to_u128(usize::try_from(width).unwrap()).value;\n                 // This should already fit the bit width\n-                Ok(Scalar::from_uint(v, Size::from_bits(width as u64)))\n+                Ok(Scalar::from_uint(v, Size::from_bits(width)))\n             }\n             // float -> int\n             Int(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = f.to_i128(width).value;\n-                Ok(Scalar::from_int(v, Size::from_bits(width as u64)))\n+                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let v = f.to_i128(usize::try_from(width).unwrap()).value;\n+                Ok(Scalar::from_int(v, Size::from_bits(width)))\n             }\n             // float -> f32\n             Float(FloatTy::F32) => Ok(Scalar::from_f32(f.convert(&mut false).value)),\n@@ -319,11 +320,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n                 for i in 0..src.layout.fields.count() {\n-                    let dst_field = self.place_field(dest, i as u64)?;\n+                    let dst_field = self.place_field(dest, i)?;\n                     if dst_field.layout.is_zst() {\n                         continue;\n                     }\n-                    let src_field = self.operand_field(src, i as u64)?;\n+                    let src_field = self.operand_field(src, i)?;\n                     if src_field.layout.ty == dst_field.layout.ty {\n                         self.copy_op(src_field, dst_field)?;\n                     } else {"}, {"sha": "c2baabf4233ce6157c59faddb0ea07e56cf8295e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -413,6 +413,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // and it also rounds up to alignment, which we want to avoid,\n                 // as the unsized field's alignment could be smaller.\n                 assert!(!layout.ty.is_simd());\n+                assert!(layout.fields.count() > 0);\n                 trace!(\"DST layout: {:?}\", layout);\n \n                 let sized_size = layout.fields.offset(layout.fields.count() - 1);\n@@ -452,7 +453,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // here. But this is where the add would go.)\n \n                 // Return the sum of sizes and max of aligns.\n-                let size = sized_size + unsized_size;\n+                let size = sized_size + unsized_size; // `Size` addition\n \n                 // Choose max of two known alignments (combined value must\n                 // be aligned according to more restrictive of the two)."}, {"sha": "e5f89b10e76ed722432828219f46cac5ebeefad4", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -29,11 +29,11 @@ fn numeric_intrinsic<'tcx, Tag>(\n         Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n     };\n-    let extra = 128 - size.bits() as u128;\n+    let extra = 128 - u128::from(size.bits());\n     let bits_out = match name {\n-        sym::ctpop => bits.count_ones() as u128,\n-        sym::ctlz => bits.leading_zeros() as u128 - extra,\n-        sym::cttz => (bits << extra).trailing_zeros() as u128 - extra,\n+        sym::ctpop => u128::from(bits.count_ones()),\n+        sym::ctlz => u128::from(bits.leading_zeros()) - extra,\n+        sym::cttz => u128::from((bits << extra).trailing_zeros()) - extra,\n         sym::bswap => (bits << extra).swap_bytes(),\n         sym::bitreverse => (bits << extra).reverse_bits(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n@@ -261,7 +261,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val_bits = self.force_bits(val, layout.size)?;\n                 let raw_shift = self.read_scalar(args[1])?.not_undef()?;\n                 let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n-                let width_bits = layout.size.bits() as u128;\n+                let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;\n                 let result_bits = if intrinsic_name == sym::rotate_left {\n@@ -350,8 +350,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n \n                 for i in 0..len {\n-                    let place = self.place_field(dest, i)?;\n-                    let value = if i == index { elem } else { self.operand_field(input, i)? };\n+                    let place = self.place_index(dest, i)?;\n+                    let value = if i == index { elem } else { self.operand_index(input, i)? };\n                     self.copy_op(value, place)?;\n                 }\n             }\n@@ -370,7 +370,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"Return type `{}` must match vector element type `{}`\",\n                     dest.layout.ty, e_ty\n                 );\n-                self.copy_op(self.operand_field(args[0], index)?, dest)?;\n+                self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n             _ => return Ok(false),\n         }"}, {"sha": "01f9cdea0f0d3a7ff22f6599213bd175a67dd1fb", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::middle::lang_items::PanicLocationLangItem;\n use rustc::ty::subst::Subst;\n use rustc_span::{Span, Symbol};\n@@ -59,8 +61,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         (\n             Symbol::intern(&caller.file.name.to_string()),\n-            caller.line as u32,\n-            caller.col_display as u32 + 1,\n+            u32::try_from(caller.line).unwrap(),\n+            u32::try_from(caller.col_display).unwrap().checked_add(1).unwrap(),\n         )\n     }\n "}, {"sha": "49b9018fd1725730b383f5b66d7c0e22191d1e18", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -8,6 +8,7 @@\n \n use std::borrow::Cow;\n use std::collections::VecDeque;\n+use std::convert::TryFrom;\n use std::ptr;\n \n use rustc::ty::layout::{Align, HasDataLayout, Size, TargetDataLayout};\n@@ -346,7 +347,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         };\n         Ok(match normalized.to_bits_or_ptr(self.pointer_size(), self) {\n             Ok(bits) => {\n-                let bits = bits as u64; // it's ptr-sized\n+                let bits = u64::try_from(bits).unwrap(); // it's ptr-sized\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL.\n                 if bits == 0 {\n@@ -667,7 +668,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n                 // this `as usize` is fine, since `i` came from a `usize`\n-                let i = i.bytes() as usize;\n+                let i = i.bytes_usize();\n \n                 // Checked definedness (and thus range) and relocations. This access also doesn't\n                 // influence interpreter execution but is only for debugging.\n@@ -692,8 +693,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             let mut pos = Size::ZERO;\n             let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n             for (i, target_id) in relocations {\n-                // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n-                write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes() as usize).unwrap();\n+                write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes_usize()).unwrap();\n                 let target = format!(\"({})\", target_id);\n                 // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n                 write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n@@ -834,8 +834,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         src: impl IntoIterator<Item = u8>,\n     ) -> InterpResult<'tcx> {\n         let src = src.into_iter();\n-        let size = Size::from_bytes(src.size_hint().0 as u64);\n-        // `write_bytes` checks that this lower bound matches the upper bound matches reality.\n+        let size = Size::from_bytes(src.size_hint().0);\n+        // `write_bytes` checks that this lower bound `size` matches the upper bound and reality.\n         let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n@@ -874,14 +874,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         let tcx = self.tcx.tcx;\n \n-        // The bits have to be saved locally before writing to dest in case src and dest overlap.\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-\n         // This checks relocation edges on the src.\n         let src_bytes =\n             self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n         let dest_bytes =\n-            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?;\n+            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?; // `Size` multiplication\n \n         // If `dest_bytes` is empty we just optimize to not run anything for zsts.\n         // See #67539\n@@ -902,7 +899,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // touched if the bytes stay undef for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n             let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n-            dest_alloc.mark_definedness(dest, size * length, false);\n+            dest_alloc.mark_definedness(dest, size * length, false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -913,9 +910,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The pointers above remain valid even if the `HashMap` table is moved around because they\n         // point into the `Vec` storing the bytes.\n         unsafe {\n-            assert_eq!(size.bytes() as usize as u64, size.bytes());\n             if src.alloc_id == dest.alloc_id {\n                 if nonoverlapping {\n+                    // `Size` additions\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset)\n                         || (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n@@ -926,16 +923,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 for i in 0..length {\n                     ptr::copy(\n                         src_bytes,\n-                        dest_bytes.offset((size.bytes() * i) as isize),\n-                        size.bytes() as usize,\n+                        dest_bytes.add((size * i).bytes_usize()), // `Size` multiplication\n+                        size.bytes_usize(),\n                     );\n                 }\n             } else {\n                 for i in 0..length {\n                     ptr::copy_nonoverlapping(\n                         src_bytes,\n-                        dest_bytes.offset((size.bytes() * i) as isize),\n-                        size.bytes() as usize,\n+                        dest_bytes.add((size * i).bytes_usize()), // `Size` multiplication\n+                        size.bytes_usize(),\n                     );\n                 }\n             }\n@@ -975,7 +972,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, u128> {\n         match scalar.to_bits_or_ptr(size, self) {\n             Ok(bits) => Ok(bits),\n-            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)? as u128),\n+            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)?.into()),\n         }\n     }\n }"}, {"sha": "409c958ac39fd67dc645768d7ec311b3e2b90829", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,7 +1,7 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n-use std::convert::{TryFrom, TryInto};\n+use std::convert::TryFrom;\n \n use super::{InterpCx, MPlaceTy, Machine, MemPlace, Place, PlaceTy};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -341,7 +341,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n+        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n         let str = ::std::str::from_utf8(bytes)\n             .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n         Ok(str)\n@@ -351,7 +351,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn operand_field(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace(self) {\n             Ok(mplace) => {\n@@ -362,7 +362,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(value) => value,\n         };\n \n-        let field = field.try_into().unwrap();\n         let field_layout = op.layout.field(self, field)?;\n         if field_layout.is_zst() {\n             let immediate = Scalar::zst().into();\n@@ -384,6 +383,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout })\n     }\n \n+    pub fn operand_index(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        if let Ok(index) = usize::try_from(index) {\n+            // We can just treat this as a field.\n+            self.operand_field(op, index)\n+        } else {\n+            // Indexing into a big array. This must be an mplace.\n+            let mplace = op.assert_mem_place(self);\n+            Ok(self.mplace_index(mplace, index)?.into())\n+        }\n+    }\n+\n     pub fn operand_downcast(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n@@ -406,7 +420,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.operand_field(base, field.index() as u64)?,\n+            Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n@@ -556,11 +570,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // where none should happen.\n                 let ptr = Pointer::new(\n                     self.tcx.alloc_map.lock().create_memory_alloc(data),\n-                    Size::from_bytes(start as u64), // offset: `start`\n+                    Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n                     self.tag_global_base_pointer(ptr).into(),\n-                    (end - start) as u64, // len: `end - start`\n+                    u64::try_from(end.checked_sub(start).unwrap()).unwrap(), // len: `end - start`\n                     self,\n                 ))\n             }\n@@ -581,7 +595,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .layout\n                     .ty\n                     .discriminant_for_variant(*self.tcx, index)\n-                    .map_or(index.as_u32() as u128, |discr| discr.val);\n+                    .map_or(u128::from(index.as_u32()), |discr| discr.val);\n                 return Ok((discr_val, index));\n             }\n             layout::Variants::Multiple {\n@@ -593,7 +607,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // read raw discriminant value\n-        let discr_op = self.operand_field(rval, discr_index as u64)?;\n+        let discr_op = self.operand_field(rval, discr_index)?;\n         let discr_val = self.read_immediate(discr_op)?;\n         let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);\n@@ -657,7 +671,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if !ptr_valid {\n                             throw_ub!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n                         }\n-                        (dataful_variant.as_u32() as u128, dataful_variant)\n+                        (u128::from(dataful_variant.as_u32()), dataful_variant)\n                     }\n                     Ok(raw_discr) => {\n                         // We need to use machine arithmetic to get the relative variant idx:\n@@ -686,7 +700,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants\n                                 .len();\n-                            assert!((variant_index as usize) < variants_len);\n+                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n                             (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n                         } else {\n                             (u128::from(dataful_variant.as_u32()), dataful_variant)"}, {"sha": "cb0aaa4d40d3ee5b790d5d1ad4280d039f07a29b", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::mir;\n use rustc::mir::interpret::{InterpResult, Scalar};\n use rustc::ty::{\n@@ -130,28 +132,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Shift ops can have an RHS with a different numeric type.\n         if bin_op == Shl || bin_op == Shr {\n             let signed = left_layout.abi.is_signed();\n-            let mut oflo = (r as u32 as u128) != r;\n-            let mut r = r as u32;\n-            let size = left_layout.size;\n-            oflo |= r >= size.bits() as u32;\n-            r %= size.bits() as u32;\n+            let size = u128::from(left_layout.size.bits());\n+            let overflow = r >= size;\n+            let r = r % size; // mask to type size\n+            let r = u32::try_from(r).unwrap(); // we masked so this will always fit\n             let result = if signed {\n                 let l = self.sign_extend(l, left_layout) as i128;\n                 let result = match bin_op {\n-                    Shl => l << r,\n-                    Shr => l >> r,\n+                    Shl => l.checked_shl(r).unwrap(),\n+                    Shr => l.checked_shr(r).unwrap(),\n                     _ => bug!(\"it has already been checked that this is a shift op\"),\n                 };\n                 result as u128\n             } else {\n                 match bin_op {\n-                    Shl => l << r,\n-                    Shr => l >> r,\n+                    Shl => l.checked_shl(r).unwrap(),\n+                    Shr => l.checked_shr(r).unwrap(),\n                     _ => bug!(\"it has already been checked that this is a shift op\"),\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);\n-            return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n+            return Ok((Scalar::from_uint(truncated, left_layout.size), overflow, left_layout.ty));\n         }\n \n         // For the remaining ops, the types must be the same on both sides\n@@ -193,7 +194,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 _ => None,\n             };\n             if let Some(op) = op {\n-                let l128 = self.sign_extend(l, left_layout) as i128;\n                 let r = self.sign_extend(r, right_layout) as i128;\n                 // We need a special check for overflowing remainder:\n                 // \"int_min % -1\" overflows and returns 0, but after casting things to a larger int\n@@ -206,8 +206,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => {}\n                 }\n+                let l = self.sign_extend(l, left_layout) as i128;\n \n-                let (result, oflo) = op(l128, r);\n+                let (result, oflo) = op(l, r);\n                 // This may be out-of-bounds for the result type, so we have to truncate ourselves.\n                 // If that truncation loses any information, we have an overflow.\n                 let result = result as u128;"}, {"sha": "5cf267c257d84d2b03b29e556c022c69e19ad72d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -385,43 +385,20 @@ where\n         Ok(place)\n     }\n \n-    /// Offset a pointer to project to a field. Unlike `place_field`, this is always\n-    /// possible without allocating, so it can take `&self`. Also return the field's layout.\n+    /// Offset a pointer to project to a field of a struct/union. Unlike `place_field`, this is\n+    /// always possible without allocating, so it can take `&self`. Also return the field's layout.\n     /// This supports both struct and array fields.\n+    ///\n+    /// This also works for arrays, but then the `usize` index type is restricting.\n+    /// For indexing into arrays, use `mplace_index`.\n     #[inline(always)]\n     pub fn mplace_field(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        // Not using the layout method because we want to compute on u64\n-        let offset = match base.layout.fields {\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                offsets[usize::try_from(field).unwrap()]\n-            }\n-            layout::FieldPlacement::Array { stride, .. } => {\n-                let len = base.len(self)?;\n-                if field >= len {\n-                    // This can only be reached in ConstProp and non-rustc-MIR.\n-                    throw_ub!(BoundsCheckFailed { len, index: field });\n-                }\n-                stride * field\n-            }\n-            layout::FieldPlacement::Union(count) => {\n-                assert!(\n-                    field < count as u64,\n-                    \"Tried to access field {} of union {:#?} with {} fields\",\n-                    field,\n-                    base.layout,\n-                    count\n-                );\n-                // Offset is always 0\n-                Size::from_bytes(0)\n-            }\n-        };\n-        // the only way conversion can fail if is this is an array (otherwise we already panicked\n-        // above). In that case, all fields are equal.\n-        let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n+        let offset = base.layout.fields.offset(field);\n+        let field_layout = base.layout.field(self, field)?;\n \n         // Offset may need adjustment for unsized fields.\n         let (meta, offset) = if field_layout.is_unsized() {\n@@ -451,6 +428,32 @@ where\n         base.offset(offset, meta, field_layout, self)\n     }\n \n+    /// Index into an array.\n+    #[inline(always)]\n+    pub fn mplace_index(\n+        &self,\n+        base: MPlaceTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        // Not using the layout method because we want to compute on u64\n+        match base.layout.fields {\n+            layout::FieldPlacement::Array { stride, .. } => {\n+                let len = base.len(self)?;\n+                if index >= len {\n+                    // This can only be reached in ConstProp and non-rustc-MIR.\n+                    throw_ub!(BoundsCheckFailed { len, index });\n+                }\n+                let offset = stride * index; // `Size` multiplication\n+                // All fields have the same layout.\n+                let field_layout = base.layout.field(self, 0)?;\n+\n+                assert!(!field_layout.is_unsized());\n+                base.offset(offset, MemPlaceMeta::None, field_layout, self)\n+            }\n+            _ => bug!(\"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n+        }\n+    }\n+\n     // Iterates over all fields of an array. Much more efficient than doing the\n     // same by repeatedly calling `mplace_array`.\n     pub(super) fn mplace_array_fields(\n@@ -465,7 +468,8 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| base.offset(i * stride, MemPlaceMeta::None, layout, dl)))\n+        // `Size` multiplication\n+        Ok((0..len).map(move |i| base.offset(stride * i, MemPlaceMeta::None, layout, dl)))\n     }\n \n     fn mplace_subslice(\n@@ -477,24 +481,24 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let actual_to = if from_end {\n-            if from + to > len {\n+            if from.checked_add(to).map_or(true, |to| to > len) {\n                 // This can only be reached in ConstProp and non-rustc-MIR.\n-                throw_ub!(BoundsCheckFailed { len: len as u64, index: from as u64 + to as u64 });\n+                throw_ub!(BoundsCheckFailed { len: len, index: from.saturating_add(to) });\n             }\n-            len - to\n+            len.checked_sub(to).unwrap()\n         } else {\n             to\n         };\n \n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => stride * from,\n+            layout::FieldPlacement::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n \n         // Compute meta and new layout\n-        let inner_len = actual_to - from;\n+        let inner_len = actual_to.checked_sub(from).unwrap();\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n@@ -527,34 +531,37 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.mplace_field(base, field.index() as u64)?,\n+            Field(field, _) => self.mplace_field(base, field.index())?,\n             Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n             Deref => self.deref_operand(base.into())?,\n \n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n                 let n = self.read_scalar(n)?;\n-                let n = self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?;\n-                self.mplace_field(base, u64::try_from(n).unwrap())?\n+                let n = u64::try_from(\n+                    self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?,\n+                )\n+                .unwrap();\n+                self.mplace_index(base, n)?\n             }\n \n             ConstantIndex { offset, min_length, from_end } => {\n                 let n = base.len(self)?;\n-                if n < min_length as u64 {\n+                if n < u64::from(min_length) {\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n-                    throw_ub!(BoundsCheckFailed { len: min_length as u64, index: n as u64 });\n+                    throw_ub!(BoundsCheckFailed { len: min_length.into(), index: n.into() });\n                 }\n \n                 let index = if from_end {\n-                    assert!(0 < offset && offset - 1 < min_length);\n-                    n - u64::from(offset)\n+                    assert!(0 < offset && offset <= min_length);\n+                    n.checked_sub(u64::from(offset)).unwrap()\n                 } else {\n                     assert!(offset < min_length);\n                     u64::from(offset)\n                 };\n \n-                self.mplace_field(base, index)?\n+                self.mplace_index(base, index)?\n             }\n \n             Subslice { from, to, from_end } => {\n@@ -570,14 +577,23 @@ where\n     pub fn place_field(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let mplace = self.force_allocation(base)?;\n         Ok(self.mplace_field(mplace, field)?.into())\n     }\n \n+    pub fn place_index(\n+        &mut self,\n+        base: PlaceTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+        let mplace = self.force_allocation(base)?;\n+        Ok(self.mplace_index(mplace, index)?.into())\n+    }\n+\n     pub fn place_downcast(\n         &self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n@@ -603,7 +619,7 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.place_field(base, field.index() as u64)?,\n+            Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n             // For the other variants, we have to force an allocation.\n@@ -723,7 +739,7 @@ where\n                 ),\n                 Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) => {\n                     assert_eq!(\n-                        Size::from_bytes(size.into()),\n+                        Size::from_bytes(size),\n                         dest.layout.size,\n                         \"Size mismatch when writing bits\"\n                     )\n@@ -1028,7 +1044,7 @@ where\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_bytes(str.as_bytes(), kind);\n-        let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n+        let meta = Scalar::from_uint(u128::try_from(str.len()).unwrap(), self.pointer_size());\n         let mplace = MemPlace {\n             ptr: ptr.into(),\n             align: Align::from_bytes(1).unwrap(),\n@@ -1072,7 +1088,7 @@ where\n                 let size = discr_layout.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, discr_index as u64)?;\n+                let discr_dest = self.place_field(dest, discr_index)?;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::Multiple {\n@@ -1103,7 +1119,7 @@ where\n                         niche_start_val,\n                     )?;\n                     // Write result.\n-                    let niche_dest = self.place_field(dest, discr_index as u64)?;\n+                    let niche_dest = self.place_field(dest, discr_index)?;\n                     self.write_immediate(*discr_val, niche_dest)?;\n                 }\n             }"}, {"sha": "6ec11d42f52d2176933dc8653f2264a0d94172f0", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -192,7 +192,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Ignore zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        let field_dest = self.place_field(dest, field_index as u64)?;\n+                        let field_dest = self.place_field(dest, field_index)?;\n                         self.copy_op(op, field_dest)?;\n                     }\n                 }"}, {"sha": "5ce5ba31a0987ddfaec960a952312be4e6c7b549", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,4 +1,5 @@\n use std::borrow::Cow;\n+use std::convert::TryFrom;\n \n use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::ty::Instance;\n@@ -29,6 +30,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n+                assert!(targets.len() > 0);\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n@@ -307,7 +309,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                     .map(|&a| Ok(a))\n                                     .chain(\n                                         (0..untuple_arg.layout.fields.count())\n-                                            .map(|i| self.operand_field(untuple_arg, i as u64)),\n+                                            .map(|i| self.operand_field(untuple_arg, i)),\n                                     )\n                                     .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>(\n                                     )?,\n@@ -330,7 +332,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n-                                let dest = self.place_field(dest, i as u64)?;\n+                                let dest = self.place_field(dest, i)?;\n                                 self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                             }\n                         } else {\n@@ -392,7 +394,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 // Find and consult vtable\n                 let vtable = receiver_place.vtable();\n-                let drop_fn = self.get_vtable_slot(vtable, idx)?;\n+                let drop_fn = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want"}, {"sha": "1e63766b85d42b065004ad6bef4d531f2e182d58", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1,9 +1,11 @@\n-use super::{FnVal, InterpCx, Machine, MemoryKind};\n+use std::convert::TryFrom;\n \n use rustc::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc::ty::layout::{Align, HasDataLayout, LayoutOf, Size};\n use rustc::ty::{self, Instance, Ty, TypeFoldable};\n \n+use super::{FnVal, InterpCx, Machine, MemoryKind};\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n@@ -54,7 +56,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         let vtable = self.memory.allocate(\n-            ptr_size * (3 + methods.len() as u64),\n+            ptr_size * u64::try_from(methods.len()).unwrap().checked_add(3).unwrap(),\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n@@ -103,11 +105,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn get_vtable_slot(\n         &self,\n         vtable: Scalar<M::PointerTag>,\n-        idx: usize,\n+        idx: u64,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n         // Skip over the 'drop_ptr', 'size', and 'align' fields.\n-        let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n+        let vtable_slot = vtable.ptr_offset(ptr_size * idx.checked_add(3).unwrap(), self)?;\n         let vtable_slot = self\n             .memory\n             .check_ptr_access(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n@@ -169,10 +171,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .expect(\"cannot be a ZST\");\n         let alloc = self.memory.get_raw(vtable.alloc_id)?;\n         let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.not_undef()?;\n-        let size = self.force_bits(size, pointer_size)? as u64;\n+        let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n         let align =\n             alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n-        let align = self.force_bits(align, pointer_size)? as u64;\n+        let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n         if size >= self.tcx.data_layout().obj_size_bound() {\n             throw_ub_format!("}, {"sha": "a355a22748010c951fcb755706e25725beb83dd8", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -4,6 +4,7 @@\n //! That's useful because it means other passes (e.g. promotion) can rely on `const`s\n //! to be const-safe.\n \n+use std::convert::TryFrom;\n use std::fmt::Write;\n use std::ops::RangeInclusive;\n \n@@ -746,7 +747,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n                 // This is the element type size.\n                 let layout = self.ecx.layout_of(tys)?;\n-                // This is the size in bytes of the whole array.\n+                // This is the size in bytes of the whole array. (This checks for overflow.)\n                 let size = layout.size * len;\n                 // Size is not 0, get a pointer.\n                 let ptr = self.ecx.force_ptr(mplace.ptr)?;\n@@ -777,7 +778,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n-                                let i = (ptr.offset.bytes() / layout.size.bytes()) as usize;\n+                                let i = usize::try_from(ptr.offset.bytes() / layout.size.bytes())\n+                                    .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n                                 throw_validation_failure!(\"undefined bytes\", self.path)"}, {"sha": "e8a7626406413682e307711179cf35bfe8e289e5", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -28,7 +28,8 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self>;\n+    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: usize)\n+    -> InterpResult<'tcx, Self>;\n }\n \n // Operands and memory-places are both values.\n@@ -62,7 +63,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     }\n \n     #[inline(always)]\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self> {\n+    fn project_field(\n+        self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n     }\n }\n@@ -96,7 +101,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     }\n \n     #[inline(always)]\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self> {\n+    fn project_field(\n+        self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n     }\n }\n@@ -206,7 +215,7 @@ macro_rules! make_value_visitor {\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> =\n                             (0..offsets.len()).map(|i| {\n-                                v.project_field(self.ecx(), i as u64)\n+                                v.project_field(self.ecx(), i)\n                             })\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;"}, {"sha": "76fcbf326fa788803ac06893ca838ad8b97e7377", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -1920,8 +1920,8 @@ fn slice_pat_covered_by_const<'tcx>(\n         }\n         (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n             assert_eq!(*t, tcx.types.u8);\n-            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start as u64));\n-            data.get_bytes(&tcx, ptr, Size::from_bytes((end - start) as u64)).unwrap()\n+            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start));\n+            data.get_bytes(&tcx, ptr, Size::from_bytes(end - start)).unwrap()\n         }\n         // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n         (_, ty::Slice(_)) => return Ok(false),\n@@ -2375,7 +2375,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 ty::Slice(t) => {\n                     match value.val {\n                         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            let offset = Size::from_bytes(start as u64);\n+                            let offset = Size::from_bytes(start);\n                             let n = (end - start) as u64;\n                             (Cow::Borrowed(data), offset, n, t)\n                         }"}, {"sha": "74d9817d2779bd709008ae25fef4f13c53842833", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f0a9ef8d3a563eeae1966ff5549400783d8e1f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=97f0a9ef8d3a563eeae1966ff5549400783d8e1f", "patch": "@@ -3,6 +3,7 @@ pub use Primitive::*;\n \n use crate::spec::Target;\n \n+use std::convert::{TryFrom, TryInto};\n use std::ops::{Add, AddAssign, Deref, Mul, Range, RangeInclusive, Sub};\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -240,31 +241,42 @@ pub struct Size {\n }\n \n impl Size {\n-    pub const ZERO: Size = Self::from_bytes(0);\n+    pub const ZERO: Size = Size { raw: 0 };\n \n     #[inline]\n-    pub fn from_bits(bits: u64) -> Size {\n+    pub fn from_bits(bits: impl TryInto<u64>) -> Size {\n+        let bits = bits.try_into().ok().unwrap();\n         // Avoid potential overflow from `bits + 7`.\n         Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n     }\n \n     #[inline]\n-    pub const fn from_bytes(bytes: u64) -> Size {\n-        Size { raw: bytes }\n+    pub fn from_bytes(bytes: impl TryInto<u64>) -> Size {\n+        Size { raw: bytes.try_into().ok().unwrap() }\n     }\n \n     #[inline]\n     pub fn bytes(self) -> u64 {\n         self.raw\n     }\n \n+    #[inline]\n+    pub fn bytes_usize(self) -> usize {\n+        self.bytes().try_into().unwrap()\n+    }\n+\n     #[inline]\n     pub fn bits(self) -> u64 {\n         self.bytes().checked_mul(8).unwrap_or_else(|| {\n             panic!(\"Size::bits: {} bytes in bits doesn't fit in u64\", self.bytes())\n         })\n     }\n \n+    #[inline]\n+    pub fn bits_usize(self) -> usize {\n+        self.bits().try_into().unwrap()\n+    }\n+\n     #[inline]\n     pub fn align_to(self, align: Align) -> Size {\n         let mask = align.bytes() - 1;\n@@ -665,7 +677,7 @@ impl FieldPlacement {\n                 Size::ZERO\n             }\n             FieldPlacement::Array { stride, count } => {\n-                let i = i as u64;\n+                let i = u64::try_from(i).unwrap();\n                 assert!(i < count);\n                 stride * i\n             }"}]}