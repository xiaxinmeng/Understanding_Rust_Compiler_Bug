{"sha": "8f0b945cfcc3d084583bc27a7ed23b27b1246751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMGI5NDVjZmNjM2QwODQ1ODNiYzI3YTdlZDIzYjI3YjEyNDY3NTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-07T15:21:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-07T15:21:30Z"}, "message": "Auto merge of #77853 - ijackson:slice-strip-stab, r=Amanieu\n\nStabilize slice::strip_prefix and slice::strip_suffix\n\nThese two methods are useful.  The corresponding methods on `str` are already stable.\n\nI believe that stablising these now would not get in the way of, in the future, extending these to take a richer pattern API a la `str`'s patterns.\n\nTracking PR: #73413.  I also have an outstanding PR to improve the docs for these two functions and the corresponding ones on `str`: #75078\n\nI have tried to follow the [instructions in the dev guide](https://rustc-dev-guide.rust-lang.org/stabilization_guide.html#stabilization-pr).  The part to do with `compiler/rustc_feature` did not seem applicable.  I assume that's because these are just library features, so there is no corresponding machinery in rustc.", "tree": {"sha": "8153c7ae5e6f3ea0a0a17e61dfbbe874d1bb2381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8153c7ae5e6f3ea0a0a17e61dfbbe874d1bb2381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f0b945cfcc3d084583bc27a7ed23b27b1246751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f0b945cfcc3d084583bc27a7ed23b27b1246751", "html_url": "https://github.com/rust-lang/rust/commit/8f0b945cfcc3d084583bc27a7ed23b27b1246751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f0b945cfcc3d084583bc27a7ed23b27b1246751/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5c496de374407c0937cf5257d89230b5358d053", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c496de374407c0937cf5257d89230b5358d053", "html_url": "https://github.com/rust-lang/rust/commit/b5c496de374407c0937cf5257d89230b5358d053"}, {"sha": "8b2e79dbac324b703493113c9f823e63cf1df4e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b2e79dbac324b703493113c9f823e63cf1df4e0", "html_url": "https://github.com/rust-lang/rust/commit/8b2e79dbac324b703493113c9f823e63cf1df4e0"}], "stats": {"total": 51, "additions": 44, "deletions": 7}, "files": [{"sha": "bd01271ec150ff0944f41953e67a7fa1bfe83f67", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8f0b945cfcc3d084583bc27a7ed23b27b1246751/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0b945cfcc3d084583bc27a7ed23b27b1246751/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=8f0b945cfcc3d084583bc27a7ed23b27b1246751", "patch": "@@ -1872,19 +1872,24 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_strip)]\n     /// let v = &[10, 40, 30];\n     /// assert_eq!(v.strip_prefix(&[10]), Some(&[40, 30][..]));\n     /// assert_eq!(v.strip_prefix(&[10, 40]), Some(&[30][..]));\n     /// assert_eq!(v.strip_prefix(&[50]), None);\n     /// assert_eq!(v.strip_prefix(&[10, 50]), None);\n+    ///\n+    /// let prefix : &str = \"he\";\n+    /// assert_eq!(b\"hello\".strip_prefix(prefix.as_bytes()),\n+    ///            Some(b\"llo\".as_ref()));\n     /// ```\n     #[must_use = \"returns the subslice without modifying the original\"]\n-    #[unstable(feature = \"slice_strip\", issue = \"73413\")]\n-    pub fn strip_prefix(&self, prefix: &[T]) -> Option<&[T]>\n+    #[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+    pub fn strip_prefix<P: SlicePattern<Item = T> + ?Sized>(&self, prefix: &P) -> Option<&[T]>\n     where\n         T: PartialEq,\n     {\n+        // This function will need rewriting if and when SlicePattern becomes more sophisticated.\n+        let prefix = prefix.as_slice();\n         let n = prefix.len();\n         if n <= self.len() {\n             let (head, tail) = self.split_at(n);\n@@ -1905,19 +1910,20 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_strip)]\n     /// let v = &[10, 40, 30];\n     /// assert_eq!(v.strip_suffix(&[30]), Some(&[10, 40][..]));\n     /// assert_eq!(v.strip_suffix(&[40, 30]), Some(&[10][..]));\n     /// assert_eq!(v.strip_suffix(&[50]), None);\n     /// assert_eq!(v.strip_suffix(&[50, 30]), None);\n     /// ```\n     #[must_use = \"returns the subslice without modifying the original\"]\n-    #[unstable(feature = \"slice_strip\", issue = \"73413\")]\n-    pub fn strip_suffix(&self, suffix: &[T]) -> Option<&[T]>\n+    #[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+    pub fn strip_suffix<P: SlicePattern<Item = T> + ?Sized>(&self, suffix: &P) -> Option<&[T]>\n     where\n         T: PartialEq,\n     {\n+        // This function will need rewriting if and when SlicePattern becomes more sophisticated.\n+        let suffix = suffix.as_slice();\n         let (len, n) = (self.len(), suffix.len());\n         if n <= len {\n             let (head, tail) = self.split_at(len - n);\n@@ -3310,3 +3316,35 @@ impl<T> Default for &mut [T] {\n         &mut []\n     }\n }\n+\n+#[unstable(feature = \"slice_pattern\", reason = \"stopgap trait for slice patterns\", issue = \"56345\")]\n+/// Patterns in slices - currently, only used by `strip_prefix` and `strip_suffix`.  At a future\n+/// point, we hope to generalise `core::str::Pattern` (which at the time of writing is limited to\n+/// `str`) to slices, and then this trait will be replaced or abolished.\n+pub trait SlicePattern {\n+    /// The element type of the slice being matched on.\n+    type Item;\n+\n+    /// Currently, the consumers of `SlicePattern` need a slice.\n+    fn as_slice(&self) -> &[Self::Item];\n+}\n+\n+#[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+impl<T> SlicePattern for [T] {\n+    type Item = T;\n+\n+    #[inline]\n+    fn as_slice(&self) -> &[Self::Item] {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"slice_strip\", since = \"1.50.0\")]\n+impl<T, const N: usize> SlicePattern for [T; N] {\n+    type Item = T;\n+\n+    #[inline]\n+    fn as_slice(&self) -> &[Self::Item] {\n+        self\n+    }\n+}"}, {"sha": "15ef5d1619ba33cd8f458a028795e7ceef85368e", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f0b945cfcc3d084583bc27a7ed23b27b1246751/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0b945cfcc3d084583bc27a7ed23b27b1246751/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8f0b945cfcc3d084583bc27a7ed23b27b1246751", "patch": "@@ -307,7 +307,6 @@\n #![feature(slice_internals)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n-#![feature(slice_strip)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stdsimd)]"}]}