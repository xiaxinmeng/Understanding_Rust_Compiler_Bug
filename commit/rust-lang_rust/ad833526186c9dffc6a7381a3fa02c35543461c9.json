{"sha": "ad833526186c9dffc6a7381a3fa02c35543461c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkODMzNTI2MTg2YzlkZmZjNmE3MzgxYTNmYTAyYzM1NTQzNDYxYzk=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-09-29T06:38:24Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@palantir.com", "date": "2014-09-30T19:52:46Z"}, "message": "Fix librustrt", "tree": {"sha": "aa2ff98c7e1283fbe824bb0caf7de5ac1633c489", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa2ff98c7e1283fbe824bb0caf7de5ac1633c489"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad833526186c9dffc6a7381a3fa02c35543461c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad833526186c9dffc6a7381a3fa02c35543461c9", "html_url": "https://github.com/rust-lang/rust/commit/ad833526186c9dffc6a7381a3fa02c35543461c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad833526186c9dffc6a7381a3fa02c35543461c9/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5647a8ea3932c8a44dad13699e128d3d3fee255", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5647a8ea3932c8a44dad13699e128d3d3fee255", "html_url": "https://github.com/rust-lang/rust/commit/d5647a8ea3932c8a44dad13699e128d3d3fee255"}], "stats": {"total": 143, "additions": 74, "deletions": 69}, "files": [{"sha": "bd63886baeeda176a95558d77445a7046e474d1e", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -39,10 +39,10 @@ pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }\n /// Make a clone of the global arguments.\n pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"dragonfly\")]\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"android\",\n+          target_os = \"freebsd\",\n+          target_os = \"dragonfly\"))]\n mod imp {\n     use core::prelude::*;\n \n@@ -146,9 +146,9 @@ mod imp {\n     }\n }\n \n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"ios\")]\n-#[cfg(target_os = \"windows\")]\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"ios\",\n+          target_os = \"windows\"))]\n mod imp {\n     use core::prelude::*;\n     use collections::vec::Vec;"}, {"sha": "72c7d89a3b98b701c007b106436e088bc8ce6d9c", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -160,7 +160,7 @@ pub unsafe fn cleanup() {\n pub mod shouldnt_be_public {\n     #[cfg(not(test))]\n     pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n+    #[cfg(all(not(windows), not(target_os = \"android\"), not(target_os = \"ios\")))]\n     pub use super::local_ptr::compiled::RT_TLS_PTR;\n }\n "}, {"sha": "2e7408d91591cc05b6cf3a12b9ac9773cc257bb4", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -16,8 +16,7 @@\n \n use libc;\n \n-#[cfg(not(target_arch = \"arm\"))]\n-#[cfg(target_os = \"ios\")]\n+#[cfg(any(not(target_arch = \"arm\"), target_os = \"ios\"))]\n #[repr(C)]\n pub enum _Unwind_Action {\n     _UA_SEARCH_PHASE = 1,\n@@ -62,14 +61,13 @@ pub static unwinder_private_data_size: uint = 5;\n #[cfg(target_arch = \"x86_64\")]\n pub static unwinder_private_data_size: uint = 6;\n \n-#[cfg(target_arch = \"arm\", not(target_os = \"ios\"))]\n+#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n pub static unwinder_private_data_size: uint = 20;\n \n-#[cfg(target_arch = \"arm\", target_os = \"ios\")]\n+#[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\n pub static unwinder_private_data_size: uint = 5;\n \n-#[cfg(target_arch = \"mips\")]\n-#[cfg(target_arch = \"mipsel\")]\n+#[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n pub static unwinder_private_data_size: uint = 2;\n \n #[repr(C)]\n@@ -85,8 +83,7 @@ pub type _Unwind_Exception_Cleanup_Fn =\n         extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                       exception: *mut _Unwind_Exception);\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"freebsd\")]\n+#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n #[link(name = \"gcc_s\")]\n extern {}\n \n@@ -101,11 +98,11 @@ extern {}\n extern \"C\" {\n     // iOS on armv7 uses SjLj exceptions and requires to link\n     // against corresponding routine (..._SjLj_...)\n-    #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n+    #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n     pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)\n                                   -> _Unwind_Reason_Code;\n \n-    #[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+    #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n     fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception)\n                                    -> _Unwind_Reason_Code;\n \n@@ -115,7 +112,7 @@ extern \"C\" {\n // ... and now we just providing access to SjLj counterspart\n // through a standard name to hide those details from others\n // (see also comment above regarding _Unwind_RaiseException)\n-#[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n #[inline(always)]\n pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception)\n                                      -> _Unwind_Reason_Code {"}, {"sha": "58f8f8b310f5551dd14f591efa8de292de6371d9", "filename": "src/librustrt/local_ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -22,13 +22,13 @@ use core::prelude::*;\n use core::mem;\n use alloc::boxed::Box;\n \n-#[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n-#[cfg(target_os = \"android\")] // see #10686\n-#[cfg(target_os = \"ios\")]\n+#[cfg(any(windows, // mingw-w32 doesn't like thread_local things\n+          target_os = \"android\", // see #10686\n+          target_os = \"ios\"))]\n pub use self::native::{init, cleanup, put, take, try_take, unsafe_take, exists,\n                        unsafe_borrow, try_unsafe_borrow};\n \n-#[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n+#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n pub use self::compiled::{init, cleanup, put, take, try_take, unsafe_take, exists,\n                          unsafe_borrow, try_unsafe_borrow};\n \n@@ -82,7 +82,7 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// implemented using LLVM's thread_local attribute which isn't necessarily\n /// working on all platforms. This implementation is faster, however, so we use\n /// it wherever possible.\n-#[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n+#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n pub mod compiled {\n     use core::prelude::*;\n "}, {"sha": "86dc9b85a792dc769db4e89ae32459697222b2c2", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -346,8 +346,7 @@ mod imp {\n     type pthread_mutexattr_t = libc::c_void;\n     type pthread_condattr_t = libc::c_void;\n \n-    #[cfg(target_os = \"freebsd\")]\n-    #[cfg(target_os = \"dragonfly\")]\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n     mod os {\n         use libc;\n \n@@ -360,8 +359,7 @@ mod imp {\n             0 as pthread_cond_t;\n     }\n \n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"ios\")]\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n     mod os {\n         use libc;\n "}, {"sha": "5c94ef61bfdb7ceb68f56c6cdf1b8adbe76b21b1", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -156,13 +156,13 @@ pub unsafe fn record_rust_managed_stack_bounds(stack_lo: uint, stack_hi: uint) {\n     #[cfg(not(windows))] #[inline(always)]\n     unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n \n-    #[cfg(windows, target_arch = \"x86\")] #[inline(always)]\n+    #[cfg(all(windows, target_arch = \"x86\"))] #[inline(always)]\n     unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n         // stack range is at TIB: %fs:0x04 (top) and %fs:0x08 (bottom)\n         asm!(\"mov $0, %fs:0x04\" :: \"r\"(stack_hi) :: \"volatile\");\n         asm!(\"mov $0, %fs:0x08\" :: \"r\"(stack_lo) :: \"volatile\");\n     }\n-    #[cfg(windows, target_arch = \"x86_64\")] #[inline(always)]\n+    #[cfg(all(windows, target_arch = \"x86_64\"))] #[inline(always)]\n     unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n         // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n         asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");\n@@ -189,49 +189,53 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     return target_record_sp_limit(limit);\n \n     // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")]\n-    #[cfg(target_arch = \"x86_64\", target_os = \"ios\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\",\n+              any(target_os = \"macos\", target_os = \"ios\")))]\n+    #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movq $$0x60+90*8, %rsi\n               movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"windows\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"windows\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(_: uint) {\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"freebsd\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movq $0, %fs:24\" :: \"r\"(limit) :: \"volatile\")\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"dragonfly\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"dragonfly\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movq $0, %fs:32\" :: \"r\"(limit) :: \"volatile\")\n     }\n \n     // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")]\n-    #[cfg(target_arch = \"x86\", target_os = \"ios\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86\",\n+              any(target_os = \"macos\", target_os = \"ios\")))]\n+    #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movl $$0x48+90*4, %eax\n               movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n     }\n-    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n-    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86\",\n+              any(target_os = \"linux\", target_os = \"freebsd\")))]\n+    #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n     }\n-    #[cfg(target_arch = \"x86\", target_os = \"windows\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86\", target_os = \"windows\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(_: uint) {\n     }\n \n     // mips, arm - Some brave soul can port these to inline asm, but it's over\n     //             my head personally\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"mipsel\")]\n-    #[cfg(target_arch = \"arm\", not(target_os = \"ios\"))] #[inline(always)]\n+    #[cfg(any(target_arch = \"mips\",\n+              target_arch = \"mipsel\",\n+              all(target_arch = \"arm\", not(target_os = \"ios\"))))]\n+    #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         use libc::c_void;\n         return record_sp_limit(limit as *const c_void);\n@@ -241,7 +245,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     }\n \n     // iOS segmented stack is disabled for now, see related notes\n-    #[cfg(target_arch = \"arm\", target_os = \"ios\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"arm\", target_os = \"ios\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(_: uint) {\n     }\n }\n@@ -259,31 +263,32 @@ pub unsafe fn get_sp_limit() -> uint {\n     return target_get_sp_limit();\n \n     // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")]\n-    #[cfg(target_arch = \"x86_64\", target_os = \"ios\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\",\n+              any(target_os = \"macos\", target_os = \"ios\")))]\n+    #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movq $$0x60+90*8, %rsi\n               movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n         return limit;\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"windows\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"windows\"))] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         return 1024;\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"freebsd\"))] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"dragonfly\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86_64\", target_os = \"dragonfly\"))] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movq %fs:32, $0\" : \"=r\"(limit) ::: \"volatile\");\n@@ -292,31 +297,34 @@ pub unsafe fn get_sp_limit() -> uint {\n \n \n     // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")]\n-    #[cfg(target_arch = \"x86\", target_os = \"ios\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86\",\n+              any(target_os = \"macos\", target_os = \"ios\")))]\n+    #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movl $$0x48+90*4, %eax\n               movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n         return limit;\n     }\n-    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n-    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86\",\n+              any(target_os = \"linux\", target_os = \"freebsd\")))]\n+    #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n-    #[cfg(target_arch = \"x86\", target_os = \"windows\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"x86\", target_os = \"windows\"))] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         return 1024;\n     }\n \n     // mips, arm - Some brave soul can port these to inline asm, but it's over\n     //             my head personally\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"mipsel\")]\n-    #[cfg(target_arch = \"arm\", not(target_os = \"ios\"))] #[inline(always)]\n+    #[cfg(any(target_arch = \"mips\",\n+              target_arch = \"mipsel\",\n+              all(target_arch = \"arm\", not(target_os = \"ios\"))))]\n+    #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         use libc::c_void;\n         return get_sp_limit() as uint;\n@@ -328,7 +336,7 @@ pub unsafe fn get_sp_limit() -> uint {\n     // iOS doesn't support segmented stacks yet. This function might\n     // be called by runtime though so it is unsafe to mark it as\n     // unreachable, let's return a fixed constant.\n-    #[cfg(target_arch = \"arm\", target_os = \"ios\")] #[inline(always)]\n+    #[cfg(all(target_arch = \"arm\", target_os = \"ios\"))] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         1024\n     }"}, {"sha": "aee70980bbaf7145e62eee52a36e7bbda01c07bc", "filename": "src/librustrt/thread_local_storage.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -41,11 +41,11 @@ pub unsafe fn destroy(key: Key) {\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_ulong;\n \n-#[cfg(target_os=\"linux\")]\n-#[cfg(target_os=\"freebsd\")]\n-#[cfg(target_os=\"dragonfly\")]\n-#[cfg(target_os=\"android\")]\n-#[cfg(target_os = \"ios\")]\n+#[cfg(any(target_os=\"linux\",\n+          target_os=\"freebsd\",\n+          target_os=\"dragonfly\",\n+          target_os=\"android\",\n+          target_os = \"ios\"))]\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_uint;\n "}, {"sha": "1561f428ce5484f84a13ebee6b7ead3c5e5b7c04", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad833526186c9dffc6a7381a3fa02c35543461c9/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=ad833526186c9dffc6a7381a3fa02c35543461c9", "patch": "@@ -235,7 +235,9 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n //\n // See also: rt/rust_try.ll\n \n-#[cfg(not(target_arch = \"arm\"), not(windows, target_arch = \"x86_64\"), not(test))]\n+#[cfg(all(not(target_arch = \"arm\"),\n+          not(all(windows, target_arch = \"x86_64\")),\n+          not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n     use libunwind as uw;\n@@ -288,7 +290,7 @@ pub mod eabi {\n // iOS on armv7 is using SjLj exceptions and therefore requires to use\n // a specialized personality routine: __gcc_personality_sj0\n \n-#[cfg(target_os = \"ios\", target_arch = \"arm\", not(test))]\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n     use libunwind as uw;\n@@ -343,7 +345,7 @@ pub mod eabi {\n \n // ARM EHABI uses a slightly different personality routine signature,\n // but otherwise works the same.\n-#[cfg(target_arch = \"arm\", not(target_os = \"ios\"), not(test))]\n+#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n #[doc(hidden)]\n pub mod eabi {\n     use libunwind as uw;\n@@ -392,7 +394,7 @@ pub mod eabi {\n // GCC reuses the same personality routine as for the other architectures by wrapping it\n // with an \"API translator\" layer (_GCC_specific_handler).\n \n-#[cfg(windows, target_arch = \"x86_64\", not(test))]\n+#[cfg(all(windows, target_arch = \"x86_64\", not(test)))]\n #[doc(hidden)]\n #[allow(non_camel_case_types, non_snake_case)]\n pub mod eabi {"}]}