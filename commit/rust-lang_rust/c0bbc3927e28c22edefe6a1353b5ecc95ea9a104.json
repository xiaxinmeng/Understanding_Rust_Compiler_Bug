{"sha": "c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYmJjMzkyN2UyOGMyMmVkZWZlNmExMzUzYjVlY2M5NWVhOWExMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-03T17:18:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-03T17:18:15Z"}, "message": "Auto merge of #55517 - nikomatsakis:universes, r=scalexm\n\nUniverses\n\nThis PR transitions the compiler to use **universes** instead of the **leak-check**. It is marked as [WIP] for a few reasons:\n\n- The diagnostics at present are terrible =)\n- This changes the behavior of coherence, regressing some things that used to compile\n\nThe goals of this PR at present are:\n\n- To start getting some eyes on the code\n- To do a crater run\n- To see the full travis results (due to https://github.com/rust-lang/rust/issues/52452, I am not able to run the full test suite locally anymore at present)\n\nThe first few commits in the PR are changing how `evaluate` treats regions. We now track whether region comparisons occurred, reverting the \"staticized\" query approach that @arielb1 put in. The problem with \"staticized\" queries is that it relied on the leak-check to get higher-ranked things correct, and we are removing the leak-check in this PR series, so that caused problems.\n\nYou can see at the end a collection of test updates. Mostly we behave the same but with atrocious diagnostics, but there are a number of cases where we used to error and now no longer do, as well as single case where we used to **not** error but we now do (the coherence-subtyping change).\n\n(Note: it would be possible to do a version of leak-check that propagates universe information and recover the old behavior. I am reluctant to do so because I'd like to leave us room to get more precise -- e.g., I want to eventually handle things like `exists<'a> { for<'b> { if ('a: 'b) { 'a: 'b } } }` which presently the leak-check cannot cope with etc. Also because it seems more consistent to me: most folks I've talked to expect the new behavior and are surprised to learn that binding sites were so significant before when it comes to coherence. One question is, though, to what extent are people relying on this in the wild?)", "tree": {"sha": "2cc354e8390966e438b510b0ba376b7fa14927b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cc354e8390966e438b510b0ba376b7fa14927b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "html_url": "https://github.com/rust-lang/rust/commit/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2442823ef572a65092fbc46f6975633f983b50b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2442823ef572a65092fbc46f6975633f983b50b6", "html_url": "https://github.com/rust-lang/rust/commit/2442823ef572a65092fbc46f6975633f983b50b6"}, {"sha": "8e89184a7beb03d58d3a3969dddc1d78964dec37", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e89184a7beb03d58d3a3969dddc1d78964dec37", "html_url": "https://github.com/rust-lang/rust/commit/8e89184a7beb03d58d3a3969dddc1d78964dec37"}], "stats": {"total": 3340, "additions": 1563, "deletions": 1777}, "files": [{"sha": "4cce8343c02c871f83efe94c4c7f61ac84f92a5d", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -132,12 +132,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n+            ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n+\n             // FIXME(#13998) RePlaceholder should probably print like\n             // ReFree rather than dumping Debug output on the user.\n             //\n             // We shouldn't really be having unification failures with ReVar\n             // and ReLateBound though.\n-            ty::RePlaceholder(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n \n@@ -324,8 +326,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // the error. If all of these fails, we fall back to a rather\n                     // general bit of code that displays the error information\n                     RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n-                        self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n-                            .emit();\n+                        if sub.is_placeholder() || sup.is_placeholder() {\n+                            self.report_placeholder_failure(region_scope_tree, origin, sub, sup)\n+                                .emit();\n+                        } else {\n+                            self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n+                                .emit();\n+                        }\n                     }\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n@@ -339,20 +346,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     RegionResolutionError::SubSupConflict(\n+                        _,\n                         var_origin,\n                         sub_origin,\n                         sub_r,\n                         sup_origin,\n                         sup_r,\n                     ) => {\n-                        self.report_sub_sup_conflict(\n-                            region_scope_tree,\n-                            var_origin,\n-                            sub_origin,\n-                            sub_r,\n-                            sup_origin,\n-                            sup_r,\n-                        );\n+                        if sub_r.is_placeholder() {\n+                            self.report_placeholder_failure(\n+                                region_scope_tree,\n+                                sub_origin,\n+                                sub_r,\n+                                sup_r,\n+                            )\n+                                .emit();\n+                        } else if sup_r.is_placeholder() {\n+                            self.report_placeholder_failure(\n+                                region_scope_tree,\n+                                sup_origin,\n+                                sub_r,\n+                                sup_r,\n+                            )\n+                                .emit();\n+                        } else {\n+                            self.report_sub_sup_conflict(\n+                                region_scope_tree,\n+                                var_origin,\n+                                sub_origin,\n+                                sub_r,\n+                                sup_origin,\n+                                sup_r,\n+                            );\n+                        }\n                     }\n                 }\n             }\n@@ -407,7 +433,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         errors.sort_by_key(|u| match *u {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n-            RegionResolutionError::SubSupConflict(ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n         });\n         errors\n     }\n@@ -1306,6 +1332,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         match (&sup_origin, &sub_origin) {\n             (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) => {\n+                debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n+                debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n+                debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n+                debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n+                debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n+                debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n+                debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n+                debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n+                debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n+\n                 if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) = (\n                     self.values_str(&sup_trace.values),\n                     self.values_str(&sub_trace.values),"}, {"sha": "f7ba546fa7f3bc52cc4a5831b9b0a018d366d6d3", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -8,6 +8,7 @@ use util::common::ErrorReported;\n mod different_lifetimes;\n mod find_anon_type;\n mod named_anon_conflict;\n+mod placeholder_error;\n mod outlives_closure;\n mod static_impl_trait;\n mod util;\n@@ -58,19 +59,20 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict()\n+            .or_else(|| self.try_report_placeholder_conflict())\n     }\n \n     pub fn try_report(&self) -> Option<ErrorReported> {\n-        self.try_report_named_anon_conflict()\n+        self.try_report_from_nll()\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())\n     }\n \n     pub fn get_regions(&self) -> (Span, ty::Region<'tcx>, ty::Region<'tcx>) {\n         match (&self.error, self.regions) {\n-            (&Some(ConcreteFailure(ref origin, sub, sup)), None) => (origin.span(), sub, sup),\n-            (&Some(SubSupConflict(_, ref origin, sub, _, sup)), None) => (origin.span(), sub, sup),\n+            (Some(ConcreteFailure(origin, sub, sup)), None) => (origin.span(), sub, sup),\n+            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => (origin.span(), sub, sup),\n             (None, Some((span, sub, sup))) => (span, sub, sup),\n             (Some(_), Some(_)) => panic!(\"incorrectly built NiceRegionError\"),\n             _ => panic!(\"trying to report on an incorrect lifetime failure\"),"}, {"sha": "c4c71037d8b35df78022aff8d3fa6883f1773ba0", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -36,7 +36,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ///              ...because it cannot outlive this closure\n     /// ```\n     pub(super) fn try_report_outlives_closure(&self) -> Option<ErrorReported> {\n-        if let Some(SubSupConflict(origin,\n+        if let Some(SubSupConflict(_,\n+                                   origin,\n                                    ref sub_origin,\n                                    _,\n                                    ref sup_origin,"}, {"sha": "0dda636a9bd53e7c1855237cee3a62c7fab8cc07", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,307 @@\n+use hir::def_id::DefId;\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n+use infer::lexical_region_resolve::RegionResolutionError;\n+use infer::ValuePairs;\n+use infer::{SubregionOrigin, TypeTrace};\n+use traits::{ObligationCause, ObligationCauseCode};\n+use ty;\n+use ty::error::ExpectedFound;\n+use ty::subst::Substs;\n+use util::common::ErrorReported;\n+use util::ppaux::RegionHighlightMode;\n+\n+impl NiceRegionError<'me, 'gcx, 'tcx> {\n+    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n+    /// an anonymous region, emit an descriptive diagnostic error.\n+    pub(super) fn try_report_placeholder_conflict(&self) -> Option<ErrorReported> {\n+        match &self.error {\n+            ///////////////////////////////////////////////////////////////////////////\n+            // NB. The ordering of cases in this match is very\n+            // sensitive, because we are often matching against\n+            // specific cases and then using an `_` to match all\n+            // others.\n+\n+            ///////////////////////////////////////////////////////////////////////////\n+            // Check for errors from comparing trait failures -- first\n+            // with two placeholders, then with one.\n+            Some(RegionResolutionError::SubSupConflict(\n+                vid,\n+                _,\n+                SubregionOrigin::Subtype(TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sub_placeholder @ ty::RePlaceholder(_),\n+                _,\n+                sup_placeholder @ ty::RePlaceholder(_),\n+            ))\n+                if expected.def_id == found.def_id =>\n+            {\n+                Some(self.try_report_placeholders_trait(\n+                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n+                    cause,\n+                    Some(sub_placeholder),\n+                    Some(sup_placeholder),\n+                    expected.def_id,\n+                    expected.substs,\n+                    found.substs,\n+                ))\n+            }\n+\n+            Some(RegionResolutionError::SubSupConflict(\n+                vid,\n+                _,\n+                SubregionOrigin::Subtype(TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sub_placeholder @ ty::RePlaceholder(_),\n+                _,\n+                _,\n+            ))\n+                if expected.def_id == found.def_id =>\n+            {\n+                Some(self.try_report_placeholders_trait(\n+                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n+                    cause,\n+                    Some(sub_placeholder),\n+                    None,\n+                    expected.def_id,\n+                    expected.substs,\n+                    found.substs,\n+                ))\n+            }\n+\n+            Some(RegionResolutionError::SubSupConflict(\n+                vid,\n+                _,\n+                SubregionOrigin::Subtype(TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                _,\n+                _,\n+                sup_placeholder @ ty::RePlaceholder(_),\n+            ))\n+                if expected.def_id == found.def_id =>\n+            {\n+                Some(self.try_report_placeholders_trait(\n+                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n+                    cause,\n+                    None,\n+                    Some(*sup_placeholder),\n+                    expected.def_id,\n+                    expected.substs,\n+                    found.substs,\n+                ))\n+            }\n+\n+            Some(RegionResolutionError::ConcreteFailure(\n+                SubregionOrigin::Subtype(TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sub_region @ ty::RePlaceholder(_),\n+                sup_region @ ty::RePlaceholder(_),\n+            ))\n+                if expected.def_id == found.def_id =>\n+            {\n+                Some(self.try_report_placeholders_trait(\n+                    None,\n+                    cause,\n+                    Some(*sub_region),\n+                    Some(*sup_region),\n+                    expected.def_id,\n+                    expected.substs,\n+                    found.substs,\n+                ))\n+            }\n+\n+            Some(RegionResolutionError::ConcreteFailure(\n+                SubregionOrigin::Subtype(TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sub_region @ ty::RePlaceholder(_),\n+                sup_region,\n+            ))\n+                if expected.def_id == found.def_id =>\n+            {\n+                Some(self.try_report_placeholders_trait(\n+                    Some(sup_region),\n+                    cause,\n+                    Some(*sub_region),\n+                    None,\n+                    expected.def_id,\n+                    expected.substs,\n+                    found.substs,\n+                ))\n+            }\n+\n+            Some(RegionResolutionError::ConcreteFailure(\n+                SubregionOrigin::Subtype(TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sub_region,\n+                sup_region @ ty::RePlaceholder(_),\n+            ))\n+                if expected.def_id == found.def_id =>\n+            {\n+                Some(self.try_report_placeholders_trait(\n+                    Some(sub_region),\n+                    cause,\n+                    None,\n+                    Some(*sup_region),\n+                    expected.def_id,\n+                    expected.substs,\n+                    found.substs,\n+                ))\n+            }\n+\n+            _ => None,\n+        }\n+    }\n+\n+    // error[E0308]: implementation of `Foo` does not apply to enough lifetimes\n+    //   --> /home/nmatsakis/tmp/foo.rs:12:5\n+    //    |\n+    // 12 |     all::<&'static u32>();\n+    //    |     ^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n+    //    |\n+    //    = note: Due to a where-clause on the function `all`,\n+    //    = note: `T` must implement `...` for any two lifetimes `'1` and `'2`.\n+    //    = note: However, the type `T` only implements `...` for some specific lifetime `'2`.\n+    fn try_report_placeholders_trait(\n+        &self,\n+        vid: Option<ty::Region<'tcx>>,\n+        cause: &ObligationCause<'tcx>,\n+        sub_placeholder: Option<ty::Region<'tcx>>,\n+        sup_placeholder: Option<ty::Region<'tcx>>,\n+        trait_def_id: DefId,\n+        expected_substs: &'tcx Substs<'tcx>,\n+        actual_substs: &'tcx Substs<'tcx>,\n+    ) -> ErrorReported {\n+        let mut err = self.tcx.sess.struct_span_err(\n+            cause.span(&self.tcx),\n+            &format!(\n+                \"implementation of `{}` is not general enough\",\n+                self.tcx.item_path_str(trait_def_id),\n+            ),\n+        );\n+\n+        match cause.code {\n+            ObligationCauseCode::ItemObligation(def_id) => {\n+                err.note(&format!(\n+                    \"Due to a where-clause on `{}`,\",\n+                    self.tcx.item_path_str(def_id),\n+                ));\n+            }\n+            _ => (),\n+        }\n+\n+        let expected_trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: expected_substs,\n+        };\n+        let actual_trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: actual_substs,\n+        };\n+\n+        // Search the expected and actual trait references to see (a)\n+        // whether the sub/sup placeholders appear in them (sometimes\n+        // you have a trait ref like `T: Foo<fn(&u8)>`, where the\n+        // placeholder was created as part of an inner type) and (b)\n+        // whether the inference variable appears. In each case,\n+        // assign a counter value in each case if so.\n+        let mut counter = 0;\n+        let mut has_sub = None;\n+        let mut has_sup = None;\n+        let mut has_vid = None;\n+\n+        self.tcx.for_each_free_region(&expected_trait_ref, |r| {\n+            if Some(r) == sub_placeholder && has_sub.is_none() {\n+                has_sub = Some(counter);\n+                counter += 1;\n+            } else if Some(r) == sup_placeholder && has_sup.is_none() {\n+                has_sup = Some(counter);\n+                counter += 1;\n+            }\n+        });\n+\n+        self.tcx.for_each_free_region(&actual_trait_ref, |r| {\n+            if Some(r) == vid && has_vid.is_none() {\n+                has_vid = Some(counter);\n+                counter += 1;\n+            }\n+        });\n+\n+        let self_ty_has_vid = self\n+            .tcx\n+            .any_free_region_meets(&actual_trait_ref.self_ty(), |r| Some(r) == vid);\n+\n+        RegionHighlightMode::maybe_highlighting_region(sub_placeholder, has_sub, || {\n+            RegionHighlightMode::maybe_highlighting_region(sup_placeholder, has_sup, || {\n+                match (has_sub, has_sup) {\n+                    (Some(n1), Some(n2)) => {\n+                        err.note(&format!(\n+                            \"`{}` must implement `{}` \\\n+                             for any two lifetimes `'{}` and `'{}`\",\n+                            expected_trait_ref.self_ty(),\n+                            expected_trait_ref,\n+                            std::cmp::min(n1, n2),\n+                            std::cmp::max(n1, n2),\n+                        ));\n+                    }\n+                    (Some(n), _) | (_, Some(n)) => {\n+                        err.note(&format!(\n+                            \"`{}` must implement `{}` \\\n+                             for any lifetime `'{}`\",\n+                            expected_trait_ref.self_ty(),\n+                            expected_trait_ref,\n+                            n,\n+                        ));\n+                    }\n+                    (None, None) => {\n+                        err.note(&format!(\n+                            \"`{}` must implement `{}`\",\n+                            expected_trait_ref.self_ty(),\n+                            expected_trait_ref,\n+                        ));\n+                    }\n+                }\n+            })\n+        });\n+\n+        RegionHighlightMode::maybe_highlighting_region(vid, has_vid, || match has_vid {\n+            Some(n) => {\n+                if self_ty_has_vid {\n+                    err.note(&format!(\n+                        \"but `{}` only implements `{}` for the lifetime `'{}`\",\n+                        actual_trait_ref.self_ty(),\n+                        actual_trait_ref,\n+                        n\n+                    ));\n+                } else {\n+                    err.note(&format!(\n+                        \"but `{}` only implements `{}` for some lifetime `'{}`\",\n+                        actual_trait_ref.self_ty(),\n+                        actual_trait_ref,\n+                        n\n+                    ));\n+                }\n+            }\n+            None => {\n+                err.note(&format!(\n+                    \"but `{}` only implements `{}`\",\n+                    actual_trait_ref.self_ty(),\n+                    actual_trait_ref,\n+                ));\n+            }\n+        });\n+\n+        err.emit();\n+        ErrorReported\n+    }\n+}"}, {"sha": "9fc3bb05cdab1f9e495cd9e706454728b2083ee9", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -11,6 +11,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         if let Some(ref error) = self.error {\n             if let RegionResolutionError::SubSupConflict(\n+                    _,\n                     var_origin,\n                     sub_origin,\n                     sub_r,"}, {"sha": "e45a4b17cdd9c1f537b1296a48cc4e7d267cf792", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -442,4 +442,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub(super) fn report_placeholder_failure(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        placeholder_origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        // I can't think how to do better than this right now. -nikomatsakis\n+        match placeholder_origin {\n+            infer::Subtype(trace) => {\n+                let terr = TypeError::RegionsPlaceholderMismatch;\n+                self.report_and_explain_type_error(trace, &terr)\n+            }\n+\n+            _ => {\n+                self.report_concrete_failure(region_scope_tree, placeholder_origin, sub, sup)\n+            }\n+        }\n+    }\n }"}, {"sha": "709e8c0ba9b24115683695ef3ec2ac49c26cfd35", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 30, "deletions": 477, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,31 +1,23 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{CombinedSnapshot,\n-            InferCtxt,\n-            HigherRankedType,\n-            SubregionOrigin,\n-            PlaceholderMap};\n use super::combine::CombineFields;\n-use super::region_constraints::{TaintDirections};\n+use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n-use ty::{self, TyCtxt, Binder, TypeFoldable};\n-use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use syntax_pos::Span;\n-use util::nodemap::{FxHashMap, FxHashSet};\n-\n-pub struct HrMatchResult<U> {\n-    pub value: U,\n-}\n+use ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n-    pub fn higher_ranked_sub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n-                                -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'tcx>\n+    pub fn higher_ranked_sub<T>(\n+        &mut self,\n+        a: &Binder<T>,\n+        b: &Binder<T>,\n+        a_is_expected: bool,\n+    ) -> RelateResult<'tcx, Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n     {\n-        debug!(\"higher_ranked_sub(a={:?}, b={:?})\",\n-               a, b);\n+        debug!(\"higher_ranked_sub(a={:?}, b={:?})\", a, b);\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -35,279 +27,37 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // please see the large comment at the end of the file in the (inlined) module\n         // `doc`.\n \n-        // Start a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            let span = self.trace.cause.span;\n-\n-            // First, we instantiate each bound region in the supertype with a\n-            // fresh placeholder region.\n-            let (b_prime, placeholder_map) =\n-                self.infcx.replace_bound_vars_with_placeholders(b);\n-\n-            // Next, we instantiate each bound region in the subtype\n-            // with a fresh region variable. These region variables --\n-            // but no other pre-existing region variables -- can name\n-            // the placeholders.\n-            let (a_prime, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n-                span,\n-                HigherRankedType,\n-                a\n-            );\n-\n-            debug!(\"a_prime={:?}\", a_prime);\n-            debug!(\"b_prime={:?}\", b_prime);\n-\n-            // Compare types now that bound regions have been replaced.\n-            let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n-\n-            // Presuming type comparison succeeds, we need to check\n-            // that the placeholder regions do not \"leak\".\n-            self.infcx.leak_check(!a_is_expected, span, &placeholder_map, snapshot)?;\n-\n-            // We are finished with the placeholder regions now so pop\n-            // them off.\n-            self.infcx.pop_placeholders(placeholder_map, snapshot);\n-\n-            debug!(\"higher_ranked_sub: OK result={:?}\", result);\n-\n-            Ok(ty::Binder::bind(result))\n-        });\n-    }\n-\n-    /// The value consists of a pair `(t, u)` where `t` is the\n-    /// *matcher* and `u` is a *value*. The idea is to find a\n-    /// substitution `S` such that `S(t) == b`, and then return\n-    /// `S(u)`. In other words, find values for the late-bound regions\n-    /// in `a` that can make `t == b` and then replace the LBR in `u`\n-    /// with those values.\n-    ///\n-    /// This routine is (as of this writing) used in trait matching,\n-    /// particularly projection.\n-    ///\n-    /// NB. It should not happen that there are LBR appearing in `U`\n-    /// that do not appear in `T`. If that happens, those regions are\n-    /// unconstrained, and this routine replaces them with `'static`.\n-    pub fn higher_ranked_match<T, U>(&mut self,\n-                                     a_pair: &Binder<(T, U)>,\n-                                     b_match: &T,\n-                                     a_is_expected: bool)\n-                                     -> RelateResult<'tcx, HrMatchResult<U>>\n-        where T: Relate<'tcx>,\n-              U: TypeFoldable<'tcx>\n-    {\n-        debug!(\"higher_ranked_match(a={:?}, b={:?})\",\n-               a_pair, b_match);\n-\n-        // Start a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            // First, we instantiate each bound region in the matcher\n-            // with a placeholder region.\n-            let ((a_match, a_value), placeholder_map) =\n-                self.infcx.replace_bound_vars_with_placeholders(a_pair);\n+        let span = self.trace.cause.span;\n \n-            debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n-            debug!(\"higher_ranked_match: placeholder_map={:?}\", placeholder_map);\n+        // First, we instantiate each bound region in the supertype with a\n+        // fresh placeholder region.\n+        let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(b);\n \n-            // Equate types now that bound regions have been replaced.\n-            self.equate(a_is_expected).relate(&a_match, &b_match)?;\n+        // Next, we instantiate each bound region in the subtype\n+        // with a fresh region variable. These region variables --\n+        // but no other pre-existing region variables -- can name\n+        // the placeholders.\n+        let (a_prime, _) =\n+            self.infcx\n+                .replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n \n-            // Map each placeholder region to a vector of other regions that it\n-            // must be equated with. (Note that this vector may include other\n-            // placeholder regions from `placeholder_map`.)\n-            let placeholder_resolution_map: FxHashMap<_, _> =\n-                placeholder_map\n-                .iter()\n-                .map(|(&br, &placeholder)| {\n-                    let tainted_regions =\n-                        self.infcx.tainted_regions(snapshot,\n-                                                   placeholder,\n-                                                   TaintDirections::incoming()); // [1]\n+        debug!(\"a_prime={:?}\", a_prime);\n+        debug!(\"b_prime={:?}\", b_prime);\n \n-                    // [1] this routine executes after the placeholder\n-                    // regions have been *equated* with something\n-                    // else, so examining the incoming edges ought to\n-                    // be enough to collect all constraints\n+        // Compare types now that bound regions have been replaced.\n+        let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n-                    (placeholder, (br, tainted_regions))\n-                })\n-                .collect();\n+        debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n-            // For each placeholder region, pick a representative -- which can\n-            // be any region from the sets above, except for other members of\n-            // `placeholder_map`. There should always be a representative if things\n-            // are properly well-formed.\n-            let placeholder_representatives: FxHashMap<_, _> =\n-                placeholder_resolution_map\n-                .iter()\n-                .map(|(&placeholder, &(_, ref regions))| {\n-                    let representative =\n-                        regions.iter()\n-                               .filter(|&&r| !placeholder_resolution_map.contains_key(r))\n-                               .cloned()\n-                               .next()\n-                               .unwrap_or_else(|| {\n-                                   bug!(\"no representative region for `{:?}` in `{:?}`\",\n-                                        placeholder, regions)\n-                               });\n-\n-                    (placeholder, representative)\n-                })\n-                .collect();\n-\n-            // Equate all the members of each placeholder set with the\n-            // representative.\n-            for (placeholder, &(_br, ref regions)) in &placeholder_resolution_map {\n-                let representative = &placeholder_representatives[placeholder];\n-                debug!(\"higher_ranked_match: \\\n-                        placeholder={:?} representative={:?} regions={:?}\",\n-                       placeholder, representative, regions);\n-                for region in regions.iter()\n-                                     .filter(|&r| !placeholder_resolution_map.contains_key(r))\n-                                     .filter(|&r| r != representative)\n-                {\n-                    let origin = SubregionOrigin::Subtype(self.trace.clone());\n-                    self.infcx.borrow_region_constraints()\n-                              .make_eqregion(origin,\n-                                             *representative,\n-                                             *region);\n-                }\n-            }\n-\n-            // Replace the placeholder regions appearing in value with\n-            // their representatives\n-            let a_value =\n-                fold_regions_in(\n-                    self.tcx(),\n-                    &a_value,\n-                    |r, _| placeholder_representatives.get(&r).cloned().unwrap_or(r));\n-\n-            debug!(\"higher_ranked_match: value={:?}\", a_value);\n-\n-            // We are now done with these placeholder variables.\n-            self.infcx.pop_placeholders(placeholder_map, snapshot);\n-\n-            Ok(HrMatchResult { value: a_value })\n-        });\n+        Ok(ty::Binder::bind(result))\n     }\n }\n \n-fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         unbound_value: &T,\n-                                         mut fldr: F)\n-                                         -> T\n-    where T: TypeFoldable<'tcx>,\n-          F: FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n-{\n-    tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n-        // we should only be encountering \"escaping\" late-bound regions here,\n-        // because the ones at the current level should have been replaced\n-        // with fresh variables\n-        assert!(match *region {\n-            ty::ReLateBound(..) => false,\n-            _ => true\n-        });\n-\n-        fldr(region, current_depth)\n-    })\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn tainted_regions(&self,\n-                       snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                       r: ty::Region<'tcx>,\n-                       directions: TaintDirections)\n-                       -> FxHashSet<ty::Region<'tcx>> {\n-        self.borrow_region_constraints().tainted(\n-            self.tcx,\n-            &snapshot.region_constraints_snapshot,\n-            r,\n-            directions)\n-    }\n-\n-    fn region_vars_confined_to_snapshot(&self,\n-                                        snapshot: &CombinedSnapshot<'a, 'tcx>)\n-                                        -> Vec<ty::RegionVid>\n-    {\n-        /*!\n-         * Returns the set of region variables that do not affect any\n-         * types/regions which existed before `snapshot` was\n-         * started. This is used in the sub/lub/glb computations. The\n-         * idea here is that when we are computing lub/glb of two\n-         * regions, we sometimes create intermediate region variables.\n-         * Those region variables may touch some of the placeholder or\n-         * other \"forbidden\" regions we created to replace bound\n-         * regions, but they don't really represent an \"external\"\n-         * constraint.\n-         *\n-         * However, sometimes fresh variables are created for other\n-         * purposes too, and those *may* represent an external\n-         * constraint. In particular, when a type variable is\n-         * instantiated, we create region variables for all the\n-         * regions that appear within, and if that type variable\n-         * pre-existed the snapshot, then those region variables\n-         * represent external constraints.\n-         *\n-         * An example appears in the unit test\n-         * `sub_free_bound_false_infer`.  In this test, we want to\n-         * know whether\n-         *\n-         * ```rust\n-         * fn(_#0t) <: for<'a> fn(&'a int)\n-         * ```\n-         *\n-         * Note that the subtype has a type variable. Because the type\n-         * variable can't be instantiated with a region that is bound\n-         * in the fn signature, this comparison ought to fail. But if\n-         * we're not careful, it will succeed.\n-         *\n-         * The reason is that when we walk through the subtyping\n-         * algorithm, we begin by replacing `'a` with a placeholder\n-         * variable `'1`. We then have `fn(_#0t) <: fn(&'1 int)`. This\n-         * can be made true by unifying `_#0t` with `&'1 int`. In the\n-         * process, we create a fresh variable for the placeholder\n-         * region, `'$2`, and hence we have that `_#0t == &'$2\n-         * int`. However, because `'$2` was created during the sub\n-         * computation, if we're not careful we will erroneously\n-         * assume it is one of the transient region variables\n-         * representing a lub/glb internally. Not good.\n-         *\n-         * To prevent this, we check for type variables which were\n-         * unified during the snapshot, and say that any region\n-         * variable created during the snapshot but which finds its\n-         * way into a type variable is considered to \"escape\" the\n-         * snapshot.\n-         */\n-\n-        let mut region_vars =\n-            self.borrow_region_constraints().vars_created_since_snapshot(\n-                &snapshot.region_constraints_snapshot);\n-\n-        let escaping_types =\n-            self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n-\n-        let mut escaping_region_vars = FxHashSet::default();\n-        for ty in &escaping_types {\n-            self.tcx.collect_regions(ty, &mut escaping_region_vars);\n-        }\n-\n-        region_vars.retain(|&region_vid| {\n-            let r = ty::ReVar(region_vid);\n-            !escaping_region_vars.contains(&r)\n-        });\n-\n-        debug!(\"region_vars_confined_to_snapshot: region_vars={:?} escaping_types={:?}\",\n-               region_vars,\n-               escaping_types);\n-\n-        region_vars\n-    }\n-\n     /// Replace all regions (resp. types) bound by `binder` with placeholder\n     /// regions (resp. types) and return a map indicating which bound-region\n-    /// was replaced with what placeholder region. This is the first step of\n-    /// checking subtyping when higher-ranked things are involved.\n+    /// placeholder region. This is the first step of checking subtyping\n+    /// when higher-ranked things are involved.\n     ///\n     /// **Important:** you must call this function from within a snapshot.\n     /// Moreover, before committing the snapshot, you must eventually call\n@@ -354,201 +104,4 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         (result, map)\n     }\n-\n-    /// Searches the region constraints created since `snapshot` was started\n-    /// and checks to determine whether any of the placeholder regions created\n-    /// in `placeholder_map` would \"escape\" -- meaning that they are related to\n-    /// other regions in some way. If so, the higher-ranked subtyping doesn't\n-    /// hold. See `README.md` for more details.\n-    pub fn leak_check(&self,\n-                      overly_polymorphic: bool,\n-                      _span: Span,\n-                      placeholder_map: &PlaceholderMap<'tcx>,\n-                      snapshot: &CombinedSnapshot<'a, 'tcx>)\n-                      -> RelateResult<'tcx, ()>\n-    {\n-        debug!(\"leak_check: placeholder_map={:?}\",\n-               placeholder_map);\n-\n-        // If the user gave `-Zno-leak-check`, then skip the leak\n-        // check completely. This is wildly unsound and also not\n-        // unlikely to cause an ICE or two. It is intended for use\n-        // only during a transition period, in which the MIR typeck\n-        // uses the \"universe-style\" check, and the rest of typeck\n-        // uses the more conservative leak check.  Since the leak\n-        // check is more conservative, we can't test the\n-        // universe-style check without disabling it.\n-        if self.tcx.sess.opts.debugging_opts.no_leak_check {\n-            return Ok(());\n-        }\n-\n-        let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n-        for (&placeholder_br, &placeholder) in placeholder_map {\n-            // The inputs to a placeholder variable can only\n-            // be itself or other new variables.\n-            let incoming_taints = self.tainted_regions(snapshot,\n-                                                       placeholder,\n-                                                       TaintDirections::both());\n-            for &tainted_region in &incoming_taints {\n-                // Each placeholder should only be relatable to itself\n-                // or new variables:\n-                match *tainted_region {\n-                    ty::ReVar(vid) => {\n-                        if new_vars.contains(&vid) {\n-                            continue;\n-                        }\n-                    }\n-                    _ => {\n-                        if tainted_region == placeholder { continue; }\n-                    }\n-                };\n-\n-                debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n-                       placeholder,\n-                       placeholder_br,\n-                       tainted_region);\n-\n-                return Err(if overly_polymorphic {\n-                    debug!(\"Overly polymorphic!\");\n-                    TypeError::RegionsOverlyPolymorphic(placeholder_br, tainted_region)\n-                } else {\n-                    debug!(\"Not as polymorphic!\");\n-                    TypeError::RegionsInsufficientlyPolymorphic(placeholder_br, tainted_region)\n-                })\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// This code converts from placeholder regions back to late-bound\n-    /// regions. It works by replacing each region in the taint set of a\n-    /// placeholder region with a bound-region. The bound region will be bound\n-    /// by the outer-most binder in `value`; the caller must ensure that there is\n-    /// such a binder and it is the right place.\n-    ///\n-    /// This routine is only intended to be used when the leak-check has\n-    /// passed; currently, it's used in the trait matching code to create\n-    /// a set of nested obligations from an impl that matches against\n-    /// something higher-ranked.  More details can be found in\n-    /// `librustc/middle/traits/README.md`.\n-    ///\n-    /// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n-    /// -> &'a int`, and the impl:\n-    ///\n-    ///     impl<A,R> Fn<A,R> for SomethingOrOther\n-    ///         where A : Clone\n-    ///     { ... }\n-    ///\n-    /// Here we will have replaced `'a` with a placeholder region\n-    /// `'0`. This means that our substitution will be `{A=>&'0\n-    /// int, R=>&'0 int}`.\n-    ///\n-    /// When we apply the substitution to the bounds, we will wind up with\n-    /// `&'0 int : Clone` as a predicate. As a last step, we then go and\n-    /// replace `'0` with a late-bound region `'a`.  The depth is matched\n-    /// to the depth of the predicate, in this case 1, so that the final\n-    /// predicate is `for<'a> &'a int : Clone`.\n-    pub fn plug_leaks<T>(&self,\n-                         placeholder_map: PlaceholderMap<'tcx>,\n-                         snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                         value: T) -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        debug!(\"plug_leaks(placeholder_map={:?}, value={:?})\",\n-               placeholder_map,\n-               value);\n-\n-        if placeholder_map.is_empty() {\n-            return value;\n-        }\n-\n-        // Compute a mapping from the \"taint set\" of each placeholder\n-        // region back to the `ty::BoundRegion` that it originally\n-        // represented. Because `leak_check` passed, we know that\n-        // these taint sets are mutually disjoint.\n-        let inv_placeholder_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n-            placeholder_map\n-            .iter()\n-            .flat_map(|(&placeholder_br, &placeholder)| {\n-                self.tainted_regions(snapshot, placeholder, TaintDirections::both())\n-                    .into_iter()\n-                    .map(move |tainted_region| (tainted_region, placeholder_br))\n-            })\n-            .collect();\n-\n-        debug!(\"plug_leaks: inv_placeholder_map={:?}\",\n-               inv_placeholder_map);\n-\n-        // Remove any instantiated type variables from `value`; those can hide\n-        // references to regions from the `fold_regions` code below.\n-        let value = self.resolve_type_vars_if_possible(&value);\n-\n-        // Map any placeholder byproducts back to a late-bound\n-        // region. Put that late-bound region at whatever the outermost\n-        // binder is that we encountered in `value`. The caller is\n-        // responsible for ensuring that (a) `value` contains at least one\n-        // binder and (b) that binder is the one we want to use.\n-        let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n-            match inv_placeholder_map.get(&r) {\n-                None => r,\n-                Some(br) => {\n-                    // It is the responsibility of the caller to ensure\n-                    // that each placeholder region appears within a\n-                    // binder. In practice, this routine is only used by\n-                    // trait checking, and all of the placeholder regions\n-                    // appear inside predicates, which always have\n-                    // binders, so this assert is satisfied.\n-                    assert!(current_depth > ty::INNERMOST);\n-\n-                    // since leak-check passed, this placeholder region\n-                    // should only have incoming edges from variables\n-                    // (which ought not to escape the snapshot, but we\n-                    // don't check that) or itself\n-                    assert!(\n-                        match *r {\n-                            ty::ReVar(_) => true,\n-                            ty::RePlaceholder(index) => index.name == *br,\n-                            _ => false,\n-                        },\n-                        \"leak-check would have us replace {:?} with {:?}\",\n-                        r, br);\n-\n-                    self.tcx.mk_region(ty::ReLateBound(\n-                        current_depth.shifted_out(1),\n-                        br.clone(),\n-                    ))\n-                }\n-            }\n-        });\n-\n-        self.pop_placeholders(placeholder_map, snapshot);\n-\n-        debug!(\"plug_leaks: result={:?}\", result);\n-\n-        result\n-    }\n-\n-    /// Pops the placeholder regions found in `placeholder_map` from the region\n-    /// inference context. Whenever you create placeholder regions via\n-    /// `replace_bound_vars_with_placeholders`, they must be popped before you\n-    /// commit the enclosing snapshot (if you do not commit, e.g., within a\n-    /// probe or as a result of an error, then this is not necessary, as\n-    /// popping happens as part of the rollback).\n-    ///\n-    /// Note: popping also occurs implicitly as part of `leak_check`.\n-    pub fn pop_placeholders(\n-        &self,\n-        placeholder_map: PlaceholderMap<'tcx>,\n-        snapshot: &CombinedSnapshot<'a, 'tcx>,\n-    ) {\n-        debug!(\"pop_placeholders({:?})\", placeholder_map);\n-        let placeholder_regions: FxHashSet<_> = placeholder_map.values().cloned().collect();\n-        self.borrow_region_constraints().pop_placeholders(&placeholder_regions);\n-        self.universe.set(snapshot.universe);\n-        if !placeholder_map.is_empty() {\n-            self.projection_cache.borrow_mut().rollback_placeholder(\n-                &snapshot.projection_cache_snapshot);\n-        }\n-    }\n }"}, {"sha": "dbf8f270ab0c988fb88e6ebb7c4ffddbbd90ad3b", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -73,12 +73,13 @@ pub enum RegionResolutionError<'tcx> {\n     /// `a` (but none of the known bounds are sufficient).\n     GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region<'tcx>),\n \n-    /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n+    /// `SubSupConflict(v, v_origin, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n-    /// Could not infer a value for `v` because `sub_r <= v` (due to\n-    /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n+    /// Could not infer a value for `v` (which has origin `v_origin`)\n+    /// because `sub_r <= v` (due to `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n     SubSupConflict(\n+        RegionVid,\n         RegionVariableOrigin,\n         SubregionOrigin<'tcx>,\n         Region<'tcx>,\n@@ -215,23 +216,41 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n-        // Check if this relationship is implied by a given.\n         match *a_region {\n+            // Check if this relationship is implied by a given.\n             ty::ReEarlyBound(_) | ty::ReFree(_) => if self.data.givens.contains(&(a_region, b_vid))\n             {\n                 debug!(\"given\");\n                 return false;\n             },\n+\n             _ => {}\n         }\n \n+\n         match *b_data {\n             VarValue::Value(cur_region) => {\n-                let lub = self.lub_concrete_regions(a_region, cur_region);\n+                let mut lub = self.lub_concrete_regions(a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n                 }\n \n+                // Watch out for `'b: !1` relationships, where the\n+                // universe of `'b` can't name the placeholder `!1`. In\n+                // that case, we have to grow `'b` to be `'static` for the\n+                // relationship to hold. This is obviously a kind of sub-optimal\n+                // choice -- in the future, when we incorporate a knowledge\n+                // of the parameter environment, we might be able to find a\n+                // tighter bound than `'static`.\n+                //\n+                // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n+                let b_universe = self.var_infos[b_vid].universe;\n+                if let ty::RePlaceholder(p) = lub {\n+                    if b_universe.cannot_name(p.universe) {\n+                        lub = self.tcx().types.re_static;\n+                    }\n+                }\n+\n                 debug!(\n                     \"Expanding value of {:?} from {:?} to {:?}\",\n                     b_vid, cur_region, lub\n@@ -554,10 +573,22 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         lower_bounds.sort_by_key(region_order_key);\n         upper_bounds.sort_by_key(region_order_key);\n \n+        let node_universe = self.var_infos[node_idx].universe;\n+\n         for lower_bound in &lower_bounds {\n+            let effective_lower_bound = if let ty::RePlaceholder(p) = lower_bound.region {\n+                if node_universe.cannot_name(p.universe) {\n+                    self.tcx().types.re_static\n+                } else {\n+                    lower_bound.region\n+                }\n+            } else {\n+                lower_bound.region\n+            };\n+\n             for upper_bound in &upper_bounds {\n                 if !self.region_rels\n-                    .is_subregion_of(lower_bound.region, upper_bound.region)\n+                    .is_subregion_of(effective_lower_bound, upper_bound.region)\n                 {\n                     let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n@@ -566,6 +597,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                         origin, node_idx, lower_bound.region, upper_bound.region\n                     );\n                     errors.push(RegionResolutionError::SubSupConflict(\n+                        node_idx,\n                         origin,\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n@@ -580,9 +612,10 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         span_bug!(\n             self.var_infos[node_idx].origin.span(),\n             \"collect_error_for_expanding_node() could not find \\\n-             error for var {:?}, lower_bounds={:?}, \\\n-             upper_bounds={:?}\",\n+             error for var {:?} in universe {:?}, lower_bounds={:#?}, \\\n+             upper_bounds={:#?}\",\n             node_idx,\n+            node_universe,\n             lower_bounds,\n             upper_bounds\n         );"}, {"sha": "2d3fb137fafdd0aabbbbcc8942c877a5842098e6", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 38, "deletions": 71, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -32,7 +32,6 @@ use ty::{FloatVid, IntVid, TyVid};\n use util::nodemap::FxHashMap;\n \n use self::combine::CombineFields;\n-use self::higher_ranked::HrMatchResult;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n@@ -226,7 +225,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n     Regions(ExpectedFound<ty::Region<'tcx>>),\n@@ -868,6 +867,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n+    /// Scan the constraints produced since `snapshot` began and returns:\n+    ///\n+    /// - None -- if none of them involve \"region outlives\" constraints\n+    /// - Some(true) -- if there are `'a: 'b` constraints where `'a` or `'b` is a placehodler\n+    /// - Some(false) -- if there are `'a: 'b` constraints but none involve placeholders\n+    pub fn region_constraints_added_in_snapshot(\n+        &self,\n+        snapshot: &CombinedSnapshot<'a, 'tcx>,\n+    ) -> Option<bool> {\n+        self.borrow_region_constraints().region_constraints_added_in_snapshot(\n+            &snapshot.region_constraints_snapshot,\n+        )\n+    }\n+\n     pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n         self.borrow_region_constraints().add_given(sub, sup);\n     }\n@@ -939,39 +952,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        Some(self.commit_if_ok(|snapshot| {\n-            let (\n-                ty::SubtypePredicate {\n-                    a_is_expected,\n-                    a,\n-                    b,\n-                },\n-                placeholder_map,\n-            ) = self.replace_bound_vars_with_placeholders(predicate);\n+        let (\n+            ty::SubtypePredicate {\n+                a_is_expected,\n+                a,\n+                b,\n+            },\n+            _,\n+        ) = self.replace_bound_vars_with_placeholders(predicate);\n \n-            let cause_span = cause.span;\n-            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n-            self.leak_check(false, cause_span, &placeholder_map, snapshot)?;\n-            self.pop_placeholders(placeholder_map, snapshot);\n-            Ok(ok.unit())\n-        }))\n+        Some(\n+            self.at(cause, param_env)\n+                .sub_exp(a_is_expected, a, b)\n+                .map(|ok| ok.unit()),\n+        )\n     }\n \n     pub fn region_outlives_predicate(\n         &self,\n         cause: &traits::ObligationCause<'tcx>,\n         predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n-    ) -> UnitResult<'tcx> {\n-        self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n-            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n-                RelateRegionParamBound(cause.span)\n-            });\n-            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, cause.span, &placeholder_map, snapshot)?;\n-            Ok(self.pop_placeholders(placeholder_map, snapshot))\n-        })\n+    ) {\n+        let (ty::OutlivesPredicate(r_a, r_b), _) =\n+            self.replace_bound_vars_with_placeholders(predicate);\n+        let origin =\n+            SubregionOrigin::from_obligation_cause(cause, || RelateRegionParamBound(cause.span));\n+        self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n@@ -1380,46 +1386,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.replace_bound_vars(value, fld_r, fld_t)\n     }\n \n-    /// Given a higher-ranked projection predicate like:\n-    ///\n-    ///     for<'a> <T as Fn<&'a u32>>::Output = &'a u32\n-    ///\n-    /// and a target trait-ref like:\n-    ///\n-    ///     <T as Fn<&'x u32>>\n-    ///\n-    /// find a substitution `S` for the higher-ranked regions (here,\n-    /// `['a => 'x]`) such that the predicate matches the trait-ref,\n-    /// and then return the value (here, `&'a u32`) but with the\n-    /// substitution applied (hence, `&'x u32`).\n-    ///\n-    /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n-    /// details.\n-    pub fn match_poly_projection_predicate(\n-        &self,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        match_a: ty::PolyProjectionPredicate<'tcx>,\n-        match_b: ty::TraitRef<'tcx>,\n-    ) -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>> {\n-        let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n-        let trace = TypeTrace {\n-            cause,\n-            values: TraitRefs(ExpectedFound::new(\n-                true,\n-                match_pair.skip_binder().0,\n-                match_b,\n-            )),\n-        };\n-\n-        let mut combine = self.combine_fields(trace, param_env);\n-        let result = combine.higher_ranked_match(&match_pair, &match_b, true)?;\n-        Ok(InferOk {\n-            value: result,\n-            obligations: combine.obligations,\n-        })\n-    }\n-\n     /// See `verify_generic_bound` method in `region_constraints`\n     pub fn verify_generic_bound(\n         &self,\n@@ -1434,18 +1400,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn type_moves_by_default(\n+    pub fn type_is_copy_modulo_regions(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n+\n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only.\n         if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n             if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n-                return ty.moves_by_default(self.tcx.global_tcx(), param_env, span);\n+                return ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span);\n             }\n         }\n \n@@ -1455,7 +1422,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        !traits::type_known_to_meet_bound(self, param_env, ty, copy_def_id, span)\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n     }\n \n     /// Obtains the latest type of the given closure; this may be a"}, {"sha": "56ae850226c91624f2ab24010555f9c993434225", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -17,8 +17,6 @@ use ty::{Region, RegionVid};\n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem, u32};\n \n-mod taint;\n-\n #[derive(Default)]\n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n@@ -130,6 +128,16 @@ pub enum Constraint<'tcx> {\n     RegSubReg(Region<'tcx>, Region<'tcx>),\n }\n \n+impl Constraint<'_> {\n+    pub fn involves_placeholders(&self) -> bool {\n+        match self {\n+            Constraint::VarSubVar(_, _) => false,\n+            Constraint::VarSubReg(_, r) | Constraint::RegSubVar(r, _) => r.is_placeholder(),\n+            Constraint::RegSubReg(r, s) => r.is_placeholder() || s.is_placeholder(),\n+        }\n+    }\n+}\n+\n /// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n /// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n@@ -326,6 +334,8 @@ impl TaintDirections {\n     }\n }\n \n+pub struct ConstraintInfo {}\n+\n impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn new() -> Self {\n         Self::default()\n@@ -487,7 +497,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ) -> RegionVid {\n         let vid = self.var_infos.push(RegionVariableInfo { origin, universe });\n \n-        let u_vid = self.unification_table\n+        let u_vid = self\n+            .unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n         assert_eq!(vid, u_vid);\n         if self.in_snapshot() {\n@@ -519,7 +530,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         assert!(self.in_snapshot());\n \n-        let constraints_to_kill: Vec<usize> = self.undo_log\n+        let constraints_to_kill: Vec<usize> = self\n+            .undo_log\n             .iter()\n             .enumerate()\n             .rev()\n@@ -822,37 +834,18 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n                 _ => None,\n-            })\n-            .collect()\n-    }\n-\n-    /// Computes all regions that have been related to `r0` since the\n-    /// mark `mark` was made---`r0` itself will be the first\n-    /// entry. The `directions` parameter controls what kind of\n-    /// relations are considered. For example, one can say that only\n-    /// \"incoming\" edges to `r0` are desired, in which case one will\n-    /// get the set of regions `{r|r <= r0}`. This is used when\n-    /// checking whether placeholder regions are being improperly\n-    /// related to other regions.\n-    pub fn tainted(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        mark: &RegionSnapshot,\n-        r0: Region<'tcx>,\n-        directions: TaintDirections,\n-    ) -> FxHashSet<ty::Region<'tcx>> {\n-        debug!(\n-            \"tainted(mark={:?}, r0={:?}, directions={:?})\",\n-            mark, r0, directions\n-        );\n+            }).collect()\n+    }\n \n-        // `result_set` acts as a worklist: we explore all outgoing\n-        // edges and add any new regions we find to result_set.  This\n-        // is not a terribly efficient implementation.\n-        let mut taint_set = taint::TaintSet::new(directions, r0);\n-        taint_set.fixed_point(tcx, &self.undo_log[mark.length..], &self.data.verifys);\n-        debug!(\"tainted: result={:?}\", taint_set);\n-        return taint_set.into_set();\n+    /// See [`RegionInference::region_constraints_added_in_snapshot`]\n+    pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> Option<bool> {\n+        self.undo_log[mark.length..]\n+            .iter()\n+            .map(|&elt| match elt {\n+                AddConstraint(constraint) => Some(constraint.involves_placeholders()),\n+                _ => None,\n+            }).max()\n+            .unwrap_or(None)\n     }\n }\n "}, {"sha": "6743f37972ae52b8cb36b7a87c590ee50aea934c", "filename": "src/librustc/infer/region_constraints/taint.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2442823ef572a65092fbc46f6975633f983b50b6/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2442823ef572a65092fbc46f6975633f983b50b6/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs?ref=2442823ef572a65092fbc46f6975633f983b50b6", "patch": "@@ -1,85 +0,0 @@\n-use super::*;\n-\n-#[derive(Debug)]\n-pub(super) struct TaintSet<'tcx> {\n-    directions: TaintDirections,\n-    regions: FxHashSet<ty::Region<'tcx>>,\n-}\n-\n-impl<'tcx> TaintSet<'tcx> {\n-    pub(super) fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n-        let mut regions = FxHashSet::default();\n-        regions.insert(initial_region);\n-        TaintSet {\n-            directions: directions,\n-            regions: regions,\n-        }\n-    }\n-\n-    pub(super) fn fixed_point(\n-        &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        undo_log: &[UndoLog<'tcx>],\n-        verifys: &[Verify<'tcx>],\n-    ) {\n-        let mut prev_len = 0;\n-        while prev_len < self.len() {\n-            debug!(\n-                \"tainted: prev_len = {:?} new_len = {:?}\",\n-                prev_len,\n-                self.len()\n-            );\n-\n-            prev_len = self.len();\n-\n-            for undo_entry in undo_log {\n-                match undo_entry {\n-                    &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::RegSubVar(a, b)) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::VarSubReg(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n-                    }\n-                    &AddConstraint(Constraint::RegSubReg(a, b)) => {\n-                        self.add_edge(a, b);\n-                    }\n-                    &AddGiven(a, b) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddVerify(i) => {\n-                        span_bug!(\n-                            verifys[i].origin.span(),\n-                            \"we never add verifications while doing higher-ranked things\",\n-                        )\n-                    }\n-                    &Purged | &AddCombination(..) | &AddVar(..) => {}\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(super) fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n-        self.regions\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.regions.len()\n-    }\n-\n-    fn add_edge(&mut self, source: ty::Region<'tcx>, target: ty::Region<'tcx>) {\n-        if self.directions.incoming {\n-            if self.regions.contains(&target) {\n-                self.regions.insert(source);\n-            }\n-        }\n-\n-        if self.directions.outgoing {\n-            if self.regions.contains(&source) {\n-                self.regions.insert(target);\n-            }\n-        }\n-    }\n-}"}, {"sha": "c1aa25b6b75c20f842ed1ed28e0e395ee93e2053", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -976,7 +976,7 @@ fn copy_or_move<'a, 'gcx, 'tcx>(mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx\n                                 move_reason: MoveReason)\n                                 -> ConsumeMode\n {\n-    if mc.type_moves_by_default(param_env, cmt.ty, cmt.span) {\n+    if !mc.type_is_copy_modulo_regions(param_env, cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "370f0d1a6c6d7ff5eb5a2e4da5193462c260f67e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -443,15 +443,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn type_moves_by_default(&self,\n-                                 param_env: ty::ParamEnv<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 span: Span)\n-                                 -> bool {\n-        self.infcx.map(|infcx| infcx.type_moves_by_default(param_env, ty, span))\n+    pub fn type_is_copy_modulo_regions(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool {\n+        self.infcx.map(|infcx| infcx.type_is_copy_modulo_regions(param_env, ty, span))\n             .or_else(|| {\n                 self.tcx.lift_to_global(&(param_env, ty)).map(|(param_env, ty)| {\n-                    ty.moves_by_default(self.tcx.global_tcx(), param_env, span)\n+                    ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span)\n                 })\n             })\n             .unwrap_or(true)"}, {"sha": "92004ece26d004a30ade168bbe7a3afd5a36a432", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -771,13 +771,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     }\n                 }\n                 &ty::Predicate::RegionOutlives(ref binder) => {\n-                    if select\n-                        .infcx()\n-                        .region_outlives_predicate(&dummy_cause, binder)\n-                        .is_err()\n-                    {\n-                        return false;\n-                    }\n+                    let () = select.infcx().region_outlives_predicate(&dummy_cause, binder);\n                 }\n                 &ty::Predicate::TypeOutlives(ref binder) => {\n                     match ("}, {"sha": "b3d732ebcd7dc07e1342bda638b9e71d23aedd43", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -4,6 +4,7 @@\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n //! [trait-specialization]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n+use infer::CombinedSnapshot;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n@@ -33,6 +34,17 @@ pub enum Conflict {\n pub struct OverlapResult<'tcx> {\n     pub impl_header: ty::ImplHeader<'tcx>,\n     pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+\n+    /// True if the overlap might've been permitted before the shift\n+    /// to universes.\n+    pub involves_placeholder: bool,\n+}\n+\n+pub fn add_placeholder_note(err: &mut ::errors::DiagnosticBuilder<'_>) {\n+    err.note(&format!(\n+        \"this behavior recently changed as a result of a bug fix; \\\n+         see rust-lang/rust#56105 for details\"\n+    ));\n }\n \n /// If there are types that satisfy both impls, invokes `on_overlap`\n@@ -104,13 +116,22 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n-fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-                            a_def_id: DefId,\n-                            b_def_id: DefId)\n-                            -> Option<OverlapResult<'tcx>>\n-{\n+fn overlap<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    a_def_id: DefId,\n+    b_def_id: DefId,\n+) -> Option<OverlapResult<'tcx>> {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n \n+    selcx.infcx().probe(|snapshot| overlap_within_probe(selcx, a_def_id, b_def_id, snapshot))\n+}\n+\n+fn overlap_within_probe(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    a_def_id: DefId,\n+    b_def_id: DefId,\n+    snapshot: &CombinedSnapshot<'_, 'tcx>,\n+) -> Option<OverlapResult<'tcx>> {\n     // For the purposes of this check, we don't bring any placeholder\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n@@ -158,7 +179,13 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     let impl_header = selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n-    Some(OverlapResult { impl_header, intercrate_ambiguity_causes })\n+\n+    let involves_placeholder = match selcx.infcx().region_constraints_added_in_snapshot(snapshot) {\n+        Some(true) => true,\n+        _ => false,\n+    };\n+\n+    Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "21352ac1053a8e7c4cc106f3c64025d68284efb6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -728,12 +728,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n-                        let err = self.region_outlives_predicate(&obligation.cause,\n-                                                                 &predicate).err().unwrap();\n-                        struct_span_err!(self.tcx.sess, span, E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate, err)\n+                        // These errors should show up as region\n+                        // inference failures.\n+                        panic!(\"region outlives {:?} failed\", predicate);\n                     }\n \n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {"}, {"sha": "2e00d4d4b7c3bda796d77f380c4d2b7e15926039", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                 if data.is_global() {\n                     // no type variables present, can use evaluation for better caching.\n                     // FIXME: consider caching errors too.\n-                    if self.selcx.infcx().predicate_must_hold(&obligation) {\n+                    if self.selcx.infcx().predicate_must_hold_considering_regions(&obligation) {\n                         debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n                                data, obligation.recursion_depth);\n                         return ProcessResult::Changed(vec![])\n@@ -331,10 +331,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }\n \n             ty::Predicate::RegionOutlives(ref binder) => {\n-                match self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n-                    Ok(()) => ProcessResult::Changed(vec![]),\n-                    Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n-                }\n+                let () = self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder);\n+                ProcessResult::Changed(vec![])\n             }\n \n             ty::Predicate::TypeOutlives(ref binder) => {"}, {"sha": "b42d742b7f84139baa982af89134866fbefd245f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -43,7 +43,8 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n-pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n+pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n+pub use self::coherence::{OrphanCheckErr, OverlapResult};\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n@@ -628,14 +629,14 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                param_env: ty::ParamEnv<'tcx>,\n-                                                ty: Ty<'tcx>,\n-                                                def_id: DefId,\n-                                                span: Span)\n--> bool\n-{\n-    debug!(\"type_known_to_meet_bound(ty={:?}, bound={:?})\",\n+pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    def_id: DefId,\n+    span: Span,\n+) -> bool {\n+    debug!(\"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n            ty,\n            infcx.tcx.item_path_str(def_id));\n \n@@ -650,7 +651,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         predicate: trait_ref.to_predicate(),\n     };\n \n-    let result = infcx.predicate_must_hold(&obligation);\n+    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n     debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n            ty, infcx.tcx.item_path_str(def_id), result);\n \n@@ -677,13 +678,13 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         // assume it is move; linear is always ok.\n         match fulfill_cx.select_all_or_error(infcx) {\n             Ok(()) => {\n-                debug!(\"type_known_to_meet_bound: ty={:?} bound={} success\",\n+                debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n                        ty,\n                        infcx.tcx.item_path_str(def_id));\n                 true\n             }\n             Err(e) => {\n-                debug!(\"type_known_to_meet_bound: ty={:?} bound={} errors={:?}\",\n+                debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n                        ty,\n                        infcx.tcx.item_path_str(def_id),\n                        e);"}, {"sha": "31342c250e2bdc86e7883c084cedc80c954c7bcb", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -568,7 +568,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n         self.infer_ctxt().enter(|ref infcx| {\n             // the receiver is dispatchable iff the obligation holds\n-            infcx.predicate_must_hold(&obligation)\n+            infcx.predicate_must_hold_modulo_regions(&obligation)\n         })\n     }\n "}, {"sha": "732ca70dc78c5e111b3711807ffae6727ae69fe2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -13,7 +13,7 @@ use super::{VtableImplData, VtableClosureData, VtableGeneratorData, VtableFnPoin\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk};\n+use infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use infer::type_variable::TypeVariableOrigin;\n use mir::interpret::ConstValue;\n use mir::interpret::{GlobalId};\n@@ -192,28 +192,12 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n            obligation);\n \n     let infcx = selcx.infcx();\n-    infcx.commit_if_ok(|snapshot| {\n-        let (placeholder_predicate, placeholder_map) =\n+    infcx.commit_if_ok(|_| {\n+        let (placeholder_predicate, _) =\n             infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n \n-        let skol_obligation = obligation.with(placeholder_predicate);\n-        let r = match project_and_unify_type(selcx, &skol_obligation) {\n-            Ok(result) => {\n-                let span = obligation.cause.span;\n-                match infcx.leak_check(false, span, &placeholder_map, snapshot) {\n-                    Ok(()) => Ok(infcx.plug_leaks(placeholder_map, snapshot, result)),\n-                    Err(e) => {\n-                        debug!(\"poly_project_and_unify_type: leak check encountered error {:?}\", e);\n-                        Err(MismatchedProjectionTypes { err: e })\n-                    }\n-                }\n-            }\n-            Err(e) => {\n-                Err(e)\n-            }\n-        };\n-\n-        r\n+        let placeholder_obligation = obligation.with(placeholder_predicate);\n+        project_and_unify_type(selcx, &placeholder_obligation)\n     })\n }\n \n@@ -1443,17 +1427,25 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    poly_projection: ty::PolyProjectionPredicate<'tcx>)\n+    poly_cache_entry: ty::PolyProjectionPredicate<'tcx>)\n     -> Progress<'tcx>\n {\n     let infcx = selcx.infcx();\n-    let cause = obligation.cause.clone();\n+    let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n-    let trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n-    match infcx.match_poly_projection_predicate(cause, param_env, poly_projection, trait_ref) {\n-        Ok(InferOk { value: ty_match, obligations }) => {\n+\n+    let (cache_entry, _) =\n+        infcx.replace_bound_vars_with_fresh_vars(\n+            cause.span,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            &poly_cache_entry);\n+\n+    let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n+    let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n+    match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n+        Ok(InferOk { value: _, obligations }) => {\n             Progress {\n-                ty: ty_match.value,\n+                ty: cache_entry.ty,\n                 obligations,\n             }\n         }\n@@ -1463,7 +1455,7 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n                 \"Failed to unify obligation `{:?}` \\\n                  with poly_projection `{:?}`: {:?}\",\n                 obligation,\n-                poly_projection,\n+                poly_cache_entry,\n                 e);\n         }\n     }"}, {"sha": "fdae7d833734e5ebc96c264b3d534dd56700f065", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -16,11 +16,26 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied in the given\n     /// `ParamEnv`, and returns `false` if not certain. However, this is\n     /// not entirely accurate if inference variables are involved.\n-    pub fn predicate_must_hold(\n+    ///\n+    /// This version may conservatively fail when outlives obligations\n+    /// are required.\n+    pub fn predicate_must_hold_considering_regions(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n-        self.evaluate_obligation_no_overflow(obligation) == EvaluationResult::EvaluatedToOk\n+        self.evaluate_obligation_no_overflow(obligation).must_apply_considering_regions()\n+    }\n+\n+    /// Evaluates whether the predicate can be satisfied in the given\n+    /// `ParamEnv`, and returns `false` if not certain. However, this is\n+    /// not entirely accurate if inference variables are involved.\n+    ///\n+    /// This version ignores all outlives constraints.\n+    pub fn predicate_must_hold_modulo_regions(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        self.evaluate_obligation_no_overflow(obligation).must_apply_modulo_regions()\n     }\n \n     /// Evaluate a given predicate, capturing overflow and propagating it back."}, {"sha": "373ec2d5e490fc5605a2389f2751b3a44a37232a", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 96, "deletions": 226, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -29,7 +29,6 @@ use super::{\n \n use dep_graph::{DepKind, DepNodeIndex};\n use hir::def_id::DefId;\n-use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener};\n use middle::lang_items;\n use mir::interpret::GlobalId;\n@@ -45,7 +44,6 @@ use rustc_target::spec::abi::Abi;\n use std::cmp;\n use std::fmt;\n use std::iter;\n-use std::mem;\n use std::rc::Rc;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -328,7 +326,8 @@ enum BuiltinImplConditions<'tcx> {\n /// evaluations.\n ///\n /// The evaluation results are ordered:\n-///     - `EvaluatedToOk` implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n+///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n+///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n ///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n ///     - the \"union\" of evaluation results is equal to their maximum -\n ///     all the \"potential success\" candidates can potentially succeed,\n@@ -337,6 +336,8 @@ enum BuiltinImplConditions<'tcx> {\n pub enum EvaluationResult {\n     /// Evaluation successful\n     EvaluatedToOk,\n+    /// Evaluation successful, but there were unevaluated region obligations\n+    EvaluatedToOkModuloRegions,\n     /// Evaluation is known to be ambiguous - it *might* hold for some\n     /// assignment of inference variables, but it might not.\n     ///\n@@ -400,9 +401,23 @@ pub enum EvaluationResult {\n }\n \n impl EvaluationResult {\n+    /// True if this evaluation result is known to apply, even\n+    /// considering outlives constraints.\n+    pub fn must_apply_considering_regions(self) -> bool {\n+        self == EvaluatedToOk\n+    }\n+\n+    /// True if this evaluation result is known to apply, ignoring\n+    /// outlives constraints.\n+    pub fn must_apply_modulo_regions(self) -> bool {\n+        self <= EvaluatedToOkModuloRegions\n+    }\n+\n     pub fn may_apply(self) -> bool {\n         match self {\n-            EvaluatedToOk | EvaluatedToAmbig | EvaluatedToUnknown => true,\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n+                true\n+            }\n \n             EvaluatedToErr | EvaluatedToRecur => false,\n         }\n@@ -412,13 +427,14 @@ impl EvaluationResult {\n         match self {\n             EvaluatedToUnknown | EvaluatedToRecur => true,\n \n-            EvaluatedToOk | EvaluatedToAmbig | EvaluatedToErr => false,\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n         }\n     }\n }\n \n impl_stable_hash_for!(enum self::EvaluationResult {\n     EvaluatedToOk,\n+    EvaluatedToOkModuloRegions,\n     EvaluatedToAmbig,\n     EvaluatedToUnknown,\n     EvaluatedToRecur,\n@@ -531,33 +547,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n-    /// context's self.\n-    fn in_snapshot<R, F>(&mut self, f: F) -> R\n-    where\n-        F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R,\n-    {\n-        self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n-    }\n-\n-    /// Wraps a probe s.t. obligations collected during it are ignored and old obligations are\n-    /// retained.\n-    fn probe<R, F>(&mut self, f: F) -> R\n-    where\n-        F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R,\n-    {\n-        self.infcx.probe(|snapshot| f(self, snapshot))\n-    }\n-\n-    /// Wraps a commit_if_ok s.t. obligations collected during it are not returned in selection if\n-    /// the transaction fails and s.t. old obligations are retained.\n-    fn commit_if_ok<T, E, F>(&mut self, f: F) -> Result<T, E>\n-    where\n-        F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> Result<T, E>,\n-    {\n-        self.infcx.commit_if_ok(|snapshot| f(self, snapshot))\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -639,11 +628,24 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        self.probe(|this, _| {\n+        self.evaluation_probe(|this| {\n             this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n         })\n     }\n \n+    fn evaluation_probe(\n+        &mut self,\n+        op: impl FnOnce(&mut Self) -> Result<EvaluationResult, OverflowError>,\n+    ) -> Result<EvaluationResult, OverflowError> {\n+        self.infcx.probe(|snapshot| -> Result<EvaluationResult, OverflowError> {\n+            let result = op(self)?;\n+            match self.infcx.region_constraints_added_in_snapshot(snapshot) {\n+                None => Ok(result),\n+                Some(_) => Ok(result.max(EvaluatedToOkModuloRegions)),\n+            }\n+        })\n+    }\n+\n     /// Evaluates the predicates in `predicates` recursively. Note that\n     /// this applies projections in the predicates, and therefore\n     /// is run within an inference probe.\n@@ -714,92 +716,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 None => Ok(EvaluatedToAmbig),\n             },\n \n-            ty::Predicate::TypeOutlives(ref binder) => {\n-                assert!(!binder.has_escaping_bound_vars());\n-                // Check if the type has higher-ranked vars.\n-                if binder.skip_binder().0.has_escaping_bound_vars() {\n-                    // If so, this obligation is an error (for now). Eventually we should be\n-                    // able to support additional cases here, like `for<'a> &'a str: 'a`.\n-\n-                    // NOTE: this hack is implemented in both trait fulfillment and\n-                    // evaluation. If you fix it in one place, make sure you fix it\n-                    // in the other.\n-\n-                    // We don't want to allow this sort of reasoning in intercrate\n-                    // mode, for backwards-compatibility reasons.\n-                    if self.intercrate.is_some() {\n-                        Ok(EvaluatedToAmbig)\n-                    } else {\n-                        Ok(EvaluatedToErr)\n-                    }\n-                } else {\n-                    // If the type has no late bound vars, then if we assign all\n-                    // the inference variables in it to be 'static, then the type\n-                    // will be 'static itself.\n-                    //\n-                    // Therefore, `staticize(T): 'a` holds for any `'a`, so this\n-                    // obligation is fulfilled. Because evaluation works with\n-                    // staticized types (yes I know this is involved with #21974),\n-                    // we are 100% OK here.\n-                    Ok(EvaluatedToOk)\n-                }\n-            }\n-\n-            ty::Predicate::RegionOutlives(ref binder) => {\n-                let ty::OutlivesPredicate(r_a, r_b) = binder.skip_binder();\n-\n-                if r_a == r_b {\n-                    // for<'a> 'a: 'a. OK\n-                    Ok(EvaluatedToOk)\n-                } else if **r_a == ty::ReStatic {\n-                    // 'static: 'x always holds.\n-                    //\n-                    // This special case is handled somewhat inconsistently - if we\n-                    // have an inference variable that is supposed to be equal to\n-                    // `'static`, then we don't allow it to be equated to an LBR,\n-                    // but if we have a literal `'static`, then we *do*.\n-                    //\n-                    // This is actually consistent with how our region inference works.\n-                    //\n-                    // It would appear that this sort of inconsistency would\n-                    // cause \"instability\" problems with evaluation caching. However,\n-                    // evaluation caching is only for trait predicates, and when\n-                    // trait predicates create nested obligations, they contain\n-                    // inference variables for all the regions in the trait - the\n-                    // only way this codepath can be reached from trait predicate\n-                    // evaluation is when the user typed an explicit `where 'static: 'a`\n-                    // lifetime bound (in which case we want to return EvaluatedToOk).\n-                    //\n-                    // If we ever want to handle inference variables that might be\n-                    // equatable with ReStatic, we need to make sure we are not confused by\n-                    // technically-allowed-by-RFC-447-but-probably-should-not-be\n-                    // impls such as\n-                    // ```Rust\n-                    // impl<'a, 's, T> X<'s> for T where T: Debug + 'a, 'a: 's\n-                    // ```\n-                    Ok(EvaluatedToOk)\n-                } else if r_a.is_late_bound() || r_b.is_late_bound() {\n-                    // There is no current way to prove `for<'a> 'a: 'x`\n-                    // unless `'a = 'x`, because there are no bounds involving\n-                    // lifetimes.\n-\n-                    // It might be possible to prove `for<'a> 'x: 'a` by forcing `'x`\n-                    // to be `'static`. However, this is not currently done by type\n-                    // inference unless `'x` is literally ReStatic. See the comment\n-                    // above.\n-\n-                    // We don't want to allow this sort of reasoning in intercrate\n-                    // mode, for backwards-compatibility reasons.\n-                    if self.intercrate.is_some() {\n-                        Ok(EvaluatedToAmbig)\n-                    } else {\n-                        Ok(EvaluatedToErr)\n-                    }\n-                } else {\n-                    // Relating 2 inference variable regions. These will\n-                    // always hold if our query is \"staticized\".\n-                    Ok(EvaluatedToOk)\n-                }\n+            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n+                // we do not consider region relationships when\n+                // evaluating trait matches\n+                Ok(EvaluatedToOkModuloRegions)\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n@@ -1013,6 +933,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n \n+            // Subtle: when checking for a coinductive cycle, we do\n+            // not compare using the \"freshened trait refs\" (which\n+            // have erased regions) but rather the fully explicit\n+            // trait refs. This is important because it's only a cycle\n+            // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take(rec_index + 1);\n             let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n             if self.coinductive_match(cycle) {\n@@ -1075,7 +1000,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             \"evaluate_candidate: depth={} candidate={:?}\",\n             stack.obligation.recursion_depth, candidate\n         );\n-        let result = self.probe(|this, _| {\n+        let result = self.evaluation_probe(|this| {\n             let candidate = (*candidate).clone();\n             match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => this.evaluate_predicates_recursively(\n@@ -1706,8 +1631,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             _ => return,\n         }\n \n-        let result = self.probe(|this, snapshot| {\n-            this.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n+        let result = self.infcx.probe(|_| {\n+            self.match_projection_obligation_against_definition_bounds(obligation)\n         });\n \n         if result {\n@@ -1718,16 +1643,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> bool {\n         let poly_trait_predicate = self.infcx()\n             .resolve_type_vars_if_possible(&obligation.predicate);\n-        let (skol_trait_predicate, placeholder_map) = self.infcx()\n+        let (skol_trait_predicate, _) = self.infcx()\n             .replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n-             skol_trait_predicate={:?} placeholder_map={:?}\",\n-            skol_trait_predicate, placeholder_map\n+             skol_trait_predicate={:?}\",\n+            skol_trait_predicate,\n         );\n \n         let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n@@ -1759,13 +1683,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let matching_bound = util::elaborate_predicates(self.tcx(), bounds.predicates)\n             .filter_to_traits()\n             .find(|bound| {\n-                self.probe(|this, _| {\n-                    this.match_projection(\n+                self.infcx.probe(|_| {\n+                    self.match_projection(\n                         obligation,\n                         bound.clone(),\n                         skol_trait_predicate.trait_ref.clone(),\n-                        &placeholder_map,\n-                        snapshot,\n                     )\n                 })\n             });\n@@ -1783,12 +1705,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     obligation,\n                     bound,\n                     skol_trait_predicate.trait_ref.clone(),\n-                    &placeholder_map,\n-                    snapshot,\n                 );\n \n-                self.infcx.pop_placeholders(placeholder_map, snapshot);\n-\n                 assert!(result);\n                 true\n             }\n@@ -1800,20 +1718,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n         skol_trait_ref: ty::TraitRef<'tcx>,\n-        placeholder_map: &infer::PlaceholderMap<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> bool {\n         debug_assert!(!skol_trait_ref.has_escaping_bound_vars());\n-        if self.infcx\n+        self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(skol_trait_ref), trait_bound)\n-            .is_err()\n-        {\n-            return false;\n-        }\n-\n-        self.infcx\n-            .leak_check(false, obligation.cause.span, placeholder_map, snapshot)\n             .is_ok()\n     }\n \n@@ -1862,7 +1771,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         stack: &TraitObligationStack<'o, 'tcx>,\n         where_clause_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        self.probe(move |this, _| {\n+        self.evaluation_probe(|this| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n                     this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n@@ -2015,14 +1924,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.probe(|this, snapshot| {\n-                    if let Ok(placeholder_map) = this.match_impl(impl_def_id, obligation, snapshot)\n+                self.infcx.probe(|_| {\n+                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation)\n                     {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n-\n-                        // N.B., we can safely drop the placeholder map\n-                        // since we are in a probe.\n-                        mem::drop(placeholder_map);\n                     }\n                 });\n             },\n@@ -2093,11 +1998,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.self_ty().skip_binder()\n         );\n \n-        self.probe(|this, _snapshot| {\n+        self.infcx.probe(|_snapshot| {\n             // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR.\n-            let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n+            let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n                 ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits()\n@@ -2111,7 +2016,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         return;\n                     }\n \n-                    data.principal().with_self_ty(this.tcx(), self_ty)\n+                    data.principal().with_self_ty(self.tcx(), self_ty)\n                 }\n                 ty::Infer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -2131,11 +2036,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // correct trait, but also the correct type parameters.\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo : Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(this.tcx(), poly_trait_ref)\n+            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n                 .filter(|upcast_trait_ref| {\n-                    this.probe(|this, _| {\n+                    self.infcx.probe(|_| {\n                         let upcast_trait_ref = upcast_trait_ref.clone();\n-                        this.match_poly_trait_ref(obligation, upcast_trait_ref)\n+                        self.match_poly_trait_ref(obligation, upcast_trait_ref)\n                             .is_ok()\n                     })\n                 })\n@@ -2352,7 +2257,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // See if we can toss out `victim` based on specialization.\n                 // This requires us to know *for sure* that the `other` impl applies\n                 // i.e., EvaluatedToOk:\n-                if other.evaluation == EvaluatedToOk {\n+                if other.evaluation.must_apply_modulo_regions() {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n                             let tcx = self.tcx().global_tcx();\n@@ -2379,7 +2284,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     ParamCandidate(ref cand) => {\n                         // Prefer these to a global where-clause bound\n                         // (see issue #50825)\n-                        is_global(cand) && other.evaluation == EvaluatedToOk\n+                        is_global(cand) && other.evaluation.must_apply_modulo_regions()\n                     }\n                     _ => false,\n                 }\n@@ -2680,20 +2585,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // binder moved -\\\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n-                self.in_snapshot(|this, snapshot| {\n-                    let (skol_ty, placeholder_map) = this.infcx()\n+                self.infcx.in_snapshot(|_| {\n+                    let (skol_ty, _) = self.infcx\n                         .replace_bound_vars_with_placeholders(&ty);\n                     let Normalized {\n                         value: normalized_ty,\n                         mut obligations,\n                     } = project::normalize_with_depth(\n-                        this,\n+                        self,\n                         param_env,\n                         cause.clone(),\n                         recursion_depth,\n                         &skol_ty,\n                     );\n-                    let skol_obligation = this.tcx().predicate_for_trait_def(\n+                    let skol_obligation = self.tcx().predicate_for_trait_def(\n                         param_env,\n                         cause.clone(),\n                         trait_def_id,\n@@ -2702,8 +2607,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         &[],\n                     );\n                     obligations.push(skol_obligation);\n-                    this.infcx()\n-                        .plug_leaks(placeholder_map, snapshot, obligations)\n+                    obligations\n                 })\n             })\n             .collect()\n@@ -2794,9 +2698,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.in_snapshot(|this, snapshot| {\n+        self.infcx.in_snapshot(|_| {\n             let result =\n-                this.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n+                self.match_projection_obligation_against_definition_bounds(obligation);\n             assert!(result);\n         })\n     }\n@@ -2913,19 +2817,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             nested,\n         );\n \n-        let trait_obligations: Vec<PredicateObligation<'_>> = self.in_snapshot(|this, snapshot| {\n+        let trait_obligations: Vec<PredicateObligation<'_>> = self.infcx.in_snapshot(|_| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let (trait_ref, placeholder_map) = this.infcx()\n+            let (trait_ref, _) = self.infcx\n                 .replace_bound_vars_with_placeholders(&poly_trait_ref);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n-            this.impl_or_trait_obligations(\n+            self.impl_or_trait_obligations(\n                 cause,\n                 obligation.recursion_depth + 1,\n                 obligation.param_env,\n                 trait_def_id,\n                 &trait_ref.substs,\n-                placeholder_map,\n-                snapshot,\n             )\n         });\n \n@@ -2950,18 +2852,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.in_snapshot(|this, snapshot| {\n-            let (substs, placeholder_map) = this.rematch_impl(impl_def_id, obligation, snapshot);\n+        self.infcx.in_snapshot(|_| {\n+            let substs = self.rematch_impl(impl_def_id, obligation);\n             debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n-            this.vtable_impl(\n+            self.vtable_impl(\n                 impl_def_id,\n                 substs,\n                 cause,\n                 obligation.recursion_depth + 1,\n                 obligation.param_env,\n-                placeholder_map,\n-                snapshot,\n             )\n         })\n     }\n@@ -2973,12 +2873,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n-        placeholder_map: infer::PlaceholderMap<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\n-            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, placeholder_map={:?})\",\n-            impl_def_id, substs, recursion_depth, placeholder_map\n+            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n+            impl_def_id, substs, recursion_depth,\n         );\n \n         let mut impl_obligations = self.impl_or_trait_obligations(\n@@ -2987,8 +2885,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             param_env,\n             impl_def_id,\n             &substs.value,\n-            placeholder_map,\n-            snapshot,\n         );\n \n         debug!(\n@@ -3041,7 +2937,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // reported an ambiguity. (When we do find a match, also\n             // record it for later.)\n             let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(\n-                |&t| match self.commit_if_ok(|this, _| this.match_poly_trait_ref(obligation, t)) {\n+                |&t| match self.infcx.commit_if_ok(|_| self.match_poly_trait_ref(obligation, t)) {\n                     Ok(obligations) => {\n                         upcast_trait_ref = Some(t);\n                         nested.extend(obligations);\n@@ -3117,21 +3013,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation, alias_def_id\n         );\n \n-        self.in_snapshot(|this, snapshot| {\n-            let (predicate, placeholder_map) = this.infcx()\n+        self.infcx.in_snapshot(|_| {\n+            let (predicate, _) = self.infcx()\n                 .replace_bound_vars_with_placeholders(&obligation.predicate);\n             let trait_ref = predicate.trait_ref;\n             let trait_def_id = trait_ref.def_id;\n             let substs = trait_ref.substs;\n \n-            let trait_obligations = this.impl_or_trait_obligations(\n+            let trait_obligations = self.impl_or_trait_obligations(\n                 obligation.cause.clone(),\n                 obligation.recursion_depth,\n                 obligation.param_env,\n                 trait_def_id,\n                 &substs,\n-                placeholder_map,\n-                snapshot,\n             );\n \n             debug!(\n@@ -3341,10 +3235,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         );\n                     tcx.mk_existential_predicates(iter)\n                 });\n-                let new_trait = tcx.mk_dynamic(existential_predicates, r_b);\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n                 let InferOk { obligations, .. } = self.infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_trait)\n+                    .sup(target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -3546,13 +3440,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n-    ) -> (\n-        Normalized<'tcx, &'tcx Substs<'tcx>>,\n-        infer::PlaceholderMap<'tcx>,\n-    ) {\n-        match self.match_impl(impl_def_id, obligation, snapshot) {\n-            Ok((substs, placeholder_map)) => (substs, placeholder_map),\n+    ) -> Normalized<'tcx, &'tcx Substs<'tcx>> {\n+        match self.match_impl(impl_def_id, obligation) {\n+            Ok(substs) => substs,\n             Err(()) => {\n                 bug!(\n                     \"Impl {:?} was matchable against {:?} but now is not\",\n@@ -3567,14 +3457,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n-    ) -> Result<\n-        (\n-            Normalized<'tcx, &'tcx Substs<'tcx>>,\n-            infer::PlaceholderMap<'tcx>,\n-        ),\n-        (),\n-    > {\n+    ) -> Result<Normalized<'tcx, &'tcx Substs<'tcx>>, ()> {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n@@ -3584,7 +3467,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Err(());\n         }\n \n-        let (skol_obligation, placeholder_map) = self.infcx()\n+        let (skol_obligation, _) = self.infcx()\n             .replace_bound_vars_with_placeholders(&obligation.predicate);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n@@ -3616,22 +3499,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n         nested_obligations.extend(obligations);\n \n-        if let Err(e) =\n-            self.infcx\n-                .leak_check(false, obligation.cause.span, &placeholder_map, snapshot)\n-        {\n-            debug!(\"match_impl: failed leak check due to `{}`\", e);\n-            return Err(());\n-        }\n-\n         debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n-        Ok((\n-            Normalized {\n-                value: impl_substs,\n-                obligations: nested_obligations,\n-            },\n-            placeholder_map,\n-        ))\n+        Ok(Normalized {\n+            value: impl_substs,\n+            obligations: nested_obligations,\n+        })\n     }\n \n     fn fast_reject_trait_refs(\n@@ -3787,8 +3659,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,         // of impl or trait\n         substs: &Substs<'tcx>, // for impl or trait\n-        placeholder_map: infer::PlaceholderMap<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> Vec<PredicateObligation<'tcx>> {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n         let tcx = self.tcx();\n@@ -3850,8 +3720,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let mut seen = FxHashSet::default();\n             predicates.retain(|i| seen.insert(i.clone()));\n         }\n-        self.infcx()\n-            .plug_leaks(placeholder_map, snapshot, predicates)\n+\n+        predicates\n     }\n }\n "}, {"sha": "63f52a34dfa70847ad4ceac0b7ebd1df650e0c6e", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -15,6 +15,7 @@ use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use lint;\n use traits::{self, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n+use traits::coherence;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;\n@@ -32,6 +33,7 @@ pub struct OverlapError {\n     pub trait_desc: String,\n     pub self_desc: Option<String>,\n     pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+    pub involves_placeholder: bool,\n }\n \n /// Given a subst for the requested impl, translate it to a subst\n@@ -370,6 +372,10 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n                     cause.add_intercrate_ambiguity_hint(&mut err);\n                 }\n \n+                if overlap.involves_placeholder {\n+                    coherence::add_placeholder_note(&mut err);\n+                }\n+\n                 err.emit();\n             }\n         } else {"}, {"sha": "db3547b2b74796ca7434d6d46c0524f493cc4fdc", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -164,6 +164,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                         None\n                     },\n                     intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n+                    involves_placeholder: overlap.involves_placeholder,\n                 }\n             };\n "}, {"sha": "76e102d88d7cef93db9ca21ee5f9179b5c3fb97e", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,5 +1,5 @@\n use hir::def_id::DefId;\n-use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n+use ty::{self, Region, Ty, TyCtxt};\n use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n@@ -9,7 +9,7 @@ use syntax_pos::Span;\n \n use hir;\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub struct ExpectedFound<T> {\n     pub expected: T,\n     pub found: T,\n@@ -27,8 +27,7 @@ pub enum TypeError<'tcx> {\n     ArgCount,\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n-    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n+    RegionsPlaceholderMismatch,\n \n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n@@ -102,17 +101,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             RegionsDoesNotOutlive(..) => {\n                 write!(f, \"lifetime mismatch\")\n             }\n-            RegionsInsufficientlyPolymorphic(br, _) => {\n-                write!(f,\n-                       \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n-                       if br.is_named() { \" \" } else { \"\" },\n-                       br)\n-            }\n-            RegionsOverlyPolymorphic(br, _) => {\n-                write!(f,\n-                       \"expected concrete lifetime, found bound lifetime parameter{}{}\",\n-                       if br.is_named() { \" \" } else { \"\" },\n-                       br)\n+            RegionsPlaceholderMismatch => {\n+                write!(f, \"one type is more general than the other\")\n             }\n             Sorts(values) => ty::tls::with(|tcx| {\n                 report_maybe_different(f, &values.expected.sort_string(tcx),"}, {"sha": "4d026b97233ee22d83184f737b971ee17961459b", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -382,7 +382,7 @@ define_queries! { <'tcx>\n         /// might want to use `reveal_all()` method to change modes.\n         [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n \n-        /// Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n+        /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n         /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n         [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n         [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,"}, {"sha": "f9b43f42d5298595024d1342c88f307b8594b957", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -434,12 +434,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             RegionsDoesNotOutlive(a, b) => {\n                 return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b))\n             }\n-            RegionsInsufficientlyPolymorphic(a, b) => {\n-                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n-            }\n-            RegionsOverlyPolymorphic(a, b) => {\n-                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b))\n-            }\n+            RegionsPlaceholderMismatch => RegionsPlaceholderMismatch,\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n             Traits(x) => Traits(x),\n@@ -1006,8 +1001,7 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::FixedArraySize)(x),\n         (ty::error::TypeError::ArgCount),\n         (ty::error::TypeError::RegionsDoesNotOutlive)(a, b),\n-        (ty::error::TypeError::RegionsInsufficientlyPolymorphic)(a, b),\n-        (ty::error::TypeError::RegionsOverlyPolymorphic)(a, b),\n+        (ty::error::TypeError::RegionsPlaceholderMismatch),\n         (ty::error::TypeError::IntMismatch)(x),\n         (ty::error::TypeError::FloatMismatch)(x),\n         (ty::error::TypeError::Traits)(x),"}, {"sha": "a2720bdf385cdcc71c975ae0fe90d60f4bbaa1a5", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1396,6 +1396,13 @@ impl RegionKind {\n         }\n     }\n \n+    pub fn is_placeholder(&self) -> bool {\n+        match *self {\n+            ty::RePlaceholder(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn bound_at_or_above_binder(&self, index: DebruijnIndex) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn >= index,"}, {"sha": "ac062a23786113a2659c505671d315b8d57a3690", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -203,7 +203,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                     let cause = ObligationCause { span, ..ObligationCause::dummy() };\n                     let ctx = traits::FulfillmentContext::new();\n                     match traits::fully_normalize(&infcx, ctx, cause, self, &ty) {\n-                        Ok(ty) => if infcx.type_moves_by_default(self, ty, span) {\n+                        Ok(ty) => if !infcx.type_is_copy_modulo_regions(self, ty, span) {\n                             infringing.push(field);\n                         }\n                         Err(errors) => {\n@@ -621,21 +621,41 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'tcx> ty::TyS<'tcx> {\n-    pub fn moves_by_default(&'tcx self,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            param_env: ty::ParamEnv<'tcx>,\n-                            span: Span)\n-                            -> bool {\n-        !tcx.at(span).is_copy_raw(param_env.and(self))\n+    /// Checks whether values of this type `T` are *moved* or *copied*\n+    /// when referenced -- this amounts to a check for whether `T:\n+    /// Copy`, but note that we **don't** consider lifetimes when\n+    /// doing this check. This means that we may generate MIR which\n+    /// does copies even when the type actually doesn't satisfy the\n+    /// full requirements for the `Copy` trait (cc #29149) -- this\n+    /// winds up being reported as an error during NLL borrow check.\n+    pub fn is_copy_modulo_regions(&'tcx self,\n+                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  param_env: ty::ParamEnv<'tcx>,\n+                                  span: Span)\n+                                  -> bool {\n+        tcx.at(span).is_copy_raw(param_env.and(self))\n     }\n \n+    /// Checks whether values of this type `T` have a size known at\n+    /// compile time (i.e., whether `T: Sized`). Lifetimes are ignored\n+    /// for the purposes of this check, so it can be an\n+    /// over-approximation in generic contexts, where one can have\n+    /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n+    /// actually carry lifetime requirements.\n     pub fn is_sized(&'tcx self,\n                     tcx_at: TyCtxtAt<'a, 'tcx, 'tcx>,\n                     param_env: ty::ParamEnv<'tcx>)-> bool\n     {\n         tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n+    /// Checks whether values of this type `T` implement the `Freeze`\n+    /// trait -- frozen types are those that do not contain a\n+    /// `UnsafeCell` anywhere.  This is a language concept used to\n+    /// distinguish \"true immutability\", which is relevant to\n+    /// optimization as well as the rules around static values. Note\n+    /// that the `Freeze` trait is not exposed to end users and is\n+    /// effectively an implementation detail.\n     pub fn is_freeze(&'tcx self,\n                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      param_env: ty::ParamEnv<'tcx>,\n@@ -851,11 +871,13 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n     tcx.infer_ctxt()\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n-                                                       param_env,\n-                                                       ty,\n-                                                       trait_def_id,\n-                                                       DUMMY_SP))\n+        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        ))\n }\n \n fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -865,11 +887,13 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n     tcx.infer_ctxt()\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n-                                                       param_env,\n-                                                       ty,\n-                                                       trait_def_id,\n-                                                       DUMMY_SP))\n+        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        ))\n }\n \n fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -879,11 +903,13 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n     tcx.infer_ctxt()\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n-                                                       param_env,\n-                                                       ty,\n-                                                       trait_def_id,\n-                                                       DUMMY_SP))\n+        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        ))\n }\n \n fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -921,11 +947,11 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // `ManuallyDrop` doesn't have a destructor regardless of field types.\n         ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n \n-        // Issue #22536: We first query type_moves_by_default.  It sees a\n+        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n         // normalized version of the type, and therefore will definitely\n         // know whether the type implements Copy (and thus needs no\n         // cleanup/drop/zeroing) ...\n-        _ if !ty.moves_by_default(tcx, param_env, DUMMY_SP) => false,\n+        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n \n         // ... (issue #22536 continued) but as an optimization, still use\n         // prior logic of asking for the structural \"may drop\"."}, {"sha": "79405b124001d23dad68d48c3c32e6b8a12e8741", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 195, "deletions": 57, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -9,7 +9,7 @@ use ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n use util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n@@ -21,17 +21,163 @@ use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::{Symbol, InternedString};\n use hir;\n \n+/// The \"region highlights\" are used to control region printing during\n+/// specific error messages. When a \"region highlight\" is enabled, it\n+/// gives an alternate way to print specific regions. For now, we\n+/// always print those regions using a number, so something like `'0`.\n+///\n+/// Regions not selected by the region highlight mode are presently\n+/// unaffected.\n+#[derive(Copy, Clone, Default)]\n+pub struct RegionHighlightMode {\n+    /// If enabled, when we see the selected region, use `\"'N\"`\n+    /// instead of the ordinary behavior.\n+    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n+\n+    /// If enabled, when printing a \"free region\" that originated from\n+    /// the given `ty::BoundRegion`, print it as `'1`. Free regions that would ordinarily\n+    /// have names print as normal.\n+    ///\n+    /// This is used when you have a signature like `fn foo(x: &u32,\n+    /// y: &'a u32)` and we want to give a name to the region of the\n+    /// reference `x`.\n+    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n+}\n+\n thread_local! {\n     /// Mechanism for highlighting of specific regions for display in NLL region inference errors.\n     /// Contains region to highlight and counter for number to use when highlighting.\n-    static HIGHLIGHT_REGION_FOR_REGIONVID: Cell<Option<(RegionVid, usize)>> = Cell::new(None)\n+    static REGION_HIGHLIGHT_MODE: Cell<RegionHighlightMode> =\n+        Cell::new(RegionHighlightMode::default())\n }\n \n-thread_local! {\n-    /// Mechanism for highlighting of specific regions for display in NLL's 'borrow does not live\n-    /// long enough' errors. Contains a region to highlight and a counter to use.\n-    static HIGHLIGHT_REGION_FOR_BOUND_REGION: Cell<Option<(ty::BoundRegion, usize)>> =\n-        Cell::new(None)\n+impl RegionHighlightMode {\n+    /// Read and return current region highlight settings (accesses thread-local state).a\n+    pub fn get() -> Self {\n+        REGION_HIGHLIGHT_MODE.with(|c| c.get())\n+    }\n+\n+    /// Internal helper to update current settings during the execution of `op`.\n+    fn set<R>(\n+        old_mode: Self,\n+        new_mode: Self,\n+        op: impl FnOnce() -> R,\n+    ) -> R {\n+        REGION_HIGHLIGHT_MODE.with(|c| {\n+            c.set(new_mode);\n+            let result = op();\n+            c.set(old_mode);\n+            result\n+        })\n+    }\n+\n+    /// If `region` and `number` are both `Some`, invoke\n+    /// `highlighting_region`. Otherwise, just invoke `op` directly.\n+    pub fn maybe_highlighting_region<R>(\n+        region: Option<ty::Region<'_>>,\n+        number: Option<usize>,\n+        op: impl FnOnce() -> R,\n+    ) -> R {\n+        if let Some(k) = region {\n+            if let Some(n) = number {\n+                return Self::highlighting_region(k, n, op);\n+            }\n+        }\n+\n+        op()\n+    }\n+\n+    /// During the execution of `op`, highlight the region inference\n+    /// vairable `vid` as `'N`.  We can only highlight one region vid\n+    /// at a time.\n+    pub fn highlighting_region<R>(\n+        region: ty::Region<'_>,\n+        number: usize,\n+        op: impl FnOnce() -> R,\n+    ) -> R {\n+        let old_mode = Self::get();\n+        let mut new_mode = old_mode;\n+        let first_avail_slot = new_mode.highlight_regions.iter_mut()\n+            .filter(|s| s.is_none())\n+            .next()\n+            .unwrap_or_else(|| {\n+                panic!(\n+                    \"can only highlight {} placeholders at a time\",\n+                    old_mode.highlight_regions.len(),\n+                )\n+            });\n+        *first_avail_slot = Some((*region, number));\n+        Self::set(old_mode, new_mode, op)\n+    }\n+\n+    /// Convenience wrapper for `highlighting_region`\n+    pub fn highlighting_region_vid<R>(\n+        vid: ty::RegionVid,\n+        number: usize,\n+        op: impl FnOnce() -> R,\n+    ) -> R {\n+        Self::highlighting_region(&ty::ReVar(vid), number, op)\n+    }\n+\n+    /// Returns true if any placeholders are highlighted.\n+    fn any_region_vids_highlighted(&self) -> bool {\n+        Self::get()\n+            .highlight_regions\n+            .iter()\n+            .any(|h| match h {\n+                Some((ty::ReVar(_), _)) => true,\n+                _ => false,\n+            })\n+    }\n+\n+    /// Returns `Some(n)` with the number to use for the given region,\n+    /// if any.\n+    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+        Self::get()\n+            .highlight_regions\n+            .iter()\n+            .filter_map(|h| match h {\n+                Some((r, n)) if r == region => Some(*n),\n+                _ => None,\n+            })\n+            .next()\n+    }\n+\n+    /// During the execution of `op`, highlight the given bound\n+    /// region. We can only highlight one bound region at a time.  See\n+    /// the field `highlight_bound_region` for more detailed notes.\n+    pub fn highlighting_bound_region<R>(\n+        br: ty::BoundRegion,\n+        number: usize,\n+        op: impl FnOnce() -> R,\n+    ) -> R {\n+        let old_mode = Self::get();\n+        assert!(old_mode.highlight_bound_region.is_none());\n+        Self::set(\n+            old_mode,\n+            Self {\n+                highlight_bound_region: Some((br, number)),\n+                ..old_mode\n+            },\n+            op,\n+        )\n+    }\n+\n+    /// Returns true if any placeholders are highlighted.\n+    pub fn any_placeholders_highlighted(&self) -> bool {\n+        Self::get()\n+            .highlight_regions\n+            .iter()\n+            .any(|h| match h {\n+                Some((ty::RePlaceholder(_), _)) => true,\n+                _ => false,\n+            })\n+    }\n+\n+    /// Returns `Some(N)` if the placeholder `p` is highlighted to print as `'N`.\n+    pub fn placeholder_highlight(&self, p: ty::PlaceholderRegion) -> Option<usize> {\n+        self.region_highlighted(&ty::RePlaceholder(p))\n+    }\n }\n \n macro_rules! gen_display_debug_body {\n@@ -553,42 +699,6 @@ pub fn parameterized<F: fmt::Write>(f: &mut F,\n     PrintContext::new().parameterized(f, substs, did, projections)\n }\n \n-fn get_highlight_region_for_regionvid() -> Option<(RegionVid, usize)> {\n-    HIGHLIGHT_REGION_FOR_REGIONVID.with(|hr| hr.get())\n-}\n-\n-pub fn with_highlight_region_for_regionvid<R>(\n-    r: RegionVid,\n-    counter: usize,\n-    op: impl FnOnce() -> R\n-) -> R {\n-    HIGHLIGHT_REGION_FOR_REGIONVID.with(|hr| {\n-        assert_eq!(hr.get(), None);\n-        hr.set(Some((r, counter)));\n-        let r = op();\n-        hr.set(None);\n-        r\n-    })\n-}\n-\n-fn get_highlight_region_for_bound_region() -> Option<(ty::BoundRegion, usize)> {\n-    HIGHLIGHT_REGION_FOR_BOUND_REGION.with(|hr| hr.get())\n-}\n-\n-pub fn with_highlight_region_for_bound_region<R>(\n-    r: ty::BoundRegion,\n-    counter: usize,\n-    op: impl Fn() -> R\n-) -> R {\n-    HIGHLIGHT_REGION_FOR_BOUND_REGION.with(|hr| {\n-        assert_eq!(hr.get(), None);\n-        hr.set(Some((r, counter)));\n-        let r = op();\n-        hr.set(None);\n-        r\n-    })\n-}\n-\n impl<'a, T: Print> Print for &'a T {\n     fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n         (*self).print(f, cx)\n@@ -740,7 +850,7 @@ define_print! {\n                 return self.print_debug(f, cx);\n             }\n \n-            if let Some((region, counter)) = get_highlight_region_for_bound_region() {\n+            if let Some((region, counter)) = RegionHighlightMode::get().highlight_bound_region {\n                 if *self == region {\n                     return match *self {\n                         BrNamed(_, name) => write!(f, \"{}\", name),\n@@ -768,13 +878,37 @@ define_print! {\n     }\n }\n \n+define_print! {\n+    () ty::PlaceholderRegion, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n+            }\n+\n+            let highlight = RegionHighlightMode::get();\n+            if let Some(counter) = highlight.placeholder_highlight(*self) {\n+                write!(f, \"'{}\", counter)\n+            } else if highlight.any_placeholders_highlighted() {\n+                write!(f, \"'_\")\n+            } else {\n+                write!(f, \"{}\", self.name)\n+            }\n+        }\n+    }\n+}\n+\n define_print! {\n     () ty::RegionKind, (self, f, cx) {\n         display {\n-            if cx.is_verbose || get_highlight_region_for_regionvid().is_some() {\n+            if cx.is_verbose {\n                 return self.print_debug(f, cx);\n             }\n \n+            // Watch out for region highlights.\n+            if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n+                return write!(f, \"'{:?}\", n);\n+            }\n+\n             // These printouts are concise.  They do not contain all the information\n             // the user might want to diagnose an error, but there is basically no way\n             // to fit that into a short string.  Hence the recommendation to use\n@@ -784,10 +918,12 @@ define_print! {\n                     write!(f, \"{}\", data.name)\n                 }\n                 ty::ReLateBound(_, br) |\n-                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-                ty::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n+                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) => {\n                     write!(f, \"{}\", br)\n                 }\n+                ty::RePlaceholder(p) => {\n+                    write!(f, \"{}\", p)\n+                }\n                 ty::ReScope(scope) if cx.identify_regions => {\n                     match scope.data {\n                         region::ScopeData::Node =>\n@@ -806,11 +942,16 @@ define_print! {\n                         ),\n                     }\n                 }\n-                ty::ReVar(region_vid) if cx.identify_regions => {\n-                    write!(f, \"'{}rv\", region_vid.index())\n+                ty::ReVar(region_vid) => {\n+                    if RegionHighlightMode::get().any_region_vids_highlighted() {\n+                        write!(f, \"{:?}\", region_vid)\n+                    } else if cx.identify_regions {\n+                        write!(f, \"'{}rv\", region_vid.index())\n+                    } else {\n+                        Ok(())\n+                    }\n                 }\n                 ty::ReScope(_) |\n-                ty::ReVar(_) |\n                 ty::ReErased => Ok(()),\n                 ty::ReStatic => write!(f, \"'static\"),\n                 ty::ReEmpty => write!(f, \"'<empty>\"),\n@@ -939,13 +1080,10 @@ impl fmt::Debug for ty::FloatVid {\n \n impl fmt::Debug for ty::RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some((region, counter)) = get_highlight_region_for_regionvid() {\n-            debug!(\"RegionVid.fmt: region={:?} self={:?} counter={:?}\", region, self, counter);\n-            return if *self == region {\n-                write!(f, \"'{:?}\", counter)\n-            } else {\n-                write!(f, \"'_\")\n-            }\n+        if let Some(counter) = RegionHighlightMode::get().region_highlighted(&ty::ReVar(*self)) {\n+            return write!(f, \"'{:?}\", counter);\n+        } else if RegionHighlightMode::get().any_region_vids_highlighted() {\n+            return write!(f, \"'_\");\n         }\n \n         write!(f, \"'_#{}r\", self.index())"}, {"sha": "9c027f110eb4ec2799d2ce06e653ef2151303e4c", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -7,7 +7,6 @@ use errors::{DiagnosticBuilder, Level};\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::session::config::{OutputFilenames, OutputTypes};\n@@ -26,7 +25,6 @@ use syntax::ast;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::source_map::{FileName, FilePathMapping, SourceMap};\n use syntax::symbol::Symbol;\n-use syntax_pos::DUMMY_SP;\n \n use std::path::PathBuf;\n use std::sync::mpsc;\n@@ -431,17 +429,6 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Checks that `t1 <: t2` is false (this may register additional\n-    /// region checks).\n-    pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub(t1, t2) {\n-            Err(_) => {}\n-            Ok(_) => {\n-                panic!(\"unexpected success computing sub({:?},{:?})\", t1, t2);\n-            }\n-        }\n-    }\n }\n \n #[test]\n@@ -470,25 +457,6 @@ fn contravariant_region_ptr_err() {\n     })\n }\n \n-#[test]\n-fn sub_free_bound_false() {\n-    //! Test that:\n-    //!\n-    //!     fn(&'a isize) <: for<'b> fn(&'b isize)\n-    //!\n-    //! *does not* hold.\n-\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(\n-            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-        );\n-    })\n-}\n-\n #[test]\n fn sub_bound_free_true() {\n     //! Test that:\n@@ -508,25 +476,6 @@ fn sub_bound_free_true() {\n     })\n }\n \n-#[test]\n-fn sub_free_bound_false_infer() {\n-    //! Test that:\n-    //!\n-    //!     fn(_#1) <: for<'b> fn(&'b isize)\n-    //!\n-    //! does NOT hold for any instantiation of `_#1`.\n-\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx\n-            .next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(\n-            env.t_fn(&[t_infer1], env.tcx().types.isize),\n-            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-        );\n-    })\n-}\n-\n /// Test substituting a bound region into a function, which introduces another level of binding.\n /// This requires adjusting the Debruijn index.\n #[test]"}, {"sha": "27b65b4ec48a4f36cb2f6715e43e4c6e680f8247", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             return;\n         }\n         let param_env = ty::ParamEnv::empty();\n-        if !ty.moves_by_default(cx.tcx, param_env, item.span) {\n+        if ty.is_copy_modulo_regions(cx.tcx, param_env, item.span) {\n             return;\n         }\n         if param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {"}, {"sha": "83cd28bbdc58cfe0a54b0566d77f340c95f28f4a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::{\n     TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n-use rustc::util::ppaux::with_highlight_region_for_bound_region;\n+use rustc::util::ppaux::RegionHighlightMode;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n@@ -2177,7 +2177,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n-            ) => with_highlight_region_for_bound_region(*br, counter, || ty.to_string()),\n+            ) => RegionHighlightMode::highlighting_bound_region(*br, counter, || ty.to_string()),\n             _ => ty.to_string(),\n         }\n     }\n@@ -2189,7 +2189,11 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             ty::TyKind::Ref(region, _, _) => match region {\n                 ty::RegionKind::ReLateBound(_, br)\n                 | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n-                    with_highlight_region_for_bound_region(*br, counter, || region.to_string())\n+                    RegionHighlightMode::highlighting_bound_region(\n+                        *br,\n+                        counter,\n+                        || region.to_string(),\n+                    )\n                 }\n                 _ => region.to_string(),\n             },"}, {"sha": "bff8015511242e1338f17a386eb623d39eba6053", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -8,7 +8,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n use rustc::ty::subst::{Substs, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n-use rustc::util::ppaux::with_highlight_region_for_regionvid;\n+use rustc::util::ppaux::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::{Name, DUMMY_NODE_ID};\n use syntax::symbol::keywords;\n@@ -396,7 +396,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let type_name = with_highlight_region_for_regionvid(needle_fr, *counter, || {\n+        let type_name = RegionHighlightMode::highlighting_region_vid(needle_fr, *counter, || {\n             infcx.extract_type_name(&argument_ty)\n         });\n \n@@ -673,8 +673,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n-        let type_name = with_highlight_region_for_regionvid(\n-            fr, *counter, || infcx.extract_type_name(&return_ty));\n+        let type_name = RegionHighlightMode::highlighting_region_vid(\n+            fr, *counter, || infcx.extract_type_name(&return_ty),\n+        );\n \n         let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n "}, {"sha": "b3e1237a4508778d3b4e917a7f7cb1dfa1979da4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -503,13 +503,17 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 substs: tcx.mk_substs_trait(place_ty.to_ty(tcx), &[]),\n             };\n \n-            // In order to have a Copy operand, the type T of the value must be Copy. Note that we\n-            // prove that T: Copy, rather than using the type_moves_by_default test. This is\n-            // important because type_moves_by_default ignores the resulting region obligations and\n-            // assumes they pass. This can result in bounds from Copy impls being unsoundly ignored\n-            // (e.g., #29149). Note that we decide to use Copy before knowing whether the bounds\n-            // fully apply: in effect, the rule is that if a value of some type could implement\n-            // Copy, then it must.\n+            // In order to have a Copy operand, the type T of the\n+            // value must be Copy. Note that we prove that T: Copy,\n+            // rather than using the `is_copy_modulo_regions`\n+            // test. This is important because\n+            // `is_copy_modulo_regions` ignores the resulting region\n+            // obligations and assumes they pass. This can result in\n+            // bounds from Copy impls being unsoundly ignored (e.g.,\n+            // #29149). Note that we decide to use Copy before knowing\n+            // whether the bounds fully apply: in effect, the rule is\n+            // that if a value of some type could implement Copy, then\n+            // it must.\n             self.cx.prove_trait_ref(\n                 trait_ref,\n                 location.to_locations(),"}, {"sha": "5b20d412f0dd536dab88c7ce6de03c62e08236e9", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.hir.tcx();\n         let ty = place.ty(&self.local_decls, tcx).to_ty(tcx);\n-        if self.hir.type_moves_by_default(ty, DUMMY_SP) {\n+        if !self.hir.type_is_copy_modulo_regions(ty, DUMMY_SP) {\n             Operand::Move(place)\n         } else {\n             Operand::Copy(place)"}, {"sha": "07f3c38c62c52365ba90e59f735bc4092f928f7d", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -223,8 +223,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.check_overflow\n     }\n \n-    pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        self.infcx.type_moves_by_default(self.param_env, ty, span)\n+    pub fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n     }\n }\n "}, {"sha": "c104af7a7d81bd6dd177caf68fea14faaa59872d", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -545,7 +545,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                     match bm {\n                         ty::BindByValue(..) => {\n                             let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n-                            if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n+                            if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n                                 check_move(p, sub.as_ref().map(|p| &**p), span_vec);\n                             }\n                         }"}, {"sha": "2aa44cc181a568c893714563a15078a36dc6f2ad", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -310,7 +310,7 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n-    let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), builder.span);\n+    let is_copy = self_ty.is_copy_modulo_regions(tcx, tcx.param_env(def_id), builder.span);\n \n     let dest = Place::Local(RETURN_PLACE);\n     let src = Place::Local(Local::new(1+0)).deref();"}, {"sha": "eb151b56bed65f8d63dd585cc842873a5656996f", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -224,8 +224,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                         \"non-field projection {:?} from union?\",\n                                         place)\n                                 };\n-                                if elem_ty.moves_by_default(self.tcx, self.param_env,\n-                                                            self.source_info.span) {\n+                                if !elem_ty.is_copy_modulo_regions(\n+                                    self.tcx,\n+                                    self.param_env,\n+                                    self.source_info.span,\n+                                ) {\n                                     self.require_unsafe(\n                                         \"assignment to non-`Copy` union field\",\n                                         \"the previous content of the field will be dropped, which \\"}, {"sha": "9d418704f487d422d3fbac66c76b431ed13f8c67", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return Err(ErrorReported);\n         }\n \n-        if self.type_is_known_to_be_sized(t, span) {\n+        if self.type_is_known_to_be_sized_modulo_regions(t, span) {\n             return Ok(Some(PointerKind::Thin));\n         }\n \n@@ -397,7 +397,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                self.expr_ty,\n                self.cast_ty);\n \n-        if !fcx.type_is_known_to_be_sized(self.cast_ty, self.span) {\n+        if !fcx.type_is_known_to_be_sized_modulo_regions(self.cast_ty, self.span) {\n             self.report_cast_to_unsized_type(fcx);\n         } else if self.expr_ty.references_error() || self.cast_ty.references_error() {\n             // No sense in giving duplicate error messages\n@@ -618,8 +618,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    fn type_is_known_to_be_sized(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+    fn type_is_known_to_be_sized_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-        traits::type_known_to_meet_bound(self, self.param_env, ty, lang_item, span)\n+        traits::type_known_to_meet_bound_modulo_regions(self, self.param_env, ty, lang_item, span)\n     }\n }"}, {"sha": "7a788f2de7f2f199936ebf371a3d44bbc07bc25b", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -353,9 +353,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         // Maybe add `*`? Only if `T: Copy`.\n                         _ => {\n-                            if !self.infcx.type_moves_by_default(self.param_env,\n-                                                                checked,\n-                                                                sp) {\n+                            if self.infcx.type_is_copy_modulo_regions(self.param_env,\n+                                                                      checked,\n+                                                                      sp) {\n                                 // do not suggest if the span comes from a macro (#52783)\n                                 if let (Ok(code),\n                                         true) = (cm.span_to_snippet(sp), sp == expr.span) {"}, {"sha": "7c871601af3088bc29672c15dfec74c865c40735", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -262,9 +262,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             let mut suggested_deref = false;\n                             if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n-                                    !self.infcx.type_moves_by_default(self.param_env,\n-                                                                        rty,\n-                                                                        lhs_expr.span) &&\n+                                    self.infcx.type_is_copy_modulo_regions(self.param_env,\n+                                                                           rty,\n+                                                                           lhs_expr.span) &&\n                                         self.lookup_op_method(rty,\n                                                               &[rhs_ty],\n                                                               Op::Binary(op, is_assign))\n@@ -334,9 +334,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             let mut suggested_deref = false;\n                             if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n-                                    !self.infcx.type_moves_by_default(self.param_env,\n-                                                                      rty,\n-                                                                      lhs_expr.span) &&\n+                                    self.infcx.type_is_copy_modulo_regions(self.param_env,\n+                                                                           rty,\n+                                                                           lhs_expr.span) &&\n                                         self.lookup_op_method(rty,\n                                                               &[rhs_ty],\n                                                               Op::Binary(op, is_assign))"}, {"sha": "53e44d53e6a9bb1c6d86dcaf3c6d5955ec5da6a8", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -873,7 +873,7 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n             trait_ref.to_predicate()\n         );\n \n-        if !fcx.predicate_must_hold(&obligation) {\n+        if !fcx.predicate_must_hold_modulo_regions(&obligation) {\n             debug!(\"receiver_is_valid: type `{:?}` does not implement `Receiver` trait\",\n                 receiver_ty);\n             return false"}, {"sha": "8d27a77b29c6cb7df9b53240b21ff7eb4f5a2d9b", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -73,6 +73,10 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n                         cause.add_intercrate_ambiguity_hint(&mut err);\n                     }\n \n+                    if overlap.involves_placeholder {\n+                        traits::add_placeholder_note(&mut err);\n+                    }\n+\n                     err.emit();\n                 }\n             }"}, {"sha": "b7aa57b5c31f704d6b304fc3e52668066afd9d44", "filename": "src/test/run-pass/coherence/coherence-subtyping.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2442823ef572a65092fbc46f6975633f983b50b6/src%2Ftest%2Frun-pass%2Fcoherence%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2442823ef572a65092fbc46f6975633f983b50b6/src%2Ftest%2Frun-pass%2Fcoherence%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence%2Fcoherence-subtyping.rs?ref=2442823ef572a65092fbc46f6975633f983b50b6", "patch": "@@ -1,39 +0,0 @@\n-// run-pass\n-// Test that two distinct impls which match subtypes of one another\n-// yield coherence errors (or not) depending on the variance.\n-\n-trait Contravariant {\n-    fn foo(&self) { }\n-}\n-\n-impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n-}\n-\n-impl Contravariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-\n-trait Covariant {\n-    fn foo(&self) { }\n-}\n-\n-impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n-}\n-\n-impl Covariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-\n-trait Invariant {\n-    fn foo(&self) { }\n-}\n-\n-impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n-}\n-\n-impl Invariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n-}\n-\n-fn main() { }"}, {"sha": "20fa1e7a48db18fe7f1e4f830455e6e2a290443d", "filename": "src/test/ui/associated-types/associated-types-eq-hr.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -77,23 +77,33 @@ fn tuple_four<T>()\n     // not ok for tuple, two lifetimes, and lifetime matching is invariant\n }\n \n-pub fn main() {\n+pub fn call_foo() {\n     foo::<IntStruct>();\n     foo::<UintStruct>(); //~ ERROR type mismatch\n+}\n \n+pub fn call_bar() {\n     bar::<IntStruct>(); //~ ERROR type mismatch\n     bar::<UintStruct>();\n+}\n \n+pub fn call_tuple_one() {\n     tuple_one::<Tuple>();\n-    //~^ ERROR E0277\n-    //~| ERROR type mismatch\n+    //~^ ERROR not general enough\n+}\n \n+pub fn call_tuple_two() {\n     tuple_two::<Tuple>();\n-    //~^ ERROR E0277\n-    //~| ERROR type mismatch\n+    //~^ ERROR not general enough\n+}\n \n+pub fn call_tuple_three() {\n     tuple_three::<Tuple>();\n+}\n \n+pub fn call_tuple_four() {\n     tuple_four::<Tuple>();\n-    //~^ ERROR E0277\n+    //~^ ERROR not general enough\n }\n+\n+fn main() { }"}, {"sha": "d3eaa894b504345f4a5bd6aab4399a39ee00a721", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 21, "deletions": 78, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -17,7 +17,7 @@ LL | | }\n    | |_^\n \n error[E0271]: type mismatch resolving `for<'x> <IntStruct as TheTrait<&'x isize>>::A == &'x usize`\n-  --> $DIR/associated-types-eq-hr.rs:84:5\n+  --> $DIR/associated-types-eq-hr.rs:86:5\n    |\n LL |     bar::<IntStruct>(); //~ ERROR type mismatch\n    |     ^^^^^^^^^^^^^^^^ expected isize, found usize\n@@ -34,93 +34,36 @@ LL | |     // ok for UintStruct, but not IntStruct\n LL | | }\n    | |_^\n \n-error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n-  --> $DIR/associated-types-eq-hr.rs:87:5\n-   |\n-LL |     tuple_one::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ the trait `for<'x, 'y> TheTrait<(&'x isize, &'y isize)>` is not implemented for `Tuple`\n-   |\n-   = help: the following implementations were found:\n-             <Tuple as TheTrait<(&'a isize, &'a isize)>>\n-note: required by `tuple_one`\n-  --> $DIR/associated-types-eq-hr.rs:56:1\n-   |\n-LL | / fn tuple_one<T>()\n-LL | |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>\n-LL | | {\n-LL | |     // not ok for tuple, two lifetimes and we pick first\n-LL | | }\n-   | |_^\n-\n-error[E0271]: type mismatch resolving `for<'x, 'y> <Tuple as TheTrait<(&'x isize, &'y isize)>>::A == &'x isize`\n-  --> $DIR/associated-types-eq-hr.rs:87:5\n-   |\n-LL |     tuple_one::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n-   |\n-note: required by `tuple_one`\n-  --> $DIR/associated-types-eq-hr.rs:56:1\n-   |\n-LL | / fn tuple_one<T>()\n-LL | |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>\n-LL | | {\n-LL | |     // not ok for tuple, two lifetimes and we pick first\n-LL | | }\n-   | |_^\n-\n-error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n+error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:91:5\n    |\n-LL |     tuple_two::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ the trait `for<'x, 'y> TheTrait<(&'x isize, &'y isize)>` is not implemented for `Tuple`\n-   |\n-   = help: the following implementations were found:\n-             <Tuple as TheTrait<(&'a isize, &'a isize)>>\n-note: required by `tuple_two`\n-  --> $DIR/associated-types-eq-hr.rs:62:1\n+LL |     tuple_one::<Tuple>();\n+   |     ^^^^^^^^^^^^^^^^^^\n    |\n-LL | / fn tuple_two<T>()\n-LL | |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>\n-LL | | {\n-LL | |     // not ok for tuple, two lifetimes and we pick second\n-LL | | }\n-   | |_^\n+   = note: Due to a where-clause on `tuple_one`,\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n-error[E0271]: type mismatch resolving `for<'x, 'y> <Tuple as TheTrait<(&'x isize, &'y isize)>>::A == &'y isize`\n-  --> $DIR/associated-types-eq-hr.rs:91:5\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:96:5\n    |\n LL |     tuple_two::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n-   |\n-note: required by `tuple_two`\n-  --> $DIR/associated-types-eq-hr.rs:62:1\n+   |     ^^^^^^^^^^^^^^^^^^\n    |\n-LL | / fn tuple_two<T>()\n-LL | |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>\n-LL | | {\n-LL | |     // not ok for tuple, two lifetimes and we pick second\n-LL | | }\n-   | |_^\n+   = note: Due to a where-clause on `tuple_two`,\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n-error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n-  --> $DIR/associated-types-eq-hr.rs:97:5\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:105:5\n    |\n LL |     tuple_four::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^^ the trait `for<'x, 'y> TheTrait<(&'x isize, &'y isize)>` is not implemented for `Tuple`\n-   |\n-   = help: the following implementations were found:\n-             <Tuple as TheTrait<(&'a isize, &'a isize)>>\n-note: required by `tuple_four`\n-  --> $DIR/associated-types-eq-hr.rs:74:1\n+   |     ^^^^^^^^^^^^^^^^^^^\n    |\n-LL | / fn tuple_four<T>()\n-LL | |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize)>\n-LL | | {\n-LL | |     // not ok for tuple, two lifetimes, and lifetime matching is invariant\n-LL | | }\n-   | |_^\n+   = note: Due to a where-clause on `tuple_four`,\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors occurred: E0271, E0277.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "e4704494e149248f7bd1a029ce53d22785fd2766", "filename": "src/test/ui/associated-types/higher-ranked-projection.bad.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,17 +1,12 @@\n-error[E0271]: type mismatch resolving `for<'a> <&'a _ as Mirror>::Image == _`\n+error[E0308]: mismatched types\n   --> $DIR/higher-ranked-projection.rs:25:5\n    |\n LL |     foo(());\n-   |     ^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |     ^^^ one type is more general than the other\n    |\n-note: required by `foo`\n-  --> $DIR/higher-ranked-projection.rs:14:1\n-   |\n-LL | / fn foo<U, T>(_t: T)\n-LL | |     where for<'a> &'a T: Mirror<Image=U>\n-LL | | {}\n-   | |__^\n+   = note: expected type `Mirror`\n+              found type `Mirror`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "db15ec51d87c6e2fdfdfa08c9ebf36ca82100640", "filename": "src/test/ui/associated-types/higher-ranked-projection.good.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -3,8 +3,7 @@ error: compilation successful\n    |\n LL | / fn main() { //[good]~ ERROR compilation successful\n LL | |     foo(());\n-LL | |     //[bad]~^ ERROR type mismatch resolving `for<'a> <&'a _ as Mirror>::Image == _`\n-LL | |     //[bad]~| expected bound lifetime parameter 'a, found concrete lifetime\n+LL | |     //[bad]~^ ERROR E0308\n LL | | }\n    | |_^\n "}, {"sha": "5b380c982f041277eff83b5cc63a0b6c7b9893d5", "filename": "src/test/ui/associated-types/higher-ranked-projection.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -23,6 +23,5 @@ fn foo<U, T>(_t: T)\n #[rustc_error]\n fn main() { //[good]~ ERROR compilation successful\n     foo(());\n-    //[bad]~^ ERROR type mismatch resolving `for<'a> <&'a _ as Mirror>::Image == _`\n-    //[bad]~| expected bound lifetime parameter 'a, found concrete lifetime\n+    //[bad]~^ ERROR E0308\n }"}, {"sha": "6977fd47a2e85f03ead9066f7d3b6ef41812d651", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -28,23 +28,24 @@ fn expect_free_supply_bound() {\n     // Here, we are given a function whose region is bound at closure level,\n     // but we expect one bound in the argument. Error results.\n     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n-    //~^ ERROR type mismatch in closure arguments\n+    //~^ ERROR mismatched types\n }\n \n fn expect_bound_supply_free_from_fn<'x>(x: &'x u32) {\n     // Here, we are given a `fn(&u32)` but we expect a `fn(&'x\n     // u32)`. In principle, this could be ok, but we demand equality.\n     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n-    //~^ ERROR type mismatch in closure arguments\n+    //~^ ERROR mismatched types\n }\n \n fn expect_bound_supply_free_from_closure() {\n     // A variant on the previous test. Here, the region `'a` will be\n     // bound at the closure level, but we expect something bound at\n     // the argument level.\n     type Foo<'a> = fn(&'a u32);\n-    with_closure_expecting_fn_with_bound_region(|_x: Foo<'_>, y| {});\n-    //~^ ERROR type mismatch in closure arguments\n+    with_closure_expecting_fn_with_bound_region(|x: Foo<'_>, y| {\n+    //~^ ERROR mismatched types\n+    });\n }\n \n fn expect_bound_supply_bound<'x>(x: &'x u32) {"}, {"sha": "b1cfd6cef1022b0baa030c5151a30f07ec5c7000", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.stderr", "status": "modified", "additions": 17, "deletions": 42, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -36,58 +36,33 @@ note: ...does not necessarily outlive the anonymous lifetime #2 defined on the b\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:30:5\n+error[E0308]: mismatched types\n+  --> $DIR/expect-fn-supply-fn.rs:30:52\n    |\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------------- found signature of `fn(for<'r> fn(&'r u32), _) -> _`\n-   |     |\n-   |     expected signature of `for<'a, 'r> fn(fn(&'a u32), &'r i32) -> _`\n-   |\n-note: required by `with_closure_expecting_fn_with_free_region`\n-  --> $DIR/expect-fn-supply-fn.rs:1:1\n+   |                                                    ^^^^^^^^ one type is more general than the other\n    |\n-LL | / fn with_closure_expecting_fn_with_free_region<F>(_: F)\n-LL | |     where F: for<'a> FnOnce(fn(&'a u32), &i32)\n-LL | | {\n-LL | | }\n-   | |_^\n+   = note: expected type `fn(&u32)`\n+              found type `for<'r> fn(&'r u32)`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:37:5\n+error[E0308]: mismatched types\n+  --> $DIR/expect-fn-supply-fn.rs:37:53\n    |\n LL |     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------------------- found signature of `fn(fn(&'x u32), _) -> _`\n-   |     |\n-   |     expected signature of `for<'r> fn(for<'s> fn(&'s u32), &'r i32) -> _`\n+   |                                                     ^^^^^^^^^^^ one type is more general than the other\n    |\n-note: required by `with_closure_expecting_fn_with_bound_region`\n-  --> $DIR/expect-fn-supply-fn.rs:6:1\n-   |\n-LL | / fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n-LL | |     where F: FnOnce(fn(&u32), &i32)\n-LL | | {\n-LL | | }\n-   | |_^\n+   = note: expected type `for<'r> fn(&'r u32)`\n+              found type `fn(&'x u32)`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/expect-fn-supply-fn.rs:46:5\n-   |\n-LL |     with_closure_expecting_fn_with_bound_region(|_x: Foo<'_>, y| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------------- found signature of `for<'r> fn(fn(&'r u32), _) -> _`\n-   |     |\n-   |     expected signature of `for<'r> fn(for<'s> fn(&'s u32), &'r i32) -> _`\n+error[E0308]: mismatched types\n+  --> $DIR/expect-fn-supply-fn.rs:46:53\n    |\n-note: required by `with_closure_expecting_fn_with_bound_region`\n-  --> $DIR/expect-fn-supply-fn.rs:6:1\n+LL |     with_closure_expecting_fn_with_bound_region(|x: Foo<'_>, y| {\n+   |                                                     ^^^^^^^ one type is more general than the other\n    |\n-LL | / fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n-LL | |     where F: FnOnce(fn(&u32), &i32)\n-LL | | {\n-LL | | }\n-   | |_^\n+   = note: expected type `for<'r> fn(&'r u32)`\n+              found type `fn(&u32)`\n \n error: aborting due to 5 previous errors\n \n-Some errors occurred: E0308, E0631.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "fb9a7fbf7aba5e343edbfb3387bca9affc282a1a", "filename": "src/test/ui/coherence/coherence-subtyping.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,15 @@\n+// Test that two distinct impls which match subtypes of one another\n+// yield coherence errors (or not) depending on the variance.\n+\n+trait TheTrait {\n+    fn foo(&self) { }\n+}\n+\n+impl TheTrait for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n+}\n+\n+impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+    //~^ ERROR\n+}\n+\n+fn main() { }"}, {"sha": "1fc5c39d5c9fd2e37e99a3463824ccf10cb2b953", "filename": "src/test/ui/coherence/coherence-subtyping.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,14 @@\n+error[E0119]: conflicting implementations of trait `TheTrait` for type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`:\n+  --> $DIR/coherence-subtyping.rs:11:1\n+   |\n+LL | impl TheTrait for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n+   | --------------------------------------------------------- first implementation here\n+...\n+LL | impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+   |\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "46d72899438576137f587c1d2a17476cd5cc35c4", "filename": "src/test/ui/generator/auto-trait-regions.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -27,7 +27,8 @@ fn main() {\n         yield;\n         assert_foo(x);\n     };\n-    assert_foo(gen); //~ ERROR the trait bound `No: Foo` is not satisfied\n+    assert_foo(gen);\n+    //~^ ERROR implementation of `Foo` is not general enough\n \n     // Allow impls which matches any lifetime\n     let x = &OnlyFooIfRef(No);\n@@ -44,5 +45,6 @@ fn main() {\n         yield;\n         assert_foo(a);\n     };\n-    assert_foo(gen); //~ ERROR the requirement `for<'r, 's> 'r : 's` is not satisfied\n+    assert_foo(gen);\n+    //~^ ERROR not general enough\n }"}, {"sha": "1b4dfe2df1c0c92948ee58447895766f3e9a44f4", "filename": "src/test/ui/generator/auto-trait-regions.stderr", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,37 +1,20 @@\n-error[E0277]: the trait bound `No: Foo` is not satisfied in `[generator@$DIR/auto-trait-regions.rs:25:15: 29:6 x:&&OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n+error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:30:5\n    |\n-LL |     assert_foo(gen); //~ ERROR the trait bound `No: Foo` is not satisfied\n-   |     ^^^^^^^^^^ within `[generator@$DIR/auto-trait-regions.rs:25:15: 29:6 x:&&OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`, the trait `Foo` is not implemented for `No`\n-   |\n-   = help: the following implementations were found:\n-             <No as Foo>\n-   = note: required because it appears within the type `OnlyFooIfStaticRef`\n-   = note: required because it appears within the type `&OnlyFooIfStaticRef`\n-   = note: required because it appears within the type `for<'r> {&'r OnlyFooIfStaticRef, ()}`\n-   = note: required because it appears within the type `[generator@$DIR/auto-trait-regions.rs:25:15: 29:6 x:&&OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n-note: required by `assert_foo`\n-  --> $DIR/auto-trait-regions.rs:20:1\n+LL |     assert_foo(gen);\n+   |     ^^^^^^^^^^\n    |\n-LL | fn assert_foo<T: Foo>(f: T) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&'0 OnlyFooIfStaticRef` must implement `Foo` for any lifetime `'0`\n+   = note: but `&'1 OnlyFooIfStaticRef` only implements `Foo` for the lifetime `'1`\n \n-error[E0279]: the requirement `for<'r, 's> 'r : 's` is not satisfied (`expected bound lifetime parameter, found concrete lifetime`)\n-  --> $DIR/auto-trait-regions.rs:47:5\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/auto-trait-regions.rs:48:5\n    |\n-LL |     assert_foo(gen); //~ ERROR the requirement `for<'r, 's> 'r : 's` is not satisfied\n+LL |     assert_foo(gen);\n    |     ^^^^^^^^^^\n    |\n-   = note: required because of the requirements on the impl of `for<'r, 's> Foo` for `A<'_, '_>`\n-   = note: required because it appears within the type `for<'r, 's> {A<'r, 's>, ()}`\n-   = note: required because it appears within the type `[generator@$DIR/auto-trait-regions.rs:42:15: 46:6 for<'r, 's> {A<'r, 's>, ()}]`\n-note: required by `assert_foo`\n-  --> $DIR/auto-trait-regions.rs:20:1\n-   |\n-LL | fn assert_foo<T: Foo>(f: T) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `A<'0, '1>` must implement `Foo` for any two lifetimes `'0` and `'1`\n+   = note: but `A<'_, '2>` only implements `Foo` for the lifetime `'2`\n \n error: aborting due to 2 previous errors\n \n-Some errors occurred: E0277, E0279.\n-For more information about an error, try `rustc --explain E0277`."}, {"sha": "bdfabdabbebb761a342fe682a582227ff53ef126", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:39:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n+   |                            ^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n LL | |                                             for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }"}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_vs_bound_a.stderr", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,16 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: compilation successful\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n-LL | |                                 for<'a>    fn(&'a u32, &'a u32)) }\n-   | |__________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected type `std::option::Option<for<'a, 'b> fn(&'a u32, &'b u32)>`\n-              found type `std::option::Option<for<'a> fn(&'a u32, &'a u32)>`\n+LL | / fn main() {\n+LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n+LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n+LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_a.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,12 +1,12 @@\n error: compilation successful\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n LL | / fn main() {\n LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-LL | | //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-LL | | //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n LL | | }\n    | |_^\n "}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_b.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,12 +1,12 @@\n error: compilation successful\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n LL | / fn main() {\n LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-LL | | //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-LL | | //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n LL | | }\n    | |_^\n "}, {"sha": "74b8c89b6e86f3482c9a2f1c5482cd50973baae6", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_free_x.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:39:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n+   |                            ^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n LL | |                              fn(&'x u32)) }"}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,16 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: compilation successful\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),\n-LL | |                                       for<'a>    fn(Co<'a>, Co<'a>)) }\n-   | |______________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected type `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>)>`\n-              found type `std::option::Option<for<'a> fn(Co<'a>, Co<'a>)>`\n+LL | / fn main() {\n+LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n+LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n+LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,16 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: compilation successful\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_co_a_co_b_ret_contra_a: (for<'a,'b> fn(Co<'a>, Co<'b>) -> Contra<'a>,\n-LL | |                                         for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n-   | |______________________________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected type `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>) -> Contra<'a>>`\n-              found type `std::option::Option<for<'a> fn(Co<'a>, Co<'a>) -> Contra<'a>>`\n+LL | / fn main() {\n+LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n+LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n+LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_vs_bound_co_b.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,12 +1,12 @@\n error: compilation successful\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n LL | / fn main() {\n LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-LL | | //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-LL | | //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n LL | | }\n    | |_^\n "}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,16 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: compilation successful\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_contra_a_contra_b_ret_co_a: (for<'a,'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>,\n-LL | |                                             for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n-   | |______________________________________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected type `std::option::Option<for<'a, 'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>>`\n-              found type `std::option::Option<for<'a> fn(Contra<'a>, Contra<'a>) -> Co<'a>>`\n+LL | / fn main() {\n+LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n+LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n+LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "8168941e2777c6d34a8281c82a1989b7cebfbd63", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:39:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n+   |                            ^^^^^^^^^^^ one type is more general than the other\n ...\n LL | / check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n LL | |                                         for<'a>    fn(Inv<'a>, Inv<'a>)) }"}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,12 +1,12 @@\n error: compilation successful\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n LL | / fn main() {\n LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-LL | | //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-LL | | //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n LL | | }\n    | |_^\n "}, {"sha": "25b74d855bb487eb52e9816ac35d4381245af28a", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_x.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,12 +1,12 @@\n error: compilation successful\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:96:1\n    |\n LL | / fn main() {\n LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-LL | | //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-LL | | //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+...  |\n+LL | | //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n LL | | }\n    | |_^\n "}, {"sha": "ad4f39f8405281defcbdfd0dc7cd4d2373616e24", "filename": "src/test/ui/hr-subtype/hr-subtype.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -31,21 +31,17 @@ macro_rules! check {\n         #[cfg($rev)]\n         fn subtype<'x,'y:'x,'z:'y>() {\n             gimme::<$t2>(None::<$t1>);\n-            //[free_inv_x_vs_free_inv_y]~^ ERROR mismatched types\n+            //[free_inv_x_vs_free_inv_y]~^ ERROR\n         }\n \n         #[cfg($rev)]\n         fn supertype<'x,'y:'x,'z:'y>() {\n             gimme::<$t1>(None::<$t2>);\n-            //[bound_a_vs_free_x]~^ ERROR mismatched types\n-            //[free_x_vs_free_y]~^^ ERROR mismatched types\n-            //[bound_inv_a_b_vs_bound_inv_a]~^^^ ERROR mismatched types\n-            //[bound_a_b_ret_a_vs_bound_a_ret_a]~^^^^ ERROR mismatched types\n-            //[free_inv_x_vs_free_inv_y]~^^^^^ ERROR mismatched types\n-            //[bound_a_b_vs_bound_a]~^^^^^^ ERROR mismatched types\n-            //[bound_co_a_b_vs_bound_co_a]~^^^^^^^ ERROR mismatched types\n-            //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^ ERROR mismatched types\n-            //[bound_co_a_co_b_ret_contra_a]~^^^^^^^^^ ERROR mismatched types\n+            //[bound_a_vs_free_x]~^ ERROR\n+            //[free_x_vs_free_y]~^^ ERROR\n+            //[bound_inv_a_b_vs_bound_inv_a]~^^^ ERROR\n+            //[bound_a_b_ret_a_vs_bound_a_ret_a]~^^^^ ERROR\n+            //[free_inv_x_vs_free_inv_y]~^^^^^ ERROR\n         }\n     }\n }\n@@ -103,4 +99,8 @@ fn main() {\n //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+//[bound_a_b_vs_bound_a]~^^^^^^ ERROR compilation successful\n+//[bound_co_a_co_b_ret_contra_a]~^^^^^^^ ERROR compilation successful\n+//[bound_co_a_b_vs_bound_co_a]~^^^^^^^^ ERROR compilation successful\n+//[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^^ ERROR compilation successful\n }"}, {"sha": "a20d03c7747cdb24078e791a4a31de085176744b", "filename": "src/test/ui/hrtb/hrtb-cache-issue-54302.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,24 @@\n+// Regression test for #54302.\n+//\n+// We were incorrectly using the \"evaluation cache\" (which ignored\n+// region results) to conclude that `&'static str: Deserialize`, even\n+// though it would require that `for<'de> 'de: 'static`, which is\n+// clearly false.\n+\n+trait Deserialize<'de> {}\n+\n+trait DeserializeOwned: for<'de> Deserialize<'de> {}\n+impl<T> DeserializeOwned for T where T: for<'de> Deserialize<'de> {}\n+\n+// Based on this impl, `&'static str` only implements Deserialize<'static>.\n+// It does not implement for<'de> Deserialize<'de>.\n+impl<'de: 'a, 'a> Deserialize<'de> for &'a str {}\n+\n+fn main() {\n+    fn assert_deserialize_owned<T: DeserializeOwned>() {}\n+    assert_deserialize_owned::<&'static str>(); //~ ERROR\n+\n+    // It correctly does not implement for<'de> Deserialize<'de>.\n+    // fn assert_hrtb<T: for<'de> Deserialize<'de>>() {}\n+    // assert_hrtb::<&'static str>();\n+}"}, {"sha": "e82fa51524ef1c52af48ac9171bf3590ea3a19f0", "filename": "src/test/ui/hrtb/hrtb-cache-issue-54302.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,11 @@\n+error: implementation of `Deserialize` is not general enough\n+  --> $DIR/hrtb-cache-issue-54302.rs:19:5\n+   |\n+LL |     assert_deserialize_owned::<&'static str>(); //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `&'static str` must implement `Deserialize<'0>` for any lifetime `'0`\n+   = note: but `&str` only implements `Deserialize<'1>` for some lifetime `'1`\n+\n+error: aborting due to previous error\n+"}, {"sha": "391303676d7845de2ead323c58a016e1ad74f0c0", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -25,6 +25,6 @@ impl<'a> Foo<(&'a isize, &'a isize)> for SomeStruct\n }\n \n fn a() { want_foo1::<SomeStruct>(); } // OK -- foo wants just one region\n-fn b() { want_foo2::<SomeStruct>(); } //~ ERROR E0277\n+fn b() { want_foo2::<SomeStruct>(); } //~ ERROR\n \n fn main() { }"}, {"sha": "2ee398e3dd3b220687552a49b0c466d8945dc857", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.stderr", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,20 +1,12 @@\n-error[E0277]: the trait bound `for<'a, 'b> SomeStruct: Foo<(&'a isize, &'b isize)>` is not satisfied\n+error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-conflate-regions.rs:28:10\n    |\n-LL | fn b() { want_foo2::<SomeStruct>(); } //~ ERROR E0277\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a, 'b> Foo<(&'a isize, &'b isize)>` is not implemented for `SomeStruct`\n+LL | fn b() { want_foo2::<SomeStruct>(); } //~ ERROR\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the following implementations were found:\n-             <SomeStruct as Foo<(&'a isize, &'a isize)>>\n-note: required by `want_foo2`\n-  --> $DIR/hrtb-conflate-regions.rs:8:1\n-   |\n-LL | / fn want_foo2<T>()\n-LL | |     where T : for<'a,'b> Foo<(&'a isize, &'b isize)>\n-LL | | {\n-LL | | }\n-   | |_^\n+   = note: Due to a where-clause on `want_foo2`,\n+   = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `SomeStruct` only implements `Foo<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "828331cb950ed722009170c05d1d025290cab832", "filename": "src/test/ui/hrtb/hrtb-exists-forall-fn.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,18 @@\n+// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+//\n+// In particular, we test this pattern in trait solving, where it is not connected\n+// to any part of the source code.\n+\n+fn foo<'a>() -> fn(&'a u32) {\n+    panic!()\n+}\n+\n+fn main() {\n+    // Here, proving that `fn(&'a u32) <: for<'b> fn(&'b u32)`:\n+    //\n+    // - instantiates `'b` with a placeholder `!b`,\n+    // - requires that `&!b u32 <: &'a u32` and hence that `!b: 'a`,\n+    // - but we can never know this.\n+\n+    let _: for<'b> fn(&'b u32) = foo(); //~ ERROR mismatched types\n+}"}, {"sha": "6301ed45ac277d7919b58d1e561de810f4086762", "filename": "src/test/ui/hrtb/hrtb-exists-forall-fn.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-fn.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/hrtb-exists-forall-fn.rs:17:34\n+   |\n+LL |     let _: for<'b> fn(&'b u32) = foo(); //~ ERROR mismatched types\n+   |                                  ^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'b> fn(&'b u32)`\n+              found type `fn(&u32)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8801760056ecb0b1054070d099bc5ca7fecc7a2e", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-contravariant.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,35 @@\n+// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+//\n+// In particular, we test this pattern in trait solving, where it is not connected\n+// to any part of the source code.\n+//\n+// compile-pass\n+\n+trait Trait<T> {}\n+\n+fn foo<T>()\n+where\n+    T: Trait<for<'b> fn(&'b u32)>,\n+{\n+}\n+\n+impl<'a> Trait<fn(&'a u32)> for () {}\n+\n+fn main() {\n+    // Here, proving that `(): Trait<for<'b> fn(&'b u32)>` uses the impl:\n+    //\n+    // - The impl provides the clause `forall<'a> { (): Trait<fn(&'a u32)> }`\n+    // - We instantiate `'a` existentially to get `(): Trait<fn(&?a u32)>`\n+    // - We unify `fn(&?a u32)` with `for<'b> fn(&'b u32)` -- this does a\n+    //   \"bidirectional\" subtyping check, so we wind up with:\n+    //   - `fn(&?a u32) <: for<'b> fn(&'b u32)` :-\n+    //     - `&'!b u32 <: &?a u32`\n+    //     - `!'b: ?a` -- solveable if `?a` is inferred to `'empty`\n+    //   - `for<'b> fn(&'b u32) <: fn(&?a u32)` :-\n+    //     - `&?a u32 u32 <: &?b u32`\n+    //     - `?a: ?b` -- solveable if `?b` is also inferred to `'empty`\n+    // - So the subtyping check succeeds, somewhat surprisingly.\n+    //   This is because we can use `'empty`.\n+\n+    foo::<()>();\n+}"}, {"sha": "da1bb7cd5fd0bf79f9e56a7d1a9dee3492ff4a57", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-covariant.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,37 @@\n+// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+//\n+// In particular, we test this pattern in trait solving, where it is not connected\n+// to any part of the source code.\n+//\n+// compile-pass\n+\n+trait Trait<T> {}\n+\n+fn foo<T>()\n+where\n+    T: Trait<for<'b> fn(fn(&'b u32))>,\n+{\n+}\n+\n+impl<'a> Trait<fn(fn(&'a u32))> for () {}\n+\n+fn main() {\n+    // Here, proving that `(): Trait<for<'b> fn(&'b u32)>` uses the impl:\n+    //\n+    // - The impl provides the clause `forall<'a> { (): Trait<fn(fn(&'a u32))> }`\n+    // - We instantiate `'a` existentially to get `(): Trait<fn(fn(&?a u32))>`\n+    // - We unify `fn(fn(&?a u32))` with `for<'b> fn(fn(&'b u32))` -- this does a\n+    //   \"bidirectional\" subtyping check, so we wind up with:\n+    //   - `fn(fn(&?a u32)) <: for<'b> fn(fn(&'b u32))` :-\n+    //     - `fn(&!b u32) <: fn(&?a u32)`\n+    //       - `&?a u32 <: &!b u32`\n+    //         - `?a: !'b` -- solveable if `?a` is inferred to `'static`\n+    //   - `for<'b> fn(fn(&'b u32)) <: fn(fn(&?a u32))` :-\n+    //     - `fn(&?a u32) <: fn(&?b u32)`\n+    //       - `&?b u32 <: &?a u32`\n+    //         - `?b: ?a` -- solveable if `?b` is inferred to `'static`\n+    // - So the subtyping check succeeds, somewhat surprisingly.\n+    //   This is because we can use `'static`.\n+\n+    foo::<()>();\n+}"}, {"sha": "da3f8ad1b89570c29a63b6a2538388158050a0e6", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,29 @@\n+// Test a `exists<'a> { forall<'b> { 'a = 'b } }` pattern -- which should not compile!\n+//\n+// In particular, we test this pattern in trait solving, where it is not connected\n+// to any part of the source code.\n+\n+use std::cell::Cell;\n+\n+trait Trait<T> {}\n+\n+fn foo<T>()\n+where\n+    T: Trait<for<'b> fn(Cell<&'b u32>)>,\n+{\n+}\n+\n+impl<'a> Trait<fn(Cell<&'a u32>)> for () {}\n+\n+fn main() {\n+    // Here, proving that `(): Trait<for<'b> fn(&'b u32)>` uses the impl:\n+    //\n+    // - The impl provides the clause `forall<'a> { (): Trait<fn(&'a u32)> }`\n+    // - We instantiate `'a` existentially to get `(): Trait<fn(&?a u32)>`\n+    // - We unify `fn(&?a u32)` with `for<'b> fn(&'b u32)`\n+    //   - This requires (among other things) instantiating `'b` universally,\n+    //     yielding `fn(&!b u32)`, in a fresh universe U1\n+    //   - So we get `?a = !b` but the universe U0 assigned to `?a` cannot name `!b`.\n+\n+    foo::<()>(); //~ ERROR not general enough\n+}"}, {"sha": "6a61181e2407cb915276d937d745f75b346a2779", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -0,0 +1,12 @@\n+error: implementation of `Trait` is not general enough\n+  --> $DIR/hrtb-exists-forall-trait-invariant.rs:28:5\n+   |\n+LL |     foo::<()>(); //~ ERROR not general enough\n+   |     ^^^^^^^^^\n+   |\n+   = note: Due to a where-clause on `foo`,\n+   = note: `()` must implement `Trait<for<'b> fn(std::cell::Cell<&'b u32>)>`\n+   = note: but `()` only implements `Trait<fn(std::cell::Cell<&'0 u32>)>` for some lifetime `'0`\n+\n+error: aborting due to previous error\n+"}, {"sha": "f9ae1429ee4a2c52a2a4c6e03a29ef3fe512c849", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits-transitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -44,7 +44,7 @@ fn want_qux<B>(b: &B)\n     where B : Qux\n {\n     want_foo_for_any_tcx(b);\n-    want_bar_for_any_ccx(b); //~ ERROR E0277\n+    want_bar_for_any_ccx(b); //~ ERROR\n }\n \n fn main() {}"}, {"sha": "0d7b5cbf82348d0391ebfbd8262c0dfa11fff5f9", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits-transitive.stderr", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,19 +1,12 @@\n-error[E0277]: the trait bound `for<'ccx> B: Bar<'ccx>` is not satisfied\n+error[E0308]: mismatched types\n   --> $DIR/hrtb-higher-ranker-supertraits-transitive.rs:47:5\n    |\n-LL |     want_bar_for_any_ccx(b); //~ ERROR E0277\n-   |     ^^^^^^^^^^^^^^^^^^^^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`\n+LL |     want_bar_for_any_ccx(b); //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = help: consider adding a `where for<'ccx> B: Bar<'ccx>` bound\n-note: required by `want_bar_for_any_ccx`\n-  --> $DIR/hrtb-higher-ranker-supertraits-transitive.rs:31:1\n-   |\n-LL | / fn want_bar_for_any_ccx<B>(b: &B)\n-LL | |     where B : for<'ccx> Bar<'ccx>\n-LL | | {\n-LL | | }\n-   | |_^\n+   = note: expected type `for<'ccx> Bar<'ccx>`\n+              found type `Bar<'static>`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3d2d403462d8b2bd48912211467db4ca327333f4", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -15,7 +15,7 @@ fn want_foo_for_some_tcx<'x,F>(f: &'x F)\n     where F : Foo<'x>\n {\n     want_foo_for_some_tcx(f);\n-    want_foo_for_any_tcx(f); //~ ERROR E0277\n+    want_foo_for_any_tcx(f); //~ ERROR E0308\n }\n \n fn want_foo_for_any_tcx<F>(f: &F)\n@@ -32,7 +32,7 @@ fn want_bar_for_some_ccx<'x,B>(b: &B)\n     want_foo_for_any_tcx(b);\n \n     want_bar_for_some_ccx(b);\n-    want_bar_for_any_ccx(b); //~ ERROR E0277\n+    want_bar_for_any_ccx(b); //~ ERROR E0308\n }\n \n fn want_bar_for_any_ccx<B>(b: &B)"}, {"sha": "31dbeec2a551bd888513ba9c9263ed2f789b9412", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits.stderr", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,40 +1,21 @@\n-error[E0277]: the trait bound `for<'tcx> F: Foo<'tcx>` is not satisfied\n+error[E0308]: mismatched types\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:18:5\n    |\n-LL |     want_foo_for_any_tcx(f); //~ ERROR E0277\n-   |     ^^^^^^^^^^^^^^^^^^^^ the trait `for<'tcx> Foo<'tcx>` is not implemented for `F`\n+LL |     want_foo_for_any_tcx(f); //~ ERROR E0308\n+   |     ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = help: consider adding a `where for<'tcx> F: Foo<'tcx>` bound\n-note: required by `want_foo_for_any_tcx`\n-  --> $DIR/hrtb-higher-ranker-supertraits.rs:21:1\n-   |\n-LL | / fn want_foo_for_any_tcx<F>(f: &F)\n-LL | |     where F : for<'tcx> Foo<'tcx>\n-LL | | {\n-LL | |     want_foo_for_some_tcx(f);\n-LL | |     want_foo_for_any_tcx(f);\n-LL | | }\n-   | |_^\n+   = note: expected type `for<'tcx> Foo<'tcx>`\n+              found type `Foo<'x>`\n \n-error[E0277]: the trait bound `for<'ccx> B: Bar<'ccx>` is not satisfied\n+error[E0308]: mismatched types\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:35:5\n    |\n-LL |     want_bar_for_any_ccx(b); //~ ERROR E0277\n-   |     ^^^^^^^^^^^^^^^^^^^^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`\n-   |\n-   = help: consider adding a `where for<'ccx> B: Bar<'ccx>` bound\n-note: required by `want_bar_for_any_ccx`\n-  --> $DIR/hrtb-higher-ranker-supertraits.rs:38:1\n+LL |     want_bar_for_any_ccx(b); //~ ERROR E0308\n+   |     ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-LL | / fn want_bar_for_any_ccx<B>(b: &B)\n-LL | |     where B : for<'ccx> Bar<'ccx>\n-LL | | {\n-LL | |     want_foo_for_some_tcx(b);\n-...  |\n-LL | |     want_bar_for_any_ccx(b);\n-LL | | }\n-   | |_^\n+   = note: expected type `for<'ccx> Bar<'ccx>`\n+              found type `Bar<'x>`\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "88d5ce8e640568dba709cac70488455176ea6f94", "filename": "src/test/ui/hrtb/hrtb-just-for-static.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -21,7 +21,13 @@ fn give_any() {\n struct StaticInt;\n impl Foo<&'static isize> for StaticInt { }\n fn give_static() {\n-    want_hrtb::<StaticInt>() //~ ERROR `for<'a> StaticInt: Foo<&'a isize>` is not satisfied\n+    want_hrtb::<StaticInt>() //~ ERROR\n+}\n+\n+// AnyInt implements Foo<&'a isize> for any 'a, so it is a match.\n+impl<'a> Foo<&'a isize> for &'a u32 { }\n+fn give_some<'a>() {\n+    want_hrtb::<&'a u32>() //~ ERROR\n }\n \n fn main() { }"}, {"sha": "094c449802415ff757f5c99263d5beef76f4bcc2", "filename": "src/test/ui/hrtb/hrtb-just-for-static.stderr", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,20 +1,22 @@\n-error[E0277]: the trait bound `for<'a> StaticInt: Foo<&'a isize>` is not satisfied\n+error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:24:5\n    |\n-LL |     want_hrtb::<StaticInt>() //~ ERROR `for<'a> StaticInt: Foo<&'a isize>` is not satisfied\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> Foo<&'a isize>` is not implemented for `StaticInt`\n+LL |     want_hrtb::<StaticInt>() //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the following implementations were found:\n-             <StaticInt as Foo<&'static isize>>\n-note: required by `want_hrtb`\n-  --> $DIR/hrtb-just-for-static.rs:8:1\n+   = note: Due to a where-clause on `want_hrtb`,\n+   = note: `StaticInt` must implement `Foo<&'0 isize>` for any lifetime `'0`\n+   = note: but `StaticInt` only implements `Foo<&'1 isize>` for some lifetime `'1`\n+\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/hrtb-just-for-static.rs:30:5\n+   |\n+LL |     want_hrtb::<&'a u32>() //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | / fn want_hrtb<T>()\n-LL | |     where T : for<'a> Foo<&'a isize>\n-LL | | {\n-LL | | }\n-   | |_^\n+   = note: Due to a where-clause on `want_hrtb`,\n+   = note: `&'a u32` must implement `Foo<&'0 isize>` for any lifetime `'0`\n+   = note: but `&'1 u32` only implements `Foo<&'1 isize>` for the lifetime `'1`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "7bd89960e42e5bb35e3ad3e561719bee1e30c8fc", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -43,7 +43,7 @@ fn foo_hrtb_bar_not<'b,T>(mut t: T)\n     // be implemented. Thus to satisfy `&mut T : for<'a> Foo<&'a\n     // isize>`, we require `T : for<'a> Bar<&'a isize>`, but the where\n     // clause only specifies `T : Bar<&'b isize>`.\n-    foo_hrtb_bar_not(&mut t); //~ ERROR `for<'a> T: Bar<&'a isize>` is not satisfied\n+    foo_hrtb_bar_not(&mut t); //~ ERROR E0308\n }\n \n fn foo_hrtb_bar_hrtb<T>(mut t: T)"}, {"sha": "ec3bf8a1a1be3b79bfaa7356b49278130ab852eb", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.stderr", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,23 +1,12 @@\n-error[E0277]: the trait bound `for<'a> T: Bar<&'a isize>` is not satisfied\n+error[E0308]: mismatched types\n   --> $DIR/hrtb-perfect-forwarding.rs:46:5\n    |\n-LL |     foo_hrtb_bar_not(&mut t); //~ ERROR `for<'a> T: Bar<&'a isize>` is not satisfied\n-   |     ^^^^^^^^^^^^^^^^ the trait `for<'a> Bar<&'a isize>` is not implemented for `T`\n+LL |     foo_hrtb_bar_not(&mut t); //~ ERROR E0308\n+   |     ^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = help: consider adding a `where for<'a> T: Bar<&'a isize>` bound\n-   = note: required because of the requirements on the impl of `for<'a> Foo<&'a isize>` for `&mut T`\n-note: required by `foo_hrtb_bar_not`\n-  --> $DIR/hrtb-perfect-forwarding.rs:39:1\n-   |\n-LL | / fn foo_hrtb_bar_not<'b,T>(mut t: T)\n-LL | |     where T : for<'a> Foo<&'a isize> + Bar<&'b isize>\n-LL | | {\n-LL | |     // Not OK -- The forwarding impl for `Foo` requires that `Bar` also\n-...  |\n-LL | |     foo_hrtb_bar_not(&mut t); //~ ERROR `for<'a> T: Bar<&'a isize>` is not satisfied\n-LL | | }\n-   | |_^\n+   = note: expected type `Foo<&'a isize>`\n+              found type `Foo<&isize>`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8ef4af15bd462b957ae1313e422f93bb8c1c153f", "filename": "src/test/ui/issues/issue-22872.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-22872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-22872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22872.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -19,7 +19,6 @@ pub trait Process<'a> {\n fn push_process<P>(process: P) where P: Process<'static> {\n     let _: Box<for<'b> Wrap<'b>> = Box::new(Wrapper(process));\n //~^ ERROR is not an iterator\n-//~| ERROR is not satisfied\n }\n \n fn main() {}"}, {"sha": "ebd096f1dde5ac98a2e29620a724251033b5dcaa", "filename": "src/test/ui/issues/issue-22872.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,23 +1,14 @@\n-error[E0277]: the trait bound `for<'b> P: Process<'b>` is not satisfied\n+error[E0277]: `<P as Process<'_>>::Item` is not an iterator\n   --> $DIR/issue-22872.rs:20:36\n    |\n LL |     let _: Box<for<'b> Wrap<'b>> = Box::new(Wrapper(process));\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'b> Process<'b>` is not implemented for `P`\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ `<P as Process<'_>>::Item` is not an iterator\n    |\n-   = help: consider adding a `where for<'b> P: Process<'b>` bound\n+   = help: the trait `std::iter::Iterator` is not implemented for `<P as Process<'_>>::Item`\n+   = help: consider adding a `where <P as Process<'_>>::Item: std::iter::Iterator` bound\n    = note: required because of the requirements on the impl of `for<'b> Wrap<'b>` for `Wrapper<P>`\n    = note: required for the cast to the object type `dyn for<'b> Wrap<'b>`\n \n-error[E0277]: `<P as Process<'b>>::Item` is not an iterator\n-  --> $DIR/issue-22872.rs:20:36\n-   |\n-LL |     let _: Box<for<'b> Wrap<'b>> = Box::new(Wrapper(process));\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ `<P as Process<'b>>::Item` is not an iterator\n-   |\n-   = help: the trait `for<'b> std::iter::Iterator` is not implemented for `<P as Process<'b>>::Item`\n-   = note: required because of the requirements on the impl of `for<'b> Wrap<'b>` for `Wrapper<P>`\n-   = note: required for the cast to the object type `dyn for<'b> Wrap<'b>`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "320992c0764cfd4a3a87200e1c8e970b62c2d5b3", "filename": "src/test/ui/issues/issue-40000.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-40000.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-40000.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40000.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -3,6 +3,5 @@ fn main() {\n \n     fn foo(x: Box<Fn(&i32)>) {}\n     let bar = Box::new(|x: &i32| {}) as Box<Fn(_)>;\n-    foo(bar); //~ ERROR mismatched types\n-    //~| expected concrete lifetime, found bound lifetime parameter\n+    foo(bar); //~ ERROR E0308\n }"}, {"sha": "d7966cea52bb0faba8303917e77e74967c9e6cf1", "filename": "src/test/ui/issues/issue-40000.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-40000.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-40000.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40000.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,11 +1,11 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-40000.rs:6:9\n    |\n-LL |     foo(bar); //~ ERROR mismatched types\n-   |         ^^^ expected concrete lifetime, found bound lifetime parameter\n+LL |     foo(bar); //~ ERROR E0308\n+   |         ^^^ one type is more general than the other\n    |\n-   = note: expected type `std::boxed::Box<(dyn for<'r> std::ops::Fn(&'r i32) + 'static)>`\n-              found type `std::boxed::Box<dyn std::ops::Fn(_)>`\n+   = note: expected type `dyn for<'r> std::ops::Fn(&'r i32)`\n+              found type `dyn std::ops::Fn(&i32)`\n \n error: aborting due to previous error\n "}, {"sha": "faa116269ee96f5d017951dbe290c33ae492f75f", "filename": "src/test/ui/issues/issue-54302-cases.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -61,25 +61,25 @@ impl<T> RefFoo<T> for T where for<'a> &'a T: Foo<'static, T> {\n fn coerce_lifetime1(a: &u32) -> &'static u32\n {\n     <u32 as RefFoo<u32>>::ref_foo(a)\n-    //~^ ERROR the trait bound `for<'a> &'a u32: Foo2<'_, u32>` is not satisfied\n+    //~^ ERROR not general enough\n }\n \n fn coerce_lifetime2(a: &i32) -> &'static i32\n {\n     <i32 as RefFoo<i32>>::ref_foo(a)\n-    //~^ ERROR the requirement `for<'a> 'a : ` is not satisfied\n+    //~^ ERROR not general enough\n }\n \n fn coerce_lifetime3(a: &u64) -> &'static u64\n {\n     <u64 as RefFoo<u64>>::ref_foo(a)\n-    //~^ ERROR type mismatch resolving `for<'a> <&'a u64 as Mirror>::Image == &u64`\n+    //~^ ERROR not general enough\n }\n \n fn coerce_lifetime4(a: &i64) -> &'static i64\n {\n     <i64 as RefFoo<i64>>::ref_foo(a)\n-    //~^ ERROR type mismatch resolving `for<'a> <&'a i64 as Mirror>::Image == &i64`\n+    //~^ ERROR not general enough\n }\n \n fn main() {}"}, {"sha": "c1329d331a18130cc6dd419714c187b17d1ef095", "filename": "src/test/ui/issues/issue-54302-cases.stderr", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,65 +1,38 @@\n-error[E0277]: the trait bound `for<'a> &'a u32: Foo2<'_, u32>` is not satisfied\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:63:5\n    |\n LL |     <u32 as RefFoo<u32>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> Foo2<'_, u32>` is not implemented for `&'a u32`\n-   |\n-   = help: the following implementations were found:\n-             <&'x u32 as Foo2<'x, u32>>\n-   = note: required because of the requirements on the impl of `for<'a> Foo<'static, u32>` for `&'a u32`\n-   = note: required because of the requirements on the impl of `RefFoo<u32>` for `u32`\n-note: required by `RefFoo::ref_foo`\n-  --> $DIR/issue-54302-cases.rs:51:5\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL |     fn ref_foo(&self) -> &'static T;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&'0 u32` must implement `Foo<'static, u32>` for any lifetime `'0`\n+   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n \n-error[E0279]: the requirement `for<'a> 'a : ` is not satisfied (`expected bound lifetime parameter 'a, found concrete lifetime`)\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:69:5\n    |\n LL |     <i32 as RefFoo<i32>>::ref_foo(a)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, i32>` for `&'a i32`\n-   = note: required because of the requirements on the impl of `for<'a> Foo<'static, i32>` for `&'a i32`\n-   = note: required because of the requirements on the impl of `RefFoo<i32>` for `i32`\n-note: required by `RefFoo::ref_foo`\n-  --> $DIR/issue-54302-cases.rs:51:5\n-   |\n-LL |     fn ref_foo(&self) -> &'static T;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&'0 i32` must implement `Foo<'static, i32>` for any lifetime `'0`\n+   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n \n-error[E0271]: type mismatch resolving `for<'a> <&'a u64 as Mirror>::Image == &u64`\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:75:5\n    |\n LL |     <u64 as RefFoo<u64>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'a, found concrete lifetime\n-   |\n-   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, u64>` for `&'a u64`\n-   = note: required because of the requirements on the impl of `for<'a> Foo<'static, u64>` for `&'a u64`\n-   = note: required because of the requirements on the impl of `RefFoo<u64>` for `u64`\n-note: required by `RefFoo::ref_foo`\n-  --> $DIR/issue-54302-cases.rs:51:5\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL |     fn ref_foo(&self) -> &'static T;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&'0 u64` must implement `Foo<'static, u64>` for any lifetime `'0`\n+   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n \n-error[E0271]: type mismatch resolving `for<'a> <&'a i64 as Mirror>::Image == &i64`\n+error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:81:5\n    |\n LL |     <i64 as RefFoo<i64>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'a, found concrete lifetime\n-   |\n-   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, i64>` for `&'a i64`\n-   = note: required because of the requirements on the impl of `for<'a> Foo<'static, i64>` for `&'a i64`\n-   = note: required because of the requirements on the impl of `RefFoo<i64>` for `i64`\n-note: required by `RefFoo::ref_foo`\n-  --> $DIR/issue-54302-cases.rs:51:5\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL |     fn ref_foo(&self) -> &'static T;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&'0 i64` must implement `Foo<'static, i64>` for any lifetime `'0`\n+   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n \n error: aborting due to 4 previous errors\n \n-Some errors occurred: E0271, E0277, E0279.\n-For more information about an error, try `rustc --explain E0271`."}, {"sha": "1bfaebc3895d96dc00c72719055d66cafcaffcfd", "filename": "src/test/ui/issues/issue-54302.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     // Then why does it implement DeserializeOwned? This compiles.\n     fn assert_deserialize_owned<T: DeserializeOwned>() {}\n     assert_deserialize_owned::<&'static str>();\n-    //~^ ERROR the requirement `for<'de> 'de : ` is not satisfied\n+    //~^ ERROR not general enough\n \n     // It correctly does not implement for<'de> Deserialize<'de>.\n     //fn assert_hrtb<T: for<'de> Deserialize<'de>>() {}"}, {"sha": "1b255204b6ef71517026be13d2b3b4f753626222", "filename": "src/test/ui/issues/issue-54302.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,17 +1,11 @@\n-error[E0279]: the requirement `for<'de> 'de : ` is not satisfied (`expected bound lifetime parameter 'de, found concrete lifetime`)\n+error: implementation of `Deserialize` is not general enough\n   --> $DIR/issue-54302.rs:13:5\n    |\n LL |     assert_deserialize_owned::<&'static str>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: required because of the requirements on the impl of `for<'de> Deserialize<'de>` for `&'static str`\n-   = note: required because of the requirements on the impl of `DeserializeOwned` for `&'static str`\n-note: required by `main::assert_deserialize_owned`\n-  --> $DIR/issue-54302.rs:12:5\n-   |\n-LL |     fn assert_deserialize_owned<T: DeserializeOwned>() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&'static str` must implement `Deserialize<'0>` for any lifetime `'0`\n+   = note: but `&str` only implements `Deserialize<'1>` for some lifetime `'1`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0279`."}, {"sha": "324dc86bd92b8175b2cb8fd388f20758bf5c23c1", "filename": "src/test/ui/lub-glb/old-lub-glb-hr.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,11 +1,16 @@\n // Test that we give a note when the old LUB/GLB algorithm would have\n-// succeeded but the new code (which is stricter) gives an error.\n+// succeeded but the new code (which requires equality) gives an\n+// error. However, now that we handle subtyping correctly, we no\n+// longer get an error, because we recognize these two types as\n+// equivalent!\n+//\n+// compile-pass\n \n fn foo(\n     x: fn(&u8, &u8),\n     y: for<'a> fn(&'a u8, &'a u8),\n ) {\n-    let z = match 22 { //~ ERROR incompatible types\n+    let z = match 22 {\n         0 => x,\n         _ => y,\n     };"}, {"sha": "9c397a8fd2cc53d1f1e043b8867f56039578eba0", "filename": "src/test/ui/lub-glb/old-lub-glb-hr.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2442823ef572a65092fbc46f6975633f983b50b6/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2442823ef572a65092fbc46f6975633f983b50b6/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr?ref=2442823ef572a65092fbc46f6975633f983b50b6", "patch": "@@ -1,17 +0,0 @@\n-error[E0308]: match arms have incompatible types\n-  --> $DIR/old-lub-glb-hr.rs:8:13\n-   |\n-LL |       let z = match 22 { //~ ERROR incompatible types\n-   |  _____________^\n-LL | |         0 => x,\n-LL | |         _ => y,\n-   | |              - match arm with an incompatible type\n-LL | |     };\n-   | |_____^ expected bound lifetime parameter, found concrete lifetime\n-   |\n-   = note: expected type `for<'r, 's> fn(&'r u8, &'s u8)`\n-              found type `for<'a> fn(&'a u8, &'a u8)`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "9be7a813603d4a30bc423b726ad291da6a5893a1", "filename": "src/test/ui/lub-glb/old-lub-glb-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -7,7 +7,7 @@ fn foo(\n     x: &for<'a, 'b> Foo<&'a u8, &'b u8>,\n     y: &for<'a> Foo<&'a u8, &'a u8>,\n ) {\n-    let z = match 22 { //~ ERROR incompatible types\n+    let z = match 22 { //~ ERROR E0308\n         0 => x,\n         _ => y,\n     };"}, {"sha": "17d3648156b51b205d9fb3a996b2cef7f590bf5c", "filename": "src/test/ui/lub-glb/old-lub-glb-object.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,16 +1,15 @@\n-error[E0308]: match arms have incompatible types\n+error[E0308]: mismatched types\n   --> $DIR/old-lub-glb-object.rs:10:13\n    |\n-LL |       let z = match 22 { //~ ERROR incompatible types\n+LL |       let z = match 22 { //~ ERROR E0308\n    |  _____________^\n LL | |         0 => x,\n LL | |         _ => y,\n-   | |              - match arm with an incompatible type\n LL | |     };\n-   | |_____^ expected bound lifetime parameter 'a, found concrete lifetime\n+   | |_____^ one type is more general than the other\n    |\n-   = note: expected type `&dyn for<'a, 'b> Foo<&'a u8, &'b u8>`\n-              found type `&dyn for<'a> Foo<&'a u8, &'a u8>`\n+   = note: expected type `dyn for<'a, 'b> Foo<&'a u8, &'b u8>`\n+              found type `dyn for<'a> Foo<&'a u8, &'a u8>`\n \n error: aborting due to previous error\n "}, {"sha": "437150666be0cc6b0e5086c16de4d947b26356c8", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -7,6 +7,6 @@ fn main() {\n \n fn baz<F: Fn(*mut &u32)>(_: F) {}\n fn _test<'a>(f: fn(*mut &'a u32)) {\n-    baz(f); //~ ERROR type mismatch\n-     //~^ ERROR type mismatch\n+    baz(f); //~ ERROR mismatched types\n+     //~| ERROR mismatched types\n }"}, {"sha": "a6628006587c181143321f1b28800f9bcfa3730b", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.stderr", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -22,34 +22,25 @@ LL |     a.iter().map(|_: (u16, u16)| 45); //~ ERROR type mismatch\n    |              |\n    |              expected signature of `fn(&(u32, u32)) -> _`\n \n-error[E0631]: type mismatch in function arguments\n+error[E0308]: mismatched types\n   --> $DIR/closure-arg-type-mismatch.rs:10:5\n    |\n-LL |     baz(f); //~ ERROR type mismatch\n-   |     ^^^\n-   |     |\n-   |     expected signature of `for<'r> fn(*mut &'r u32) -> _`\n-   |     found signature of `fn(*mut &'a u32) -> _`\n+LL |     baz(f); //~ ERROR mismatched types\n+   |     ^^^ one type is more general than the other\n    |\n-note: required by `baz`\n-  --> $DIR/closure-arg-type-mismatch.rs:8:1\n-   |\n-LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected type `for<'r> std::ops::Fn<(*mut &'r u32,)>`\n+              found type `std::ops::Fn<(*mut &'a u32,)>`\n \n-error[E0271]: type mismatch resolving `for<'r> <fn(*mut &'a u32) as std::ops::FnOnce<(*mut &'r u32,)>>::Output == ()`\n+error[E0308]: mismatched types\n   --> $DIR/closure-arg-type-mismatch.rs:10:5\n    |\n-LL |     baz(f); //~ ERROR type mismatch\n-   |     ^^^ expected bound lifetime parameter, found concrete lifetime\n-   |\n-note: required by `baz`\n-  --> $DIR/closure-arg-type-mismatch.rs:8:1\n+LL |     baz(f); //~ ERROR mismatched types\n+   |     ^^^ one type is more general than the other\n    |\n-LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected type `std::ops::FnOnce<(*mut &u32,)>`\n+              found type `std::ops::FnOnce<(*mut &'a u32,)>`\n \n error: aborting due to 5 previous errors\n \n-Some errors occurred: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+Some errors occurred: E0308, E0631.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "152a525493732aa4eb3278bd69574cf970a71f1b", "filename": "src/test/ui/mismatched_types/closure-mismatch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -5,6 +5,5 @@ impl<T: Fn(&())> Foo for T {}\n fn baz<T: Foo>(_: T) {}\n \n fn main() {\n-    baz(|_| ()); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n+    baz(|_| ()); //~ ERROR E0308\n }"}, {"sha": "0d87bc228755fc60942ceaae778871dbc88a2b7f", "filename": "src/test/ui/mismatched_types/closure-mismatch.stderr", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,32 +1,12 @@\n-error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/closure-mismatch.rs:8:9: 8:15] as std::ops::FnOnce<(&'r (),)>>::Output == ()`\n+error[E0308]: mismatched types\n   --> $DIR/closure-mismatch.rs:8:5\n    |\n-LL |     baz(|_| ()); //~ ERROR type mismatch\n-   |     ^^^ expected bound lifetime parameter, found concrete lifetime\n+LL |     baz(|_| ()); //~ ERROR E0308\n+   |     ^^^ one type is more general than the other\n    |\n-   = note: required because of the requirements on the impl of `Foo` for `[closure@$DIR/closure-mismatch.rs:8:9: 8:15]`\n-note: required by `baz`\n-  --> $DIR/closure-mismatch.rs:5:1\n-   |\n-LL | fn baz<T: Foo>(_: T) {}\n-   | ^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/closure-mismatch.rs:8:5\n-   |\n-LL |     baz(|_| ()); //~ ERROR type mismatch\n-   |     ^^^ ------ found signature of `fn(_) -> _`\n-   |     |\n-   |     expected signature of `for<'r> fn(&'r ()) -> _`\n-   |\n-   = note: required because of the requirements on the impl of `Foo` for `[closure@$DIR/closure-mismatch.rs:8:9: 8:15]`\n-note: required by `baz`\n-  --> $DIR/closure-mismatch.rs:5:1\n-   |\n-LL | fn baz<T: Foo>(_: T) {}\n-   | ^^^^^^^^^^^^^^^^^^^^\n+   = note: expected type `for<'r> std::ops::Fn<(&'r (),)>`\n+              found type `std::ops::Fn<(&(),)>`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0271, E0631.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "242119cc201dafcbc273639118b14b2a3cd1340f", "filename": "src/test/ui/regions-fn-subtyping-return-static-fail.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -37,20 +37,15 @@ fn baz(x: &S) -> &S {\n fn supply_F() {\n     want_F(foo);\n \n-    // FIXME(#33684) -- this should be a subtype, but current alg. rejects it incorrectly\n-    want_F(bar); //~ ERROR E0308\n+    want_F(bar);\n \n     want_F(baz);\n }\n \n fn supply_G() {\n     want_G(foo);\n     want_G(bar);\n-    want_G(baz);\n-    //~^ ERROR mismatched types\n-    //~| expected type `for<'cx> fn(&'cx S) -> &'static S`\n-    //~| found type `for<'r> fn(&'r S) -> &'r S {baz}`\n-    //~| expected concrete lifetime, found bound lifetime parameter 'cx\n+    want_G(baz); //~ ERROR\n }\n \n pub fn main() {"}, {"sha": "a9234e43191eabed1a59258a7f0c609579c0b080", "filename": "src/test/ui/regions-fn-subtyping-return-static-fail.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,21 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/regions-fn-subtyping-return-static-fail.rs:41:12\n+  --> $DIR/regions-fn-subtyping-return-static-fail.rs:48:12\n    |\n-LL |     want_F(bar); //~ ERROR E0308\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n-   |\n-   = note: expected type `for<'cx> fn(&'cx S) -> &'cx S`\n-              found type `for<'a> fn(&'a S) -> &S {bar::<'_>}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/regions-fn-subtyping-return-static-fail.rs:49:12\n-   |\n-LL |     want_G(baz);\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n+LL |     want_G(baz); //~ ERROR\n+   |            ^^^ one type is more general than the other\n    |\n    = note: expected type `for<'cx> fn(&'cx S) -> &'static S`\n-              found type `for<'r> fn(&'r S) -> &'r S {baz}`\n+              found type `for<'r> fn(&'r S) -> &'r S`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "47e1d0efdc77b8d257a9f8ef43f22520ae19b894", "filename": "src/test/ui/regions/region-lifetime-bounds-on-fns-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -20,10 +20,10 @@ error[E0308]: mismatched types\n   --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:43\n    |\n LL |     let _: fn(&mut &isize, &mut &isize) = a; //~ ERROR mismatched types\n-   |                                           ^ expected concrete lifetime, found bound lifetime parameter\n+   |                                           ^ one type is more general than the other\n    |\n    = note: expected type `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n-              found type `for<'r, 's> fn(&'r mut &isize, &'s mut &isize) {a::<'_, '_>}`\n+              found type `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "066522548ad4567d98c7e9673718d0051cadfc81", "filename": "src/test/ui/regions/region-multiple-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -19,7 +19,7 @@ fn c<'a,'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) {\n fn d() {\n     // 'a and 'b are early bound in the function `a` because they appear\n     // inconstraints:\n-    let _: fn(&mut &isize, &mut &isize, &mut &isize) = a; //~ ERROR mismatched types\n+    let _: fn(&mut &isize, &mut &isize, &mut &isize) = a; //~ ERROR E0308\n }\n \n fn e() {"}, {"sha": "1e7b99053f77f01be9f359eb537206d940e3cf93", "filename": "src/test/ui/regions/region-multiple-lifetime-bounds-on-fns-where-clause.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -30,11 +30,11 @@ LL |     a(x, y, z); //~ ERROR lifetime mismatch [E0623]\n error[E0308]: mismatched types\n   --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:56\n    |\n-LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a; //~ ERROR mismatched types\n-   |                                                        ^ expected concrete lifetime, found bound lifetime parameter\n+LL |     let _: fn(&mut &isize, &mut &isize, &mut &isize) = a; //~ ERROR E0308\n+   |                                                        ^ one type is more general than the other\n    |\n    = note: expected type `for<'r, 's, 't0, 't1, 't2, 't3> fn(&'r mut &'s isize, &'t0 mut &'t1 isize, &'t2 mut &'t3 isize)`\n-              found type `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize) {a::<'_, '_, '_>}`\n+              found type `for<'r, 's, 't0> fn(&'r mut &isize, &'s mut &isize, &'t0 mut &isize)`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "4d6d342f571a5c6b27fecbdd0ab0d5dc5acfa53f", "filename": "src/test/ui/regions/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -5,6 +5,8 @@\n // *ANY* lifetime and returns a reference with the 'static lifetime.\n // This can safely be considered to be an instance of `F` because all\n // lifetimes are sublifetimes of 'static.\n+//\n+// compile-pass\n \n #![allow(dead_code)]\n #![allow(unused_variables)]\n@@ -37,8 +39,7 @@ fn baz(x: &S) -> &S {\n fn supply_F() {\n     want_F(foo);\n \n-    // FIXME(#33684) -- this should be a subtype, but current alg. rejects it incorrectly\n-    want_F(bar); //~ ERROR E0308\n+    want_F(bar);\n \n     want_F(baz);\n }"}, {"sha": "61eaf9fcf109b01d782a96095a09581468d9c927", "filename": "src/test/ui/regions/regions-fn-subtyping-return-static.stderr", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,12 +1,26 @@\n-error[E0308]: mismatched types\n-  --> $DIR/regions-fn-subtyping-return-static.rs:41:12\n+warning: function `want_F` should have a snake case name such as `want_f`\n+  --> $DIR/regions-fn-subtyping-return-static.rs:18:1\n    |\n-LL |     want_F(bar); //~ ERROR E0308\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n+LL | fn want_F(f: F) { }\n+   | ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected type `for<'cx> fn(&'cx S) -> &'cx S`\n-              found type `for<'a> fn(&'a S) -> &S {bar::<'_>}`\n+   = note: #[warn(non_snake_case)] on by default\n \n-error: aborting due to previous error\n+warning: function `want_G` should have a snake case name such as `want_g`\n+  --> $DIR/regions-fn-subtyping-return-static.rs:22:1\n+   |\n+LL | fn want_G(f: G) { }\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+warning: function `supply_F` should have a snake case name such as `supply_f`\n+  --> $DIR/regions-fn-subtyping-return-static.rs:39:1\n+   |\n+LL | / fn supply_F() {\n+LL | |     want_F(foo);\n+LL | |\n+LL | |     want_F(bar);\n+LL | |\n+LL | |     want_F(baz);\n+LL | | }\n+   | |_^\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "7d7f62e19792f1847158ad3a76f726ddac6bd353", "filename": "src/test/ui/regions/regions-lifetime-bounds-on-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -17,7 +17,7 @@ fn c<'a,'b>(x: &mut &'a isize, y: &mut &'b isize) {\n fn d() {\n     // 'a and 'b are early bound in the function `a` because they appear\n     // inconstraints:\n-    let _: fn(&mut &isize, &mut &isize) = a; //~ ERROR mismatched types\n+    let _: fn(&mut &isize, &mut &isize) = a; //~ ERROR E0308\n }\n \n fn e() {"}, {"sha": "a43ee7ec3ace0d9c6f41ad11cec64c9daf95e218", "filename": "src/test/ui/regions/regions-lifetime-bounds-on-fns.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -19,11 +19,11 @@ LL |     a(x, y); //~ ERROR lifetime mismatch [E0623]\n error[E0308]: mismatched types\n   --> $DIR/regions-lifetime-bounds-on-fns.rs:20:43\n    |\n-LL |     let _: fn(&mut &isize, &mut &isize) = a; //~ ERROR mismatched types\n-   |                                           ^ expected concrete lifetime, found bound lifetime parameter\n+LL |     let _: fn(&mut &isize, &mut &isize) = a; //~ ERROR E0308\n+   |                                           ^ one type is more general than the other\n    |\n    = note: expected type `for<'r, 's, 't0, 't1> fn(&'r mut &'s isize, &'t0 mut &'t1 isize)`\n-              found type `for<'r, 's> fn(&'r mut &isize, &'s mut &isize) {a::<'_, '_>}`\n+              found type `for<'r, 's> fn(&'r mut &isize, &'s mut &isize)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0ce38e69f6b0fa8c29c4a45f5305713e7e6f7d15", "filename": "src/test/ui/where-clauses/where-for-self-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.rs?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -18,6 +18,5 @@ fn foo<T>(x: &T)\n {}\n \n fn main() {\n-    foo(&X);\n-    //~^ error: `for<'a> &'a _: Bar` is not satisfied\n+    foo(&X); //~ ERROR implementation of `Bar` is not general enough\n }"}, {"sha": "afc80bf4d8ee653b040ed3adea2e65d1b99391cf", "filename": "src/test/ui/where-clauses/where-for-self-2.stderr", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr?ref=c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "patch": "@@ -1,19 +1,12 @@\n-error[E0277]: the trait bound `for<'a> &'a _: Bar` is not satisfied\n+error: implementation of `Bar` is not general enough\n   --> $DIR/where-for-self-2.rs:21:5\n    |\n-LL |     foo(&X);\n-   |     ^^^ the trait `for<'a> Bar` is not implemented for `&'a _`\n+LL |     foo(&X); //~ ERROR implementation of `Bar` is not general enough\n+   |     ^^^\n    |\n-   = help: the following implementations were found:\n-             <&'static u32 as Bar>\n-note: required by `foo`\n-  --> $DIR/where-for-self-2.rs:16:1\n-   |\n-LL | / fn foo<T>(x: &T)\n-LL | |     where for<'a> &'a T: Bar\n-LL | | {}\n-   | |__^\n+   = note: Due to a where-clause on `foo`,\n+   = note: `&'0 _` must implement `Bar` for any lifetime `'0`\n+   = note: but `&'1 u32` only implements `Bar` for the lifetime `'1`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}]}