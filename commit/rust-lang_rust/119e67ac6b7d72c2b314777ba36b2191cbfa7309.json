{"sha": "119e67ac6b7d72c2b314777ba36b2191cbfa7309", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOWU2N2FjNmI3ZDcyYzJiMzE0Nzc3YmEzNmIyMTkxY2JmYTczMDk=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-23T17:44:41Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-23T17:44:41Z"}, "message": "Reduce noise and document test case.\n\nThis commit introduces a `assert_drop_order_after_poll` helper function\nto the test case for this case to reduce repetitive noise and documents\nwhat each function aims to test.", "tree": {"sha": "b1f97b4197dc140f4e77c4f8e286dc0a04f0687e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1f97b4197dc140f4e77c4f8e286dc0a04f0687e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119e67ac6b7d72c2b314777ba36b2191cbfa7309", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAly/TzQACgkQAXYLT59T\n8VQ+6w//Y1QIIU1vYcCICa42c2+A8gMRBFmHt1iSof7FT8ChnrF3xtJwSzfiVZnb\nQCc24V0Io6aszLvHAQqygsBKN5xMjHJe7emmhTscPRcIJLOLKNPdd7amMmwnwWDh\n+yC1/bO9/3gJnfz7rDFcW7d/cKWlM0YuVChRIVUlp9EFsDQHFKCyP7QLHYjNo6dl\nhHgnUG91H+c549y47rfyFCXz5fF0b+ng1JLcUMtfPoPEiqM+Yb0+jp+AyS1E66D5\nHWWmW74iKd2pARZ5IAREHBXJgxapNmSUEUI7xcdQOcZ/B3ivGh+ziIyh7B9kZ6qx\nIOidzdEZw9mVCFoY1Ku5qIK3beuvqQeLwBeDsz3bW0OaZYT8ToybqtQDOwQ9ekAe\nQzoRlb8jUr/SZlGJyDUtbb2+E7maRDs4HsVejQFQt7+bILAfUcOwn5XkMLs5LdAi\nZDDqbj/XXj/eZH7jn9P/ydY539R/V/xh7MwKJ+DVCKB8Uty6FwF5wGANucrLiRjb\nc0oniz3VCCo0MkrgNBKj7tAZuxOZTbrWLkipGNGtlgxi+2Vnn9soyXSwGfe1IFPz\n301R4hjK9rByRxKtLSjr4sIVS3W40aQ8eY7cN94DlFqNzLNoVQRZAc+IWylLIt7y\nhgCYXQpMAtyDR+ZyrlaBHDA6UCnYy8LWVz7+jpbT+FyrtQX72pk=\n=xxSK\n-----END PGP SIGNATURE-----", "payload": "tree b1f97b4197dc140f4e77c4f8e286dc0a04f0687e\nparent 09c707f0ca8198bcf81ceab2f68298f661b37b6f\nauthor David Wood <david@davidtw.co> 1556041481 +0100\ncommitter David Wood <david@davidtw.co> 1556041481 +0100\n\nReduce noise and document test case.\n\nThis commit introduces a `assert_drop_order_after_poll` helper function\nto the test case for this case to reduce repetitive noise and documents\nwhat each function aims to test.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119e67ac6b7d72c2b314777ba36b2191cbfa7309", "html_url": "https://github.com/rust-lang/rust/commit/119e67ac6b7d72c2b314777ba36b2191cbfa7309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119e67ac6b7d72c2b314777ba36b2191cbfa7309/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09c707f0ca8198bcf81ceab2f68298f661b37b6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/09c707f0ca8198bcf81ceab2f68298f661b37b6f", "html_url": "https://github.com/rust-lang/rust/commit/09c707f0ca8198bcf81ceab2f68298f661b37b6f"}], "stats": {"total": 174, "additions": 83, "deletions": 91}, "files": [{"sha": "ea4f5e076b005b294470c613891f52d3d35506a2", "filename": "src/test/run-pass/issue-54716.rs", "status": "modified", "additions": 83, "deletions": 91, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/119e67ac6b7d72c2b314777ba36b2191cbfa7309/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119e67ac6b7d72c2b314777ba36b2191cbfa7309/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-54716.rs?ref=119e67ac6b7d72c2b314777ba36b2191cbfa7309", "patch": "@@ -12,6 +12,7 @@ use std::cell::RefCell;\n use std::future::Future;\n use std::marker::PhantomData;\n use std::sync::Arc;\n+use std::rc::Rc;\n use std::task::Context;\n \n struct EmptyWaker;\n@@ -26,45 +27,59 @@ enum DropOrder {\n     Val(&'static str),\n }\n \n-struct D(&'static str, Arc<RefCell<Vec<DropOrder>>>);\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n \n impl Drop for D {\n     fn drop(&mut self) {\n         self.1.borrow_mut().push(DropOrder::Val(self.0));\n     }\n }\n \n+/// Check that unused bindings are dropped after the function is polled.\n async fn foo(x: D, _y: D) {\n     x.1.borrow_mut().push(DropOrder::Function);\n }\n \n+/// Check that underscore patterns are dropped after the function is polled.\n async fn bar(x: D, _: D) {\n     x.1.borrow_mut().push(DropOrder::Function);\n }\n \n+/// Check that underscore patterns within more complex patterns are dropped after the function\n+/// is polled.\n async fn baz((x, _): (D, D)) {\n     x.1.borrow_mut().push(DropOrder::Function);\n }\n \n+/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n+/// after the function is polled.\n async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n     x.1.borrow_mut().push(DropOrder::Function);\n }\n \n struct Foo;\n \n impl Foo {\n+    /// Check that unused bindings are dropped after the method is polled.\n     async fn foo(x: D, _y: D) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n \n+    /// Check that underscore patterns are dropped after the method is polled.\n     async fn bar(x: D, _: D) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n \n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// is polled.\n     async fn baz((x, _): (D, D)) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n \n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method is polled.\n     async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n@@ -73,120 +88,97 @@ impl Foo {\n struct Bar<'a>(PhantomData<&'a ()>);\n \n impl<'a> Bar<'a> {\n+    /// Check that unused bindings are dropped after the method with self is polled.\n     async fn foo(&'a self, x: D, _y: D) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n \n+    /// Check that underscore patterns are dropped after the method with self is polled.\n     async fn bar(&'a self, x: D, _: D) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n \n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// with self is polled.\n     async fn baz(&'a self, (x, _): (D, D)) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n \n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method with self is polled.\n     async fn foobar(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n         x.1.borrow_mut().push(DropOrder::Function);\n     }\n }\n \n-fn main() {\n+fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    expected_order: &[DropOrder],\n+) {\n     let empty = Arc::new(EmptyWaker);\n     let waker = ArcWake::into_waker(empty);\n     let mut cx = Context::from_waker(&waker);\n \n-    use DropOrder::*;\n-\n-    // Currently, the `bar` and `foobar` tests do not output the same order as the equivalent\n-    // non-async functions. This is because the drop order of captured variables doesn't match the\n-    // drop order of arguments in a function.\n-\n-    // Free functions\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(foo(D(\"x\", af.clone()), D(\"_y\", af.clone())));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"_y\"), Val(\"x\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(bar(D(\"x\", af.clone()), D(\"_\", af.clone())));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"x\"), Val(\"_\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(baz((D(\"x\", af.clone()), D(\"_\", af.clone()))));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"x\"), Val(\"_\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(foobar(\n-        D(\"x\", af.clone()),\n-        (D(\"a\", af.clone()), D(\"_\", af.clone()), D(\"_c\", af.clone())),\n-        D(\"_\", af.clone()),\n-        D(\"_y\", af.clone()),\n-    ));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[\n-       Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\"),\n-    ]);\n-\n-    // Methods w/out self\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(Foo::foo(D(\"x\", af.clone()), D(\"_y\", af.clone())));\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n     let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"_y\"), Val(\"x\")]);\n \n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(Foo::bar(D(\"x\", af.clone()), D(\"_\", af.clone())));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"x\"), Val(\"_\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(Foo::baz((D(\"x\", af.clone()), D(\"_\", af.clone()))));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"x\"), Val(\"_\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(Foo::foobar(\n-        D(\"x\", af.clone()),\n-        (D(\"a\", af.clone()), D(\"_\", af.clone()), D(\"_c\", af.clone())),\n-        D(\"_\", af.clone()),\n-        D(\"_y\", af.clone()),\n-    ));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[\n-       Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\"),\n-    ]);\n+    assert_eq!(*actual_order.borrow(), expected_order);\n+}\n \n-    // Methods\n+fn main() {\n+    use DropOrder::*;\n \n+    // At time of writing (23/04/19), the `bar` and `foobar` tests do not output the same order as\n+    // the equivalent non-async functions. This is because the drop order of captured variables\n+    // doesn't match the drop order of arguments in a function.\n+\n+    // Free functions (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n+    assert_drop_order_after_poll(|l| bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| {\n+        foobar(\n+            D(\"x\", l.clone()),\n+            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+            D(\"_\", l.clone()),\n+            D(\"_y\", l.clone()),\n+        )\n+    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n+\n+    // Methods w/out self (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| Foo::foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n+    assert_drop_order_after_poll(|l| Foo::bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| Foo::baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| {\n+        Foo::foobar(\n+            D(\"x\", l.clone()),\n+            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+            D(\"_\", l.clone()),\n+            D(\"_y\", l.clone()),\n+        )\n+    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n+\n+    // Methods (see doc comment on function for what it tests).\n     let b = Bar(Default::default());\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(b.foo(D(\"x\", af.clone()), D(\"_y\", af.clone())));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"_y\"), Val(\"x\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(b.bar(D(\"x\", af.clone()), D(\"_\", af.clone())));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"x\"), Val(\"_\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(b.baz((D(\"x\", af.clone()), D(\"_\", af.clone()))));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[Function, Val(\"x\"), Val(\"_\")]);\n-\n-    let af = Arc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(b.foobar(\n-        D(\"x\", af.clone()),\n-        (D(\"a\", af.clone()), D(\"_\", af.clone()), D(\"_c\", af.clone())),\n-        D(\"_\", af.clone()),\n-        D(\"_y\", af.clone()),\n-    ));\n-    let _ = fut.as_mut().poll(&mut cx);\n-    assert_eq!(*af.borrow(), &[\n-       Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\"),\n-    ]);\n+    assert_drop_order_after_poll(|l| b.foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n+    assert_drop_order_after_poll(|l| b.bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| b.baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| {\n+        b.foobar(\n+            D(\"x\", l.clone()),\n+            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+            D(\"_\", l.clone()),\n+            D(\"_y\", l.clone()),\n+        )\n+    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n }"}]}