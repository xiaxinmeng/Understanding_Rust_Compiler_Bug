{"sha": "967a4b64af2f09e11108d28f11565fa0f3e583a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2N2E0YjY0YWYyZjA5ZTExMTA4ZDI4ZjExNTY1ZmEwZjNlNTgzYTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-16T14:17:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T09:53:22Z"}, "message": "Reorganize name resolution", "tree": {"sha": "985072c007ce020de3c5205f0f976d872e44c41a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/985072c007ce020de3c5205f0f976d872e44c41a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/967a4b64af2f09e11108d28f11565fa0f3e583a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/967a4b64af2f09e11108d28f11565fa0f3e583a5", "html_url": "https://github.com/rust-lang/rust/commit/967a4b64af2f09e11108d28f11565fa0f3e583a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/967a4b64af2f09e11108d28f11565fa0f3e583a5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4449945a069d26035afe9d8627414f6dfc8bf0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4449945a069d26035afe9d8627414f6dfc8bf0a", "html_url": "https://github.com/rust-lang/rust/commit/d4449945a069d26035afe9d8627414f6dfc8bf0a"}], "stats": {"total": 1003, "additions": 481, "deletions": 522}, "files": [{"sha": "c3124480b3d8361702a1be45b5b939ae4c347283", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -8,8 +8,7 @@ use crate::{\n     Name, ScopesWithSourceMap, Ty, HirFileId,\n     HirDatabase, PersistentHirDatabase,\n     type_ref::TypeRef,\n-    nameres::{ModuleScope, Namespace, lower::ImportId},\n-    nameres::crate_def_map::ModuleId,\n+    nameres::{ModuleScope, Namespace, ImportId, ModuleId},\n     expr::{Body, BodySourceMap},\n     ty::InferenceResult,\n     adt::{EnumVariantId, StructFieldId, VariantDef},"}, {"sha": "9f4448475c564e67a8dca4805d1d16d420a4675e", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -3,8 +3,7 @@ use ra_syntax::{ast, SyntaxNode, TreeArc, AstNode};\n \n use crate::{\n     Module, ModuleSource, Problem, Name,\n-    nameres::crate_def_map::ModuleId,\n-    nameres::lower::ImportId,\n+    nameres::{ModuleId, ImportId},\n     HirDatabase, PersistentHirDatabase,\n     HirFileId, SourceItemId,\n };"}, {"sha": "d2cc19b0f9206c6fa45a65fca96a1deac870f6c7", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n     macros::MacroExpansion,\n-    nameres::{Namespace, lower::{ImportSourceMap}, crate_def_map::{RawItems, CrateDefMap}},\n+    nameres::{Namespace, ImportSourceMap, RawItems, CrateDefMap},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig},\n     adt::{StructData, EnumData},\n     impl_block::{ModuleImplBlocks, ImplSourceMap},"}, {"sha": "30e959c0442f63efa2ec66edc9986baab83a6449", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 362, "deletions": 100, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -1,35 +1,128 @@\n-//! Name resolution algorithm. The end result of the algorithm is an `ItemMap`:\n-//! a map which maps each module to its scope: the set of items visible in the\n-//! module. That is, we only resolve imports here, name resolution of item\n-//! bodies will be done in a separate step.\n-//!\n-//! Like Rustc, we use an interactive per-crate algorithm: we start with scopes\n-//! containing only directly defined items, and then iteratively resolve\n-//! imports.\n-//!\n-//! To make this work nicely in the IDE scenario, we place `InputModuleItems`\n-//! in between raw syntax and name resolution. `InputModuleItems` are computed\n-//! using only the module's syntax, and it is all directly defined items plus\n-//! imports. The plan is to make `InputModuleItems` independent of local\n-//! modifications (that is, typing inside a function should not change IMIs),\n-//! so that the results of name resolution can be preserved unless the module\n-//! structure itself is modified.\n-pub(crate) mod lower;\n-pub(crate) mod crate_def_map;\n+/// This module implements import-resolution/macro expansion algorithm.\n+///\n+/// The result of this module is `CrateDefMap`: a datastructure which contains:\n+///\n+///   * a tree of modules for the crate\n+///   * for each module, a set of items visible in the module (directly declared\n+///     or imported)\n+///\n+/// Note that `CrateDefMap` contains fully macro expanded code.\n+///\n+/// Computing `CrateDefMap` can be partitioned into several logically\n+/// independent \"phases\". The phases are mutually recursive though, there's no\n+/// stric ordering.\n+///\n+/// ## Collecting RawItems\n+///\n+///  This happens in the `raw` module, which parses a single source file into a\n+///  set of top-level items. Nested importa are desugared to flat imports in\n+///  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+///  TokenTree).\n+///\n+/// ## Collecting Modules\n+///\n+/// This happens in the `collector` module. In this phase, we recursively walk\n+/// tree of modules, collect raw items from submodules, populate module scopes\n+/// with defined items (so, we assign item ids in this phase) and record the set\n+/// of unresovled imports and macros.\n+///\n+/// While we walk tree of modules, we also record macro_rules defenitions and\n+/// expand calls to macro_rules defined macros.\n+///\n+/// ## Resolving Imports\n+///\n+/// TBD\n+///\n+/// ## Resolving Macros\n+///\n+/// While macro_rules from the same crate use a global mutable namespace, macros\n+/// from other crates (including proc-macros) can be used with `foo::bar!`\n+/// syntax.\n+///\n+/// TBD;\n+\n+mod per_ns;\n+mod raw;\n+mod collector;\n+#[cfg(test)]\n+mod tests;\n+\n+use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n-use ra_db::Edition;\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_db::{FileId, Edition};\n+use test_utils::tested_by;\n \n use crate::{\n-    ModuleDef, Name,\n-    nameres::lower::ImportId,\n+    ModuleDef, Name, Crate, Module, Problem,\n+    PersistentHirDatabase, Path, PathKind, HirFileId,\n+    ids::{SourceItemId, SourceFileItemId},\n };\n \n-pub(crate) use self::crate_def_map::{CrateDefMap, ModuleId};\n+pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n+\n+pub use self::per_ns::{PerNs, Namespace};\n+\n+/// Contans all top-level defs from a macro-expanded crate\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct CrateDefMap {\n+    krate: Crate,\n+    edition: Edition,\n+    /// The prelude module for this crate. This either comes from an import\n+    /// marked with the `prelude_import` attribute, or (in the normal case) from\n+    /// a dependency (`std` or `core`).\n+    prelude: Option<Module>,\n+    extern_prelude: FxHashMap<Name, ModuleDef>,\n+    root: ModuleId,\n+    modules: Arena<ModuleId, ModuleData>,\n+    public_macros: FxHashMap<Name, mbe::MacroRules>,\n+    problems: CrateDefMapProblems,\n+}\n+\n+impl std::ops::Index<ModuleId> for CrateDefMap {\n+    type Output = ModuleData;\n+    fn index(&self, id: ModuleId) -> &ModuleData {\n+        &self.modules[id]\n+    }\n+}\n+\n+/// An ID of a module, **local** to a specific crate\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(crate) struct ModuleId(RawId);\n+impl_arena_id!(ModuleId);\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct ModuleData {\n+    pub(crate) parent: Option<ModuleId>,\n+    pub(crate) children: FxHashMap<Name, ModuleId>,\n+    pub(crate) scope: ModuleScope,\n+    /// None for root\n+    pub(crate) declaration: Option<SourceItemId>,\n+    /// None for inline modules.\n+    ///\n+    /// Note that non-inline modules, by definition, live inside non-macro file.\n+    pub(crate) definition: Option<FileId>,\n+}\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct CrateDefMapProblems {\n+    problems: Vec<(SourceItemId, Problem)>,\n+}\n+\n+impl CrateDefMapProblems {\n+    fn add(&mut self, source_item_id: SourceItemId, problem: Problem) {\n+        self.problems.push((source_item_id, problem))\n+    }\n+\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (&'a SourceItemId, &'a Problem)> + 'a {\n+        self.problems.iter().map(|(s, p)| (s, p))\n+    }\n+}\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n-    pub(crate) items: FxHashMap<Name, Resolution>,\n+    items: FxHashMap<Name, Resolution>,\n }\n \n impl ModuleScope {\n@@ -41,8 +134,6 @@ impl ModuleScope {\n     }\n }\n \n-/// `Resolution` is basically `DefId` atm, but it should account for stuff like\n-/// multiple namespaces, ambiguity and errors.\n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct Resolution {\n     /// None for unresolved\n@@ -51,114 +142,285 @@ pub struct Resolution {\n     pub import: Option<ImportId>,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Namespace {\n-    Types,\n-    Values,\n+#[derive(Debug, Clone)]\n+struct ResolvePathResult {\n+    resolved_def: PerNs<ModuleDef>,\n+    segment_index: Option<usize>,\n+    reached_fixedpoint: ReachedFixedPoint,\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct PerNs<T> {\n-    pub types: Option<T>,\n-    pub values: Option<T>,\n-}\n+impl ResolvePathResult {\n+    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+    }\n \n-impl<T> Default for PerNs<T> {\n-    fn default() -> Self {\n-        PerNs { types: None, values: None }\n+    fn with(\n+        resolved_def: PerNs<ModuleDef>,\n+        reached_fixedpoint: ReachedFixedPoint,\n+        segment_index: Option<usize>,\n+    ) -> ResolvePathResult {\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n     }\n }\n \n-impl<T> PerNs<T> {\n-    pub fn none() -> PerNs<T> {\n-        PerNs { types: None, values: None }\n-    }\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ResolveMode {\n+    Import,\n+    Other,\n+}\n \n-    pub fn values(t: T) -> PerNs<T> {\n-        PerNs { types: None, values: Some(t) }\n-    }\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ReachedFixedPoint {\n+    Yes,\n+    No,\n+}\n \n-    pub fn types(t: T) -> PerNs<T> {\n-        PerNs { types: Some(t), values: None }\n+impl CrateDefMap {\n+    pub(crate) fn crate_def_map_query(\n+        db: &impl PersistentHirDatabase,\n+        krate: Crate,\n+    ) -> Arc<CrateDefMap> {\n+        let def_map = {\n+            let edition = krate.edition(db);\n+            let mut modules: Arena<ModuleId, ModuleData> = Arena::default();\n+            let root = modules.alloc(ModuleData::default());\n+            CrateDefMap {\n+                krate,\n+                edition,\n+                extern_prelude: FxHashMap::default(),\n+                prelude: None,\n+                root,\n+                modules,\n+                public_macros: FxHashMap::default(),\n+                problems: CrateDefMapProblems::default(),\n+            }\n+        };\n+        let def_map = collector::collect_defs(db, def_map);\n+        Arc::new(def_map)\n     }\n \n-    pub fn both(types: T, values: T) -> PerNs<T> {\n-        PerNs { types: Some(types), values: Some(values) }\n+    pub(crate) fn root(&self) -> ModuleId {\n+        self.root\n     }\n \n-    pub fn is_none(&self) -> bool {\n-        self.types.is_none() && self.values.is_none()\n+    pub(crate) fn problems(&self) -> &CrateDefMapProblems {\n+        &self.problems\n     }\n \n-    pub fn is_both(&self) -> bool {\n-        self.types.is_some() && self.values.is_some()\n+    pub(crate) fn mk_module(&self, module_id: ModuleId) -> Module {\n+        Module { krate: self.krate, module_id }\n     }\n \n-    pub fn take(self, namespace: Namespace) -> Option<T> {\n-        match namespace {\n-            Namespace::Types => self.types,\n-            Namespace::Values => self.values,\n-        }\n+    pub(crate) fn prelude(&self) -> Option<Module> {\n+        self.prelude\n     }\n \n-    pub fn take_types(self) -> Option<T> {\n-        self.take(Namespace::Types)\n+    pub(crate) fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDef> {\n+        &self.extern_prelude\n     }\n \n-    pub fn take_values(self) -> Option<T> {\n-        self.take(Namespace::Values)\n+    pub(crate) fn find_module_by_source(\n+        &self,\n+        file_id: HirFileId,\n+        decl_id: Option<SourceFileItemId>,\n+    ) -> Option<ModuleId> {\n+        let decl_id = decl_id.map(|it| it.with_file_id(file_id));\n+        let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n+            if decl_id.is_some() {\n+                module_data.declaration == decl_id\n+            } else {\n+                module_data.definition.map(|it| it.into()) == Some(file_id)\n+            }\n+        })?;\n+        Some(module_id)\n     }\n \n-    pub fn get(&self, namespace: Namespace) -> Option<&T> {\n-        self.as_ref().take(namespace)\n+    pub(crate) fn resolve_path(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        original_module: ModuleId,\n+        path: &Path,\n+    ) -> (PerNs<ModuleDef>, Option<usize>) {\n+        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n+        (res.resolved_def, res.segment_index)\n     }\n \n-    pub fn as_ref(&self) -> PerNs<&T> {\n-        PerNs { types: self.types.as_ref(), values: self.values.as_ref() }\n-    }\n+    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n+    // the result.\n+    fn resolve_path_fp(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        mode: ResolveMode,\n+        original_module: ModuleId,\n+        path: &Path,\n+    ) -> ResolvePathResult {\n+        let mut segments = path.segments.iter().enumerate();\n+        let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n+            PathKind::Crate => {\n+                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+            }\n+            PathKind::Self_ => {\n+                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n+            }\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // TODO there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+            }\n+            PathKind::Plain => {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in module\", segment);\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n+            }\n+            PathKind::Super => {\n+                if let Some(p) = self.modules[original_module].parent {\n+                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                }\n+            }\n+            PathKind::Abs => {\n+                // 2018-style absolute path -- only extern prelude\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n+                    PerNs::types(*def)\n+                } else {\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                }\n+            }\n+        };\n \n-    pub fn or(self, other: PerNs<T>) -> PerNs<T> {\n-        PerNs { types: self.types.or(other.types), values: self.values.or(other.values) }\n-    }\n+        for (i, segment) in segments {\n+            let curr = match curr_per_ns.as_ref().take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because `curr_per_ns` might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                }\n+            };\n+            // resolve segment in curr\n \n-    pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n-        PerNs { types: self.types.and_then(&f), values: self.values.and_then(&f) }\n-    }\n+            curr_per_ns = match curr {\n+                ModuleDef::Module(module) => {\n+                    if module.krate != self.krate {\n+                        let path = Path {\n+                            segments: path.segments[i..].iter().cloned().collect(),\n+                            kind: PathKind::Self_,\n+                        };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let defp_map = db.crate_def_map(module.krate);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        return ResolvePathResult::with(\n+                            def,\n+                            ReachedFixedPoint::Yes,\n+                            s.map(|s| s + i),\n+                        );\n+                    }\n \n-    pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n-        PerNs { types: self.types.map(&f), values: self.values.map(&f) }\n+                    match self[module.module_id].scope.items.get(&segment.name) {\n+                        Some(res) if !res.def.is_none() => res.def,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                        }\n+                    }\n+                }\n+                ModuleDef::Enum(e) => {\n+                    // enum variant\n+                    tested_by!(can_import_enum_variant);\n+                    match e.variant(db, &segment.name) {\n+                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types((*e).into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n+                    }\n+                }\n+                s => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated item\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types((*s).into()),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n+                }\n+            };\n+        }\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n-}\n \n-#[derive(Debug, Clone)]\n-struct ResolvePathResult {\n-    resolved_def: PerNs<ModuleDef>,\n-    segment_index: Option<usize>,\n-    reached_fixedpoint: ReachedFixedPoint,\n-}\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        let from_crate_root =\n+            self[self.root].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n-impl ResolvePathResult {\n-    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+        from_crate_root.or(from_extern_prelude)\n     }\n \n-    fn with(\n-        resolved_def: PerNs<ModuleDef>,\n-        reached_fixedpoint: ReachedFixedPoint,\n-        segment_index: Option<usize>,\n-    ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+    pub(crate) fn resolve_name_in_module(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        module: ModuleId,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        // Resolve in:\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n+        let from_scope = self[module].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, name);\n+\n+        from_scope.or(from_extern_prelude).or(from_prelude)\n     }\n-}\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ResolveMode {\n-    Import,\n-    Other,\n-}\n+    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ReachedFixedPoint {\n-    Yes,\n-    No,\n+    fn resolve_in_prelude(&self, db: &impl PersistentHirDatabase, name: &Name) -> PerNs<ModuleDef> {\n+        if let Some(prelude) = self.prelude {\n+            let resolution = if prelude.krate == self.krate {\n+                self[prelude.module_id].scope.items.get(name).cloned()\n+            } else {\n+                db.crate_def_map(prelude.krate)[prelude.module_id].scope.items.get(name).cloned()\n+            };\n+            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n }"}, {"sha": "cbe850ba449ac50e2c0ae1f8631734c3e4af866c", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -8,11 +8,11 @@ use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n     PersistentHirDatabase, HirFileId, Name, Path, Problem,\n     KnownName,\n-    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode},\n+    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode, raw},\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n };\n \n-use super::{CrateDefMap, ModuleId, ModuleData, raw};\n+use super::{CrateDefMap, ModuleId, ModuleData};\n \n pub(super) fn collect_defs(\n     db: &impl PersistentHirDatabase,", "previous_filename": "crates/ra_hir/src/nameres/crate_def_map/collector.rs"}, {"sha": "cc4955053567da50cedeba25a4364b81b477f8a6", "filename": "crates/ra_hir/src/nameres/crate_def_map.rs", "status": "removed", "additions": 0, "deletions": 368, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/d4449945a069d26035afe9d8627414f6dfc8bf0a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4449945a069d26035afe9d8627414f6dfc8bf0a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs?ref=d4449945a069d26035afe9d8627414f6dfc8bf0a", "patch": "@@ -1,368 +0,0 @@\n-/// This module implements new import-resolution/macro expansion algorithm.\n-///\n-/// The result of this module is `CrateDefMap`: a datastructure which contains:\n-///\n-///   * a tree of modules for the crate\n-///   * for each module, a set of items visible in the module (directly declared\n-///     or imported)\n-///\n-/// Note that `CrateDefMap` contains fully macro expanded code.\n-///\n-/// Computing `CrateDefMap` can be partitioned into several logically\n-/// independent \"phases\". The phases are mutually recursive though, there's no\n-/// stric ordering.\n-///\n-/// ## Collecting RawItems\n-///\n-///  This happens in the `raw` module, which parses a single source file into a\n-///  set of top-level items. Nested importa are desugared to flat imports in\n-///  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n-///  TokenTree).\n-///\n-/// ## Collecting Modules\n-///\n-/// This happens in the `collector` module. In this phase, we recursively walk\n-/// tree of modules, collect raw items from submodules, populate module scopes\n-/// with defined items (so, we assign item ids in this phase) and record the set\n-/// of unresovled imports and macros.\n-///\n-/// While we walk tree of modules, we also record macro_rules defenitions and\n-/// expand calls to macro_rules defined macros.\n-///\n-/// ## Resolving Imports\n-///\n-/// TBD\n-///\n-/// ## Resolving Macros\n-///\n-/// While macro_rules from the same crate use a global mutable namespace, macros\n-/// from other crates (including proc-macros) can be used with `foo::bar!`\n-/// syntax.\n-///\n-/// TBD;\n-\n-mod raw;\n-mod collector;\n-#[cfg(test)]\n-mod tests;\n-\n-use rustc_hash::FxHashMap;\n-use test_utils::tested_by;\n-use ra_arena::{Arena, RawId, impl_arena_id};\n-use ra_db::FileId;\n-\n-use std::sync::Arc;\n-\n-use crate::{\n-    Name, Module, Path, PathKind, ModuleDef, Crate, Problem, HirFileId,\n-    PersistentHirDatabase,\n-    nameres::{ModuleScope, ResolveMode, ResolvePathResult, PerNs, Edition, ReachedFixedPoint},\n-    ids::{SourceItemId, SourceFileItemId},\n-};\n-\n-pub(crate) use self::raw::RawItems;\n-\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleData {\n-    pub(crate) parent: Option<ModuleId>,\n-    pub(crate) children: FxHashMap<Name, ModuleId>,\n-    pub(crate) scope: ModuleScope,\n-    /// None for root\n-    pub(crate) declaration: Option<SourceItemId>,\n-    /// None for inline modules.\n-    ///\n-    /// Note that non-inline modules, by definition, live inside non-macro file.\n-    pub(crate) definition: Option<FileId>,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct ModuleId(RawId);\n-impl_arena_id!(ModuleId);\n-\n-/// Contans all top-level defs from a macro-expanded crate\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct CrateDefMap {\n-    krate: Crate,\n-    edition: Edition,\n-    /// The prelude module for this crate. This either comes from an import\n-    /// marked with the `prelude_import` attribute, or (in the normal case) from\n-    /// a dependency (`std` or `core`).\n-    prelude: Option<Module>,\n-    extern_prelude: FxHashMap<Name, ModuleDef>,\n-    root: ModuleId,\n-    modules: Arena<ModuleId, ModuleData>,\n-    public_macros: FxHashMap<Name, mbe::MacroRules>,\n-    problems: CrateDefMapProblems,\n-}\n-\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct CrateDefMapProblems {\n-    problems: Vec<(SourceItemId, Problem)>,\n-}\n-\n-impl CrateDefMapProblems {\n-    fn add(&mut self, source_item_id: SourceItemId, problem: Problem) {\n-        self.problems.push((source_item_id, problem))\n-    }\n-\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (&'a SourceItemId, &'a Problem)> + 'a {\n-        self.problems.iter().map(|(s, p)| (s, p))\n-    }\n-}\n-\n-impl std::ops::Index<ModuleId> for CrateDefMap {\n-    type Output = ModuleData;\n-    fn index(&self, id: ModuleId) -> &ModuleData {\n-        &self.modules[id]\n-    }\n-}\n-\n-impl CrateDefMap {\n-    pub(crate) fn crate_def_map_query(\n-        db: &impl PersistentHirDatabase,\n-        krate: Crate,\n-    ) -> Arc<CrateDefMap> {\n-        let def_map = {\n-            let edition = krate.edition(db);\n-            let mut modules: Arena<ModuleId, ModuleData> = Arena::default();\n-            let root = modules.alloc(ModuleData::default());\n-            CrateDefMap {\n-                krate,\n-                edition,\n-                extern_prelude: FxHashMap::default(),\n-                prelude: None,\n-                root,\n-                modules,\n-                public_macros: FxHashMap::default(),\n-                problems: CrateDefMapProblems::default(),\n-            }\n-        };\n-        let def_map = collector::collect_defs(db, def_map);\n-        Arc::new(def_map)\n-    }\n-\n-    pub(crate) fn root(&self) -> ModuleId {\n-        self.root\n-    }\n-\n-    pub(crate) fn problems(&self) -> &CrateDefMapProblems {\n-        &self.problems\n-    }\n-\n-    pub(crate) fn mk_module(&self, module_id: ModuleId) -> Module {\n-        Module { krate: self.krate, module_id }\n-    }\n-\n-    pub(crate) fn prelude(&self) -> Option<Module> {\n-        self.prelude\n-    }\n-\n-    pub(crate) fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDef> {\n-        &self.extern_prelude\n-    }\n-\n-    pub(crate) fn find_module_by_source(\n-        &self,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> Option<ModuleId> {\n-        let decl_id = decl_id.map(|it| it.with_file_id(file_id));\n-        let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n-            if decl_id.is_some() {\n-                module_data.declaration == decl_id\n-            } else {\n-                module_data.definition.map(|it| it.into()) == Some(file_id)\n-            }\n-        })?;\n-        Some(module_id)\n-    }\n-\n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        original_module: ModuleId,\n-        path: &Path,\n-    ) -> (PerNs<ModuleDef>, Option<usize>) {\n-        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n-        (res.resolved_def, res.segment_index)\n-    }\n-\n-    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n-    // the result.\n-    fn resolve_path_fp(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        mode: ResolveMode,\n-        original_module: ModuleId,\n-        path: &Path,\n-    ) -> ResolvePathResult {\n-        let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n-            PathKind::Crate => {\n-                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n-            }\n-            PathKind::Self_ => {\n-                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n-            }\n-            // plain import or absolute path in 2015: crate-relative with\n-            // fallback to extern prelude (with the simplification in\n-            // rust-lang/rust#57745)\n-            // TODO there must be a nicer way to write this condition\n-            PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n-                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n-            {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n-            }\n-            PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n-            }\n-            PathKind::Super => {\n-                if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n-                } else {\n-                    log::debug!(\"super path in root module\");\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-                }\n-            }\n-            PathKind::Abs => {\n-                // 2018-style absolute path -- only extern prelude\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n-                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n-                } else {\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n-                }\n-            }\n-        };\n-\n-        for (i, segment) in segments {\n-            let curr = match curr_per_ns.as_ref().take_types() {\n-                Some(r) => r,\n-                None => {\n-                    // we still have path segments left, but the path so far\n-                    // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because `curr_per_ns` might contain\n-                    // something in the value namespace, and it would be wrong\n-                    // to return that)\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                }\n-            };\n-            // resolve segment in curr\n-\n-            curr_per_ns = match curr {\n-                ModuleDef::Module(module) => {\n-                    if module.krate != self.krate {\n-                        let path = Path {\n-                            segments: path.segments[i..].iter().cloned().collect(),\n-                            kind: PathKind::Self_,\n-                        };\n-                        log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n-                        return ResolvePathResult::with(\n-                            def,\n-                            ReachedFixedPoint::Yes,\n-                            s.map(|s| s + i),\n-                        );\n-                    }\n-\n-                    match self[module.module_id].scope.items.get(&segment.name) {\n-                        Some(res) if !res.def.is_none() => res.def,\n-                        _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                        }\n-                    }\n-                }\n-                ModuleDef::Enum(e) => {\n-                    // enum variant\n-                    tested_by!(can_import_enum_variant);\n-                    match e.variant(db, &segment.name) {\n-                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n-                        None => {\n-                            return ResolvePathResult::with(\n-                                PerNs::types((*e).into()),\n-                                ReachedFixedPoint::Yes,\n-                                Some(i),\n-                            );\n-                        }\n-                    }\n-                }\n-                s => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated item\n-                    log::debug!(\n-                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n-                        curr,\n-                    );\n-\n-                    return ResolvePathResult::with(\n-                        PerNs::types((*s).into()),\n-                        ReachedFixedPoint::Yes,\n-                        Some(i),\n-                    );\n-                }\n-            };\n-        }\n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n-    }\n-\n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n-        let from_crate_root =\n-            self[self.root].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n-\n-        from_crate_root.or(from_extern_prelude)\n-    }\n-\n-    pub(crate) fn resolve_name_in_module(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        module: ModuleId,\n-        name: &Name,\n-    ) -> PerNs<ModuleDef> {\n-        // Resolve in:\n-        //  - current module / scope\n-        //  - extern prelude\n-        //  - std prelude\n-        let from_scope = self[module].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, name);\n-\n-        from_scope.or(from_extern_prelude).or(from_prelude)\n-    }\n-\n-    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n-    }\n-\n-    fn resolve_in_prelude(&self, db: &impl PersistentHirDatabase, name: &Name) -> PerNs<ModuleDef> {\n-        if let Some(prelude) = self.prelude {\n-            let resolution = if prelude.krate == self.krate {\n-                self[prelude.module_id].scope.items.get(name).cloned()\n-            } else {\n-                db.crate_def_map(prelude.krate)[prelude.module_id].scope.items.get(name).cloned()\n-            };\n-            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n-        } else {\n-            PerNs::none()\n-        }\n-    }\n-}"}, {"sha": "d4c7f24814e8cccfebc329fbe4783bd1bba96c0f", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d4449945a069d26035afe9d8627414f6dfc8bf0a/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4449945a069d26035afe9d8627414f6dfc8bf0a/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=d4449945a069d26035afe9d8627414f6dfc8bf0a", "patch": "@@ -1,40 +0,0 @@\n-use ra_syntax::{\n-    AstNode, SourceFile, TreeArc, AstPtr,\n-    ast,\n-};\n-use ra_arena::{RawId, impl_arena_id, map::ArenaMap};\n-\n-use crate::{Path, ModuleSource, Name};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ImportId(RawId);\n-impl_arena_id!(ImportId);\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImportData {\n-    pub(super) path: Path,\n-    pub(super) alias: Option<Name>,\n-    pub(super) is_glob: bool,\n-    pub(super) is_prelude: bool,\n-    pub(super) is_extern_crate: bool,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ImportSourceMap {\n-    map: ArenaMap<ImportId, AstPtr<ast::PathSegment>>,\n-}\n-\n-impl ImportSourceMap {\n-    pub(crate) fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n-        self.map.insert(import, AstPtr::new(segment))\n-    }\n-\n-    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n-        let file = match source {\n-            ModuleSource::SourceFile(file) => &*file,\n-            ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n-        };\n-\n-        self.map[import].to_node(file).to_owned()\n-    }\n-}"}, {"sha": "c40a3ff9d934cb4e205cb29eab697f64588ea56b", "filename": "crates/ra_hir/src/nameres/per_ns.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -0,0 +1,78 @@\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Namespace {\n+    Types,\n+    Values,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct PerNs<T> {\n+    pub types: Option<T>,\n+    pub values: Option<T>,\n+}\n+\n+impl<T> Default for PerNs<T> {\n+    fn default() -> Self {\n+        PerNs { types: None, values: None }\n+    }\n+}\n+\n+impl<T> PerNs<T> {\n+    pub fn none() -> PerNs<T> {\n+        PerNs { types: None, values: None }\n+    }\n+\n+    pub fn values(t: T) -> PerNs<T> {\n+        PerNs { types: None, values: Some(t) }\n+    }\n+\n+    pub fn types(t: T) -> PerNs<T> {\n+        PerNs { types: Some(t), values: None }\n+    }\n+\n+    pub fn both(types: T, values: T) -> PerNs<T> {\n+        PerNs { types: Some(types), values: Some(values) }\n+    }\n+\n+    pub fn is_none(&self) -> bool {\n+        self.types.is_none() && self.values.is_none()\n+    }\n+\n+    pub fn is_both(&self) -> bool {\n+        self.types.is_some() && self.values.is_some()\n+    }\n+\n+    pub fn take(self, namespace: Namespace) -> Option<T> {\n+        match namespace {\n+            Namespace::Types => self.types,\n+            Namespace::Values => self.values,\n+        }\n+    }\n+\n+    pub fn take_types(self) -> Option<T> {\n+        self.take(Namespace::Types)\n+    }\n+\n+    pub fn take_values(self) -> Option<T> {\n+        self.take(Namespace::Values)\n+    }\n+\n+    pub fn get(&self, namespace: Namespace) -> Option<&T> {\n+        self.as_ref().take(namespace)\n+    }\n+\n+    pub fn as_ref(&self) -> PerNs<&T> {\n+        PerNs { types: self.types.as_ref(), values: self.values.as_ref() }\n+    }\n+\n+    pub fn or(self, other: PerNs<T>) -> PerNs<T> {\n+        PerNs { types: self.types.or(other.types), values: self.values.or(other.values) }\n+    }\n+\n+    pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n+        PerNs { types: self.types.and_then(&f), values: self.values.and_then(&f) }\n+    }\n+\n+    pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n+        PerNs { types: self.types.map(&f), values: self.values.map(&f) }\n+    }\n+}"}, {"sha": "3226bbf0dfff3d21fa0487aa978edeebd8e1a94f", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "renamed", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -5,16 +5,15 @@ use std::{\n \n use test_utils::tested_by;\n use ra_db::FileId;\n-use ra_arena::{Arena, impl_arena_id, RawId};\n+use ra_arena::{Arena, impl_arena_id, RawId, map::ArenaMap};\n use ra_syntax::{\n-    AstNode, SourceFile,\n+    AstNode, SourceFile, AstPtr, TreeArc,\n     ast::{self, NameOwner, AttrsOwner},\n };\n \n use crate::{\n-    PersistentHirDatabase, Name, AsName, Path, HirFileId,\n+    PersistentHirDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n     ids::{SourceFileItemId, SourceFileItems},\n-    nameres::lower::ImportSourceMap,\n };\n \n #[derive(Debug, Default, PartialEq, Eq)]\n@@ -27,6 +26,26 @@ pub struct RawItems {\n     items: Vec<RawItem>,\n }\n \n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct ImportSourceMap {\n+    map: ArenaMap<ImportId, AstPtr<ast::PathSegment>>,\n+}\n+\n+impl ImportSourceMap {\n+    pub(crate) fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n+        self.map.insert(import, AstPtr::new(segment))\n+    }\n+\n+    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n+        let file = match source {\n+            ModuleSource::SourceFile(file) => &*file,\n+            ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n+        };\n+\n+        self.map[import].to_node(file).to_owned()\n+    }\n+}\n+\n impl RawItems {\n     pub(crate) fn raw_items_query(\n         db: &impl PersistentHirDatabase,\n@@ -113,8 +132,18 @@ pub(crate) enum ModuleData {\n     Definition { name: Name, source_item_id: SourceFileItemId, items: Vec<RawItem> },\n }\n \n-pub(crate) use crate::nameres::lower::ImportId;\n-pub(super) use crate::nameres::lower::ImportData;\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ImportId(RawId);\n+impl_arena_id!(ImportId);\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImportData {\n+    pub(crate) path: Path,\n+    pub(crate) alias: Option<Name>,\n+    pub(crate) is_glob: bool,\n+    pub(crate) is_prelude: bool,\n+    pub(crate) is_extern_crate: bool,\n+}\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct Def(RawId);", "previous_filename": "crates/ra_hir/src/nameres/crate_def_map/raw.rs"}, {"sha": "36c1d74ceaf25948001bfc2b4e50ce682673cf23", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "previous_filename": "crates/ra_hir/src/nameres/crate_def_map/tests.rs"}, {"sha": "6e50c7ff6e931b1e0b4f480bd0609a02983f950c", "filename": "crates/ra_hir/src/nameres/tests/globs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "previous_filename": "crates/ra_hir/src/nameres/crate_def_map/tests/globs.rs"}, {"sha": "6987819233bdfda886741c3f441d6338dada1d2b", "filename": "crates/ra_hir/src/nameres/tests/incremental.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "previous_filename": "crates/ra_hir/src/nameres/crate_def_map/tests/incremental.rs"}, {"sha": "8781b026b6fb3ef1294a5a8013daa5b4442e6ae5", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "previous_filename": "crates/ra_hir/src/nameres/crate_def_map/tests/macros.rs"}, {"sha": "1adf9eef94e4dbaaa9363c4bb484055624bd22b9", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967a4b64af2f09e11108d28f11565fa0f3e583a5/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=967a4b64af2f09e11108d28f11565fa0f3e583a5", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{AdtDef, Ty},\n-    nameres::crate_def_map::ModuleId,\n+    nameres::ModuleId,\n \n };\n "}]}