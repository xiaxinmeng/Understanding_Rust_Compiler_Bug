{"sha": "0bd2232fe4a474af108666bdeb24c44b9e10669a", "node_id": "C_kwDOAAsO6NoAKDBiZDIyMzJmZTRhNDc0YWYxMDg2NjZiZGViMjRjNDRiOWUxMDY2OWE", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-04-17T02:01:17Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-05-05T17:13:00Z"}, "message": "Implement the unused_macro_rules lint", "tree": {"sha": "dc70b9d1a585ada5f37c9f5975301c09cb0df481", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc70b9d1a585ada5f37c9f5975301c09cb0df481"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bd2232fe4a474af108666bdeb24c44b9e10669a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd2232fe4a474af108666bdeb24c44b9e10669a", "html_url": "https://github.com/rust-lang/rust/commit/0bd2232fe4a474af108666bdeb24c44b9e10669a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bd2232fe4a474af108666bdeb24c44b9e10669a/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d43be3ad397b68d4fcf1c5d3d3f4eb3b75ca184", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d43be3ad397b68d4fcf1c5d3d3f4eb3b75ca184", "html_url": "https://github.com/rust-lang/rust/commit/3d43be3ad397b68d4fcf1c5d3d3f4eb3b75ca184"}], "stats": {"total": 166, "additions": 139, "deletions": 27}, "files": [{"sha": "3d28da684d14e3d16e15264e721126e826f3252d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -887,6 +887,8 @@ pub trait ResolverExpand {\n         force: bool,\n     ) -> Result<Lrc<SyntaxExtension>, Indeterminate>;\n \n+    fn record_macro_rule_usage(&mut self, mac_id: NodeId, rule_index: usize);\n+\n     fn check_unused_macros(&mut self);\n \n     // Resolver interfaces for specific built-in macros."}, {"sha": "ba0b35470b6ba5645b84f00b387e701f19dfc478", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -156,13 +156,13 @@ impl<'a> ParserAnyMacro<'a> {\n }\n \n struct MacroRulesMacroExpander {\n+    node_id: NodeId,\n     name: Ident,\n     span: Span,\n     transparency: Transparency,\n     lhses: Vec<Vec<MatcherLoc>>,\n     rhses: Vec<mbe::TokenTree>,\n     valid: bool,\n-    is_local: bool,\n }\n \n impl TTMacroExpander for MacroRulesMacroExpander {\n@@ -179,12 +179,12 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n             cx,\n             sp,\n             self.span,\n+            self.node_id,\n             self.name,\n             self.transparency,\n             input,\n             &self.lhses,\n             &self.rhses,\n-            self.is_local,\n         )\n     }\n }\n@@ -207,14 +207,17 @@ fn generic_extension<'cx, 'tt>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     def_span: Span,\n+    node_id: NodeId,\n     name: Ident,\n     transparency: Transparency,\n     arg: TokenStream,\n     lhses: &'tt [Vec<MatcherLoc>],\n     rhses: &'tt [mbe::TokenTree],\n-    is_local: bool,\n ) -> Box<dyn MacResult + 'cx> {\n     let sess = &cx.sess.parse_sess;\n+    // Macros defined in the current crate have a real node id,\n+    // whereas macros from an external crate have a dummy id.\n+    let is_local = node_id != DUMMY_NODE_ID;\n \n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(&arg));\n@@ -296,6 +299,10 @@ fn generic_extension<'cx, 'tt>(\n                 let mut p = Parser::new(sess, tts, false, None);\n                 p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n \n+                if is_local {\n+                    cx.resolver.record_macro_rule_usage(node_id, i);\n+                }\n+\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return Box::new(ParserAnyMacro {\n@@ -372,7 +379,7 @@ pub fn compile_declarative_macro(\n     features: &Features,\n     def: &ast::Item,\n     edition: Edition,\n-) -> SyntaxExtension {\n+) -> (SyntaxExtension, Vec<Span>) {\n     debug!(\"compile_declarative_macro: {:?}\", def);\n     let mk_syn_ext = |expander| {\n         SyntaxExtension::new(\n@@ -385,6 +392,7 @@ pub fn compile_declarative_macro(\n             &def.attrs,\n         )\n     };\n+    let dummy_syn_ext = || (mk_syn_ext(Box::new(macro_rules_dummy_expander)), Vec::new());\n \n     let diag = &sess.parse_sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n@@ -445,17 +453,17 @@ pub fn compile_declarative_macro(\n             let s = parse_failure_msg(&token);\n             let sp = token.span.substitute_dummy(def.span);\n             sess.parse_sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n-            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+            return dummy_syn_ext();\n         }\n         Error(sp, msg) => {\n             sess.parse_sess\n                 .span_diagnostic\n                 .struct_span_err(sp.substitute_dummy(def.span), &msg)\n                 .emit();\n-            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+            return dummy_syn_ext();\n         }\n         ErrorReported => {\n-            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+            return dummy_syn_ext();\n         }\n     };\n \n@@ -530,6 +538,15 @@ pub fn compile_declarative_macro(\n         None => {}\n     }\n \n+    // Compute the spans of the macro rules\n+    // We only take the span of the lhs here,\n+    // so that the spans of created warnings are smaller.\n+    let rule_spans = if def.id != DUMMY_NODE_ID {\n+        lhses.iter().map(|lhs| lhs.span()).collect::<Vec<_>>()\n+    } else {\n+        Vec::new()\n+    };\n+\n     // Convert the lhses into `MatcherLoc` form, which is better for doing the\n     // actual matching. Unless the matcher is invalid.\n     let lhses = if valid {\n@@ -549,17 +566,16 @@ pub fn compile_declarative_macro(\n         vec![]\n     };\n \n-    mk_syn_ext(Box::new(MacroRulesMacroExpander {\n+    let expander = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         span: def.span,\n+        node_id: def.id,\n         transparency,\n         lhses,\n         rhses,\n         valid,\n-        // Macros defined in the current crate have a real node id,\n-        // whereas macros from an external crate have a dummy id.\n-        is_local: def.id != DUMMY_NODE_ID,\n-    }))\n+    });\n+    (mk_syn_ext(expander), rule_spans)\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree) -> bool {"}, {"sha": "b2178ff59954b620d34e6ca32db5508e9d7489c4", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-test = false\n doctest = false\n \n [dependencies]"}, {"sha": "e68d6fdeea55b310321eae866438d87abe9bab24", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -194,7 +194,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let ext = Lrc::new(match self.cstore().load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(item, edition) => self.compile_macro(&item, edition),\n+            LoadedMacro::MacroDef(item, edition) => self.compile_macro(&item, edition).0,\n             LoadedMacro::ProcMacro(ext) => ext,\n         });\n \n@@ -1218,25 +1218,35 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     // Mark the given macro as unused unless its name starts with `_`.\n     // Macro uses will remove items from this set, and the remaining\n     // items will be reported as `unused_macros`.\n-    fn insert_unused_macro(&mut self, ident: Ident, def_id: LocalDefId, node_id: NodeId) {\n+    fn insert_unused_macro(\n+        &mut self,\n+        ident: Ident,\n+        def_id: LocalDefId,\n+        node_id: NodeId,\n+        rule_spans: &[Span],\n+    ) {\n         if !ident.as_str().starts_with('_') {\n             self.r.unused_macros.insert(def_id, (node_id, ident));\n+            for (rule_i, rule_span) in rule_spans.iter().enumerate() {\n+                self.r.unused_macro_rules.insert((def_id, rule_i), (ident, *rule_span));\n+            }\n         }\n     }\n \n     fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScopeRef<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n         let def_id = self.r.local_def_id(item.id);\n-        let (ext, ident, span, macro_rules) = match &item.kind {\n+        let (ext, ident, span, macro_rules, rule_spans) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n-                let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n-                (ext, item.ident, item.span, def.macro_rules)\n+                let (ext, rule_spans) = self.r.compile_macro(item, self.r.session.edition());\n+                let ext = Lrc::new(ext);\n+                (ext, item.ident, item.span, def.macro_rules, rule_spans)\n             }\n             ItemKind::Fn(..) => match self.proc_macro_stub(item) {\n                 Some((macro_kind, ident, span)) => {\n                     self.r.proc_macro_stubs.insert(def_id);\n-                    (self.r.dummy_ext(macro_kind), ident, span, false)\n+                    (self.r.dummy_ext(macro_kind), ident, span, false, Vec::new())\n                 }\n                 None => return parent_scope.macro_rules,\n             },\n@@ -1264,7 +1274,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));\n             } else {\n                 self.r.check_reserved_macro_name(ident, res);\n-                self.insert_unused_macro(ident, def_id, item.id);\n+                self.insert_unused_macro(ident, def_id, item.id, &rule_spans);\n             }\n             self.r.visibilities.insert(def_id, vis);\n             let scope = self.r.arenas.alloc_macro_rules_scope(MacroRulesScope::Binding(\n@@ -1287,7 +1297,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 _ => self.resolve_visibility(&item.vis),\n             };\n             if vis != ty::Visibility::Public {\n-                self.insert_unused_macro(ident, def_id, item.id);\n+                self.insert_unused_macro(ident, def_id, item.id, &rule_spans);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n             self.r.visibilities.insert(def_id, vis);"}, {"sha": "bffff0dfac511a859669044c90268da97a94e25e", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -35,6 +35,9 @@ use crate::{LexicalScopeBinding, NameBinding, NameBindingKind, PrivacyError, Vis\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet};\n use crate::{Segment, UseError};\n \n+#[cfg(test)]\n+mod tests;\n+\n type Res = def::Res<ast::NodeId>;\n \n /// A vector of spans and replacements, a message and applicability.\n@@ -2663,3 +2666,14 @@ fn is_span_suitable_for_use_injection(s: Span) -> bool {\n     // import or other generated ones\n     !s.from_expansion()\n }\n+\n+/// Convert the given number into the corresponding ordinal\n+crate fn ordinalize(v: usize) -> String {\n+    let suffix = match ((11..=13).contains(&(v % 100)), v % 10) {\n+        (false, 1) => \"st\",\n+        (false, 2) => \"nd\",\n+        (false, 3) => \"rd\",\n+        _ => \"th\",\n+    };\n+    format!(\"{v}{suffix}\")\n+}"}, {"sha": "2aa6cc61e460ad4363f768acc940f22a350d8463", "filename": "compiler/rustc_resolve/src/diagnostics/tests.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics%2Ftests.rs?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -0,0 +1,40 @@\n+use super::ordinalize;\n+\n+#[test]\n+fn test_ordinalize() {\n+    assert_eq!(ordinalize(1), \"1st\");\n+    assert_eq!(ordinalize(2), \"2nd\");\n+    assert_eq!(ordinalize(3), \"3rd\");\n+    assert_eq!(ordinalize(4), \"4th\");\n+    assert_eq!(ordinalize(5), \"5th\");\n+    // ...\n+    assert_eq!(ordinalize(10), \"10th\");\n+    assert_eq!(ordinalize(11), \"11th\");\n+    assert_eq!(ordinalize(12), \"12th\");\n+    assert_eq!(ordinalize(13), \"13th\");\n+    assert_eq!(ordinalize(14), \"14th\");\n+    // ...\n+    assert_eq!(ordinalize(20), \"20th\");\n+    assert_eq!(ordinalize(21), \"21st\");\n+    assert_eq!(ordinalize(22), \"22nd\");\n+    assert_eq!(ordinalize(23), \"23rd\");\n+    assert_eq!(ordinalize(24), \"24th\");\n+    // ...\n+    assert_eq!(ordinalize(30), \"30th\");\n+    assert_eq!(ordinalize(31), \"31st\");\n+    assert_eq!(ordinalize(32), \"32nd\");\n+    assert_eq!(ordinalize(33), \"33rd\");\n+    assert_eq!(ordinalize(34), \"34th\");\n+    // ...\n+    assert_eq!(ordinalize(7010), \"7010th\");\n+    assert_eq!(ordinalize(7011), \"7011th\");\n+    assert_eq!(ordinalize(7012), \"7012th\");\n+    assert_eq!(ordinalize(7013), \"7013th\");\n+    assert_eq!(ordinalize(7014), \"7014th\");\n+    // ...\n+    assert_eq!(ordinalize(7020), \"7020th\");\n+    assert_eq!(ordinalize(7021), \"7021st\");\n+    assert_eq!(ordinalize(7022), \"7022nd\");\n+    assert_eq!(ordinalize(7023), \"7023rd\");\n+    assert_eq!(ordinalize(7024), \"7024th\");\n+}"}, {"sha": "7aa66efc038cceccc278716a5eab5a17bcf30256", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -973,6 +973,7 @@ pub struct Resolver<'a> {\n     local_macro_def_scopes: FxHashMap<LocalDefId, Module<'a>>,\n     ast_transform_scopes: FxHashMap<LocalExpnId, Module<'a>>,\n     unused_macros: FxHashMap<LocalDefId, (NodeId, Ident)>,\n+    unused_macro_rules: FxHashMap<(LocalDefId, usize), (Ident, Span)>,\n     proc_macro_stubs: FxHashSet<LocalDefId>,\n     /// Traces collected during macro resolution and validated when it's complete.\n     single_segment_macro_resolutions:\n@@ -1372,6 +1373,7 @@ impl<'a> Resolver<'a> {\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: Default::default(),\n             unused_macros: Default::default(),\n+            unused_macro_rules: Default::default(),\n             proc_macro_stubs: Default::default(),\n             single_segment_macro_resolutions: Default::default(),\n             multi_segment_macro_resolutions: Default::default(),"}, {"sha": "2337f72f1e8b1c8093909063db84fe818c89fca5", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2232fe4a474af108666bdeb24c44b9e10669a/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=0bd2232fe4a474af108666bdeb24c44b9e10669a", "patch": "@@ -22,7 +22,8 @@ use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{CrateNum, LocalDefId};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::RegisteredTools;\n-use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE, UNUSED_MACROS};\n+use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE};\n+use rustc_session::lint::builtin::{UNUSED_MACROS, UNUSED_MACRO_RULES};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -311,6 +312,11 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         Ok(ext)\n     }\n \n+    fn record_macro_rule_usage(&mut self, id: NodeId, rule_i: usize) {\n+        let did = self.local_def_id(id);\n+        self.unused_macro_rules.remove(&(did, rule_i));\n+    }\n+\n     fn check_unused_macros(&mut self) {\n         for (_, &(node_id, ident)) in self.unused_macros.iter() {\n             self.lint_buffer.buffer_lint(\n@@ -320,6 +326,23 @@ impl<'a> ResolverExpand for Resolver<'a> {\n                 &format!(\"unused macro definition: `{}`\", ident.as_str()),\n             );\n         }\n+        for (&(def_id, arm_i), &(ident, rule_span)) in self.unused_macro_rules.iter() {\n+            if self.unused_macros.contains_key(&def_id) {\n+                // We already lint the entire macro as unused\n+                continue;\n+            }\n+            let node_id = self.def_id_to_node_id[def_id];\n+            self.lint_buffer.buffer_lint(\n+                UNUSED_MACRO_RULES,\n+                node_id,\n+                rule_span,\n+                &format!(\n+                    \"{} rule of macro `{}` is never used\",\n+                    crate::diagnostics::ordinalize(arm_i + 1),\n+                    ident.as_str()\n+                ),\n+            );\n+        }\n     }\n \n     fn has_derive_copy(&self, expn_id: LocalExpnId) -> bool {\n@@ -830,10 +853,15 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// Compile the macro into a `SyntaxExtension` and possibly replace\n-    /// its expander to a pre-defined one for built-in macros.\n-    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n-        let mut result = compile_declarative_macro(\n+    /// Compile the macro into a `SyntaxExtension` and its rule spans.\n+    ///\n+    /// Possibly replace its expander to a pre-defined one for built-in macros.\n+    crate fn compile_macro(\n+        &mut self,\n+        item: &ast::Item,\n+        edition: Edition,\n+    ) -> (SyntaxExtension, Vec<Span>) {\n+        let (mut result, mut rule_spans) = compile_declarative_macro(\n             &self.session,\n             self.session.features_untracked(),\n             item,\n@@ -849,6 +877,7 @@ impl<'a> Resolver<'a> {\n                 match mem::replace(builtin_macro, BuiltinMacroState::AlreadySeen(item.span)) {\n                     BuiltinMacroState::NotYetSeen(ext) => {\n                         result.kind = ext;\n+                        rule_spans = Vec::new();\n                         if item.id != ast::DUMMY_NODE_ID {\n                             self.builtin_macro_kinds\n                                 .insert(self.local_def_id(item.id), result.macro_kind());\n@@ -871,6 +900,6 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        result\n+        (result, rule_spans)\n     }\n }"}]}