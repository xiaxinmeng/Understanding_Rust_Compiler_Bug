{"sha": "4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZTEyOTY1MTE2N2U0YmExYTE2ZDZlZTkzYmMwY2EzOGM3Y2Y3ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T10:52:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T10:52:04Z"}, "message": "auto merge of #10660 : alexcrichton/rust/little-scope, r=pcwalton\n\nThis moves the locking/waiting methods to returning an RAII struct instead of\r\nrelying on closures. Additionally, this changes the methods to all take\r\n'&mut self' to discourage recursive locking. The new method to block is to call\r\n`wait` on the returned RAII structure instead of calling it on the lock itself\r\n(this enforces that the lock is held).\r\n\r\nAt the same time, this improves the Mutex interface a bit by allowing\r\ndestruction of non-initialized members and by allowing construction of an empty\r\nmutex (nothing initialized inside).", "tree": {"sha": "96637056faae22b8e417b327d8de942ce1c75d65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96637056faae22b8e417b327d8de942ce1c75d65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "html_url": "https://github.com/rust-lang/rust/commit/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21990cdda624f5eee340311b7f8e542ab8a218e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/21990cdda624f5eee340311b7f8e542ab8a218e1", "html_url": "https://github.com/rust-lang/rust/commit/21990cdda624f5eee340311b7f8e542ab8a218e1"}, {"sha": "ac59888d8f466522a9802ee7d33134505794ee12", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac59888d8f466522a9802ee7d33134505794ee12", "html_url": "https://github.com/rust-lang/rust/commit/ac59888d8f466522a9802ee7d33134505794ee12"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "ff46824d82359cb2e9ecaaaf31df6ef1837dd9e0", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "patch": "@@ -70,6 +70,15 @@ impl Mutex {\n         }\n     }\n \n+    /// Creates a new mutex, with the lock/condition variable not initialized.\n+    /// This is the same as initializing from the MUTEX_INIT static.\n+    pub unsafe fn empty() -> Mutex {\n+        Mutex {\n+            lock: atomics::AtomicUint::new(0),\n+            cond: atomics::AtomicUint::new(0),\n+        }\n+    }\n+\n     /// Creates a new copy of this mutex. This is an unsafe operation because\n     /// there is no reference counting performed on this type.\n     ///\n@@ -117,8 +126,10 @@ impl Mutex {\n     /// that no other thread is currently holding the lock or waiting on the\n     /// condition variable contained inside.\n     pub unsafe fn destroy(&mut self) {\n-        imp::free_lock(self.lock.swap(0, atomics::Relaxed));\n-        imp::free_cond(self.cond.swap(0, atomics::Relaxed));\n+        let lock = self.lock.swap(0, atomics::Relaxed);\n+        let cond = self.cond.swap(0, atomics::Relaxed);\n+        if lock != 0 { imp::free_lock(lock) }\n+        if cond != 0 { imp::free_cond(cond) }\n     }\n \n     unsafe fn getlock(&mut self) -> *c_void {\n@@ -333,4 +344,12 @@ mod test {\n             t.join();\n         }\n     }\n+\n+    #[test]\n+    fn destroy_immediately() {\n+        unsafe {\n+            let mut m = Mutex::empty();\n+            m.destroy();\n+        }\n+    }\n }"}, {"sha": "e80b58d01efb2acebb2b4180f90cd45669f519cb", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 50, "deletions": 69, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "patch": "@@ -319,67 +319,49 @@ pub struct LittleLock {\n     priv l: Mutex,\n }\n \n+pub struct LittleGuard<'a> {\n+    priv l: &'a mut Mutex,\n+}\n+\n impl Drop for LittleLock {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.l.destroy();\n-        }\n+        unsafe { self.l.destroy(); }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for LittleGuard<'a> {\n+    fn drop(&mut self) {\n+        unsafe { self.l.unlock(); }\n     }\n }\n \n impl LittleLock {\n     pub fn new() -> LittleLock {\n-        unsafe {\n-            LittleLock {\n-                l: Mutex::new()\n-            }\n-        }\n+        unsafe { LittleLock { l: Mutex::new() } }\n     }\n \n-    pub unsafe fn lock<T>(&self, f: || -> T) -> T {\n-        let this = cast::transmute_mut(self);\n-        do atomically {\n-            this.l.lock();\n-            do (|| {\n-                f()\n-            }).finally {\n-                this.l.unlock();\n-            }\n-        }\n+    pub unsafe fn lock<'a>(&'a mut self) -> LittleGuard<'a> {\n+        self.l.lock();\n+        LittleGuard { l: &mut self.l }\n     }\n \n-    pub unsafe fn try_lock<T>(&self, f: || -> T) -> Option<T> {\n-        let this = cast::transmute_mut(self);\n-        do atomically {\n-            if this.l.trylock() {\n-                Some(do (|| {\n-                    f()\n-                }).finally {\n-                    this.l.unlock();\n-                })\n-            } else {\n-                None\n-            }\n+    pub unsafe fn try_lock<'a>(&'a mut self) -> Option<LittleGuard<'a>> {\n+        if self.l.trylock() {\n+            Some(LittleGuard { l: &mut self.l })\n+        } else {\n+            None\n         }\n     }\n \n-    pub unsafe fn signal(&self) {\n-        let this = cast::transmute_mut(self);\n-        this.l.signal();\n+    pub unsafe fn signal(&mut self) {\n+        self.l.signal();\n     }\n+}\n \n-    pub unsafe fn lock_and_wait(&self, f: || -> bool) {\n-        let this = cast::transmute_mut(self);\n-        do atomically {\n-            this.l.lock();\n-            do (|| {\n-                if f() {\n-                    this.l.wait();\n-                }\n-            }).finally {\n-                this.l.unlock();\n-            }\n-        }\n+impl<'a> LittleGuard<'a> {\n+    pub unsafe fn wait(&mut self) {\n+        self.l.wait();\n     }\n }\n \n@@ -431,15 +413,14 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U {\n         let rec = self.x.get();\n-        do (*rec).lock.lock {\n-            if (*rec).failed {\n-                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            let result = f(&mut (*rec).data);\n-            (*rec).failed = false;\n-            result\n+        let _l = (*rec).lock.lock();\n+        if (*rec).failed {\n+            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n+        (*rec).failed = true;\n+        let result = f(&mut (*rec).data);\n+        (*rec).failed = false;\n+        result\n     }\n \n     #[inline]\n@@ -452,28 +433,28 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n-        do (*rec).lock.lock {\n-            if (*rec).failed {\n-                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            f(&mut (*rec).data);\n-            (*rec).failed = false;\n-            (*rec).lock.signal();\n+        let _l = (*rec).lock.lock();\n+        if (*rec).failed {\n+            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n+        (*rec).failed = true;\n+        f(&mut (*rec).data);\n+        (*rec).failed = false;\n+        (*rec).lock.signal();\n     }\n \n     #[inline]\n     pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n         let rec = self.x.get();\n-        do (*rec).lock.lock_and_wait {\n-            if (*rec).failed {\n-                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            let result = f(&(*rec).data);\n-            (*rec).failed = false;\n-            result\n+        let mut l = (*rec).lock.lock();\n+        if (*rec).failed {\n+            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n+        }\n+        (*rec).failed = true;\n+        let result = f(&(*rec).data);\n+        (*rec).failed = false;\n+        if result {\n+            l.wait();\n         }\n     }\n "}]}