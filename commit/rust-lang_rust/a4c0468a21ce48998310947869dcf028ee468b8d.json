{"sha": "a4c0468a21ce48998310947869dcf028ee468b8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YzA0NjhhMjFjZTQ4OTk4MzEwOTQ3ODY5ZGNmMDI4ZWU0NjhiOGQ=", "commit": {"author": {"name": "Andrew Poelstra", "email": "asp11@sfu.ca", "date": "2014-06-24T00:35:43Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T19:34:19Z"}, "message": "collections::bitv: implement BitvSet directly as a Bitv", "tree": {"sha": "de03ebd9c37cd6d946e66ad257713571737d63d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de03ebd9c37cd6d946e66ad257713571737d63d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4c0468a21ce48998310947869dcf028ee468b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4c0468a21ce48998310947869dcf028ee468b8d", "html_url": "https://github.com/rust-lang/rust/commit/a4c0468a21ce48998310947869dcf028ee468b8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4c0468a21ce48998310947869dcf028ee468b8d/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f728ad0134fc87e0751a6a09022f4ab176dfc191", "url": "https://api.github.com/repos/rust-lang/rust/commits/f728ad0134fc87e0751a6a09022f4ab176dfc191", "html_url": "https://github.com/rust-lang/rust/commit/f728ad0134fc87e0751a6a09022f4ab176dfc191"}], "stats": {"total": 245, "additions": 143, "deletions": 102}, "files": [{"sha": "59ad188b530c1e911f77f5dc98837f01dc4c236f", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 143, "deletions": 102, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/a4c0468a21ce48998310947869dcf028ee468b8d/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4c0468a21ce48998310947869dcf028ee468b8d/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=a4c0468a21ce48998310947869dcf028ee468b8d", "patch": "@@ -15,7 +15,8 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Enumerate, Repeat, Map, Zip};\n+use core::iter::{Map, Zip};\n+use core::option;\n use core::ops;\n use core::slice;\n use core::uint;\n@@ -268,6 +269,33 @@ fn die() -> ! {\n     fail!(\"Tried to do operation on bit vectors with different sizes\");\n }\n \n+enum WordsVariant<'a> {\n+    NoneIter,\n+    OneIter(option::Item<uint>),\n+    VecIter(slice::Items<'a, uint>)\n+}\n+\n+struct Words<'a> {\n+    rep: WordsVariant<'a>,\n+    offset: uint\n+}\n+\n+impl<'a> Iterator<(uint, uint)> for Words<'a> {\n+    /// Returns (offset, word)\n+    fn next<'a>(&'a mut self) -> Option<(uint, uint)> {\n+        let ret = match self.rep {\n+            NoneIter => None,\n+            OneIter(ref mut it) => it.next(),\n+            VecIter(ref mut it) => it.next().map(|n| *n)\n+        };\n+        self.offset += 1;\n+        match ret {\n+            Some(n) => Some((self.offset - 1, n)),\n+            None => None\n+        }\n+    }\n+}\n+\n impl Bitv {\n     #[inline]\n     fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n@@ -295,6 +323,18 @@ impl Bitv {\n           }\n         }\n     }\n+\n+    #[inline]\n+    fn words<'a>(&'a self, start: uint) -> Words<'a> {\n+        Words {\n+          rep: match self.rep {\n+              Small(_) if start > 0 => NoneIter,\n+              Small(ref s) => OneIter(Some(s.bits).move_iter()),\n+              Big(ref b) => VecIter(b.storage.slice_from(start).iter())\n+          },\n+          offset: start\n+        }\n+    }\n }\n \n impl Bitv {\n@@ -687,15 +727,8 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n /// as a `uint`.\n-#[deriving(Clone)]\n-pub struct BitvSet {\n-    size: uint,\n-\n-    // In theory this is a `Bitv` instead of always a `BigBitv`, but knowing that\n-    // there's an array of storage makes our lives a whole lot easier when\n-    // performing union/intersection/etc operations\n-    bitv: BigBitv\n-}\n+#[deriving(Clone, PartialEq, Eq)]\n+pub struct BitvSet(Bitv);\n \n impl Default for BitvSet {\n     #[inline]\n@@ -705,56 +738,87 @@ impl Default for BitvSet {\n impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n     pub fn new() -> BitvSet {\n-        BitvSet{ size: 0, bitv: BigBitv::new(vec!(0)) }\n+        BitvSet(Bitv::new(0, false))\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n-        let mut size = 0;\n-        bitv.ones(|_| {\n-            size += 1;\n-            true\n-        });\n-        let Bitv{rep, ..} = bitv;\n-        match rep {\n-            Big(b) => BitvSet{ size: size, bitv: b },\n-            Small(SmallBitv{bits}) =>\n-                BitvSet{ size: size, bitv: BigBitv{ storage: vec!(bits) } },\n-        }\n+        BitvSet(bitv)\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n-    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::BITS }\n+    pub fn capacity(&self) -> uint {\n+        let &BitvSet(ref bitv) = self;\n+        match bitv.rep {\n+            Small(_) => uint::BITS,\n+            Big(ref s) => s.storage.len() * uint::BITS\n+        }\n+    }\n \n     /// Consumes this set to return the underlying bit vector\n     pub fn unwrap(self) -> Bitv {\n-        let cap = self.capacity();\n-        let BitvSet{bitv, ..} = self;\n-        return Bitv{ nbits:cap, rep: Big(bitv) };\n+        let BitvSet(bitv) = self;\n+        bitv\n+    }\n+\n+    #[inline]\n+    /// Grows the vector to be able to store bits with indices `[0, size - 1]`\n+    fn grow(&mut self, size: uint) {\n+        let &BitvSet(ref mut bitv) = self;\n+        let small_to_big = match bitv.rep { Small(s) if size >= uint::BITS => Some(s.bits), _ => None };\n+        if small_to_big.is_some() {\n+            bitv.rep = Big(BigBitv { storage: vec![small_to_big.unwrap()]  });\n+        }\n+        match bitv.rep {\n+            Small(_) => {},\n+            Big(ref mut b) => {\n+                let size = (size + uint::BITS - 1) / uint::BITS;\n+                if b.storage.len() < size {\n+                    b.storage.grow(size, &0);\n+                }\n+            }\n+        };\n     }\n \n     #[inline]\n     fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n-        fn nbits(mut w: uint) -> uint {\n-            let mut bits = 0;\n-            for _ in range(0u, uint::BITS) {\n-                if w == 0 {\n-                    break;\n+        // Expand the vector if necessary\n+        self.grow(other.capacity());\n+        // Unwrap Bitvs\n+        let &BitvSet(ref mut self_bitv) = self;\n+        let &BitvSet(ref other_bitv) = other;\n+        for (i, w) in other_bitv.words(0) {\n+            match self_bitv.rep {\n+                Small(ref mut s) => { s.bits = f(s.bits, w); }\n+                Big(ref mut b) => {\n+                    let old = *b.storage.get(i);\n+                    let new = f(old, w);\n+                    *b.storage.get_mut(i) = new;\n+                    *b.storage.get_mut(i) = f(*b.storage.get(i), w);\n                 }\n-                bits += w & 1;\n-                w >>= 1;\n             }\n-            return bits;\n-        }\n-        if self.capacity() < other.capacity() {\n-            self.bitv.storage.grow(other.capacity() / uint::BITS, &0);\n         }\n-        for (i, &w) in other.bitv.storage.iter().enumerate() {\n-            let old = *self.bitv.storage.get(i);\n-            let new = f(old, w);\n-            *self.bitv.storage.get_mut(i) = new;\n-            self.size += nbits(new) - nbits(old);\n+    }\n+\n+    #[inline]\n+    /// Truncate the underlying vector to the least length required\n+    pub fn shrink_to_fit(&mut self) {\n+        let &BitvSet(ref mut bitv) = self;\n+        // Two steps: we borrow b as immutable to get the length...\n+        let old_len = match bitv.rep {\n+            Small(_) => 1,\n+            Big(ref b) => b.storage.len()\n+        };\n+        // ...and as mutable to change it.\n+        match bitv.rep {\n+            Small(_) => {},\n+            Big(ref mut b) => {\n+                let n = b.storage.iter().rev().take_while(|&&n| n == 0).count();\n+                let trunc_len = cmp::max(old_len - n, 1);\n+                b.storage.truncate(trunc_len);\n+                bitv.nbits = trunc_len * uint::BITS;\n+            }\n         }\n     }\n \n@@ -818,29 +882,6 @@ impl BitvSet {\n     }\n }\n \n-impl cmp::PartialEq for BitvSet {\n-    fn eq(&self, other: &BitvSet) -> bool {\n-        if self.size != other.size {\n-            return false;\n-        }\n-        for (_, w1, w2) in self.commons(other) {\n-            if w1 != w2 {\n-                return false;\n-            }\n-        }\n-        for (_, _, w) in self.outliers(other) {\n-            if w != 0 {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n-}\n-\n-impl cmp::Eq for BitvSet {}\n-\n impl fmt::Show for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"{{\"));\n@@ -866,19 +907,26 @@ impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n \n impl Collection for BitvSet {\n     #[inline]\n-    fn len(&self) -> uint { self.size }\n+    fn len(&self) -> uint  {\n+        let &BitvSet(ref bitv) = self;\n+        match bitv.rep {\n+            Small(ref s) => s.bits.count_ones(),\n+            Big(ref b) => b.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n+        }\n+    }\n }\n \n impl Mutable for BitvSet {\n     fn clear(&mut self) {\n-        self.bitv.each_storage(|w| { *w = 0; true });\n-        self.size = 0;\n+        let &BitvSet(ref mut bitv) = self;\n+        bitv.clear();\n     }\n }\n \n impl Set<uint> for BitvSet {\n     fn contains(&self, value: &uint) -> bool {\n-        *value < self.bitv.storage.len() * uint::BITS && self.bitv.get(*value)\n+        let &BitvSet(ref bitv) = self;\n+        *value < bitv.nbits && bitv.get(*value)\n     }\n \n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n@@ -914,31 +962,24 @@ impl MutableSet<uint> for BitvSet {\n         if self.contains(&value) {\n             return false;\n         }\n-        let nbits = self.capacity();\n-        if value >= nbits {\n-            let newsize = cmp::max(value, nbits * 2) / uint::BITS + 1;\n-            assert!(newsize > self.bitv.storage.len());\n-            self.bitv.storage.grow(newsize, &0);\n+        if value >= self.capacity() {\n+            let new_cap = cmp::max(value + 1, self.capacity() * 2);\n+            self.grow(new_cap);\n+        }\n+        let &BitvSet(ref mut bitv) = self;\n+        if value >= bitv.nbits {\n+            bitv.nbits = value + 1;\n         }\n-        self.size += 1;\n-        self.bitv.set(value, true);\n+        bitv.set(value, true);\n         return true;\n     }\n \n     fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n         }\n-        self.size -= 1;\n-        self.bitv.set(*value, false);\n-\n-        // Attempt to truncate our storage\n-        let mut i = self.bitv.storage.len();\n-        while i > 1 && *self.bitv.storage.get(i - 1) == 0 {\n-            i -= 1;\n-        }\n-        self.bitv.storage.truncate(i);\n-\n+        let &BitvSet(ref mut bitv) = self;\n+        bitv.set(*value, false);\n         return true;\n     }\n }\n@@ -949,12 +990,12 @@ impl BitvSet {\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn commons<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<'static, ((uint, &'a uint), &'a Vec<uint>), (uint, uint, uint),\n-               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<&'a Vec<uint>>>> {\n-        let min = cmp::min(self.bitv.storage.len(), other.bitv.storage.len());\n-        self.bitv.storage.slice(0, min).iter().enumerate()\n-            .zip(Repeat::new(&other.bitv.storage))\n-            .map(|((i, &w), o_store)| (i * uint::BITS, w, *o_store.get(i)))\n+        -> Map<((uint, uint), (uint, uint)), (uint, uint, uint),\n+               Zip<Words<'a>, Words<'a>>> {\n+        let &BitvSet(ref self_bitv) = self;\n+        let &BitvSet(ref other_bitv) = other;\n+        self_bitv.words(0).zip(other_bitv.words(0))\n+            .map(|((i, w1), (_, w2))| (i * uint::BITS, w1, w2))\n     }\n \n     /// Visits each word in `self` or `other` that extends beyond the other. This\n@@ -965,19 +1006,18 @@ impl BitvSet {\n     /// is true if the word comes from `self`, and `false` if it comes from\n     /// `other`.\n     fn outliers<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n-               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<uint>>> {\n-        let slen = self.bitv.storage.len();\n-        let olen = other.bitv.storage.len();\n+        -> Map<(uint, uint), (bool, uint, uint), Words<'a>> {\n+        let slen = self.capacity() / uint::BITS;\n+        let olen = other.capacity() / uint::BITS;\n+        let &BitvSet(ref self_bitv) = self;\n+        let &BitvSet(ref other_bitv) = other;\n \n         if olen < slen {\n-            self.bitv.storage.slice_from(olen).iter().enumerate()\n-                .zip(Repeat::new(olen))\n-                .map(|((i, &w), min)| (true, (i + min) * uint::BITS, w))\n+            self_bitv.words(olen)\n+                .map(|(i, w)| (true, i * uint::BITS, w))\n         } else {\n-            other.bitv.storage.slice_from(slen).iter().enumerate()\n-                .zip(Repeat::new(slen))\n-                .map(|((i, &w), min)| (false, (i + min) * uint::BITS, w))\n+            other_bitv.words(slen)\n+                .map(|(i, w)| (false, i * uint::BITS, w))\n         }\n     }\n }\n@@ -1600,6 +1640,7 @@ mod tests {\n \n         assert!(a.insert(1000));\n         assert!(a.remove(&1000));\n+        a.shrink_to_fit();\n         assert_eq!(a.capacity(), uint::BITS);\n     }\n "}]}