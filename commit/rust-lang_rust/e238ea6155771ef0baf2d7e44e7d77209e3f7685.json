{"sha": "e238ea6155771ef0baf2d7e44e7d77209e3f7685", "node_id": "C_kwDOAAsO6NoAKGUyMzhlYTYxNTU3NzFlZjBiYWYyZDdlNDRlN2Q3NzIwOWUzZjc2ODU", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-05T18:17:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-05T18:17:00Z"}, "message": "Merge pull request #1350 from bjorn3/inline_asm_sym\n\nImplement const and sym operands for inline asm", "tree": {"sha": "769aa1872da7629f816662a26493ce004a1329ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/769aa1872da7629f816662a26493ce004a1329ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e238ea6155771ef0baf2d7e44e7d77209e3f7685", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj3/KcCRBK7hj4Ov3rIwAAUvoIAGd69Fzx2/7KOlZhIxKbFNmc\nN1HEAE/u8zhbDucuJNCdsiHV2B+BOqMMc3fNyg2UZW6/WVf8tp0SJ6wKfv5Hm+PK\nZHqnlZ1B07LeSN4lbeGGR5Yt+7/qI/4xZCW4cV2hVztdU7isDuwoD5tl/Z5lMGfv\nW2iI76+bZgruq6a2X/dVxvdLkYJb6bnmrD8xK5KzGH8iMh8CMIvwN9UQewTa1CUD\nh4FR8pawXRwUFX1LUbGXV44FJ15q43uv6D4M03xbQhg9rTvpARRmcT7bMuC8o8BP\n/+iRGsTPdMGcT8E5GNg2iIChExwB2O640N5V02twEwCbQgtZQOP06TBTY+8ukSw=\n=lrMo\n-----END PGP SIGNATURE-----\n", "payload": "tree 769aa1872da7629f816662a26493ce004a1329ef\nparent 8b481380394bad81054a4049b338c455dbf9d4d7\nparent a2719a285c7baeddb5cb0fd9bdd801b303b74a3e\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1675621020 +0100\ncommitter GitHub <noreply@github.com> 1675621020 +0100\n\nMerge pull request #1350 from bjorn3/inline_asm_sym\n\nImplement const and sym operands for inline asm"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e238ea6155771ef0baf2d7e44e7d77209e3f7685", "html_url": "https://github.com/rust-lang/rust/commit/e238ea6155771ef0baf2d7e44e7d77209e3f7685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e238ea6155771ef0baf2d7e44e7d77209e3f7685/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b481380394bad81054a4049b338c455dbf9d4d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b481380394bad81054a4049b338c455dbf9d4d7", "html_url": "https://github.com/rust-lang/rust/commit/8b481380394bad81054a4049b338c455dbf9d4d7"}, {"sha": "a2719a285c7baeddb5cb0fd9bdd801b303b74a3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2719a285c7baeddb5cb0fd9bdd801b303b74a3e", "html_url": "https://github.com/rust-lang/rust/commit/a2719a285c7baeddb5cb0fd9bdd801b303b74a3e"}], "stats": {"total": 302, "additions": 195, "deletions": 107}, "files": [{"sha": "1c73957ca571c0af73a40ddc6ff7bf17c63ebb37", "filename": "src/allocator.rs", "status": "modified", "additions": 14, "deletions": 61, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e238ea6155771ef0baf2d7e44e7d77209e3f7685/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e238ea6155771ef0baf2d7e44e7d77209e3f7685/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=e238ea6155771ef0baf2d7e44e7d77209e3f7685", "patch": "@@ -70,74 +70,27 @@ fn codegen_inner(\n             params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n             returns: output.into_iter().map(AbiParam::new).collect(),\n         };\n-\n-        let caller_name = format!(\"__rust_{}\", method.name);\n-        let callee_name = kind.fn_name(method.name);\n-\n-        let func_id = module.declare_function(&caller_name, Linkage::Export, &sig).unwrap();\n-\n-        let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n-\n-        let mut ctx = Context::new();\n-        ctx.func.signature = sig.clone();\n-        {\n-            let mut func_ctx = FunctionBuilderContext::new();\n-            let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-            let block = bcx.create_block();\n-            bcx.switch_to_block(block);\n-            let args = arg_tys\n-                .into_iter()\n-                .map(|ty| bcx.append_block_param(block, ty))\n-                .collect::<Vec<Value>>();\n-\n-            let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n-            let call_inst = bcx.ins().call(callee_func_ref, &args);\n-            let results = bcx.inst_results(call_inst).to_vec(); // Clone to prevent borrow error\n-\n-            bcx.ins().return_(&results);\n-            bcx.seal_all_blocks();\n-            bcx.finalize();\n-        }\n-        module.define_function(func_id, &mut ctx).unwrap();\n-        unwind_context.add_function(func_id, &ctx, module.isa());\n+        crate::common::create_wrapper_function(\n+            module,\n+            unwind_context,\n+            sig,\n+            &format!(\"__rust_{}\", method.name),\n+            &kind.fn_name(method.name),\n+        );\n     }\n \n     let sig = Signature {\n         call_conv: module.target_config().default_call_conv,\n         params: vec![AbiParam::new(usize_ty), AbiParam::new(usize_ty)],\n         returns: vec![],\n     };\n-\n-    let callee_name = alloc_error_handler_kind.fn_name(sym::oom);\n-\n-    let func_id =\n-        module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n-\n-    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n-\n-    let mut ctx = Context::new();\n-    ctx.func.signature = sig;\n-    {\n-        let mut func_ctx = FunctionBuilderContext::new();\n-        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-        let block = bcx.create_block();\n-        bcx.switch_to_block(block);\n-        let args = (&[usize_ty, usize_ty])\n-            .iter()\n-            .map(|&ty| bcx.append_block_param(block, ty))\n-            .collect::<Vec<Value>>();\n-\n-        let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n-        bcx.ins().call(callee_func_ref, &args);\n-\n-        bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-        bcx.seal_all_blocks();\n-        bcx.finalize();\n-    }\n-    module.define_function(func_id, &mut ctx).unwrap();\n-    unwind_context.add_function(func_id, &ctx, module.isa());\n+    crate::common::create_wrapper_function(\n+        module,\n+        unwind_context,\n+        sig,\n+        \"__rust_alloc_error_handler\",\n+        &alloc_error_handler_kind.fn_name(sym::oom),\n+    );\n \n     let data_id = module.declare_data(OomStrategy::SYMBOL, Linkage::Export, false, false).unwrap();\n     let mut data_ctx = DataContext::new();"}, {"sha": "a8be0d32cc8c7c4d6d2948134bf7e8abf2bcd8a7", "filename": "src/common.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e238ea6155771ef0baf2d7e44e7d77209e3f7685/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e238ea6155771ef0baf2d7e44e7d77209e3f7685/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=e238ea6155771ef0baf2d7e44e7d77209e3f7685", "patch": "@@ -254,6 +254,44 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n+pub(crate) fn create_wrapper_function(\n+    module: &mut dyn Module,\n+    unwind_context: &mut UnwindContext,\n+    sig: Signature,\n+    wrapper_name: &str,\n+    callee_name: &str,\n+) {\n+    let wrapper_func_id = module.declare_function(wrapper_name, Linkage::Export, &sig).unwrap();\n+    let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n+\n+    let mut ctx = Context::new();\n+    ctx.func.signature = sig;\n+    {\n+        let mut func_ctx = FunctionBuilderContext::new();\n+        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+        let block = bcx.create_block();\n+        bcx.switch_to_block(block);\n+        let func = &mut bcx.func.stencil;\n+        let args = func\n+            .signature\n+            .params\n+            .iter()\n+            .map(|param| func.dfg.append_block_param(block, param.value_type))\n+            .collect::<Vec<Value>>();\n+\n+        let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n+        let call_inst = bcx.ins().call(callee_func_ref, &args);\n+        let results = bcx.inst_results(call_inst).to_vec(); // Clone to prevent borrow error\n+\n+        bcx.ins().return_(&results);\n+        bcx.seal_all_blocks();\n+        bcx.finalize();\n+    }\n+    module.define_function(wrapper_func_id, &mut ctx).unwrap();\n+    unwind_context.add_function(wrapper_func_id, &ctx, module.isa());\n+}\n+\n pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) cx: &'clif mut crate::CodegenCx,\n     pub(crate) module: &'m mut dyn Module,"}, {"sha": "6206fbf7dd571505c5954fff7cb55e6ee560870c", "filename": "src/inline_asm.rs", "status": "modified", "additions": 143, "deletions": 46, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/e238ea6155771ef0baf2d7e44e7d77209e3f7685/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e238ea6155771ef0baf2d7e44e7d77209e3f7685/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=e238ea6155771ef0baf2d7e44e7d77209e3f7685", "patch": "@@ -9,9 +9,33 @@ use rustc_middle::mir::InlineAsmOperand;\n use rustc_span::sym;\n use rustc_target::asm::*;\n \n+enum CInlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        value: CValue<'tcx>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        place: Option<CPlace<'tcx>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        _late: bool,\n+        in_value: CValue<'tcx>,\n+        out_place: Option<CPlace<'tcx>>,\n+    },\n+    Const {\n+        value: String,\n+    },\n+    Symbol {\n+        symbol: String,\n+    },\n+}\n+\n pub(crate) fn codegen_inline_asm<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    _span: Span,\n+    span: Span,\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n@@ -198,6 +222,81 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         }\n     }\n \n+    let operands = operands\n+        .into_iter()\n+        .map(|operand| match *operand {\n+            InlineAsmOperand::In { reg, ref value } => {\n+                CInlineAsmOperand::In { reg, value: crate::base::codegen_operand(fx, value) }\n+            }\n+            InlineAsmOperand::Out { reg, late, ref place } => CInlineAsmOperand::Out {\n+                reg,\n+                late,\n+                place: place.map(|place| crate::base::codegen_place(fx, place)),\n+            },\n+            InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n+                CInlineAsmOperand::InOut {\n+                    reg,\n+                    _late: late,\n+                    in_value: crate::base::codegen_operand(fx, in_value),\n+                    out_place: out_place.map(|place| crate::base::codegen_place(fx, place)),\n+                }\n+            }\n+            InlineAsmOperand::Const { ref value } => {\n+                let (const_value, ty) = crate::constant::eval_mir_constant(fx, &*value)\n+                    .unwrap_or_else(|| span_bug!(span, \"asm const cannot be resolved\"));\n+                let value = rustc_codegen_ssa::common::asm_const_to_str(\n+                    fx.tcx,\n+                    span,\n+                    const_value,\n+                    fx.layout_of(ty),\n+                );\n+                CInlineAsmOperand::Const { value }\n+            }\n+            InlineAsmOperand::SymFn { ref value } => {\n+                let literal = fx.monomorphize(value.literal);\n+                if let ty::FnDef(def_id, substs) = *literal.ty().kind() {\n+                    let instance = ty::Instance::resolve_for_fn_ptr(\n+                        fx.tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .unwrap();\n+                    let symbol = fx.tcx.symbol_name(instance);\n+\n+                    // Pass a wrapper rather than the function itself as the function itself may not\n+                    // be exported from the main codegen unit and may thus be unreachable from the\n+                    // object file created by an external assembler.\n+                    let inline_asm_index = fx.cx.inline_asm_index.get();\n+                    fx.cx.inline_asm_index.set(inline_asm_index + 1);\n+                    let wrapper_name = format!(\n+                        \"__inline_asm_{}_wrapper_n{}\",\n+                        fx.cx.cgu_name.as_str().replace('.', \"__\").replace('-', \"_\"),\n+                        inline_asm_index\n+                    );\n+                    let sig =\n+                        get_function_sig(fx.tcx, fx.target_config.default_call_conv, instance);\n+                    create_wrapper_function(\n+                        fx.module,\n+                        &mut fx.cx.unwind_context,\n+                        sig,\n+                        &wrapper_name,\n+                        symbol.name,\n+                    );\n+\n+                    CInlineAsmOperand::Symbol { symbol: wrapper_name }\n+                } else {\n+                    span_bug!(span, \"invalid type for asm sym (fn)\");\n+                }\n+            }\n+            InlineAsmOperand::SymStatic { def_id } => {\n+                assert!(fx.tcx.is_static(def_id));\n+                let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n+                CInlineAsmOperand::Symbol { symbol: fx.tcx.symbol_name(instance).name.to_owned() }\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n     let mut inputs = Vec::new();\n     let mut outputs = Vec::new();\n \n@@ -206,7 +305,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         arch: fx.tcx.sess.asm_arch.unwrap(),\n         enclosing_def_id: fx.instance.def_id(),\n         template,\n-        operands,\n+        operands: &operands,\n         options,\n         registers: Vec::new(),\n         stack_slots_clobber: Vec::new(),\n@@ -229,36 +328,22 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     fx.cx.global_asm.push_str(&generated_asm);\n \n     for (i, operand) in operands.iter().enumerate() {\n-        match *operand {\n-            InlineAsmOperand::In { reg: _, ref value } => {\n-                inputs.push((\n-                    asm_gen.stack_slots_input[i].unwrap(),\n-                    crate::base::codegen_operand(fx, value).load_scalar(fx),\n-                ));\n-            }\n-            InlineAsmOperand::Out { reg: _, late: _, place } => {\n+        match operand {\n+            CInlineAsmOperand::In { reg: _, value } => {\n+                inputs.push((asm_gen.stack_slots_input[i].unwrap(), value.load_scalar(fx)));\n+            }\n+            CInlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n-                    outputs.push((\n-                        asm_gen.stack_slots_output[i].unwrap(),\n-                        crate::base::codegen_place(fx, place),\n-                    ));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), place.clone()));\n                 }\n             }\n-            InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n-                inputs.push((\n-                    asm_gen.stack_slots_input[i].unwrap(),\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                ));\n+            CInlineAsmOperand::InOut { reg: _, _late: _, in_value, out_place } => {\n+                inputs.push((asm_gen.stack_slots_input[i].unwrap(), in_value.load_scalar(fx)));\n                 if let Some(out_place) = out_place {\n-                    outputs.push((\n-                        asm_gen.stack_slots_output[i].unwrap(),\n-                        crate::base::codegen_place(fx, out_place),\n-                    ));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), out_place.clone()));\n                 }\n             }\n-            InlineAsmOperand::Const { value: _ } => todo!(),\n-            InlineAsmOperand::SymFn { value: _ } => todo!(),\n-            InlineAsmOperand::SymStatic { def_id: _ } => todo!(),\n+            CInlineAsmOperand::Const { value: _ } | CInlineAsmOperand::Symbol { symbol: _ } => {}\n         }\n     }\n \n@@ -280,7 +365,7 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n     arch: InlineAsmArch,\n     enclosing_def_id: DefId,\n     template: &'a [InlineAsmTemplatePiece],\n-    operands: &'a [InlineAsmOperand<'tcx>],\n+    operands: &'a [CInlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n     registers: Vec<Option<InlineAsmReg>>,\n     stack_slots_clobber: Vec<Option<Size>>,\n@@ -304,18 +389,20 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Add explicit registers to the allocated set.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                CInlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().0 = true;\n                 }\n-                InlineAsmOperand::Out {\n-                    reg: InlineAsmRegOrRegClass::Reg(reg), late: true, ..\n+                CInlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(reg),\n+                    late: true,\n+                    ..\n                 } => {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().1 = true;\n                 }\n-                InlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n-                | InlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                CInlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n+                | CInlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n                     regs[i] = Some(reg);\n                     allocated.insert(reg, (true, true));\n                 }\n@@ -326,12 +413,12 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate out/inout/inlateout registers first because they are more constrained.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::Out {\n+                CInlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::RegClass(class),\n                     late: false,\n                     ..\n                 }\n-                | InlineAsmOperand::InOut {\n+                | CInlineAsmOperand::InOut {\n                     reg: InlineAsmRegOrRegClass::RegClass(class), ..\n                 } => {\n                     let mut alloc_reg = None;\n@@ -360,7 +447,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate in/lateout.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n+                CInlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n                     let mut alloc_reg = None;\n                     for &reg in &map[&class] {\n                         let mut used = false;\n@@ -380,7 +467,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().0 = true;\n                 }\n-                InlineAsmOperand::Out {\n+                CInlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::RegClass(class),\n                     late: true,\n                     ..\n@@ -455,7 +542,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for inout\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n+                CInlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n                     let slot = new_slot(reg.reg_class());\n                     slots_input[i] = Some(slot);\n                     slots_output[i] = Some(slot);\n@@ -470,8 +557,8 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for input\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg, .. }\n-                | InlineAsmOperand::InOut { reg, out_place: None, .. } => {\n+                CInlineAsmOperand::In { reg, .. }\n+                | CInlineAsmOperand::InOut { reg, out_place: None, .. } => {\n                     slots_input[i] = Some(new_slot(reg.reg_class()));\n                 }\n                 _ => (),\n@@ -487,7 +574,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for output\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::Out { reg, place: Some(_), .. } => {\n+                CInlineAsmOperand::Out { reg, place: Some(_), .. } => {\n                     slots_output[i] = Some(new_slot(reg.reg_class()));\n                 }\n                 _ => (),\n@@ -549,13 +636,23 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n                     generated_asm.push_str(s);\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n-                    if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                        generated_asm.push('%');\n+                    match self.operands[*operand_idx] {\n+                        CInlineAsmOperand::In { .. }\n+                        | CInlineAsmOperand::Out { .. }\n+                        | CInlineAsmOperand::InOut { .. } => {\n+                            if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                                generated_asm.push('%');\n+                            }\n+                            self.registers[*operand_idx]\n+                                .unwrap()\n+                                .emit(&mut generated_asm, self.arch, *modifier)\n+                                .unwrap();\n+                        }\n+                        CInlineAsmOperand::Const { ref value } => {\n+                            generated_asm.push_str(value);\n+                        }\n+                        CInlineAsmOperand::Symbol { ref symbol } => generated_asm.push_str(symbol),\n                     }\n-                    self.registers[*operand_idx]\n-                        .unwrap()\n-                        .emit(&mut generated_asm, self.arch, *modifier)\n-                        .unwrap();\n                 }\n             }\n         }"}]}