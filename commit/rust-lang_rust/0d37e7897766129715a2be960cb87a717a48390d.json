{"sha": "0d37e7897766129715a2be960cb87a717a48390d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMzdlNzg5Nzc2NjEyOTcxNWEyYmU5NjBjYjg3YTcxN2E0ODM5MGQ=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-28T22:13:54Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-28T22:13:54Z"}, "message": "lots more felix fixes", "tree": {"sha": "7eabeb467402cad0ca4e05db7a5e678722110575", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7eabeb467402cad0ca4e05db7a5e678722110575"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d37e7897766129715a2be960cb87a717a48390d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d37e7897766129715a2be960cb87a717a48390d", "html_url": "https://github.com/rust-lang/rust/commit/0d37e7897766129715a2be960cb87a717a48390d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d37e7897766129715a2be960cb87a717a48390d/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "html_url": "https://github.com/rust-lang/rust/commit/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe"}], "stats": {"total": 178, "additions": 104, "deletions": 74}, "files": [{"sha": "cb12ffe8d21453a21c06ea2c14f8c7f7d5c52bc2", "filename": "src/doc/tarpl/casts.md", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcasts.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -41,8 +41,7 @@ Note that lengths are not adjusted when casting raw slices -\n half of the original memory.\n \n Casting is not transitive, that is, even if `e as U1 as U2` is a valid\n-expression, `e as U2` is not necessarily so (in fact it will only be valid if\n-`U1` coerces to `U2`).\n+expression, `e as U2` is not necessarily so.\n \n For numeric casts, there are quite a few cases to consider:\n \n@@ -53,15 +52,20 @@ For numeric casts, there are quite a few cases to consider:\n     * zero-extend if the source is unsigned\n     * sign-extend if the source is signed\n * casting from a float to an integer will round the float towards zero\n-    * **NOTE: currently this will cause Undefined Behaviour if the rounded\n-      value cannot be represented by the target integer type**. This includes\n-      Inf and NaN. This is a bug and will be fixed.\n+    * **[NOTE: currently this will cause Undefined Behaviour if the rounded\n+      value cannot be represented by the target integer type][float-int]**.\n+      This includes Inf and NaN. This is a bug and will be fixed.\n * casting from an integer to float will produce the floating point\n   representation of the integer, rounded if necessary (rounding strategy\n   unspecified)\n * casting from an f32 to an f64 is perfect and lossless\n * casting from an f64 to an f32 will produce the closest possible value\n   (rounding strategy unspecified)\n-    * **NOTE: currently this will cause Undefined Behaviour if the value\n+    * **[NOTE: currently this will cause Undefined Behaviour if the value\n       is finite but larger or smaller than the largest or smallest finite\n-      value representable by f32**. This is a bug and will be fixed.\n+      value representable by f32][float-float]**. This is a bug and will\n+      be fixed.\n+\n+\n+[float-int]: https://github.com/rust-lang/rust/issues/10184\n+[float-float]: https://github.com/rust-lang/rust/issues/15536"}, {"sha": "706016a480c6625c9362c41876418197687dff12", "filename": "src/doc/tarpl/checked-uninit.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -104,5 +104,14 @@ fn main() {\n ```\n \n However reassigning `y` in this example *would* require `y` to be marked as\n-mutable, as a Safe Rust program could observe that the value of `y` changed.\n-Otherwise the variable is exactly like new.\n+mutable, as a Safe Rust program could observe that the value of `y` changed:\n+\n+```rust\n+fn main() {\n+    let mut y = Box::new(0);\n+    let z = y; // y is now logically uninitialized because Box isn't Copy\n+    y = Box::new(1); // reinitialize y\n+}\n+```\n+\n+Otherwise it's like `y` is a brand new variable."}, {"sha": "2e33a6729d1cc8bf23f95b336f64e9fc660b4fee", "filename": "src/doc/tarpl/coercions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fcoercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fcoercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcoercions.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -27,7 +27,7 @@ only implemented automatically, and enables the following transformations:\n * `Foo<..., T, ...>` => `Foo<..., U, ...>` where:\n     * `T: Unsize<U>`\n     * `Foo` is a struct\n-    * Only the last field has type `T`\n+    * Only the last field of `Foo` has type `T`\n     * `T` is not part of the type of any other fields\n \n Coercions occur at a *coercion site*. Any location that is explicitly typed"}, {"sha": "f95ccc00329e55f5d240e055efd31961dfa5c510", "filename": "src/doc/tarpl/drop-flags.md", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdrop-flags.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -2,29 +2,42 @@\n \n The examples in the previous section introduce an interesting problem for Rust.\n We have seen that's possible to conditionally initialize, deinitialize, and\n-*reinitialize* locations of memory totally safely. For Copy types, this isn't\n+reinitialize locations of memory totally safely. For Copy types, this isn't\n particularly notable since they're just a random pile of bits. However types\n with destructors are a different story: Rust needs to know whether to call a\n destructor whenever a variable is assigned to, or a variable goes out of scope.\n How can it do this with conditional initialization?\n \n+Note that this is not a problem that all assignments need worry about. In\n+particular, assigning through a dereference unconditionally drops, and assigning\n+in a `let` unconditionally *doesn't* drop:\n+\n+```\n+let mut x = Box::new(0); // let makes a fresh variable, so never need to drop\n+let y = &mut x;\n+*y = Box::new(1); // Deref assumes the referent is initialized, so always drops\n+```\n+\n+This is only a problem when overwriting a previously initialized variable or\n+one of its subfields.\n+\n It turns out that Rust actually tracks whether a type should be dropped or not\n *at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\n for that variable is toggled. When a variable *might* need to be dropped, this\n flag is evaluated to determine if it *should* be dropped.\n \n Of course, it is *often* the case that a value's initialization state can be\n *statically* known at every point in the program. If this is the case, then the\n-compiler can theoretically generate more effecient code! For instance, straight-\n+compiler can theoretically generate more efficient code! For instance, straight-\n line code has such *static drop semantics*:\n \n ```rust\n let mut x = Box::new(0); // x was uninit; just overwrite.\n let mut y = x;           // y was uninit; just overwrite and make x uninit.\n x = Box::new(0);         // x was uninit; just overwrite.\n y = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n-                         // y was init; Drop y!\n-                         // x was uninit; do nothing.\n+                         // y goes out of scope; y was init; Drop y!\n+                         // x goes out of scope; x was uninit; do nothing.\n ```\n \n And even branched code where all branches have the same behaviour with respect\n@@ -40,7 +53,7 @@ if condition {\n     drop(x)                 // x gets moved out; make x uninit.\n }\n x = Box::new(0);            // x was uninit; just overwrite.\n-                            // x was init; Drop x!\n+                            // x goes out of scope; x was init; Drop x!\n ```\n \n However code like this *requires* runtime information to correctly Drop:\n@@ -52,7 +65,8 @@ if condition {\n     x = Box::new(0);        // x was uninit; just overwrite.\n     println!(\"{}\", x);\n }\n-                            // x *might* be uninit; check the flag!\n+                            // x goes out of scope; x *might* be uninit;\n+                            // check the flag!\n ```\n \n Of course, in this case it's trivial to retrieve static drop semantics:\n@@ -66,10 +80,10 @@ if condition {\n ```\n \n As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a hidden\n-field of any type that implements Drop. Rust sets the drop flag by\n-overwriting the *entire* value with a particular byte. This is pretty obviously\n-Not The Fastest and causes a bunch of trouble with optimizing code. It's legacy\n-from a time when you could do much more complex conditional initialization.\n+field of any type that implements Drop. Rust sets the drop flag by overwriting\n+the *entire* value with a particular bit pattern. This is pretty obviously Not\n+The Fastest and causes a bunch of trouble with optimizing code. It's legacy from\n+a time when you could do much more complex conditional initialization.\n \n As such work is currently under way to move the flags out onto the stack frame\n where they more reasonably belong. Unfortunately, this work will take some time"}, {"sha": "419c61281d9fc95639f451edde75fd489cc9537a", "filename": "src/doc/tarpl/dropck.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdropck.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -49,7 +49,7 @@ accidentally make dangling pointers. Consider the following simple program:\n struct Inspector<'a>(&'a u8);\n \n fn main() {\n-    let (days, inspector);\n+    let (inspector, days);\n     days = Box::new(1);\n     inspector = Inspector(&days);\n }\n@@ -71,7 +71,7 @@ impl<'a> Drop for Inspector<'a> {\n }\n \n fn main() {\n-    let (days, inspector);\n+    let (inspector, days);\n     days = Box::new(1);\n     inspector = Inspector(&days);\n     // Let's say `days` happens to get dropped first.\n@@ -85,14 +85,14 @@ fn main() {\n                                      ^~~~\n <anon>:9:11: 15:2 note: reference must be valid for the block at 9:10...\n <anon>:9 fn main() {\n-<anon>:10     let (days, inspector);\n+<anon>:10     let (inspector, days);\n <anon>:11     days = Box::new(1);\n <anon>:12     inspector = Inspector(&days);\n <anon>:13     // Let's say `days` happens to get dropped first.\n <anon>:14     // Then when Inspector is dropped, it will try to read free'd memory!\n           ...\n <anon>:10:27: 15:2 note: ...but borrowed value is only valid for the block suffix following statement 0 at 10:26\n-<anon>:10     let (days, inspector);\n+<anon>:10     let (inspector, days);\n <anon>:11     days = Box::new(1);\n <anon>:12     inspector = Inspector(&days);\n <anon>:13     // Let's say `days` happens to get dropped first.\n@@ -112,8 +112,8 @@ of the finer details of how the drop checker validates types is totally up in\n the air. However The Big Rule is the subtlety that we have focused on this whole\n section:\n \n-**For a generic type to soundly implement drop, it must strictly outlive all of\n-its generic arguments.**\n+**For a generic type to soundly implement drop, its generics arguments must\n+strictly outlive it.**\n \n This rule is sufficient but not necessary to satisfy the drop checker. That is,\n if your type obeys this rule then it's *definitely* sound to drop. However"}, {"sha": "a43eec4f37ea3de9c7b79ff0a30bca5a829666ed", "filename": "src/doc/tarpl/exception-safety.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexception-safety.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -37,7 +37,7 @@ needs to be careful and consider exception safety.\n ## Vec::push_all\n \n `Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\n-effecient without specialization. Here's a simple implementation:\n+efficient without specialization. Here's a simple implementation:\n \n ```rust,ignore\n impl<T: Clone> Vec<T> {"}, {"sha": "3cc06f21df0007176f99f1ed360974af68f3b731", "filename": "src/doc/tarpl/hrtb.md", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fhrtb.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fhrtb.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fhrtb.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -1,6 +1,6 @@\n % Higher-Rank Trait Bounds (HRTBs)\n \n-Rust's Fn traits are a little bit magic. For instance, we can write the\n+Rust's `Fn` traits are a little bit magic. For instance, we can write the\n following code:\n \n ```rust\n@@ -52,21 +52,22 @@ fn main() {\n }\n ```\n \n-How on earth are we supposed to express the lifetimes on F's trait bound? We need\n-to provide some lifetime there, but the lifetime we care about can't be named until\n-we enter the body of `call`! Also, that isn't some fixed lifetime; call works with\n-*any* lifetime `&self` happens to have at that point.\n+How on earth are we supposed to express the lifetimes on `F`'s trait bound? We\n+need to provide some lifetime there, but the lifetime we care about can't be\n+named until we enter the body of `call`! Also, that isn't some fixed lifetime;\n+call works with *any* lifetime `&self` happens to have at that point.\n \n-This job requires The Magic of Higher-Rank Trait Bounds. The way we desugar\n-this is as follows:\n+This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we\n+desugar this is as follows:\n \n ```rust,ignore\n where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n ```\n \n-(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* Fn trait)\n+(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\n+trait)\n \n `for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n-*inifinite list* of trait bounds that F must satisfy. Intense. There aren't many\n-places outside of the Fn traits where we encounter HRTBs, and even for those we\n-have a nice magic sugar for the common cases.\n+*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\n+places outside of the `Fn` traits where we encounter HRTBs, and even for\n+those we have a nice magic sugar for the common cases."}, {"sha": "e320c5c7b6b6d62bf697046b978eacf6f2157650", "filename": "src/doc/tarpl/lifetime-splitting.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -52,16 +52,17 @@ In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n to unsafe code. For instance, mutable slices expose a `split_at_mut` function\n that consumes the slice and returns *two* mutable slices. One for everything to\n the left of the index, and one for everything to the right. Intuitively we know\n-this is safe because the slices don't alias. However the implementation requires\n-some unsafety:\n+this is safe because the slices don't overlap, and therefore alias. However\n+the implementation requires some unsafety:\n \n ```rust,ignore\n fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+    let len = self.len();\n+    let ptr = self.as_mut_ptr();\n+    assert!(mid <= len);\n     unsafe {\n-        let self2: &mut [T] = mem::transmute_copy(&self);\n-\n-        (ops::IndexMut::index_mut(self, ops::RangeTo { end: mid } ),\n-         ops::IndexMut::index_mut(self2, ops::RangeFrom { start: mid } ))\n+        (from_raw_parts_mut(ptr, mid),\n+         from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n     }\n }\n ```"}, {"sha": "5d7b305982fbe3ce98d5231ebe369d41d227c0ff", "filename": "src/doc/tarpl/lifetimes.md", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetimes.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -7,22 +7,21 @@ the scope it's valid for.\n \n Within a function body, Rust generally doesn't let you explicitly name the\n lifetimes involved. This is because it's generally not really *necessary*\n-to talk about lifetimes in a local context; rust has all the information and\n-can work out everything. It's also a good thing because the scope of a borrow\n-is often significantly smaller than the scope its referent is *actually* valid\n-for. Rust will introduce *many* anonymous scopes and temporaries to make your\n-code *just work*.\n+to talk about lifetimes in a local context; Rust has all the information and\n+can work out everything as optimally as possible. Many anonymous scopes and\n+temporaries that you would otherwise have to write are often introduced to\n+make your code *just work*.\n \n However once you cross the function boundary, you need to start talking about\n lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\n our toes with lifetimes, we're going to pretend that we're actually allowed\n to label scopes with lifetimes, and desugar the examples from the start of\n this chapter.\n \n-Originally, our examples made use of *aggressive* sugar -- high fructose corn syrup even --\n-around scopes and lifetimes, because writing everything out explicitly is\n-*extremely noisy*. All Rust code relies on aggressive inference and elision of\n-\"obvious\" things.\n+Originally, our examples made use of *aggressive* sugar -- high fructose corn\n+syrup even -- around scopes and lifetimes, because writing everything out\n+explicitly is *extremely noisy*. All Rust code relies on aggressive inference\n+and elision of \"obvious\" things.\n \n One particularly interesting piece of sugar is that each `let` statement implicitly\n introduces a scope. For the most part, this doesn't really matter. However it"}, {"sha": "1a4e5b8ffad191bbdf4bbe5659d3ccc5fbab76ea", "filename": "src/doc/tarpl/safe-unsafe-meaning.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -125,13 +125,13 @@ unsafe impl UnsafeOrd for MyType {\n But it's probably not the implementation you want.\n \n Rust has traditionally avoided making traits unsafe because it makes Unsafe\n-pervasive, which is not desirable. Send and Sync are unsafe is because\n-thread safety is a *fundamental property* that Unsafe cannot possibly hope to\n-defend against in the same way it would defend against a bad Ord implementation.\n-The only way to possibly defend against thread-unsafety would be to *not use\n-threading at all*. Making every operation atomic isn't even sufficient, because\n-it's possible for complex invariants to exist between disjoint locations in\n-memory. For instance, the pointer and capacity of a Vec must be in sync.\n+pervasive, which is not desirable. Send and Sync are unsafe is because thread\n+safety is a *fundamental property* that Unsafe cannot possibly hope to defend\n+against in the same way it would defend against a bad Ord implementation. The\n+only way to possibly defend against thread-unsafety would be to *not use\n+threading at all*. Making every load and store atomic isn't even sufficient,\n+because it's possible for complex invariants to exist between disjoint locations\n+in memory. For instance, the pointer and capacity of a Vec must be in sync.\n \n Even concurrent paradigms that are traditionally regarded as Totally Safe like\n message passing implicitly rely on some notion of thread safety -- are you"}, {"sha": "975d1c59c76db43e4b6e163df59093047f5fa7ae", "filename": "src/doc/tarpl/subtyping.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsubtyping.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -33,7 +33,7 @@ Variance is where things get a bit complicated.\n Variance is a property that *type constructors* have with respect to their\n arguments. A type constructor in Rust is a generic type with unbound arguments.\n For instance `Vec` is a type constructor that takes a `T` and returns a\n-`Vec<T>`. `&` and `&mut` are type constructors that take a two types: a\n+`Vec<T>`. `&` and `&mut` are type constructors that take two inputs: a\n lifetime, and a type to point to.\n \n A type constructor's *variance* is how the subtyping of its inputs affects the\n@@ -54,7 +54,8 @@ Some important variances:\n * `&'a T` is variant over `'a` and `T` (as is `*const T` by metaphor)\n * `&'a mut T` is variant with over `'a` but invariant over `T`\n * `Fn(T) -> U` is invariant over `T`, but variant over `U`\n-* `Box`, `Vec`, and all other collections are variant over their contents\n+* `Box`, `Vec`, and all other collections are variant over the types of\n+  their contents\n * `UnsafeCell<T>`, `Cell<T>`, `RefCell<T>`, `Mutex<T>` and all other\n   interior mutability types are invariant over T (as is `*mut T` by metaphor)\n \n@@ -71,7 +72,7 @@ to be able to pass `&&'static str` where an `&&'a str` is expected. The\n additional level of indirection does not change the desire to be able to pass\n longer lived things where shorted lived things are expected.\n \n-However this logic *does not* apply to see why `&mut`. To see why &mut should\n+However this logic *does not* apply to `&mut`. To see why `&mut` should\n be invariant over T, consider the following code:\n \n ```rust,ignore\n@@ -117,8 +118,9 @@ in them *via a mutable reference*! The mutable reference makes the whole type\n invariant, and therefore prevents you from smuggling a short-lived type into\n them.\n \n-Being variant *does* allows them to be weakened when shared immutably.\n-So you can pass a `&Box<&'static str>` where a `&Box<&'a str>` is expected.\n+Being variant *does* allows `Box` and `Vec` to be weakened when shared\n+immutably. So you can pass a `&Box<&'static str>` where a `&Box<&'a str>` is\n+expected.\n \n However what should happen when passing *by-value* is less obvious. It turns out\n that, yes, you can use subtyping when passing by-value. That is, this works:\n@@ -178,7 +180,7 @@ fn foo(usize) -> &'static str;\n in its place. Therefore functions *are* variant over their return type.\n \n `*const` has the exact same semantics as `&`, so variance follows. `*mut` on the\n-other hand can dereference to an &mut whether shared or not, so it is marked\n+other hand can dereference to an `&mut` whether shared or not, so it is marked\n as invariant just like cells.\n \n This is all well and good for the types the standard library provides, but"}, {"sha": "d0397c371908470d0a281df938dbfbf7c8a299d5", "filename": "src/doc/tarpl/unchecked-uninit.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d37e7897766129715a2be960cb87a717a48390d/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md?ref=0d37e7897766129715a2be960cb87a717a48390d", "patch": "@@ -26,7 +26,7 @@ returns a pointer to uninitialized memory.\n \n To handle this, we must use the `ptr` module. In particular, it provides\n three functions that allow us to assign bytes to a location in memory without\n-evaluating the old value: `write`, `copy`, and `copy_nonoverlapping`.\n+dropping the old value: `write`, `copy`, and `copy_nonoverlapping`.\n \n * `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed\n   to by `ptr`.\n@@ -35,7 +35,7 @@ evaluating the old value: `write`, `copy`, and `copy_nonoverlapping`.\n   order is reversed!)\n * `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a\n   little faster on the assumption that the two ranges of memory don't overlap.\n-  (this is equivalent to memcopy -- note that the argument order is reversed!)\n+  (this is equivalent to memcpy -- note that the argument order is reversed!)\n \n It should go without saying that these functions, if misused, will cause serious\n havoc or just straight up Undefined Behaviour. The only things that these\n@@ -68,14 +68,14 @@ unsafe {\n println!(\"{:?}\", x);\n ```\n \n-It's worth noting that you don't need to worry about ptr::write-style\n-shenanigans with types which don't implement Drop or\n-contain Drop types, because Rust knows not to try to Drop them. Similarly you\n-should be able to assign to fields of partially initialized structs\n-directly if those fields don't contain any Drop types.\n+It's worth noting that you don't need to worry about `ptr::write`-style\n+shenanigans with types which don't implement `Drop` or contain `Drop` types,\n+because Rust knows not to try to drop them. Similarly you should be able to\n+assign to fields of partially initialized structs directly if those fields don't\n+contain any `Drop` types.\n \n However when working with uninitialized memory you need to be ever-vigilant for\n-Rust trying to Drop values you make like this before they're fully initialized.\n+Rust trying to drop values you make like this before they're fully initialized.\n Every control path through that variable's scope must initialize the value\n before it ends, if has a destructor.\n *[This includes code panicking](unwinding.html)*."}]}