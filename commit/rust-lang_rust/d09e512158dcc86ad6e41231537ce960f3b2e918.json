{"sha": "d09e512158dcc86ad6e41231537ce960f3b2e918", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOWU1MTIxNThkY2M4NmFkNmU0MTIzMTUzN2NlOTYwZjNiMmU5MTg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-01-26T09:37:25Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-02-28T22:13:34Z"}, "message": "Remove a `loop` in `ext::tt::transcribe`.", "tree": {"sha": "b063c7f0ab7d908837ef48c1c862af357771497f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b063c7f0ab7d908837ef48c1c862af357771497f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d09e512158dcc86ad6e41231537ce960f3b2e918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d09e512158dcc86ad6e41231537ce960f3b2e918", "html_url": "https://github.com/rust-lang/rust/commit/d09e512158dcc86ad6e41231537ce960f3b2e918", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d09e512158dcc86ad6e41231537ce960f3b2e918/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be760566cf938d11d34c2f6bd90d8fd0f67c2344", "url": "https://api.github.com/repos/rust-lang/rust/commits/be760566cf938d11d34c2f6bd90d8fd0f67c2344", "html_url": "https://github.com/rust-lang/rust/commit/be760566cf938d11d34c2f6bd90d8fd0f67c2344"}], "stats": {"total": 55, "additions": 23, "deletions": 32}, "files": [{"sha": "a2ce782eec8917d368a04909f17608b21b7d6099", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d09e512158dcc86ad6e41231537ce960f3b2e918/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09e512158dcc86ad6e41231537ce960f3b2e918/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=d09e512158dcc86ad6e41231537ce960f3b2e918", "patch": "@@ -151,43 +151,34 @@ fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n /// EFFECT: advances the reader's token field\n fn tt_next_token(r: &mut TtReader, prev_span: Span) -> Option<TokenTree> {\n     loop {\n-        let should_pop = if let Some(frame) = r.stack.last() {\n-            if frame.idx < frame.forest.len() {\n-                break;\n-            }\n-            !frame.dotdotdoted || *r.repeat_idx.last().unwrap() == *r.repeat_len.last().unwrap() - 1\n-        } else {\n-            return None;\n+        let frame = match r.stack.last() {\n+            Some(frame) => frame.clone(),\n+            None => return None,\n         };\n \n-        /* done with this set; pop or repeat? */\n-        if should_pop {\n-            let prev = r.stack.pop().unwrap();\n-            if let Some(frame) = r.stack.last_mut() {\n-                frame.idx += 1;\n+        if frame.idx == frame.forest.len() {\n+            if frame.dotdotdoted &&\n+               *r.repeat_idx.last().unwrap() == *r.repeat_len.last().unwrap() - 1 {\n+                *r.repeat_idx.last_mut().unwrap() += 1;\n+                r.stack.last_mut().unwrap().idx = 0;\n+                if let Some(tk) = r.stack.last().unwrap().sep.clone() {\n+                    return Some(TokenTree::Token(prev_span, tk)); // repeat same span, I guess\n+                }\n             } else {\n-                return None;\n-            }\n-            if prev.dotdotdoted {\n-                r.repeat_idx.pop();\n-                r.repeat_len.pop();\n-            }\n-        } else { /* repeat */\n-            *r.repeat_idx.last_mut().unwrap() += 1;\n-            r.stack.last_mut().unwrap().idx = 0;\n-            if let Some(tk) = r.stack.last().unwrap().sep.clone() {\n-                return Some(TokenTree::Token(prev_span, tk)); // repeat same span, I guess\n+                r.stack.pop();\n+                match r.stack.last_mut() {\n+                    Some(frame) => frame.idx += 1,\n+                    None => return None,\n+                }\n+                if frame.dotdotdoted {\n+                    r.repeat_idx.pop();\n+                    r.repeat_len.pop();\n+                }\n             }\n+            continue\n         }\n-    }\n-    loop { /* because it's easiest, this handles `TokenTree::Delimited` not starting\n-              with a `TokenTree::Token`, even though it won't happen */\n-        let t = {\n-            let frame = r.stack.last().unwrap();\n-            // FIXME(pcwalton): Bad copy.\n-            frame.forest.get_tt(frame.idx)\n-        };\n-        match t {\n+\n+        match frame.forest.get_tt(frame.idx) {\n             TokenTree::Sequence(sp, seq) => {\n                 // FIXME(pcwalton): Bad copy.\n                 match lockstep_iter_size(&TokenTree::Sequence(sp, seq.clone()),"}]}