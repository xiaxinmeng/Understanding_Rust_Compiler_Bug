{"sha": "ff0312fa32715ce42f134fd9f049c4df5956d042", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMDMxMmZhMzI3MTVjZTQyZjEzNGZkOWYwNDljNGRmNTk1NmQwNDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-16T11:00:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-16T16:03:04Z"}, "message": "Semantical call info", "tree": {"sha": "b514e34d3486a650fef35e29396a810ee7741cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b514e34d3486a650fef35e29396a810ee7741cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff0312fa32715ce42f134fd9f049c4df5956d042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0312fa32715ce42f134fd9f049c4df5956d042", "html_url": "https://github.com/rust-lang/rust/commit/ff0312fa32715ce42f134fd9f049c4df5956d042", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff0312fa32715ce42f134fd9f049c4df5956d042/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9210fcc076808e53e9bde84be26307fc0dc7d688", "url": "https://api.github.com/repos/rust-lang/rust/commits/9210fcc076808e53e9bde84be26307fc0dc7d688", "html_url": "https://github.com/rust-lang/rust/commit/9210fcc076808e53e9bde84be26307fc0dc7d688"}], "stats": {"total": 568, "additions": 310, "deletions": 258}, "files": [{"sha": "057dfb82afcc7ee12153cf53b8c8afb876d86647", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -1,5 +1,5 @@\n //! FIXME: write short doc here\n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use either::Either;\n@@ -12,6 +12,7 @@ use hir_def::{\n     import_map,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n+    src::HasSource as _,\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocContainerId, ConstId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule,\n     ImplId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StaticId, StructId,\n@@ -25,8 +26,8 @@ use hir_expand::{\n use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n-    method_resolution, ApplicationTy, Canonical, GenericPredicate, InEnvironment, Substs,\n-    TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    method_resolution, ApplicationTy, CallableDefId, Canonical, FnSig, GenericPredicate,\n+    InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n@@ -40,7 +41,7 @@ use stdx::impl_from;\n use crate::{\n     db::{DefDatabase, HirDatabase},\n     has_source::HasSource,\n-    CallableDefId, HirDisplay, InFile, Name,\n+    HirDisplay, InFile, Name,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -1168,6 +1169,12 @@ impl Type {\n         Type::new(db, krate, def, ty)\n     }\n \n+    pub fn is_unit(&self) -> bool {\n+        matches!(\n+            self.ty.value,\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { cardinality: 0 }, .. })\n+        )\n+    }\n     pub fn is_bool(&self) -> bool {\n         matches!(self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. }))\n     }\n@@ -1225,9 +1232,10 @@ impl Type {\n         db.trait_solve(self.krate, goal).is_some()\n     }\n \n-    // FIXME: this method is broken, as it doesn't take closures into account.\n-    pub fn as_callable(&self) -> Option<CallableDefId> {\n-        Some(self.ty.value.as_callable()?.0)\n+    pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n+        let (id, substs) = self.ty.value.as_callable()?;\n+        let sig = db.callable_item_signature(id).subst(substs);\n+        Some(Callable { ty: self.clone(), sig, id, is_bound_method: false })\n     }\n \n     pub fn is_closure(&self) -> bool {\n@@ -1512,6 +1520,60 @@ impl HirDisplay for Type {\n     }\n }\n \n+// FIXME: closures\n+#[derive(Debug)]\n+pub struct Callable {\n+    ty: Type,\n+    sig: FnSig,\n+    id: CallableDefId,\n+    pub(crate) is_bound_method: bool,\n+}\n+\n+pub enum CallableKind {\n+    Function(Function),\n+    TupleStruct(Struct),\n+    TupleEnumVariant(EnumVariant),\n+}\n+\n+impl Callable {\n+    pub fn kind(&self) -> CallableKind {\n+        match self.id {\n+            CallableDefId::FunctionId(it) => CallableKind::Function(it.into()),\n+            CallableDefId::StructId(it) => CallableKind::TupleStruct(it.into()),\n+            CallableDefId::EnumVariantId(it) => CallableKind::TupleEnumVariant(it.into()),\n+        }\n+    }\n+    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {\n+        let func = match self.id {\n+            CallableDefId::FunctionId(it) if self.is_bound_method => it,\n+            _ => return None,\n+        };\n+        let src = func.lookup(db.upcast()).source(db.upcast());\n+        let param_list = src.value.param_list()?;\n+        param_list.self_param()\n+    }\n+    pub fn params(&self, db: &dyn HirDatabase) -> Vec<(Option<ast::Pat>, Type)> {\n+        let types = self\n+            .sig\n+            .params()\n+            .iter()\n+            .skip(if self.is_bound_method { 1 } else { 0 })\n+            .map(|ty| self.ty.derived(ty.clone()));\n+        let patterns = match self.id {\n+            CallableDefId::FunctionId(func) => {\n+                let src = func.lookup(db.upcast()).source(db.upcast());\n+                src.value.param_list().map(|it| it.params().map(|it| it.pat()))\n+            }\n+            CallableDefId::StructId(_) => None,\n+            CallableDefId::EnumVariantId(_) => None,\n+        };\n+        patterns.into_iter().flatten().chain(iter::repeat(None)).zip(types).collect()\n+    }\n+    pub fn return_type(&self) -> Type {\n+        self.ty.derived(self.sig.ret().clone())\n+    }\n+}\n+\n /// For IDE only\n #[derive(Debug)]\n pub enum ScopeDef {"}, {"sha": "31f3241c9ed12a5b09226da3f18abb8707eb78fb", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -32,10 +32,10 @@ mod has_source;\n \n pub use crate::{\n     code_model::{\n-        Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Const, Crate, CrateDependency,\n-        DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource, Function, GenericDef, HasAttrs,\n-        HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef, Static, Struct,\n-        Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n+        Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Callable, CallableKind, Const,\n+        Crate, CrateDependency, DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource, Function,\n+        GenericDef, HasAttrs, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef,\n+        Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     has_source::HasSource,\n     semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n@@ -52,7 +52,8 @@ pub use hir_def::{\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId,\n+    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n+    MacroDefId, /* FIXME */\n     MacroFile, Origin,\n };\n-pub use hir_ty::{display::HirDisplay, CallableDefId};\n+pub use hir_ty::display::HirDisplay;"}, {"sha": "f5283ab220e264237d58fa5b73259726d19f4498", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -6,7 +6,7 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    AsMacroCall, TraitId, VariantId,\n+    AsMacroCall, FunctionId, TraitId, VariantId,\n };\n use hir_expand::{diagnostics::AstDiagnostic, hygiene::Hygiene, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n@@ -24,8 +24,8 @@ use crate::{\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n-    AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n-    Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    AssocItem, Callable, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module,\n+    ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n use resolver::TypeNs;\n \n@@ -197,7 +197,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        self.imp.resolve_method_call(call)\n+        self.imp.resolve_method_call(call).map(Function::from)\n+    }\n+\n+    pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n+        self.imp.resolve_method_call_as_callable(call)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n@@ -385,10 +389,21 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(param.syntax()).type_of_self(self.db, &param)\n     }\n \n-    fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n+    fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<FunctionId> {\n         self.analyze(call.syntax()).resolve_method_call(self.db, call)\n     }\n \n+    fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n+        // FIXME: this erases Substs\n+        let func = self.resolve_method_call(call)?;\n+        let ty = self.db.value_ty(func.into());\n+        let resolver = self.analyze(call.syntax()).resolver;\n+        let ty = Type::new_with_resolver(self.db, &resolver, ty.value)?;\n+        let mut res = ty.as_callable(self.db)?;\n+        res.is_bound_method = true;\n+        Some(res)\n+    }\n+\n     fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n         self.analyze(field.syntax()).resolve_field(self.db, field)\n     }"}, {"sha": "86a47a9e54f2db77a710b57d363a40703fc8fbe1", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -14,7 +14,7 @@ use hir_def::{\n     },\n     expr::{ExprId, Pat, PatId},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n-    AsMacroCall, DefWithBodyId, FieldId, LocalFieldId, VariantId,\n+    AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n use hir_ty::{\n@@ -142,9 +142,9 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         call: &ast::MethodCallExpr,\n-    ) -> Option<Function> {\n+    ) -> Option<FunctionId> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id).map(Function::from)\n+        self.infer.as_ref()?.method_resolution(expr_id)\n     }\n \n     pub(crate) fn resolve_field("}, {"sha": "dbfa7fccb4777b58e0d9c259c162839f09a39974", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -226,7 +226,15 @@ impl CrateDefMap {\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into(), Visibility::Public)\n+                            match &*enum_data.variants[local_id].variant_data {\n+                                crate::adt::VariantData::Record(_) => {\n+                                    PerNs::types(variant.into(), Visibility::Public)\n+                                }\n+                                crate::adt::VariantData::Tuple(_)\n+                                | crate::adt::VariantData::Unit => {\n+                                    PerNs::both(variant.into(), variant.into(), Visibility::Public)\n+                                }\n+                            }\n                         }\n                         None => {\n                             return ResolvePathResult::with("}, {"sha": "6af251d231c5e9b39f9c316f1e58c0a9da4b4932", "filename": "crates/ra_ide/src/call_hierarchy.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -95,9 +95,9 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             if let Some(func_target) = match &call_node {\n                 FnCallNode::CallExpr(expr) => {\n                     //FIXME: Type::as_callable is broken\n-                    let callable_def = sema.type_of_expr(&expr.expr()?)?.as_callable()?;\n-                    match callable_def {\n-                        hir::CallableDefId::FunctionId(it) => {\n+                    let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(db)?;\n+                    match callable.kind() {\n+                        hir::CallableKind::Function(it) => {\n                             let fn_def: hir::Function = it.into();\n                             let nav = fn_def.to_nav(db);\n                             Some(nav)\n@@ -109,10 +109,6 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n                     let function = sema.resolve_method_call(&expr)?;\n                     Some(function.to_nav(db))\n                 }\n-                FnCallNode::MacroCallExpr(macro_call) => {\n-                    let macro_def = sema.resolve_macro_call(&macro_call)?;\n-                    Some(macro_def.to_nav(db))\n-                }\n             } {\n                 Some((func_target, name_ref.syntax().text_range()))\n             } else {"}, {"sha": "a2d23b2ec92321295da8b45c6cba1795799af497", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 168, "deletions": 164, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -1,20 +1,41 @@\n //! FIXME: write short doc here\n-use hir::Semantics;\n+use hir::{Docs, HirDisplay, Semantics, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, ArgListOwner},\n-    match_ast, AstNode, SyntaxNode, SyntaxToken,\n+    match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n+use stdx::format_to;\n use test_utils::mark;\n \n-use crate::{FilePosition, FunctionSignature};\n+use crate::FilePosition;\n \n /// Contains information about a call site. Specifically the\n /// `FunctionSignature`and current parameter.\n #[derive(Debug)]\n pub struct CallInfo {\n-    pub signature: FunctionSignature,\n+    pub doc: Option<String>,\n+    pub signature: String,\n     pub active_parameter: Option<usize>,\n+    parameters: Vec<TextRange>,\n+}\n+\n+impl CallInfo {\n+    pub fn parameter_labels(&self) -> impl Iterator<Item = &str> + '_ {\n+        self.parameters.iter().map(move |&it| &self.signature[it])\n+    }\n+    pub fn parameter_ranges(&self) -> &[TextRange] {\n+        &self.parameters\n+    }\n+    fn push_param(&mut self, param: &str) {\n+        if !self.signature.ends_with('(') {\n+            self.signature.push_str(\", \");\n+        }\n+        let start = TextSize::of(&self.signature);\n+        self.signature.push_str(param);\n+        let end = TextSize::of(&self.signature);\n+        self.parameters.push(TextRange::new(start, end))\n+    }\n }\n \n /// Computes parameter information for the given call expression.\n@@ -24,105 +45,127 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let file = file.syntax();\n     let token = file.token_at_offset(position.offset).next()?;\n     let token = sema.descend_into_macros(token);\n-    call_info_for_token(&sema, token)\n-}\n \n-#[derive(Debug)]\n-pub(crate) struct ActiveParameter {\n-    /// FIXME: should be `Type` and `Name\n-    pub(crate) ty: String,\n-    pub(crate) name: String,\n-}\n+    let (callable, active_parameter) = call_info_impl(&sema, token)?;\n \n-impl ActiveParameter {\n-    pub(crate) fn at(db: &RootDatabase, position: FilePosition) -> Option<Self> {\n-        call_info(db, position)?.into_active_parameter()\n+    let mut res =\n+        CallInfo { doc: None, signature: String::new(), parameters: vec![], active_parameter };\n+\n+    match callable.kind() {\n+        hir::CallableKind::Function(func) => {\n+            res.doc = func.docs(db).map(|it| it.as_str().to_string());\n+            format_to!(res.signature, \"fn {}\", func.name(db));\n+        }\n+        hir::CallableKind::TupleStruct(strukt) => {\n+            res.doc = strukt.docs(db).map(|it| it.as_str().to_string());\n+            format_to!(res.signature, \"struct {}\", strukt.name(db));\n+        }\n+        hir::CallableKind::TupleEnumVariant(variant) => {\n+            res.doc = variant.docs(db).map(|it| it.as_str().to_string());\n+            format_to!(\n+                res.signature,\n+                \"enum {}::{}\",\n+                variant.parent_enum(db).name(db),\n+                variant.name(db)\n+            );\n+        }\n     }\n \n-    pub(crate) fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n-        call_info_for_token(sema, token)?.into_active_parameter()\n+    res.signature.push('(');\n+    {\n+        if let Some(self_param) = callable.receiver_param(db) {\n+            format_to!(res.signature, \"{}\", self_param)\n+        }\n+        let mut buf = String::new();\n+        for (pat, ty) in callable.params(db) {\n+            buf.clear();\n+            if let Some(pat) = pat {\n+                format_to!(buf, \"{}: \", pat);\n+            }\n+            format_to!(buf, \"{}\", ty.display(db));\n+            res.push_param(&buf);\n+        }\n     }\n+    res.signature.push(')');\n+\n+    match callable.kind() {\n+        hir::CallableKind::Function(_) => {\n+            let ret_type = callable.return_type();\n+            if !ret_type.is_unit() {\n+                format_to!(res.signature, \" -> {}\", ret_type.display(db));\n+            }\n+        }\n+        hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n+    }\n+    Some(res)\n }\n \n-fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<CallInfo> {\n+fn call_info_impl(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+) -> Option<(hir::Callable, Option<usize>)> {\n     // Find the calling expression and it's NameRef\n     let calling_node = FnCallNode::with_node(&token.parent())?;\n \n-    let signature = match &calling_node {\n-        FnCallNode::CallExpr(call) => {\n-            //FIXME: Type::as_callable is broken\n-            let callable_def = sema.type_of_expr(&call.expr()?)?.as_callable()?;\n-            match callable_def {\n-                hir::CallableDefId::FunctionId(it) => {\n-                    let fn_def = it.into();\n-                    FunctionSignature::from_hir(sema.db, fn_def)\n-                }\n-                hir::CallableDefId::StructId(it) => {\n-                    FunctionSignature::from_struct(sema.db, it.into())?\n-                }\n-                hir::CallableDefId::EnumVariantId(it) => {\n-                    FunctionSignature::from_enum_variant(sema.db, it.into())?\n-                }\n-            }\n-        }\n-        FnCallNode::MethodCallExpr(method_call) => {\n-            let function = sema.resolve_method_call(&method_call)?;\n-            FunctionSignature::from_hir(sema.db, function)\n-        }\n-        FnCallNode::MacroCallExpr(macro_call) => {\n-            let macro_def = sema.resolve_macro_call(&macro_call)?;\n-            FunctionSignature::from_macro(sema.db, macro_def)?\n+    let callable = match &calling_node {\n+        FnCallNode::CallExpr(call) => sema.type_of_expr(&call.expr()?)?.as_callable(sema.db)?,\n+        FnCallNode::MethodCallExpr(call) => sema.resolve_method_call_as_callable(call)?,\n+    };\n+    let active_param = if let Some(arg_list) = calling_node.arg_list() {\n+        // Number of arguments specified at the call site\n+        let num_args_at_callsite = arg_list.args().count();\n+\n+        let arg_list_range = arg_list.syntax().text_range();\n+        if !arg_list_range.contains_inclusive(token.text_range().start()) {\n+            mark::hit!(call_info_bad_offset);\n+            return None;\n         }\n+        let param = std::cmp::min(\n+            num_args_at_callsite,\n+            arg_list\n+                .args()\n+                .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+                .count(),\n+        );\n+\n+        Some(param)\n+    } else {\n+        None\n     };\n+    Some((callable, active_param))\n+}\n \n-    // If we have a calling expression let's find which argument we are on\n-    let num_params = signature.parameters.len();\n-\n-    let active_parameter = match num_params {\n-        0 => None,\n-        1 if signature.has_self_param => None,\n-        1 => Some(0),\n-        _ => {\n-            if let Some(arg_list) = calling_node.arg_list() {\n-                // Number of arguments specified at the call site\n-                let num_args_at_callsite = arg_list.args().count();\n-\n-                let arg_list_range = arg_list.syntax().text_range();\n-                if !arg_list_range.contains_inclusive(token.text_range().start()) {\n-                    mark::hit!(call_info_bad_offset);\n-                    return None;\n-                }\n+#[derive(Debug)]\n+pub(crate) struct ActiveParameter {\n+    pub(crate) ty: Type,\n+    pub(crate) name: String,\n+}\n \n-                let mut param = std::cmp::min(\n-                    num_args_at_callsite,\n-                    arg_list\n-                        .args()\n-                        .take_while(|arg| {\n-                            arg.syntax().text_range().end() <= token.text_range().start()\n-                        })\n-                        .count(),\n-                );\n-\n-                // If we are in a method account for `self`\n-                if signature.has_self_param {\n-                    param += 1;\n-                }\n+impl ActiveParameter {\n+    pub(crate) fn at(db: &RootDatabase, position: FilePosition) -> Option<Self> {\n+        let sema = Semantics::new(db);\n+        let file = sema.parse(position.file_id);\n+        let file = file.syntax();\n+        let token = file.token_at_offset(position.offset).next()?;\n+        let token = sema.descend_into_macros(token);\n+        Self::at_token(&sema, token)\n+    }\n \n-                Some(param)\n-            } else {\n-                None\n-            }\n-        }\n-    };\n+    pub(crate) fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n+        let (signature, active_parameter) = call_info_impl(&sema, token)?;\n \n-    Some(CallInfo { signature, active_parameter })\n+        let idx = active_parameter?;\n+        let mut params = signature.params(sema.db);\n+        let (pat, ty) = params.swap_remove(idx);\n+        let name = pat?.to_string();\n+        Some(ActiveParameter { ty, name })\n+    }\n }\n \n #[derive(Debug)]\n pub(crate) enum FnCallNode {\n     CallExpr(ast::CallExpr),\n     MethodCallExpr(ast::MethodCallExpr),\n-    MacroCallExpr(ast::MacroCall),\n }\n \n impl FnCallNode {\n@@ -138,7 +181,6 @@ impl FnCallNode {\n                         }\n                         Some(FnCallNode::MethodCallExpr(it))\n                     },\n-                    ast::MacroCall(it) => Some(FnCallNode::MacroCallExpr(it)),\n                     _ => None,\n                 }\n             }\n@@ -150,7 +192,6 @@ impl FnCallNode {\n             match node {\n                 ast::CallExpr(it) => Some(FnCallNode::CallExpr(it)),\n                 ast::MethodCallExpr(it) => Some(FnCallNode::MethodCallExpr(it)),\n-                ast::MacroCall(it) => Some(FnCallNode::MacroCallExpr(it)),\n                 _ => None,\n             }\n         }\n@@ -166,30 +207,17 @@ impl FnCallNode {\n             FnCallNode::MethodCallExpr(call_expr) => {\n                 call_expr.syntax().children().filter_map(ast::NameRef::cast).next()\n             }\n-\n-            FnCallNode::MacroCallExpr(call_expr) => call_expr.path()?.segment()?.name_ref(),\n         }\n     }\n \n     fn arg_list(&self) -> Option<ast::ArgList> {\n         match self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n             FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MacroCallExpr(_) => None,\n         }\n     }\n }\n \n-impl CallInfo {\n-    fn into_active_parameter(self) -> Option<ActiveParameter> {\n-        let idx = self.active_parameter?;\n-        let ty = self.signature.parameter_types.get(idx)?.clone();\n-        let name = self.signature.parameter_names.get(idx)?.clone();\n-        let res = ActiveParameter { ty, name };\n-        Some(res)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect::{expect, Expect};\n@@ -202,20 +230,18 @@ mod tests {\n         let call_info = analysis.call_info(position).unwrap();\n         let actual = match call_info {\n             Some(call_info) => {\n-                let docs = match &call_info.signature.doc {\n+                let docs = match &call_info.doc {\n                     None => \"\".to_string(),\n                     Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n                 };\n                 let params = call_info\n-                    .signature\n-                    .parameters\n-                    .iter()\n+                    .parameter_labels()\n                     .enumerate()\n                     .map(|(i, param)| {\n                         if Some(i) == call_info.active_parameter {\n                             format!(\"<{}>\", param)\n                         } else {\n-                            param.clone()\n+                            param.to_string()\n                         }\n                     })\n                     .collect::<Vec<_>>()\n@@ -296,10 +322,8 @@ fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n fn bar() { foo(<|>3, ); }\n \"#,\n             expect![[r#\"\n-                fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n-                where T: Copy + Display,\n-                      U: Debug\n-                (<x: T>, y: U)\n+                fn foo(x: i32, y: {unknown}) -> u32\n+                (<x: i32>, y: {unknown})\n             \"#]],\n         );\n     }\n@@ -312,8 +336,7 @@ fn foo<T>() -> T where T: Copy + Display {}\n fn bar() { foo(<|>); }\n \"#,\n             expect![[r#\"\n-                fn foo<T>() -> T\n-                where T: Copy + Display\n+                fn foo() -> {unknown}\n                 ()\n             \"#]],\n         );\n@@ -323,11 +346,14 @@ fn bar() { foo(<|>); }\n     fn test_fn_signature_for_impl() {\n         check(\n             r#\"\n-struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\n+struct F;\n+impl F { pub fn new() { } }\n+fn bar() {\n+    let _ : F = F::new(<|>);\n+}\n \"#,\n             expect![[r#\"\n-                pub fn new()\n+                fn new()\n                 ()\n             \"#]],\n         );\n@@ -346,8 +372,8 @@ fn bar() {\n }\n \"#,\n             expect![[r#\"\n-                pub fn do_it(&self)\n-                (&self)\n+                fn do_it(&self)\n+                ()\n             \"#]],\n         );\n     }\n@@ -365,8 +391,8 @@ fn bar() {\n }\n \"#,\n             expect![[r#\"\n-                pub fn do_it(&self, x: i32)\n-                (&self, <x: i32>)\n+                fn do_it(&self, x: i32)\n+                (<x: i32>)\n             \"#]],\n         );\n     }\n@@ -425,7 +451,7 @@ pub fn do() {\n                 assert_eq!(6, my_crate::add_one(5));\n                 ```\n                 ------\n-                pub fn add_one(x: i32) -> i32\n+                fn add_one(x: i32) -> i32\n                 (<x: i32>)\n             \"##]],\n         );\n@@ -467,7 +493,7 @@ pub fn do_it() {\n                 assert_eq!(6, my_crate::add_one(5));\n                 ```\n                 ------\n-                pub fn add_one(x: i32) -> i32\n+                fn add_one(x: i32) -> i32\n                 (<x: i32>)\n             \"##]],\n         );\n@@ -505,8 +531,8 @@ pub fn foo(mut r: WriteHandler<()>) {\n \n                 By default this method stops actor's `Context`.\n                 ------\n-                fn finished(&mut self, ctx: &mut Self::Context)\n-                (&mut self, <ctx: &mut Self::Context>)\n+                fn finished(&mut self, ctx: &mut {unknown})\n+                (<ctx: &mut {unknown}>)\n             \"#]],\n         );\n     }\n@@ -539,7 +565,7 @@ fn main() {\n \"#,\n             expect![[r#\"\n                 fn bar(&self, _: u32)\n-                (&self, <_: u32>)\n+                (<_: u32>)\n             \"#]],\n         );\n     }\n@@ -549,15 +575,15 @@ fn main() {\n         check(\n             r#\"\n /// A cool tuple struct\n-struct TS(u32, i32);\n+struct S(u32, i32);\n fn main() {\n-    let s = TS(0, <|>);\n+    let s = S(0, <|>);\n }\n \"#,\n             expect![[r#\"\n                 A cool tuple struct\n                 ------\n-                struct TS(u32, i32) -> TS\n+                struct S(u32, i32)\n                 (u32, <i32>)\n             \"#]],\n         );\n@@ -567,31 +593,18 @@ fn main() {\n     fn generic_struct() {\n         check(\n             r#\"\n-struct TS<T>(T);\n+struct S<T>(T);\n fn main() {\n-    let s = TS(<|>);\n+    let s = S(<|>);\n }\n \"#,\n             expect![[r#\"\n-                struct TS<T>(T) -> TS\n-                (<T>)\n+                struct S({unknown})\n+                (<{unknown}>)\n             \"#]],\n         );\n     }\n \n-    #[test]\n-    fn cant_call_named_structs() {\n-        check(\n-            r#\"\n-struct TS { x: u32, y: i32 }\n-fn main() {\n-    let s = TS(<|>);\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n     #[test]\n     fn works_for_enum_variants() {\n         check(\n@@ -612,52 +625,43 @@ fn main() {\n             expect![[r#\"\n                 A Variant\n                 ------\n-                E::A(0: i32)\n-                (<0: i32>)\n+                enum E::A(i32)\n+                (<i32>)\n             \"#]],\n         );\n     }\n \n     #[test]\n-    fn cant_call_enum_records() {\n+    fn cant_call_struct_record() {\n         check(\n             r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n+struct S { x: u32, y: i32 }\n fn main() {\n-    let a = E::C(<|>);\n+    let s = S(<|>);\n }\n \"#,\n             expect![[\"\"]],\n         );\n     }\n \n     #[test]\n-    fn fn_signature_for_macro() {\n+    fn cant_call_enum_record() {\n         check(\n             r#\"\n-/// empty macro\n-macro_rules! foo {\n-    () => {}\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n }\n \n-fn f() {\n-    foo!(<|>);\n+fn main() {\n+    let a = E::C(<|>);\n }\n \"#,\n-            expect![[r#\"\n-                empty macro\n-                ------\n-                foo!()\n-                ()\n-            \"#]],\n+            expect![[\"\"]],\n         );\n     }\n "}, {"sha": "e6b4737aac50776267d61dcb6ffd9d75126d464e", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -329,15 +329,10 @@ pub(crate) fn compute_score(\n     ty: &Type,\n     name: &str,\n ) -> Option<CompletionScore> {\n-    // FIXME: this should not fall back to string equality.\n-    let ty = &ty.display(ctx.db).to_string();\n     let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n         mark::hit!(record_field_type_match);\n         let (struct_field, _local) = ctx.sema.resolve_record_field(record_field)?;\n-        (\n-            struct_field.name(ctx.db).to_string(),\n-            struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n-        )\n+        (struct_field.name(ctx.db).to_string(), struct_field.signature_ty(ctx.db))\n     } else if let Some(active_parameter) = &ctx.active_parameter {\n         mark::hit!(active_param_type_match);\n         (active_parameter.name.clone(), active_parameter.ty.clone())"}, {"sha": "709a85f65554caed10b63e34ef2610f77dafaf29", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -149,27 +149,6 @@ impl FunctionSignature {\n             has_self_param: false,\n         })\n     }\n-\n-    pub(crate) fn from_macro(db: &RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n-        let node: ast::MacroCall = macro_def.source(db).value;\n-\n-        let params = vec![];\n-\n-        Some(FunctionSignature {\n-            kind: CallableKind::Macro,\n-            visibility: None,\n-            qualifier: Default::default(),\n-            name: node.name().map(|n| n.text().to_string()),\n-            ret_type: None,\n-            parameters: params,\n-            parameter_names: vec![],\n-            parameter_types: vec![],\n-            generic_parameters: vec![],\n-            where_predicates: vec![],\n-            doc: macro_def.docs(db),\n-            has_self_param: false,\n-        })\n-    }\n }\n \n impl From<&'_ ast::FnDef> for FunctionSignature {"}, {"sha": "2e021f032998d445fdc8b67c1f15594cde3f2f1e", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -322,15 +322,15 @@ fn get_fn_signature(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n             // FIXME: Type::as_callable is broken for closures\n-            let callable_def = sema.type_of_expr(&expr.expr()?)?.as_callable()?;\n-            match callable_def {\n-                hir::CallableDefId::FunctionId(it) => {\n+            let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db)?;\n+            match callable.kind() {\n+                hir::CallableKind::Function(it) => {\n                     Some(FunctionSignature::from_hir(sema.db, it.into()))\n                 }\n-                hir::CallableDefId::StructId(it) => {\n+                hir::CallableKind::TupleStruct(it) => {\n                     FunctionSignature::from_struct(sema.db, it.into())\n                 }\n-                hir::CallableDefId::EnumVariantId(it) => {\n+                hir::CallableKind::TupleEnumVariant(it) => {\n                     FunctionSignature::from_enum_variant(sema.db, it.into())\n                 }\n             }"}, {"sha": "447d73fd493d4e385cc95fa401d3734605f04993", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -553,21 +553,12 @@ pub(crate) fn handle_signature_help(\n     let _p = profile(\"handle_signature_help\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n     let call_info = match snap.analysis.call_info(position)? {\n-        None => return Ok(None),\n         Some(it) => it,\n+        None => return Ok(None),\n     };\n     let concise = !snap.config.call_info_full;\n-    let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n-    if concise && call_info.signature.has_self_param {\n-        active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n-    }\n-    let sig_info = to_proto::signature_information(call_info.signature, concise);\n-\n-    Ok(Some(lsp_types::SignatureHelp {\n-        signatures: vec![sig_info],\n-        active_signature: Some(0),\n-        active_parameter,\n-    }))\n+    let res = to_proto::signature_help(call_info, concise);\n+    Ok(Some(res))\n }\n \n pub(crate) fn handle_hover("}, {"sha": "43fc5284821f3b44633a5132177216ec4d5e0809", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0312fa32715ce42f134fd9f049c4df5956d042/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=ff0312fa32715ce42f134fd9f049c4df5956d042", "patch": "@@ -4,8 +4,8 @@ use std::path::{self, Path};\n use itertools::Itertools;\n use ra_db::{FileId, FileRange};\n use ra_ide::{\n-    Assist, AssistKind, CompletionItem, CompletionItemKind, Documentation, FileSystemEdit, Fold,\n-    FoldKind, FunctionSignature, Highlight, HighlightModifier, HighlightTag, HighlightedRange,\n+    Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, Documentation,\n+    FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag, HighlightedRange,\n     Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup, NavigationTarget,\n     ReferenceAccess, ResolvedAssist, Runnable, Severity, SourceChange, SourceFileEdit, TextEdit,\n };\n@@ -219,29 +219,30 @@ pub(crate) fn completion_item(\n     res\n }\n \n-pub(crate) fn signature_information(\n-    signature: FunctionSignature,\n-    concise: bool,\n-) -> lsp_types::SignatureInformation {\n-    let (label, documentation, params) = if concise {\n-        let mut params = signature.parameters;\n-        if signature.has_self_param {\n-            params.remove(0);\n-        }\n-        (params.join(\", \"), None, params)\n-    } else {\n-        (signature.to_string(), signature.doc.map(documentation), signature.parameters)\n-    };\n-\n-    let parameters: Vec<lsp_types::ParameterInformation> = params\n-        .into_iter()\n-        .map(|param| lsp_types::ParameterInformation {\n-            label: lsp_types::ParameterLabel::Simple(param),\n+pub(crate) fn signature_help(call_info: CallInfo, concise: bool) -> lsp_types::SignatureHelp {\n+    let parameters = call_info\n+        .parameter_labels()\n+        .map(|label| lsp_types::ParameterInformation {\n+            label: lsp_types::ParameterLabel::Simple(label.to_string()),\n             documentation: None,\n         })\n         .collect();\n \n-    lsp_types::SignatureInformation { label, documentation, parameters: Some(parameters) }\n+    let label = if concise { call_info.parameter_labels().join(\", \") } else { call_info.signature };\n+    let documentation = call_info.doc.map(|doc| {\n+        lsp_types::Documentation::MarkupContent(lsp_types::MarkupContent {\n+            kind: lsp_types::MarkupKind::Markdown,\n+            value: doc,\n+        })\n+    });\n+\n+    let signature =\n+        lsp_types::SignatureInformation { label, documentation, parameters: Some(parameters) };\n+    lsp_types::SignatureHelp {\n+        signatures: vec![signature],\n+        active_signature: None,\n+        active_parameter: call_info.active_parameter.map(|it| it as i64),\n+    }\n }\n \n pub(crate) fn inlay_int(line_index: &LineIndex, inlay_hint: InlayHint) -> lsp_ext::InlayHint {"}]}