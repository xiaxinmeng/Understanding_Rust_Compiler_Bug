{"sha": "729345cb97f32839bd00cb2546314865cb2a9964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOTM0NWNiOTdmMzI4MzliZDAwY2IyNTQ2MzE0ODY1Y2IyYTk5NjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-07T03:56:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-08T01:05:58Z"}, "message": "implement a chained hashmap", "tree": {"sha": "5fe2415c1e690e85eb04b667c12971eb29d60877", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fe2415c1e690e85eb04b667c12971eb29d60877"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/729345cb97f32839bd00cb2546314865cb2a9964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/729345cb97f32839bd00cb2546314865cb2a9964", "html_url": "https://github.com/rust-lang/rust/commit/729345cb97f32839bd00cb2546314865cb2a9964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/729345cb97f32839bd00cb2546314865cb2a9964/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "501c514e892b4d3a4b8ce1f89d4bd42b3f266ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/501c514e892b4d3a4b8ce1f89d4bd42b3f266ef2", "html_url": "https://github.com/rust-lang/rust/commit/501c514e892b4d3a4b8ce1f89d4bd42b3f266ef2"}], "stats": {"total": 245, "additions": 243, "deletions": 2}, "files": [{"sha": "f93e904a904a448e9d3ad29fef6992b6d8352d17", "filename": "src/libstd/map.rs", "status": "modified", "additions": 243, "deletions": 2, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/729345cb97f32839bd00cb2546314865cb2a9964/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729345cb97f32839bd00cb2546314865cb2a9964/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=729345cb97f32839bd00cb2546314865cb2a9964", "patch": "@@ -104,6 +104,242 @@ type hashmap<K, V> = obj {\n \n /* Section: Operations */\n \n+mod chained {\n+    type entry<copy K, copy V> = {\n+        hash: uint,\n+        key: K,\n+        mutable value: V,\n+        mutable next: chain<K, V>\n+    };\n+\n+    tag chain<copy K, copy V> {\n+        present(@entry<K, V>);\n+        absent;\n+    }\n+\n+    type t<copy K, copy V> = {\n+        mutable size: uint,\n+        mutable chains: [mutable chain<K,V>],\n+        hasher: hashfn<K>,\n+        eqer: eqfn<K>\n+    };\n+\n+    tag search_result<copy K, copy V> {\n+        not_found(uint);\n+        found_first(uint, @entry<K,V>);\n+        found_after(@entry<K,V>, @entry<K,V>);\n+    }\n+\n+    fn search_rem<copy K, copy V>(tbl: t<K,V>,\n+                                  k: K,\n+                                  h: uint,\n+                                  idx: uint,\n+                                  e_root: @entry<K,V>) -> search_result<K,V> {\n+        let e0 = e_root;\n+        while true {\n+            alt e0.next {\n+              absent. {\n+                ret not_found(idx);\n+              }\n+              present(e1) {\n+                let e1_key = e1.key; // Satisfy alias checker.\n+                if e1.hash == h && tbl.eqer(e1_key, k) {\n+                    ret found_after(e0, e1);\n+                } else {\n+                    e0 = e1;\n+                }\n+              }\n+            }\n+        }\n+        util::unreachable();\n+    }\n+\n+    fn search_tbl<copy K, copy V>(\n+        tbl: t<K,V>, k: K, h: uint) -> search_result<K,V> {\n+\n+        let idx = h % vec::len(tbl.chains);\n+\n+        alt tbl.chains[idx] {\n+          absent. {\n+            ret not_found(idx);\n+          }\n+          present(e) {\n+            let e_key = e.key; // Satisfy alias checker.\n+            if e.hash == h && tbl.eqer(e_key, k) {\n+                ret found_first(idx, e);\n+            } else {\n+                ret search_rem(tbl, k, h, idx, e);\n+            }\n+          }\n+        }\n+    }\n+\n+    fn insert_h<copy K, copy V>(tbl: t<K,V>, k: K, v: V, hash: uint) -> bool {\n+        // internal routine: does not update size\n+        alt search_tbl(tbl, k, hash) {\n+          not_found(idx) {\n+            let old_chain = tbl.chains[idx];\n+            tbl.chains[idx] = present(@{\n+                hash: hash,\n+                key: k,\n+                mutable value: v,\n+                mutable next: old_chain});\n+            ret true;\n+          }\n+          found_first(_, entry) {\n+            entry.value = v;\n+            ret false;\n+          }\n+          found_after(_, entry) {\n+            entry.value = v;\n+            ret false\n+          }\n+        }\n+    }\n+\n+    fn insert<copy K, copy V>(tbl: t<K,V>, k: K, v: V) -> bool {\n+        tbl.size += 1u;\n+        ret insert_h(tbl, k, v, tbl.hasher(k));\n+    }\n+\n+    fn get<copy K, copy V>(tbl: t<K,V>, k: K) -> option::t<V> {\n+        alt search_tbl(tbl, k, tbl.hasher(k)) {\n+          not_found(_) {\n+            ret option::none;\n+          }\n+\n+          found_first(_, entry) {\n+            ret option::some(entry.value);\n+          }\n+\n+          found_after(_, entry) {\n+            ret option::some(entry.value);\n+          }\n+        }\n+    }\n+\n+    fn remove<copy K, copy V>(tbl: t<K,V>, k: K) -> option::t<V> {\n+        alt search_tbl(tbl, k, tbl.hasher(k)) {\n+          not_found(_) {\n+            ret option::none;\n+          }\n+\n+          found_first(idx, entry) {\n+            tbl.chains[idx] = entry.next;\n+            ret option::some(entry.value);\n+          }\n+\n+          found_after(eprev, entry) {\n+            eprev.next = entry.next;\n+            ret option::some(entry.value);\n+          }\n+        }\n+    }\n+\n+    fn chains<copy K, copy V>(nchains: uint) -> [mutable chain<K,V>] {\n+        ret vec::init_elt_mut(absent, nchains);\n+    }\n+\n+    fn foreach_entry<copy K, copy V>(chain0: chain<K,V>,\n+                                     blk: block(@entry<K,V>)) {\n+        let chain = chain0;\n+        while true {\n+            alt chain {\n+              absent. { ret; }\n+              present(entry) {\n+                blk(entry);\n+                chain = entry.next;\n+              }\n+            }\n+        }\n+    }\n+\n+    fn foreach_chain<copy K, copy V>(chains: [const chain<K,V>],\n+                                     blk: block(@entry<K,V>)) {\n+        let i = 0u, n = vec::len(chains);\n+        while i < n {\n+            foreach_entry(chains[i], blk);\n+            i += 1u;\n+        }\n+    }\n+\n+    fn rehash<copy K, copy V>(tbl: t<K,V>) {\n+        let old_chains = tbl.chains;\n+        let n_old_chains = vec::len(old_chains);\n+        let n_new_chains: uint = uint::next_power_of_two(n_old_chains + 1u);\n+        tbl.chains = chains(n_new_chains);\n+        foreach_chain(old_chains) { |entry|\n+            insert_h(tbl, entry.key, entry.value, entry.hash);\n+        }\n+    }\n+\n+    fn items<copy K, copy V>(tbl: t<K,V>, blk: block(K,V)) {\n+        let tbl_chains = tbl.chains;  // Satisfy alias checker.\n+        foreach_chain(tbl_chains) { |entry|\n+            let key = entry.key;\n+            let value = entry.value;\n+            blk(key, value);\n+        }\n+    }\n+\n+    obj o<copy K, copy V>(tbl: @t<K,V>,\n+                          lf: float) {\n+        fn size() -> uint {\n+            ret tbl.size;\n+        }\n+\n+        fn insert(k: K, v: V) -> bool {\n+            let nchains = vec::len(tbl.chains);\n+            let load = (tbl.size + 1u as float) / (nchains as float);\n+            if load > lf {\n+                rehash(*tbl);\n+            }\n+            ret insert(*tbl, k, v);\n+        }\n+\n+        fn contains_key(k: K) -> bool {\n+            ret option::is_some(get(*tbl, k));\n+        }\n+\n+        fn get(k: K) -> V {\n+            ret option::get(get(*tbl, k));\n+        }\n+\n+        fn find(k: K) -> option::t<V> {\n+            ret get(*tbl, k);\n+        }\n+\n+        fn remove(k: K) -> option::t<V> {\n+            ret remove(*tbl, k);\n+        }\n+\n+        fn rehash() {\n+            rehash(*tbl);\n+        }\n+\n+        fn items(blk: block(K, V)) {\n+            items(*tbl, blk);\n+        }\n+\n+        fn keys(blk: block(K)) {\n+            items(*tbl) { |k, _v| blk(k) }\n+        }\n+\n+        fn values(blk: block(V)) {\n+            items(*tbl) { |_k, v| blk(v) }\n+        }\n+    }\n+\n+    fn mk<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K,V> {\n+        let initial_capacity: uint = 32u; // 2^5\n+        let t = @{mutable size: 0u,\n+                  mutable chains: chains(initial_capacity),\n+                  hasher: hasher,\n+                  eqer: eqer};\n+        ret o(t, 0.75);\n+    }\n+}\n+\n /*\n Function: mk_hashmap\n \n@@ -114,7 +350,7 @@ Parameters:\n hasher - The hash function for key type K\n eqer - The equality function for key type K\n */\n-fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n+fn mk_flat_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n     -> hashmap<K, V> {\n     let initial_capacity: uint = 32u; // 2^5\n \n@@ -134,7 +370,7 @@ fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n     // buckets before the resulting pair of hash functions no longer\n     // probes all buckets for a fixed key.  Note that hashl is made to\n     // output odd numbers (hence coprime to the number of nbkts, which\n-    // is always a power of 2), so that all buckets are probed for a\n+    // is always a power? of 2), so that all buckets are probed for a\n     // fixed key.\n \n     fn hashl(n: u32) -> u32 { ret (n >>> 16u32) * 2u32 + 1u32; }\n@@ -293,6 +529,11 @@ fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n     ret hashmap(hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n }\n \n+fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n+    -> hashmap<K, V> {\n+    ret chained::mk(hasher, eqer);\n+}\n+\n /*\n Function: new_str_hash\n "}]}