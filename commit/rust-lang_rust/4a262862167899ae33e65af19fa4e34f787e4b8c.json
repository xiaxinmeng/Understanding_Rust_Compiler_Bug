{"sha": "4a262862167899ae33e65af19fa4e34f787e4b8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMjYyODYyMTY3ODk5YWUzM2U2NWFmMTlmYTRlMzRmNzg3ZTRiOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-08T02:02:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-08T02:02:51Z"}, "message": "Auto merge of #36214 - jseyfried:stackless_expansion, r=nrc\n\nmacros: stackless expansion\n\nAfter this PR, macro expansion cannot overflow the stack unless the expanded crate is too deep to fold.\nEverything but the stackless placeholder expansion commit is also groundwork for macro modularization.\n\nr? @nrc or @eddyb", "tree": {"sha": "35f5dcf5927b8e1f7bf3a4b978f632469c28a62c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35f5dcf5927b8e1f7bf3a4b978f632469c28a62c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a262862167899ae33e65af19fa4e34f787e4b8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a262862167899ae33e65af19fa4e34f787e4b8c", "html_url": "https://github.com/rust-lang/rust/commit/4a262862167899ae33e65af19fa4e34f787e4b8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a262862167899ae33e65af19fa4e34f787e4b8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7b2232d20320dc3b4044a2aec1d51a129e7e17d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b2232d20320dc3b4044a2aec1d51a129e7e17d", "html_url": "https://github.com/rust-lang/rust/commit/a7b2232d20320dc3b4044a2aec1d51a129e7e17d"}, {"sha": "9ac91fa48b3eb479cccb5695395faed8f59ece8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ac91fa48b3eb479cccb5695395faed8f59ece8e", "html_url": "https://github.com/rust-lang/rust/commit/9ac91fa48b3eb479cccb5695395faed8f59ece8e"}], "stats": {"total": 1674, "additions": 941, "deletions": 733}, "files": [{"sha": "ba6c4b9b84c37da50462c598f4c81e909a564a8d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -555,7 +555,7 @@ pub struct ExpansionResult<'a> {\n /// Returns `None` if we're aborting after handling -W help.\n pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n                                            cstore: &CStore,\n-                                           mut krate: ast::Crate,\n+                                           krate: ast::Crate,\n                                            registry: Option<Registry>,\n                                            crate_name: &'a str,\n                                            addl_plugins: Option<Vec<String>>,\n@@ -566,21 +566,9 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n {\n     let time_passes = sess.time_passes();\n \n-    // strip before anything else because crate metadata may use #[cfg_attr]\n-    // and so macros can depend on configuration variables, such as\n-    //\n-    //   #[macro_use] #[cfg(foo)]\n-    //   mod bar { macro_rules! baz!(() => {{}}) }\n-    //\n-    // baz! should not use this definition unless foo is enabled.\n-\n-    krate = time(time_passes, \"configuration\", || {\n-        let (krate, features) =\n-            syntax::config::strip_unconfigured_items(krate, &sess.parse_sess, sess.opts.test);\n-        // these need to be set \"early\" so that expansion sees `quote` if enabled.\n-        *sess.features.borrow_mut() = features;\n-        krate\n-    });\n+    let (mut krate, features) = syntax::config::features(krate, &sess.parse_sess, sess.opts.test);\n+    // these need to be set \"early\" so that expansion sees `quote` if enabled.\n+    *sess.features.borrow_mut() = features;\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n     *sess.crate_disambiguator.borrow_mut() ="}, {"sha": "3f5b294cc0443803e658dc724010718516d07681", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 104, "deletions": 85, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -10,11 +10,10 @@\n \n use attr::HasAttrs;\n use feature_gate::{emit_feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n-use fold::Folder;\n use {fold, attr};\n use ast;\n use codemap::{Spanned, respan};\n-use parse::{ParseSess, token};\n+use parse::ParseSess;\n use ptr::P;\n \n use util::small_vector::SmallVector;\n@@ -27,8 +26,51 @@ pub struct StripUnconfigured<'a> {\n     pub features: Option<&'a Features>,\n }\n \n+// `cfg_attr`-process the crate's attributes and compute the crate's features.\n+pub fn features(mut krate: ast::Crate, sess: &ParseSess, should_test: bool)\n+                -> (ast::Crate, Features) {\n+    let features;\n+    {\n+        let mut strip_unconfigured = StripUnconfigured {\n+            config: &krate.config.clone(),\n+            should_test: should_test,\n+            sess: sess,\n+            features: None,\n+        };\n+\n+        let unconfigured_attrs = krate.attrs.clone();\n+        let err_count = sess.span_diagnostic.err_count();\n+        if let Some(attrs) = strip_unconfigured.configure(krate.attrs) {\n+            krate.attrs = attrs;\n+        } else { // the entire crate is unconfigured\n+            krate.attrs = Vec::new();\n+            krate.module.items = Vec::new();\n+            return (krate, Features::new());\n+        }\n+\n+        features = get_features(&sess.span_diagnostic, &krate.attrs);\n+\n+        // Avoid reconfiguring malformed `cfg_attr`s\n+        if err_count == sess.span_diagnostic.err_count() {\n+            strip_unconfigured.features = Some(&features);\n+            strip_unconfigured.configure(unconfigured_attrs);\n+        }\n+    }\n+\n+    (krate, features)\n+}\n+\n+macro_rules! configure {\n+    ($this:ident, $node:ident) => {\n+        match $this.configure($node) {\n+            Some(node) => node,\n+            None => return Default::default(),\n+        }\n+    }\n+}\n+\n impl<'a> StripUnconfigured<'a> {\n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+    pub fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         let node = self.process_cfg_attrs(node);\n         if self.in_cfg(node.attrs()) { Some(node) } else { None }\n     }\n@@ -123,65 +165,35 @@ impl<'a> StripUnconfigured<'a> {\n             }\n         }\n     }\n-}\n-\n-// Support conditional compilation by transforming the AST, stripping out\n-// any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(mut krate: ast::Crate, sess: &ParseSess, should_test: bool)\n-                                -> (ast::Crate, Features) {\n-    let features;\n-    {\n-        let mut strip_unconfigured = StripUnconfigured {\n-            config: &krate.config.clone(),\n-            should_test: should_test,\n-            sess: sess,\n-            features: None,\n-        };\n-\n-        let err_count = sess.span_diagnostic.err_count();\n-        let krate_attrs = strip_unconfigured.configure(krate.attrs.clone()).unwrap_or_default();\n-        features = get_features(&sess.span_diagnostic, &krate_attrs);\n-        if err_count < sess.span_diagnostic.err_count() {\n-            krate.attrs = krate_attrs.clone(); // Avoid reconfiguring malformed `cfg_attr`s\n-        }\n-\n-        strip_unconfigured.features = Some(&features);\n-        krate = strip_unconfigured.fold_crate(krate);\n-        krate.attrs = krate_attrs;\n-    }\n \n-    (krate, features)\n-}\n-\n-impl<'a> fold::Folder for StripUnconfigured<'a> {\n-    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+    pub fn configure_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n-            items: foreign_mod.items.into_iter().filter_map(|item| {\n-                self.configure(item).map(|item| fold::noop_fold_foreign_item(item, self))\n-            }).collect(),\n+            items: foreign_mod.items.into_iter().filter_map(|item| self.configure(item)).collect(),\n         }\n     }\n \n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        let fold_struct = |this: &mut Self, vdata| match vdata {\n+    fn configure_variant_data(&mut self, vdata: ast::VariantData) -> ast::VariantData {\n+        match vdata {\n             ast::VariantData::Struct(fields, id) => {\n-                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                let fields = fields.into_iter().filter_map(|field| self.configure(field));\n                 ast::VariantData::Struct(fields.collect(), id)\n             }\n             ast::VariantData::Tuple(fields, id) => {\n-                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                let fields = fields.into_iter().filter_map(|field| self.configure(field));\n                 ast::VariantData::Tuple(fields.collect(), id)\n             }\n             ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n-        };\n+        }\n+    }\n \n-        let item = match item {\n+    pub fn configure_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        match item {\n             ast::ItemKind::Struct(def, generics) => {\n-                ast::ItemKind::Struct(fold_struct(self, def), generics)\n+                ast::ItemKind::Struct(self.configure_variant_data(def), generics)\n             }\n             ast::ItemKind::Union(def, generics) => {\n-                ast::ItemKind::Union(fold_struct(self, def), generics)\n+                ast::ItemKind::Union(self.configure_variant_data(def), generics)\n             }\n             ast::ItemKind::Enum(def, generics) => {\n                 let variants = def.variants.into_iter().filter_map(|v| {\n@@ -190,7 +202,7 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n                             node: ast::Variant_ {\n                                 name: v.node.name,\n                                 attrs: v.node.attrs,\n-                                data: fold_struct(self, v.node.data),\n+                                data: self.configure_variant_data(v.node.data),\n                                 disr_expr: v.node.disr_expr,\n                             },\n                             span: v.span\n@@ -202,12 +214,19 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n                 }, generics)\n             }\n             item => item,\n-        };\n+        }\n+    }\n \n-        fold::noop_fold_item_kind(item, self)\n+    pub fn configure_expr_kind(&mut self, expr_kind: ast::ExprKind) -> ast::ExprKind {\n+        if let ast::ExprKind::Match(m, arms) = expr_kind {\n+            let arms = arms.into_iter().filter_map(|a| self.configure(a)).collect();\n+            ast::ExprKind::Match(m, arms)\n+        } else {\n+            expr_kind\n+        }\n     }\n \n-    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn configure_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.visit_stmt_or_expr_attrs(expr.attrs());\n \n         // If an expr is valid to cfg away it will have been removed by the\n@@ -222,64 +241,64 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n             self.sess.span_diagnostic.span_err(attr.span, msg);\n         }\n \n-        let expr = self.process_cfg_attrs(expr);\n-        fold_expr(self, expr)\n+        self.process_cfg_attrs(expr)\n     }\n \n-    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        self.configure(expr).map(|expr| fold_expr(self, expr))\n+    pub fn configure_stmt(&mut self, stmt: ast::Stmt) -> Option<ast::Stmt> {\n+        self.visit_stmt_or_expr_attrs(stmt.attrs());\n+        self.configure(stmt)\n     }\n+}\n \n-    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        self.visit_stmt_or_expr_attrs(stmt.attrs());\n-        self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))\n-                            .unwrap_or(SmallVector::zero())\n+impl<'a> fold::Folder for StripUnconfigured<'a> {\n+    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+        let foreign_mod = self.configure_foreign_mod(foreign_mod);\n+        fold::noop_fold_foreign_mod(foreign_mod, self)\n     }\n \n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        let item = self.configure_item_kind(item);\n+        fold::noop_fold_item_kind(item, self)\n+    }\n+\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        let mut expr = self.configure_expr(expr).unwrap();\n+        expr.node = self.configure_expr_kind(expr.node);\n+        P(fold::noop_fold_expr(expr, self))\n+    }\n+\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr).unwrap();\n+        expr.node = self.configure_expr_kind(expr.node);\n+        Some(P(fold::noop_fold_expr(expr, self)))\n+    }\n+\n+    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n+        match self.configure_stmt(stmt) {\n+            Some(stmt) => fold::noop_fold_stmt(stmt, self),\n+            None => return SmallVector::zero(),\n+        }\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        self.configure(item).map(|item| fold::noop_fold_item(item, self))\n-                            .unwrap_or(SmallVector::zero())\n+        fold::noop_fold_item(configure!(self, item), self)\n     }\n \n     fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        self.configure(item).map(|item| fold::noop_fold_impl_item(item, self))\n-                            .unwrap_or(SmallVector::zero())\n+        fold::noop_fold_impl_item(configure!(self, item), self)\n     }\n \n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        self.configure(item).map(|item| fold::noop_fold_trait_item(item, self))\n-                            .unwrap_or(SmallVector::zero())\n+        fold::noop_fold_trait_item(configure!(self, item), self)\n     }\n \n-    fn fold_interpolated(&mut self, nt: token::Nonterminal) -> token::Nonterminal {\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         // Don't configure interpolated AST (c.f. #34171).\n         // Interpolated AST will get configured once the surrounding tokens are parsed.\n-        nt\n+        mac\n     }\n }\n \n-fn fold_expr(folder: &mut StripUnconfigured, expr: P<ast::Expr>) -> P<ast::Expr> {\n-    expr.map(|ast::Expr {id, span, node, attrs}| {\n-        fold::noop_fold_expr(ast::Expr {\n-            id: id,\n-            node: match node {\n-                ast::ExprKind::Match(m, arms) => {\n-                    ast::ExprKind::Match(m, arms.into_iter()\n-                                        .filter_map(|a| folder.configure(a))\n-                                        .collect())\n-                }\n-                _ => node\n-            },\n-            span: span,\n-            attrs: attrs,\n-        }, folder)\n-    })\n-}\n-\n fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }"}, {"sha": "edd38ea23e2fd9ecee40ec5407d38f6587b1874c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 90, "deletions": 101, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -24,12 +24,14 @@ use parse::parser;\n use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n use ptr::P;\n+use std_inject;\n use util::small_vector::SmallVector;\n use util::lev_distance::find_best_match_for_name;\n use fold::Folder;\n use feature_gate;\n \n use std::collections::{HashMap, HashSet};\n+use std::path::PathBuf;\n use std::rc::Rc;\n use tokenstream;\n \n@@ -90,16 +92,6 @@ impl Annotatable {\n             _ => panic!(\"expected Item\")\n         }\n     }\n-\n-    pub fn fold_with<F: Folder>(self, folder: &mut F) -> SmallVector<Self> {\n-        match self {\n-            Annotatable::Item(item) => folder.fold_item(item).map(Annotatable::Item),\n-            Annotatable::ImplItem(item) =>\n-                folder.fold_impl_item(item.unwrap()).map(|item| Annotatable::ImplItem(P(item))),\n-            Annotatable::TraitItem(item) =>\n-                folder.fold_trait_item(item.unwrap()).map(|item| Annotatable::TraitItem(P(item))),\n-        }\n-    }\n }\n \n // A more flexible ItemDecorator.\n@@ -472,19 +464,6 @@ pub enum SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n-pub struct BlockInfo {\n-    /// Should macros escape from this scope?\n-    pub macros_escape: bool,\n-}\n-\n-impl BlockInfo {\n-    pub fn new() -> BlockInfo {\n-        BlockInfo {\n-            macros_escape: false,\n-        }\n-    }\n-}\n-\n /// The base map of methods for expanding syntax extension\n /// AST nodes into full ASTs\n fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n@@ -595,40 +574,29 @@ pub struct ExtCtxt<'a> {\n     pub crate_root: Option<&'static str>,\n     pub loader: &'a mut MacroLoader,\n \n-    pub mod_path: Vec<ast::Ident> ,\n     pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n     pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n     pub recursion_count: usize,\n-\n-    pub filename: Option<String>,\n-    pub mod_path_stack: Vec<InternedString>,\n-    pub in_block: bool,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n                loader: &'a mut MacroLoader)\n                -> ExtCtxt<'a> {\n-        let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n+            syntax_env: initial_syntax_expander_table(&ecfg),\n             parse_sess: parse_sess,\n             cfg: cfg,\n             backtrace: NO_EXPANSION,\n-            mod_path: Vec::new(),\n             ecfg: ecfg,\n             crate_root: None,\n             exported_macros: Vec::new(),\n             loader: loader,\n-            syntax_env: env,\n             derive_modes: HashMap::new(),\n             recursion_count: 0,\n-\n-            filename: None,\n-            mod_path_stack: Vec::new(),\n-            in_block: false,\n         }\n     }\n \n@@ -677,16 +645,7 @@ impl<'a> ExtCtxt<'a> {\n         last_macro.expect(\"missing expansion backtrace\")\n     }\n \n-    pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n-    pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n-    pub fn mod_path(&self) -> Vec<ast::Ident> {\n-        let mut v = Vec::new();\n-        v.push(token::str_to_ident(&self.ecfg.crate_name));\n-        v.extend(self.mod_path.iter().cloned());\n-        return v;\n-    }\n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n-        self.recursion_count += 1;\n         if self.recursion_count > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n@@ -700,17 +659,7 @@ impl<'a> ExtCtxt<'a> {\n             callee: ei.callee\n         });\n     }\n-    pub fn bt_pop(&mut self) {\n-        match self.backtrace {\n-            NO_EXPANSION => self.bug(\"tried to pop without a push\"),\n-            expn_id => {\n-                self.recursion_count -= 1;\n-                self.backtrace = self.codemap().with_expn_info(expn_id, |expn_info| {\n-                    expn_info.map_or(NO_EXPANSION, |ei| ei.call_site.expn_id)\n-                });\n-            }\n-        }\n-    }\n+    pub fn bt_pop(&mut self) {}\n \n     pub fn insert_macro(&mut self, def: ast::MacroDef) {\n         if def.export {\n@@ -829,6 +778,28 @@ impl<'a> ExtCtxt<'a> {\n             }\n         }\n     }\n+\n+    pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n+        if std_inject::no_core(&krate) {\n+            self.crate_root = None;\n+        } else if std_inject::no_std(&krate) {\n+            self.crate_root = Some(\"core\");\n+        } else {\n+            self.crate_root = Some(\"std\");\n+        }\n+\n+        for (name, extension) in user_exts {\n+            self.syntax_env.insert(name, extension);\n+        }\n+\n+        self.syntax_env.current_module = Module(0);\n+        let mut paths = ModulePaths {\n+            mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n+            directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n+        };\n+        paths.directory.pop();\n+        self.syntax_env.module_data[0].paths = Rc::new(paths);\n+    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,\n@@ -915,79 +886,97 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n ///\n /// This environment maps Names to SyntaxExtensions.\n pub struct SyntaxEnv {\n-    chain: Vec<MapChainFrame>,\n+    module_data: Vec<ModuleData>,\n+    pub current_module: Module,\n+\n     /// All bang-style macro/extension names\n     /// encountered so far; to be used for diagnostics in resolve\n     pub names: HashSet<Name>,\n }\n \n-// impl question: how to implement it? Initially, the\n-// env will contain only macros, so it might be painful\n-// to add an empty frame for every context. Let's just\n-// get it working, first....\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct Module(u32);\n \n-// NB! the mutability of the underlying maps means that\n-// if expansion is out-of-order, a deeper scope may be\n-// able to refer to a macro that was added to an enclosing\n-// scope lexically later than the deeper scope.\n+struct ModuleData {\n+    parent: Module,\n+    paths: Rc<ModulePaths>,\n+    macros: HashMap<Name, Rc<SyntaxExtension>>,\n+    macros_escape: bool,\n+    in_block: bool,\n+}\n \n-struct MapChainFrame {\n-    info: BlockInfo,\n-    map: HashMap<Name, Rc<SyntaxExtension>>,\n+#[derive(Clone)]\n+pub struct ModulePaths {\n+    pub mod_path: Vec<ast::Ident>,\n+    pub directory: PathBuf,\n }\n \n impl SyntaxEnv {\n     fn new() -> SyntaxEnv {\n-        let mut map = SyntaxEnv { chain: Vec::new() , names: HashSet::new()};\n-        map.push_frame();\n-        map\n+        let mut env = SyntaxEnv {\n+            current_module: Module(0),\n+            module_data: Vec::new(),\n+            names: HashSet::new(),\n+        };\n+        let paths = Rc::new(ModulePaths { mod_path: Vec::new(), directory: PathBuf::new() });\n+        env.add_module(false, false, paths);\n+        env\n     }\n \n-    pub fn push_frame(&mut self) {\n-        self.chain.push(MapChainFrame {\n-            info: BlockInfo::new(),\n-            map: HashMap::new(),\n-        });\n+    fn data(&self, module: Module) -> &ModuleData {\n+        &self.module_data[module.0 as usize]\n     }\n \n-    pub fn pop_frame(&mut self) {\n-        assert!(self.chain.len() > 1, \"too many pops on MapChain!\");\n-        self.chain.pop();\n+    pub fn paths(&self) -> Rc<ModulePaths> {\n+        self.data(self.current_module).paths.clone()\n     }\n \n-    fn find_escape_frame(&mut self) -> &mut MapChainFrame {\n-        for (i, frame) in self.chain.iter_mut().enumerate().rev() {\n-            if !frame.info.macros_escape || i == 0 {\n-                return frame\n-            }\n-        }\n-        unreachable!()\n+    pub fn in_block(&self) -> bool {\n+        self.data(self.current_module).in_block\n     }\n \n-    pub fn find(&self, k: Name) -> Option<Rc<SyntaxExtension>> {\n-        for frame in self.chain.iter().rev() {\n-            if let Some(v) = frame.map.get(&k) {\n-                return Some(v.clone());\n+    pub fn add_module(&mut self, macros_escape: bool, in_block: bool, paths: Rc<ModulePaths>)\n+                      -> Module {\n+        let data = ModuleData {\n+            parent: self.current_module,\n+            paths: paths,\n+            macros: HashMap::new(),\n+            macros_escape: macros_escape,\n+            in_block: in_block,\n+        };\n+\n+        self.module_data.push(data);\n+        Module(self.module_data.len() as u32 - 1)\n+    }\n+\n+    pub fn find(&self, name: Name) -> Option<Rc<SyntaxExtension>> {\n+        let mut module = self.current_module;\n+        let mut module_data;\n+        loop {\n+            module_data = self.data(module);\n+            if let Some(ext) = module_data.macros.get(&name) {\n+                return Some(ext.clone());\n             }\n+            if module == module_data.parent {\n+                return None;\n+            }\n+            module = module_data.parent;\n         }\n-        None\n     }\n \n-    pub fn insert(&mut self, k: Name, v: SyntaxExtension) {\n-        if let NormalTT(..) = v {\n-            self.names.insert(k);\n+    pub fn insert(&mut self, name: Name, ext: SyntaxExtension) {\n+        if let NormalTT(..) = ext {\n+            self.names.insert(name);\n         }\n-        self.find_escape_frame().map.insert(k, Rc::new(v));\n-    }\n \n-    pub fn info(&mut self) -> &mut BlockInfo {\n-        let last_chain_index = self.chain.len() - 1;\n-        &mut self.chain[last_chain_index].info\n+        let mut module = self.current_module;\n+        while self.data(module).macros_escape {\n+            module = self.data(module).parent;\n+        }\n+        self.module_data[module.0 as usize].macros.insert(name, Rc::new(ext));\n     }\n \n     pub fn is_crate_root(&mut self) -> bool {\n-        // The first frame is pushed in `SyntaxEnv::new()` and the second frame is\n-        // pushed when folding the crate root pseudo-module (c.f. noop_fold_crate).\n-        self.chain.len() <= 2\n+        self.current_module == Module(0)\n     }\n }"}, {"sha": "4715eda8374900fb488ea6d6e5522b44a7d0d4ee", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 533, "deletions": 492, "changes": 1025, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use ast::{Block, Crate, Ident, Mac_, PatKind};\n-use ast::{MacStmtStyle, Stmt, StmtKind, ItemKind};\n+use ast::{MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n+use ext::placeholders::{self, placeholder, PlaceholderExpander};\n use attr::{self, HasAttrs};\n-use codemap::{dummy_spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n@@ -24,188 +25,348 @@ use parse::token::{intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n-use visit;\n-use visit::Visitor;\n-use std_inject;\n \n-// A trait for AST nodes and AST node lists into which macro invocations may expand.\n-trait MacroGenerable: Sized {\n-    // Expand the given MacResult using its appropriate `make_*` method.\n-    fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self>;\n+use std::mem;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+\n+macro_rules! expansions {\n+    ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n+            $(.$fold:ident)*  $(lift .$fold_elt:ident)*;)*) => {\n+        #[derive(Copy, Clone)]\n+        pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n+        pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n+\n+        impl ExpansionKind {\n+            fn name(self) -> &'static str {\n+                match self {\n+                    ExpansionKind::OptExpr => \"expression\",\n+                    $( ExpansionKind::$kind => $kind_name, )*\n+                }\n+            }\n \n-    // Fold this node or list of nodes using the given folder.\n-    fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n-    fn visit_with<V: Visitor>(&self, visitor: &mut V);\n+            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<Expansion> {\n+                match self {\n+                    ExpansionKind::OptExpr => result.make_expr().map(Some).map(Expansion::OptExpr),\n+                    $( ExpansionKind::$kind => result.$make().map(Expansion::$kind), )*\n+                }\n+            }\n+        }\n \n-    // The user-friendly name of the node type (e.g. \"expression\", \"item\", etc.) for diagnostics.\n-    fn kind_name() -> &'static str;\n+        impl Expansion {\n+            pub fn make_opt_expr(self) -> Option<P<ast::Expr>> {\n+                match self {\n+                    Expansion::OptExpr(expr) => expr,\n+                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                }\n+            }\n+            $( pub fn $make(self) -> $ty {\n+                match self {\n+                    Expansion::$kind(ast) => ast,\n+                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                }\n+            } )*\n+\n+            pub fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n+                use self::Expansion::*;\n+                match self {\n+                    OptExpr(expr) => OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n+                    $($( $kind(ast) => $kind(folder.$fold(ast)), )*)*\n+                    $($( $kind(ast) => {\n+                        $kind(ast.into_iter().flat_map(|ast| folder.$fold_elt(ast)).collect())\n+                    }, )*)*\n+                }\n+            }\n+        }\n \n-    // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n-    fn dummy(span: Span) -> Self {\n-        Self::make_with(DummyResult::any(span)).unwrap()\n+        impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n+            fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+                self.expand(Expansion::OptExpr(Some(expr))).make_opt_expr()\n+            }\n+            $($(fn $fold(&mut self, node: $ty) -> $ty {\n+                self.expand(Expansion::$kind(node)).$make()\n+            })*)*\n+            $($(fn $fold_elt(&mut self, node: $ty_elt) -> $ty {\n+                self.expand(Expansion::$kind(SmallVector::one(node))).$make()\n+            })*)*\n+        }\n     }\n }\n \n-macro_rules! impl_macro_generable {\n-    ($($ty:ty: $kind_name:expr, .$make:ident,\n-               $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n-               $(.$visit:ident)* $(lift .$visit_elt:ident)*;)*) => { $(\n-        impl MacroGenerable for $ty {\n-            fn kind_name() -> &'static str { $kind_name }\n-            fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> { result.$make() }\n-            fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n-                $( folder.$fold(self) )*\n-                $( self.into_iter().flat_map(|item| folder. $fold_elt (item)).collect() )*\n-            }\n-            fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n-                $( visitor.$visit(self) )*\n-                $( for item in self.as_slice() { visitor. $visit_elt (item) } )*\n-            }\n+expansions! {\n+    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr;\n+    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat;\n+    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty;\n+    Stmts: SmallVector<ast::Stmt> [SmallVector, ast::Stmt],\n+        \"statement\",  .make_stmts,       lift .fold_stmt;\n+    Items: SmallVector<P<ast::Item>> [SmallVector, P<ast::Item>],\n+        \"item\",       .make_items,       lift .fold_item;\n+    TraitItems: SmallVector<ast::TraitItem> [SmallVector, ast::TraitItem],\n+        \"trait item\", .make_trait_items, lift .fold_trait_item;\n+    ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n+        \"impl item\",  .make_impl_items,  lift .fold_impl_item;\n+}\n+\n+impl ExpansionKind {\n+    fn dummy(self, span: Span) -> Expansion {\n+        self.make_from(DummyResult::any(span)).unwrap()\n+    }\n+\n+    fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n+        let items = items.into_iter();\n+        match self {\n+            ExpansionKind::Items =>\n+                Expansion::Items(items.map(Annotatable::expect_item).collect()),\n+            ExpansionKind::ImplItems =>\n+                Expansion::ImplItems(items.map(Annotatable::expect_impl_item).collect()),\n+            ExpansionKind::TraitItems =>\n+                Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n+            _ => unreachable!(),\n         }\n-    )* }\n+    }\n }\n \n-impl_macro_generable! {\n-    P<ast::Expr>: \"expression\", .make_expr, .fold_expr, .visit_expr;\n-    P<ast::Pat>:  \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n-    P<ast::Ty>:   \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n-    SmallVector<ast::Stmt>: \"statement\", .make_stmts, lift .fold_stmt, lift .visit_stmt;\n-    SmallVector<P<ast::Item>>: \"item\",   .make_items, lift .fold_item, lift .visit_item;\n-    SmallVector<ast::TraitItem>:\n-        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n-    SmallVector<ast::ImplItem>:\n-        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n+pub struct Invocation {\n+    kind: InvocationKind,\n+    expansion_kind: ExpansionKind,\n+    mark: Mark,\n+    module: Module,\n+    backtrace: ExpnId,\n+    depth: usize,\n }\n \n-impl MacroGenerable for Option<P<ast::Expr>> {\n-    fn kind_name() -> &'static str { \"expression\" }\n-    fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> {\n-        result.make_expr().map(Some)\n+enum InvocationKind {\n+    Bang {\n+        attrs: Vec<ast::Attribute>,\n+        mac: ast::Mac,\n+        ident: Option<Ident>,\n+        span: Span,\n+    },\n+    Attr {\n+        attr: ast::Attribute,\n+        item: Annotatable,\n+    },\n+}\n+\n+pub struct MacroExpander<'a, 'b:'a> {\n+    pub cx: &'a mut ExtCtxt<'b>,\n+    pub single_step: bool,\n+    pub keep_macs: bool,\n+}\n+\n+impl<'a, 'b> MacroExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>,\n+               single_step: bool,\n+               keep_macs: bool) -> MacroExpander<'a, 'b> {\n+        MacroExpander {\n+            cx: cx,\n+            single_step: single_step,\n+            keep_macs: keep_macs\n+        }\n     }\n-    fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n-        self.and_then(|expr| folder.fold_opt_expr(expr))\n+\n+    fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+        let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+\n+        let items = Expansion::Items(SmallVector::many(krate.module.items));\n+        krate.module.items = self.expand(items).make_items().into();\n+        krate.exported_macros = self.cx.exported_macros.clone();\n+\n+        if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n+            self.cx.parse_sess.span_diagnostic.abort_if_errors();\n+        }\n+\n+        krate\n     }\n-    fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n-        self.as_ref().map(|expr| visitor.visit_expr(expr));\n+\n+    // Fully expand all the invocations in `expansion`.\n+    fn expand(&mut self, expansion: Expansion) -> Expansion {\n+        self.cx.recursion_count = 0;\n+        let (expansion, mut invocations) = self.collect_invocations(expansion);\n+        invocations.reverse();\n+\n+        let mut expansions = vec![vec![(0, expansion)]];\n+        while let Some(invoc) = invocations.pop() {\n+            let Invocation { mark, module, depth, backtrace, .. } = invoc;\n+            self.cx.syntax_env.current_module = module;\n+            self.cx.recursion_count = depth;\n+            self.cx.backtrace = backtrace;\n+\n+            let expansion = self.expand_invoc(invoc);\n+\n+            self.cx.syntax_env.current_module = module;\n+            self.cx.recursion_count = depth + 1;\n+            let (expansion, new_invocations) = self.collect_invocations(expansion);\n+\n+            if expansions.len() == depth {\n+                expansions.push(Vec::new());\n+            }\n+            expansions[depth].push((mark.as_u32(), expansion));\n+            if !self.single_step {\n+                invocations.extend(new_invocations.into_iter().rev());\n+            }\n+        }\n+\n+        let mut placeholder_expander = PlaceholderExpander::new();\n+        while let Some(expansions) = expansions.pop() {\n+            for (mark, expansion) in expansions.into_iter().rev() {\n+                let expansion = expansion.fold_with(&mut placeholder_expander);\n+                placeholder_expander.add(mark, expansion);\n+            }\n+        }\n+\n+        placeholder_expander.remove(0)\n+    }\n+\n+    fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n+        let crate_config = mem::replace(&mut self.cx.cfg, Vec::new());\n+        let result = {\n+            let mut collector = InvocationCollector {\n+                cfg: StripUnconfigured {\n+                    config: &crate_config,\n+                    should_test: self.cx.ecfg.should_test,\n+                    sess: self.cx.parse_sess,\n+                    features: self.cx.ecfg.features,\n+                },\n+                cx: self.cx,\n+                invocations: Vec::new(),\n+            };\n+            (expansion.fold_with(&mut collector), collector.invocations)\n+        };\n+\n+        self.cx.cfg = crate_config;\n+        result\n     }\n-}\n \n-pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    match expr.node {\n-        // expr_mac should really be expr_ext or something; it's the\n-        // entry-point for all syntax extensions.\n-        ast::ExprKind::Mac(mac) => {\n-            return expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld);\n+    fn expand_invoc(&mut self, invoc: Invocation) -> Expansion {\n+        match invoc.kind {\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc),\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc),\n         }\n-        _ => P(noop_fold_expr(expr, fld)),\n     }\n-}\n \n-struct MacroScopePlaceholder;\n-impl MacResult for MacroScopePlaceholder {\n-    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n-        Some(SmallVector::one(P(ast::Item {\n-            ident: keywords::Invalid.ident(),\n-            attrs: Vec::new(),\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::ItemKind::Mac(dummy_spanned(ast::Mac_ {\n-                path: ast::Path { span: syntax_pos::DUMMY_SP, global: false, segments: Vec::new() },\n-                tts: Vec::new(),\n-            })),\n-            vis: ast::Visibility::Inherited,\n-            span: syntax_pos::DUMMY_SP,\n-        })))\n+    fn expand_attr_invoc(&mut self, invoc: Invocation) -> Expansion {\n+        let Invocation { expansion_kind: kind, .. } = invoc;\n+        let (attr, item) = match invoc.kind {\n+            InvocationKind::Attr { attr, item } => (attr, item),\n+            _ => unreachable!(),\n+        };\n+\n+        let extension = match self.cx.syntax_env.find(intern(&attr.name())) {\n+            Some(extension) => extension,\n+            None => unreachable!(),\n+        };\n+\n+        attr::mark_used(&attr);\n+        self.cx.bt_push(ExpnInfo {\n+            call_site: attr.span,\n+            callee: NameAndSpan {\n+                format: MacroAttribute(intern(&attr.name())),\n+                span: Some(attr.span),\n+                allow_internal_unstable: false,\n+            }\n+        });\n+\n+        match *extension {\n+            MultiModifier(ref mac) => {\n+                let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n+                kind.expect_from_annotatables(item)\n+            }\n+            MultiDecorator(ref mac) => {\n+                let mut items = Vec::new();\n+                mac.expand(self.cx, attr.span, &attr.node.value, &item,\n+                           &mut |item| items.push(item));\n+                items.push(item);\n+                kind.expect_from_annotatables(items)\n+            }\n+            _ => unreachable!(),\n+        }\n     }\n-}\n \n-/// Expand a macro invocation. Returns the result of expansion.\n-fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attribute>, span: Span,\n-                       fld: &mut MacroExpander) -> T\n-    where T: MacroGenerable,\n-{\n-    // It would almost certainly be cleaner to pass the whole macro invocation in,\n-    // rather than pulling it apart and marking the tts and the ctxt separately.\n-    let Mac_ { path, tts, .. } = mac.node;\n-    let mark = Mark::fresh();\n-\n-    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mark,\n-                      attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n-                      -> Option<Box<MacResult + 'a>> {\n+    /// Expand a macro invocation. Returns the result of expansion.\n+    fn expand_bang_invoc(&mut self, invoc: Invocation) -> Expansion {\n+        let Invocation { mark, expansion_kind: kind, .. } = invoc;\n+        let (attrs, mac, ident, span) = match invoc.kind {\n+            InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n+            _ => unreachable!(),\n+        };\n+        let Mac_ { path, tts, .. } = mac.node;\n+\n         // Detect use of feature-gated or invalid attributes on macro invoations\n         // since they will not be detected after macro expansion.\n         for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n-                                          &fld.cx.parse_sess.codemap(),\n-                                          &fld.cx.ecfg.features.unwrap());\n+            feature_gate::check_attribute(&attr, &self.cx.parse_sess.span_diagnostic,\n+                                          &self.cx.parse_sess.codemap(),\n+                                          &self.cx.ecfg.features.unwrap());\n         }\n \n         if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n-            fld.cx.span_err(path.span, \"expected macro name without module separators\");\n-            return None;\n+            self.cx.span_err(path.span, \"expected macro name without module separators\");\n+            return kind.dummy(span);\n         }\n \n         let extname = path.segments[0].identifier.name;\n-        let extension = if let Some(extension) = fld.cx.syntax_env.find(extname) {\n+        let extension = if let Some(extension) = self.cx.syntax_env.find(extname) {\n             extension\n         } else {\n-            let mut err = fld.cx.struct_span_err(path.span,\n-                                                 &format!(\"macro undefined: '{}!'\", &extname));\n-            fld.cx.suggest_macro_name(&extname.as_str(), &mut err);\n+            let mut err =\n+                self.cx.struct_span_err(path.span, &format!(\"macro undefined: '{}!'\", &extname));\n+            self.cx.suggest_macro_name(&extname.as_str(), &mut err);\n             err.emit();\n-            return None;\n+            return kind.dummy(span);\n         };\n \n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n-        match *extension {\n+        let opt_expanded = match *extension {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n-                    fld.cx.span_err(path.span, &msg);\n-                    return None;\n+                    self.cx.span_err(path.span, &msg);\n+                    return kind.dummy(span);\n                 }\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: call_site,\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(extname),\n                         span: exp_span,\n                         allow_internal_unstable: allow_internal_unstable,\n                     },\n                 });\n \n-                Some(expandfun.expand(fld.cx, call_site, &marked_tts))\n+                kind.make_from(expandfun.expand(self.cx, span, &marked_tts))\n             }\n \n             IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n                 if ident.name == keywords::Invalid.name() {\n-                    fld.cx.span_err(path.span,\n+                    self.cx.span_err(path.span,\n                                     &format!(\"macro {}! expects an ident argument\", extname));\n-                    return None;\n+                    return kind.dummy(span);\n                 };\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: call_site,\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(extname),\n                         span: tt_span,\n                         allow_internal_unstable: allow_internal_unstable,\n                     }\n                 });\n \n-                Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n+                kind.make_from(expander.expand(self.cx, span, ident, marked_tts))\n             }\n \n             MacroRulesTT => {\n                 if ident.name == keywords::Invalid.name() {\n-                    fld.cx.span_err(path.span,\n+                    self.cx.span_err(path.span,\n                                     &format!(\"macro {}! expects an ident argument\", extname));\n-                    return None;\n+                    return kind.dummy(span);\n                 };\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: call_site,\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(extname),\n                         span: None,\n@@ -218,7 +379,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                 let def = ast::MacroDef {\n                     ident: ident,\n                     id: ast::DUMMY_NODE_ID,\n-                    span: call_site,\n+                    span: span,\n                     imported_from: None,\n                     use_locally: true,\n                     body: marked_tts,\n@@ -227,427 +388,332 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     attrs: attrs,\n                 };\n \n-                fld.cx.insert_macro(def.clone());\n+                self.cx.insert_macro(def.clone());\n \n-                // macro_rules! has a side effect, but expands to nothing.\n                 // If keep_macs is true, expands to a MacEager::items instead.\n-                if fld.keep_macs {\n-                    Some(MacEager::items(SmallVector::one(P(ast::Item {\n-                        ident: def.ident,\n-                        attrs: def.attrs.clone(),\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: ast::ItemKind::Mac(ast::Mac {\n-                            span: def.span,\n-                            node: ast::Mac_ {\n-                                path: path.clone(),\n-                                tts: def.body.clone(),\n-                            }\n-                        }),\n-                        vis: ast::Visibility::Inherited,\n-                        span: def.span,\n-                    }))))\n+                if self.keep_macs {\n+                    Some(placeholders::reconstructed_macro_rules(&def, &path))\n                 } else {\n-                    Some(Box::new(MacroScopePlaceholder))\n+                    Some(placeholders::macro_scope_placeholder())\n                 }\n             }\n \n             MultiDecorator(..) | MultiModifier(..) => {\n-                fld.cx.span_err(path.span,\n-                                &format!(\"`{}` can only be used in attributes\", extname));\n-                None\n+                self.cx.span_err(path.span,\n+                                 &format!(\"`{}` can only be used in attributes\", extname));\n+                return kind.dummy(span);\n             }\n-        }\n-    }\n+        };\n \n-    let opt_expanded = T::make_with(match mac_result(&path, ident, tts, mark, attrs, span, fld) {\n-        Some(result) => result,\n-        None => return T::dummy(span),\n-    });\n-\n-    let expanded = if let Some(expanded) = opt_expanded {\n-        expanded\n-    } else {\n-        let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                          name = path.segments[0].identifier.name, kind = T::kind_name());\n-        fld.cx.span_err(path.span, &msg);\n-        return T::dummy(span);\n-    };\n-\n-    let marked = expanded.fold_with(&mut Marker { mark: mark, expn_id: Some(fld.cx.backtrace()) });\n-    let configured = marked.fold_with(&mut fld.strip_unconfigured());\n-    fld.load_macros(&configured);\n-\n-    let fully_expanded = if fld.single_step {\n-        configured\n-    } else {\n-        configured.fold_with(fld)\n-    };\n-\n-    fld.cx.bt_pop();\n-    fully_expanded\n-}\n+        let expanded = if let Some(expanded) = opt_expanded {\n+            expanded\n+        } else {\n+            let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n+                              name = path.segments[0].identifier.name, kind = kind.name());\n+            self.cx.span_err(path.span, &msg);\n+            return kind.dummy(span);\n+        };\n \n-// eval $e with a new exts frame.\n-// must be a macro so that $e isn't evaluated too early.\n-macro_rules! with_exts_frame {\n-    ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n-    ({$extsboxexpr.push_frame();\n-      $extsboxexpr.info().macros_escape = $macros_escape;\n-      let result = $e;\n-      $extsboxexpr.pop_frame();\n-      result\n-     })\n+        expanded.fold_with(&mut Marker {\n+            mark: mark,\n+            expn_id: Some(self.cx.backtrace()),\n+        })\n+    }\n }\n \n-// When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n-                   -> SmallVector<P<ast::Item>> {\n-    expand_annotatable(Annotatable::Item(it), fld)\n-        .into_iter().map(|i| i.expect_item()).collect()\n+struct InvocationCollector<'a, 'b: 'a> {\n+    cx: &'a mut ExtCtxt<'b>,\n+    cfg: StripUnconfigured<'a>,\n+    invocations: Vec<Invocation>,\n }\n \n-// does this attribute list contain \"macro_use\" ?\n-fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n-    for attr in attrs {\n-        let mut is_use = attr.check_name(\"macro_use\");\n-        if attr.check_name(\"macro_escape\") {\n-            let mut err =\n-                fld.cx.struct_span_warn(attr.span,\n-                                        \"macro_escape is a deprecated synonym for macro_use\");\n-            is_use = true;\n-            if let ast::AttrStyle::Inner = attr.node.style {\n-                err.help(\"consider an outer attribute, \\\n-                          #[macro_use] mod ...\").emit();\n-            } else {\n-                err.emit();\n-            }\n-        };\n-\n-        if is_use {\n-            if !attr.is_word() {\n-              fld.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n-            }\n-            return true;\n+macro_rules! fully_configure {\n+    ($this:ident, $node:ident, $noop_fold:ident) => {\n+        match $noop_fold($node, &mut $this.cfg).pop() {\n+            Some(node) => node,\n+            None => return SmallVector::zero(),\n         }\n     }\n-    false\n }\n \n-/// Expand a stmt\n-fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n-    let (mac, style, attrs) = match stmt.node {\n-        StmtKind::Mac(mac) => mac.unwrap(),\n-        _ => return noop_fold_stmt(stmt, fld)\n-    };\n-\n-    let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac, None, attrs.into(), stmt.span, fld);\n-\n-    // If this is a macro invocation with a semicolon, then apply that\n-    // semicolon to the final statement produced by expansion.\n-    if style == MacStmtStyle::Semicolon {\n-        if let Some(stmt) = fully_expanded.pop() {\n-            fully_expanded.push(stmt.add_trailing_semicolon());\n-        }\n+impl<'a, 'b> InvocationCollector<'a, 'b> {\n+    fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n+        let mark = Mark::fresh();\n+        self.invocations.push(Invocation {\n+            kind: kind,\n+            expansion_kind: expansion_kind,\n+            mark: mark,\n+            module: self.cx.syntax_env.current_module,\n+            backtrace: self.cx.backtrace,\n+            depth: self.cx.recursion_count,\n+        });\n+        placeholder(expansion_kind, mark.as_u32())\n     }\n \n-    fully_expanded\n-}\n+    fn collect_bang(\n+        &mut self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind,\n+    ) -> Expansion {\n+        self.collect(kind, InvocationKind::Bang { attrs: attrs, mac: mac, ident: None, span: span })\n+    }\n \n-fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n-    match p.node {\n-        PatKind::Mac(_) => {}\n-        _ => return noop_fold_pat(p, fld)\n+    fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n+                    -> Expansion {\n+        self.collect(kind, InvocationKind::Attr { attr: attr, item: item })\n     }\n-    p.and_then(|ast::Pat {node, span, ..}| {\n-        match node {\n-            PatKind::Mac(mac) => expand_mac_invoc(mac, None, Vec::new(), span, fld),\n-            _ => unreachable!()\n-        }\n-    })\n-}\n \n-fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n-    match a {\n-        Annotatable::Item(it) => match it.node {\n-            ast::ItemKind::Mac(..) => {\n-                if match it.node {\n-                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n-                    _ => unreachable!(),\n-                } {\n-                    return SmallVector::one(Annotatable::Item(it));\n+    // If `item` is an attr invocation, remove and return the macro attribute.\n+    fn classify_item<T: HasAttrs>(&self, mut item: T) -> (T, Option<ast::Attribute>) {\n+        let mut attr = None;\n+        item = item.map_attrs(|mut attrs| {\n+            for i in 0..attrs.len() {\n+                if let Some(extension) = self.cx.syntax_env.find(intern(&attrs[i].name())) {\n+                    match *extension {\n+                        MultiModifier(..) | MultiDecorator(..) => {\n+                            attr = Some(attrs.remove(i));\n+                            break;\n+                        }\n+                        _ => {}\n+                    }\n                 }\n-                it.and_then(|it| match it.node {\n-                    ItemKind::Mac(mac) =>\n-                        expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),\n-                    _ => unreachable!(),\n-                })\n             }\n-            ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n-                let valid_ident =\n-                    it.ident.name != keywords::Invalid.name();\n-\n-                if valid_ident {\n-                    fld.cx.mod_push(it.ident);\n-                }\n-                let macro_use = contains_macro_use(fld, &it.attrs);\n-                let result = with_exts_frame!(fld.cx.syntax_env,\n-                                              macro_use,\n-                                              noop_fold_item(it, fld));\n-                if valid_ident {\n-                    fld.cx.mod_pop();\n+            attrs\n+        });\n+        (item, attr)\n+    }\n+\n+    // does this attribute list contain \"macro_use\" ?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            let mut is_use = attr.check_name(\"macro_use\");\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.cx.struct_span_warn(attr.span, msg);\n+                is_use = true;\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n                 }\n-                result\n-            },\n-            _ => noop_fold_item(it, fld),\n-        }.into_iter().map(|i| Annotatable::Item(i)).collect(),\n+            };\n \n-        Annotatable::TraitItem(it) => {\n-            expand_trait_item(it.unwrap(), fld).into_iter().\n-                map(|it| Annotatable::TraitItem(P(it))).collect()\n+            if is_use {\n+                if !attr.is_word() {\n+                    self.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+                }\n+                return true;\n+            }\n         }\n+        false\n+    }\n \n-        Annotatable::ImplItem(ii) => {\n-            expand_impl_item(ii.unwrap(), fld).into_iter().\n-                map(|ii| Annotatable::ImplItem(P(ii))).collect()\n-        }\n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        self.cfg.configure(node)\n     }\n }\n \n-fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n-    let mut multi_modifier = None;\n-    item = item.map_attrs(|mut attrs| {\n-        for i in 0..attrs.len() {\n-            if let Some(extension) = fld.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                match *extension {\n-                    MultiModifier(..) | MultiDecorator(..) => {\n-                        multi_modifier = Some((attrs.remove(i), extension));\n-                        break;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        attrs\n-    });\n-\n-    match multi_modifier {\n-        None => expand_multi_modified(item, fld),\n-        Some((attr, extension)) => {\n-            attr::mark_used(&attr);\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: attr.span,\n-                callee: NameAndSpan {\n-                    format: MacroAttribute(intern(&attr.name())),\n-                    span: Some(attr.span),\n-                    allow_internal_unstable: false,\n-                }\n-            });\n-\n-            let modified = match *extension {\n-                MultiModifier(ref mac) => mac.expand(fld.cx, attr.span, &attr.node.value, item),\n-                MultiDecorator(ref mac) => {\n-                    let mut items = Vec::new();\n-                    mac.expand(fld.cx, attr.span, &attr.node.value, &item,\n-                               &mut |item| items.push(item));\n-                    items.push(item);\n-                    items\n-                }\n-                _ => unreachable!(),\n-            };\n-\n-            fld.cx.bt_pop();\n-            let configured = modified.into_iter().flat_map(|it| {\n-                it.fold_with(&mut fld.strip_unconfigured())\n-            }).collect::<SmallVector<_>>();\n+impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        let mut expr = self.cfg.configure_expr(expr).unwrap();\n+        expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-            configured.into_iter().flat_map(|it| expand_annotatable(it, fld)).collect()\n+        if let ast::ExprKind::Mac(mac) = expr.node {\n+            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr).make_expr()\n+        } else {\n+            P(noop_fold_expr(expr, self))\n         }\n     }\n-}\n \n-fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n-                 -> SmallVector<ast::ImplItem> {\n-    match ii.node {\n-        ast::ImplItemKind::Macro(mac) => {\n-            expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr).unwrap();\n+        expr.node = self.cfg.configure_expr_kind(expr.node);\n+\n+        if let ast::ExprKind::Mac(mac) = expr.node {\n+            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr)\n+                .make_opt_expr()\n+        } else {\n+            Some(P(noop_fold_expr(expr, self)))\n         }\n-        _ => fold::noop_fold_impl_item(ii, fld)\n     }\n-}\n \n-fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n-                     -> SmallVector<ast::TraitItem> {\n-    match ti.node {\n-        ast::TraitItemKind::Macro(mac) => {\n-            expand_mac_invoc(mac, None, ti.attrs, ti.span, fld)\n+    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n+        match pat.node {\n+            PatKind::Mac(_) => {}\n+            _ => return noop_fold_pat(pat, self),\n         }\n-        _ => fold::noop_fold_trait_item(ti, fld)\n+\n+        pat.and_then(|pat| match pat.node {\n+            PatKind::Mac(mac) =>\n+                self.collect_bang(mac, Vec::new(), pat.span, ExpansionKind::Pat).make_pat(),\n+            _ => unreachable!(),\n+        })\n     }\n-}\n \n-pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n-    let t = match t.node.clone() {\n-        ast::TyKind::Mac(mac) => {\n-            expand_mac_invoc(mac, None, Vec::new(), t.span, fld)\n-        }\n-        _ => t\n-    };\n+    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n+        let stmt = match self.cfg.configure_stmt(stmt) {\n+            Some(stmt) => stmt,\n+            None => return SmallVector::zero(),\n+        };\n \n-    fold::noop_fold_ty(t, fld)\n-}\n+        let (mac, style, attrs) = match stmt.node {\n+            StmtKind::Mac(mac) => mac.unwrap(),\n+            _ => return noop_fold_stmt(stmt, self),\n+        };\n \n-/// A tree-folder that performs macro expansion\n-pub struct MacroExpander<'a, 'b:'a> {\n-    pub cx: &'a mut ExtCtxt<'b>,\n-    pub single_step: bool,\n-    pub keep_macs: bool,\n-}\n+        let mut placeholder =\n+            self.collect_bang(mac, attrs.into(), stmt.span, ExpansionKind::Stmts).make_stmts();\n \n-impl<'a, 'b> MacroExpander<'a, 'b> {\n-    pub fn new(cx: &'a mut ExtCtxt<'b>,\n-               single_step: bool,\n-               keep_macs: bool) -> MacroExpander<'a, 'b> {\n-        MacroExpander {\n-            cx: cx,\n-            single_step: single_step,\n-            keep_macs: keep_macs\n+        // If this is a macro invocation with a semicolon, then apply that\n+        // semicolon to the final statement produced by expansion.\n+        if style == MacStmtStyle::Semicolon {\n+            if let Some(stmt) = placeholder.pop() {\n+                placeholder.push(stmt.add_trailing_semicolon());\n+            }\n         }\n+\n+        placeholder\n     }\n \n-    fn strip_unconfigured(&mut self) -> StripUnconfigured {\n-        StripUnconfigured {\n-            config: &self.cx.cfg,\n-            should_test: self.cx.ecfg.should_test,\n-            sess: self.cx.parse_sess,\n-            features: self.cx.ecfg.features,\n-        }\n+    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n+        let paths = self.cx.syntax_env.paths();\n+        let module = self.cx.syntax_env.add_module(false, true, paths);\n+        let orig_module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+        let result = noop_fold_block(block, self);\n+        self.cx.syntax_env.current_module = orig_module;\n+        result\n     }\n \n-    fn load_macros<T: MacroGenerable>(&mut self, node: &T) {\n-        struct MacroLoadingVisitor<'a, 'b: 'a>{\n-            cx: &'a mut ExtCtxt<'b>,\n-            at_crate_root: bool,\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        let item = configure!(self, item);\n+\n+        let (item, attr) = self.classify_item(item);\n+        if let Some(attr) = attr {\n+            let item = Annotatable::Item(fully_configure!(self, item, noop_fold_item));\n+            return self.collect_attr(attr, item, ExpansionKind::Items).make_items();\n         }\n \n-        impl<'a, 'b> Visitor for MacroLoadingVisitor<'a, 'b> {\n-            fn visit_mac(&mut self, _: &ast::Mac) {}\n-            fn visit_item(&mut self, item: &ast::Item) {\n-                if let ast::ItemKind::ExternCrate(..) = item.node {\n-                    // We need to error on `#[macro_use] extern crate` when it isn't at the\n-                    // crate root, because `$crate` won't work properly.\n-                    for def in self.cx.loader.load_crate(item, self.at_crate_root) {\n-                        match def {\n-                            LoadedMacro::Def(def) => self.cx.insert_macro(def),\n-                            LoadedMacro::CustomDerive(name, ext) => {\n-                                self.cx.insert_custom_derive(&name, ext, item.span);\n-                            }\n-                        }\n+        match item.node {\n+            ast::ItemKind::Mac(..) => {\n+                if match item.node {\n+                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n+                    _ => unreachable!(),\n+                } {\n+                    return SmallVector::one(item);\n+                }\n+\n+                item.and_then(|item| match item.node {\n+                    ItemKind::Mac(mac) => {\n+                        self.collect(ExpansionKind::Items, InvocationKind::Bang {\n+                            mac: mac,\n+                            attrs: item.attrs,\n+                            ident: Some(item.ident),\n+                            span: item.span,\n+                        }).make_items()\n                     }\n+                    _ => unreachable!(),\n+                })\n+            }\n+            ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n+                let mut paths = (*self.cx.syntax_env.paths()).clone();\n+                paths.mod_path.push(item.ident);\n+\n+                // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n+                // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n+                // Thus, if `inner` is the dummy span, we know the module is inline.\n+                let inline_module = item.span.contains(inner) || inner == syntax_pos::DUMMY_SP;\n+\n+                if inline_module {\n+                    paths.directory.push(&*{\n+                        ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n+                            .unwrap_or(item.ident.name.as_str())\n+                    });\n                 } else {\n-                    let at_crate_root = ::std::mem::replace(&mut self.at_crate_root, false);\n-                    visit::walk_item(self, item);\n-                    self.at_crate_root = at_crate_root;\n+                    paths.directory =\n+                        PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n+                    paths.directory.pop();\n                 }\n-            }\n-            fn visit_block(&mut self, block: &ast::Block) {\n-                let at_crate_root = ::std::mem::replace(&mut self.at_crate_root, false);\n-                visit::walk_block(self, block);\n-                self.at_crate_root = at_crate_root;\n-            }\n-        }\n \n-        node.visit_with(&mut MacroLoadingVisitor {\n-            at_crate_root: self.cx.syntax_env.is_crate_root(),\n-            cx: self.cx,\n-        });\n-    }\n-}\n-\n-impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n-    fn fold_crate(&mut self, c: Crate) -> Crate {\n-        self.cx.filename = Some(self.cx.parse_sess.codemap().span_to_filename(c.span));\n-        noop_fold_crate(c, self)\n-    }\n-\n-    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        expr.and_then(|expr| expand_expr(expr, self))\n+                let macro_use = self.contains_macro_use(&item.attrs);\n+                let in_block = self.cx.syntax_env.in_block();\n+                let module = self.cx.syntax_env.add_module(macro_use, in_block, Rc::new(paths));\n+                let module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+                let result = noop_fold_item(item, self);\n+                self.cx.syntax_env.current_module = module;\n+                result\n+            },\n+            ast::ItemKind::ExternCrate(..) => {\n+                // We need to error on `#[macro_use] extern crate` when it isn't at the\n+                // crate root, because `$crate` won't work properly.\n+                let is_crate_root = self.cx.syntax_env.is_crate_root();\n+                for def in self.cx.loader.load_crate(&*item, is_crate_root) {\n+                    match def {\n+                        LoadedMacro::Def(def) => self.cx.insert_macro(def),\n+                        LoadedMacro::CustomDerive(name, ext) => {\n+                            self.cx.insert_custom_derive(&name, ext, item.span);\n+                        }\n+                    }\n+                }\n+                SmallVector::one(item)\n+            },\n+            _ => noop_fold_item(item, self),\n+        }\n     }\n \n-    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        expr.and_then(|expr| match expr.node {\n-            ast::ExprKind::Mac(mac) =>\n-                expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, self),\n-            _ => Some(expand_expr(expr, self)),\n-        })\n-    }\n+    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n+        let item = configure!(self, item);\n \n-    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        expand_pat(pat, self)\n-    }\n+        let (item, attr) = self.classify_item(item);\n+        if let Some(attr) = attr {\n+            let item =\n+                Annotatable::TraitItem(P(fully_configure!(self, item, noop_fold_trait_item)));\n+            return self.collect_attr(attr, item, ExpansionKind::TraitItems).make_trait_items()\n+        }\n \n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        use std::mem::replace;\n-        let result;\n-        if let ast::ItemKind::Mod(ast::Mod { inner, .. }) = item.node {\n-            if item.span.contains(inner) {\n-                self.push_mod_path(item.ident, &item.attrs);\n-                result = expand_item(item, self);\n-                self.pop_mod_path();\n-            } else {\n-                let filename = if inner != syntax_pos::DUMMY_SP {\n-                    Some(self.cx.parse_sess.codemap().span_to_filename(inner))\n-                } else { None };\n-                let orig_filename = replace(&mut self.cx.filename, filename);\n-                let orig_mod_path_stack = replace(&mut self.cx.mod_path_stack, Vec::new());\n-                result = expand_item(item, self);\n-                self.cx.filename = orig_filename;\n-                self.cx.mod_path_stack = orig_mod_path_stack;\n+        match item.node {\n+            ast::TraitItemKind::Macro(mac) => {\n+                let ast::TraitItem { attrs, span, .. } = item;\n+                self.collect_bang(mac, attrs, span, ExpansionKind::TraitItems).make_trait_items()\n             }\n-        } else {\n-            result = expand_item(item, self);\n+            _ => fold::noop_fold_trait_item(item, self),\n         }\n-        result\n     }\n \n-    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        expand_stmt(stmt, self)\n-    }\n-\n-    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let was_in_block = ::std::mem::replace(&mut self.cx.in_block, true);\n-        let result = with_exts_frame!(self.cx.syntax_env, false, noop_fold_block(block, self));\n-        self.cx.in_block = was_in_block;\n-        result\n-    }\n+    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n+        let item = configure!(self, item);\n \n-    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        expand_annotatable(Annotatable::TraitItem(P(i)), self)\n-            .into_iter().map(|i| i.expect_trait_item()).collect()\n-    }\n+        let (item, attr) = self.classify_item(item);\n+        if let Some(attr) = attr {\n+            let item = Annotatable::ImplItem(P(fully_configure!(self, item, noop_fold_impl_item)));\n+            return self.collect_attr(attr, item, ExpansionKind::ImplItems).make_impl_items();\n+        }\n \n-    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        expand_annotatable(Annotatable::ImplItem(P(i)), self)\n-            .into_iter().map(|i| i.expect_impl_item()).collect()\n+        match item.node {\n+            ast::ImplItemKind::Macro(mac) => {\n+                let ast::ImplItem { attrs, span, .. } = item;\n+                self.collect_bang(mac, attrs, span, ExpansionKind::ImplItems).make_impl_items()\n+            }\n+            _ => fold::noop_fold_impl_item(item, self),\n+        }\n     }\n \n     fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        expand_type(ty, self)\n+        let ty = match ty.node {\n+            ast::TyKind::Mac(_) => ty.unwrap(),\n+            _ => return fold::noop_fold_ty(ty, self),\n+        };\n+\n+        match ty.node {\n+            ast::TyKind::Mac(mac) =>\n+                self.collect_bang(mac, Vec::new(), ty.span, ExpansionKind::Ty).make_ty(),\n+            _ => unreachable!(),\n+        }\n     }\n-}\n \n-impl<'a, 'b> MacroExpander<'a, 'b> {\n-    fn push_mod_path(&mut self, id: Ident, attrs: &[ast::Attribute]) {\n-        let default_path = id.name.as_str();\n-        let file_path = match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            Some(d) => d,\n-            None => default_path,\n-        };\n-        self.cx.mod_path_stack.push(file_path)\n+    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+        noop_fold_foreign_mod(self.cfg.configure_foreign_mod(foreign_mod), self)\n     }\n \n-    fn pop_mod_path(&mut self) {\n-        self.cx.mod_path_stack.pop().unwrap();\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        noop_fold_item_kind(self.cfg.configure_item_kind(item), self)\n     }\n }\n \n@@ -699,42 +765,17 @@ impl<'feat> ExpansionConfig<'feat> {\n pub fn expand_crate(cx: &mut ExtCtxt,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n-    let mut expander = MacroExpander::new(cx, false, false);\n-    expand_crate_with_expander(&mut expander, user_exts, c)\n+    cx.initialize(user_exts, &c);\n+    cx.expander().expand_crate(c)\n }\n \n // Expands crate using supplied MacroExpander - allows for\n // non-standard expansion behaviour (e.g. step-wise).\n pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n                                   user_exts: Vec<NamedSyntaxExtension>,\n-                                  mut c: Crate) -> Crate {\n-    if std_inject::no_core(&c) {\n-        expander.cx.crate_root = None;\n-    } else if std_inject::no_std(&c) {\n-        expander.cx.crate_root = Some(\"core\");\n-    } else {\n-        expander.cx.crate_root = Some(\"std\");\n-    }\n-\n-    // User extensions must be added before expander.load_macros is called,\n-    // so that macros from external crates shadow user defined extensions.\n-    for (name, extension) in user_exts {\n-        expander.cx.syntax_env.insert(name, extension);\n-    }\n-\n-    let items = SmallVector::many(c.module.items);\n-    expander.load_macros(&items);\n-    c.module.items = items.into();\n-\n-    let err_count = expander.cx.parse_sess.span_diagnostic.err_count();\n-    let mut ret = expander.fold_crate(c);\n-    ret.exported_macros = expander.cx.exported_macros.clone();\n-\n-    if expander.cx.parse_sess.span_diagnostic.err_count() > err_count {\n-        expander.cx.parse_sess.span_diagnostic.abort_if_errors();\n-    }\n-\n-    ret\n+                                  c: Crate) -> Crate {\n+    expander.cx.initialize(user_exts, &c);\n+    expander.expand_crate(c)\n }\n \n // A Marker adds the given mark to the syntax context and"}, {"sha": "27e8eab62e11482aaa9785943dd8f8d558567bd8", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -40,6 +40,10 @@ impl Mark {\n             ::std::mem::replace(&mut data.next_mark, next_mark)\n         })\n     }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n }\n \n struct HygieneData {"}, {"sha": "abadcf867b146a28f9425848eca0e79e53a55348", "filename": "src/libsyntax/ext/placeholders.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -0,0 +1,175 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast;\n+use codemap::{DUMMY_SP, dummy_spanned};\n+use ext::expand::{Expansion, ExpansionKind};\n+use fold::*;\n+use parse::token::keywords;\n+use ptr::P;\n+use util::small_vector::SmallVector;\n+\n+use std::collections::HashMap;\n+\n+pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n+    fn mac_placeholder() -> ast::Mac {\n+        dummy_spanned(ast::Mac_ {\n+            path: ast::Path { span: DUMMY_SP, global: false, segments: Vec::new() },\n+            tts: Vec::new(),\n+        })\n+    }\n+\n+    let ident = keywords::Invalid.ident();\n+    let attrs = Vec::new();\n+    let vis = ast::Visibility::Inherited;\n+    let span = DUMMY_SP;\n+    let expr_placeholder = || P(ast::Expr {\n+        id: id, span: span,\n+        attrs: ast::ThinVec::new(),\n+        node: ast::ExprKind::Mac(mac_placeholder()),\n+    });\n+\n+    match kind {\n+        ExpansionKind::Expr => Expansion::Expr(expr_placeholder()),\n+        ExpansionKind::OptExpr => Expansion::OptExpr(Some(expr_placeholder())),\n+        ExpansionKind::Items => Expansion::Items(SmallVector::one(P(ast::Item {\n+            id: id, span: span, ident: ident, vis: vis, attrs: attrs,\n+            node: ast::ItemKind::Mac(mac_placeholder()),\n+        }))),\n+        ExpansionKind::TraitItems => Expansion::TraitItems(SmallVector::one(ast::TraitItem {\n+            id: id, span: span, ident: ident, attrs: attrs,\n+            node: ast::TraitItemKind::Macro(mac_placeholder()),\n+        })),\n+        ExpansionKind::ImplItems => Expansion::ImplItems(SmallVector::one(ast::ImplItem {\n+            id: id, span: span, ident: ident, vis: vis, attrs: attrs,\n+            node: ast::ImplItemKind::Macro(mac_placeholder()),\n+            defaultness: ast::Defaultness::Final,\n+        })),\n+        ExpansionKind::Pat => Expansion::Pat(P(ast::Pat {\n+            id: id, span: span, node: ast::PatKind::Mac(mac_placeholder()),\n+        })),\n+        ExpansionKind::Ty => Expansion::Ty(P(ast::Ty {\n+            id: id, span: span, node: ast::TyKind::Mac(mac_placeholder()),\n+        })),\n+        ExpansionKind::Stmts => Expansion::Stmts(SmallVector::one({\n+            let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ast::ThinVec::new()));\n+            ast::Stmt { id: id, span: span, node: ast::StmtKind::Mac(mac) }\n+        })),\n+    }\n+}\n+\n+pub fn macro_scope_placeholder() -> Expansion {\n+    placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+}\n+\n+pub struct PlaceholderExpander {\n+    expansions: HashMap<ast::NodeId, Expansion>,\n+}\n+\n+impl PlaceholderExpander {\n+    pub fn new() -> Self {\n+        PlaceholderExpander {\n+            expansions: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn add(&mut self, id: ast::NodeId, expansion: Expansion) {\n+        self.expansions.insert(id, expansion);\n+    }\n+\n+    pub fn remove(&mut self, id: ast::NodeId) -> Expansion {\n+        self.expansions.remove(&id).unwrap()\n+    }\n+}\n+\n+impl Folder for PlaceholderExpander {\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        match item.node {\n+            // Scope placeholder\n+            ast::ItemKind::Mac(_) if item.id == ast::DUMMY_NODE_ID => SmallVector::one(item),\n+            ast::ItemKind::Mac(_) => self.remove(item.id).make_items(),\n+            _ => noop_fold_item(item, self),\n+        }\n+    }\n+\n+    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n+        match item.node {\n+            ast::TraitItemKind::Macro(_) => self.remove(item.id).make_trait_items(),\n+            _ => noop_fold_trait_item(item, self),\n+        }\n+    }\n+\n+    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n+        match item.node {\n+            ast::ImplItemKind::Macro(_) => self.remove(item.id).make_impl_items(),\n+            _ => noop_fold_impl_item(item, self),\n+        }\n+    }\n+\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        match expr.node {\n+            ast::ExprKind::Mac(_) => self.remove(expr.id).make_expr(),\n+            _ => expr.map(|expr| noop_fold_expr(expr, self)),\n+        }\n+    }\n+\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        match expr.node {\n+            ast::ExprKind::Mac(_) => self.remove(expr.id).make_opt_expr(),\n+            _ => noop_fold_opt_expr(expr, self),\n+        }\n+    }\n+\n+    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n+        let (style, mut expansion) = match stmt.node {\n+            ast::StmtKind::Mac(mac) => (mac.1, self.remove(stmt.id).make_stmts()),\n+            _ => return noop_fold_stmt(stmt, self),\n+        };\n+\n+        if style == ast::MacStmtStyle::Semicolon {\n+            if let Some(stmt) = expansion.pop() {\n+                expansion.push(stmt.add_trailing_semicolon());\n+            }\n+        }\n+\n+        expansion\n+    }\n+\n+    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n+        match pat.node {\n+            ast::PatKind::Mac(_) => self.remove(pat.id).make_pat(),\n+            _ => noop_fold_pat(pat, self),\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n+        match ty.node {\n+            ast::TyKind::Mac(_) => self.remove(ty.id).make_ty(),\n+            _ => noop_fold_ty(ty, self),\n+        }\n+    }\n+}\n+\n+pub fn reconstructed_macro_rules(def: &ast::MacroDef, path: &ast::Path) -> Expansion {\n+    Expansion::Items(SmallVector::one(P(ast::Item {\n+        ident: def.ident,\n+        attrs: def.attrs.clone(),\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::ItemKind::Mac(ast::Mac {\n+            span: def.span,\n+            node: ast::Mac_ {\n+                path: path.clone(),\n+                tts: def.body.clone(),\n+            }\n+        }),\n+        vis: ast::Visibility::Inherited,\n+        span: def.span,\n+    })))\n+}"}, {"sha": "105b2261117385bbaf258e771ccdb49df7d82903", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -74,11 +74,9 @@ pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTre\n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    let string = cx.mod_path()\n-                   .iter()\n-                   .map(|x| x.to_string())\n-                   .collect::<Vec<String>>()\n-                   .join(\"::\");\n+    let paths = cx.syntax_env.paths();\n+    let string = paths.mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n+\n     base::MacEager::expr(cx.expr_str(\n             sp,\n             token::intern_and_get_ident(&string[..])))"}, {"sha": "ed80ec9cbc49e1d5781ebfccf54e67f6420e41f7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -211,9 +211,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            imported_from,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n-                p.filename = cx.filename.clone();\n-                p.mod_path_stack = cx.mod_path_stack.clone();\n-                p.restrictions = match cx.in_block {\n+                p.directory = cx.syntax_env.paths().directory.clone();\n+                p.restrictions = match cx.syntax_env.in_block() {\n                     true => Restrictions::NO_NONINLINE_MOD,\n                     false => Restrictions::empty(),\n                 };"}, {"sha": "4a2c9aff2d2b4e98d0648b98272bdb731dec4164", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -104,6 +104,7 @@ pub mod abi;\n pub mod ast;\n pub mod attr;\n pub mod codemap;\n+#[macro_use]\n pub mod config;\n pub mod entry;\n pub mod feature_gate;\n@@ -126,6 +127,7 @@ pub mod ext {\n     pub mod base;\n     pub mod build;\n     pub mod expand;\n+    pub mod placeholders;\n     pub mod hygiene;\n     pub mod proc_macro_shim;\n     pub mod quote;"}, {"sha": "6a0e40edded59ab09bc935239209db5c1a64872f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -264,8 +264,7 @@ pub struct Parser<'a> {\n     /// extra detail when the same error is seen twice\n     pub obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    pub filename: Option<String>,\n-    pub mod_path_stack: Vec<InternedString>,\n+    pub directory: PathBuf,\n     /// Stack of open delimiters and their spans. Used for error message.\n     pub open_braces: Vec<(token::DelimToken, Span)>,\n     /// Flag if this parser \"owns\" the directory that it is currently parsing\n@@ -346,9 +345,11 @@ impl<'a> Parser<'a> {\n     {\n         let tok0 = rdr.real_token();\n         let span = tok0.sp;\n-        let filename = if span != syntax_pos::DUMMY_SP {\n-            Some(sess.codemap().span_to_filename(span))\n-        } else { None };\n+        let mut directory = match span {\n+            syntax_pos::DUMMY_SP => PathBuf::new(),\n+            _ => PathBuf::from(sess.codemap().span_to_filename(span)),\n+        };\n+        directory.pop();\n         let placeholder = TokenAndSpan {\n             tok: token::Underscore,\n             sp: span,\n@@ -377,8 +378,7 @@ impl<'a> Parser<'a> {\n             quote_depth: 0,\n             parsing_token_tree: false,\n             obsolete_set: HashSet::new(),\n-            mod_path_stack: Vec::new(),\n-            filename: filename,\n+            directory: directory,\n             open_braces: Vec::new(),\n             owns_directory: true,\n             root_module_name: None,\n@@ -5306,27 +5306,24 @@ impl<'a> Parser<'a> {\n             let (m, attrs) = self.eval_src_mod(id, &outer_attrs, id_span)?;\n             Ok((id, m, Some(attrs)))\n         } else {\n-            self.push_mod_path(id, &outer_attrs);\n+            let directory = self.directory.clone();\n+            self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.span.lo;\n             let attrs = self.parse_inner_attributes()?;\n             let m = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n-            self.pop_mod_path();\n+            self.directory = directory;\n             Ok((id, ItemKind::Mod(m), Some(attrs)))\n         }\n     }\n \n-    fn push_mod_path(&mut self, id: Ident, attrs: &[Attribute]) {\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n         let default_path = self.id_to_interned_str(id);\n         let file_path = match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n             Some(d) => d,\n             None => default_path,\n         };\n-        self.mod_path_stack.push(file_path)\n-    }\n-\n-    fn pop_mod_path(&mut self) {\n-        self.mod_path_stack.pop().unwrap();\n+        self.directory.push(&*file_path)\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n@@ -5374,18 +5371,11 @@ impl<'a> Parser<'a> {\n                    id: ast::Ident,\n                    outer_attrs: &[ast::Attribute],\n                    id_sp: Span) -> PResult<'a, ModulePathSuccess> {\n-        let mut prefix = PathBuf::from(self.filename.as_ref().unwrap());\n-        prefix.pop();\n-        let mut dir_path = prefix;\n-        for part in &self.mod_path_stack {\n-            dir_path.push(&**part);\n-        }\n-\n-        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &dir_path) {\n+        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &self.directory) {\n             return Ok(ModulePathSuccess { path: p, owns_directory: true });\n         }\n \n-        let paths = Parser::default_submod_path(id, &dir_path, self.sess.codemap());\n+        let paths = Parser::default_submod_path(id, &self.directory, self.sess.codemap());\n \n         if self.restrictions.contains(Restrictions::NO_NONINLINE_MOD) {\n             let msg =\n@@ -5400,8 +5390,8 @@ impl<'a> Parser<'a> {\n         } else if !self.owns_directory {\n             let mut err = self.diagnostic().struct_span_err(id_sp,\n                 \"cannot declare a new module at this location\");\n-            let this_module = match self.mod_path_stack.last() {\n-                Some(name) => name.to_string(),\n+            let this_module = match self.directory.file_name() {\n+                Some(file_name) => file_name.to_str().unwrap().to_owned(),\n                 None => self.root_module_name.as_ref().unwrap().clone(),\n             };\n             err.span_note(id_sp,"}, {"sha": "3108296e778a2d9421e99713620513ac0e8a139e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -300,14 +300,11 @@ fn generate_test_harness(sess: &ParseSess,\n         }\n     });\n \n-    let mut fold = TestHarnessGenerator {\n+    TestHarnessGenerator {\n         cx: cx,\n         tests: Vec::new(),\n         tested_submods: Vec::new(),\n-    };\n-    let res = fold.fold_crate(krate);\n-    fold.cx.ext_cx.bt_pop();\n-    return res;\n+    }.fold_crate(krate)\n }\n \n /// Craft a span that will be ignored by the stability lint's"}, {"sha": "373dfc4ddfac5c0dfcbd796101279515eee1087c", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a262862167899ae33e65af19fa4e34f787e4b8c/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=4a262862167899ae33e65af19fa4e34f787e4b8c", "patch": "@@ -29,6 +29,12 @@ enum SmallVectorRepr<T> {\n     Many(Vec<T>),\n }\n \n+impl<T> Default for SmallVector<T> {\n+    fn default() -> Self {\n+        SmallVector { repr: Zero }\n+    }\n+}\n+\n impl<T> Into<Vec<T>> for SmallVector<T> {\n     fn into(self) -> Vec<T> {\n         match self.repr {"}]}