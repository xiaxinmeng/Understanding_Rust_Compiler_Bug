{"sha": "232d8e560561e07b3ba54c5d0234816e50342fb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzMmQ4ZTU2MDU2MWUwN2IzYmE1NGM1ZDAyMzQ4MTZlNTAzNDJmYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-21T18:06:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-21T18:06:18Z"}, "message": "auto merge of #11665 : alexcrichton/rust/zed-cleanup, r=brson\n\n* Stop using hardcoded numbers that have to all get updated when something changes (inevitable errors and rebase conflicts) as well as removes some unneeded -Z options (obsoleted over time).\r\n* Remove `std::rt::borrowck`", "tree": {"sha": "1d831edd0cab59bd97fb8e0acbd4bc2cb9e7b07c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d831edd0cab59bd97fb8e0acbd4bc2cb9e7b07c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/232d8e560561e07b3ba54c5d0234816e50342fb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/232d8e560561e07b3ba54c5d0234816e50342fb3", "html_url": "https://github.com/rust-lang/rust/commit/232d8e560561e07b3ba54c5d0234816e50342fb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/232d8e560561e07b3ba54c5d0234816e50342fb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43cffe9d719170bd342b10d1bb81911f0e14a7c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/43cffe9d719170bd342b10d1bb81911f0e14a7c4", "html_url": "https://github.com/rust-lang/rust/commit/43cffe9d719170bd342b10d1bb81911f0e14a7c4"}, {"sha": "d84c3369f732233adf0a80056d43dbc36d813aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/d84c3369f732233adf0a80056d43dbc36d813aae", "html_url": "https://github.com/rust-lang/rust/commit/d84c3369f732233adf0a80056d43dbc36d813aae"}], "stats": {"total": 495, "additions": 105, "deletions": 390}, "files": [{"sha": "7f1a6945d8a35a807225f28f7859fb66f8aeb98f", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -124,11 +124,6 @@ endif\n ifdef TRACE\n   CFG_RUSTC_FLAGS += -Z trace\n endif\n-ifndef DEBUG_BORROWS\n-  RUSTFLAGS_STAGE0 += -Z no-debug-borrows\n-  RUSTFLAGS_STAGE1 += -Z no-debug-borrows\n-  RUSTFLAGS_STAGE2 += -Z no-debug-borrows\n-endif\n \n # The executables crated during this compilation process have no need to include\n # static copies of libstd and libextra. We also generate dynamic versions of all"}, {"sha": "06c13c7de15ac5b037f4c9b911e73039149a4189", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -126,7 +126,7 @@ pub mod write {\n               session::Default => lib::llvm::CodeGenLevelDefault,\n               session::Aggressive => lib::llvm::CodeGenLevelAggressive,\n             };\n-            let use_softfp = sess.opts.debugging_opts & session::use_softfp != 0;\n+            let use_softfp = sess.opts.debugging_opts & session::USE_SOFTFP != 0;\n \n             let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|T| {\n                 sess.opts.target_cpu.with_c_str(|CPU| {\n@@ -156,7 +156,6 @@ pub mod write {\n                 pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n             };\n             if !sess.no_verify() { assert!(addpass(\"verify\")); }\n-            if sess.lint_llvm()  { assert!(addpass(\"lint\"));   }\n \n             if !sess.no_prepopulate_passes() {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n@@ -988,7 +987,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     let mut cc_args = sess.targ_cfg.target_strs.cc_args.clone();\n     cc_args.push_all_move(link_args(sess, dylib, tmpdir.path(),\n                                     obj_filename, out_filename));\n-    if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n+    if (sess.opts.debugging_opts & session::PRINT_LINK_ARGS) != 0 {\n         println!(\"{} link args: '{}'\", cc_prog, cc_args.connect(\"' '\"));\n     }\n "}, {"sha": "dcab4376cd1d738b396f82a17f18ea45c2262e26", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -759,22 +759,22 @@ pub fn build_session_options(binary: ~str,\n         }\n     }\n \n-    let mut debugging_opts = 0u;\n+    let mut debugging_opts = 0;\n     let debug_flags = matches.opt_strs(\"Z\");\n     let debug_map = session::debugging_opts_map();\n     for debug_flag in debug_flags.iter() {\n-        let mut this_bit = 0u;\n+        let mut this_bit = 0;\n         for tuple in debug_map.iter() {\n             let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n             if *name == *debug_flag { this_bit = bit; break; }\n         }\n-        if this_bit == 0u {\n+        if this_bit == 0 {\n             early_error(demitter, format!(\"unknown debug flag: {}\", *debug_flag))\n         }\n         debugging_opts |= this_bit;\n     }\n \n-    if debugging_opts & session::debug_llvm != 0 {\n+    if debugging_opts & session::DEBUG_LLVM != 0 {\n         unsafe { llvm::LLVMSetDebug(1); }\n     }\n \n@@ -797,7 +797,7 @@ pub fn build_session_options(binary: ~str,\n     let target_feature = matches.opt_str(\"target-feature\").unwrap_or(~\"\");\n     let save_temps = matches.opt_present(\"save-temps\");\n     let opt_level = {\n-        if (debugging_opts & session::no_opt) != 0 {\n+        if (debugging_opts & session::NO_OPT) != 0 {\n             No\n         } else if matches.opt_present(\"O\") {\n             if matches.opt_present(\"opt-level\") {\n@@ -816,9 +816,9 @@ pub fn build_session_options(binary: ~str,\n             }\n         } else { No }\n     };\n-    let gc = debugging_opts & session::gc != 0;\n-    let extra_debuginfo = debugging_opts & session::extra_debug_info != 0;\n-    let debuginfo = debugging_opts & session::debug_info != 0 ||\n+    let gc = debugging_opts & session::GC != 0;\n+    let extra_debuginfo = debugging_opts & session::EXTRA_DEBUG_INFO != 0;\n+    let debuginfo = debugging_opts & session::DEBUG_INFO != 0 ||\n         extra_debuginfo;\n \n     let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| {"}, {"sha": "75094bc808432c86b9708ba4ab4e93e8a6944345", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 94, "deletions": 102, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -39,89 +39,91 @@ pub struct Config {\n     uint_type: UintTy,\n }\n \n-pub static verbose:                 uint = 1 <<  0;\n-pub static time_passes:             uint = 1 <<  1;\n-pub static count_llvm_insns:        uint = 1 <<  2;\n-pub static time_llvm_passes:        uint = 1 <<  3;\n-pub static trans_stats:             uint = 1 <<  4;\n-pub static asm_comments:            uint = 1 <<  5;\n-pub static no_verify:               uint = 1 <<  6;\n-pub static borrowck_stats:          uint = 1 <<  7;\n-pub static borrowck_note_pure:      uint = 1 <<  8;\n-pub static borrowck_note_loan:      uint = 1 <<  9;\n-pub static no_landing_pads:         uint = 1 << 10;\n-pub static debug_llvm:              uint = 1 << 11;\n-pub static count_type_sizes:        uint = 1 << 12;\n-pub static meta_stats:              uint = 1 << 13;\n-pub static no_opt:                  uint = 1 << 14;\n-pub static gc:                      uint = 1 << 15;\n-pub static debug_info:              uint = 1 << 16;\n-pub static extra_debug_info:        uint = 1 << 17;\n-pub static print_link_args:         uint = 1 << 18;\n-pub static no_debug_borrows:        uint = 1 << 19;\n-pub static lint_llvm:               uint = 1 << 20;\n-pub static print_llvm_passes:       uint = 1 << 21;\n-pub static no_vectorize_loops:      uint = 1 << 22;\n-pub static no_vectorize_slp:        uint = 1 << 23;\n-pub static no_prepopulate_passes:   uint = 1 << 24;\n-pub static use_softfp:              uint = 1 << 25;\n-pub static gen_crate_map:           uint = 1 << 26;\n-pub static prefer_dynamic:          uint = 1 << 27;\n-pub static no_integrated_as:        uint = 1 << 28;\n-pub static lto:                     uint = 1 << 29;\n+macro_rules! debugging_opts(\n+    ([ $opt:ident ] $cnt:expr ) => (\n+        pub static $opt: u64 = 1 << $cnt;\n+    );\n+    ([ $opt:ident, $($rest:ident),* ] $cnt:expr ) => (\n+        pub static $opt: u64 = 1 << $cnt;\n+        debugging_opts!([ $($rest),* ] $cnt + 1)\n+    )\n+)\n \n-pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n-    ~[(\"verbose\", \"in general, enable more debug printouts\", verbose),\n-     (\"time-passes\", \"measure time of each rustc pass\", time_passes),\n+debugging_opts!(\n+    [\n+        VERBOSE,\n+        TIME_PASSES,\n+        COUNT_LLVM_INSNS,\n+        TIME_LLVM_PASSES,\n+        TRANS_STATS,\n+        ASM_COMMENTS,\n+        NO_VERIFY,\n+        BORROWCK_STATS,\n+        NO_LANDING_PADS,\n+        DEBUG_LLVM,\n+        COUNT_TYPE_SIZES,\n+        META_STATS,\n+        NO_OPT,\n+        GC,\n+        DEBUG_INFO,\n+        EXTRA_DEBUG_INFO,\n+        PRINT_LINK_ARGS,\n+        PRINT_LLVM_PASSES,\n+        NO_VECTORIZE_LOOPS,\n+        NO_VECTORIZE_SLP,\n+        NO_PREPOPULATE_PASSES,\n+        USE_SOFTFP,\n+        GEN_CRATE_MAP,\n+        PREFER_DYNAMIC,\n+        NO_INTEGRATED_AS,\n+        LTO\n+    ]\n+    0\n+)\n+\n+pub fn debugging_opts_map() -> ~[(&'static str, &'static str, u64)] {\n+    ~[(\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n+     (\"time-passes\", \"measure time of each rustc pass\", TIME_PASSES),\n      (\"count-llvm-insns\", \"count where LLVM \\\n-                           instrs originate\", count_llvm_insns),\n+                           instrs originate\", COUNT_LLVM_INSNS),\n      (\"time-llvm-passes\", \"measure time of each LLVM pass\",\n-      time_llvm_passes),\n-     (\"trans-stats\", \"gather trans statistics\", trans_stats),\n-     (\"asm-comments\", \"generate comments into the assembly (may change behavior)\", asm_comments),\n-     (\"no-verify\", \"skip LLVM verification\", no_verify),\n-     (\"borrowck-stats\", \"gather borrowck statistics\",  borrowck_stats),\n-     (\"borrowck-note-pure\", \"note where purity is req'd\",\n-      borrowck_note_pure),\n-     (\"borrowck-note-loan\", \"note where loans are req'd\",\n-      borrowck_note_loan),\n+      TIME_LLVM_PASSES),\n+     (\"trans-stats\", \"gather trans statistics\", TRANS_STATS),\n+     (\"asm-comments\", \"generate comments into the assembly (may change behavior)\",\n+      ASM_COMMENTS),\n+     (\"no-verify\", \"skip LLVM verification\", NO_VERIFY),\n+     (\"borrowck-stats\", \"gather borrowck statistics\",  BORROWCK_STATS),\n      (\"no-landing-pads\", \"omit landing pads for unwinding\",\n-      no_landing_pads),\n-     (\"debug-llvm\", \"enable debug output from LLVM\", debug_llvm),\n+      NO_LANDING_PADS),\n+     (\"debug-llvm\", \"enable debug output from LLVM\", DEBUG_LLVM),\n      (\"count-type-sizes\", \"count the sizes of aggregate types\",\n-      count_type_sizes),\n-     (\"meta-stats\", \"gather metadata statistics\", meta_stats),\n-     (\"no-opt\", \"do not optimize, even if -O is passed\", no_opt),\n-     (\"print-link-args\", \"Print the arguments passed to the linker\", print_link_args),\n-     (\"gc\", \"Garbage collect shared data (experimental)\", gc),\n+      COUNT_TYPE_SIZES),\n+     (\"meta-stats\", \"gather metadata statistics\", META_STATS),\n+     (\"no-opt\", \"do not optimize, even if -O is passed\", NO_OPT),\n+     (\"print-link-args\", \"Print the arguments passed to the linker\",\n+      PRINT_LINK_ARGS),\n+     (\"gc\", \"Garbage collect shared data (experimental)\", GC),\n      (\"extra-debug-info\", \"Extra debugging info (experimental)\",\n-      extra_debug_info),\n-     (\"debug-info\", \"Produce debug info (experimental)\", debug_info),\n-     (\"no-debug-borrows\",\n-      \"do not show where borrow checks fail\",\n-      no_debug_borrows),\n-     (\"lint-llvm\",\n-      \"Run the LLVM lint pass on the pre-optimization IR\",\n-      lint_llvm),\n+      EXTRA_DEBUG_INFO),\n+     (\"debug-info\", \"Produce debug info (experimental)\", DEBUG_INFO),\n      (\"print-llvm-passes\",\n       \"Prints the llvm optimization passes being run\",\n-      print_llvm_passes),\n+      PRINT_LLVM_PASSES),\n      (\"no-prepopulate-passes\",\n       \"Don't pre-populate the pass managers with a list of passes, only use \\\n         the passes from --passes\",\n-      no_prepopulate_passes),\n+      NO_PREPOPULATE_PASSES),\n      (\"no-vectorize-loops\",\n       \"Don't run the loop vectorization optimization passes\",\n-      no_vectorize_loops),\n-     (\"no-vectorize-slp\",\n-      \"Don't run LLVM's SLP vectorization passes\",\n-      no_vectorize_slp),\n-     (\"soft-float\", \"Generate software floating point library calls\", use_softfp),\n-     (\"gen-crate-map\", \"Force generation of a toplevel crate map\", gen_crate_map),\n-     (\"prefer-dynamic\", \"Prefer dynamic linking to static linking\", prefer_dynamic),\n+      NO_VECTORIZE_LOOPS),\n+     (\"no-vectorize-slp\", \"Don't run LLVM's SLP vectorization passes\",\n+      NO_VECTORIZE_SLP),\n+     (\"soft-float\", \"Generate software floating point library calls\", USE_SOFTFP),\n+     (\"gen-crate-map\", \"Force generation of a toplevel crate map\", GEN_CRATE_MAP),\n+     (\"prefer-dynamic\", \"Prefer dynamic linking to static linking\", PREFER_DYNAMIC),\n      (\"no-integrated-as\",\n-      \"Use external assembler rather than LLVM's integrated one\", no_integrated_as),\n-     (\"lto\", \"Perform LLVM link-time optimizations\", lto),\n+      \"Use external assembler rather than LLVM's integrated one\", NO_INTEGRATED_AS),\n+     (\"lto\", \"Perform LLVM link-time optimizations\", LTO),\n     ]\n }\n \n@@ -168,7 +170,7 @@ pub struct Options {\n     parse_only: bool,\n     no_trans: bool,\n     no_analysis: bool,\n-    debugging_opts: uint,\n+    debugging_opts: u64,\n     android_cross_path: Option<~str>,\n     /// Whether to write dependency files. It's (enabled, optional filename).\n     write_dependency_info: (bool, Option<Path>),\n@@ -291,66 +293,56 @@ impl Session_ {\n     pub fn diagnostic(&self) -> @diagnostic::SpanHandler {\n         self.span_diagnostic\n     }\n-    pub fn debugging_opt(&self, opt: uint) -> bool {\n-        (self.opts.debugging_opts & opt) != 0u\n+    pub fn debugging_opt(&self, opt: u64) -> bool {\n+        (self.opts.debugging_opts & opt) != 0\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, format!(\"Impossible case reached: {}\", msg));\n     }\n-    pub fn verbose(&self) -> bool { self.debugging_opt(verbose) }\n-    pub fn time_passes(&self) -> bool { self.debugging_opt(time_passes) }\n+    pub fn verbose(&self) -> bool { self.debugging_opt(VERBOSE) }\n+    pub fn time_passes(&self) -> bool { self.debugging_opt(TIME_PASSES) }\n     pub fn count_llvm_insns(&self) -> bool {\n-        self.debugging_opt(count_llvm_insns)\n+        self.debugging_opt(COUNT_LLVM_INSNS)\n     }\n     pub fn count_type_sizes(&self) -> bool {\n-        self.debugging_opt(count_type_sizes)\n+        self.debugging_opt(COUNT_TYPE_SIZES)\n     }\n     pub fn time_llvm_passes(&self) -> bool {\n-        self.debugging_opt(time_llvm_passes)\n-    }\n-    pub fn trans_stats(&self) -> bool { self.debugging_opt(trans_stats) }\n-    pub fn meta_stats(&self) -> bool { self.debugging_opt(meta_stats) }\n-    pub fn asm_comments(&self) -> bool { self.debugging_opt(asm_comments) }\n-    pub fn no_verify(&self) -> bool { self.debugging_opt(no_verify) }\n-    pub fn lint_llvm(&self) -> bool { self.debugging_opt(lint_llvm) }\n-    pub fn borrowck_stats(&self) -> bool { self.debugging_opt(borrowck_stats) }\n-    pub fn borrowck_note_pure(&self) -> bool {\n-        self.debugging_opt(borrowck_note_pure)\n-    }\n-    pub fn borrowck_note_loan(&self) -> bool {\n-        self.debugging_opt(borrowck_note_loan)\n-    }\n-    pub fn debug_borrows(&self) -> bool {\n-        self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n+        self.debugging_opt(TIME_LLVM_PASSES)\n     }\n+    pub fn trans_stats(&self) -> bool { self.debugging_opt(TRANS_STATS) }\n+    pub fn meta_stats(&self) -> bool { self.debugging_opt(META_STATS) }\n+    pub fn asm_comments(&self) -> bool { self.debugging_opt(ASM_COMMENTS) }\n+    pub fn no_verify(&self) -> bool { self.debugging_opt(NO_VERIFY) }\n+    pub fn borrowck_stats(&self) -> bool { self.debugging_opt(BORROWCK_STATS) }\n     pub fn print_llvm_passes(&self) -> bool {\n-        self.debugging_opt(print_llvm_passes)\n+        self.debugging_opt(PRINT_LLVM_PASSES)\n     }\n     pub fn no_prepopulate_passes(&self) -> bool {\n-        self.debugging_opt(no_prepopulate_passes)\n+        self.debugging_opt(NO_PREPOPULATE_PASSES)\n     }\n     pub fn no_vectorize_loops(&self) -> bool {\n-        self.debugging_opt(no_vectorize_loops)\n+        self.debugging_opt(NO_VECTORIZE_LOOPS)\n     }\n     pub fn no_vectorize_slp(&self) -> bool {\n-        self.debugging_opt(no_vectorize_slp)\n+        self.debugging_opt(NO_VECTORIZE_SLP)\n     }\n     pub fn gen_crate_map(&self) -> bool {\n-        self.debugging_opt(gen_crate_map)\n+        self.debugging_opt(GEN_CRATE_MAP)\n     }\n     pub fn prefer_dynamic(&self) -> bool {\n-        self.debugging_opt(prefer_dynamic)\n+        self.debugging_opt(PREFER_DYNAMIC)\n     }\n     pub fn no_integrated_as(&self) -> bool {\n-        self.debugging_opt(no_integrated_as)\n+        self.debugging_opt(NO_INTEGRATED_AS)\n     }\n     pub fn lto(&self) -> bool {\n-        self.debugging_opt(lto)\n+        self.debugging_opt(LTO)\n     }\n     pub fn no_landing_pads(&self) -> bool {\n-        self.debugging_opt(no_landing_pads)\n+        self.debugging_opt(NO_LANDING_PADS)\n     }\n \n     // pointless function, now...\n@@ -396,7 +388,7 @@ pub fn basic_options() -> @Options {\n         parse_only: false,\n         no_trans: false,\n         no_analysis: false,\n-        debugging_opts: 0u,\n+        debugging_opts: 0,\n         android_cross_path: None,\n         write_dependency_info: (false, None),\n         print_metas: (false, false, false),"}, {"sha": "4d8df829a944869b67122a3626e69f137e323352", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -104,7 +104,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @RefCell::new(libs),\n         outputs: ~[session::OutputExecutable],\n-        debugging_opts: session::prefer_dynamic,\n+        debugging_opts: session::PREFER_DYNAMIC,\n         .. (*session::basic_options()).clone()\n     };\n "}, {"sha": "7dcbae995ed7b2be3a278e3d8ed8b13fefde5b4d", "filename": "src/libstd/rt/borrowck.rs", "status": "removed", "additions": 0, "deletions": 220, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/43cffe9d719170bd342b10d1bb81911f0e14a7c4/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cffe9d719170bd342b10d1bb81911f0e14a7c4/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=43cffe9d719170bd342b10d1bb81911f0e14a7c4", "patch": "@@ -1,220 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use c_str::{ToCStr, CString};\n-use container::Container;\n-use iter::Iterator;\n-use libc::{c_char, size_t};\n-use option::{Option, None, Some};\n-use ptr::RawPtr;\n-use rt;\n-use rt::local::Local;\n-use rt::task::Task;\n-use str::OwnedStr;\n-use str;\n-use uint;\n-use unstable::raw;\n-use vec::{ImmutableVector, OwnedVector};\n-\n-pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n-pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n-static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n-\n-#[deriving(Eq)]\n-pub struct BorrowRecord {\n-    priv alloc: *mut raw::Box<()>,\n-    file: *c_char,\n-    priv line: size_t\n-}\n-\n-fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    let mut task = Local::borrow(None::<Task>);\n-    task.get().borrow_list.take()\n-}\n-\n-fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n-    let borrows = match try_take_task_borrow_list() {\n-        Some(l) => l,\n-        None => ~[]\n-    };\n-    let borrows = f(borrows);\n-\n-    let mut task = Local::borrow(None::<Task>);\n-    task.get().borrow_list = Some(borrows)\n-}\n-\n-pub fn clear_task_borrow_list() {\n-    // pub because it is used by the box annihilator.\n-    let _ = try_take_task_borrow_list();\n-}\n-\n-#[cold]\n-unsafe fn fail_borrowed(alloc: *mut raw::Box<()>, file: *c_char, line: size_t)\n-                        -> ! {\n-    debug_borrow(\"fail_borrowed: \", alloc, 0, 0, file, line);\n-\n-    match try_take_task_borrow_list() {\n-        None => { // not recording borrows\n-            let msg = \"borrowed\";\n-            msg.with_c_str(|msg_p| rt::begin_unwind_raw(msg_p, file, line))\n-        }\n-        Some(borrow_list) => { // recording borrows\n-            let mut msg = ~\"borrowed\";\n-            let mut sep = \" at \";\n-            for entry in borrow_list.rev_iter() {\n-                if entry.alloc == alloc {\n-                    msg.push_str(sep);\n-                    let filename = str::raw::from_c_str(entry.file);\n-                    msg.push_str(filename);\n-                    msg.push_str(format!(\":{}\", entry.line));\n-                    sep = \" and at \";\n-                }\n-            }\n-            msg.with_c_str(|msg_p| rt::begin_unwind_raw(msg_p, file, line))\n-        }\n-    }\n-}\n-\n-/// Because this code is so perf. sensitive, use a static constant so that\n-/// debug printouts are compiled out most of the time.\n-static ENABLE_DEBUG: bool = false;\n-\n-#[inline]\n-unsafe fn debug_borrow<T,P:RawPtr<T>>(tag: &'static str,\n-                                      p: P,\n-                                      old_bits: uint,\n-                                      new_bits: uint,\n-                                      filename: *c_char,\n-                                      line: size_t) {\n-    //! A useful debugging function that prints a pointer + tag + newline\n-    //! without allocating memory.\n-\n-    if ENABLE_DEBUG && rt::env::debug_borrow() {\n-        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n-    }\n-\n-    unsafe fn debug_borrow_slow<T,P:RawPtr<T>>(tag: &'static str,\n-                                               p: P,\n-                                               old_bits: uint,\n-                                               new_bits: uint,\n-                                               filename: *c_char,\n-                                               line: size_t) {\n-        let filename = CString::new(filename, false);\n-        rterrln!(\"{}{:#x} {:x} {:x} {}:{}\",\n-                 tag, p.to_uint(), old_bits, new_bits,\n-                 filename.as_str().unwrap(), line);\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a = a as *mut raw::Box<()>;\n-    let old_ref_count = (*a).ref_count;\n-    let new_ref_count = old_ref_count | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & MUT_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).ref_count = new_ref_count;\n-\n-    old_ref_count\n-}\n-\n-#[inline]\n-pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a = a as *mut raw::Box<()>;\n-    let old_ref_count = (*a).ref_count;\n-    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).ref_count = new_ref_count;\n-\n-    old_ref_count\n-}\n-\n-pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before\n-        let a = a as *mut raw::Box<()>;\n-        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n-        swap_task_borrow_list(|borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            borrow_list.push(BorrowRecord {\n-                alloc: a,\n-                file: file,\n-                line: line,\n-            });\n-            borrow_list\n-        })\n-    }\n-}\n-\n-pub unsafe fn unrecord_borrow(a: *u8,\n-                              old_ref_count: uint,\n-                              file: *c_char,\n-                              line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before, so we should find the record at\n-        // the end of the list\n-        let a = a as *mut raw::Box<()>;\n-        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n-        swap_task_borrow_list(|borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            assert!(!borrow_list.is_empty());\n-            let br = borrow_list.pop();\n-            if br.alloc != a || br.file != file || br.line != line {\n-                let err = format!(\"wrong borrow found, br={:?}\", br);\n-                err.with_c_str(|msg_p| {\n-                    rt::begin_unwind_raw(msg_p, file, line)\n-                })\n-            }\n-            borrow_list\n-        })\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    // Sometimes the box is null, if it is conditionally frozen.\n-    // See e.g. #4904.\n-    if !a.is_null() {\n-        let a = a as *mut raw::Box<()>;\n-        let old_ref_count = (*a).ref_count;\n-        let new_ref_count =\n-            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n-\n-        debug_borrow(\"return_to_mut:\",\n-                     a, old_ref_count, new_ref_count, file, line);\n-\n-        (*a).ref_count = new_ref_count;\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn check_not_borrowed(a: *u8,\n-                                 file: *c_char,\n-                                 line: size_t) {\n-    let a = a as *mut raw::Box<()>;\n-    let ref_count = (*a).ref_count;\n-    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n-    if (ref_count & FROZEN_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-}"}, {"sha": "40e9a3ec5b2f31a4530b5bf3717094b65081410a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -127,9 +127,6 @@ mod util;\n // Global command line argument storage\n pub mod args;\n \n-// Support for dynamic borrowck\n-pub mod borrowck;\n-\n /// The default error code of the rust runtime if the main task fails instead\n /// of exiting cleanly.\n pub static DEFAULT_ERROR_CODE: int = 101;"}, {"sha": "e63208bcaec6fb0c9266e20714002ab3c2a1b4c4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -27,8 +27,6 @@ use option::{Option, Some, None};\n use prelude::drop;\n use result::{Result, Ok, Err};\n use rt::Runtime;\n-use rt::borrowck::BorrowRecord;\n-use rt::borrowck;\n use rt::local::Local;\n use rt::local_heap::LocalHeap;\n use rt::rtio::LocalIo;\n@@ -52,8 +50,6 @@ pub struct Task {\n     death: Death,\n     destroyed: bool,\n     name: Option<SendStr>,\n-    // Dynamic borrowck debugging info\n-    borrow_list: Option<~[BorrowRecord]>,\n \n     logger: Option<~Logger>,\n     stdout: Option<~Writer>,\n@@ -93,7 +89,6 @@ impl Task {\n             death: Death::new(),\n             destroyed: false,\n             name: None,\n-            borrow_list: None,\n             logger: None,\n             stdout: None,\n             stderr: None,\n@@ -182,9 +177,6 @@ impl Task {\n \n         unsafe { (*handle).unwinder.try(try_block); }\n \n-        // Cleanup the dynamic borrowck debugging info\n-        borrowck::clear_task_borrow_list();\n-\n         // Here we must unsafely borrow the task in order to not remove it from\n         // TLS. When collecting failure, we may attempt to send on a channel (or\n         // just run aribitrary code), so we must be sure to still have a local"}, {"sha": "8460152ff7bae2f8984367d9e93df730f7927eca", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232d8e560561e07b3ba54c5d0234816e50342fb3/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=232d8e560561e07b3ba54c5d0234816e50342fb3", "patch": "@@ -12,7 +12,6 @@\n \n use c_str::ToCStr;\n use libc::{c_char, size_t, uintptr_t};\n-use rt::borrowck;\n \n #[cold]\n #[lang=\"fail_\"]\n@@ -42,42 +41,3 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n pub unsafe fn local_free(ptr: *c_char) {\n     ::rt::local_heap::local_free(ptr);\n }\n-\n-#[lang=\"borrow_as_imm\"]\n-#[inline]\n-pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n-    borrowck::borrow_as_imm(a, file, line)\n-}\n-\n-#[lang=\"borrow_as_mut\"]\n-#[inline]\n-pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n-    borrowck::borrow_as_mut(a, file, line)\n-}\n-\n-#[lang=\"record_borrow\"]\n-pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    borrowck::record_borrow(a, old_ref_count, file, line)\n-}\n-\n-#[lang=\"unrecord_borrow\"]\n-pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n-                              file: *c_char, line: size_t) {\n-    borrowck::unrecord_borrow(a, old_ref_count, file, line)\n-}\n-\n-#[lang=\"return_to_mut\"]\n-#[inline]\n-pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    borrowck::return_to_mut(a, orig_ref_count, file, line)\n-}\n-\n-#[lang=\"check_not_borrowed\"]\n-#[inline]\n-pub unsafe fn check_not_borrowed(a: *u8,\n-                                 file: *c_char,\n-                                 line: size_t) {\n-    borrowck::check_not_borrowed(a, file, line)\n-}"}]}