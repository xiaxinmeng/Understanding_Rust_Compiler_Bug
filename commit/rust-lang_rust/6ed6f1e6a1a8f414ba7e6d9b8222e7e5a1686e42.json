{"sha": "6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZDZmMWU2YTFhOGY0MTRiYTdlNmQ5YjgyMjJlN2U1YTE2ODZlNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-11T19:54:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-11T19:54:48Z"}, "message": "Auto merge of #6826 - TaKO8Ki:refactor-methods-mod, r=phansch\n\nRefactor: arrange lints in `methods` module\n\nThis PR arranges methods lints so that they can be accessed more easily.\nBasically, I refactored them following the instruction described in #6680.\n\nchangelog: Move lints in methods module into their own modules.", "tree": {"sha": "5840a0469d2116556fdace3c24373de5258e1473", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5840a0469d2116556fdace3c24373de5258e1473"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "html_url": "https://github.com/rust-lang/rust/commit/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "534a13db96a3ed78956bb793e0cec4640d452939", "url": "https://api.github.com/repos/rust-lang/rust/commits/534a13db96a3ed78956bb793e0cec4640d452939", "html_url": "https://github.com/rust-lang/rust/commit/534a13db96a3ed78956bb793e0cec4640d452939"}, {"sha": "83a955335f986c503ac114cf5009ff965bb21741", "url": "https://api.github.com/repos/rust-lang/rust/commits/83a955335f986c503ac114cf5009ff965bb21741", "html_url": "https://github.com/rust-lang/rust/commit/83a955335f986c503ac114cf5009ff965bb21741"}], "stats": {"total": 4645, "additions": 2502, "deletions": 2143}, "files": [{"sha": "5decb81d9f2e26ca461cb3d6f9aa9343341e3adb", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -158,7 +158,7 @@ pub(crate) trait BindInsteadOfMap {\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-    fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n+    fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n         if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n             return false;\n         }"}, {"sha": "71a7e195e41cee1cb2163cdf19abe032ba0d6984", "filename": "clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -7,7 +7,7 @@ use rustc_span::sym;\n \n use super::BYTES_NTH;\n \n-pub(super) fn lints<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>]) {\n     if_chain! {\n         if let ExprKind::MethodCall(_, _, ref args, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(&iter_args[0]).peel_refs();"}, {"sha": "4a130ed47db15bc00e6f3afc075c963f55a5a75d", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,109 @@\n+use crate::utils::{is_copy, span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use std::iter;\n+\n+use super::CLONE_DOUBLE_REF;\n+use super::CLONE_ON_COPY;\n+\n+/// Checks for the `CLONE_ON_COPY` lint.\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if let ty::Ref(_, inner, _) = arg_ty.kind() {\n+        if let ty::Ref(_, innermost, _) = inner.kind() {\n+            span_lint_and_then(\n+                cx,\n+                CLONE_DOUBLE_REF,\n+                expr.span,\n+                &format!(\n+                    \"using `clone` on a double-reference; \\\n+                    this will copy the reference of type `{}` instead of cloning the inner type\",\n+                    ty\n+                ),\n+                |diag| {\n+                    if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n+                        let mut ty = innermost;\n+                        let mut n = 0;\n+                        while let ty::Ref(_, inner, _) = ty.kind() {\n+                            ty = inner;\n+                            n += 1;\n+                        }\n+                        let refs: String = iter::repeat('&').take(n + 1).collect();\n+                        let derefs: String = iter::repeat('*').take(n).collect();\n+                        let explicit = format!(\"<{}{}>::clone({})\", refs, ty, snip);\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"try dereferencing it\",\n+                            format!(\"{}({}{}).clone()\", refs, derefs, snip.deref()),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"or try being explicit if you are sure, that you want to clone a reference\",\n+                            explicit,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                },\n+            );\n+            return; // don't report clone_on_copy\n+        }\n+    }\n+\n+    if is_copy(cx, ty) {\n+        let snip;\n+        if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n+            let parent = cx.tcx.hir().get_parent_node(expr.hir_id);\n+            match &cx.tcx.hir().get(parent) {\n+                hir::Node::Expr(parent) => match parent.kind {\n+                    // &*x is a nop, &x.clone() is not\n+                    hir::ExprKind::AddrOf(..) => return,\n+                    // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n+                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n+                        return;\n+                    },\n+\n+                    _ => {},\n+                },\n+                hir::Node::Stmt(stmt) => {\n+                    if let hir::StmtKind::Local(ref loc) = stmt.kind {\n+                        if let hir::PatKind::Ref(..) = loc.pat.kind {\n+                            // let ref y = *x borrows x, let ref y = x.clone() does not\n+                            return;\n+                        }\n+                    }\n+                },\n+                _ => {},\n+            }\n+\n+            // x.clone() might have dereferenced x, possibly through Deref impls\n+            if cx.typeck_results().expr_ty(arg) == ty {\n+                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n+            } else {\n+                let deref_count = cx\n+                    .typeck_results()\n+                    .expr_adjustments(arg)\n+                    .iter()\n+                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n+                    .count();\n+                let derefs: String = iter::repeat('*').take(deref_count).collect();\n+                snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n+            }\n+        } else {\n+            snip = None;\n+        }\n+        span_lint_and_then(\n+            cx,\n+            CLONE_ON_COPY,\n+            expr.span,\n+            &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n+            |diag| {\n+                if let Some((text, snip)) = snip {\n+                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "3d5a68d69d7d2d9bbc510c70131bfbb215f4eba4", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,36 @@\n+use crate::utils::{is_type_diagnostic_item, match_type, paths, snippet_with_macro_callsite, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::CLONE_ON_REF_PTR;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n+\n+    if let ty::Adt(_, subst) = obj_ty.kind() {\n+        let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n+            \"Rc\"\n+        } else if is_type_diagnostic_item(cx, obj_ty, sym::Arc) {\n+            \"Arc\"\n+        } else if match_type(cx, obj_ty, &paths::WEAK_RC) || match_type(cx, obj_ty, &paths::WEAK_ARC) {\n+            \"Weak\"\n+        } else {\n+            return;\n+        };\n+\n+        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n+\n+        span_lint_and_sugg(\n+            cx,\n+            CLONE_ON_REF_PTR,\n+            expr.span,\n+            \"using `.clone()` on a ref-counted pointer\",\n+            \"try this\",\n+            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet),\n+            Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n+        );\n+    }\n+}"}, {"sha": "6866e9c652ab37d9c5202f0f95a2e7a62dc0ff38", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,199 @@\n+use crate::utils::{is_expn_of, is_type_diagnostic_item, snippet, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::EXPECT_FUN_CALL;\n+\n+/// Checks for the `EXPECT_FUN_CALL` lint.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Span, name: &str, args: &[hir::Expr<'_>]) {\n+    // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n+    // `&str`\n+    fn get_arg_root<'a>(cx: &LateContext<'_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n+        let mut arg_root = arg;\n+        loop {\n+            arg_root = match &arg_root.kind {\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n+                hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n+                    if call_args.len() == 1\n+                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n+                        && {\n+                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n+                            let base_type = arg_type.peel_refs();\n+                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::string_type)\n+                        }\n+                    {\n+                        &call_args[0]\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                _ => break,\n+            };\n+        }\n+        arg_root\n+    }\n+\n+    // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n+    // converted to string.\n+    fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n+        let arg_ty = cx.typeck_results().expr_ty(arg);\n+        if is_type_diagnostic_item(cx, arg_ty, sym::string_type) {\n+            return false;\n+        }\n+        if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n+            if *ty.kind() == ty::Str && can_be_static_str(cx, arg) {\n+                return false;\n+            }\n+        };\n+        true\n+    }\n+\n+    // Check if an expression could have type `&'static str`, knowing that it\n+    // has type `&str` for some lifetime.\n+    fn can_be_static_str(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n+        match arg.kind {\n+            hir::ExprKind::Lit(_) => true,\n+            hir::ExprKind::Call(fun, _) => {\n+                if let hir::ExprKind::Path(ref p) = fun.kind {\n+                    match cx.qpath_res(p, fun.hir_id) {\n+                        hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n+                            cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n+                            ty::Ref(ty::ReStatic, ..)\n+                        ),\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            },\n+            hir::ExprKind::MethodCall(..) => {\n+                cx.typeck_results()\n+                    .type_dependent_def_id(arg.hir_id)\n+                    .map_or(false, |method_id| {\n+                        matches!(\n+                            cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n+                            ty::Ref(ty::ReStatic, ..)\n+                        )\n+                    })\n+            },\n+            hir::ExprKind::Path(ref p) => matches!(\n+                cx.qpath_res(p, arg.hir_id),\n+                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n+            ),\n+            _ => false,\n+        }\n+    }\n+\n+    fn generate_format_arg_snippet(\n+        cx: &LateContext<'_>,\n+        a: &hir::Expr<'_>,\n+        applicability: &mut Applicability,\n+    ) -> Vec<String> {\n+        if_chain! {\n+            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref format_arg) = a.kind;\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.kind;\n+            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.kind;\n+\n+            then {\n+                format_arg_expr_tup\n+                    .iter()\n+                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n+                    .collect()\n+            } else {\n+                unreachable!()\n+            }\n+        }\n+    }\n+\n+    fn is_call(node: &hir::ExprKind<'_>) -> bool {\n+        match node {\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n+                is_call(&expr.kind)\n+            },\n+            hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..)\n+            // These variants are debatable or require further examination\n+            | hir::ExprKind::If(..)\n+            | hir::ExprKind::Match(..)\n+            | hir::ExprKind::Block{ .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n+        return;\n+    }\n+\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::option_type) {\n+        \"||\"\n+    } else if is_type_diagnostic_item(cx, receiver_type, sym::result_type) {\n+        \"|_|\"\n+    } else {\n+        return;\n+    };\n+\n+    let arg_root = get_arg_root(cx, &args[1]);\n+\n+    let span_replace_word = method_span.with_hi(expr.span.hi());\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    //Special handling for `format!` as arg_root\n+    if_chain! {\n+        if let hir::ExprKind::Block(block, None) = &arg_root.kind;\n+        if block.stmts.len() == 1;\n+        if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n+        if let Some(arg_root) = &local.init;\n+        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.kind;\n+        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n+        if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n+        then {\n+            let fmt_spec = &format_args[0];\n+            let fmt_args = &format_args[1];\n+\n+            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n+\n+            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n+\n+            let sugg = args.join(\", \");\n+\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{}` followed by a function call\", name),\n+                \"try this\",\n+                format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+                applicability,\n+            );\n+\n+            return;\n+        }\n+    }\n+\n+    let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);\n+    if requires_to_string(cx, arg_root) {\n+        arg_root_snippet.to_mut().push_str(\".to_string()\");\n+    }\n+\n+    span_lint_and_sugg(\n+        cx,\n+        EXPECT_FUN_CALL,\n+        span_replace_word,\n+        &format!(\"use of `{}` followed by a function call\", name),\n+        \"try this\",\n+        format!(\n+            \"unwrap_or_else({} {{ panic!(\\\"{{}}\\\", {}) }})\",\n+            closure_args, arg_root_snippet\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "90b781bd9d1905015998d3bd7df81bc067ae5008", "filename": "clippy_lints/src/methods/expect_used.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,30 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::EXPECT_USED;\n+\n+/// lint use of `expect()` for `Option`s and `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n+\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n+        Some((EXPECT_USED, \"an Option\", \"None\"))\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n+        Some((EXPECT_USED, \"a Result\", \"Err\"))\n+    } else {\n+        None\n+    };\n+\n+    if let Some((lint, kind, none_value)) = mess {\n+        span_lint_and_help(\n+            cx,\n+            lint,\n+            expr.span,\n+            &format!(\"used `expect()` on `{}` value\", kind,),\n+            None,\n+            &format!(\"if this value is an `{}`, it will panic\", none_value,),\n+        );\n+    }\n+}"}, {"sha": "b03835f97e634728bf554d2b415f04c17520ccc2", "filename": "clippy_lints/src/methods/filetype_is_file.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,39 @@\n+use crate::utils::{get_parent_expr, match_type, paths, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::FILETYPE_IS_FILE;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(&args[0]);\n+\n+    if !match_type(cx, ty, &paths::FILE_TYPE) {\n+        return;\n+    }\n+\n+    let span: Span;\n+    let verb: &str;\n+    let lint_unary: &str;\n+    let help_unary: &str;\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let hir::ExprKind::Unary(op, _) = parent.kind;\n+        if op == hir::UnOp::Not;\n+        then {\n+            lint_unary = \"!\";\n+            verb = \"denies\";\n+            help_unary = \"\";\n+            span = parent.span;\n+        } else {\n+            lint_unary = \"\";\n+            verb = \"covers\";\n+            help_unary = \"!\";\n+            span = expr.span;\n+        }\n+    }\n+    let lint_msg = format!(\"`{}FileType::is_file()` only {} regular files\", lint_unary, verb);\n+    let help_msg = format!(\"use `{}FileType::is_dir()` instead\", help_unary);\n+    span_lint_and_help(cx, FILETYPE_IS_FILE, span, &lint_msg, None, &help_msg);\n+}"}, {"sha": "8da867fce515cde5d051ce25b10043bb05f584d5", "filename": "clippy_lints/src/methods/filter_flat_map.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,21 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_MAP;\n+\n+/// lint use of `filter().flat_map()` for `Iterators`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n+) {\n+    // lint if caller of `.filter().flat_map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter(..).flat_map(..)` on an `Iterator`\";\n+        let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n+                    and filtering by returning `iter::empty()`\";\n+        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n+    }\n+}"}, {"sha": "f559160004cb1f56ad61fb21a5aa4a427c7e2b36", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,85 @@\n+use crate::utils::{match_trait_method, path_to_local_id, paths, snippet, span_lint_and_sugg, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use rustc_span::symbol::sym;\n+\n+use super::MANUAL_FILTER_MAP;\n+use super::MANUAL_FIND_MAP;\n+\n+/// lint use of `filter().map()` or `find().map()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n+        if let ExprKind::MethodCall(_, _, [_, filter_arg], filter_span) = map_recv.kind;\n+        if match_trait_method(cx, map_recv, &paths::ITERATOR);\n+\n+        // filter(|x| ...is_some())...\n+        if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n+        let filter_body = cx.tcx.hir().body(filter_body_id);\n+        if let [filter_param] = filter_body.params;\n+        // optional ref pattern: `filter(|&x| ..)`\n+        let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n+            (ref_pat, true)\n+        } else {\n+            (filter_param.pat, false)\n+        };\n+        // closure ends with is_some() or is_ok()\n+        if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n+        if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n+        if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n+        if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n+            Some(false)\n+        } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n+            Some(true)\n+        } else {\n+            None\n+        };\n+        if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n+\n+        // ...map(|x| ...unwrap())\n+        if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n+        let map_body = cx.tcx.hir().body(map_body_id);\n+        if let [map_param] = map_body.params;\n+        if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n+        // closure ends with expect() or unwrap()\n+        if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n+        if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n+\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            // in `filter(|x| ..)`, replace `*x` with `x`\n+            let a_path = if_chain! {\n+                if !is_filter_param_ref;\n+                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n+                then { expr_path } else { a }\n+            };\n+            // let the filter closure arg and the map closure arg be equal\n+            if_chain! {\n+                if path_to_local_id(a_path, filter_param_id);\n+                if path_to_local_id(b, map_param_id);\n+                if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n+                then {\n+                    return true;\n+                }\n+            }\n+            false\n+        };\n+        if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n+        then {\n+            let span = filter_span.to(map_span);\n+            let (filter_name, lint) = if is_find {\n+                (\"find\", MANUAL_FIND_MAP)\n+            } else {\n+                (\"filter\", MANUAL_FILTER_MAP)\n+            };\n+            let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n+            let to_opt = if is_result { \".ok()\" } else { \"\" };\n+            let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n+                snippet(cx, map_arg.span, \"..\"), to_opt);\n+            span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n+        }\n+    }\n+}"}, {"sha": "a6db138623a8c6e7d5243652d4df89fb25e80b26", "filename": "clippy_lints/src/methods/filter_map_flat_map.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,21 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_MAP;\n+\n+/// lint use of `filter_map().flat_map()` for `Iterators`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n+) {\n+    // lint if caller of `.filter_map().flat_map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter_map(..).flat_map(..)` on an `Iterator`\";\n+        let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n+                    and filtering by returning `iter::empty()`\";\n+        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n+    }\n+}"}, {"sha": "d015b4c7b385e85381ecd8c9876a3a7294c9bf18", "filename": "clippy_lints/src/methods/filter_map_map.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,20 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_MAP;\n+\n+/// lint use of `filter_map().map()` for `Iterators`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n+) {\n+    // lint if caller of `.filter_map().map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter_map(..).map(..)` on an `Iterator`\";\n+        let hint = \"this is more succinctly expressed by only calling `.filter_map(..)` instead\";\n+        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n+    }\n+}"}, {"sha": "a789df922ffdbfb2327419d867438ffbe2466304", "filename": "clippy_lints/src/methods/filter_map_next.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,40 @@\n+use crate::utils::{match_trait_method, meets_msrv, paths, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_semver::RustcVersion;\n+\n+use super::FILTER_MAP_NEXT;\n+\n+const FILTER_MAP_NEXT_MSRV: RustcVersion = RustcVersion::new(1, 30, 0);\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    filter_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n+) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if !meets_msrv(msrv, &FILTER_MAP_NEXT_MSRV) {\n+            return;\n+        }\n+\n+        let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find_map(..)` instead\";\n+        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        if filter_snippet.lines().count() <= 1 {\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            span_lint_and_sugg(\n+                cx,\n+                FILTER_MAP_NEXT,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.find_map({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint(cx, FILTER_MAP_NEXT, expr.span, msg);\n+        }\n+    }\n+}"}, {"sha": "81619e73017f26a07892e72bd41a3ac01c9f5698", "filename": "clippy_lints/src/methods/filter_next.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,31 @@\n+use crate::utils::{match_trait_method, paths, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_NEXT;\n+\n+/// lint use of `filter().next()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.filter().next()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find(..)` instead\";\n+        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        if filter_snippet.lines().count() <= 1 {\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            // add note if not multi-line\n+            span_lint_and_sugg(\n+                cx,\n+                FILTER_NEXT,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.find({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint(cx, FILTER_NEXT, expr.span, msg);\n+        }\n+    }\n+}"}, {"sha": "ce3194f8a2373ef809cacc548beee4938b7ef04f", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,57 @@\n+use crate::utils::{match_qpath, match_trait_method, paths, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::FLAT_MAP_IDENTITY;\n+\n+/// lint use of `flat_map` for `Iterators` where `flatten` would be sufficient\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    flat_map_args: &'tcx [hir::Expr<'_>],\n+    flat_map_span: Span,\n+) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let arg_node = &flat_map_args[1].kind;\n+\n+        let apply_lint = |message: &str| {\n+            span_lint_and_sugg(\n+                cx,\n+                FLAT_MAP_IDENTITY,\n+                flat_map_span.with_hi(expr.span.hi()),\n+                message,\n+                \"try\",\n+                \"flatten()\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        };\n+\n+        if_chain! {\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = arg_node;\n+            let body = cx.tcx.hir().body(*body_id);\n+\n+            if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.kind;\n+\n+            if path.segments.len() == 1;\n+            if path.segments[0].ident.name == binding_ident.name;\n+\n+            then {\n+                apply_lint(\"called `flat_map(|x| x)` on an `Iterator`\");\n+            }\n+        }\n+\n+        if_chain! {\n+            if let hir::ExprKind::Path(ref qpath) = arg_node;\n+\n+            if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n+\n+            then {\n+                apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "e50d0a3340026d466f521ca5660bbe65c6935405", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,67 @@\n+use crate::utils::{get_trait_def_id, implements_trait, paths, span_lint_and_sugg, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::ty::Ty;\n+\n+use super::FROM_ITER_INSTEAD_OF_COLLECT;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n+\n+    if_chain! {\n+        if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n+        if let Some(iter_id) = get_trait_def_id(cx, &paths::ITERATOR);\n+\n+        if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]);\n+        then {\n+            // `expr` implements `FromIterator` trait\n+            let iter_expr = sugg::Sugg::hir(cx, &args[0], \"..\").maybe_par();\n+            let turbofish = extract_turbofish(cx, expr, ty);\n+            let sugg = format!(\"{}.collect::<{}>()\", iter_expr, turbofish);\n+            span_lint_and_sugg(\n+                cx,\n+                FROM_ITER_INSTEAD_OF_COLLECT,\n+                expr.span,\n+                \"usage of `FromIterator::from_iter`\",\n+                \"use `.collect()` instead of `::from_iter()`\",\n+                sugg,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}\n+\n+fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n+    if_chain! {\n+        let call_site = expr.span.source_callsite();\n+        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n+        let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n+        if let Some((_, elements)) = snippet_split.split_last();\n+\n+        then {\n+            // is there a type specifier? (i.e.: like `<u32>` in `collections::BTreeSet::<u32>::`)\n+            if let Some(type_specifier) = snippet_split.iter().find(|e| e.starts_with('<') && e.ends_with('>')) {\n+                // remove the type specifier from the path elements\n+                let without_ts = elements.iter().filter_map(|e| {\n+                    if e == type_specifier { None } else { Some((*e).to_string()) }\n+                }).collect::<Vec<_>>();\n+                // join and add the type specifier at the end (i.e.: `collections::BTreeSet<u32>`)\n+                format!(\"{}{}\", without_ts.join(\"::\"), type_specifier)\n+            } else {\n+                // type is not explicitly specified so wildcards are needed\n+                // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n+                let ty_str = ty.to_string();\n+                let start = ty_str.find('<').unwrap_or(0);\n+                let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n+                let nb_wildcard = ty_str[start..end].split(',').count();\n+                let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n+                format!(\"{}<{}>\", elements.join(\"::\"), wildcards)\n+            }\n+        } else {\n+            ty.to_string()\n+        }\n+    }\n+}"}, {"sha": "e157db2712a9ac143c9475dab5005e7abf215a22", "filename": "clippy_lints/src/methods/get_unwrap.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,84 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{\n+    get_parent_expr, is_type_diagnostic_item, match_type, paths, snippet_with_applicability, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::GET_UNWRAP;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args: &'tcx [hir::Expr<'_>], is_mut: bool) {\n+    // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n+    // because they do not implement `IndexMut`\n+    let mut applicability = Applicability::MachineApplicable;\n+    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n+    let get_args_str = if get_args.len() > 1 {\n+        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n+    } else {\n+        return; // not linting on a .get().unwrap() chain or variant\n+    };\n+    let mut needs_ref;\n+    let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"slice\"\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"Vec\"\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vecdeque_type) {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"VecDeque\"\n+    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym::hashmap_type) {\n+        needs_ref = true;\n+        \"HashMap\"\n+    } else if !is_mut && match_type(cx, expr_ty, &paths::BTREEMAP) {\n+        needs_ref = true;\n+        \"BTreeMap\"\n+    } else {\n+        return; // caller is not a type that we want to lint\n+    };\n+\n+    let mut span = expr.span;\n+\n+    // Handle the case where the result is immediately dereferenced\n+    // by not requiring ref and pulling the dereference into the\n+    // suggestion.\n+    if_chain! {\n+        if needs_ref;\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let hir::ExprKind::Unary(hir::UnOp::Deref, _) = parent.kind;\n+        then {\n+            needs_ref = false;\n+            span = parent.span;\n+        }\n+    }\n+\n+    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n+    let borrow_str = if !needs_ref {\n+        \"\"\n+    } else if is_mut {\n+        \"&mut \"\n+    } else {\n+        \"&\"\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        GET_UNWRAP,\n+        span,\n+        &format!(\n+            \"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n+            mut_str, caller_type\n+        ),\n+        \"try this\",\n+        format!(\n+            \"{}{}[{}]\",\n+            borrow_str,\n+            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n+            get_args_str\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "3045b09c2389f4890a9b1543cc3ee89c5cd0f6ca", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n     if_chain! {\n         if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);"}, {"sha": "959457a5bfc960c9fb7855b895297cd616e0bf00", "filename": "clippy_lints/src/methods/inspect_for_each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Finspect_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Finspect_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finspect_for_each.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -7,7 +7,7 @@ use crate::utils::{match_trait_method, paths, span_lint_and_help};\n use super::INSPECT_FOR_EACH;\n \n /// lint use of `inspect().for_each()` for `Iterators`\n-pub(super) fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, inspect_span: Span) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, inspect_span: Span) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `inspect(..).for_each(..)` on an `Iterator`\";\n         let hint = \"move the code from `inspect(..)` to `for_each(..)` and remove the `inspect(..)`\";"}, {"sha": "1e8315dbee25eb90e9d40c957235b6877980b8ca", "filename": "clippy_lints/src/methods/into_iter_on_ref.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,43 @@\n+use crate::utils::{has_iter_method, match_trait_method, paths, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n+\n+use super::INTO_ITER_ON_REF;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n+    if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n+        return;\n+    }\n+    if let Some((kind, method_name)) = ty_has_iter_method(cx, self_ref_ty) {\n+        span_lint_and_sugg(\n+            cx,\n+            INTO_ITER_ON_REF,\n+            method_span,\n+            &format!(\n+                \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n+                method_name, kind,\n+            ),\n+            \"call directly\",\n+            method_name.to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(Symbol, &'static str)> {\n+    has_iter_method(cx, self_ref_ty).map(|ty_name| {\n+        let mutbl = match self_ref_ty.kind() {\n+            ty::Ref(_, _, mutbl) => mutbl,\n+            _ => unreachable!(),\n+        };\n+        let method_name = match mutbl {\n+            hir::Mutability::Not => \"iter\",\n+            hir::Mutability::Mut => \"iter_mut\",\n+        };\n+        (ty_name, method_name)\n+    })\n+}"}, {"sha": "c3e48ffa5fae4de57a7652307bd97d7b17e021f8", "filename": "clippy_lints/src/methods/iter_cloned_collect.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,30 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::ITER_CLONED_COLLECT;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+    if_chain! {\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type);\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n+        if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n+\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_CLONED_COLLECT,\n+                to_replace,\n+                \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                more readable\",\n+                \"try\",\n+                \".to_vec()\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "869440e0165b2a7973705527e48ec729858215e1", "filename": "clippy_lints/src/methods/iter_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -8,7 +8,7 @@ use rustc_span::sym;\n \n use super::ITER_COUNT;\n \n-pub(crate) fn lints<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>], iter_method: &str) {\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>], iter_method: &str) {\n     let ty = cx.typeck_results().expr_ty(&iter_args[0]);\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], ty).is_some() {\n         \"slice\""}, {"sha": "3c03a949cfed09138abaedf02b9f500db27ca92b", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,68 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{get_parent_expr, higher, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::ITER_NEXT_SLICE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+    let caller_expr = &iter_args[0];\n+\n+    // Skip lint if the `iter().next()` expression is a for loop argument,\n+    // since it is already covered by `&loops::ITER_NEXT_LOOP`\n+    let mut parent_expr_opt = get_parent_expr(cx, expr);\n+    while let Some(parent_expr) = parent_expr_opt {\n+        if higher::for_loop(parent_expr).is_some() {\n+            return;\n+        }\n+        parent_expr_opt = get_parent_expr(cx, parent_expr);\n+    }\n+\n+    if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n+        // caller is a Slice\n+        if_chain! {\n+            if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n+            if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n+                = higher::range(index_expr);\n+            if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n+            if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    ITER_NEXT_SLICE,\n+                    expr.span,\n+                    \"using `.iter().next()` on a Slice without end index\",\n+                    \"try calling\",\n+                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n+                    applicability,\n+                );\n+            }\n+        }\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym::vec_type)\n+        || matches!(\n+            &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n+            ty::Array(_, _)\n+        )\n+    {\n+        // caller is a Vec or an Array\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_NEXT_SLICE,\n+            expr.span,\n+            \"using `.iter().next()` on an array\",\n+            \"try calling\",\n+            format!(\n+                \"{}.get(0)\",\n+                snippet_with_applicability(cx, caller_expr.span, \"..\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "cc3e56ea87277de289d95e242b81a32d62400cf5", "filename": "clippy_lints/src/methods/iter_nth.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,38 @@\n+use crate::methods::derefs_to_slice;\n+use crate::methods::iter_nth_zero;\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::ITER_NTH;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    nth_and_iter_args: &[&'tcx [hir::Expr<'tcx>]],\n+    is_mut: bool,\n+) {\n+    let iter_args = nth_and_iter_args[1];\n+    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n+        \"slice\"\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n+        \"Vec\"\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vecdeque_type) {\n+        \"VecDeque\"\n+    } else {\n+        let nth_args = nth_and_iter_args[0];\n+        iter_nth_zero::check(cx, expr, &nth_args);\n+        return; // caller is not a type that we want to lint\n+    };\n+\n+    span_lint_and_help(\n+        cx,\n+        ITER_NTH,\n+        expr.span,\n+        &format!(\"called `.iter{0}().nth()` on a {1}\", mut_str, caller_type),\n+        None,\n+        &format!(\"calling `.get{}()` is both faster and more readable\", mut_str),\n+    );\n+}"}, {"sha": "247192d81f3ec58f33340eedcecce5511655d8d4", "filename": "clippy_lints/src/methods/iter_nth_zero.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,27 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::{match_trait_method, paths, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::ITER_NTH_ZERO;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n+    if_chain! {\n+        if match_trait_method(cx, expr, &paths::ITERATOR);\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &nth_args[1]);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_NTH_ZERO,\n+                expr.span,\n+                \"called `.nth(0)` on a `std::iter::Iterator`, when `.next()` is equivalent\",\n+                \"try calling `.next()` instead of `.nth(0)`\",\n+                format!(\"{}.next()\", snippet_with_applicability(cx, nth_args[0].span, \"..\", &mut applicability)),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "5f5969134e49062483a4a5ab31f5934a28a02ff5", "filename": "clippy_lints/src/methods/iter_skip_next.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,24 @@\n+use crate::utils::{match_trait_method, paths, snippet, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::ITER_SKIP_NEXT;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[hir::Expr<'_>]) {\n+    // lint if caller of skip is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if let [caller, n] = skip_args {\n+            let hint = format!(\".nth({})\", snippet(cx, n.span, \"..\"));\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_SKIP_NEXT,\n+                expr.span.trim_start(caller.span).unwrap(),\n+                \"called `skip(..).next()` on an iterator\",\n+                \"use `nth` instead\",\n+                hint,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "3e05d7f76b75aa2272f7b237a5b082d71543be62", "filename": "clippy_lints/src/methods/iterator_step_by_zero.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,19 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::{match_trait_method, paths, span_lint};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::ITERATOR_STEP_BY_ZERO;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+            span_lint(\n+                cx,\n+                ITERATOR_STEP_BY_ZERO,\n+                expr.span,\n+                \"`Iterator::step_by(0)` will panic at runtime\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "0b414e0eb95676e46e9037db66be59d73bdeebac", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -6,7 +6,7 @@ use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_target::abi::LayoutOf;\n \n-pub fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n+pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n     let unwrap_arg = &args[0][1];\n     let arith_lhs = &args[1][0];\n     let arith_rhs = &args[1][1];"}, {"sha": "5b20e268d9f7ee8d7060d7e7eadd0fc52bbbbb73", "filename": "clippy_lints/src/methods/map_collect_result_unit.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{is_type_diagnostic_item, match_trait_method, paths, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_COLLECT_RESULT_UNIT;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    map_args: &[hir::Expr<'_>],\n+    collect_args: &[hir::Expr<'_>],\n+) {\n+    if_chain! {\n+        // called on Iterator\n+        if let [map_expr] = collect_args;\n+        if match_trait_method(cx, map_expr, &paths::ITERATOR);\n+        // return of collect `Result<(),_>`\n+        let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n+        if is_type_diagnostic_item(cx, collect_ret_ty, sym::result_type);\n+        if let ty::Adt(_, substs) = collect_ret_ty.kind();\n+        if let Some(result_t) = substs.types().next();\n+        if result_t.is_unit();\n+        // get parts for snippet\n+        if let [iter, map_fn] = map_args;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_COLLECT_RESULT_UNIT,\n+                expr.span,\n+                \"`.map().collect()` can be replaced with `.try_for_each()`\",\n+                \"try this\",\n+                format!(\n+                    \"{}.try_for_each({})\",\n+                    snippet(cx, iter.span, \"..\"),\n+                    snippet(cx, map_fn.span, \"..\")\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "14a14e4f9ecd1a4d24aae583077810b31b2731c8", "filename": "clippy_lints/src/methods/map_flatten.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,61 @@\n+use crate::utils::{is_type_diagnostic_item, match_trait_method, paths, snippet, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_FLATTEN;\n+\n+/// lint use of `map().flatten()` for `Iterators` and 'Options'\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.map().flatten()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n+        let is_map_to_option = match map_closure_ty.kind() {\n+            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n+                let map_closure_sig = match map_closure_ty.kind() {\n+                    ty::Closure(_, substs) => substs.as_closure().sig(),\n+                    _ => map_closure_ty.fn_sig(cx.tcx),\n+                };\n+                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n+                is_type_diagnostic_item(cx, map_closure_return_ty, sym::option_type)\n+            },\n+            _ => false,\n+        };\n+\n+        let method_to_use = if is_map_to_option {\n+            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n+            \"filter_map\"\n+        } else {\n+            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n+            \"flat_map\"\n+        };\n+        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_FLATTEN,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Iterator`\",\n+            &format!(\"try using `{}` instead\", method_to_use),\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    // lint if caller of `.map().flatten()` is an Option\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n+        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let hint = format!(\".and_then({})\", func_snippet);\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_FLATTEN,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Option`\",\n+            \"try using `and_then` instead\",\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "63b2cf87f32ada410984e722fcd10bb817ea259f", "filename": "clippy_lints/src/methods/map_unwrap_or.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,76 @@\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{is_type_diagnostic_item, meets_msrv, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_semver::RustcVersion;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_UNWRAP_OR;\n+\n+const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n+\n+/// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n+/// Return true if lint triggered\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    map_args: &'tcx [hir::Expr<'_>],\n+    unwrap_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n+) -> bool {\n+    if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n+        return false;\n+    }\n+    // lint if the caller of `map()` is an `Option`\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n+\n+    if is_option || is_result {\n+        // Don't make a suggestion that may fail to compile due to mutably borrowing\n+        // the same variable twice.\n+        let map_mutated_vars = mutated_variables(&map_args[0], cx);\n+        let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n+        if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n+            if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+\n+        // lint message\n+        let msg = if is_option {\n+            \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling \\\n+            `map_or_else(<g>, <f>)` instead\"\n+        } else {\n+            \"called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling \\\n+            `.map_or_else(<g>, <f>)` instead\"\n+        };\n+        // get snippets for args to map() and unwrap_or_else()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or_else() have the same span\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        if same_span && !multiline {\n+            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_UNWRAP_OR,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.map_or_else({}, {})\", var_snippet, unwrap_snippet, map_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        } else if same_span && multiline {\n+            span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "7fd14c4f9b11c055a44dcc43ec416977ee6ba891", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 240, "deletions": 2134, "changes": 2374, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42"}, {"sha": "c1706cc7cc7d266ad0c2f902e3a2d615148c6ca0", "filename": "clippy_lints/src/methods/ok_expect.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{implements_trait, is_type_diagnostic_item, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::sym;\n+\n+use super::OK_EXPECT;\n+\n+/// lint use of `ok().expect()` for `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n+    if_chain! {\n+        // lint if the caller of `ok()` is a `Result`\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n+        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n+        if let Some(error_type) = get_error_type(cx, result_type);\n+        if has_debug_impl(error_type, cx);\n+\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                OK_EXPECT,\n+                expr.span,\n+                \"called `ok().expect()` on a `Result` value\",\n+                None,\n+                \"you can call `expect()` directly on the `Result`\",\n+            );\n+        }\n+    }\n+}\n+\n+/// Given a `Result<T, E>` type, return its error type (`E`).\n+fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n+    match ty.kind() {\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym::result_type) => substs.types().nth(1),\n+        _ => None,\n+    }\n+}\n+\n+/// This checks whether a given type is known to implement Debug.\n+fn has_debug_impl<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    cx.tcx\n+        .get_diagnostic_item(sym::debug_trait)\n+        .map_or(false, |debug| implements_trait(cx, ty, debug, &[]))\n+}"}, {"sha": "89067dbfe0e51a780e6e6df125d2c9cfad98e357", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,122 @@\n+use crate::utils::{\n+    is_type_diagnostic_item, match_def_path, meets_msrv, path_to_local_id, paths, remove_blocks, snippet,\n+    span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n+use rustc_span::sym;\n+\n+use super::OPTION_AS_REF_DEREF;\n+\n+const OPTION_AS_REF_DEREF_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n+\n+/// lint use of `_.as_ref().map(Deref::deref)` for `Option`s\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    as_ref_args: &[hir::Expr<'_>],\n+    map_args: &[hir::Expr<'_>],\n+    is_mut: bool,\n+    msrv: Option<&RustcVersion>,\n+) {\n+    if !meets_msrv(msrv, &OPTION_AS_REF_DEREF_MSRV) {\n+        return;\n+    }\n+\n+    let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n+\n+    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n+    if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n+        return;\n+    }\n+\n+    let deref_aliases: [&[&str]; 9] = [\n+        &paths::DEREF_TRAIT_METHOD,\n+        &paths::DEREF_MUT_TRAIT_METHOD,\n+        &paths::CSTRING_AS_C_STR,\n+        &paths::OS_STRING_AS_OS_STR,\n+        &paths::PATH_BUF_AS_PATH,\n+        &paths::STRING_AS_STR,\n+        &paths::STRING_AS_MUT_STR,\n+        &paths::VEC_AS_SLICE,\n+        &paths::VEC_AS_MUT_SLICE,\n+    ];\n+\n+    let is_deref = match map_args[1].kind {\n+        hir::ExprKind::Path(ref expr_qpath) => cx\n+            .qpath_res(expr_qpath, map_args[1].hir_id)\n+            .opt_def_id()\n+            .map_or(false, |fun_def_id| {\n+                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n+            }),\n+        hir::ExprKind::Closure(_, _, body_id, _, _) => {\n+            let closure_body = cx.tcx.hir().body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+\n+            match &closure_expr.kind {\n+                hir::ExprKind::MethodCall(_, _, args, _) => {\n+                    if_chain! {\n+                        if args.len() == 1;\n+                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n+                        let adj = cx\n+                            .typeck_results()\n+                            .expr_adjustments(&args[0])\n+                            .iter()\n+                            .map(|x| &x.kind)\n+                            .collect::<Box<[_]>>();\n+                        if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n+                        then {\n+                            let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n+                            deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n+                    if_chain! {\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner1) = inner.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner2) = inner1.kind;\n+                        then {\n+                            path_to_local_id(inner2, closure_body.params[0].pat.hir_id)\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                _ => false,\n+            }\n+        },\n+        _ => false,\n+    };\n+\n+    if is_deref {\n+        let current_method = if is_mut {\n+            format!(\".as_mut().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+        } else {\n+            format!(\".as_ref().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+        };\n+        let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n+        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_args[0].span, \"..\"), method_hint);\n+        let suggestion = format!(\"try using {} instead\", method_hint);\n+\n+        let msg = format!(\n+            \"called `{0}` on an Option value. This can be done more directly \\\n+            by calling `{1}` instead\",\n+            current_method, hint\n+        );\n+        span_lint_and_sugg(\n+            cx,\n+            OPTION_AS_REF_DEREF,\n+            expr.span,\n+            &msg,\n+            &suggestion,\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "64f6ebc5062ef3ef208c2190f7b50891702ffaaf", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,78 @@\n+use crate::utils::{is_type_diagnostic_item, match_qpath, paths, snippet, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::OPTION_MAP_OR_NONE;\n+use super::RESULT_MAP_OR_INTO_OPTION;\n+\n+/// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::result_type);\n+\n+    // There are two variants of this `map_or` lint:\n+    // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n+    // (2) using `map_or` as a combinator instead of `and_then`\n+    //\n+    // (For this lint) we don't care if any other type calls `map_or`\n+    if !is_option && !is_result {\n+        return;\n+    }\n+\n+    let (lint_name, msg, instead, hint) = {\n+        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].kind {\n+            match_qpath(qpath, &paths::OPTION_NONE)\n+        } else {\n+            return;\n+        };\n+\n+        if !default_arg_is_none {\n+            // nothing to lint!\n+            return;\n+        }\n+\n+        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_or_args[2].kind {\n+            match_qpath(qpath, &paths::OPTION_SOME)\n+        } else {\n+            false\n+        };\n+\n+        if is_option {\n+            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n+            let func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n+            let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `and_then(..)` instead\";\n+            (\n+                OPTION_MAP_OR_NONE,\n+                msg,\n+                \"try using `and_then` instead\",\n+                format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n+            )\n+        } else if f_arg_is_some {\n+            let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n+                       `ok()` instead\";\n+            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n+            (\n+                RESULT_MAP_OR_INTO_OPTION,\n+                msg,\n+                \"try using `ok` instead\",\n+                format!(\"{0}.ok()\", self_snippet),\n+            )\n+        } else {\n+            // nothing to lint!\n+            return;\n+        }\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        lint_name,\n+        expr.span,\n+        msg,\n+        instead,\n+        hint,\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "7cdd49bbf0307a6a3a2adaa6c6e8b1e976f1ce55", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -12,7 +12,7 @@ use rustc_span::{sym, Symbol};\n use super::MAP_UNWRAP_OR;\n \n /// lint use of `map().unwrap_or()` for `Option`s\n-pub(super) fn lint<'tcx>(\n+pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &rustc_hir::Expr<'_>,\n     map_args: &'tcx [rustc_hir::Expr<'_>],"}, {"sha": "5f7fc431d22483edca2dbf1c8ce14b0021bf60c5", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,173 @@\n+use crate::utils::eager_or_lazy::is_lazyness_candidate;\n+use crate::utils::{\n+    contains_return, get_trait_def_id, implements_trait, is_type_diagnostic_item, last_path_segment, match_type, paths,\n+    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::OR_FUN_CALL;\n+\n+/// Checks for the `OR_FUN_CALL` lint.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_span: Span,\n+    name: &str,\n+    args: &'tcx [hir::Expr<'_>],\n+) {\n+    /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    fn check_unwrap_or_default(\n+        cx: &LateContext<'_>,\n+        name: &str,\n+        fun: &hir::Expr<'_>,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &hir::Expr<'_>,\n+        or_has_args: bool,\n+        span: Span,\n+    ) -> bool {\n+        if_chain! {\n+            if !or_has_args;\n+            if name == \"unwrap_or\";\n+            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+            let path = &*last_path_segment(qpath).ident.as_str();\n+            if [\"default\", \"new\"].contains(&path);\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n+            if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+            if implements_trait(cx, arg_ty, default_trait_id, &[]);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span,\n+                    &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                    \"try this\",\n+                    format!(\n+                        \"{}.unwrap_or_default()\",\n+                        snippet_with_applicability(cx, self_expr.span, \"..\", &mut applicability)\n+                    ),\n+                    applicability,\n+                );\n+\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks for `*or(foo())`.\n+    #[allow(clippy::too_many_arguments)]\n+    fn check_general_case<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        name: &str,\n+        method_span: Span,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &'tcx hir::Expr<'_>,\n+        span: Span,\n+        // None if lambda is required\n+        fun_span: Option<Span>,\n+    ) {\n+        // (path, fn_has_argument, methods, suffix)\n+        static KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n+            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        ];\n+\n+        if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n+            if path.ident.as_str() == \"len\" {\n+                let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+\n+                match ty.kind() {\n+                    ty::Slice(_) | ty::Array(_, _) => return,\n+                    _ => (),\n+                }\n+\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        if_chain! {\n+            if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n+\n+            if is_lazyness_candidate(cx, arg);\n+            if !contains_return(&arg);\n+\n+            let self_ty = cx.typeck_results().expr_ty(self_expr);\n+\n+            if let Some(&(_, fn_has_arguments, poss, suffix)) =\n+                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+\n+            if poss.contains(&name);\n+\n+            then {\n+                let macro_expanded_snipped;\n+                let sugg: Cow<'_, str> = {\n+                    let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n+                        (false, Some(fun_span)) => (fun_span, false),\n+                        _ => (arg.span, true),\n+                    };\n+                    let snippet = {\n+                        let not_macro_argument_snippet = snippet_with_macro_callsite(cx, snippet_span, \"..\");\n+                        if not_macro_argument_snippet == \"vec![]\" {\n+                            macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n+                            match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n+                                Some(stripped) => Cow::from(stripped),\n+                                None => macro_expanded_snipped\n+                            }\n+                        }\n+                        else {\n+                            not_macro_argument_snippet\n+                        }\n+                    };\n+\n+                    if use_lambda {\n+                        let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n+                        format!(\"|{}| {}\", l_arg, snippet).into()\n+                    } else {\n+                        snippet\n+                    }\n+                };\n+                let span_replace_word = method_span.with_hi(span.hi());\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span_replace_word,\n+                    &format!(\"use of `{}` followed by a function call\", name),\n+                    \"try this\",\n+                    format!(\"{}_{}({})\", name, suffix, sugg),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+\n+    if args.len() == 2 {\n+        match args[1].kind {\n+            hir::ExprKind::Call(ref fun, ref or_args) => {\n+                let or_has_args = !or_args.is_empty();\n+                if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n+                    let fun_span = if or_has_args { None } else { Some(fun.span) };\n+                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n+                }\n+            },\n+            hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n+                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}, {"sha": "e9e654432208d94813f5083cfb2fe931faa47829", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,101 @@\n+use crate::utils::{\n+    is_type_diagnostic_item, match_trait_method, paths, snippet, snippet_with_applicability, span_lint_and_help,\n+    span_lint_and_sugg, strip_pat_refs,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::PatKind;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+\n+use super::SEARCH_IS_SOME;\n+\n+/// lint searching an Iterator followed by `is_some()`\n+/// or calling `find()` on a string followed by `is_some()`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    search_method: &str,\n+    search_args: &'tcx [hir::Expr<'_>],\n+    is_some_args: &'tcx [hir::Expr<'_>],\n+    method_span: Span,\n+) {\n+    // lint if caller of search is an Iterator\n+    if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n+        let msg = format!(\n+            \"called `is_some()` after searching an `Iterator` with `{}`\",\n+            search_method\n+        );\n+        let hint = \"this is more succinctly expressed by calling `any()`\";\n+        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n+        if search_snippet.lines().count() <= 1 {\n+            // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n+            // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n+            let any_search_snippet = if_chain! {\n+                if search_method == \"find\";\n+                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].kind;\n+                let closure_body = cx.tcx.hir().body(body_id);\n+                if let Some(closure_arg) = closure_body.params.get(0);\n+                then {\n+                    if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n+                        Some(search_snippet.replacen('&', \"\", 1))\n+                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(&closure_arg.pat).kind {\n+                        let name = &*ident.name.as_str();\n+                        Some(search_snippet.replace(&format!(\"*{}\", name), name))\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            };\n+            // add note if not multi-line\n+            span_lint_and_sugg(\n+                cx,\n+                SEARCH_IS_SOME,\n+                method_span.with_hi(expr.span.hi()),\n+                &msg,\n+                \"use `any()` instead\",\n+                format!(\n+                    \"any({})\",\n+                    any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint_and_help(cx, SEARCH_IS_SOME, expr.span, &msg, None, hint);\n+        }\n+    }\n+    // lint if `find()` is called by `String` or `&str`\n+    else if search_method == \"find\" {\n+        let is_string_or_str_slice = |e| {\n+            let self_ty = cx.typeck_results().expr_ty(e).peel_refs();\n+            if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n+                true\n+            } else {\n+                *self_ty.kind() == ty::Str\n+            }\n+        };\n+        if_chain! {\n+            if is_string_or_str_slice(&search_args[0]);\n+            if is_string_or_str_slice(&search_args[1]);\n+            then {\n+                let msg = \"called `is_some()` after calling `find()` on a string\";\n+                let mut applicability = Applicability::MachineApplicable;\n+                let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n+                    method_span.with_hi(expr.span.hi()),\n+                    msg,\n+                    \"use `contains()` instead\",\n+                    format!(\"contains({})\", find_arg),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "0ce8b66978dc12cdd4e307a8612ab2dce2d860cf", "filename": "clippy_lints/src/methods/single_char_insert_string.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,27 @@\n+use crate::methods::get_hint_if_single_char_arg;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SINGLE_CHAR_ADD_STR;\n+\n+/// lint for length-1 `str`s as argument for `insert_str`\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[2], &mut applicability) {\n+        let base_string_snippet =\n+            snippet_with_applicability(cx, args[0].span.source_callsite(), \"_\", &mut applicability);\n+        let pos_arg = snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability);\n+        let sugg = format!(\"{}.insert({}, {})\", base_string_snippet, pos_arg, extension_string);\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_ADD_STR,\n+            expr.span,\n+            \"calling `insert_str()` using a single-character string literal\",\n+            \"consider using `insert` with a character literal\",\n+            sugg,\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "61cbc9d2f0a6296d83d1b58af359380e9fdedd5e", "filename": "clippy_lints/src/methods/single_char_pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,23 @@\n+use crate::methods::get_hint_if_single_char_arg;\n+use crate::utils::span_lint_and_sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SINGLE_CHAR_PATTERN;\n+\n+/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n+pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability) {\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_PATTERN,\n+            arg.span,\n+            \"single-character string constant used as pattern\",\n+            \"try using a `char` instead\",\n+            hint,\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "deacc70b713e5ae15d6b571cb9877f8aa9a8fd10", "filename": "clippy_lints/src/methods/single_char_push_string.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,26 @@\n+use crate::methods::get_hint_if_single_char_arg;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SINGLE_CHAR_ADD_STR;\n+\n+/// lint for length-1 `str`s as argument for `push_str`\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n+        let base_string_snippet =\n+            snippet_with_applicability(cx, args[0].span.source_callsite(), \"..\", &mut applicability);\n+        let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_ADD_STR,\n+            expr.span,\n+            \"calling `push_str()` using a single-character string literal\",\n+            \"consider using `push` with a character literal\",\n+            sugg,\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "8ba6ae952003e6ce480a65e9e316cd7dadf5a371", "filename": "clippy_lints/src/methods/skip_while_next.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,20 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SKIP_WHILE_NEXT;\n+\n+/// lint use of `skip_while().next()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, _skip_while_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.skip_while().next()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        span_lint_and_help(\n+            cx,\n+            SKIP_WHILE_NEXT,\n+            expr.span,\n+            \"called `skip_while(<p>).next()` on an `Iterator`\",\n+            None,\n+            \"this is more succinctly expressed by calling `.find(!<p>)` instead\",\n+        );\n+    }\n+}"}, {"sha": "0a08ea26175fe17d7a2589923a4b303ae4abc9e8", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,42 @@\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::STRING_EXTEND_CHARS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+    if is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n+        let arg = &args[1];\n+        if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n+            let target = &arglists[0][0];\n+            let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n+            let ref_str = if *self_ty.kind() == ty::Str {\n+                \"\"\n+            } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n+                \"&\"\n+            } else {\n+                return;\n+            };\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                STRING_EXTEND_CHARS,\n+                expr.span,\n+                \"calling `.extend(_.chars())`\",\n+                \"try this\",\n+                format!(\n+                    \"{}.push_str({}{})\",\n+                    snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n+                    ref_str,\n+                    snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "e135a826dc4d093e855a228d679b40669249ceb9", "filename": "clippy_lints/src/methods/suspicious_map.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,16 @@\n+use crate::utils::span_lint_and_help;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SUSPICIOUS_MAP;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n+    span_lint_and_help(\n+        cx,\n+        SUSPICIOUS_MAP,\n+        expr.span,\n+        \"this call to `map()` won't have an effect on the call to `count()`\",\n+        None,\n+        \"make sure you did not confuse `map` with `filter` or `for_each`\",\n+    );\n+}"}, {"sha": "798b66192c81829cd53afc1816f97277125ddc37", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,35 @@\n+use crate::utils::{match_def_path, match_qpath, paths, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::UNINIT_ASSUMED_INIT;\n+\n+/// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Expr<'_>) {\n+    if_chain! {\n+        if let hir::ExprKind::Call(ref callee, ref args) = expr.kind;\n+        if args.is_empty();\n+        if let hir::ExprKind::Path(ref path) = callee.kind;\n+        if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n+        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(outer));\n+        then {\n+            span_lint(\n+                cx,\n+                UNINIT_ASSUMED_INIT,\n+                outer.span,\n+                \"this call for this type may be undefined behavior\"\n+            );\n+        }\n+    }\n+}\n+\n+fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n+        ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n+        ty::Adt(ref adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n+        _ => false,\n+    }\n+}"}, {"sha": "12b2cf0a16582f407d65902a5b1abe4fb64a189b", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -9,7 +9,7 @@ use if_chain::if_chain;\n \n use super::UNNECESSARY_FILTER_MAP;\n \n-pub(super) fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n     }"}, {"sha": "a26443f4ee94420be3fb97007329249448c049e1", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,101 @@\n+use crate::utils::{\n+    match_trait_method, path_to_local_id, paths, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n+    strip_pat_refs,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::PatKind;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::UNNECESSARY_FOLD;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n+    fn check_fold_with_op(\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        fold_args: &[hir::Expr<'_>],\n+        fold_span: Span,\n+        op: hir::BinOpKind,\n+        replacement_method_name: &str,\n+        replacement_has_args: bool,\n+    ) {\n+        if_chain! {\n+            // Extract the body of the closure passed to fold\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].kind;\n+            let closure_body = cx.tcx.hir().body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+\n+            // Check if the closure body is of the form `acc <op> some_expr(x)`\n+            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.kind;\n+            if bin_op.node == op;\n+\n+            // Extract the names of the two arguments to the closure\n+            if let [param_a, param_b] = closure_body.params;\n+            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(&param_a.pat).kind;\n+            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(&param_b.pat).kind;\n+\n+            if path_to_local_id(left_expr, first_arg_id);\n+            if replacement_has_args || path_to_local_id(right_expr, second_arg_id);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let sugg = if replacement_has_args {\n+                    format!(\n+                        \"{replacement}(|{s}| {r})\",\n+                        replacement = replacement_method_name,\n+                        s = second_arg_ident,\n+                        r = snippet_with_applicability(cx, right_expr.span, \"EXPR\", &mut applicability),\n+                    )\n+                } else {\n+                    format!(\n+                        \"{replacement}()\",\n+                        replacement = replacement_method_name,\n+                    )\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_FOLD,\n+                    fold_span.with_hi(expr.span.hi()),\n+                    // TODO #2371 don't suggest e.g., .any(|x| f(x)) if we can suggest .any(f)\n+                    \"this `.fold` can be written more succinctly using another method\",\n+                    \"try\",\n+                    sugg,\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+\n+    // Check that this is a call to Iterator::fold rather than just some function called fold\n+    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n+        return;\n+    }\n+\n+    assert!(\n+        fold_args.len() == 3,\n+        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\"\n+    );\n+\n+    // Check if the first argument to .fold is a suitable literal\n+    if let hir::ExprKind::Lit(ref lit) = fold_args[1].kind {\n+        match lit.node {\n+            ast::LitKind::Bool(false) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Or, \"any\", true)\n+            },\n+            ast::LitKind::Bool(true) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::And, \"all\", true)\n+            },\n+            ast::LitKind::Int(0, _) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Add, \"sum\", false)\n+            },\n+            ast::LitKind::Int(1, _) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Mul, \"product\", false)\n+            },\n+            _ => (),\n+        }\n+    }\n+}"}, {"sha": "a17259d697faa3128d33a83f8699f9e4f5efa86e", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -9,7 +9,7 @@ use super::UNNECESSARY_LAZY_EVALUATIONS;\n \n /// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n /// replaced with `<fn>(return value of simple closure)`\n-pub(super) fn lint<'tcx>(\n+pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],"}, {"sha": "094c3fc45c493b097b13c4bba274938aa1c5f2ee", "filename": "clippy_lints/src/methods/unwrap_used.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,34 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::UNWRAP_USED;\n+\n+/// lint use of `unwrap()` for `Option`s and `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n+\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n+        Some((UNWRAP_USED, \"an Option\", \"None\"))\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n+        Some((UNWRAP_USED, \"a Result\", \"Err\"))\n+    } else {\n+        None\n+    };\n+\n+    if let Some((lint, kind, none_value)) = mess {\n+        span_lint_and_help(\n+            cx,\n+            lint,\n+            expr.span,\n+            &format!(\"used `unwrap()` on `{}` value\", kind,),\n+            None,\n+            &format!(\n+                \"if you don't want to handle the `{}` case gracefully, consider \\\n+                using `expect()` to provide a better panic message\",\n+                none_value,\n+            ),\n+        );\n+    }\n+}"}, {"sha": "e4554f8d4897e21470d34605ec481ab7d4d34dec", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{\n+    get_parent_expr, match_trait_method, paths, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty_depth,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::USELESS_ASREF;\n+\n+/// Checks for the `USELESS_ASREF` lint.\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n+    // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n+    // check if the call is to the actual `AsRef` or `AsMut` trait\n+    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n+        // check if the type after `as_ref` or `as_mut` is the same as before\n+        let recvr = &as_ref_args[0];\n+        let rcv_ty = cx.typeck_results().expr_ty(recvr);\n+        let res_ty = cx.typeck_results().expr_ty(expr);\n+        let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n+        let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n+        if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n+            // allow the `as_ref` or `as_mut` if it is followed by another method call\n+            if_chain! {\n+                if let Some(parent) = get_parent_expr(cx, expr);\n+                if let hir::ExprKind::MethodCall(_, ref span, _, _) = parent.kind;\n+                if span != &expr.span;\n+                then {\n+                    return;\n+                }\n+            }\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                USELESS_ASREF,\n+                expr.span,\n+                &format!(\"this call to `{}` does nothing\", call_name),\n+                \"try this\",\n+                snippet_with_applicability(cx, recvr.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "90fab577436618a231b527c75b4e9fede9bc2413", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,76 @@\n+use crate::methods::SelfKind;\n+use crate::utils::span_lint;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use rustc_span::source_map::Span;\n+use std::fmt;\n+\n+use super::WRONG_PUB_SELF_CONVENTION;\n+use super::WRONG_SELF_CONVENTION;\n+\n+#[rustfmt::skip]\n+const CONVENTIONS: [(Convention, &[SelfKind]); 7] = [\n+    (Convention::Eq(\"new\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"as_\"), &[SelfKind::Ref, SelfKind::RefMut]),\n+    (Convention::StartsWith(\"from_\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"into_\"), &[SelfKind::Value]),\n+    (Convention::StartsWith(\"is_\"), &[SelfKind::Ref, SelfKind::No]),\n+    (Convention::Eq(\"to_mut\"), &[SelfKind::RefMut]),\n+    (Convention::StartsWith(\"to_\"), &[SelfKind::Ref]),\n+];\n+enum Convention {\n+    Eq(&'static str),\n+    StartsWith(&'static str),\n+}\n+\n+impl Convention {\n+    #[must_use]\n+    fn check(&self, other: &str) -> bool {\n+        match *self {\n+            Self::Eq(this) => this == other,\n+            Self::StartsWith(this) => other.starts_with(this) && this != other,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Convention {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n+        match *self {\n+            Self::Eq(this) => this.fmt(f),\n+            Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+        }\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    item_name: &str,\n+    is_pub: bool,\n+    self_ty: &'tcx TyS<'tcx>,\n+    first_arg_ty: &'tcx TyS<'tcx>,\n+    first_arg_span: Span,\n+) {\n+    let lint = if is_pub {\n+        WRONG_PUB_SELF_CONVENTION\n+    } else {\n+        WRONG_SELF_CONVENTION\n+    };\n+    if let Some((ref conv, self_kinds)) = &CONVENTIONS.iter().find(|(ref conv, _)| conv.check(item_name)) {\n+        if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n+            span_lint(\n+                cx,\n+                lint,\n+                first_arg_span,\n+                &format!(\n+                    \"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n+                    conv,\n+                    &self_kinds\n+                        .iter()\n+                        .map(|k| k.description())\n+                        .collect::<Vec<_>>()\n+                        .join(\" or \")\n+                ),\n+            );\n+        }\n+    }\n+}"}, {"sha": "f1335726736ca4d85f3e927091d078edd0a1247d", "filename": "clippy_lints/src/methods/zst_offset.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42", "patch": "@@ -0,0 +1,19 @@\n+use crate::utils::span_lint;\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::ZST_OFFSET;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    if_chain! {\n+        if args.len() == 2;\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind();\n+        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n+        if layout.is_zst();\n+        then {\n+            span_lint(cx, ZST_OFFSET, expr.span, \"offset calculation on zero-sized value\");\n+        }\n+    }\n+}"}]}