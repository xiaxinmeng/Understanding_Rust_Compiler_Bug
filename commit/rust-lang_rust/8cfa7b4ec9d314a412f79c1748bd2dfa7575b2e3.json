{"sha": "8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZmE3YjRlYzlkMzE0YTQxMmY3OWMxNzQ4YmQyZGZhNzU3NWIyZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-21T01:30:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-21T01:30:26Z"}, "message": "Auto merge of #78588 - HeroicKatora:sccc, r=nikomatsakis\n\nReworks Sccc computation to iteration instead of recursion\n\nLinear graphs, producing as many scc's as nodes, would recurse once for every node when entered from the start of the list. This adds a test that exhausted the stack at least on my machine with error:\n\n```\nthread 'graph::scc::tests::test_deep_linear' has overflowed its stack\nfatal runtime error: stack overflow\n```\n\nThis may or may not be connected to #78567. I was only reminded that I started this rework some time ago. It might be plausible as borrow checking a long function with many borrow regions around each other\u2014((((((\u2026))))))\u2014 may produce the linear list setup to trigger this stack overflow ? I don't know enough about borrow check to say for sure.\n\nThis is best read in two separate commits. The first addresses only `find_state` internally. This is classical union phase from union-find. There's also a common solution of using the parent pointers in the (virtual) linked list to track the backreferences while traversing upwards and then following them backwards in a second path compression phase.\n\nThe second is more involved as it rewrites the mutually recursive `walk_node` and `walk_unvisited_node`. Firstly, the caller is required to handle the unvisited case of `walk_node` so a new `start_walk_from` method is added to handle that by walking the unvisited node if necessary. Then `walk_unvisited_node`, where we would previously recurse into in the missing case, is rewritten to construct a manual stack of its frames. The state fields consist of the previous stack slots.", "tree": {"sha": "31f8b9d55570d5f4c473af7106006772fc1e8064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31f8b9d55570d5f4c473af7106006772fc1e8064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3", "html_url": "https://github.com/rust-lang/rust/commit/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "432d116a5c2565774bae4c42fcacab8b685608b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/432d116a5c2565774bae4c42fcacab8b685608b5", "html_url": "https://github.com/rust-lang/rust/commit/432d116a5c2565774bae4c42fcacab8b685608b5"}, {"sha": "eb597f5c4e258563cac1a957ae348f7c24cb0734", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb597f5c4e258563cac1a957ae348f7c24cb0734", "html_url": "https://github.com/rust-lang/rust/commit/eb597f5c4e258563cac1a957ae348f7c24cb0734"}], "stats": {"total": 459, "additions": 364, "deletions": 95}, "files": [{"sha": "5b3d8233f3da3b960c1c2cef55edacfd49b52128", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 292, "deletions": 95, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3", "patch": "@@ -231,20 +231,30 @@ where\n \n         let scc_indices = (0..num_nodes)\n             .map(G::Node::new)\n-            .map(|node| match this.walk_node(0, node) {\n+            .map(|node| match this.start_walk_from(node) {\n                 WalkReturn::Complete { scc_index } => scc_index,\n-                WalkReturn::Cycle { min_depth } => {\n-                    panic!(\"`walk_node(0, {:?})` returned cycle with depth {:?}\", node, min_depth)\n-                }\n+                WalkReturn::Cycle { min_depth } => panic!(\n+                    \"`start_walk_node({:?})` returned cycle with depth {:?}\",\n+                    node, min_depth\n+                ),\n             })\n             .collect();\n \n         Sccs { scc_indices, scc_data: this.scc_data }\n     }\n \n-    /// Visits a node during the DFS. We first examine its current\n-    /// state -- if it is not yet visited (`NotVisited`), we can push\n-    /// it onto the stack and start walking its successors.\n+    fn start_walk_from(&mut self, node: G::Node) -> WalkReturn<S> {\n+        if let Some(result) = self.inspect_node(node) {\n+            result\n+        } else {\n+            self.walk_unvisited_node(node)\n+        }\n+    }\n+\n+    /// Inspect a node during the DFS. We first examine its current\n+    /// state -- if it is not yet visited (`NotVisited`), return `None` so\n+    /// that the caller might push it onto the stack and start walking its\n+    /// successors.\n     ///\n     /// If it is already on the DFS stack it will be in the state\n     /// `BeingVisited`. In that case, we have found a cycle and we\n@@ -253,125 +263,312 @@ where\n     /// Otherwise, we are looking at a node that has already been\n     /// completely visited. We therefore return `WalkReturn::Complete`\n     /// with its associated SCC index.\n-    fn walk_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n-        debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, node);\n-        match self.find_state(node) {\n+    fn inspect_node(&mut self, node: G::Node) -> Option<WalkReturn<S>> {\n+        Some(match self.find_state(node) {\n             NodeState::InCycle { scc_index } => WalkReturn::Complete { scc_index },\n \n             NodeState::BeingVisited { depth: min_depth } => WalkReturn::Cycle { min_depth },\n \n-            NodeState::NotVisited => self.walk_unvisited_node(depth, node),\n+            NodeState::NotVisited => return None,\n \n             NodeState::InCycleWith { parent } => panic!(\n                 \"`find_state` returned `InCycleWith({:?})`, which ought to be impossible\",\n                 parent\n             ),\n-        }\n+        })\n     }\n \n     /// Fetches the state of the node `r`. If `r` is recorded as being\n     /// in a cycle with some other node `r2`, then fetches the state\n     /// of `r2` (and updates `r` to reflect current result). This is\n     /// basically the \"find\" part of a standard union-find algorithm\n     /// (with path compression).\n-    fn find_state(&mut self, r: G::Node) -> NodeState<G::Node, S> {\n-        debug!(\"find_state(r = {:?} in state {:?})\", r, self.node_states[r]);\n-        match self.node_states[r] {\n-            NodeState::InCycle { scc_index } => NodeState::InCycle { scc_index },\n-            NodeState::BeingVisited { depth } => NodeState::BeingVisited { depth },\n-            NodeState::NotVisited => NodeState::NotVisited,\n-            NodeState::InCycleWith { parent } => {\n-                let parent_state = self.find_state(parent);\n-                debug!(\"find_state: parent_state = {:?}\", parent_state);\n-                match parent_state {\n-                    NodeState::InCycle { .. } => {\n-                        self.node_states[r] = parent_state;\n-                        parent_state\n-                    }\n+    fn find_state(&mut self, mut node: G::Node) -> NodeState<G::Node, S> {\n+        // To avoid recursion we temporarily reuse the `parent` of each\n+        // InCycleWith link to encode a downwards link while compressing\n+        // the path. After we have found the root or deepest node being\n+        // visited, we traverse the reverse links and correct the node\n+        // states on the way.\n+        //\n+        // **Note**: This mutation requires that this is a leaf function\n+        // or at least that none of the called functions inspects the\n+        // current node states. Luckily, we are a leaf.\n+\n+        // Remember one previous link. The termination condition when\n+        // following links downwards is then simply as soon as we have\n+        // found the initial self-loop.\n+        let mut previous_node = node;\n+\n+        // Ultimately assigned by the parent when following\n+        // `InCycleWith` upwards.\n+        let node_state = loop {\n+            debug!(\"find_state(r = {:?} in state {:?})\", node, self.node_states[node]);\n+            match self.node_states[node] {\n+                NodeState::InCycle { scc_index } => break NodeState::InCycle { scc_index },\n+                NodeState::BeingVisited { depth } => break NodeState::BeingVisited { depth },\n+                NodeState::NotVisited => break NodeState::NotVisited,\n+                NodeState::InCycleWith { parent } => {\n+                    // We test this, to be extremely sure that we never\n+                    // ever break our termination condition for the\n+                    // reverse iteration loop.\n+                    assert!(node != parent, \"Node can not be in cycle with itself\");\n+                    // Store the previous node as an inverted list link\n+                    self.node_states[node] = NodeState::InCycleWith { parent: previous_node };\n+                    // Update to parent node.\n+                    previous_node = node;\n+                    node = parent;\n+                }\n+            }\n+        };\n \n-                    NodeState::BeingVisited { depth } => {\n-                        self.node_states[r] =\n-                            NodeState::InCycleWith { parent: self.node_stack[depth] };\n-                        parent_state\n-                    }\n+        // The states form a graph where up to one outgoing link is stored at\n+        // each node. Initially in general,\n+        //\n+        //                                                  E\n+        //                                                  ^\n+        //                                                  |\n+        //                                InCycleWith/BeingVisited/NotVisited\n+        //                                                  |\n+        //   A-InCycleWith->B-InCycleWith\u2026>C-InCycleWith->D-+\n+        //   |\n+        //   = node, previous_node\n+        //\n+        // After the first loop, this will look like\n+        //                                                  E\n+        //                                                  ^\n+        //                                                  |\n+        //                                InCycleWith/BeingVisited/NotVisited\n+        //                                                  |\n+        // +>A<-InCycleWith-B<\u2026InCycleWith-C<-InCycleWith-D-+\n+        // | |                             |              |\n+        // | InCycleWith                   |              = node\n+        // +-+                             =previous_node\n+        //\n+        // Note in particular that A will be linked to itself in a self-cycle\n+        // and no other self-cycles occur due to how InCycleWith is assigned in\n+        // the find phase implemented by `walk_unvisited_node`.\n+        //\n+        // We now want to compress the path, that is assign the state of the\n+        // link D-E to all other links.\n+        //\n+        // We can then walk backwards, starting from `previous_node`, and assign\n+        // each node in the list with the updated state. The loop terminates\n+        // when we reach the self-cycle.\n+\n+        // Move backwards until we found the node where we started. We\n+        // will know when we hit the state where previous_node == node.\n+        loop {\n+            // Back at the beginning, we can return.\n+            if previous_node == node {\n+                return node_state;\n+            }\n+            // Update to previous node in the link.\n+            match self.node_states[previous_node] {\n+                NodeState::InCycleWith { parent: previous } => {\n+                    node = previous_node;\n+                    previous_node = previous;\n+                }\n+                // Only InCycleWith nodes were added to the reverse linked list.\n+                other => panic!(\"Invalid previous link while compressing cycle: {:?}\", other),\n+            }\n \n-                    NodeState::NotVisited | NodeState::InCycleWith { .. } => {\n-                        panic!(\"invalid parent state: {:?}\", parent_state)\n-                    }\n+            debug!(\"find_state: parent_state = {:?}\", node_state);\n+\n+            // Update the node state from the parent state. The assigned\n+            // state is actually a loop invariant but it will only be\n+            // evaluated if there is at least one backlink to follow.\n+            // Fully trusting llvm here to find this loop optimization.\n+            match node_state {\n+                // Path compression, make current node point to the same root.\n+                NodeState::InCycle { .. } => {\n+                    self.node_states[node] = node_state;\n+                }\n+                // Still visiting nodes, compress to cycle to the node\n+                // at that depth.\n+                NodeState::BeingVisited { depth } => {\n+                    self.node_states[node] =\n+                        NodeState::InCycleWith { parent: self.node_stack[depth] };\n+                }\n+                // These are never allowed as parent nodes. InCycleWith\n+                // should have been followed to a real parent and\n+                // NotVisited can not be part of a cycle since it should\n+                // have instead gotten explored.\n+                NodeState::NotVisited | NodeState::InCycleWith { .. } => {\n+                    panic!(\"invalid parent state: {:?}\", node_state)\n                 }\n             }\n         }\n     }\n \n     /// Walks a node that has never been visited before.\n-    fn walk_unvisited_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n-        debug!(\"walk_unvisited_node(depth = {:?}, node = {:?})\", depth, node);\n-\n-        debug_assert!(matches!(self.node_states[node], NodeState::NotVisited));\n-\n-        // Push `node` onto the stack.\n-        self.node_states[node] = NodeState::BeingVisited { depth };\n-        self.node_stack.push(node);\n-\n-        // Walk each successor of the node, looking to see if any of\n-        // them can reach a node that is presently on the stack. If\n-        // so, that means they can also reach us.\n-        let mut min_depth = depth;\n-        let mut min_cycle_root = node;\n-        let successors_len = self.successors_stack.len();\n-        for successor_node in self.graph.successors(node) {\n-            debug!(\"walk_unvisited_node: node = {:?} successor_ode = {:?}\", node, successor_node);\n-            match self.walk_node(depth + 1, successor_node) {\n-                WalkReturn::Cycle { min_depth: successor_min_depth } => {\n-                    // Track the minimum depth we can reach.\n-                    assert!(successor_min_depth <= depth);\n-                    if successor_min_depth < min_depth {\n+    ///\n+    /// Call this method when `inspect_node` has returned `None`. Having the\n+    /// caller decide avoids mutual recursion between the two methods and allows\n+    /// us to maintain an allocated stack for nodes on the path between calls.\n+    fn walk_unvisited_node(&mut self, initial: G::Node) -> WalkReturn<S> {\n+        struct VisitingNodeFrame<G: DirectedGraph, Successors> {\n+            node: G::Node,\n+            iter: Option<Successors>,\n+            depth: usize,\n+            min_depth: usize,\n+            successors_len: usize,\n+            min_cycle_root: G::Node,\n+            successor_node: G::Node,\n+        }\n+\n+        // Move the stack to a local variable. We want to utilize the existing allocation and\n+        // mutably borrow it without borrowing self at the same time.\n+        let mut successors_stack = core::mem::take(&mut self.successors_stack);\n+        debug_assert_eq!(successors_stack.len(), 0);\n+\n+        let mut stack: Vec<VisitingNodeFrame<G, _>> = vec![VisitingNodeFrame {\n+            node: initial,\n+            depth: 0,\n+            min_depth: 0,\n+            iter: None,\n+            successors_len: 0,\n+            min_cycle_root: initial,\n+            successor_node: initial,\n+        }];\n+\n+        let mut return_value = None;\n+\n+        'recurse: while let Some(frame) = stack.last_mut() {\n+            let VisitingNodeFrame {\n+                node,\n+                depth,\n+                iter,\n+                successors_len,\n+                min_depth,\n+                min_cycle_root,\n+                successor_node,\n+            } = frame;\n+\n+            let node = *node;\n+            let depth = *depth;\n+\n+            let successors = match iter {\n+                Some(iter) => iter,\n+                None => {\n+                    // This None marks that we still have the initialize this node's frame.\n+                    debug!(\"walk_unvisited_node(depth = {:?}, node = {:?})\", depth, node);\n+\n+                    debug_assert!(matches!(self.node_states[node], NodeState::NotVisited));\n+\n+                    // Push `node` onto the stack.\n+                    self.node_states[node] = NodeState::BeingVisited { depth };\n+                    self.node_stack.push(node);\n+\n+                    // Walk each successor of the node, looking to see if any of\n+                    // them can reach a node that is presently on the stack. If\n+                    // so, that means they can also reach us.\n+                    *successors_len = successors_stack.len();\n+                    // Set and return a reference, this is currently empty.\n+                    iter.get_or_insert(self.graph.successors(node))\n+                }\n+            };\n+\n+            // Now that iter is initialized, this is a constant for this frame.\n+            let successors_len = *successors_len;\n+\n+            // Construct iterators for the nodes and walk results. There are two cases:\n+            // * The walk of a successor node returned.\n+            // * The remaining successor nodes.\n+            let returned_walk =\n+                return_value.take().into_iter().map(|walk| (*successor_node, Some(walk)));\n+\n+            let successor_walk = successors.by_ref().map(|successor_node| {\n+                debug!(\n+                    \"walk_unvisited_node: node = {:?} successor_ode = {:?}\",\n+                    node, successor_node\n+                );\n+                (successor_node, self.inspect_node(successor_node))\n+            });\n+\n+            for (successor_node, walk) in returned_walk.chain(successor_walk) {\n+                match walk {\n+                    Some(WalkReturn::Cycle { min_depth: successor_min_depth }) => {\n+                        // Track the minimum depth we can reach.\n+                        assert!(successor_min_depth <= depth);\n+                        if successor_min_depth < *min_depth {\n+                            debug!(\n+                                \"walk_unvisited_node: node = {:?} successor_min_depth = {:?}\",\n+                                node, successor_min_depth\n+                            );\n+                            *min_depth = successor_min_depth;\n+                            *min_cycle_root = successor_node;\n+                        }\n+                    }\n+\n+                    Some(WalkReturn::Complete { scc_index: successor_scc_index }) => {\n+                        // Push the completed SCC indices onto\n+                        // the `successors_stack` for later.\n                         debug!(\n-                            \"walk_unvisited_node: node = {:?} successor_min_depth = {:?}\",\n-                            node, successor_min_depth\n+                            \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n+                            node, successor_scc_index\n                         );\n-                        min_depth = successor_min_depth;\n-                        min_cycle_root = successor_node;\n+                        successors_stack.push(successor_scc_index);\n                     }\n-                }\n \n-                WalkReturn::Complete { scc_index: successor_scc_index } => {\n-                    // Push the completed SCC indices onto\n-                    // the `successors_stack` for later.\n-                    debug!(\n-                        \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n-                        node, successor_scc_index\n-                    );\n-                    self.successors_stack.push(successor_scc_index);\n+                    None => {\n+                        let depth = depth + 1;\n+                        debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, successor_node);\n+                        // Remember which node the return value will come from.\n+                        frame.successor_node = successor_node;\n+                        // Start a new stack frame the step into it.\n+                        stack.push(VisitingNodeFrame {\n+                            node: successor_node,\n+                            depth,\n+                            iter: None,\n+                            successors_len: 0,\n+                            min_depth: depth,\n+                            min_cycle_root: successor_node,\n+                            successor_node: successor_node,\n+                        });\n+                        continue 'recurse;\n+                    }\n                 }\n             }\n-        }\n \n-        // Completed walk, remove `node` from the stack.\n-        let r = self.node_stack.pop();\n-        debug_assert_eq!(r, Some(node));\n-\n-        // If `min_depth == depth`, then we are the root of the\n-        // cycle: we can't reach anyone further down the stack.\n-        if min_depth == depth {\n-            // Note that successor stack may have duplicates, so we\n-            // want to remove those:\n-            let deduplicated_successors = {\n-                let duplicate_set = &mut self.duplicate_set;\n-                duplicate_set.clear();\n-                self.successors_stack\n-                    .drain(successors_len..)\n-                    .filter(move |&i| duplicate_set.insert(i))\n-            };\n-            let scc_index = self.scc_data.create_scc(deduplicated_successors);\n-            self.node_states[node] = NodeState::InCycle { scc_index };\n-            WalkReturn::Complete { scc_index }\n-        } else {\n-            // We are not the head of the cycle. Return back to our\n-            // caller. They will take ownership of the\n-            // `self.successors` data that we pushed.\n-            self.node_states[node] = NodeState::InCycleWith { parent: min_cycle_root };\n-            WalkReturn::Cycle { min_depth }\n+            // Completed walk, remove `node` from the stack.\n+            let r = self.node_stack.pop();\n+            debug_assert_eq!(r, Some(node));\n+\n+            // Remove the frame, it's done.\n+            let frame = stack.pop().unwrap();\n+\n+            // If `min_depth == depth`, then we are the root of the\n+            // cycle: we can't reach anyone further down the stack.\n+\n+            // Pass the 'return value' down the stack.\n+            // We return one frame at a time so there can't be another return value.\n+            debug_assert!(return_value.is_none());\n+            return_value = Some(if frame.min_depth == depth {\n+                // Note that successor stack may have duplicates, so we\n+                // want to remove those:\n+                let deduplicated_successors = {\n+                    let duplicate_set = &mut self.duplicate_set;\n+                    duplicate_set.clear();\n+                    successors_stack\n+                        .drain(successors_len..)\n+                        .filter(move |&i| duplicate_set.insert(i))\n+                };\n+                let scc_index = self.scc_data.create_scc(deduplicated_successors);\n+                self.node_states[node] = NodeState::InCycle { scc_index };\n+                WalkReturn::Complete { scc_index }\n+            } else {\n+                // We are not the head of the cycle. Return back to our\n+                // caller. They will take ownership of the\n+                // `self.successors` data that we pushed.\n+                self.node_states[node] = NodeState::InCycleWith { parent: frame.min_cycle_root };\n+                WalkReturn::Cycle { min_depth: frame.min_depth }\n+            });\n         }\n+\n+        // Keep the allocation we used for successors_stack.\n+        self.successors_stack = successors_stack;\n+        debug_assert_eq!(self.successors_stack.len(), 0);\n+\n+        return_value.unwrap()\n     }\n }"}, {"sha": "364005e67e63f91f0dd5dc2a563ef7f0b465d6db", "filename": "compiler/rustc_data_structures/src/graph/scc/tests.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs?ref=8cfa7b4ec9d314a412f79c1748bd2dfa7575b2e3", "patch": "@@ -1,3 +1,5 @@\n+extern crate test;\n+\n use super::*;\n use crate::graph::tests::TestGraph;\n \n@@ -139,3 +141,73 @@ fn test_find_state_3() {\n     assert_eq!(sccs.successors(0), &[]);\n     assert_eq!(sccs.successors(1), &[0]);\n }\n+\n+#[test]\n+fn test_deep_linear() {\n+    /*\n+    0\n+    |\n+    v\n+    1\n+    |\n+    v\n+    2\n+    |\n+    v\n+    \u2026\n+     */\n+    const NR_NODES: usize = 1 << 14;\n+    let mut nodes = vec![];\n+    for i in 1..NR_NODES {\n+        nodes.push((i - 1, i));\n+    }\n+    let graph = TestGraph::new(0, nodes.as_slice());\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), NR_NODES);\n+    assert_eq!(sccs.scc(0), NR_NODES - 1);\n+    assert_eq!(sccs.scc(NR_NODES - 1), 0);\n+}\n+\n+#[bench]\n+fn bench_sccc(b: &mut test::Bencher) {\n+    // Like `test_three_sccs` but each state is replaced by a group of\n+    // three or four to have some amount of test data.\n+    /*\n+       0-3\n+        |\n+        v\n+    +->4-6 11-14\n+    |   |    |\n+    |   v    |\n+    +--7-10<-+\n+         */\n+    fn make_3_clique(slice: &mut [(usize, usize)], base: usize) {\n+        slice[0] = (base + 0, base + 1);\n+        slice[1] = (base + 1, base + 2);\n+        slice[2] = (base + 2, base + 0);\n+    }\n+    // Not actually a clique but strongly connected.\n+    fn make_4_clique(slice: &mut [(usize, usize)], base: usize) {\n+        slice[0] = (base + 0, base + 1);\n+        slice[1] = (base + 1, base + 2);\n+        slice[2] = (base + 2, base + 3);\n+        slice[3] = (base + 3, base + 0);\n+        slice[4] = (base + 1, base + 3);\n+        slice[5] = (base + 2, base + 1);\n+    }\n+\n+    let mut graph = [(0, 0); 6 + 3 + 6 + 3 + 4];\n+    make_4_clique(&mut graph[0..6], 0);\n+    make_3_clique(&mut graph[6..9], 4);\n+    make_4_clique(&mut graph[9..15], 7);\n+    make_3_clique(&mut graph[15..18], 11);\n+    graph[18] = (0, 4);\n+    graph[19] = (5, 7);\n+    graph[20] = (11, 10);\n+    graph[21] = (7, 4);\n+    let graph = TestGraph::new(0, &graph[..]);\n+    b.iter(|| {\n+        let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+        assert_eq!(sccs.num_sccs(), 3);\n+    });\n+}"}]}