{"sha": "1f512948a03cd24c2f8a056be0a2f53675802fd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNTEyOTQ4YTAzY2QyNGMyZjhhMDU2YmUwYTJmNTM2NzU4MDJmZDI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-12T03:58:58Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-13T02:41:49Z"}, "message": "Reformat source code using new defaults", "tree": {"sha": "683723a5fc810af95d0c9c97cdbd98e87fc64063", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/683723a5fc810af95d0c9c97cdbd98e87fc64063"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f512948a03cd24c2f8a056be0a2f53675802fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f512948a03cd24c2f8a056be0a2f53675802fd2", "html_url": "https://github.com/rust-lang/rust/commit/1f512948a03cd24c2f8a056be0a2f53675802fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f512948a03cd24c2f8a056be0a2f53675802fd2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32e882789ba98cf6c02b1822beecacbcb8800269", "url": "https://api.github.com/repos/rust-lang/rust/commits/32e882789ba98cf6c02b1822beecacbcb8800269", "html_url": "https://github.com/rust-lang/rust/commit/32e882789ba98cf6c02b1822beecacbcb8800269"}], "stats": {"total": 5705, "additions": 3241, "deletions": 2464}, "files": [{"sha": "b7b906b5d40e2ec0a0334a2b2e299eed18eed1ce", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -1,6 +1,6 @@\n [root]\n name = \"rustfmt\"\n-version = \"0.8.5\"\n+version = \"0.9.0\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "6bb598f0c0e9e1e4db83a36c21cc377246587d60", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -1,7 +1,7 @@\n [package]\n \n name = \"rustfmt\"\n-version = \"0.9\"\n+version = \"0.9.0\"\n authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang-nursery/rustfmt\""}, {"sha": "eeccae5c0776899248f867c7a38f191d42d1937b", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -42,10 +42,12 @@ fn execute() -> i32 {\n     opts.optflag(\"h\", \"help\", \"show this message\");\n     opts.optflag(\"q\", \"quiet\", \"no output printed to stdout\");\n     opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n-    opts.optmulti(\"p\",\n-                  \"package\",\n-                  \"specify package to format (only usable in workspaces)\",\n-                  \"<package>\");\n+    opts.optmulti(\n+        \"p\",\n+        \"package\",\n+        \"specify package to format (only usable in workspaces)\",\n+        \"<package>\",\n+    );\n     opts.optflag(\"\", \"all\", \"format all packages (only usable in workspaces)\");\n \n     let matches = match opts.parse(env::args().skip(1).take_while(|a| a != \"--\")) {\n@@ -90,9 +92,11 @@ fn execute() -> i32 {\n \n fn print_usage(opts: &Options, reason: &str) {\n     let msg = format!(\"{}\\nusage: cargo fmt [options]\", reason);\n-    println!(\"{}\\nThis utility formats all bin and lib files of the current crate using rustfmt. \\\n+    println!(\n+        \"{}\\nThis utility formats all bin and lib files of the current crate using rustfmt. \\\n               Arguments after `--` are passed to rustfmt.\",\n-             opts.usage(&msg));\n+        opts.usage(&msg)\n+    );\n }\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -102,18 +106,19 @@ pub enum Verbosity {\n     Quiet,\n }\n \n-fn format_crate(verbosity: Verbosity,\n-                workspace_hitlist: WorkspaceHitlist)\n-                -> Result<ExitStatus, std::io::Error> {\n+fn format_crate(\n+    verbosity: Verbosity,\n+    workspace_hitlist: WorkspaceHitlist,\n+) -> Result<ExitStatus, std::io::Error> {\n     let targets = get_targets(workspace_hitlist)?;\n \n     // Currently only bin and lib files get formatted\n     let files: Vec<_> = targets\n         .into_iter()\n         .filter(|t| t.kind.should_format())\n         .inspect(|t| if verbosity == Verbosity::Verbose {\n-                     println!(\"[{:?}] {:?}\", t.kind, t.path)\n-                 })\n+            println!(\"[{:?}] {:?}\", t.kind, t.path)\n+        })\n         .map(|t| t.path)\n         .collect();\n \n@@ -194,8 +199,10 @@ fn get_targets(workspace_hitlist: WorkspaceHitlist) -> Result<Vec<Target>, std::\n \n             return Ok(targets);\n         }\n-        return Err(std::io::Error::new(std::io::ErrorKind::NotFound,\n-                                       str::from_utf8(&output.stderr).unwrap()));\n+        return Err(std::io::Error::new(\n+            std::io::ErrorKind::NotFound,\n+            str::from_utf8(&output.stderr).unwrap(),\n+        ));\n     }\n     // This happens when cargo-fmt is not used inside a crate or\n     // is used inside a workspace.\n@@ -221,18 +228,22 @@ fn get_targets(workspace_hitlist: WorkspaceHitlist) -> Result<Vec<Target>, std::\n             .unwrap()\n             .into_iter()\n             .filter(|member| if workspace_hitlist == WorkspaceHitlist::All {\n-                        true\n-                    } else {\n-                        let member_obj = member.as_object().unwrap();\n-                        let member_name = member_obj.get(\"name\").unwrap().as_str().unwrap();\n-                        hitlist.take(&member_name.to_string()).is_some()\n-                    })\n+                true\n+            } else {\n+                let member_obj = member.as_object().unwrap();\n+                let member_name = member_obj.get(\"name\").unwrap().as_str().unwrap();\n+                hitlist.take(&member_name.to_string()).is_some()\n+            })\n             .collect();\n         if hitlist.len() != 0 {\n             // Mimick cargo of only outputting one <package> spec.\n-            return Err(std::io::Error::new(std::io::ErrorKind::InvalidInput,\n-                                           format!(\"package `{}` is not a member of the workspace\",\n-                                                   hitlist.iter().next().unwrap())));\n+            return Err(std::io::Error::new(\n+                std::io::ErrorKind::InvalidInput,\n+                format!(\n+                    \"package `{}` is not a member of the workspace\",\n+                    hitlist.iter().next().unwrap()\n+                ),\n+            ));\n         }\n         for member in members {\n             let member_obj = member.as_object().unwrap();\n@@ -243,8 +254,10 @@ fn get_targets(workspace_hitlist: WorkspaceHitlist) -> Result<Vec<Target>, std::\n         }\n         return Ok(targets);\n     }\n-    Err(std::io::Error::new(std::io::ErrorKind::NotFound,\n-                            str::from_utf8(&output.stderr).unwrap()))\n+    Err(std::io::Error::new(\n+        std::io::ErrorKind::NotFound,\n+        str::from_utf8(&output.stderr).unwrap(),\n+    ))\n \n }\n \n@@ -268,10 +281,11 @@ fn target_from_json(jtarget: &Value) -> Target {\n     }\n }\n \n-fn format_files(files: &[PathBuf],\n-                fmt_args: &[String],\n-                verbosity: Verbosity)\n-                -> Result<ExitStatus, std::io::Error> {\n+fn format_files(\n+    files: &[PathBuf],\n+    fmt_args: &[String],\n+    verbosity: Verbosity,\n+) -> Result<ExitStatus, std::io::Error> {\n     let stdout = if verbosity == Verbosity::Quiet {\n         std::process::Stdio::null()\n     } else {\n@@ -294,8 +308,10 @@ fn format_files(files: &[PathBuf],\n         .spawn()\n         .map_err(|e| match e.kind() {\n             std::io::ErrorKind::NotFound => {\n-                std::io::Error::new(std::io::ErrorKind::Other,\n-                                    \"Could not run rustfmt, please make sure it is in your PATH.\")\n+                std::io::Error::new(\n+                    std::io::ErrorKind::Other,\n+                    \"Could not run rustfmt, please make sure it is in your PATH.\",\n+                )\n             }\n             _ => e,\n         })?;"}, {"sha": "1929285fdfe6959408561b81daed27d4792bc821", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 75, "deletions": 52, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -74,7 +74,9 @@ impl CliOptions {\n             if let Ok(write_mode) = WriteMode::from_str(write_mode) {\n                 options.write_mode = Some(write_mode);\n             } else {\n-                return Err(FmtError::from(format!(\"Invalid write-mode: {}\", write_mode)));\n+                return Err(FmtError::from(\n+                    format!(\"Invalid write-mode: {}\", write_mode),\n+                ));\n             }\n         }\n \n@@ -96,9 +98,10 @@ impl CliOptions {\n }\n \n /// read the given config file path recursively if present else read the project file path\n-fn match_cli_path_or_file(config_path: Option<PathBuf>,\n-                          input_file: &Path)\n-                          -> FmtResult<(Config, Option<PathBuf>)> {\n+fn match_cli_path_or_file(\n+    config_path: Option<PathBuf>,\n+    input_file: &Path,\n+) -> FmtResult<(Config, Option<PathBuf>)> {\n \n     if let Some(config_file) = config_path {\n         let toml = Config::from_toml_path(config_file.as_ref())?;\n@@ -112,32 +115,44 @@ fn make_opts() -> Options {\n     opts.optflag(\"h\", \"help\", \"show this message\");\n     opts.optflag(\"V\", \"version\", \"show version information\");\n     opts.optflag(\"v\", \"verbose\", \"print verbose output\");\n-    opts.optopt(\"\",\n-                \"write-mode\",\n-                \"mode to write in (not usable when piping from stdin)\",\n-                \"[replace|overwrite|display|diff|coverage|checkstyle]\");\n+    opts.optopt(\n+        \"\",\n+        \"write-mode\",\n+        \"mode to write in (not usable when piping from stdin)\",\n+        \"[replace|overwrite|display|diff|coverage|checkstyle]\",\n+    );\n     opts.optflag(\"\", \"skip-children\", \"don't reformat child modules\");\n \n-    opts.optflag(\"\",\n-                 \"config-help\",\n-                 \"show details of rustfmt configuration options\");\n-    opts.optopt(\"\",\n-                \"dump-default-config\",\n-                \"Dumps the default configuration to a file and exits.\",\n-                \"PATH\");\n-    opts.optopt(\"\",\n-                \"dump-minimal-config\",\n-                \"Dumps configuration options that were checked during formatting to a file.\",\n-                \"PATH\");\n-    opts.optopt(\"\",\n-                \"config-path\",\n-                \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n+    opts.optflag(\n+        \"\",\n+        \"config-help\",\n+        \"show details of rustfmt configuration options\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"dump-default-config\",\n+        \"Dumps the default configuration to a file and exits.\",\n+        \"PATH\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"dump-minimal-config\",\n+        \"Dumps configuration options that were checked during formatting to a file.\",\n+        \"PATH\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"config-path\",\n+        \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n                  found reverts to the input file path\",\n-                \"[Path for the configuration file]\");\n-    opts.optopt(\"\",\n-                \"file-lines\",\n-                \"Format specified line ranges. See README for more detail on the JSON format.\",\n-                \"JSON\");\n+        \"[Path for the configuration file]\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"file-lines\",\n+        \"Format specified line ranges. See README for more detail on the JSON format.\",\n+        \"JSON\",\n+    );\n \n     opts\n }\n@@ -167,8 +182,8 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n         }\n         Operation::Stdin { input, config_path } => {\n             // try to read config from local directory\n-            let (mut config, _) = match_cli_path_or_file(config_path,\n-                                                         &env::current_dir().unwrap())?;\n+            let (mut config, _) =\n+                match_cli_path_or_file(config_path, &env::current_dir().unwrap())?;\n \n             // write_mode is always Plain for Stdin.\n             config.set().write_mode(WriteMode::Plain);\n@@ -225,9 +240,11 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                             Config::from_resolved_toml_path(file.parent().unwrap())?;\n                         if options.verbose {\n                             if let Some(path) = path_tmp.as_ref() {\n-                                println!(\"Using rustfmt config file {} for {}\",\n-                                         path.display(),\n-                                         file.display());\n+                                println!(\n+                                    \"Using rustfmt config file {} for {}\",\n+                                    path.display(),\n+                                    file.display()\n+                                );\n                             }\n                         }\n                         config = config_tmp;\n@@ -288,16 +305,20 @@ fn main() {\n }\n \n fn print_usage(opts: &Options, reason: &str) {\n-    let reason = format!(\"{}\\n\\nusage: {} [options] <file>...\",\n-                         reason,\n-                         env::args_os().next().unwrap().to_string_lossy());\n+    let reason = format!(\n+        \"{}\\n\\nusage: {} [options] <file>...\",\n+        reason,\n+        env::args_os().next().unwrap().to_string_lossy()\n+    );\n     println!(\"{}\", opts.usage(&reason));\n }\n \n fn print_version() {\n-    println!(\"{}-nightly{}\",\n-             env!(\"CARGO_PKG_VERSION\"),\n-             include_str!(concat!(env!(\"OUT_DIR\"), \"/commit-info.txt\")))\n+    println!(\n+        \"{}-nightly{}\",\n+        env!(\"CARGO_PKG_VERSION\"),\n+        include_str!(concat!(env!(\"OUT_DIR\"), \"/commit-info.txt\"))\n+    )\n }\n \n fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n@@ -318,8 +339,10 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n     }\n \n     let config_path_not_found = |path: &str| -> FmtResult<Operation> {\n-        Err(FmtError::from(format!(\"Error: unable to find a config file for the given path: `{}`\",\n-                                   path)))\n+        Err(FmtError::from(format!(\n+            \"Error: unable to find a config file for the given path: `{}`\",\n+            path\n+        )))\n     };\n \n     // Read the config_path and convert to parent dir if a file is provided.\n@@ -346,25 +369,25 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n         io::stdin().read_to_string(&mut buffer)?;\n \n         return Ok(Operation::Stdin {\n-                      input: buffer,\n-                      config_path: config_path,\n-                  });\n+            input: buffer,\n+            config_path: config_path,\n+        });\n     }\n \n     let files: Vec<_> = matches\n         .free\n         .iter()\n         .map(|s| {\n-                 let p = PathBuf::from(s);\n-                 // we will do comparison later, so here tries to canonicalize first\n-                 // to get the expected behavior.\n-                 p.canonicalize().unwrap_or(p)\n-             })\n+            let p = PathBuf::from(s);\n+            // we will do comparison later, so here tries to canonicalize first\n+            // to get the expected behavior.\n+            p.canonicalize().unwrap_or(p)\n+        })\n         .collect();\n \n     Ok(Operation::Format {\n-           files: files,\n-           config_path: config_path,\n-           minimal_config_path: minimal_config_path,\n-       })\n+        files: files,\n+        config_path: config_path,\n+        minimal_config_path: minimal_config_path,\n+    })\n }"}, {"sha": "eba79505e206926660e3f140dcf9d0d3ac91faf4", "filename": "src/chains.rs", "status": "modified", "additions": 161, "deletions": 121, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -101,9 +101,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let trailing_try_num = subexpr_list\n         .iter()\n         .take_while(|e| match e.node {\n-                        ast::ExprKind::Try(..) => true,\n-                        _ => false,\n-                    })\n+            ast::ExprKind::Try(..) => true,\n+            _ => false,\n+        })\n         .count();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n@@ -128,7 +128,10 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         } else {\n             chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n-        (nested_shape, context.config.chain_indent() == IndentStyle::Visual || is_small_parent)\n+        (\n+            nested_shape,\n+            context.config.chain_indent() == IndentStyle::Visual || is_small_parent,\n+        )\n     } else if is_block_expr(context, &parent, &parent_rewrite) {\n         match context.config.chain_indent() {\n             // Try to put the first child on the same line with parent's last line\n@@ -155,26 +158,33 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     } else {\n         other_child_shape\n     };\n-    debug!(\"child_shapes {:?} {:?}\",\n-           first_child_shape,\n-           other_child_shape);\n-\n-    let child_shape_iter =\n-        Some(first_child_shape)\n-            .into_iter()\n-            .chain(::std::iter::repeat(other_child_shape).take(subexpr_list.len() - 1));\n+    debug!(\n+        \"child_shapes {:?} {:?}\",\n+        first_child_shape,\n+        other_child_shape\n+    );\n+\n+    let child_shape_iter = Some(first_child_shape).into_iter().chain(\n+        ::std::iter::repeat(\n+            other_child_shape,\n+        ).take(\n+            subexpr_list.len() - 1,\n+        ),\n+    );\n     let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n-    let mut rewrites = try_opt!(iter.map(|(e, shape)| {\n-                                             rewrite_chain_subexpr(e, total_span, context, shape)\n-                                         }).collect::<Option<Vec<_>>>());\n+    let mut rewrites = try_opt!(\n+        iter.map(|(e, shape)| {\n+            rewrite_chain_subexpr(e, total_span, context, shape)\n+        }).collect::<Option<Vec<_>>>()\n+    );\n \n     // Total of all items excluding the last.\n     let last_non_try_index = rewrites.len() - (1 + trailing_try_num);\n-    let almost_total = rewrites[..last_non_try_index]\n-        .iter()\n-        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n+    let almost_total = rewrites[..last_non_try_index].iter().fold(0, |a, b| {\n+        a + first_line_width(b)\n+    }) + parent_rewrite.len();\n     let one_line_len = rewrites.iter().fold(0, |a, r| a + first_line_width(r)) +\n-                       parent_rewrite.len();\n+        parent_rewrite.len();\n \n     let one_line_budget = min(shape.width, context.config.chain_one_line_max());\n     let veto_single_line = if one_line_len > one_line_budget {\n@@ -206,12 +216,15 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         if fits_single_line {\n             fits_single_line = match expr.node {\n                 ref e @ ast::ExprKind::MethodCall(..) => {\n-                    if rewrite_method_call_with_overflow(e,\n-                                                         &mut last[0],\n-                                                         almost_total,\n-                                                         total_span,\n-                                                         context,\n-                                                         shape) {\n+                    if rewrite_method_call_with_overflow(\n+                        e,\n+                        &mut last[0],\n+                        almost_total,\n+                        total_span,\n+                        context,\n+                        shape,\n+                    )\n+                    {\n                         // If the first line of the last method does not fit into a single line\n                         // after the others, allow new lines.\n                         almost_total + first_line_width(&last[0]) < context.config.max_width()\n@@ -233,13 +246,15 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n                 width: one_line_budget,\n                 ..parent_shape\n             };\n-            fits_single_line = rewrite_last_child_with_overflow(context,\n-                                                                &subexpr_list[trailing_try_num],\n-                                                                overflow_shape,\n-                                                                total_span,\n-                                                                almost_total,\n-                                                                one_line_budget,\n-                                                                &mut last[0]);\n+            fits_single_line = rewrite_last_child_with_overflow(\n+                context,\n+                &subexpr_list[trailing_try_num],\n+                overflow_shape,\n+                total_span,\n+                almost_total,\n+                one_line_budget,\n+                &mut last[0],\n+            );\n         }\n     }\n \n@@ -254,68 +269,83 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = choose_first_connector(context,\n-                                                 &parent_rewrite,\n-                                                 &rewrites[0],\n-                                                 &connector,\n-                                                 &subexpr_list,\n-                                                 extend);\n+    let first_connector = choose_first_connector(\n+        context,\n+        &parent_rewrite,\n+        &rewrites[0],\n+        &connector,\n+        &subexpr_list,\n+        extend,\n+    );\n \n     if is_small_parent && rewrites.len() > 1 {\n-        let second_connector = choose_first_connector(context,\n-                                                      &rewrites[0],\n-                                                      &rewrites[1],\n-                                                      &connector,\n-                                                      &subexpr_list[0..subexpr_list.len() - 1],\n-                                                      false);\n-        wrap_str(format!(\"{}{}{}{}{}\",\n-                         parent_rewrite,\n-                         first_connector,\n-                         rewrites[0],\n-                         second_connector,\n-                         join_rewrites(&rewrites[1..],\n-                                       &subexpr_list[0..subexpr_list.len() - 1],\n-                                       &connector)),\n-                 context.config.max_width(),\n-                 shape)\n+        let second_connector = choose_first_connector(\n+            context,\n+            &rewrites[0],\n+            &rewrites[1],\n+            &connector,\n+            &subexpr_list[0..subexpr_list.len() - 1],\n+            false,\n+        );\n+        wrap_str(\n+            format!(\n+                \"{}{}{}{}{}\",\n+                parent_rewrite,\n+                first_connector,\n+                rewrites[0],\n+                second_connector,\n+                join_rewrites(\n+                    &rewrites[1..],\n+                    &subexpr_list[0..subexpr_list.len() - 1],\n+                    &connector,\n+                )\n+            ),\n+            context.config.max_width(),\n+            shape,\n+        )\n     } else {\n-        wrap_str(format!(\"{}{}{}\",\n-                         parent_rewrite,\n-                         first_connector,\n-                         join_rewrites(&rewrites, &subexpr_list, &connector)),\n-                 context.config.max_width(),\n-                 shape)\n+        wrap_str(\n+            format!(\n+                \"{}{}{}\",\n+                parent_rewrite,\n+                first_connector,\n+                join_rewrites(&rewrites, &subexpr_list, &connector)\n+            ),\n+            context.config.max_width(),\n+            shape,\n+        )\n     }\n }\n \n fn is_extendable_parent(context: &RewriteContext, parent_str: &str) -> bool {\n     context.config.chain_indent() == IndentStyle::Block &&\n-    parent_str.lines().last().map_or(false, |s| {\n-        s.trim()\n-            .chars()\n-            .all(|c| c == ')' || c == ']' || c == '}' || c == '?')\n-    })\n+        parent_str.lines().last().map_or(false, |s| {\n+            s.trim().chars().all(|c| {\n+                c == ')' || c == ']' || c == '}' || c == '?'\n+            })\n+        })\n }\n \n // True if the chain is only `?`s.\n fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n     exprs.iter().all(|e| if let ast::ExprKind::Try(_) = e.node {\n-                         true\n-                     } else {\n-                         false\n-                     })\n+        true\n+    } else {\n+        false\n+    })\n }\n \n // Try to rewrite and replace the last non-try child. Return `true` if\n // replacing succeeds.\n-fn rewrite_last_child_with_overflow(context: &RewriteContext,\n-                                    expr: &ast::Expr,\n-                                    shape: Shape,\n-                                    span: Span,\n-                                    almost_total: usize,\n-                                    one_line_budget: usize,\n-                                    last_child: &mut String)\n-                                    -> bool {\n+fn rewrite_last_child_with_overflow(\n+    context: &RewriteContext,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+    span: Span,\n+    almost_total: usize,\n+    one_line_budget: usize,\n+    last_child: &mut String,\n+) -> bool {\n     if let Some(shape) = shape.shrink_left(almost_total) {\n         if let Some(ref mut rw) = rewrite_chain_subexpr(expr, span, context, shape) {\n             if almost_total + first_line_width(rw) <= one_line_budget {\n@@ -327,15 +357,18 @@ fn rewrite_last_child_with_overflow(context: &RewriteContext,\n     false\n }\n \n-pub fn rewrite_try(expr: &ast::Expr,\n-                   try_count: usize,\n-                   context: &RewriteContext,\n-                   shape: Shape)\n-                   -> Option<String> {\n+pub fn rewrite_try(\n+    expr: &ast::Expr,\n+    try_count: usize,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let sub_expr = try_opt!(expr.rewrite(context, try_opt!(shape.sub_width(try_count))));\n-    Some(format!(\"{}{}\",\n-                 sub_expr,\n-                 iter::repeat(\"?\").take(try_count).collect::<String>()))\n+    Some(format!(\n+        \"{}{}\",\n+        sub_expr,\n+        iter::repeat(\"?\").take(try_count).collect::<String>()\n+    ))\n }\n \n fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) -> String {\n@@ -398,24 +431,27 @@ fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n     }\n }\n \n-fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n-                                     last: &mut String,\n-                                     almost_total: usize,\n-                                     total_span: Span,\n-                                     context: &RewriteContext,\n-                                     shape: Shape)\n-                                     -> bool {\n+fn rewrite_method_call_with_overflow(\n+    expr_kind: &ast::ExprKind,\n+    last: &mut String,\n+    almost_total: usize,\n+    total_span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> bool {\n     if let &ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) = expr_kind {\n         let shape = match shape.shrink_left(almost_total) {\n             Some(b) => b,\n             None => return false,\n         };\n-        let mut last_rewrite = rewrite_method_call(method_name.node,\n-                                                   types,\n-                                                   expressions,\n-                                                   total_span,\n-                                                   context,\n-                                                   shape);\n+        let mut last_rewrite = rewrite_method_call(\n+            method_name.node,\n+            types,\n+            expressions,\n+            total_span,\n+            context,\n+            shape,\n+        );\n \n         if let Some(ref mut s) = last_rewrite {\n             ::std::mem::swap(s, last);\n@@ -457,11 +493,12 @@ fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n \n // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n // `.c`.\n-fn rewrite_chain_subexpr(expr: &ast::Expr,\n-                         span: Span,\n-                         context: &RewriteContext,\n-                         shape: Shape)\n-                         -> Option<String> {\n+fn rewrite_chain_subexpr(\n+    expr: &ast::Expr,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let rewrite_element = |expr_str: String| if expr_str.len() <= shape.width {\n         Some(expr_str)\n     } else {\n@@ -500,20 +537,23 @@ fn is_try(expr: &ast::Expr) -> bool {\n     }\n }\n \n-fn choose_first_connector<'a>(context: &RewriteContext,\n-                              parent_str: &str,\n-                              first_child_str: &str,\n-                              connector: &'a str,\n-                              subexpr_list: &[ast::Expr],\n-                              extend: bool)\n-                              -> &'a str {\n+fn choose_first_connector<'a>(\n+    context: &RewriteContext,\n+    parent_str: &str,\n+    first_child_str: &str,\n+    connector: &'a str,\n+    subexpr_list: &[ast::Expr],\n+    extend: bool,\n+) -> &'a str {\n     if subexpr_list.is_empty() {\n         \"\"\n     } else if extend || subexpr_list.last().map_or(false, is_try) ||\n-              is_extendable_parent(context, parent_str) {\n+               is_extendable_parent(context, parent_str)\n+    {\n         // 1 = \";\", being conservative here.\n         if last_line_width(parent_str) + first_line_width(first_child_str) + 1 <=\n-           context.config.max_width() {\n+            context.config.max_width()\n+        {\n             \"\"\n         } else {\n             connector\n@@ -523,18 +563,18 @@ fn choose_first_connector<'a>(context: &RewriteContext,\n     }\n }\n \n-fn rewrite_method_call(method_name: ast::Ident,\n-                       types: &[ptr::P<ast::Ty>],\n-                       args: &[ptr::P<ast::Expr>],\n-                       span: Span,\n-                       context: &RewriteContext,\n-                       shape: Shape)\n-                       -> Option<String> {\n+fn rewrite_method_call(\n+    method_name: ast::Ident,\n+    types: &[ptr::P<ast::Ty>],\n+    args: &[ptr::P<ast::Expr>],\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let (lo, type_str) = if types.is_empty() {\n         (args[0].span.hi, String::new())\n     } else {\n-        let type_list: Vec<_> =\n-            try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n+        let type_list: Vec<_> = try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n \n         let type_str = if context.config.spaces_within_angle_brackets() && type_list.len() > 0 {\n             format!(\"::< {} >\", type_list.join(\", \"))"}, {"sha": "90ba45610246db48d4742a5783aa6f54043868f6", "filename": "src/checkstyle.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fcheckstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fcheckstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcheckstyle.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -13,7 +13,8 @@ use config::WriteMode;\n \n \n pub fn output_header<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n-    where T: Write\n+where\n+    T: Write,\n {\n     if mode == WriteMode::Checkstyle {\n         let mut xml_heading = String::new();\n@@ -26,7 +27,8 @@ pub fn output_header<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n }\n \n pub fn output_footer<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n-    where T: Write\n+where\n+    T: Write,\n {\n     if mode == WriteMode::Checkstyle {\n         let mut xml_tail = String::new();\n@@ -36,23 +38,27 @@ pub fn output_footer<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n     Ok(())\n }\n \n-pub fn output_checkstyle_file<T>(mut writer: T,\n-                                 filename: &str,\n-                                 diff: Vec<Mismatch>)\n-                                 -> Result<(), io::Error>\n-    where T: Write\n+pub fn output_checkstyle_file<T>(\n+    mut writer: T,\n+    filename: &str,\n+    diff: Vec<Mismatch>,\n+) -> Result<(), io::Error>\n+where\n+    T: Write,\n {\n     write!(writer, \"<file name=\\\"{}\\\">\", filename)?;\n     for mismatch in diff {\n         for line in mismatch.lines {\n             // Do nothing with `DiffLine::Context` and `DiffLine::Resulting`.\n             if let DiffLine::Expected(ref str) = line {\n                 let message = xml_escape_str(str);\n-                write!(writer,\n-                       \"<error line=\\\"{}\\\" severity=\\\"warning\\\" message=\\\"Should be `{}`\\\" \\\n+                write!(\n+                    writer,\n+                    \"<error line=\\\"{}\\\" severity=\\\"warning\\\" message=\\\"Should be `{}`\\\" \\\n                              />\",\n-                       mismatch.line_number,\n-                       message)?;\n+                    mismatch.line_number,\n+                    message\n+                )?;\n             }\n         }\n     }"}, {"sha": "065c39f67c191b3c3c23974dbde900453f54616f", "filename": "src/codemap.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -77,10 +77,12 @@ impl LineRangeUtils for CodeMap {\n         let lo = self.lookup_char_pos(span.lo);\n         let hi = self.lookup_char_pos(span.hi);\n \n-        assert!(lo.file.name == hi.file.name,\n-                \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n-                lo,\n-                hi);\n+        assert!(\n+            lo.file.name == hi.file.name,\n+            \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n+            lo,\n+            hi\n+        );\n \n         LineRange {\n             file: lo.file.clone(),"}, {"sha": "d31ba5f9f2dfe12ea73e0a6c166453bf4ce09fec", "filename": "src/comment.rs", "status": "modified", "additions": 133, "deletions": 92, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -45,9 +45,9 @@ pub enum CommentStyle<'a> {\n \n fn custom_opener(s: &str) -> &str {\n     s.lines().next().map_or(\"\", |first_line| {\n-        first_line\n-            .find(' ')\n-            .map_or(first_line, |space_index| &first_line[0..space_index + 1])\n+        first_line.find(' ').map_or(first_line, |space_index| {\n+            &first_line[0..space_index + 1]\n+        })\n     })\n }\n \n@@ -98,14 +98,14 @@ impl<'a> CommentStyle<'a> {\n             CommentStyle::TripleSlash |\n             CommentStyle::Doc => {\n                 line.trim_left().starts_with(self.line_start().trim_left()) ||\n-                comment_style(line, normalize_comments) == *self\n+                    comment_style(line, normalize_comments) == *self\n             }\n             CommentStyle::DoubleBullet |\n             CommentStyle::SingleBullet |\n             CommentStyle::Exclamation => {\n                 line.trim_left().starts_with(self.closer().trim_left()) ||\n-                line.trim_left().starts_with(self.line_start().trim_left()) ||\n-                comment_style(line, normalize_comments) == *self\n+                    line.trim_left().starts_with(self.line_start().trim_left()) ||\n+                    comment_style(line, normalize_comments) == *self\n             }\n             CommentStyle::Custom(opener) => line.trim_left().starts_with(opener.trim_right()),\n         }\n@@ -130,7 +130,8 @@ fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle {\n             CommentStyle::DoubleSlash\n         }\n     } else if (orig.starts_with(\"///\") && orig.chars().nth(3).map_or(true, |c| c != '/')) ||\n-              (orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\")) {\n+               (orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\"))\n+    {\n         CommentStyle::TripleSlash\n     } else if orig.starts_with(\"//!\") || orig.starts_with(\"/*!\") {\n         CommentStyle::Doc\n@@ -141,17 +142,20 @@ fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle {\n     }\n }\n \n-pub fn rewrite_comment(orig: &str,\n-                       block_style: bool,\n-                       shape: Shape,\n-                       config: &Config)\n-                       -> Option<String> {\n+pub fn rewrite_comment(\n+    orig: &str,\n+    block_style: bool,\n+    shape: Shape,\n+    config: &Config,\n+) -> Option<String> {\n     // If there are lines without a starting sigil, we won't format them correctly\n     // so in that case we won't even re-align (if !config.normalize_comments()) and\n     // we should stop now.\n     let num_bare_lines = orig.lines()\n         .map(|line| line.trim())\n-        .filter(|l| !(l.starts_with('*') || l.starts_with(\"//\") || l.starts_with(\"/*\")))\n+        .filter(|l| {\n+            !(l.starts_with('*') || l.starts_with(\"//\") || l.starts_with(\"/*\"))\n+        })\n         .count();\n     if num_bare_lines > 0 && !config.normalize_comments() {\n         return Some(orig.to_owned());\n@@ -163,11 +167,12 @@ pub fn rewrite_comment(orig: &str,\n     identify_comment(orig, block_style, shape, config)\n }\n \n-fn identify_comment(orig: &str,\n-                    block_style: bool,\n-                    shape: Shape,\n-                    config: &Config)\n-                    -> Option<String> {\n+fn identify_comment(\n+    orig: &str,\n+    block_style: bool,\n+    shape: Shape,\n+    config: &Config,\n+) -> Option<String> {\n     let style = comment_style(orig, false);\n     let first_group = orig.lines()\n         .take_while(|l| style.line_with_same_comment_style(l, false))\n@@ -178,28 +183,34 @@ fn identify_comment(orig: &str,\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let first_group_str =\n-        try_opt!(rewrite_comment_inner(&first_group, block_style, style, shape, config));\n+    let first_group_str = try_opt!(rewrite_comment_inner(\n+        &first_group,\n+        block_style,\n+        style,\n+        shape,\n+        config,\n+    ));\n     if rest.is_empty() {\n         Some(first_group_str)\n     } else {\n         identify_comment(&rest, block_style, shape, config).map(|rest_str| {\n-                                                                    format!(\"{}\\n{}{}\",\n-                                                                            first_group_str,\n-                                                                            shape\n-                                                                                .indent\n-                                                                                .to_string(config),\n-                                                                            rest_str)\n-                                                                })\n-    }\n-}\n-\n-fn rewrite_comment_inner(orig: &str,\n-                         block_style: bool,\n-                         style: CommentStyle,\n-                         shape: Shape,\n-                         config: &Config)\n-                         -> Option<String> {\n+            format!(\n+                \"{}\\n{}{}\",\n+                first_group_str,\n+                shape.indent.to_string(config),\n+                rest_str\n+            )\n+        })\n+    }\n+}\n+\n+fn rewrite_comment_inner(\n+    orig: &str,\n+    block_style: bool,\n+    style: CommentStyle,\n+    shape: Shape,\n+    config: &Config,\n+) -> Option<String> {\n     let (opener, closer, line_start) = if block_style {\n         CommentStyle::SingleBullet.to_str_tuplet()\n     } else {\n@@ -235,10 +246,10 @@ fn rewrite_comment_inner(orig: &str,\n         })\n         .map(|s| left_trim_comment_line(s, &style))\n         .map(|line| if orig.starts_with(\"/*\") && line_breaks == 0 {\n-                 line.trim_left()\n-             } else {\n-                 line\n-             });\n+            line.trim_left()\n+        } else {\n+            line\n+        });\n \n     let mut result = opener.to_owned();\n     for line in lines {\n@@ -299,21 +310,24 @@ fn light_rewrite_comment(orig: &str, offset: Indent, config: &Config) -> Option<\n /// Does not trim all whitespace.\n fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> &'a str {\n     if line.starts_with(\"//! \") || line.starts_with(\"/// \") || line.starts_with(\"/*! \") ||\n-       line.starts_with(\"/** \") {\n+        line.starts_with(\"/** \")\n+    {\n         &line[4..]\n     } else if let &CommentStyle::Custom(opener) = style {\n         if line.starts_with(opener) {\n             &line[opener.len()..]\n         } else {\n             &line[opener.trim_right().len()..]\n         }\n-    } else if line.starts_with(\"/* \") || line.starts_with(\"// \") || line.starts_with(\"//!\") ||\n-              line.starts_with(\"///\") ||\n-              line.starts_with(\"** \") || line.starts_with(\"/*!\") ||\n-              (line.starts_with(\"/**\") && !line.starts_with(\"/**/\")) {\n+    } else if line.starts_with(\"/* \") || line.starts_with(\"// \") ||\n+               line.starts_with(\"//!\") || line.starts_with(\"///\") ||\n+               line.starts_with(\"** \") || line.starts_with(\"/*!\") ||\n+               (line.starts_with(\"/**\") && !line.starts_with(\"/**/\"))\n+    {\n         &line[3..]\n     } else if line.starts_with(\"/*\") || line.starts_with(\"* \") || line.starts_with(\"//\") ||\n-              line.starts_with(\"**\") {\n+               line.starts_with(\"**\")\n+    {\n         &line[2..]\n     } else if line.starts_with('*') {\n         &line[1..]\n@@ -379,8 +393,9 @@ pub fn contains_comment(text: &str) -> bool {\n }\n \n struct CharClasses<T>\n-    where T: Iterator,\n-          T::Item: RichChar\n+where\n+    T: Iterator,\n+    T::Item: RichChar,\n {\n     base: iter::Peekable<T>,\n     status: CharClassesStatus,\n@@ -462,8 +477,9 @@ impl FullCodeCharKind {\n }\n \n impl<T> CharClasses<T>\n-    where T: Iterator,\n-          T::Item: RichChar\n+where\n+    T: Iterator,\n+    T::Item: RichChar,\n {\n     fn new(base: T) -> CharClasses<T> {\n         CharClasses {\n@@ -474,8 +490,9 @@ impl<T> CharClasses<T>\n }\n \n impl<T> Iterator for CharClasses<T>\n-    where T: Iterator,\n-          T::Item: RichChar\n+where\n+    T: Iterator,\n+    T::Item: RichChar,\n {\n     type Item = (FullCodeCharKind, T::Item);\n \n@@ -603,13 +620,15 @@ impl<'a> Iterator for UngroupedCommentCodeSlices<'a> {\n             Some(&(_, (end_idx, _))) => &self.slice[start_idx..end_idx],\n             None => &self.slice[start_idx..],\n         };\n-        Some((if kind.is_comment() {\n-                  CodeCharKind::Comment\n-              } else {\n-                  CodeCharKind::Normal\n-              },\n-              start_idx,\n-              slice))\n+        Some((\n+            if kind.is_comment() {\n+                CodeCharKind::Comment\n+            } else {\n+                CodeCharKind::Normal\n+            },\n+            start_idx,\n+            slice,\n+        ))\n     }\n }\n \n@@ -650,8 +669,8 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n \n         for (kind, (i, c)) in &mut iter {\n             let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal &&\n-                                       &subslice[..2] == \"//\" &&\n-                                       [' ', '\\t'].contains(&c);\n+                &subslice[..2] == \"//\" &&\n+                [' ', '\\t'].contains(&c);\n \n             if is_comment_connector && first_whitespace.is_none() {\n                 first_whitespace = Some(i);\n@@ -683,7 +702,11 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n             CodeCharKind::Comment => CodeCharKind::Normal,\n             CodeCharKind::Normal => CodeCharKind::Comment,\n         };\n-        let res = (kind, self.last_slice_end, &self.slice[self.last_slice_end..sub_slice_end]);\n+        let res = (\n+            kind,\n+            self.last_slice_end,\n+            &self.slice[self.last_slice_end..sub_slice_end],\n+        );\n         self.last_slice_end = sub_slice_end;\n         self.last_slice_kind = kind;\n \n@@ -693,11 +716,12 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n \n /// Checks is `new` didn't miss any comment from `span`, if it removed any, return previous text\n /// (if it fits in the width/offset, else return None), else return `new`\n-pub fn recover_comment_removed(new: String,\n-                               span: Span,\n-                               context: &RewriteContext,\n-                               shape: Shape)\n-                               -> Option<String> {\n+pub fn recover_comment_removed(\n+    new: String,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let snippet = context.snippet(span);\n     if changed_comment_content(&snippet, &new) {\n         // We missed some comments\n@@ -723,12 +747,14 @@ fn changed_comment_content(orig: &str, new: &str) -> bool {\n             .flat_map(|(_, _, s)| CommentReducer::new(s))\n     };\n     let res = code_comment_content(orig).ne(code_comment_content(new));\n-    debug!(\"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\",\n-           res,\n-           orig,\n-           new,\n-           code_comment_content(orig).collect::<String>(),\n-           code_comment_content(new).collect::<String>());\n+    debug!(\n+        \"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\",\n+        res,\n+        orig,\n+        new,\n+        code_comment_content(orig).collect::<String>(),\n+        code_comment_content(new).collect::<String>()\n+    );\n     res\n }\n \n@@ -787,11 +813,14 @@ fn remove_comment_header(comment: &str) -> &str {\n     } else if comment.starts_with(\"//\") {\n         &comment[2..]\n     } else if (comment.starts_with(\"/**\") && !comment.starts_with(\"/**/\")) ||\n-              comment.starts_with(\"/*!\") {\n+               comment.starts_with(\"/*!\")\n+    {\n         &comment[3..comment.len() - 2]\n     } else {\n-        assert!(comment.starts_with(\"/*\"),\n-                format!(\"string '{}' is not a comment\", comment));\n+        assert!(\n+            comment.starts_with(\"/*\"),\n+            format!(\"string '{}' is not a comment\", comment)\n+        );\n         &comment[2..comment.len() - 2]\n     }\n }\n@@ -819,8 +848,10 @@ mod test {\n         let mut iter = CommentCodeSlices::new(input);\n \n         assert_eq!((CodeCharKind::Normal, 0, \"code(); \"), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Comment, 8, \"/* test */\"),\n-                   iter.next().unwrap());\n+        assert_eq!(\n+            (CodeCharKind::Comment, 8, \"/* test */\"),\n+            iter.next().unwrap()\n+        );\n         assert_eq!((CodeCharKind::Normal, 18, \" 1 + 1\"), iter.next().unwrap());\n         assert_eq!(None, iter.next());\n     }\n@@ -831,10 +862,14 @@ mod test {\n         let mut iter = CommentCodeSlices::new(input);\n \n         assert_eq!((CodeCharKind::Normal, 0, \"\"), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Comment, 0, \"// comment\\n\"),\n-                   iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Normal, 11, \"    test();\"),\n-                   iter.next().unwrap());\n+        assert_eq!(\n+            (CodeCharKind::Comment, 0, \"// comment\\n\"),\n+            iter.next().unwrap()\n+        );\n+        assert_eq!(\n+            (CodeCharKind::Normal, 11, \"    test();\"),\n+            iter.next().unwrap()\n+        );\n         assert_eq!(None, iter.next());\n     }\n \n@@ -844,8 +879,10 @@ mod test {\n         let mut iter = CommentCodeSlices::new(input);\n \n         assert_eq!((CodeCharKind::Normal, 0, \"1 \"), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Comment, 2, \"// comment\\n    // comment2\\n\"),\n-                   iter.next().unwrap());\n+        assert_eq!(\n+            (CodeCharKind::Comment, 2, \"// comment\\n    // comment2\\n\"),\n+            iter.next().unwrap()\n+        );\n         assert_eq!((CodeCharKind::Normal, 29, \"\\n\"), iter.next().unwrap());\n         assert_eq!(None, iter.next());\n     }\n@@ -896,17 +933,19 @@ mod test {\n     fn uncommented(text: &str) -> String {\n         CharClasses::new(text.chars())\n             .filter_map(|(s, c)| match s {\n-                            FullCodeCharKind::Normal => Some(c),\n-                            _ => None,\n-                        })\n+                FullCodeCharKind::Normal => Some(c),\n+                _ => None,\n+            })\n             .collect()\n     }\n \n     #[test]\n     fn test_uncommented() {\n         assert_eq!(&uncommented(\"abc/*...*/\"), \"abc\");\n-        assert_eq!(&uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"),\n-                   \"..ac\\n\");\n+        assert_eq!(\n+            &uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"),\n+            \"..ac\\n\"\n+        );\n         assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"), \"abc \\\" /* */\\\" qsdf\");\n     }\n \n@@ -927,9 +966,11 @@ mod test {\n         check(\"/*/ */test\", \"test\", Some(6));\n         check(\"//test\\ntest\", \"test\", Some(7));\n         check(\"/* comment only */\", \"whatever\", None);\n-        check(\"/* comment */ some text /* more commentary */ result\",\n-              \"result\",\n-              Some(46));\n+        check(\n+            \"/* comment */ some text /* more commentary */ result\",\n+            \"result\",\n+            Some(46),\n+        );\n         check(\"sup // sup\", \"p\", Some(2));\n         check(\"sup\", \"x\", None);\n         check(r#\"\u03c0? /**/ \u03c0 is nice!\"#, r#\"\u03c0 is nice\"#, Some(9));"}, {"sha": "931b99bb5da93cc2f7e289c6493b5e088ae1ec36", "filename": "src/config.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -605,7 +605,9 @@ mod test {\n \n         let used_options = config.used_options();\n         let toml = used_options.to_toml().unwrap();\n-        assert_eq!(toml,\n-                   format!(\"verbose = {}\\nskip_children = {}\\n\", verbose, skip_children));\n+        assert_eq!(\n+            toml,\n+            format!(\"verbose = {}\\nskip_children = {}\\n\", verbose, skip_children)\n+        );\n     }\n }"}, {"sha": "24432fb1dff1a1f2fdf5c57944ee2df8e5953b78", "filename": "src/expr.rs", "status": "modified", "additions": 766, "deletions": 574, "changes": 1340, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -47,31 +47,36 @@ enum ExprType {\n     SubExpression,\n }\n \n-fn format_expr(expr: &ast::Expr,\n-               expr_type: ExprType,\n-               context: &RewriteContext,\n-               shape: Shape)\n-               -> Option<String> {\n+fn format_expr(\n+    expr: &ast::Expr,\n+    expr_type: ExprType,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     if contains_skip(&*expr.attrs) {\n         return Some(context.snippet(expr.span));\n     }\n     let attr_rw = (&*expr.attrs).rewrite(context, shape);\n     let expr_rw = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => {\n-            rewrite_array(expr_vec.iter().map(|e| &**e),\n-                          mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n-                          context,\n-                          shape)\n+            rewrite_array(\n+                expr_vec.iter().map(|e| &**e),\n+                mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n+                context,\n+                shape,\n+            )\n         }\n         ast::ExprKind::Lit(ref l) => {\n             match l.node {\n                 ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n                     rewrite_string_lit(context, l.span, shape)\n                 }\n                 _ => {\n-                    wrap_str(context.snippet(expr.span),\n-                             context.config.max_width(),\n-                             shape)\n+                    wrap_str(\n+                        context.snippet(expr.span),\n+                        context.config.max_width(),\n+                        shape,\n+                    )\n                 }\n             }\n         }\n@@ -82,22 +87,26 @@ fn format_expr(expr: &ast::Expr,\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape),\n         ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n             // FIXME: format comments between operands and operator\n-            rewrite_pair(&**lhs,\n-                         &**rhs,\n-                         \"\",\n-                         &format!(\" {} \", context.snippet(op.span)),\n-                         \"\",\n-                         context,\n-                         shape)\n+            rewrite_pair(\n+                &**lhs,\n+                &**rhs,\n+                \"\",\n+                &format!(\" {} \", context.snippet(op.span)),\n+                \"\",\n+                context,\n+                shape,\n+            )\n         }\n         ast::ExprKind::Unary(ref op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n         ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-            rewrite_struct_lit(context,\n-                               path,\n-                               fields,\n-                               base.as_ref().map(|e| &**e),\n-                               expr.span,\n-                               shape)\n+            rewrite_struct_lit(\n+                context,\n+                path,\n+                fields,\n+                base.as_ref().map(|e| &**e),\n+                expr.span,\n+                shape,\n+            )\n         }\n         ast::ExprKind::Tup(ref items) => rewrite_tuple(context, items, expr.span, shape),\n         ast::ExprKind::While(ref cond, ref block, label) => {\n@@ -114,24 +123,26 @@ fn format_expr(expr: &ast::Expr,\n         }\n         ast::ExprKind::Block(ref block) => block.rewrite(context, shape),\n         ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n-            ControlFlow::new_if(cond,\n-                                None,\n-                                if_block,\n-                                else_block.as_ref().map(|e| &**e),\n-                                expr_type == ExprType::SubExpression,\n-                                false,\n-                                expr.span)\n-                .rewrite(context, shape)\n+            ControlFlow::new_if(\n+                cond,\n+                None,\n+                if_block,\n+                else_block.as_ref().map(|e| &**e),\n+                expr_type == ExprType::SubExpression,\n+                false,\n+                expr.span,\n+            ).rewrite(context, shape)\n         }\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n-            ControlFlow::new_if(cond,\n-                                Some(pat),\n-                                if_block,\n-                                else_block.as_ref().map(|e| &**e),\n-                                expr_type == ExprType::SubExpression,\n-                                false,\n-                                expr.span)\n-                .rewrite(context, shape)\n+            ControlFlow::new_if(\n+                cond,\n+                Some(pat),\n+                if_block,\n+                else_block.as_ref().map(|e| &**e),\n+                expr_type == ExprType::SubExpression,\n+                false,\n+                expr.span,\n+            ).rewrite(context, shape)\n         }\n         ast::ExprKind::Match(ref cond, ref arms) => {\n             rewrite_match(context, cond, arms, shape, expr.span)\n@@ -150,9 +161,11 @@ fn format_expr(expr: &ast::Expr,\n                 Some(ident) => format!(\" {}\", ident.node),\n                 None => String::new(),\n             };\n-            wrap_str(format!(\"continue{}\", id_str),\n-                     context.config.max_width(),\n-                     shape)\n+            wrap_str(\n+                format!(\"continue{}\", id_str),\n+                context.config.max_width(),\n+                shape,\n+            )\n         }\n         ast::ExprKind::Break(ref opt_ident, ref opt_expr) => {\n             let id_str = match *opt_ident {\n@@ -163,9 +176,11 @@ fn format_expr(expr: &ast::Expr,\n             if let Some(ref expr) = *opt_expr {\n                 rewrite_unary_prefix(context, &format!(\"break{} \", id_str), &**expr, shape)\n             } else {\n-                wrap_str(format!(\"break{}\", id_str),\n-                         context.config.max_width(),\n-                         shape)\n+                wrap_str(\n+                    format!(\"break{}\", id_str),\n+                    context.config.max_width(),\n+                    shape,\n+                )\n             }\n         }\n         ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n@@ -179,9 +194,11 @@ fn format_expr(expr: &ast::Expr,\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n             rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n-                wrap_str(context.snippet(expr.span),\n-                         context.config.max_width(),\n-                         shape)\n+                wrap_str(\n+                    context.snippet(expr.span),\n+                    context.config.max_width(),\n+                    shape,\n+                )\n             })\n         }\n         ast::ExprKind::Ret(None) => {\n@@ -249,38 +266,45 @@ fn format_expr(expr: &ast::Expr,\n         // satisfy our width restrictions.\n         ast::ExprKind::InPlace(..) |\n         ast::ExprKind::InlineAsm(..) => {\n-            wrap_str(context.snippet(expr.span),\n-                     context.config.max_width(),\n-                     shape)\n+            wrap_str(\n+                context.snippet(expr.span),\n+                context.config.max_width(),\n+                shape,\n+            )\n         }\n         ast::ExprKind::Catch(ref block) => {\n             if let rewrite @ Some(_) = try_one_line_block(context, shape, \"do catch \", block) {\n                 return rewrite;\n             }\n             // 9 = `do catch `\n             let budget = shape.width.checked_sub(9).unwrap_or(0);\n-            Some(format!(\"{}{}\",\n-                         \"do catch \",\n-                         try_opt!(block.rewrite(&context, Shape::legacy(budget, shape.indent)))))\n+            Some(format!(\n+                \"{}{}\",\n+                \"do catch \",\n+                try_opt!(block.rewrite(&context, Shape::legacy(budget, shape.indent)))\n+            ))\n         }\n     };\n     match (attr_rw, expr_rw) {\n         (Some(attr_str), Some(expr_str)) => {\n             let space = if attr_str.is_empty() { \"\" } else { \" \" };\n-            recover_comment_removed(format!(\"{}{}{}\", attr_str, space, expr_str),\n-                                    expr.span,\n-                                    context,\n-                                    shape)\n+            recover_comment_removed(\n+                format!(\"{}{}{}\", attr_str, space, expr_str),\n+                expr.span,\n+                context,\n+                shape,\n+            )\n         }\n         _ => None,\n     }\n }\n \n-fn try_one_line_block(context: &RewriteContext,\n-                      shape: Shape,\n-                      prefix: &str,\n-                      block: &ast::Block)\n-                      -> Option<String> {\n+fn try_one_line_block(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    prefix: &str,\n+    block: &ast::Block,\n+) -> Option<String> {\n     if is_simple_block(block, context.codemap) {\n         let expr_shape = Shape::legacy(shape.width - prefix.len(), shape.indent);\n         let expr_str = try_opt!(block.stmts[0].rewrite(context, expr_shape));\n@@ -292,16 +316,18 @@ fn try_one_line_block(context: &RewriteContext,\n     None\n }\n \n-pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n-                              rhs: &RHS,\n-                              prefix: &str,\n-                              infix: &str,\n-                              suffix: &str,\n-                              context: &RewriteContext,\n-                              shape: Shape)\n-                              -> Option<String>\n-    where LHS: Rewrite,\n-          RHS: Rewrite\n+pub fn rewrite_pair<LHS, RHS>(\n+    lhs: &LHS,\n+    rhs: &RHS,\n+    prefix: &str,\n+    infix: &str,\n+    suffix: &str,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String>\n+where\n+    LHS: Rewrite,\n+    RHS: Rewrite,\n {\n     // Get \"full width\" rhs and see if it fits on the current line. This\n     // usually works fairly well since it tends to place operands of\n@@ -374,21 +400,25 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n         Style::Rfc => try_opt!(shape.sub_width(prefix.len() + infix.len())),\n     };\n     let lhs_result = try_opt!(lhs.rewrite(context, lhs_shape));\n-    Some(format!(\"{}{}{}\\n{}{}{}\",\n-                 prefix,\n-                 lhs_result,\n-                 infix,\n-                 rhs_shape.indent.to_string(context.config),\n-                 rhs_result,\n-                 suffix))\n+    Some(format!(\n+        \"{}{}{}\\n{}{}{}\",\n+        prefix,\n+        lhs_result,\n+        infix,\n+        rhs_shape.indent.to_string(context.config),\n+        rhs_result,\n+        suffix\n+    ))\n }\n \n-pub fn rewrite_array<'a, I>(expr_iter: I,\n-                            span: Span,\n-                            context: &RewriteContext,\n-                            shape: Shape)\n-                            -> Option<String>\n-    where I: Iterator<Item = &'a ast::Expr>\n+pub fn rewrite_array<'a, I>(\n+    expr_iter: I,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String>\n+where\n+    I: Iterator<Item = &'a ast::Expr>,\n {\n     let bracket_size = if context.config.spaces_within_square_brackets() {\n         2 // \"[ \"\n@@ -399,21 +429,22 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     let nested_shape = match context.config.array_layout() {\n         IndentStyle::Block => shape.block().block_indent(context.config.tab_spaces()),\n         IndentStyle::Visual => {\n-            try_opt!(shape\n-                         .visual_indent(bracket_size)\n-                         .sub_width(bracket_size * 2))\n+            try_opt!(shape.visual_indent(bracket_size).sub_width(\n+                bracket_size * 2,\n+            ))\n         }\n     };\n \n-    let items = itemize_list(context.codemap,\n-                             expr_iter,\n-                             \"]\",\n-                             |item| item.span.lo,\n-                             |item| item.span.hi,\n-                             |item| item.rewrite(context, nested_shape),\n-                             span.lo,\n-                             span.hi)\n-        .collect::<Vec<_>>();\n+    let items = itemize_list(\n+        context.codemap,\n+        expr_iter,\n+        \"]\",\n+        |item| item.span.lo,\n+        |item| item.span.hi,\n+        |item| item.rewrite(context, nested_shape),\n+        span.lo,\n+        span.hi,\n+    ).collect::<Vec<_>>();\n \n     if items.is_empty() {\n         if context.config.spaces_within_square_brackets() {\n@@ -423,11 +454,12 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         }\n     }\n \n-    let has_long_item = try_opt!(items\n-                                     .iter()\n-                                     .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n-                                     .fold(Some(false),\n-                                           |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n+    let has_long_item = try_opt!(\n+        items\n+            .iter()\n+            .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n+            .fold(Some(false), |acc, x| acc.and_then(|y| x.map(|x| x || y)))\n+    );\n \n     let tactic = match context.config.array_layout() {\n         IndentStyle::Block => {\n@@ -443,11 +475,11 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         }\n         IndentStyle::Visual => {\n             if has_long_item || items.iter().any(ListItem::is_multiline) {\n-                definitive_tactic(&items,\n-                                  ListTactic::LimitedHorizontalVertical(context\n-                                                                            .config\n-                                                                            .array_width()),\n-                                  nested_shape.width)\n+                definitive_tactic(\n+                    &items,\n+                    ListTactic::LimitedHorizontalVertical(context.config.array_width()),\n+                    nested_shape.width,\n+                )\n             } else {\n                 DefinitiveListTactic::Mixed\n             }\n@@ -465,17 +497,20 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n     let result = if context.config.array_layout() == IndentStyle::Visual ||\n-                    tactic != DefinitiveListTactic::Vertical {\n+        tactic != DefinitiveListTactic::Vertical\n+    {\n         if context.config.spaces_within_square_brackets() && list_str.len() > 0 {\n             format!(\"[ {} ]\", list_str)\n         } else {\n             format!(\"[{}]\", list_str)\n         }\n     } else {\n-        format!(\"[\\n{}{},\\n{}]\",\n-                nested_shape.indent.to_string(context.config),\n-                list_str,\n-                shape.block().indent.to_string(context.config))\n+        format!(\n+            \"[\\n{}{},\\n{}]\",\n+            nested_shape.indent.to_string(context.config),\n+            list_str,\n+            shape.block().indent.to_string(context.config)\n+        )\n     };\n \n     Some(result)\n@@ -490,13 +525,14 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n //   * if the first expression in the body ends with a block (i.e., is a\n //     statement without needing a semi-colon), then adding or removing braces\n //     can change whether it is treated as an expression or statement.\n-fn rewrite_closure(capture: ast::CaptureBy,\n-                   fn_decl: &ast::FnDecl,\n-                   body: &ast::Expr,\n-                   span: Span,\n-                   context: &RewriteContext,\n-                   shape: Shape)\n-                   -> Option<String> {\n+fn rewrite_closure(\n+    capture: ast::CaptureBy,\n+    fn_decl: &ast::FnDecl,\n+    body: &ast::Expr,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let mover = if capture == ast::CaptureBy::Value {\n         \"move \"\n     } else {\n@@ -511,14 +547,16 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     let arg_shape = try_opt!(nested_shape.shrink_left(1)).visual_indent(0);\n     let ret_str = try_opt!(fn_decl.output.rewrite(context, arg_shape));\n \n-    let arg_items = itemize_list(context.codemap,\n-                                 fn_decl.inputs.iter(),\n-                                 \"|\",\n-                                 |arg| span_lo_for_arg(arg),\n-                                 |arg| span_hi_for_arg(arg),\n-                                 |arg| arg.rewrite(context, arg_shape),\n-                                 context.codemap.span_after(span, \"|\"),\n-                                 body.span.lo);\n+    let arg_items = itemize_list(\n+        context.codemap,\n+        fn_decl.inputs.iter(),\n+        \"|\",\n+        |arg| span_lo_for_arg(arg),\n+        |arg| span_hi_for_arg(arg),\n+        |arg| arg.rewrite(context, arg_shape),\n+        context.codemap.span_after(span, \"|\"),\n+        body.span.lo,\n+    );\n     let item_vec = arg_items.collect::<Vec<_>>();\n     // 1 = space between arguments and return type.\n     let horizontal_budget = nested_shape\n@@ -564,9 +602,9 @@ fn rewrite_closure(capture: ast::CaptureBy,\n \n         // Figure out if the block is necessary.\n         let needs_block = block.rules != ast::BlockCheckMode::Default ||\n-                          block.stmts.len() > 1 || context.inside_macro ||\n-                          block_contains_comment(block, context.codemap) ||\n-                          prefix.contains('\\n');\n+            block.stmts.len() > 1 || context.inside_macro ||\n+            block_contains_comment(block, context.codemap) ||\n+            prefix.contains('\\n');\n \n         if ret_str.is_empty() && !needs_block {\n             // lock.stmts.len() == 1\n@@ -600,41 +638,46 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     // The closure originally had a non-block expression, but we can't fit on\n     // one line, so we'll insert a block.\n     let block = ast::Block {\n-        stmts: vec![ast::Stmt {\n-                        id: ast::NodeId::new(0),\n-                        node: ast::StmtKind::Expr(ptr::P(body.clone())),\n-                        span: body.span,\n-                    }],\n+        stmts: vec![\n+            ast::Stmt {\n+                id: ast::NodeId::new(0),\n+                node: ast::StmtKind::Expr(ptr::P(body.clone())),\n+                span: body.span,\n+            },\n+        ],\n         id: ast::NodeId::new(0),\n         rules: ast::BlockCheckMode::Default,\n         span: body.span,\n     };\n     return rewrite_closure_block(&block, prefix, context, body_shape);\n \n-    fn rewrite_closure_expr(expr: &ast::Expr,\n-                            prefix: &str,\n-                            context: &RewriteContext,\n-                            shape: Shape)\n-                            -> Option<String> {\n+    fn rewrite_closure_expr(\n+        expr: &ast::Expr,\n+        prefix: &str,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<String> {\n         let mut rewrite = expr.rewrite(context, shape);\n         if classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(expr)) {\n             rewrite = and_one_line(rewrite);\n         }\n         rewrite.map(|rw| format!(\"{} {}\", prefix, rw))\n     }\n \n-    fn rewrite_closure_block(block: &ast::Block,\n-                             prefix: String,\n-                             context: &RewriteContext,\n-                             shape: Shape)\n-                             -> Option<String> {\n+    fn rewrite_closure_block(\n+        block: &ast::Block,\n+        prefix: String,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<String> {\n         // Start with visual indent, then fall back to block indent if the\n         // closure is large.\n         let block_threshold = context.config.closure_block_indent_threshold();\n         if block_threshold >= 0 {\n             if let Some(block_str) = block.rewrite(&context, shape) {\n                 if block_str.matches('\\n').count() <= block_threshold as usize &&\n-                   !need_block_indent(&block_str, shape) {\n+                    !need_block_indent(&block_str, shape)\n+                {\n                     if let Some(block_str) = block_str.rewrite(context, shape) {\n                         return Some(format!(\"{} {}\", prefix, block_str));\n                     }\n@@ -656,13 +699,14 @@ fn and_one_line(x: Option<String>) -> Option<String> {\n \n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n     debug!(\"nop_block_collapse {:?} {}\", block_str, budget);\n-    block_str.map(|block_str| if block_str.starts_with('{') && budget >= 2 &&\n-                                 (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() ==\n-                                  block_str.len() - 2) {\n-                      \"{}\".to_owned()\n-                  } else {\n-                      block_str.to_owned()\n-                  })\n+    block_str.map(|block_str| if block_str.starts_with('{') &&\n+        budget >= 2 &&\n+        (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2)\n+    {\n+        \"{}\".to_owned()\n+    } else {\n+        block_str.to_owned()\n+    })\n }\n \n impl Rewrite for ast::Block {\n@@ -671,7 +715,8 @@ impl Rewrite for ast::Block {\n         // or an unsafe expression `unsafe { e }`.\n \n         if self.stmts.is_empty() && !block_contains_comment(self, context.codemap) &&\n-           shape.width >= 2 {\n+            shape.width >= 2\n+        {\n             return Some(\"{}\".to_owned());\n         }\n \n@@ -681,8 +726,9 @@ impl Rewrite for ast::Block {\n         if user_str.starts_with('{') && user_str.ends_with('}') {\n             let comment_str = user_str[1..user_str.len() - 1].trim();\n             if self.stmts.is_empty() && !comment_str.contains('\\n') &&\n-               !comment_str.starts_with(\"//\") &&\n-               comment_str.len() + 4 <= shape.width {\n+                !comment_str.starts_with(\"//\") &&\n+                comment_str.len() + 4 <= shape.width\n+            {\n                 return Some(format!(\"{{ {} }}\", comment_str));\n             }\n         }\n@@ -703,11 +749,15 @@ impl Rewrite for ast::Block {\n                 let prefix = if !trimmed.is_empty() {\n                     // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n                     let budget = try_opt!(shape.width.checked_sub(9));\n-                    format!(\"unsafe {} \",\n-                            try_opt!(rewrite_comment(trimmed,\n-                                                     true,\n-                                                     Shape::legacy(budget, shape.indent + 7),\n-                                                     context.config)))\n+                    format!(\n+                        \"unsafe {} \",\n+                        try_opt!(rewrite_comment(\n+                            trimmed,\n+                            true,\n+                            Shape::legacy(budget, shape.indent + 7),\n+                            context.config,\n+                        ))\n+                    )\n                 } else {\n                     \"unsafe \".to_owned()\n                 };\n@@ -724,8 +774,10 @@ impl Rewrite for ast::Block {\n \n         visitor.visit_block(self);\n         if visitor.failed && shape.indent.alignment != 0 {\n-            self.rewrite(context,\n-                         Shape::indented(shape.indent.block_only(), context.config))\n+            self.rewrite(\n+                context,\n+                Shape::indented(shape.indent.block_only(), context.config),\n+            )\n         } else {\n             Some(format!(\"{}{}\", prefix, visitor.buffer))\n         }\n@@ -740,20 +792,23 @@ impl Rewrite for ast::Stmt {\n             ast::StmtKind::Semi(ref ex) => {\n                 let suffix = if semicolon_for_stmt(self) { \";\" } else { \"\" };\n \n-                format_expr(ex,\n-                            match self.node {\n-                                ast::StmtKind::Expr(_) => ExprType::SubExpression,\n-                                ast::StmtKind::Semi(_) => ExprType::Statement,\n-                                _ => unreachable!(),\n-                            },\n-                            context,\n-                            try_opt!(shape.sub_width(suffix.len())))\n-                    .map(|s| s + suffix)\n+                format_expr(\n+                    ex,\n+                    match self.node {\n+                        ast::StmtKind::Expr(_) => ExprType::SubExpression,\n+                        ast::StmtKind::Semi(_) => ExprType::Statement,\n+                        _ => unreachable!(),\n+                    },\n+                    context,\n+                    try_opt!(shape.sub_width(suffix.len())),\n+                ).map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) |\n             ast::StmtKind::Item(..) => None,\n         };\n-        result.and_then(|res| recover_comment_removed(res, self.span, context, shape))\n+        result.and_then(|res| {\n+            recover_comment_removed(res, self.span, context, shape)\n+        })\n     }\n }\n \n@@ -775,14 +830,15 @@ struct ControlFlow<'a> {\n }\n \n impl<'a> ControlFlow<'a> {\n-    fn new_if(cond: &'a ast::Expr,\n-              pat: Option<&'a ast::Pat>,\n-              block: &'a ast::Block,\n-              else_block: Option<&'a ast::Expr>,\n-              allow_single_line: bool,\n-              nested_if: bool,\n-              span: Span)\n-              -> ControlFlow<'a> {\n+    fn new_if(\n+        cond: &'a ast::Expr,\n+        pat: Option<&'a ast::Pat>,\n+        block: &'a ast::Block,\n+        else_block: Option<&'a ast::Expr>,\n+        allow_single_line: bool,\n+        nested_if: bool,\n+        span: Span,\n+    ) -> ControlFlow<'a> {\n         ControlFlow {\n             cond: Some(cond),\n             block: block,\n@@ -801,10 +857,11 @@ impl<'a> ControlFlow<'a> {\n         }\n     }\n \n-    fn new_loop(block: &'a ast::Block,\n-                label: Option<ast::SpannedIdent>,\n-                span: Span)\n-                -> ControlFlow<'a> {\n+    fn new_loop(\n+        block: &'a ast::Block,\n+        label: Option<ast::SpannedIdent>,\n+        span: Span,\n+    ) -> ControlFlow<'a> {\n         ControlFlow {\n             cond: None,\n             block: block,\n@@ -820,12 +877,13 @@ impl<'a> ControlFlow<'a> {\n         }\n     }\n \n-    fn new_while(pat: Option<&'a ast::Pat>,\n-                 cond: &'a ast::Expr,\n-                 block: &'a ast::Block,\n-                 label: Option<ast::SpannedIdent>,\n-                 span: Span)\n-                 -> ControlFlow<'a> {\n+    fn new_while(\n+        pat: Option<&'a ast::Pat>,\n+        cond: &'a ast::Expr,\n+        block: &'a ast::Block,\n+        label: Option<ast::SpannedIdent>,\n+        span: Span,\n+    ) -> ControlFlow<'a> {\n         ControlFlow {\n             cond: Some(cond),\n             block: block,\n@@ -844,12 +902,13 @@ impl<'a> ControlFlow<'a> {\n         }\n     }\n \n-    fn new_for(pat: &'a ast::Pat,\n-               cond: &'a ast::Expr,\n-               block: &'a ast::Block,\n-               label: Option<ast::SpannedIdent>,\n-               span: Span)\n-               -> ControlFlow<'a> {\n+    fn new_for(\n+        pat: &'a ast::Pat,\n+        cond: &'a ast::Expr,\n+        block: &'a ast::Block,\n+        label: Option<ast::SpannedIdent>,\n+        span: Span,\n+    ) -> ControlFlow<'a> {\n         ControlFlow {\n             cond: Some(cond),\n             block: block,\n@@ -865,40 +924,49 @@ impl<'a> ControlFlow<'a> {\n         }\n     }\n \n-    fn rewrite_single_line(&self,\n-                           pat_expr_str: &str,\n-                           context: &RewriteContext,\n-                           width: usize)\n-                           -> Option<String> {\n+    fn rewrite_single_line(\n+        &self,\n+        pat_expr_str: &str,\n+        context: &RewriteContext,\n+        width: usize,\n+    ) -> Option<String> {\n         assert!(self.allow_single_line);\n         let else_block = try_opt!(self.else_block);\n         let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n \n         if let ast::ExprKind::Block(ref else_node) = else_block.node {\n             if !is_simple_block(self.block, context.codemap) ||\n-               !is_simple_block(else_node, context.codemap) ||\n-               pat_expr_str.contains('\\n') {\n+                !is_simple_block(else_node, context.codemap) ||\n+                pat_expr_str.contains('\\n')\n+            {\n                 return None;\n             }\n \n             let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n             let expr = &self.block.stmts[0];\n-            let if_str = try_opt!(expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n+            let if_str = try_opt!(expr.rewrite(\n+                context,\n+                Shape::legacy(new_width, Indent::empty()),\n+            ));\n \n             let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n             let else_expr = &else_node.stmts[0];\n-            let else_str =\n-                try_opt!(else_expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n+            let else_str = try_opt!(else_expr.rewrite(\n+                context,\n+                Shape::legacy(new_width, Indent::empty()),\n+            ));\n \n             if if_str.contains('\\n') || else_str.contains('\\n') {\n                 return None;\n             }\n \n-            let result = format!(\"{} {} {{ {} }} else {{ {} }}\",\n-                                 self.keyword,\n-                                 pat_expr_str,\n-                                 if_str,\n-                                 else_str);\n+            let result = format!(\n+                \"{} {} {{ {} }} else {{ {} }}\",\n+                self.keyword,\n+                pat_expr_str,\n+                if_str,\n+                else_str\n+            );\n \n             if result.len() <= width {\n                 return Some(result);\n@@ -935,26 +1003,29 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                     cond_shape = try_opt!(cond_shape.sub_width(2));\n                 }\n \n-                try_opt!(rewrite_pat_expr(context,\n-                                          self.pat,\n-                                          cond,\n-                                          self.matcher,\n-                                          self.connector,\n-                                          self.keyword,\n-                                          cond_shape))\n+                try_opt!(rewrite_pat_expr(\n+                    context,\n+                    self.pat,\n+                    cond,\n+                    self.matcher,\n+                    self.connector,\n+                    self.keyword,\n+                    cond_shape,\n+                ))\n             }\n             None => String::new(),\n         };\n \n         let force_newline_brace = context.config.control_style() == Style::Rfc &&\n-                                  pat_expr_string.contains('\\n');\n+            pat_expr_string.contains('\\n');\n \n         // Try to format if-else on single line.\n         if self.allow_single_line && context.config.single_line_if_else_max_width() > 0 {\n             let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n \n             if trial.is_some() &&\n-               trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width() {\n+                trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width()\n+            {\n                 return trial;\n             }\n         }\n@@ -1009,17 +1080,19 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             extract_comment(mk_sp(cond_span.hi, self.block.span.lo), context, shape);\n \n         let alt_block_sep = String::from(\"\\n\") +\n-                            &shape.indent.block_only().to_string(context.config);\n+            &shape.indent.block_only().to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n         } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine ||\n-                  force_newline_brace {\n+                   force_newline_brace\n+        {\n             alt_block_sep.as_str()\n         } else {\n             \" \"\n         };\n \n-        let mut result = format!(\"{}{}{}{}{}{}\",\n+        let mut result =\n+            format!(\"{}{}{}{}{}{}\",\n                                  label_string,\n                                  self.keyword,\n                                  between_kwd_cond_comment\n@@ -1044,24 +1117,26 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 // Note how we're passing the original shape, as the\n                 // cost of \"else\" should not cascade.\n                 ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n-                    ControlFlow::new_if(cond,\n-                                        Some(pat),\n-                                        if_block,\n-                                        next_else_block.as_ref().map(|e| &**e),\n-                                        false,\n-                                        true,\n-                                        mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, shape)\n+                    ControlFlow::new_if(\n+                        cond,\n+                        Some(pat),\n+                        if_block,\n+                        next_else_block.as_ref().map(|e| &**e),\n+                        false,\n+                        true,\n+                        mk_sp(else_block.span.lo, self.span.hi),\n+                    ).rewrite(context, shape)\n                 }\n                 ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n-                    ControlFlow::new_if(cond,\n-                                        None,\n-                                        if_block,\n-                                        next_else_block.as_ref().map(|e| &**e),\n-                                        false,\n-                                        true,\n-                                        mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, shape)\n+                    ControlFlow::new_if(\n+                        cond,\n+                        None,\n+                        if_block,\n+                        next_else_block.as_ref().map(|e| &**e),\n+                        false,\n+                        true,\n+                        mk_sp(else_block.span.lo, self.span.hi),\n+                    ).rewrite(context, shape)\n                 }\n                 _ => {\n                     last_in_chain = true;\n@@ -1076,18 +1151,23 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             };\n \n             let between_kwd_else_block =\n-                mk_sp(self.block.span.hi,\n-                      context\n-                          .codemap\n-                          .span_before(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"));\n+                mk_sp(\n+                    self.block.span.hi,\n+                    context.codemap.span_before(\n+                        mk_sp(self.block.span.hi, else_block.span.lo),\n+                        \"else\",\n+                    ),\n+                );\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n-            let after_else = mk_sp(context\n-                                       .codemap\n-                                       .span_after(mk_sp(self.block.span.hi, else_block.span.lo),\n-                                                   \"else\"),\n-                                   else_block.span.lo);\n+            let after_else = mk_sp(\n+                context.codemap.span_after(\n+                    mk_sp(self.block.span.hi, else_block.span.lo),\n+                    \"else\",\n+                ),\n+                else_block.span.lo,\n+            );\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n             let between_sep = match context.config.control_brace_style() {\n@@ -1099,13 +1179,17 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 ControlBraceStyle::AlwaysNextLine if last_in_chain => &*alt_block_sep,\n                 _ => \" \",\n             };\n-            try_opt!(write!(&mut result,\n-                            \"{}else{}\",\n-                            between_kwd_else_block_comment\n-                                .as_ref()\n-                                .map_or(between_sep, |s| &**s),\n-                            after_else_comment.as_ref().map_or(after_sep, |s| &**s))\n-                         .ok());\n+            try_opt!(\n+                write!(\n+                    &mut result,\n+                    \"{}else{}\",\n+                    between_kwd_else_block_comment.as_ref().map_or(\n+                        between_sep,\n+                        |s| &**s,\n+                    ),\n+                    after_else_comment.as_ref().map_or(after_sep, |s| &**s)\n+                ).ok()\n+            );\n             result.push_str(&try_opt!(rewrite));\n         }\n \n@@ -1123,10 +1207,17 @@ fn rewrite_label(label: Option<ast::SpannedIdent>) -> String {\n fn extract_comment(span: Span, context: &RewriteContext, shape: Shape) -> Option<String> {\n     let comment_str = context.snippet(span);\n     if contains_comment(&comment_str) {\n-        let comment = try_opt!(rewrite_comment(comment_str.trim(), false, shape, context.config));\n-        Some(format!(\"\\n{indent}{}\\n{indent}\",\n-                     comment,\n-                     indent = shape.indent.to_string(context.config)))\n+        let comment = try_opt!(rewrite_comment(\n+            comment_str.trim(),\n+            false,\n+            shape,\n+            context.config,\n+        ));\n+        Some(format!(\n+            \"\\n{indent}{}\\n{indent}\",\n+            comment,\n+            indent = shape.indent.to_string(context.config)\n+        ))\n     } else {\n         None\n     }\n@@ -1142,7 +1233,7 @@ fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n // the expression.\n pub fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n     (block.stmts.len() == 1 && stmt_is_expr(&block.stmts[0]) &&\n-     !block_contains_comment(block, codemap))\n+         !block_contains_comment(block, codemap))\n }\n \n /// Checks whether a block contains at most one statement or expression, and no comments.\n@@ -1173,11 +1264,12 @@ fn is_unsafe_block(block: &ast::Block) -> bool {\n // inter-match-arm-comment-rules:\n //  - all comments following a match arm before the start of the next arm\n //    are about the second arm\n-fn rewrite_match_arm_comment(context: &RewriteContext,\n-                             missed_str: &str,\n-                             shape: Shape,\n-                             arm_indent_str: &str)\n-                             -> Option<String> {\n+fn rewrite_match_arm_comment(\n+    context: &RewriteContext,\n+    missed_str: &str,\n+    shape: Shape,\n+    arm_indent_str: &str,\n+) -> Option<String> {\n     // The leading \",\" is not part of the arm-comment\n     let missed_str = match missed_str.find_uncommented(\",\") {\n         Some(n) => &missed_str[n + 1..],\n@@ -1190,9 +1282,10 @@ fn rewrite_match_arm_comment(context: &RewriteContext,\n     result.push_str(&missed_str[..first_brk]);\n     let missed_str = &missed_str[first_brk..]; // If missed_str had one newline, it starts with it\n \n-    let first = missed_str\n-        .find(|c: char| !c.is_whitespace())\n-        .unwrap_or(missed_str.len());\n+    let first = missed_str.find(|c: char| !c.is_whitespace()).unwrap_or(\n+        missed_str\n+            .len(),\n+    );\n     if missed_str[..first].chars().filter(|c| c == &'\\n').count() >= 2 {\n         // Excessive vertical whitespace before comment should be preserved\n         // FIXME handle vertical whitespace better\n@@ -1209,12 +1302,13 @@ fn rewrite_match_arm_comment(context: &RewriteContext,\n     Some(result)\n }\n \n-fn rewrite_match(context: &RewriteContext,\n-                 cond: &ast::Expr,\n-                 arms: &[ast::Arm],\n-                 shape: Shape,\n-                 span: Span)\n-                 -> Option<String> {\n+fn rewrite_match(\n+    context: &RewriteContext,\n+    cond: &ast::Expr,\n+    arms: &[ast::Arm],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String> {\n     if arms.is_empty() {\n         return None;\n     }\n@@ -1240,9 +1334,10 @@ fn rewrite_match(context: &RewriteContext,\n \n     let arm_indent_str = arm_shape.indent.to_string(context.config);\n \n-    let open_brace_pos = context\n-        .codemap\n-        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n+    let open_brace_pos = context.codemap.span_after(\n+        mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n+        \"{\",\n+    );\n \n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n@@ -1251,8 +1346,12 @@ fn rewrite_match(context: &RewriteContext,\n         } else {\n             context.snippet(mk_sp(arm_end_pos(&arms[i - 1]), arm_start_pos(arm)))\n         };\n-        let comment =\n-            try_opt!(rewrite_match_arm_comment(context, &missed_str, arm_shape, &arm_indent_str));\n+        let comment = try_opt!(rewrite_match_arm_comment(\n+            context,\n+            &missed_str,\n+            arm_shape,\n+            &arm_indent_str,\n+        ));\n         result.push_str(&comment);\n         result.push('\\n');\n         result.push_str(&arm_indent_str);\n@@ -1270,8 +1369,12 @@ fn rewrite_match(context: &RewriteContext,\n     // BytePos(1) = closing match brace.\n     let last_span = mk_sp(arm_end_pos(&arms[arms.len() - 1]), span.hi - BytePos(1));\n     let last_comment = context.snippet(last_span);\n-    let comment =\n-        try_opt!(rewrite_match_arm_comment(context, &last_comment, arm_shape, &arm_indent_str));\n+    let comment = try_opt!(rewrite_match_arm_comment(\n+        context,\n+        &last_comment,\n+        arm_shape,\n+        &arm_indent_str,\n+    ));\n     result.push_str(&comment);\n     result.push('\\n');\n     result.push_str(&shape.indent.to_string(context.config));\n@@ -1336,9 +1439,11 @@ impl Rewrite for ast::Arm {\n         // 5 = ` => {`\n         let pat_shape = try_opt!(shape.sub_width(5));\n \n-        let pat_strs = try_opt!(pats.iter()\n-                                    .map(|p| p.rewrite(context, pat_shape))\n-                                    .collect::<Option<Vec<_>>>());\n+        let pat_strs = try_opt!(\n+            pats.iter()\n+                .map(|p| p.rewrite(context, pat_shape))\n+                .collect::<Option<Vec<_>>>()\n+        );\n \n         let all_simple = pat_strs.iter().all(|p| pat_is_simple(p));\n         let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n@@ -1362,17 +1467,19 @@ impl Rewrite for ast::Arm {\n             shape\n         };\n \n-        let guard_str = try_opt!(rewrite_guard(context,\n-                                               guard,\n-                                               guard_shape,\n-                                               trimmed_last_line_width(&pats_str)));\n+        let guard_str = try_opt!(rewrite_guard(\n+            context,\n+            guard,\n+            guard_shape,\n+            trimmed_last_line_width(&pats_str),\n+        ));\n \n         let pats_str = format!(\"{}{}\", pats_str, guard_str);\n \n         let (mut extend, body) = match body.node {\n             ast::ExprKind::Block(ref block) if !is_unsafe_block(block) &&\n-                                               is_simple_block(block, context.codemap) &&\n-                                               context.config.wrap_match_arms() => {\n+                                                   is_simple_block(block, context.codemap) &&\n+                                                   context.config.wrap_match_arms() => {\n                 if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                     (false, &**expr)\n                 } else {\n@@ -1389,7 +1496,7 @@ impl Rewrite for ast::Arm {\n \n         let comma = arm_comma(&context.config, body);\n         let alt_block_sep = String::from(\"\\n\") +\n-                            &shape.indent.block_only().to_string(context.config);\n+            &shape.indent.block_only().to_string(context.config);\n \n         let pat_width = extra_offset(&pats_str, shape);\n         // Let's try and get the arm body on the same line as the condition.\n@@ -1409,21 +1516,23 @@ impl Rewrite for ast::Arm {\n \n             match rewrite {\n                 Some(ref body_str) if (!body_str.contains('\\n') &&\n-                                       body_str.len() <= arm_shape.width) ||\n-                                      !context.config.wrap_match_arms() ||\n-                                      (extend && first_line_width(body_str) <= arm_shape.width) ||\n-                                      is_block => {\n+                                           body_str.len() <= arm_shape.width) ||\n+                                          !context.config.wrap_match_arms() ||\n+                                          (extend && first_line_width(body_str) <= arm_shape.width) ||\n+                                          is_block => {\n                     let block_sep = match context.config.control_brace_style() {\n                         ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n                         _ => \" \",\n                     };\n \n-                    return Some(format!(\"{}{} =>{}{}{}\",\n-                                        attr_str.trim_left(),\n-                                        pats_str,\n-                                        block_sep,\n-                                        body_str,\n-                                        comma));\n+                    return Some(format!(\n+                        \"{}{} =>{}{}{}\",\n+                        attr_str.trim_left(),\n+                        pats_str,\n+                        block_sep,\n+                        body_str,\n+                        comma\n+                    ));\n                 }\n                 _ => {}\n             }\n@@ -1433,12 +1542,13 @@ impl Rewrite for ast::Arm {\n         // necessary.\n         let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces()))\n             .block_indent(context.config.tab_spaces());\n-        let next_line_body = try_opt!(nop_block_collapse(body.rewrite(context, body_shape),\n-                                                         body_shape.width));\n-        let indent_str = shape\n-            .indent\n-            .block_indent(context.config)\n-            .to_string(context.config);\n+        let next_line_body = try_opt!(nop_block_collapse(\n+            body.rewrite(context, body_shape),\n+            body_shape.width,\n+        ));\n+        let indent_str = shape.indent.block_indent(context.config).to_string(\n+            context.config,\n+        );\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms() {\n             if context.config.match_block_trailing_comma() {\n                 (\"{\", \"},\")\n@@ -1457,22 +1567,26 @@ impl Rewrite for ast::Arm {\n         };\n \n         if context.config.wrap_match_arms() {\n-            Some(format!(\"{}{} =>{}{}{}\\n{}{}\",\n-                         attr_str.trim_left(),\n-                         pats_str,\n-                         block_sep,\n-                         indent_str,\n-                         next_line_body,\n-                         shape.indent.to_string(context.config),\n-                         body_suffix))\n+            Some(format!(\n+                \"{}{} =>{}{}{}\\n{}{}\",\n+                attr_str.trim_left(),\n+                pats_str,\n+                block_sep,\n+                indent_str,\n+                next_line_body,\n+                shape.indent.to_string(context.config),\n+                body_suffix\n+            ))\n         } else {\n-            Some(format!(\"{}{} =>{}{}{}{}\",\n-                         attr_str.trim_left(),\n-                         pats_str,\n-                         block_sep,\n-                         indent_str,\n-                         next_line_body,\n-                         body_suffix))\n+            Some(format!(\n+                \"{}{} =>{}{}{}{}\",\n+                attr_str.trim_left(),\n+                pats_str,\n+                block_sep,\n+                indent_str,\n+                next_line_body,\n+                body_suffix\n+            ))\n         }\n     }\n }\n@@ -1481,17 +1595,18 @@ impl Rewrite for ast::Arm {\n // E.g. `Foo::Bar` is simple, but `Foo(..)` is not.\n fn pat_is_simple(pat_str: &str) -> bool {\n     pat_str.len() <= 16 ||\n-    (pat_str.len() <= 24 && pat_str.chars().all(|c| c.is_alphabetic() || c == ':'))\n+        (pat_str.len() <= 24 && pat_str.chars().all(|c| c.is_alphabetic() || c == ':'))\n }\n \n // The `if ...` guard on a match arm.\n-fn rewrite_guard(context: &RewriteContext,\n-                 guard: &Option<ptr::P<ast::Expr>>,\n-                 shape: Shape,\n-                 // The amount of space used up on this line for the pattern in\n-                 // the arm (excludes offset).\n-                 pattern_width: usize)\n-                 -> Option<String> {\n+fn rewrite_guard(\n+    context: &RewriteContext,\n+    guard: &Option<ptr::P<ast::Expr>>,\n+    shape: Shape,\n+    // The amount of space used up on this line for the pattern in\n+    // the arm (excludes offset).\n+    pattern_width: usize,\n+) -> Option<String> {\n     if let Some(ref guard) = *guard {\n         // First try to fit the guard string on the same line as the pattern.\n         // 4 = ` if `, 5 = ` => {`\n@@ -1526,16 +1641,17 @@ fn rewrite_guard(context: &RewriteContext,\n     }\n }\n \n-fn rewrite_pat_expr(context: &RewriteContext,\n-                    pat: Option<&ast::Pat>,\n-                    expr: &ast::Expr,\n-                    matcher: &str,\n-                    // Connecting piece between pattern and expression,\n-                    // *without* trailing space.\n-                    connector: &str,\n-                    keyword: &str,\n-                    shape: Shape)\n-                    -> Option<String> {\n+fn rewrite_pat_expr(\n+    context: &RewriteContext,\n+    pat: Option<&ast::Pat>,\n+    expr: &ast::Expr,\n+    matcher: &str,\n+    // Connecting piece between pattern and expression,\n+    // *without* trailing space.\n+    connector: &str,\n+    keyword: &str,\n+    shape: Shape,\n+) -> Option<String> {\n     debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, pat, expr);\n     let mut pat_string = String::new();\n     let mut result = match pat {\n@@ -1545,8 +1661,9 @@ fn rewrite_pat_expr(context: &RewriteContext,\n             } else {\n                 format!(\"{} \", matcher)\n             };\n-            let pat_shape = try_opt!(try_opt!(shape.shrink_left(matcher.len()))\n-                                         .sub_width(connector.len()));\n+            let pat_shape = try_opt!(try_opt!(shape.shrink_left(matcher.len())).sub_width(\n+                connector.len(),\n+            ));\n             pat_string = try_opt!(pat.rewrite(context, pat_shape));\n             format!(\"{}{}{}\", matcher, pat_string, connector)\n         }\n@@ -1596,7 +1713,8 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     }\n \n     if !context.config.force_format_strings() &&\n-       !string_requires_rewrite(context, span, &string_lit, shape) {\n+        !string_requires_rewrite(context, span, &string_lit, shape)\n+    {\n         return Some(string_lit);\n     }\n \n@@ -1616,11 +1734,12 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     rewrite_string(str_lit, &fmt)\n }\n \n-fn string_requires_rewrite(context: &RewriteContext,\n-                           span: Span,\n-                           string: &str,\n-                           shape: Shape)\n-                           -> bool {\n+fn string_requires_rewrite(\n+    context: &RewriteContext,\n+    span: Span,\n+    string: &str,\n+    shape: Shape,\n+) -> bool {\n     if context.codemap.lookup_char_pos(span.lo).col.0 != shape.indent.width() {\n         return true;\n     }\n@@ -1640,13 +1759,15 @@ fn string_requires_rewrite(context: &RewriteContext,\n     false\n }\n \n-pub fn rewrite_call_with_binary_search<R>(context: &RewriteContext,\n-                                          callee: &R,\n-                                          args: &[ptr::P<ast::Expr>],\n-                                          span: Span,\n-                                          shape: Shape)\n-                                          -> Option<String>\n-    where R: Rewrite\n+pub fn rewrite_call_with_binary_search<R>(\n+    context: &RewriteContext,\n+    callee: &R,\n+    args: &[ptr::P<ast::Expr>],\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String>\n+where\n+    R: Rewrite,\n {\n     let closure = |callee_max_width| {\n         // FIXME using byte lens instead of char lens (and probably all over the\n@@ -1655,32 +1776,34 @@ pub fn rewrite_call_with_binary_search<R>(context: &RewriteContext,\n             width: callee_max_width,\n             ..shape\n         };\n-        let callee_str = callee\n-            .rewrite(context, callee_shape)\n-            .ok_or(Ordering::Greater)?;\n+        let callee_str = callee.rewrite(context, callee_shape).ok_or(\n+            Ordering::Greater,\n+        )?;\n \n         rewrite_call_inner(context, &callee_str, args, span, shape, false)\n     };\n \n     binary_search(1, shape.width, closure)\n }\n \n-pub fn rewrite_call(context: &RewriteContext,\n-                    callee: &str,\n-                    args: &[ptr::P<ast::Expr>],\n-                    span: Span,\n-                    shape: Shape)\n-                    -> Option<String> {\n+pub fn rewrite_call(\n+    context: &RewriteContext,\n+    callee: &str,\n+    args: &[ptr::P<ast::Expr>],\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String> {\n     rewrite_call_inner(context, &callee, args, span, shape, false).ok()\n }\n \n-fn rewrite_call_inner(context: &RewriteContext,\n-                      callee_str: &str,\n-                      args: &[ptr::P<ast::Expr>],\n-                      span: Span,\n-                      shape: Shape,\n-                      force_trailing_comma: bool)\n-                      -> Result<String, Ordering> {\n+fn rewrite_call_inner(\n+    context: &RewriteContext,\n+    callee_str: &str,\n+    args: &[ptr::P<ast::Expr>],\n+    span: Span,\n+    shape: Shape,\n+    force_trailing_comma: bool,\n+) -> Result<String, Ordering> {\n     // 2 = `( `, 1 = `(`\n     let paren_overhead = if context.config.spaces_within_parens() {\n         2\n@@ -1693,11 +1816,12 @@ fn rewrite_call_inner(context: &RewriteContext,\n         .checked_sub(used_width + 2 * paren_overhead)\n         .ok_or(Ordering::Greater)?;\n \n-    let nested_shape = shape_from_fn_call_style(context,\n-                                                shape,\n-                                                used_width + 2 * paren_overhead,\n-                                                used_width + paren_overhead)\n-        .ok_or(Ordering::Greater)?;\n+    let nested_shape = shape_from_fn_call_style(\n+        context,\n+        shape,\n+        used_width + 2 * paren_overhead,\n+        used_width + paren_overhead,\n+    ).ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n     let args_span = mk_sp(span_lo, span.hi);\n@@ -1727,12 +1851,14 @@ fn rewrite_call_inner(context: &RewriteContext,\n     if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n         let mut new_context = context.clone();\n         new_context.use_block = true;\n-        return rewrite_call_inner(&new_context,\n-                                  callee_str,\n-                                  args,\n-                                  span,\n-                                  shape,\n-                                  force_trailing_comma);\n+        return rewrite_call_inner(\n+            &new_context,\n+            callee_str,\n+            args,\n+            span,\n+            shape,\n+            force_trailing_comma,\n+        );\n     }\n \n     let args_shape = shape\n@@ -1745,28 +1871,32 @@ fn rewrite_call_inner(context: &RewriteContext,\n \n fn need_block_indent(s: &str, shape: Shape) -> bool {\n     s.lines().skip(1).any(|s| {\n-                              s.find(|c| !char::is_whitespace(c))\n-                                  .map_or(false, |w| w + 1 < shape.indent.width())\n-                          })\n+        s.find(|c| !char::is_whitespace(c)).map_or(false, |w| {\n+            w + 1 < shape.indent.width()\n+        })\n+    })\n }\n \n-fn rewrite_call_args(context: &RewriteContext,\n-                     args: &[ptr::P<ast::Expr>],\n-                     span: Span,\n-                     shape: Shape,\n-                     one_line_width: usize,\n-                     force_trailing_comma: bool)\n-                     -> Option<(bool, String)> {\n+fn rewrite_call_args(\n+    context: &RewriteContext,\n+    args: &[ptr::P<ast::Expr>],\n+    span: Span,\n+    shape: Shape,\n+    one_line_width: usize,\n+    force_trailing_comma: bool,\n+) -> Option<(bool, String)> {\n     let mut item_context = context.clone();\n     item_context.inside_macro = false;\n-    let items = itemize_list(context.codemap,\n-                             args.iter(),\n-                             \")\",\n-                             |item| item.span.lo,\n-                             |item| item.span.hi,\n-                             |item| item.rewrite(&item_context, shape),\n-                             span.lo,\n-                             span.hi);\n+    let items = itemize_list(\n+        context.codemap,\n+        args.iter(),\n+        \")\",\n+        |item| item.span.lo,\n+        |item| item.span.hi,\n+        |item| item.rewrite(&item_context, shape),\n+        span.lo,\n+        span.hi,\n+    );\n     let mut item_vec: Vec<_> = items.collect();\n \n     // Try letting the last argument overflow to the next line with block\n@@ -1789,15 +1919,18 @@ fn rewrite_call_args(context: &RewriteContext,\n         config: context.config,\n     };\n \n-    write_list(&item_vec, &fmt).map(|args_str| (tactic != DefinitiveListTactic::Vertical, args_str))\n+    write_list(&item_vec, &fmt).map(|args_str| {\n+        (tactic != DefinitiveListTactic::Vertical, args_str)\n+    })\n }\n \n-fn try_overflow_last_arg(context: &RewriteContext,\n-                         item_vec: &mut Vec<ListItem>,\n-                         args: &[ptr::P<ast::Expr>],\n-                         shape: Shape,\n-                         one_line_width: usize)\n-                         -> DefinitiveListTactic {\n+fn try_overflow_last_arg(\n+    context: &RewriteContext,\n+    item_vec: &mut Vec<ListItem>,\n+    args: &[ptr::P<ast::Expr>],\n+    shape: Shape,\n+    one_line_width: usize,\n+) -> DefinitiveListTactic {\n     let overflow_last = can_be_overflowed(&context, args);\n \n     // Replace the last item with its first line to see if it fits with\n@@ -1809,19 +1942,22 @@ fn try_overflow_last_arg(context: &RewriteContext,\n             _ => (),\n         }\n         last_arg_shape(&context, &item_vec, shape).map_or((None, None), |arg_shape| {\n-            rewrite_last_arg_with_overflow(&context,\n-                                           &args[args.len() - 1],\n-                                           &mut item_vec[args.len() - 1],\n-                                           arg_shape)\n+            rewrite_last_arg_with_overflow(\n+                &context,\n+                &args[args.len() - 1],\n+                &mut item_vec[args.len() - 1],\n+                arg_shape,\n+            )\n         })\n     } else {\n         (None, None)\n     };\n \n-    let tactic =\n-        definitive_tactic(&*item_vec,\n-                          ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n-                          one_line_width);\n+    let tactic = definitive_tactic(\n+        &*item_vec,\n+        ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n+        one_line_width,\n+    );\n \n     // Replace the stub with the full overflowing last argument if the rewrite\n     // succeeded and its first line fits with the other arguments.\n@@ -1849,17 +1985,18 @@ fn last_arg_shape(context: &RewriteContext, items: &Vec<ListItem>, shape: Shape)\n         shape.block().indent\n     };\n     Some(Shape {\n-             width: try_opt!(max_width.checked_sub(overhead)),\n-             indent: arg_indent,\n-             offset: 0,\n-         })\n+        width: try_opt!(max_width.checked_sub(overhead)),\n+        indent: arg_indent,\n+        offset: 0,\n+    })\n }\n \n-fn rewrite_last_arg_with_overflow(context: &RewriteContext,\n-                                  last_arg: &ptr::P<ast::Expr>,\n-                                  last_item: &mut ListItem,\n-                                  shape: Shape)\n-                                  -> (Option<String>, Option<String>) {\n+fn rewrite_last_arg_with_overflow(\n+    context: &RewriteContext,\n+    last_arg: &ptr::P<ast::Expr>,\n+    last_item: &mut ListItem,\n+    shape: Shape,\n+) -> (Option<String>, Option<String>) {\n     let rewrite = last_arg.rewrite(context, shape);\n     let orig_last = last_item.item.clone();\n \n@@ -1873,15 +2010,16 @@ fn rewrite_last_arg_with_overflow(context: &RewriteContext,\n }\n \n fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n-    args.last()\n-        .map_or(false, |x| can_be_overflowed_expr(context, &x, args.len()))\n+    args.last().map_or(false, |x| {\n+        can_be_overflowed_expr(context, &x, args.len())\n+    })\n }\n \n fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n     match expr.node {\n         ast::ExprKind::Match(..) => {\n             (context.use_block_indent() && args_len == 1) ||\n-            (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n+                (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n         }\n         ast::ExprKind::If(..) |\n         ast::ExprKind::IfLet(..) |\n@@ -1894,7 +2032,7 @@ fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len:\n         ast::ExprKind::Block(..) |\n         ast::ExprKind::Closure(..) => {\n             context.use_block_indent() ||\n-            context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n+                context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n         }\n         ast::ExprKind::Call(..) |\n         ast::ExprKind::MethodCall(..) |\n@@ -1933,10 +2071,12 @@ fn wrap_args_with_parens(context: &RewriteContext,\n             format!(\"({})\", args_str)\n         }\n     } else {\n-        format!(\"(\\n{}{}\\n{})\",\n-                nested_shape.indent.to_string(context.config),\n-                args_str,\n-                shape.block().indent.to_string(context.config))\n+        format!(\n+            \"(\\n{}{}\\n{})\",\n+            nested_shape.indent.to_string(context.config),\n+            args_str,\n+            shape.block().indent.to_string(context.config)\n+        )\n     }\n }\n \n@@ -1948,18 +2088,21 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     let subexpr_str = subexpr.rewrite(context, sub_shape);\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n-    subexpr_str.map(|s| if context.config.spaces_within_parens() && s.len() > 0 {\n-                        format!(\"( {} )\", s)\n-                    } else {\n-                        format!(\"({})\", s)\n-                    })\n+    subexpr_str.map(|s| if context.config.spaces_within_parens() &&\n+        s.len() > 0\n+    {\n+        format!(\"( {} )\", s)\n+    } else {\n+        format!(\"({})\", s)\n+    })\n }\n \n-fn rewrite_index(expr: &ast::Expr,\n-                 index: &ast::Expr,\n-                 context: &RewriteContext,\n-                 shape: Shape)\n-                 -> Option<String> {\n+fn rewrite_index(\n+    expr: &ast::Expr,\n+    index: &ast::Expr,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let expr_str = try_opt!(expr.rewrite(context, shape));\n \n     let (lbr, rbr) = if context.config.spaces_within_square_brackets() {\n@@ -1979,21 +2122,29 @@ fn rewrite_index(expr: &ast::Expr,\n     let indent = indent.to_string(&context.config);\n     // FIXME this is not right, since we don't take into account that shape.width\n     // might be reduced from max_width by something on the right.\n-    let budget = try_opt!(context\n-                              .config\n-                              .max_width()\n-                              .checked_sub(indent.len() + lbr.len() + rbr.len()));\n+    let budget = try_opt!(context.config.max_width().checked_sub(\n+        indent.len() + lbr.len() +\n+            rbr.len(),\n+    ));\n     let index_str = try_opt!(index.rewrite(context, Shape::legacy(budget, shape.indent)));\n-    Some(format!(\"{}\\n{}{}{}{}\", expr_str, indent, lbr, index_str, rbr))\n+    Some(format!(\n+        \"{}\\n{}{}{}{}\",\n+        expr_str,\n+        indent,\n+        lbr,\n+        index_str,\n+        rbr\n+    ))\n }\n \n-fn rewrite_struct_lit<'a>(context: &RewriteContext,\n-                          path: &ast::Path,\n-                          fields: &'a [ast::Field],\n-                          base: Option<&'a ast::Expr>,\n-                          span: Span,\n-                          shape: Shape)\n-                          -> Option<String> {\n+fn rewrite_struct_lit<'a>(\n+    context: &RewriteContext,\n+    path: &ast::Path,\n+    fields: &'a [ast::Field],\n+    base: Option<&'a ast::Expr>,\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String> {\n     debug!(\"rewrite_struct_lit: shape {:?}\", shape);\n \n     enum StructLitField<'a> {\n@@ -2003,7 +2154,13 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     // 2 = \" {\".len()\n     let path_shape = try_opt!(shape.sub_width(2));\n-    let path_str = try_opt!(rewrite_path(context, PathContext::Expr, None, path, path_shape));\n+    let path_str = try_opt!(rewrite_path(\n+        context,\n+        PathContext::Expr,\n+        None,\n+        path,\n+        path_shape,\n+    ));\n \n     if fields.len() == 0 && base.is_none() {\n         return Some(format!(\"{} {{}}\", path_str));\n@@ -2042,14 +2199,16 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         }\n     };\n \n-    let items = itemize_list(context.codemap,\n-                             field_iter,\n-                             \"}\",\n-                             span_lo,\n-                             span_hi,\n-                             rewrite,\n-                             context.codemap.span_after(span, \"{\"),\n-                             span.hi);\n+    let items = itemize_list(\n+        context.codemap,\n+        field_iter,\n+        \"}\",\n+        span_lo,\n+        span_hi,\n+        rewrite,\n+        context.codemap.span_after(span, \"{\"),\n+        span.hi,\n+    );\n     let item_vec = items.collect::<Vec<_>>();\n \n     let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n@@ -2058,14 +2217,16 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     let fields_str = try_opt!(write_list(&item_vec, &fmt));\n     let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n-                        (fields_str.contains('\\n') ||\n-                         context.config.struct_lit_multiline_style() ==\n-                         MultilineStyle::ForceMulti ||\n-                         fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n-        format!(\"\\n{}{}\\n{}\",\n-                v_shape.indent.to_string(context.config),\n-                fields_str,\n-                shape.indent.to_string(context.config))\n+        (fields_str.contains('\\n') ||\n+             context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti ||\n+             fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0))\n+    {\n+        format!(\n+            \"\\n{}{}\\n{}\",\n+            v_shape.indent.to_string(context.config),\n+            fields_str,\n+            shape.indent.to_string(context.config)\n+        )\n     } else {\n         // One liner or visual indent.\n         format!(\" {} \", fields_str)\n@@ -2078,8 +2239,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n }\n \n pub fn struct_lit_field_separator(config: &Config) -> &str {\n-    colon_spaces(config.space_before_struct_lit_field_colon(),\n-                 config.space_after_struct_lit_field_colon())\n+    colon_spaces(\n+        config.space_before_struct_lit_field_colon(),\n+        config.space_after_struct_lit_field_colon(),\n+    )\n }\n \n fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) -> Option<String> {\n@@ -2102,68 +2265,76 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n             Some(e) => Some(format!(\"{}{}{}{}\", attrs_str, name, separator, e)),\n             None => {\n                 let expr_offset = shape.indent.block_indent(context.config);\n-                let expr = field\n-                    .expr\n-                    .rewrite(context, Shape::indented(expr_offset, context.config));\n+                let expr = field.expr.rewrite(\n+                    context,\n+                    Shape::indented(expr_offset, context.config),\n+                );\n                 expr.map(|s| {\n-                             format!(\"{}{}:\\n{}{}\",\n-                                     attrs_str,\n-                                     name,\n-                                     expr_offset.to_string(&context.config),\n-                                     s)\n-                         })\n+                    format!(\n+                        \"{}{}:\\n{}{}\",\n+                        attrs_str,\n+                        name,\n+                        expr_offset.to_string(&context.config),\n+                        s\n+                    )\n+                })\n             }\n         }\n     }\n }\n \n-fn shape_from_fn_call_style(context: &RewriteContext,\n-                            shape: Shape,\n-                            overhead: usize,\n-                            offset: usize)\n-                            -> Option<Shape> {\n+fn shape_from_fn_call_style(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    overhead: usize,\n+    offset: usize,\n+) -> Option<Shape> {\n     if context.use_block_indent() {\n         Some(shape.block().block_indent(context.config.tab_spaces()))\n     } else {\n         shape.visual_indent(offset).sub_width(overhead)\n     }\n }\n \n-pub fn rewrite_tuple_type<'a, I>(context: &RewriteContext,\n-                                 mut items: I,\n-                                 span: Span,\n-                                 shape: Shape)\n-                                 -> Option<String>\n-    where I: ExactSizeIterator,\n-          <I as Iterator>::Item: Deref,\n-          <I::Item as Deref>::Target: Rewrite + Spanned + 'a\n+pub fn rewrite_tuple_type<'a, I>(\n+    context: &RewriteContext,\n+    mut items: I,\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String>\n+where\n+    I: ExactSizeIterator,\n+    <I as Iterator>::Item: Deref,\n+    <I::Item as Deref>::Target: Rewrite + Spanned + 'a,\n {\n     // In case of length 1, need a trailing comma\n     debug!(\"rewrite_tuple_type {:?}\", shape);\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n         let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n-        return items\n-            .next()\n-            .unwrap()\n-            .rewrite(context, nested_shape)\n-            .map(|s| if context.config.spaces_within_parens() {\n-                     format!(\"( {}, )\", s)\n-                 } else {\n-                     format!(\"({},)\", s)\n-                 });\n+        return items.next().unwrap().rewrite(context, nested_shape).map(\n+            |s| {\n+                if context.config.spaces_within_parens() {\n+                    format!(\"( {}, )\", s)\n+                } else {\n+                    format!(\"({},)\", s)\n+                }\n+            },\n+        );\n     }\n \n     let list_lo = context.codemap.span_after(span, \"(\");\n     let nested_shape = try_opt!(shape.sub_width(2)).visual_indent(1);\n-    let items = itemize_list(context.codemap,\n-                             items,\n-                             \")\",\n-                             |item| item.span().lo,\n-                             |item| item.span().hi,\n-                             |item| item.rewrite(context, nested_shape),\n-                             list_lo,\n-                             span.hi - BytePos(1));\n+    let items = itemize_list(\n+        context.codemap,\n+        items,\n+        \")\",\n+        |item| item.span().lo,\n+        |item| item.span().hi,\n+        |item| item.rewrite(context, nested_shape),\n+        list_lo,\n+        span.hi - BytePos(1),\n+    );\n     let list_str = try_opt!(format_item_list(items, nested_shape, context.config));\n \n     if context.config.spaces_within_parens() && list_str.len() > 0 {\n@@ -2173,11 +2344,12 @@ pub fn rewrite_tuple_type<'a, I>(context: &RewriteContext,\n     }\n }\n \n-pub fn rewrite_tuple(context: &RewriteContext,\n-                     items: &[ptr::P<ast::Expr>],\n-                     span: Span,\n-                     shape: Shape)\n-                     -> Option<String> {\n+pub fn rewrite_tuple(\n+    context: &RewriteContext,\n+    items: &[ptr::P<ast::Expr>],\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String> {\n     debug!(\"rewrite_tuple {:?}\", shape);\n     // Use old `rewrite_tuple`\n     if context.config.fn_call_style() == IndentStyle::Visual {\n@@ -2186,45 +2358,49 @@ pub fn rewrite_tuple(context: &RewriteContext,\n \n     // We use the same rule as funcation call for rewriting tuple.\n     // 1 = \",\"\n-    rewrite_call_inner(context,\n-                       &String::new(),\n-                       items,\n-                       span,\n-                       shape,\n-                       items.len() == 1)\n-        .ok()\n+    rewrite_call_inner(\n+        context,\n+        &String::new(),\n+        items,\n+        span,\n+        shape,\n+        items.len() == 1,\n+    ).ok()\n }\n \n-pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n-                                        prefix: &str,\n-                                        rewrite: &R,\n-                                        shape: Shape)\n-                                        -> Option<String> {\n+pub fn rewrite_unary_prefix<R: Rewrite>(\n+    context: &RewriteContext,\n+    prefix: &str,\n+    rewrite: &R,\n+    shape: Shape,\n+) -> Option<String> {\n     rewrite\n         .rewrite(context, try_opt!(shape.offset_left(prefix.len())))\n         .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n // FIXME: this is probably not correct for multi-line Rewrites. we should\n // subtract suffix.len() from the last line budget, not the first!\n-pub fn rewrite_unary_suffix<R: Rewrite>(context: &RewriteContext,\n-                                        suffix: &str,\n-                                        rewrite: &R,\n-                                        shape: Shape)\n-                                        -> Option<String> {\n+pub fn rewrite_unary_suffix<R: Rewrite>(\n+    context: &RewriteContext,\n+    suffix: &str,\n+    rewrite: &R,\n+    shape: Shape,\n+) -> Option<String> {\n     rewrite\n         .rewrite(context, try_opt!(shape.sub_width(suffix.len())))\n         .map(|mut r| {\n-                 r.push_str(suffix);\n-                 r\n-             })\n+            r.push_str(suffix);\n+            r\n+        })\n }\n \n-fn rewrite_unary_op(context: &RewriteContext,\n-                    op: &ast::UnOp,\n-                    expr: &ast::Expr,\n-                    shape: Shape)\n-                    -> Option<String> {\n+fn rewrite_unary_op(\n+    context: &RewriteContext,\n+    op: &ast::UnOp,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n     // For some reason, an UnOp is not spanned like BinOp!\n     let operator_str = match *op {\n         ast::UnOp::Deref => \"*\",\n@@ -2234,40 +2410,44 @@ fn rewrite_unary_op(context: &RewriteContext,\n     rewrite_unary_prefix(context, operator_str, expr, shape)\n }\n \n-fn rewrite_assignment(context: &RewriteContext,\n-                      lhs: &ast::Expr,\n-                      rhs: &ast::Expr,\n-                      op: Option<&ast::BinOp>,\n-                      shape: Shape)\n-                      -> Option<String> {\n+fn rewrite_assignment(\n+    context: &RewriteContext,\n+    lhs: &ast::Expr,\n+    rhs: &ast::Expr,\n+    op: Option<&ast::BinOp>,\n+    shape: Shape,\n+) -> Option<String> {\n     let operator_str = match op {\n         Some(op) => context.snippet(op.span),\n         None => \"=\".to_owned(),\n     };\n \n     // 1 = space between lhs and operator.\n     let lhs_shape = try_opt!(shape.sub_width(operator_str.len() + 1));\n-    let lhs_str = format!(\"{} {}\",\n-                          try_opt!(lhs.rewrite(context, lhs_shape)),\n-                          operator_str);\n+    let lhs_str = format!(\n+        \"{} {}\",\n+        try_opt!(lhs.rewrite(context, lhs_shape)),\n+        operator_str\n+    );\n \n     rewrite_assign_rhs(context, lhs_str, rhs, shape)\n }\n \n // The left hand side must contain everything up to, and including, the\n // assignment operator.\n-pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n-                                           lhs: S,\n-                                           ex: &ast::Expr,\n-                                           shape: Shape)\n-                                           -> Option<String> {\n+pub fn rewrite_assign_rhs<S: Into<String>>(\n+    context: &RewriteContext,\n+    lhs: S,\n+    ex: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n     let mut result = lhs.into();\n     let last_line_width = last_line_width(&result) -\n-                          if result.contains('\\n') {\n-                              shape.indent.width()\n-                          } else {\n-                              0\n-                          };\n+        if result.contains('\\n') {\n+            shape.indent.width()\n+        } else {\n+            0\n+        };\n     // 1 = space between operator and rhs.\n     let orig_shape = try_opt!(shape.block_indent(0).offset_left(last_line_width + 1));\n     let rhs = match ex.node {\n@@ -2300,10 +2480,21 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n \n             // FIXME: DRY!\n             match (rhs, new_rhs) {\n-                (Some(ref orig_rhs), Some(ref replacement_rhs))\n-                    if count_line_breaks(orig_rhs) > count_line_breaks(replacement_rhs) + 1 ||\n-                       (orig_rhs.rewrite(context, shape).is_none() &&\n-                        replacement_rhs.rewrite(context, new_shape).is_some()) => {\n+                (Some(ref orig_rhs), Some(ref replacement_rhs)) if count_line_breaks(\n+                    orig_rhs,\n+                ) >\n+                                                                       count_line_breaks(\n+                    replacement_rhs,\n+                ) + 1 ||\n+                                                                       (orig_rhs\n+                                                                            .rewrite(context, shape)\n+                                                                            .is_none() &&\n+                                                                            replacement_rhs\n+                                                                                .rewrite(\n+                    context,\n+                    new_shape,\n+                )\n+                                                                                .is_some()) => {\n                     result.push_str(&format!(\"\\n{}\", new_shape.indent.to_string(context.config)));\n                     result.push_str(replacement_rhs);\n                 }\n@@ -2323,11 +2514,12 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n     Some(result)\n }\n \n-fn rewrite_expr_addrof(context: &RewriteContext,\n-                       mutability: ast::Mutability,\n-                       expr: &ast::Expr,\n-                       shape: Shape)\n-                       -> Option<String> {\n+fn rewrite_expr_addrof(\n+    context: &RewriteContext,\n+    mutability: ast::Mutability,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n     let operator_str = match mutability {\n         ast::Mutability::Immutable => \"&\",\n         ast::Mutability::Mutable => \"&mut \","}, {"sha": "8a0ed4b5d7aa3daf0492ee49f5c32aefe33245f9", "filename": "src/file_lines.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -52,7 +52,7 @@ impl Range {\n             false\n         } else {\n             (self.lo <= other.hi && other.hi <= self.hi) ||\n-            (other.lo <= self.hi && self.hi <= other.hi)\n+                (other.lo <= self.hi && self.hi <= other.hi)\n         }\n     }\n \n@@ -68,7 +68,10 @@ impl Range {\n     /// intersect; returns `None` otherwise.\n     fn merge(self, other: Range) -> Option<Range> {\n         if self.adjacent_to(other) || self.intersects(other) {\n-            Some(Range::new(cmp::min(self.lo, other.lo), cmp::max(self.hi, other.hi)))\n+            Some(Range::new(\n+                cmp::min(self.lo, other.lo),\n+                cmp::max(self.hi, other.hi),\n+            ))\n         } else {\n             None\n         }\n@@ -127,7 +130,8 @@ impl FileLines {\n     /// Returns true if `self` includes all lines in all files. Otherwise runs `f` on all ranges in\n     /// the designated file (if any) and returns true if `f` ever does.\n     fn file_range_matches<F>(&self, file_name: &str, f: F) -> bool\n-        where F: FnMut(&Range) -> bool\n+    where\n+        F: FnMut(&Range) -> bool,\n     {\n         let map = match self.0 {\n             // `None` means \"all lines in all files\".\n@@ -209,8 +213,9 @@ struct JsonSpan {\n impl JsonSpan {\n     fn into_tuple(self) -> Result<(String, Range), String> {\n         let (lo, hi) = self.range;\n-        let canonical = canonicalize_path_string(&self.file)\n-            .ok_or_else(|| format!(\"Can't canonicalize {}\", &self.file))?;\n+        let canonical = canonicalize_path_string(&self.file).ok_or_else(|| {\n+            format!(\"Can't canonicalize {}\", &self.file)\n+        })?;\n         Ok((canonical, Range::new(lo, hi)))\n     }\n }\n@@ -219,18 +224,22 @@ impl JsonSpan {\n // for `FileLines`, so it will just panic instead.\n impl<'de> ::serde::de::Deserialize<'de> for FileLines {\n     fn deserialize<D>(_: D) -> Result<Self, D::Error>\n-        where D: ::serde::de::Deserializer<'de>\n+    where\n+        D: ::serde::de::Deserializer<'de>,\n     {\n-        panic!(\"FileLines cannot be deserialized from a project rustfmt.toml file: please \\\n-                specify it via the `--file-lines` option instead\");\n+        panic!(\n+            \"FileLines cannot be deserialized from a project rustfmt.toml file: please \\\n+                specify it via the `--file-lines` option instead\"\n+        );\n     }\n }\n \n // We also want to avoid attempting to serialize a FileLines to toml. The\n // `Config` struct should ensure this impl is never reached.\n impl ::serde::ser::Serialize for FileLines {\n     fn serialize<S>(&self, _: S) -> Result<S::Ok, S::Error>\n-        where S: ::serde::ser::Serializer\n+    where\n+        S: ::serde::ser::Serializer,\n     {\n         unreachable!(\"FileLines cannot be serialized. This is a rustfmt bug.\");\n     }\n@@ -270,13 +279,21 @@ mod test {\n     fn test_range_merge() {\n         assert_eq!(None, Range::new(1, 3).merge(Range::new(5, 5)));\n         assert_eq!(None, Range::new(4, 7).merge(Range::new(0, 1)));\n-        assert_eq!(Some(Range::new(3, 7)),\n-                   Range::new(3, 5).merge(Range::new(4, 7)));\n-        assert_eq!(Some(Range::new(3, 7)),\n-                   Range::new(3, 5).merge(Range::new(5, 7)));\n-        assert_eq!(Some(Range::new(3, 7)),\n-                   Range::new(3, 5).merge(Range::new(6, 7)));\n-        assert_eq!(Some(Range::new(3, 7)),\n-                   Range::new(3, 7).merge(Range::new(4, 5)));\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(4, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(5, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(6, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 7).merge(Range::new(4, 5))\n+        );\n     }\n }"}, {"sha": "e9779edfe5cbd51f269332cdd84802a3e743ae23", "filename": "src/filemap.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -31,7 +31,8 @@ pub fn append_newline(s: &mut StringBuffer) {\n }\n \n pub fn write_all_files<T>(file_map: &FileMap, out: &mut T, config: &Config) -> Result<(), io::Error>\n-    where T: Write\n+where\n+    T: Write,\n {\n     output_header(out, config.write_mode()).ok();\n     for &(ref filename, ref text) in file_map {\n@@ -43,11 +44,13 @@ pub fn write_all_files<T>(file_map: &FileMap, out: &mut T, config: &Config) -> R\n }\n \n // Prints all newlines either as `\\n` or as `\\r\\n`.\n-pub fn write_system_newlines<T>(writer: T,\n-                                text: &StringBuffer,\n-                                config: &Config)\n-                                -> Result<(), io::Error>\n-    where T: Write\n+pub fn write_system_newlines<T>(\n+    writer: T,\n+    text: &StringBuffer,\n+    config: &Config,\n+) -> Result<(), io::Error>\n+where\n+    T: Write,\n {\n     // Buffer output, since we're writing a since char at a time.\n     let mut writer = BufWriter::new(writer);\n@@ -78,18 +81,21 @@ pub fn write_system_newlines<T>(writer: T,\n     }\n }\n \n-pub fn write_file<T>(text: &StringBuffer,\n-                     filename: &str,\n-                     out: &mut T,\n-                     config: &Config)\n-                     -> Result<bool, io::Error>\n-    where T: Write\n+pub fn write_file<T>(\n+    text: &StringBuffer,\n+    filename: &str,\n+    out: &mut T,\n+    config: &Config,\n+) -> Result<bool, io::Error>\n+where\n+    T: Write,\n {\n \n-    fn source_and_formatted_text(text: &StringBuffer,\n-                                 filename: &str,\n-                                 config: &Config)\n-                                 -> Result<(String, String), io::Error> {\n+    fn source_and_formatted_text(\n+        text: &StringBuffer,\n+        filename: &str,\n+        config: &Config,\n+    ) -> Result<(String, String), io::Error> {\n         let mut f = File::open(filename)?;\n         let mut ori_text = String::new();\n         f.read_to_string(&mut ori_text)?;\n@@ -99,10 +105,11 @@ pub fn write_file<T>(text: &StringBuffer,\n         Ok((ori_text, fmt_text))\n     }\n \n-    fn create_diff(filename: &str,\n-                   text: &StringBuffer,\n-                   config: &Config)\n-                   -> Result<Vec<Mismatch>, io::Error> {\n+    fn create_diff(\n+        filename: &str,\n+        text: &StringBuffer,\n+        config: &Config,\n+    ) -> Result<Vec<Mismatch>, io::Error> {\n         let (ori, fmt) = source_and_formatted_text(text, filename, config)?;\n         Ok(make_diff(&ori, &fmt, 3))\n     }"}, {"sha": "8a327069c2fbaf431123f7af6f1b6bd9fbe88ecf", "filename": "src/imports.rs", "status": "modified", "additions": 90, "deletions": 56, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -73,9 +73,10 @@ fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Orde\n     }\n }\n \n-fn compare_path_list_item_lists(a_items: &Vec<ast::PathListItem>,\n-                                b_items: &Vec<ast::PathListItem>)\n-                                -> Ordering {\n+fn compare_path_list_item_lists(\n+    a_items: &Vec<ast::PathListItem>,\n+    b_items: &Vec<ast::PathListItem>,\n+) -> Ordering {\n     let mut a = a_items.clone();\n     let mut b = b_items.clone();\n     a.sort_by(|a, b| compare_path_list_items(a, b));\n@@ -123,19 +124,33 @@ fn compare_use_items(a: &ast::Item, b: &ast::Item) -> Option<Ordering> {\n // TODO (some day) remove unused imports, expand globs, compress many single\n // imports into a list import.\n \n-fn rewrite_view_path_prefix(path: &ast::Path,\n-                            context: &RewriteContext,\n-                            shape: Shape)\n-                            -> Option<String> {\n+fn rewrite_view_path_prefix(\n+    path: &ast::Path,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\" &&\n-                      path.segments.len() > 1 {\n+        path.segments.len() > 1\n+    {\n         let path = &ast::Path {\n             span: path.span.clone(),\n             segments: path.segments[..path.segments.len() - 1].to_owned(),\n         };\n-        try_opt!(rewrite_path(context, PathContext::Import, None, path, shape))\n+        try_opt!(rewrite_path(\n+            context,\n+            PathContext::Import,\n+            None,\n+            path,\n+            shape,\n+        ))\n     } else {\n-        try_opt!(rewrite_path(context, PathContext::Import, None, path, shape))\n+        try_opt!(rewrite_path(\n+            context,\n+            PathContext::Import,\n+            None,\n+            path,\n+            shape,\n+        ))\n     };\n     Some(path_str)\n }\n@@ -162,11 +177,13 @@ impl Rewrite for ast::ViewPath {\n                 let prefix_shape = try_opt!(shape.sub_width(ident_str.len() + 4));\n                 let path_str = try_opt!(rewrite_view_path_prefix(path, context, prefix_shape));\n \n-                Some(if path.segments.last().unwrap().identifier == ident {\n-                         path_str\n-                     } else {\n-                         format!(\"{} as {}\", path_str, ident_str)\n-                     })\n+                Some(\n+                    if path.segments.last().unwrap().identifier == ident {\n+                        path_str\n+                    } else {\n+                        format!(\"{} as {}\", path_str, ident_str)\n+                    },\n+                )\n             }\n         }\n     }\n@@ -179,24 +196,24 @@ impl<'a> FmtVisitor<'a> {\n         let pos_before_first_use_item = use_items\n             .first()\n             .map(|p_i| {\n-                     cmp::max(self.last_pos,\n-                              p_i.attrs\n-                                  .iter()\n-                                  .map(|attr| attr.span.lo)\n-                                  .min()\n-                                  .unwrap_or(p_i.span.lo))\n-                 })\n+                cmp::max(\n+                    self.last_pos,\n+                    p_i.attrs.iter().map(|attr| attr.span.lo).min().unwrap_or(\n+                        p_i.span.lo,\n+                    ),\n+                )\n+            })\n             .unwrap_or(self.last_pos);\n         // Construct a list of pairs, each containing a `use` item and the start of span before\n         // that `use` item.\n         let mut last_pos_of_prev_use_item = pos_before_first_use_item;\n         let mut ordered_use_items = use_items\n             .iter()\n             .map(|p_i| {\n-                     let new_item = (&*p_i, last_pos_of_prev_use_item);\n-                     last_pos_of_prev_use_item = p_i.span.hi;\n-                     new_item\n-                 })\n+                let new_item = (&*p_i, last_pos_of_prev_use_item);\n+                last_pos_of_prev_use_item = p_i.span.hi;\n+                new_item\n+            })\n             .collect::<Vec<_>>();\n         let pos_after_last_use_item = last_pos_of_prev_use_item;\n         // Order the imports by view-path & other import path properties\n@@ -237,8 +254,10 @@ impl<'a> FmtVisitor<'a> {\n         let mut offset = self.block_indent;\n         offset.alignment += vis.len() + \"use \".len();\n         // 1 = \";\"\n-        match vp.rewrite(&self.get_context(),\n-                         Shape::legacy(self.config.max_width() - offset.width() - 1, offset)) {\n+        match vp.rewrite(\n+            &self.get_context(),\n+            Shape::legacy(self.config.max_width() - offset.width() - 1, offset),\n+        ) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n                 let prev_span = utils::mk_sp(self.last_pos, source!(self, span).lo);\n@@ -295,14 +314,21 @@ fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n \n // Pretty prints a multi-item import.\n // Assumes that path_list.len() > 0.\n-pub fn rewrite_use_list(shape: Shape,\n-                        path: &ast::Path,\n-                        path_list: &[ast::PathListItem],\n-                        span: Span,\n-                        context: &RewriteContext)\n-                        -> Option<String> {\n+pub fn rewrite_use_list(\n+    shape: Shape,\n+    path: &ast::Path,\n+    path_list: &[ast::PathListItem],\n+    span: Span,\n+    context: &RewriteContext,\n+) -> Option<String> {\n     // Returns a different option to distinguish `::foo` and `foo`\n-    let path_str = try_opt!(rewrite_path(context, PathContext::Import, None, path, shape));\n+    let path_str = try_opt!(rewrite_path(\n+        context,\n+        PathContext::Import,\n+        None,\n+        path,\n+        shape,\n+    ));\n \n     match path_list.len() {\n         0 => unreachable!(),\n@@ -321,14 +347,16 @@ pub fn rewrite_use_list(shape: Shape,\n     let mut items = {\n         // Dummy value, see explanation below.\n         let mut items = vec![ListItem::from_str(\"\")];\n-        let iter = itemize_list(context.codemap,\n-                                path_list.iter(),\n-                                \"}\",\n-                                |vpi| vpi.span.lo,\n-                                |vpi| vpi.span.hi,\n-                                rewrite_path_item,\n-                                context.codemap.span_after(span, \"{\"),\n-                                span.hi);\n+        let iter = itemize_list(\n+            context.codemap,\n+            path_list.iter(),\n+            \"}\",\n+            |vpi| vpi.span.lo,\n+            |vpi| vpi.span.hi,\n+            rewrite_path_item,\n+            context.codemap.span_after(span, \"{\"),\n+            span.hi,\n+        );\n         items.extend(iter);\n         items\n     };\n@@ -344,34 +372,40 @@ pub fn rewrite_use_list(shape: Shape,\n     }\n \n \n-    let tactic = definitive_tactic(&items[first_index..],\n-                                   ::lists::ListTactic::Mixed,\n-                                   remaining_width);\n+    let tactic = definitive_tactic(\n+        &items[first_index..],\n+        ::lists::ListTactic::Mixed,\n+        remaining_width,\n+    );\n \n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n         // Add one to the indent to account for \"{\"\n-        shape: Shape::legacy(remaining_width,\n-                             shape.indent + path_str.len() + colons_offset + 1),\n+        shape: Shape::legacy(\n+            remaining_width,\n+            shape.indent + path_str.len() + colons_offset + 1,\n+        ),\n         ends_with_newline: false,\n         config: context.config,\n     };\n     let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n-    Some(if path_str.is_empty() {\n-             format!(\"{{{}}}\", list_str)\n-         } else {\n-             format!(\"{}::{{{}}}\", path_str, list_str)\n-         })\n+    Some(\n+        if path_str.is_empty() {\n+            format!(\"{{{}}}\", list_str)\n+        } else {\n+            format!(\"{}::{{{}}}\", path_str, list_str)\n+        },\n+    )\n }\n \n // Returns true when self item was found.\n fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n-    match items\n-              .iter()\n-              .position(|item| item.item.as_ref().map(|x| &x[..]) == Some(\"self\")) {\n+    match items.iter().position(|item| {\n+        item.item.as_ref().map(|x| &x[..]) == Some(\"self\")\n+    }) {\n         Some(pos) => {\n             items[0] = items.remove(pos);\n             true"}, {"sha": "0211723e93051f4944ff028e65874cb6923c8f19", "filename": "src/issues.rs", "status": "modified", "additions": 57, "deletions": 40, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -172,11 +172,12 @@ impl BadIssueSeeker {\n         }\n     }\n \n-    fn inspect_number(&mut self,\n-                      c: char,\n-                      issue: Issue,\n-                      mut part: NumberPart)\n-                      -> IssueClassification {\n+    fn inspect_number(\n+        &mut self,\n+        c: char,\n+        issue: Issue,\n+        mut part: NumberPart,\n+    ) -> IssueClassification {\n         if !issue.missing_number || c == '\\n' {\n             return IssueClassification::Bad(issue);\n         } else if c == ')' {\n@@ -223,8 +224,10 @@ impl BadIssueSeeker {\n fn find_unnumbered_issue() {\n     fn check_fail(text: &str, failing_pos: usize) {\n         let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n-        assert_eq!(Some(failing_pos),\n-                   text.chars().position(|c| seeker.inspect(c).is_some()));\n+        assert_eq!(\n+            Some(failing_pos),\n+            text.chars().position(|c| seeker.inspect(c).is_some())\n+        );\n     }\n \n     fn check_pass(text: &str) {\n@@ -252,46 +255,60 @@ fn find_issue() {\n         text.chars().any(|c| seeker.inspect(c).is_some())\n     }\n \n-    assert!(is_bad_issue(\"TODO(@maintainer, #1222, hello)\\n\",\n-                         ReportTactic::Always,\n-                         ReportTactic::Never));\n-\n-    assert!(!is_bad_issue(\"TODO: no number\\n\",\n-                          ReportTactic::Never,\n-                          ReportTactic::Always));\n-\n-    assert!(is_bad_issue(\"This is a FIXME(#1)\\n\",\n-                         ReportTactic::Never,\n-                         ReportTactic::Always));\n-\n-    assert!(!is_bad_issue(\"bad FIXME\\n\", ReportTactic::Always, ReportTactic::Never));\n+    assert!(is_bad_issue(\n+        \"TODO(@maintainer, #1222, hello)\\n\",\n+        ReportTactic::Always,\n+        ReportTactic::Never,\n+    ));\n+\n+    assert!(!is_bad_issue(\n+        \"TODO: no number\\n\",\n+        ReportTactic::Never,\n+        ReportTactic::Always,\n+    ));\n+\n+    assert!(is_bad_issue(\n+        \"This is a FIXME(#1)\\n\",\n+        ReportTactic::Never,\n+        ReportTactic::Always,\n+    ));\n+\n+    assert!(!is_bad_issue(\n+        \"bad FIXME\\n\",\n+        ReportTactic::Always,\n+        ReportTactic::Never,\n+    ));\n }\n \n #[test]\n fn issue_type() {\n     let mut seeker = BadIssueSeeker::new(ReportTactic::Always, ReportTactic::Never);\n     let expected = Some(Issue {\n-                            issue_type: IssueType::Todo,\n-                            missing_number: false,\n-                        });\n-\n-    assert_eq!(expected,\n-               \"TODO(#100): more awesomeness\"\n-                   .chars()\n-                   .map(|c| seeker.inspect(c))\n-                   .find(Option::is_some)\n-                   .unwrap());\n+        issue_type: IssueType::Todo,\n+        missing_number: false,\n+    });\n+\n+    assert_eq!(\n+        expected,\n+        \"TODO(#100): more awesomeness\"\n+            .chars()\n+            .map(|c| seeker.inspect(c))\n+            .find(Option::is_some)\n+            .unwrap()\n+    );\n \n     let mut seeker = BadIssueSeeker::new(ReportTactic::Never, ReportTactic::Unnumbered);\n     let expected = Some(Issue {\n-                            issue_type: IssueType::Fixme,\n-                            missing_number: true,\n-                        });\n-\n-    assert_eq!(expected,\n-               \"Test. FIXME: bad, bad, not good\"\n-                   .chars()\n-                   .map(|c| seeker.inspect(c))\n-                   .find(Option::is_some)\n-                   .unwrap());\n+        issue_type: IssueType::Fixme,\n+        missing_number: true,\n+    });\n+\n+    assert_eq!(\n+        expected,\n+        \"Test. FIXME: bad, bad, not good\"\n+            .chars()\n+            .map(|c| seeker.inspect(c))\n+            .find(Option::is_some)\n+            .unwrap()\n+    );\n }"}, {"sha": "3639e5ae0e5f3d94852699ab9aadf81a1a106114", "filename": "src/items.rs", "status": "modified", "additions": 853, "deletions": 694, "changes": 1547, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -29,19 +29,23 @@ use syntax::codemap::{Span, BytePos};\n use syntax::ast::ImplItem;\n \n fn type_annotation_separator(config: &Config) -> &str {\n-    colon_spaces(config.space_before_type_annotation(),\n-                 config.space_after_type_annotation_colon())\n+    colon_spaces(\n+        config.space_before_type_annotation(),\n+        config.space_after_type_annotation_colon(),\n+    )\n }\n \n \n // Statements of the form\n // let pat: ty = init;\n impl Rewrite for ast::Local {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        debug!(\"Local::rewrite {:?} {} {:?}\",\n-               self,\n-               shape.width,\n-               shape.indent);\n+        debug!(\n+            \"Local::rewrite {:?} {} {:?}\",\n+            self,\n+            shape.width,\n+            shape.indent\n+        );\n         let mut result = \"let \".to_owned();\n \n         // 4 = \"let \".len()\n@@ -145,8 +149,9 @@ impl<'a> FmtVisitor<'a> {\n                 self.format_missing_no_indent(item.span.hi - BytePos(1));\n                 self.block_indent = self.block_indent.block_unindent(self.config);\n \n-                self.buffer\n-                    .push_str(&self.block_indent.to_string(self.config));\n+                self.buffer.push_str(\n+                    &self.block_indent.to_string(self.config),\n+                );\n             } else {\n                 for item in &item.body {\n                     self.format_body_element(item);\n@@ -181,22 +186,24 @@ impl<'a> FmtVisitor<'a> {\n         match item.node {\n             ast::ForeignItemKind::Fn(ref fn_decl, ref generics) => {\n                 let indent = self.block_indent;\n-                let rewrite = rewrite_fn_base(&self.get_context(),\n-                                              indent,\n-                                              item.ident,\n-                                              fn_decl,\n-                                              generics,\n-                                              ast::Unsafety::Normal,\n-                                              ast::Constness::NotConst,\n-                                              ast::Defaultness::Final,\n-                                              // These are not actually rust functions,\n-                                              // but we format them as such.\n-                                              abi::Abi::Rust,\n-                                              &item.vis,\n-                                              span,\n-                                              false,\n-                                              false,\n-                                              false);\n+                let rewrite = rewrite_fn_base(\n+                    &self.get_context(),\n+                    indent,\n+                    item.ident,\n+                    fn_decl,\n+                    generics,\n+                    ast::Unsafety::Normal,\n+                    ast::Constness::NotConst,\n+                    ast::Defaultness::Final,\n+                    // These are not actually rust functions,\n+                    // but we format them as such.\n+                    abi::Abi::Rust,\n+                    &item.vis,\n+                    span,\n+                    false,\n+                    false,\n+                    false,\n+                );\n \n                 match rewrite {\n                     Some((new_fn, _)) => {\n@@ -231,45 +238,49 @@ impl<'a> FmtVisitor<'a> {\n         self.last_pos = item.span.hi;\n     }\n \n-    pub fn rewrite_fn(&mut self,\n-                      indent: Indent,\n-                      ident: ast::Ident,\n-                      fd: &ast::FnDecl,\n-                      generics: &ast::Generics,\n-                      unsafety: ast::Unsafety,\n-                      constness: ast::Constness,\n-                      defaultness: ast::Defaultness,\n-                      abi: abi::Abi,\n-                      vis: &ast::Visibility,\n-                      span: Span,\n-                      block: &ast::Block)\n-                      -> Option<String> {\n+    pub fn rewrite_fn(\n+        &mut self,\n+        indent: Indent,\n+        ident: ast::Ident,\n+        fd: &ast::FnDecl,\n+        generics: &ast::Generics,\n+        unsafety: ast::Unsafety,\n+        constness: ast::Constness,\n+        defaultness: ast::Defaultness,\n+        abi: abi::Abi,\n+        vis: &ast::Visibility,\n+        span: Span,\n+        block: &ast::Block,\n+    ) -> Option<String> {\n         let mut newline_brace = newline_for_brace(self.config, &generics.where_clause);\n         let context = self.get_context();\n \n         let block_snippet = self.snippet(mk_sp(block.span.lo, block.span.hi));\n         let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n-                       !context.config.fn_empty_single_line();\n-\n-        let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(&context,\n-                                                                         indent,\n-                                                                         ident,\n-                                                                         fd,\n-                                                                         generics,\n-                                                                         unsafety,\n-                                                                         constness,\n-                                                                         defaultness,\n-                                                                         abi,\n-                                                                         vis,\n-                                                                         span,\n-                                                                         newline_brace,\n-                                                                         has_body,\n-                                                                         true));\n+            !context.config.fn_empty_single_line();\n+\n+        let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(\n+            &context,\n+            indent,\n+            ident,\n+            fd,\n+            generics,\n+            unsafety,\n+            constness,\n+            defaultness,\n+            abi,\n+            vis,\n+            span,\n+            newline_brace,\n+            has_body,\n+            true,\n+        ));\n \n         if force_newline_brace {\n             newline_brace = true;\n         } else if self.config.fn_brace_style() != BraceStyle::AlwaysNextLine &&\n-                  !result.contains('\\n') {\n+                   !result.contains('\\n')\n+        {\n             newline_brace = false;\n         }\n \n@@ -288,30 +299,33 @@ impl<'a> FmtVisitor<'a> {\n         self.single_line_fn(&result, block).or_else(|| Some(result))\n     }\n \n-    pub fn rewrite_required_fn(&mut self,\n-                               indent: Indent,\n-                               ident: ast::Ident,\n-                               sig: &ast::MethodSig,\n-                               span: Span)\n-                               -> Option<String> {\n+    pub fn rewrite_required_fn(\n+        &mut self,\n+        indent: Indent,\n+        ident: ast::Ident,\n+        sig: &ast::MethodSig,\n+        span: Span,\n+    ) -> Option<String> {\n         // Drop semicolon or it will be interpreted as comment.\n         let span = mk_sp(span.lo, span.hi - BytePos(1));\n         let context = self.get_context();\n \n-        let (mut result, _) = try_opt!(rewrite_fn_base(&context,\n-                                                       indent,\n-                                                       ident,\n-                                                       &sig.decl,\n-                                                       &sig.generics,\n-                                                       sig.unsafety,\n-                                                       sig.constness.node,\n-                                                       ast::Defaultness::Final,\n-                                                       sig.abi,\n-                                                       &ast::Visibility::Inherited,\n-                                                       span,\n-                                                       false,\n-                                                       false,\n-                                                       false));\n+        let (mut result, _) = try_opt!(rewrite_fn_base(\n+            &context,\n+            indent,\n+            ident,\n+            &sig.decl,\n+            &sig.generics,\n+            sig.unsafety,\n+            sig.constness.node,\n+            ast::Defaultness::Final,\n+            sig.abi,\n+            &ast::Visibility::Inherited,\n+            span,\n+            false,\n+            false,\n+            false,\n+        ));\n \n         // Re-attach semicolon\n         result.push(';');\n@@ -327,7 +341,8 @@ impl<'a> FmtVisitor<'a> {\n         let codemap = self.get_context().codemap;\n \n         if self.config.fn_empty_single_line() && is_empty_block(block, codemap) &&\n-           self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width() {\n+            self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width()\n+        {\n             return Some(format!(\"{}{{}}\", fn_str));\n         }\n \n@@ -338,14 +353,17 @@ impl<'a> FmtVisitor<'a> {\n                         Some(e) => {\n                             let suffix = if semicolon_for_expr(e) { \";\" } else { \"\" };\n \n-                            e.rewrite(&self.get_context(),\n-                                      Shape::indented(self.block_indent, self.config))\n-                                .map(|s| s + suffix)\n+                            e.rewrite(\n+                                &self.get_context(),\n+                                Shape::indented(self.block_indent, self.config),\n+                            ).map(|s| s + suffix)\n                                 .or_else(|| Some(self.snippet(e.span)))\n                         }\n                         None => {\n-                            stmt.rewrite(&self.get_context(),\n-                                         Shape::indented(self.block_indent, self.config))\n+                            stmt.rewrite(\n+                                &self.get_context(),\n+                                Shape::indented(self.block_indent, self.config),\n+                            )\n                         }\n                     }\n                 } else {\n@@ -364,26 +382,29 @@ impl<'a> FmtVisitor<'a> {\n         None\n     }\n \n-    pub fn visit_enum(&mut self,\n-                      ident: ast::Ident,\n-                      vis: &ast::Visibility,\n-                      enum_def: &ast::EnumDef,\n-                      generics: &ast::Generics,\n-                      span: Span) {\n+    pub fn visit_enum(\n+        &mut self,\n+        ident: ast::Ident,\n+        vis: &ast::Visibility,\n+        enum_def: &ast::EnumDef,\n+        generics: &ast::Generics,\n+        span: Span,\n+    ) {\n         self.buffer.push_str(&format_header(\"enum \", ident, vis));\n \n         let enum_snippet = self.snippet(span);\n         let brace_pos = enum_snippet.find_uncommented(\"{\").unwrap();\n         let body_start = span.lo + BytePos(brace_pos as u32 + 1);\n-        let generics_str = format_generics(&self.get_context(),\n-                                           generics,\n-                                           \"{\",\n-                                           \"{\",\n-                                           self.config.item_brace_style(),\n-                                           enum_def.variants.is_empty(),\n-                                           self.block_indent,\n-                                           mk_sp(span.lo, body_start))\n-            .unwrap();\n+        let generics_str = format_generics(\n+            &self.get_context(),\n+            generics,\n+            \"{\",\n+            \"{\",\n+            self.config.item_brace_style(),\n+            enum_def.variants.is_empty(),\n+            self.block_indent,\n+            mk_sp(span.lo, body_start),\n+        ).unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n@@ -403,19 +424,21 @@ impl<'a> FmtVisitor<'a> {\n         self.block_indent = self.block_indent.block_unindent(self.config);\n \n         if variant_list.is_some() || contains_comment(&enum_snippet[brace_pos..]) {\n-            self.buffer\n-                .push_str(&self.block_indent.to_string(self.config));\n+            self.buffer.push_str(\n+                &self.block_indent.to_string(self.config),\n+            );\n         }\n         self.buffer.push_str(\"}\");\n         self.last_pos = span.hi;\n     }\n \n     // Format the body of an enum definition\n-    fn format_variant_list(&self,\n-                           enum_def: &ast::EnumDef,\n-                           body_lo: BytePos,\n-                           body_hi: BytePos)\n-                           -> Option<String> {\n+    fn format_variant_list(\n+        &self,\n+        enum_def: &ast::EnumDef,\n+        body_lo: BytePos,\n+        body_hi: BytePos,\n+    ) -> Option<String> {\n         if enum_def.variants.is_empty() {\n             return None;\n         }\n@@ -424,18 +447,20 @@ impl<'a> FmtVisitor<'a> {\n         let indentation = self.block_indent.to_string(self.config);\n         result.push_str(&indentation);\n \n-        let items = itemize_list(self.codemap,\n-                                 enum_def.variants.iter(),\n-                                 \"}\",\n-                                 |f| if !f.node.attrs.is_empty() {\n-                                     f.node.attrs[0].span.lo\n-                                 } else {\n-                                     f.span.lo\n-                                 },\n-                                 |f| f.span.hi,\n-                                 |f| self.format_variant(f),\n-                                 body_lo,\n-                                 body_hi);\n+        let items = itemize_list(\n+            self.codemap,\n+            enum_def.variants.iter(),\n+            \"}\",\n+            |f| if !f.node.attrs.is_empty() {\n+                f.node.attrs[0].span.lo\n+            } else {\n+                f.span.lo\n+            },\n+            |f| f.span.hi,\n+            |f| self.format_variant(f),\n+            body_lo,\n+            body_hi,\n+        );\n \n         let shape = Shape::indented(self.block_indent, self.config)\n             .sub_width(2)\n@@ -465,41 +490,41 @@ impl<'a> FmtVisitor<'a> {\n \n         let context = self.get_context();\n         let indent = self.block_indent;\n-        let mut result = try_opt!(field\n-                                      .node\n-                                      .attrs\n-                                      .rewrite(&context, Shape::indented(indent, self.config)));\n+        let mut result = try_opt!(field.node.attrs.rewrite(\n+            &context,\n+            Shape::indented(indent, self.config),\n+        ));\n         if !result.is_empty() {\n             let shape = Shape {\n                 width: context.config.max_width(),\n                 indent: self.block_indent,\n                 offset: self.block_indent.alignment,\n             };\n-            let missing_comment =\n-                rewrite_missing_comment_on_field(&context,\n-                                                 shape,\n-                                                 field.node.attrs[field.node.attrs.len() - 1]\n-                                                     .span\n-                                                     .hi,\n-                                                 field.span.lo,\n-                                                 &mut result)\n-                    .unwrap_or(String::new());\n+            let missing_comment = rewrite_missing_comment_on_field(\n+                &context,\n+                shape,\n+                field.node.attrs[field.node.attrs.len() - 1].span.hi,\n+                field.span.lo,\n+                &mut result,\n+            ).unwrap_or(String::new());\n             result.push_str(&missing_comment);\n         }\n \n         let variant_body = match field.node.data {\n             ast::VariantData::Tuple(..) |\n             ast::VariantData::Struct(..) => {\n                 // FIXME: Should limit the width, as we have a trailing comma\n-                format_struct(&context,\n-                              \"\",\n-                              field.node.name,\n-                              &ast::Visibility::Inherited,\n-                              &field.node.data,\n-                              None,\n-                              field.span,\n-                              indent,\n-                              Some(self.config.struct_variant_width()))\n+                format_struct(\n+                    &context,\n+                    \"\",\n+                    field.node.name,\n+                    &ast::Visibility::Inherited,\n+                    &field.node.data,\n+                    None,\n+                    field.span,\n+                    indent,\n+                    Some(self.config.struct_variant_width()),\n+                )\n             }\n             ast::VariantData::Unit(..) => {\n                 let tag = if let Some(ref expr) = field.node.disr_expr {\n@@ -508,9 +533,11 @@ impl<'a> FmtVisitor<'a> {\n                     field.node.name.to_string()\n                 };\n \n-                wrap_str(tag,\n-                         self.config.max_width(),\n-                         Shape::indented(indent, self.config))\n+                wrap_str(\n+                    tag,\n+                    self.config.max_width(),\n+                    Shape::indented(indent, self.config),\n+                )\n             }\n         };\n \n@@ -626,31 +653,35 @@ pub fn format_impl(context: &RewriteContext,\n     }\n }\n \n-fn is_impl_single_line(context: &RewriteContext,\n-                       items: &[ImplItem],\n-                       result: &str,\n-                       where_clause_str: &str,\n-                       item: &ast::Item)\n-                       -> Option<bool> {\n+fn is_impl_single_line(\n+    context: &RewriteContext,\n+    items: &[ImplItem],\n+    result: &str,\n+    where_clause_str: &str,\n+    item: &ast::Item,\n+) -> Option<bool> {\n     let snippet = context.snippet(item.span);\n     let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n-    Some(context.config.impl_empty_single_line() && items.is_empty() &&\n-         result.len() + where_clause_str.len() <= context.config.max_width() &&\n-         !contains_comment(&snippet[open_pos..]))\n+    Some(\n+        context.config.impl_empty_single_line() && items.is_empty() &&\n+            result.len() + where_clause_str.len() <= context.config.max_width() &&\n+            !contains_comment(&snippet[open_pos..]),\n+    )\n }\n \n fn format_impl_ref_and_type(context: &RewriteContext,\n                             item: &ast::Item,\n                             offset: Indent)\n                             -> Option<String> {\n     if let ast::ItemKind::Impl(unsafety,\n-                               polarity,\n-                               _,\n-                               ref generics,\n-                               ref trait_ref,\n-                               ref self_ty,\n-                               _) = item.node {\n+                            polarity,\n+                            _,\n+                            ref generics,\n+                            ref trait_ref,\n+                            ref self_ty,\n+                            _) = item.node\n+    {\n         let mut result = String::new();\n \n         result.push_str(&format_visibility(&item.vis));\n@@ -802,37 +833,44 @@ pub fn format_struct(context: &RewriteContext,\n     match *struct_def {\n         ast::VariantData::Unit(..) => Some(format_unit_struct(item_name, ident, vis)),\n         ast::VariantData::Tuple(ref fields, _) => {\n-            format_tuple_struct(context,\n-                                item_name,\n-                                ident,\n-                                vis,\n-                                fields,\n-                                generics,\n-                                span,\n-                                offset)\n+            format_tuple_struct(\n+                context,\n+                item_name,\n+                ident,\n+                vis,\n+                fields,\n+                generics,\n+                span,\n+                offset,\n+            )\n         }\n         ast::VariantData::Struct(ref fields, _) => {\n-            format_struct_struct(context,\n-                                 item_name,\n-                                 ident,\n-                                 vis,\n-                                 fields,\n-                                 generics,\n-                                 span,\n-                                 offset,\n-                                 one_line_width)\n+            format_struct_struct(\n+                context,\n+                item_name,\n+                ident,\n+                vis,\n+                fields,\n+                generics,\n+                span,\n+                offset,\n+                one_line_width,\n+            )\n         }\n     }\n }\n \n pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent) -> Option<String> {\n     if let ast::ItemKind::Trait(unsafety, ref generics, ref type_param_bounds, ref trait_items) =\n-        item.node {\n+        item.node\n+    {\n         let mut result = String::new();\n-        let header = format!(\"{}{}trait {}\",\n-                             format_visibility(&item.vis),\n-                             format_unsafety(unsafety),\n-                             item.ident);\n+        let header = format!(\n+            \"{}{}trait {}\",\n+            format_visibility(&item.vis),\n+            format_unsafety(unsafety),\n+            item.ident\n+        );\n \n         result.push_str(&header);\n \n@@ -843,14 +881,16 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             try_opt!(rewrite_generics(context, generics, shape, mk_sp(item.span.lo, body_lo)));\n         result.push_str(&generics_str);\n \n-        let trait_bound_str =\n-            try_opt!(rewrite_trait_bounds(context,\n-                                          type_param_bounds,\n-                                          Shape::legacy(context.config.max_width(), offset)));\n+        let trait_bound_str = try_opt!(rewrite_trait_bounds(\n+            context,\n+            type_param_bounds,\n+            Shape::legacy(context.config.max_width(), offset),\n+        ));\n         // If the trait, generics, and trait bound cannot fit on the same line,\n         // put the trait bounds on an indented new line\n         if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n-           context.config.comment_width() {\n+            context.config.comment_width()\n+        {\n             result.push('\\n');\n             let trait_indent = offset.block_only().block_indent(context.config);\n             result.push_str(&trait_indent.to_string(context.config));\n@@ -859,38 +899,39 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let has_body = !trait_items.is_empty();\n \n-        let where_density =\n-            if (context.config.where_density() == Density::Compressed &&\n-                (!result.contains('\\n') ||\n-                 context.config.fn_args_layout() == IndentStyle::Block)) ||\n-               (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty()) ||\n-               (context.config.where_density() == Density::CompressedIfEmpty && !has_body &&\n-                !result.contains('\\n')) {\n-                Density::Compressed\n-            } else {\n-                Density::Tall\n-            };\n+        let where_density = if (context.config.where_density() == Density::Compressed &&\n+                                 (!result.contains('\\n') ||\n+                                      context.config.fn_args_layout() == IndentStyle::Block)) ||\n+            (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty()) ||\n+            (context.config.where_density() == Density::CompressedIfEmpty && !has_body &&\n+                 !result.contains('\\n'))\n+        {\n+            Density::Compressed\n+        } else {\n+            Density::Tall\n+        };\n \n-        let where_budget = try_opt!(context\n-                                        .config\n-                                        .max_width()\n-                                        .checked_sub(last_line_width(&result)));\n-        let where_clause_str = try_opt!(rewrite_where_clause(context,\n-                                                             &generics.where_clause,\n-                                                             context.config.item_brace_style(),\n-                                                             Shape::legacy(where_budget,\n-                                                                           offset.block_only()),\n-                                                             where_density,\n-                                                             \"{\",\n-                                                             !has_body,\n-                                                             trait_bound_str.is_empty() &&\n-                                                             last_line_width(&generics_str) == 1,\n-                                                             None));\n+        let where_budget = try_opt!(context.config.max_width().checked_sub(\n+            last_line_width(&result),\n+        ));\n+        let where_clause_str = try_opt!(rewrite_where_clause(\n+            context,\n+            &generics.where_clause,\n+            context.config.item_brace_style(),\n+            Shape::legacy(where_budget, offset.block_only()),\n+            where_density,\n+            \"{\",\n+            !has_body,\n+            trait_bound_str.is_empty() &&\n+                last_line_width(&generics_str) == 1,\n+            None,\n+        ));\n         // If the where clause cannot fit on the same line,\n         // put the where clause on a new line\n         if !where_clause_str.contains('\\n') &&\n-           last_line_width(&result) + where_clause_str.len() + offset.width() >\n-           context.config.comment_width() {\n+            last_line_width(&result) + where_clause_str.len() + offset.width() >\n+                context.config.comment_width()\n+        {\n             result.push('\\n');\n             let width = offset.block_indent + context.config.tab_spaces() - 1;\n             let where_indent = Indent::new(0, width);\n@@ -906,7 +947,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             BraceStyle::PreferSameLine => result.push(' '),\n             BraceStyle::SameLineWhere => {\n                 if !where_clause_str.is_empty() &&\n-                   (!trait_items.is_empty() || result.contains('\\n')) {\n+                    (!trait_items.is_empty() || result.contains('\\n'))\n+                {\n                     result.push('\\n');\n                     result.push_str(&offset.to_string(context.config));\n                 } else {\n@@ -953,16 +995,17 @@ fn format_unit_struct(item_name: &str, ident: ast::Ident, vis: &ast::Visibility)\n     format!(\"{};\", format_header(item_name, ident, vis))\n }\n \n-fn format_struct_struct(context: &RewriteContext,\n-                        item_name: &str,\n-                        ident: ast::Ident,\n-                        vis: &ast::Visibility,\n-                        fields: &[ast::StructField],\n-                        generics: Option<&ast::Generics>,\n-                        span: Span,\n-                        offset: Indent,\n-                        one_line_width: Option<usize>)\n-                        -> Option<String> {\n+fn format_struct_struct(\n+    context: &RewriteContext,\n+    item_name: &str,\n+    ident: ast::Ident,\n+    vis: &ast::Visibility,\n+    fields: &[ast::StructField],\n+    generics: Option<&ast::Generics>,\n+    span: Span,\n+    offset: Indent,\n+    one_line_width: Option<usize>,\n+) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n \n     let header_str = format_header(item_name, ident, vis);\n@@ -972,18 +1015,21 @@ fn format_struct_struct(context: &RewriteContext,\n \n     let generics_str = match generics {\n         Some(g) => {\n-            try_opt!(format_generics(context,\n-                                     g,\n-                                     \"{\",\n-                                     \"{\",\n-                                     context.config.item_brace_style(),\n-                                     fields.is_empty(),\n-                                     offset,\n-                                     mk_sp(span.lo, body_lo)))\n+            try_opt!(format_generics(\n+                context,\n+                g,\n+                \"{\",\n+                \"{\",\n+                context.config.item_brace_style(),\n+                fields.is_empty(),\n+                offset,\n+                mk_sp(span.lo, body_lo),\n+            ))\n         }\n         None => {\n             if context.config.item_brace_style() == BraceStyle::AlwaysNextLine &&\n-               !fields.is_empty() {\n+                !fields.is_empty()\n+            {\n                 format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n                 \" {\".to_owned()\n@@ -1010,28 +1056,27 @@ fn format_struct_struct(context: &RewriteContext,\n \n     let item_indent = offset.block_indent(context.config);\n     // 1 = \",\"\n-    let item_budget = try_opt!(context\n-                                   .config\n-                                   .max_width()\n-                                   .checked_sub(item_indent.width() + 1));\n-\n-    let items =\n-        itemize_list(context.codemap,\n-                     fields.iter(),\n-                     \"}\",\n-                     |field| {\n-                         // Include attributes and doc comments, if present\n-                         if !field.attrs.is_empty() {\n-                             field.attrs[0].span.lo\n-                         } else {\n-                             field.span.lo\n-                         }\n-                     },\n-                     |field| field.ty.span.hi,\n-                     |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n-                     context.codemap.span_after(span, \"{\"),\n-                     span.hi)\n-            .collect::<Vec<_>>();\n+    let item_budget = try_opt!(context.config.max_width().checked_sub(\n+        item_indent.width() + 1,\n+    ));\n+\n+    let items = itemize_list(\n+        context.codemap,\n+        fields.iter(),\n+        \"}\",\n+        |field| {\n+            // Include attributes and doc comments, if present\n+            if !field.attrs.is_empty() {\n+                field.attrs[0].span.lo\n+            } else {\n+                field.span.lo\n+            }\n+        },\n+        |field| field.ty.span.hi,\n+        |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n+        context.codemap.span_after(span, \"{\"),\n+        span.hi,\n+    ).collect::<Vec<_>>();\n     // 1 = ,\n     let budget = context.config.max_width() - offset.width() + context.config.tab_spaces() - 1;\n \n@@ -1052,25 +1097,28 @@ fn format_struct_struct(context: &RewriteContext,\n     if one_line_width.is_some() && !items_str.contains('\\n') {\n         Some(format!(\"{} {} }}\", result, items_str))\n     } else {\n-        Some(format!(\"{}\\n{}{}\\n{}}}\",\n-                     result,\n-                     offset\n-                         .block_indent(context.config)\n-                         .to_string(context.config),\n-                     items_str,\n-                     offset.to_string(context.config)))\n+        Some(format!(\n+            \"{}\\n{}{}\\n{}}}\",\n+            result,\n+            offset.block_indent(context.config).to_string(\n+                context.config,\n+            ),\n+            items_str,\n+            offset.to_string(context.config)\n+        ))\n     }\n }\n \n-fn format_tuple_struct(context: &RewriteContext,\n-                       item_name: &str,\n-                       ident: ast::Ident,\n-                       vis: &ast::Visibility,\n-                       fields: &[ast::StructField],\n-                       generics: Option<&ast::Generics>,\n-                       span: Span,\n-                       offset: Indent)\n-                       -> Option<String> {\n+fn format_tuple_struct(\n+    context: &RewriteContext,\n+    item_name: &str,\n+    ident: ast::Ident,\n+    vis: &ast::Visibility,\n+    fields: &[ast::StructField],\n+    generics: Option<&ast::Generics>,\n+    span: Span,\n+    offset: Indent,\n+) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n \n     let header_str = format_header(item_name, ident, vis);\n@@ -1089,19 +1137,20 @@ fn format_tuple_struct(context: &RewriteContext,\n             let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n             result.push_str(&generics_str);\n \n-            let where_budget = try_opt!(context\n-                                            .config\n-                                            .max_width()\n-                                            .checked_sub(last_line_width(&result)));\n-            try_opt!(rewrite_where_clause(context,\n-                                          &generics.where_clause,\n-                                          context.config.item_brace_style(),\n-                                          Shape::legacy(where_budget, offset.block_only()),\n-                                          Density::Compressed,\n-                                          \";\",\n-                                          true,\n-                                          false,\n-                                          None))\n+            let where_budget = try_opt!(context.config.max_width().checked_sub(\n+                last_line_width(&result),\n+            ));\n+            try_opt!(rewrite_where_clause(\n+                context,\n+                &generics.where_clause,\n+                context.config.item_brace_style(),\n+                Shape::legacy(where_budget, offset.block_only()),\n+                Density::Compressed,\n+                \";\",\n+                true,\n+                false,\n+                None,\n+            ))\n         }\n         None => \"\".to_owned(),\n     };\n@@ -1123,44 +1172,51 @@ fn format_tuple_struct(context: &RewriteContext,\n         let (tactic, item_indent) = match context.config.fn_args_layout() {\n             IndentStyle::Visual => {\n                 // 1 = `(`\n-                (ListTactic::HorizontalVertical, offset.block_only() + result.len() + 1)\n+                (\n+                    ListTactic::HorizontalVertical,\n+                    offset.block_only() + result.len() + 1,\n+                )\n             }\n             IndentStyle::Block => {\n-                (ListTactic::HorizontalVertical, offset.block_only().block_indent(&context.config))\n+                (\n+                    ListTactic::HorizontalVertical,\n+                    offset.block_only().block_indent(&context.config),\n+                )\n             }\n         };\n         // 3 = `();`\n-        let item_budget = try_opt!(context\n-                                       .config\n-                                       .max_width()\n-                                       .checked_sub(item_indent.width() + 3));\n-\n-        let items =\n-            itemize_list(context.codemap,\n-                         fields.iter(),\n-                         \")\",\n-                         |field| {\n-                             // Include attributes and doc comments, if present\n-                             if !field.attrs.is_empty() {\n-                                 field.attrs[0].span.lo\n-                             } else {\n-                                 field.span.lo\n-                             }\n-                         },\n-                         |field| field.ty.span.hi,\n-                         |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n-                         context.codemap.span_after(span, \"(\"),\n-                         span.hi);\n-        let body_budget =\n-            try_opt!(context\n-                         .config\n-                         .max_width()\n-                         .checked_sub(offset.block_only().width() + result.len() + 3));\n-        let body = try_opt!(list_helper(items,\n-                                        // TODO budget is wrong in block case\n-                                        Shape::legacy(body_budget, item_indent),\n-                                        context.config,\n-                                        tactic));\n+        let item_budget = try_opt!(context.config.max_width().checked_sub(\n+            item_indent.width() + 3,\n+        ));\n+\n+        let items = itemize_list(\n+            context.codemap,\n+            fields.iter(),\n+            \")\",\n+            |field| {\n+                // Include attributes and doc comments, if present\n+                if !field.attrs.is_empty() {\n+                    field.attrs[0].span.lo\n+                } else {\n+                    field.span.lo\n+                }\n+            },\n+            |field| field.ty.span.hi,\n+            |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n+            context.codemap.span_after(span, \"(\"),\n+            span.hi,\n+        );\n+        let body_budget = try_opt!(context.config.max_width().checked_sub(\n+            offset.block_only().width() +\n+                result.len() + 3,\n+        ));\n+        let body = try_opt!(list_helper(\n+            items,\n+            // TODO budget is wrong in block case\n+            Shape::legacy(body_budget, item_indent),\n+            context.config,\n+            tactic,\n+        ));\n \n         if context.config.fn_args_layout() == IndentStyle::Visual || !body.contains('\\n') {\n             result.push('(');\n@@ -1185,28 +1241,30 @@ fn format_tuple_struct(context: &RewriteContext,\n     }\n \n     if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') &&\n-       (result.contains('\\n') ||\n-        offset.block_indent + result.len() + where_clause_str.len() + 1 >\n-        context.config.max_width()) {\n+        (result.contains('\\n') ||\n+             offset.block_indent + result.len() + where_clause_str.len() + 1 >\n+                 context.config.max_width())\n+    {\n         // We need to put the where clause on a new line, but we didn't\n         // know that earlier, so the where clause will not be indented properly.\n         result.push('\\n');\n         result.push_str(&(offset.block_only() + (context.config.tab_spaces() - 1))\n-                            .to_string(context.config));\n+            .to_string(context.config));\n     }\n     result.push_str(&where_clause_str);\n \n     Some(result)\n }\n \n-pub fn rewrite_type_alias(context: &RewriteContext,\n-                          indent: Indent,\n-                          ident: ast::Ident,\n-                          ty: &ast::Ty,\n-                          generics: &ast::Generics,\n-                          vis: &ast::Visibility,\n-                          span: Span)\n-                          -> Option<String> {\n+pub fn rewrite_type_alias(\n+    context: &RewriteContext,\n+    indent: Indent,\n+    ident: ast::Ident,\n+    ty: &ast::Ty,\n+    generics: &ast::Generics,\n+    vis: &ast::Visibility,\n+    span: Span,\n+) -> Option<String> {\n     let mut result = String::new();\n \n     result.push_str(&format_visibility(vis));\n@@ -1219,19 +1277,20 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n-    let where_budget = try_opt!(context\n-                                    .config\n-                                    .max_width()\n-                                    .checked_sub(last_line_width(&result)));\n-    let where_clause_str = try_opt!(rewrite_where_clause(context,\n-                                                         &generics.where_clause,\n-                                                         context.config.item_brace_style(),\n-                                                         Shape::legacy(where_budget, indent),\n-                                                         context.config.where_density(),\n-                                                         \"=\",\n-                                                         true,\n-                                                         true,\n-                                                         Some(span.hi)));\n+    let where_budget = try_opt!(context.config.max_width().checked_sub(\n+        last_line_width(&result),\n+    ));\n+    let where_clause_str = try_opt!(rewrite_where_clause(\n+        context,\n+        &generics.where_clause,\n+        context.config.item_brace_style(),\n+        Shape::legacy(where_budget, indent),\n+        context.config.where_density(),\n+        \"=\",\n+        true,\n+        true,\n+        Some(span.hi),\n+    ));\n     result.push_str(&where_clause_str);\n     result.push_str(\" = \");\n \n@@ -1255,10 +1314,9 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n                 let type_indent = indent.block_indent(context.config);\n                 result.push('\\n');\n                 result.push_str(&type_indent.to_string(context.config));\n-                let budget = try_opt!(context\n-                                          .config\n-                                          .max_width()\n-                                          .checked_sub(type_indent.width() + \";\".len()));\n+                let budget = try_opt!(context.config.max_width().checked_sub(\n+                    type_indent.width() + \";\".len(),\n+                ));\n                 ty.rewrite(context, Shape::legacy(budget, type_indent))\n             })\n     );\n@@ -1268,24 +1326,27 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n }\n \n fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n-    (if config.space_before_type_annotation() {\n-         \" \"\n-     } else {\n-         \"\"\n-     },\n-     if config.space_after_type_annotation_colon() {\n-         \" \"\n-     } else {\n-         \"\"\n-     })\n+    (\n+        if config.space_before_type_annotation() {\n+            \" \"\n+        } else {\n+            \"\"\n+        },\n+        if config.space_after_type_annotation_colon() {\n+            \" \"\n+        } else {\n+            \"\"\n+        },\n+    )\n }\n \n-fn rewrite_missing_comment_on_field(context: &RewriteContext,\n-                                    shape: Shape,\n-                                    lo: BytePos,\n-                                    hi: BytePos,\n-                                    result: &mut String)\n-                                    -> Option<String> {\n+fn rewrite_missing_comment_on_field(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    lo: BytePos,\n+    hi: BytePos,\n+    result: &mut String,\n+) -> Option<String> {\n     let possibly_comment_snippet = context.snippet(mk_sp(lo, hi));\n     let newline_index = possibly_comment_snippet.find('\\n');\n     let comment_index = possibly_comment_snippet.find('/');\n@@ -1300,8 +1361,9 @@ fn rewrite_missing_comment_on_field(context: &RewriteContext,\n     if trimmed.is_empty() {\n         None\n     } else {\n-        rewrite_comment(trimmed, false, shape, context.config)\n-            .map(|s| format!(\"{}\\n{}\", s, shape.indent.to_string(context.config)))\n+        rewrite_comment(trimmed, false, shape, context.config).map(|s| {\n+            format!(\"{}\\n{}\", s, shape.indent.to_string(context.config))\n+        })\n     }\n }\n \n@@ -1314,56 +1376,65 @@ impl Rewrite for ast::StructField {\n \n         let name = self.ident;\n         let vis = format_visibility(&self.vis);\n-        let mut attr_str = try_opt!(self.attrs.rewrite(context,\n-                                                       Shape::indented(shape.indent,\n-                                                                       context.config)));\n+        let mut attr_str = try_opt!(self.attrs.rewrite(\n+            context,\n+            Shape::indented(shape.indent, context.config),\n+        ));\n         // Try format missing comments after attributes\n         let missing_comment = if !self.attrs.is_empty() {\n-            rewrite_missing_comment_on_field(context,\n-                                             shape,\n-                                             self.attrs[self.attrs.len() - 1].span.hi,\n-                                             self.span.lo,\n-                                             &mut attr_str)\n-                .unwrap_or(String::new())\n+            rewrite_missing_comment_on_field(\n+                context,\n+                shape,\n+                self.attrs[self.attrs.len() - 1].span.hi,\n+                self.span.lo,\n+                &mut attr_str,\n+            ).unwrap_or(String::new())\n         } else {\n             String::new()\n         };\n \n         let type_annotation_spacing = type_annotation_spacing(context.config);\n         let mut result = match name {\n             Some(name) => {\n-                format!(\"{}{}{}{}{}:\",\n-                        attr_str,\n-                        missing_comment,\n-                        vis,\n-                        name,\n-                        type_annotation_spacing.0)\n+                format!(\n+                    \"{}{}{}{}{}:\",\n+                    attr_str,\n+                    missing_comment,\n+                    vis,\n+                    name,\n+                    type_annotation_spacing.0\n+                )\n             }\n             None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n         };\n \n         let type_offset = shape.indent.block_indent(context.config);\n         let rewrite_type_in_next_line = || {\n-            self.ty\n-                .rewrite(context, Shape::indented(type_offset, context.config))\n+            self.ty.rewrite(\n+                context,\n+                Shape::indented(type_offset, context.config),\n+            )\n         };\n \n         let last_line_width = last_line_width(&result) + type_annotation_spacing.1.len();\n         let budget = try_opt!(shape.width.checked_sub(last_line_width));\n-        let ty_rewritten =\n-            self.ty.rewrite(context,\n-                            Shape::legacy(budget, shape.indent + last_line_width));\n+        let ty_rewritten = self.ty.rewrite(\n+            context,\n+            Shape::legacy(budget, shape.indent + last_line_width),\n+        );\n         match ty_rewritten {\n             Some(ref ty) if ty.contains('\\n') => {\n                 let new_ty = rewrite_type_in_next_line();\n                 match new_ty {\n                     Some(ref new_ty) if !new_ty.contains('\\n') &&\n-                                        new_ty.len() + type_offset.width() <=\n-                                        context.config.max_width() => {\n-                        Some(format!(\"{}\\n{}{}\",\n-                                     result,\n-                                     type_offset.to_string(&context.config),\n-                                     &new_ty))\n+                                            new_ty.len() + type_offset.width() <=\n+                                                context.config.max_width() => {\n+                        Some(format!(\n+                            \"{}\\n{}{}\",\n+                            result,\n+                            type_offset.to_string(&context.config),\n+                            &new_ty\n+                        ))\n                     }\n                     _ => {\n                         if name.is_some() {\n@@ -1381,72 +1452,83 @@ impl Rewrite for ast::StructField {\n             }\n             None => {\n                 let ty = try_opt!(rewrite_type_in_next_line());\n-                Some(format!(\"{}\\n{}{}\",\n-                             result,\n-                             type_offset.to_string(&context.config),\n-                             &ty))\n+                Some(format!(\n+                    \"{}\\n{}{}\",\n+                    result,\n+                    type_offset.to_string(&context.config),\n+                    &ty\n+                ))\n             }\n         }\n     }\n }\n \n-pub fn rewrite_static(prefix: &str,\n-                      vis: &ast::Visibility,\n-                      ident: ast::Ident,\n-                      ty: &ast::Ty,\n-                      mutability: ast::Mutability,\n-                      expr_opt: Option<&ptr::P<ast::Expr>>,\n-                      offset: Indent,\n-                      span: Span,\n-                      context: &RewriteContext)\n-                      -> Option<String> {\n+pub fn rewrite_static(\n+    prefix: &str,\n+    vis: &ast::Visibility,\n+    ident: ast::Ident,\n+    ty: &ast::Ty,\n+    mutability: ast::Mutability,\n+    expr_opt: Option<&ptr::P<ast::Expr>>,\n+    offset: Indent,\n+    span: Span,\n+    context: &RewriteContext,\n+) -> Option<String> {\n     let type_annotation_spacing = type_annotation_spacing(context.config);\n-    let prefix = format!(\"{}{} {}{}{}:{}\",\n-                         format_visibility(vis),\n-                         prefix,\n-                         format_mutability(mutability),\n-                         ident,\n-                         type_annotation_spacing.0,\n-                         type_annotation_spacing.1);\n+    let prefix = format!(\n+        \"{}{} {}{}{}:{}\",\n+        format_visibility(vis),\n+        prefix,\n+        format_mutability(mutability),\n+        ident,\n+        type_annotation_spacing.0,\n+        type_annotation_spacing.1\n+    );\n     // 2 = \" =\".len()\n-    let ty_str = try_opt!(ty.rewrite(context,\n-                                     Shape::legacy(context.config.max_width() -\n-                                                   offset.block_indent -\n-                                                   prefix.len() -\n-                                                   2,\n-                                                   offset.block_only())));\n+    let ty_str = try_opt!(ty.rewrite(\n+        context,\n+        Shape::legacy(\n+            context.config.max_width() - offset.block_indent -\n+                prefix.len() - 2,\n+            offset.block_only(),\n+        ),\n+    ));\n \n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n         let remaining_width = context.config.max_width() - offset.block_indent - 1;\n-        rewrite_assign_rhs(context,\n-                           lhs,\n-                           expr,\n-                           Shape::legacy(remaining_width, offset.block_only()))\n-            .and_then(|res| {\n-                recover_comment_removed(res,\n-                                        span,\n-                                        context,\n-                                        Shape {\n-                                            width: context.config.max_width(),\n-                                            indent: offset,\n-                                            offset: offset.alignment,\n-                                        })\n-            })\n+        rewrite_assign_rhs(\n+            context,\n+            lhs,\n+            expr,\n+            Shape::legacy(remaining_width, offset.block_only()),\n+        ).and_then(|res| {\n+            recover_comment_removed(\n+                res,\n+                span,\n+                context,\n+                Shape {\n+                    width: context.config.max_width(),\n+                    indent: offset,\n+                    offset: offset.alignment,\n+                },\n+            )\n+        })\n             .map(|s| if s.ends_with(';') { s } else { s + \";\" })\n     } else {\n         let lhs = format!(\"{}{};\", prefix, ty_str);\n         Some(lhs)\n     }\n }\n \n-pub fn rewrite_associated_type(ident: ast::Ident,\n-                               ty_opt: Option<&ptr::P<ast::Ty>>,\n-                               ty_param_bounds_opt: Option<&ast::TyParamBounds>,\n-                               context: &RewriteContext,\n-                               indent: Indent)\n-                               -> Option<String> {\n+pub fn rewrite_associated_type(\n+    ident: ast::Ident,\n+    ty_opt: Option<&ptr::P<ast::Ty>>,\n+    ty_param_bounds_opt: Option<&ast::TyParamBounds>,\n+    context: &RewriteContext,\n+    indent: Indent,\n+) -> Option<String> {\n     let prefix = format!(\"type {}\", ident);\n \n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n@@ -1466,27 +1548,35 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n     };\n \n     if let Some(ty) = ty_opt {\n-        let ty_str = try_opt!(ty.rewrite(context,\n-                                         Shape::legacy(context.config.max_width() -\n-                                                       indent.block_indent -\n-                                                       prefix.len() -\n-                                                       2,\n-                                                       indent.block_only())));\n+        let ty_str = try_opt!(ty.rewrite(\n+            context,\n+            Shape::legacy(\n+                context.config.max_width() - indent.block_indent -\n+                    prefix.len() - 2,\n+                indent.block_only(),\n+            ),\n+        ));\n         Some(format!(\"{} = {};\", prefix, ty_str))\n     } else {\n         Some(format!(\"{}{};\", prefix, type_bounds_str))\n     }\n }\n \n-pub fn rewrite_associated_impl_type(ident: ast::Ident,\n-                                    defaultness: ast::Defaultness,\n-                                    ty_opt: Option<&ptr::P<ast::Ty>>,\n-                                    ty_param_bounds_opt: Option<&ast::TyParamBounds>,\n-                                    context: &RewriteContext,\n-                                    indent: Indent)\n-                                    -> Option<String> {\n-    let result =\n-        try_opt!(rewrite_associated_type(ident, ty_opt, ty_param_bounds_opt, context, indent));\n+pub fn rewrite_associated_impl_type(\n+    ident: ast::Ident,\n+    defaultness: ast::Defaultness,\n+    ty_opt: Option<&ptr::P<ast::Ty>>,\n+    ty_param_bounds_opt: Option<&ast::TyParamBounds>,\n+    context: &RewriteContext,\n+    indent: Indent,\n+) -> Option<String> {\n+    let result = try_opt!(rewrite_associated_type(\n+        ident,\n+        ty_opt,\n+        ty_param_bounds_opt,\n+        context,\n+        indent,\n+    ));\n \n     match defaultness {\n         ast::Defaultness::Default => Some(format!(\"default {}\", result)),\n@@ -1510,8 +1600,10 @@ impl Rewrite for ast::FunctionRetTy {\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n-            let mut result = try_opt!(self.pat.rewrite(context,\n-                                                       Shape::legacy(shape.width, shape.indent)));\n+            let mut result = try_opt!(self.pat.rewrite(\n+                context,\n+                Shape::legacy(shape.width, shape.indent),\n+            ));\n \n             if self.ty.node != ast::TyKind::Infer {\n                 if context.config.space_before_type_annotation() {\n@@ -1522,9 +1614,10 @@ impl Rewrite for ast::Arg {\n                     result.push_str(\" \");\n                 }\n                 let max_width = try_opt!(shape.width.checked_sub(result.len()));\n-                let ty_str = try_opt!(self.ty.rewrite(context,\n-                                                      Shape::legacy(max_width,\n-                                                                    shape.indent + result.len())));\n+                let ty_str = try_opt!(self.ty.rewrite(\n+                    context,\n+                    Shape::legacy(max_width, shape.indent + result.len()),\n+                ));\n                 result.push_str(&ty_str);\n             }\n \n@@ -1535,18 +1628,20 @@ impl Rewrite for ast::Arg {\n     }\n }\n \n-fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n-                         args: &[ast::Arg],\n-                         context: &RewriteContext)\n-                         -> Option<String> {\n+fn rewrite_explicit_self(\n+    explicit_self: &ast::ExplicitSelf,\n+    args: &[ast::Arg],\n+    context: &RewriteContext,\n+) -> Option<String> {\n     match explicit_self.node {\n         ast::SelfKind::Region(lt, m) => {\n             let mut_str = format_mutability(m);\n             match lt {\n                 Some(ref l) => {\n-                    let lifetime_str = try_opt!(l.rewrite(context,\n-                                                          Shape::legacy(usize::max_value(),\n-                                                                        Indent::empty())));\n+                    let lifetime_str = try_opt!(l.rewrite(\n+                        context,\n+                        Shape::legacy(usize::max_value(), Indent::empty()),\n+                    ));\n                     Some(format!(\"&{} {}self\", lifetime_str, mut_str))\n                 }\n                 None => Some(format!(\"&{}self\", mut_str)),\n@@ -1556,10 +1651,16 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n-            let type_str = try_opt!(ty.rewrite(context,\n-                                               Shape::legacy(usize::max_value(), Indent::empty())));\n-\n-            Some(format!(\"{}self: {}\", format_mutability(mutability), type_str))\n+            let type_str = try_opt!(ty.rewrite(\n+                context,\n+                Shape::legacy(usize::max_value(), Indent::empty()),\n+            ));\n+\n+            Some(format!(\n+                \"{}self: {}\",\n+                format_mutability(mutability),\n+                type_str\n+            ))\n         }\n         ast::SelfKind::Value(_) => {\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n@@ -1640,21 +1741,22 @@ fn span_for_where_pred(pred: &ast::WherePredicate) -> Span {\n }\n \n // Return type is (result, force_new_line_for_brace)\n-fn rewrite_fn_base(context: &RewriteContext,\n-                   indent: Indent,\n-                   ident: ast::Ident,\n-                   fd: &ast::FnDecl,\n-                   generics: &ast::Generics,\n-                   unsafety: ast::Unsafety,\n-                   constness: ast::Constness,\n-                   defaultness: ast::Defaultness,\n-                   abi: abi::Abi,\n-                   vis: &ast::Visibility,\n-                   span: Span,\n-                   newline_brace: bool,\n-                   has_body: bool,\n-                   has_braces: bool)\n-                   -> Option<(String, bool)> {\n+fn rewrite_fn_base(\n+    context: &RewriteContext,\n+    indent: Indent,\n+    ident: ast::Ident,\n+    fd: &ast::FnDecl,\n+    generics: &ast::Generics,\n+    unsafety: ast::Unsafety,\n+    constness: ast::Constness,\n+    defaultness: ast::Defaultness,\n+    abi: abi::Abi,\n+    vis: &ast::Visibility,\n+    span: Span,\n+    newline_brace: bool,\n+    has_body: bool,\n+    has_braces: bool,\n+) -> Option<(String, bool)> {\n     let mut force_new_line_for_brace = false;\n \n     let where_clause = &generics.where_clause;\n@@ -1674,7 +1776,10 @@ fn rewrite_fn_base(context: &RewriteContext,\n     result.push_str(::utils::format_unsafety(unsafety));\n \n     if abi != abi::Abi::Rust {\n-        result.push_str(&::utils::format_abi(abi, context.config.force_explicit_abi()));\n+        result.push_str(&::utils::format_abi(\n+            abi,\n+            context.config.force_explicit_abi(),\n+        ));\n     }\n \n     // fn foo\n@@ -1687,37 +1792,43 @@ fn rewrite_fn_base(context: &RewriteContext,\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n-    let snuggle_angle_bracket = generics_str\n-        .lines()\n-        .last()\n-        .map_or(false, |l| l.trim_left().len() == 1);\n+    let snuggle_angle_bracket = generics_str.lines().last().map_or(\n+        false,\n+        |l| l.trim_left().len() == 1,\n+    );\n \n     // Note that the width and indent don't really matter, we'll re-layout the\n     // return type later anyway.\n-    let ret_str = try_opt!(fd.output\n-                               .rewrite(&context, Shape::indented(indent, context.config)));\n+    let ret_str = try_opt!(fd.output.rewrite(\n+        &context,\n+        Shape::indented(indent, context.config),\n+    ));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n \n     // Args.\n     let (mut one_line_budget, mut multi_line_budget, mut arg_indent) =\n-        try_opt!(compute_budgets_for_args(context,\n-                                          &result,\n-                                          indent,\n-                                          ret_str_len,\n-                                          newline_brace,\n-                                          has_braces));\n+        try_opt!(compute_budgets_for_args(\n+            context,\n+            &result,\n+            indent,\n+            ret_str_len,\n+            newline_brace,\n+            has_braces,\n+        ));\n \n     if context.config.fn_args_layout() == IndentStyle::Block {\n         arg_indent = indent.block_indent(context.config);\n         multi_line_budget = context.config.max_width() - arg_indent.width();\n     }\n \n-    debug!(\"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n-           one_line_budget,\n-           multi_line_budget,\n-           arg_indent);\n+    debug!(\n+        \"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n+        one_line_budget,\n+        multi_line_budget,\n+        arg_indent\n+    );\n \n     // Check if vertical layout was forced.\n     if one_line_budget == 0 {\n@@ -1751,25 +1862,29 @@ fn rewrite_fn_base(context: &RewriteContext,\n     }\n \n     // A conservative estimation, to goal is to be over all parens in generics\n-    let args_start = generics\n-        .ty_params\n-        .last()\n-        .map_or(span.lo, |tp| end_typaram(tp));\n-    let args_span = mk_sp(context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n-                          span_for_return(&fd.output).lo);\n-    let arg_str = try_opt!(rewrite_args(context,\n-                                        &fd.inputs,\n-                                        fd.get_self().as_ref(),\n-                                        one_line_budget,\n-                                        multi_line_budget,\n-                                        indent,\n-                                        arg_indent,\n-                                        args_span,\n-                                        fd.variadic,\n-                                        generics_str.contains('\\n')));\n+    let args_start = generics.ty_params.last().map_or(\n+        span.lo,\n+        |tp| end_typaram(tp),\n+    );\n+    let args_span = mk_sp(\n+        context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n+        span_for_return(&fd.output).lo,\n+    );\n+    let arg_str = try_opt!(rewrite_args(\n+        context,\n+        &fd.inputs,\n+        fd.get_self().as_ref(),\n+        one_line_budget,\n+        multi_line_budget,\n+        indent,\n+        arg_indent,\n+        args_span,\n+        fd.variadic,\n+        generics_str.contains('\\n'),\n+    ));\n \n     let multi_line_arg_str = arg_str.contains('\\n') ||\n-                             arg_str.chars().last().map_or(false, |c| c == ',');\n+        arg_str.chars().last().map_or(false, |c| c == ',');\n \n     let put_args_in_block = match context.config.fn_args_layout() {\n         IndentStyle::Block => multi_line_arg_str || generics_str.contains('\\n'),\n@@ -1792,10 +1907,10 @@ fn rewrite_fn_base(context: &RewriteContext,\n         }\n         // If the last line of args contains comment, we cannot put the closing paren\n         // on the same line.\n-        if arg_str\n-               .lines()\n-               .last()\n-               .map_or(false, |last_line| last_line.contains(\"//\")) {\n+        if arg_str.lines().last().map_or(false, |last_line| {\n+            last_line.contains(\"//\")\n+        })\n+        {\n             args_last_line_contains_comment = true;\n             result.push('\\n');\n             result.push_str(&arg_indent.to_string(context.config));\n@@ -1824,7 +1939,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n                 let overlong_sig = sig_length > context.config.max_width();\n \n                 (!args_last_line_contains_comment) &&\n-                (result.contains('\\n') || multi_line_ret_str || overlong_sig)\n+                    (result.contains('\\n') || multi_line_ret_str || overlong_sig)\n             }\n         };\n         let ret_indent = if ret_should_indent {\n@@ -1852,8 +1967,10 @@ fn rewrite_fn_base(context: &RewriteContext,\n         if multi_line_ret_str || ret_should_indent {\n             // Now that we know the proper indent and width, we need to\n             // re-layout the return type.\n-            let ret_str = try_opt!(fd.output.rewrite(context,\n-                                                     Shape::indented(ret_indent, context.config)));\n+            let ret_str = try_opt!(fd.output.rewrite(\n+                context,\n+                Shape::indented(ret_indent, context.config),\n+            ));\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -1865,20 +1982,21 @@ fn rewrite_fn_base(context: &RewriteContext,\n             let snippet_hi = span.hi;\n             let snippet = context.snippet(mk_sp(snippet_lo, snippet_hi));\n             // Try to preserve the layout of the original snippet.\n-            let original_starts_with_newline =\n-                snippet\n-                    .find(|c| c != ' ')\n-                    .map_or(false, |i| snippet[i..].starts_with('\\n'));\n-            let original_ends_with_newline = snippet\n-                .rfind(|c| c != ' ')\n-                .map_or(false, |i| snippet[i..].ends_with('\\n'));\n+            let original_starts_with_newline = snippet.find(|c| c != ' ').map_or(false, |i| {\n+                snippet[i..].starts_with('\\n')\n+            });\n+            let original_ends_with_newline = snippet.rfind(|c| c != ' ').map_or(false, |i| {\n+                snippet[i..].ends_with('\\n')\n+            });\n             let snippet = snippet.trim();\n             if !snippet.is_empty() {\n-                result.push(if original_starts_with_newline {\n-                                '\\n'\n-                            } else {\n-                                ' '\n-                            });\n+                result.push(\n+                    if original_starts_with_newline {\n+                        '\\n'\n+                    } else {\n+                        ' '\n+                    },\n+                );\n                 result.push_str(snippet);\n                 if original_ends_with_newline {\n                     force_new_line_for_brace = true;\n@@ -1898,20 +2016,22 @@ fn rewrite_fn_base(context: &RewriteContext,\n     } || (put_args_in_block && ret_str.is_empty());\n \n     if where_clause.predicates.len() == 1 && should_compress_where {\n-        let budget = try_opt!(context\n-                                  .config\n-                                  .max_width()\n-                                  .checked_sub(last_line_width(&result)));\n+        let budget = try_opt!(context.config.max_width().checked_sub(\n+            last_line_width(&result),\n+        ));\n         if let Some(where_clause_str) =\n-            rewrite_where_clause(context,\n-                                 where_clause,\n-                                 context.config.fn_brace_style(),\n-                                 Shape::legacy(budget, indent),\n-                                 Density::Compressed,\n-                                 \"{\",\n-                                 !has_braces,\n-                                 put_args_in_block && ret_str.is_empty(),\n-                                 Some(span.hi)) {\n+            rewrite_where_clause(\n+                context,\n+                where_clause,\n+                context.config.fn_brace_style(),\n+                Shape::legacy(budget, indent),\n+                Density::Compressed,\n+                \"{\",\n+                !has_braces,\n+                put_args_in_block && ret_str.is_empty(),\n+                Some(span.hi),\n+            )\n+        {\n             if !where_clause_str.contains('\\n') {\n                 if last_line_width(&result) + where_clause_str.len() > context.config.max_width() {\n                     result.push('\\n');\n@@ -1925,15 +2045,17 @@ fn rewrite_fn_base(context: &RewriteContext,\n         }\n     }\n \n-    let where_clause_str = try_opt!(rewrite_where_clause(context,\n-                                                         where_clause,\n-                                                         context.config.fn_brace_style(),\n-                                                         Shape::indented(indent, context.config),\n-                                                         Density::Tall,\n-                                                         \"{\",\n-                                                         !has_braces,\n-                                                         put_args_in_block && ret_str.is_empty(),\n-                                                         Some(span.hi)));\n+    let where_clause_str = try_opt!(rewrite_where_clause(\n+        context,\n+        where_clause,\n+        context.config.fn_brace_style(),\n+        Shape::indented(indent, context.config),\n+        Density::Tall,\n+        \"{\",\n+        !has_braces,\n+        put_args_in_block && ret_str.is_empty(),\n+        Some(span.hi),\n+    ));\n \n     result.push_str(&where_clause_str);\n \n@@ -1945,27 +2067,33 @@ fn last_line_contains_single_line_comment(s: &str) -> bool {\n     s.lines().last().map_or(false, |l| l.contains(\"//\"))\n }\n \n-fn rewrite_args(context: &RewriteContext,\n-                args: &[ast::Arg],\n-                explicit_self: Option<&ast::ExplicitSelf>,\n-                one_line_budget: usize,\n-                multi_line_budget: usize,\n-                indent: Indent,\n-                arg_indent: Indent,\n-                span: Span,\n-                variadic: bool,\n-                generics_str_contains_newline: bool)\n-                -> Option<String> {\n-    let mut arg_item_strs =\n-        try_opt!(args.iter()\n-                     .map(|arg| arg.rewrite(&context, Shape::legacy(multi_line_budget, arg_indent)))\n-                     .collect::<Option<Vec<_>>>());\n+fn rewrite_args(\n+    context: &RewriteContext,\n+    args: &[ast::Arg],\n+    explicit_self: Option<&ast::ExplicitSelf>,\n+    one_line_budget: usize,\n+    multi_line_budget: usize,\n+    indent: Indent,\n+    arg_indent: Indent,\n+    span: Span,\n+    variadic: bool,\n+    generics_str_contains_newline: bool,\n+) -> Option<String> {\n+    let mut arg_item_strs = try_opt!(\n+        args.iter()\n+            .map(|arg| {\n+                arg.rewrite(&context, Shape::legacy(multi_line_budget, arg_indent))\n+            })\n+            .collect::<Option<Vec<_>>>()\n+    );\n \n     // Account for sugary self.\n     // FIXME: the comment for the self argument is dropped. This is blocked\n     // on rust issue #27522.\n     let min_args = explicit_self\n-        .and_then(|explicit_self| rewrite_explicit_self(explicit_self, args, context))\n+        .and_then(|explicit_self| {\n+            rewrite_explicit_self(explicit_self, args, context)\n+        })\n         .map_or(1, |self_str| {\n             arg_item_strs[0] = self_str;\n             2\n@@ -2008,33 +2136,34 @@ fn rewrite_args(context: &RewriteContext,\n             None\n         };\n \n-        let more_items = itemize_list(context.codemap,\n-                                      args[min_args - 1..]\n-                                          .iter()\n-                                          .map(ArgumentKind::Regular)\n-                                          .chain(variadic_arg),\n-                                      \")\",\n-                                      |arg| match *arg {\n-                                          ArgumentKind::Regular(arg) => span_lo_for_arg(arg),\n-                                          ArgumentKind::Variadic(start) => start,\n-                                      },\n-                                      |arg| match *arg {\n-                                          ArgumentKind::Regular(arg) => arg.ty.span.hi,\n-                                          ArgumentKind::Variadic(start) => start + BytePos(3),\n-                                      },\n-                                      |arg| match *arg {\n-                                          ArgumentKind::Regular(..) => None,\n-                                          ArgumentKind::Variadic(..) => Some(\"...\".to_owned()),\n-                                      },\n-                                      comment_span_start,\n-                                      span.hi);\n+        let more_items = itemize_list(\n+            context.codemap,\n+            args[min_args - 1..]\n+                .iter()\n+                .map(ArgumentKind::Regular)\n+                .chain(variadic_arg),\n+            \")\",\n+            |arg| match *arg {\n+                ArgumentKind::Regular(arg) => span_lo_for_arg(arg),\n+                ArgumentKind::Variadic(start) => start,\n+            },\n+            |arg| match *arg {\n+                ArgumentKind::Regular(arg) => arg.ty.span.hi,\n+                ArgumentKind::Variadic(start) => start + BytePos(3),\n+            },\n+            |arg| match *arg {\n+                ArgumentKind::Regular(..) => None,\n+                ArgumentKind::Variadic(..) => Some(\"...\".to_owned()),\n+            },\n+            comment_span_start,\n+            span.hi,\n+        );\n \n         arg_items.extend(more_items);\n     }\n \n     let fits_in_one_line = !generics_str_contains_newline &&\n-                           (arg_items.len() == 0 ||\n-                            arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n+        (arg_items.len() == 0 || arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n \n     for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n         item.item = Some(arg);\n@@ -2048,20 +2177,30 @@ fn rewrite_args(context: &RewriteContext,\n \n     let (indent, trailing_comma, end_with_newline) = match context.config.fn_args_layout() {\n         IndentStyle::Block if fits_in_one_line => {\n-            (indent.block_indent(context.config), SeparatorTactic::Never, true)\n+            (\n+                indent.block_indent(context.config),\n+                SeparatorTactic::Never,\n+                true,\n+            )\n         }\n         IndentStyle::Block => {\n-            (indent.block_indent(context.config), SeparatorTactic::Vertical, true)\n+            (\n+                indent.block_indent(context.config),\n+                SeparatorTactic::Vertical,\n+                true,\n+            )\n         }\n         IndentStyle::Visual if last_line_ends_with_comment => {\n             (arg_indent, SeparatorTactic::Vertical, true)\n         }\n         IndentStyle::Visual => (arg_indent, SeparatorTactic::Never, false),\n     };\n \n-    let tactic = definitive_tactic(&arg_items,\n-                                   context.config.fn_args_density().to_list_tactic(),\n-                                   one_line_budget);\n+    let tactic = definitive_tactic(\n+        &arg_items,\n+        context.config.fn_args_density().to_list_tactic(),\n+        one_line_budget,\n+    );\n     let budget = match tactic {\n         DefinitiveListTactic::Horizontal => one_line_budget,\n         _ => multi_line_budget,\n@@ -2093,18 +2232,21 @@ fn arg_has_pattern(arg: &ast::Arg) -> bool {\n     }\n }\n \n-fn compute_budgets_for_args(context: &RewriteContext,\n-                            result: &str,\n-                            indent: Indent,\n-                            ret_str_len: usize,\n-                            newline_brace: bool,\n-                            has_braces: bool)\n-                            -> Option<((usize, usize, Indent))> {\n-    debug!(\"compute_budgets_for_args {} {:?}, {}, {}\",\n-           result.len(),\n-           indent,\n-           ret_str_len,\n-           newline_brace);\n+fn compute_budgets_for_args(\n+    context: &RewriteContext,\n+    result: &str,\n+    indent: Indent,\n+    ret_str_len: usize,\n+    newline_brace: bool,\n+    has_braces: bool,\n+) -> Option<((usize, usize, Indent))> {\n+    debug!(\n+        \"compute_budgets_for_args {} {:?}, {}, {}\",\n+        result.len(),\n+        indent,\n+        ret_str_len,\n+        newline_brace\n+    );\n     // Try keeping everything on the same line.\n     if !result.contains('\\n') {\n         // 2 = `()`, 3 = `() `, space is before ret_string.\n@@ -2128,11 +2270,14 @@ fn compute_budgets_for_args(context: &RewriteContext,\n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n             let multi_line_overhead = indent.width() + result.len() +\n-                                      if newline_brace { 2 } else { 4 };\n-            let multi_line_budget =\n-                try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n-\n-            return Some((one_line_budget, multi_line_budget, indent + result.len() + 1));\n+                if newline_brace { 2 } else { 4 };\n+            let multi_line_budget = try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n+\n+            return Some((\n+                one_line_budget,\n+                multi_line_budget,\n+                indent + result.len() + 1,\n+            ));\n         }\n     }\n \n@@ -2182,13 +2327,13 @@ fn rewrite_generics_inner(context: &RewriteContext,\n \n     // Extract comments between generics.\n     let lt_spans = lifetimes.iter().map(|l| {\n-                                            let hi = if l.bounds.is_empty() {\n-                                                l.lifetime.span.hi\n-                                            } else {\n-                                                l.bounds[l.bounds.len() - 1].span.hi\n-                                            };\n-                                            mk_sp(l.lifetime.span.lo, hi)\n-                                        });\n+        let hi = if l.bounds.is_empty() {\n+            l.lifetime.span.hi\n+        } else {\n+            l.bounds[l.bounds.len() - 1].span.hi\n+        };\n+        mk_sp(l.lifetime.span.lo, hi)\n+    });\n     let ty_spans = tys.iter().map(span_for_ty_param);\n \n     let items = itemize_list(context.codemap,\n@@ -2260,10 +2405,11 @@ pub fn wrap_generics_with_angle_brackets(context: &RewriteContext,\n     }\n }\n \n-fn rewrite_trait_bounds(context: &RewriteContext,\n-                        type_param_bounds: &ast::TyParamBounds,\n-                        shape: Shape)\n-                        -> Option<String> {\n+fn rewrite_trait_bounds(\n+    context: &RewriteContext,\n+    type_param_bounds: &ast::TyParamBounds,\n+    shape: Shape,\n+) -> Option<String> {\n     let bounds: &[_] = type_param_bounds;\n \n     if bounds.is_empty() {\n@@ -2276,15 +2422,16 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     Some(format!(\": {}\", join_bounds(context, shape, &bound_str)))\n }\n \n-fn rewrite_where_clause_rfc_style(context: &RewriteContext,\n-                                  where_clause: &ast::WhereClause,\n-                                  shape: Shape,\n-                                  terminator: &str,\n-                                  suppress_comma: bool,\n-                                  // where clause can be kept on the current line.\n-                                  snuggle: bool,\n-                                  span_end: Option<BytePos>)\n-                                  -> Option<String> {\n+fn rewrite_where_clause_rfc_style(\n+    context: &RewriteContext,\n+    where_clause: &ast::WhereClause,\n+    shape: Shape,\n+    terminator: &str,\n+    suppress_comma: bool,\n+    // where clause can be kept on the current line.\n+    snuggle: bool,\n+    span_end: Option<BytePos>,\n+) -> Option<String> {\n     let block_shape = shape.block();\n \n     let starting_newline = if snuggle {\n@@ -2325,34 +2472,39 @@ fn rewrite_where_clause_rfc_style(context: &RewriteContext,\n     };\n     let preds_str = try_opt!(write_list(items, &fmt));\n \n-    Some(format!(\"{}where\\n{}{}\",\n-                 starting_newline,\n-                 clause_shape.indent.to_string(context.config),\n-                 preds_str))\n+    Some(format!(\n+        \"{}where\\n{}{}\",\n+        starting_newline,\n+        clause_shape.indent.to_string(context.config),\n+        preds_str\n+    ))\n }\n \n-fn rewrite_where_clause(context: &RewriteContext,\n-                        where_clause: &ast::WhereClause,\n-                        brace_style: BraceStyle,\n-                        shape: Shape,\n-                        density: Density,\n-                        terminator: &str,\n-                        suppress_comma: bool,\n-                        snuggle: bool,\n-                        span_end: Option<BytePos>)\n-                        -> Option<String> {\n+fn rewrite_where_clause(\n+    context: &RewriteContext,\n+    where_clause: &ast::WhereClause,\n+    brace_style: BraceStyle,\n+    shape: Shape,\n+    density: Density,\n+    terminator: &str,\n+    suppress_comma: bool,\n+    snuggle: bool,\n+    span_end: Option<BytePos>,\n+) -> Option<String> {\n     if where_clause.predicates.is_empty() {\n         return Some(String::new());\n     }\n \n     if context.config.where_style() == Style::Rfc {\n-        return rewrite_where_clause_rfc_style(context,\n-                                              where_clause,\n-                                              shape,\n-                                              terminator,\n-                                              suppress_comma,\n-                                              snuggle,\n-                                              span_end);\n+        return rewrite_where_clause_rfc_style(\n+            context,\n+            where_clause,\n+            shape,\n+            terminator,\n+            suppress_comma,\n+            snuggle,\n+            span_end,\n+        );\n     }\n \n     let extra_indent = Indent::new(context.config.tab_spaces(), 0);\n@@ -2372,14 +2524,16 @@ fn rewrite_where_clause(context: &RewriteContext,\n     let len = where_clause.predicates.len();\n     let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n     let span_end = span_end.unwrap_or(end_of_preds);\n-    let items = itemize_list(context.codemap,\n-                             where_clause.predicates.iter(),\n-                             terminator,\n-                             |pred| span_for_where_pred(pred).lo,\n-                             |pred| span_for_where_pred(pred).hi,\n-                             |pred| pred.rewrite(context, Shape::legacy(budget, offset)),\n-                             span_start,\n-                             span_end);\n+    let items = itemize_list(\n+        context.codemap,\n+        where_clause.predicates.iter(),\n+        terminator,\n+        |pred| span_for_where_pred(pred).lo,\n+        |pred| span_for_where_pred(pred).hi,\n+        |pred| pred.rewrite(context, Shape::legacy(budget, offset)),\n+        span_start,\n+        span_end,\n+    );\n     let item_vec = items.collect::<Vec<_>>();\n     // FIXME: we don't need to collect here if the where_layout isn't\n     // HorizontalVertical.\n@@ -2415,10 +2569,13 @@ fn rewrite_where_clause(context: &RewriteContext,\n         terminator.len()\n     };\n     if density == Density::Tall || preds_str.contains('\\n') ||\n-       shape.indent.width() + \" where \".len() + preds_str.len() + end_length > shape.width {\n-        Some(format!(\"\\n{}where {}\",\n-                     (shape.indent + extra_indent).to_string(context.config),\n-                     preds_str))\n+        shape.indent.width() + \" where \".len() + preds_str.len() + end_length > shape.width\n+    {\n+        Some(format!(\n+            \"\\n{}where {}\",\n+            (shape.indent + extra_indent).to_string(context.config),\n+            preds_str\n+        ))\n     } else {\n         Some(format!(\" where {}\", preds_str))\n     }\n@@ -2428,39 +2585,40 @@ fn format_header(item_name: &str, ident: ast::Ident, vis: &ast::Visibility) -> S\n     format!(\"{}{}{}\", format_visibility(vis), item_name, ident)\n }\n \n-fn format_generics(context: &RewriteContext,\n-                   generics: &ast::Generics,\n-                   opener: &str,\n-                   terminator: &str,\n-                   brace_style: BraceStyle,\n-                   force_same_line_brace: bool,\n-                   offset: Indent,\n-                   span: Span)\n-                   -> Option<String> {\n+fn format_generics(\n+    context: &RewriteContext,\n+    generics: &ast::Generics,\n+    opener: &str,\n+    terminator: &str,\n+    brace_style: BraceStyle,\n+    force_same_line_brace: bool,\n+    offset: Indent,\n+    span: Span,\n+) -> Option<String> {\n     let shape = Shape::indented(offset, context.config);\n     let mut result = try_opt!(rewrite_generics(context, generics, shape, span));\n \n     if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n-        let budget = try_opt!(context\n-                                  .config\n-                                  .max_width()\n-                                  .checked_sub(last_line_width(&result)));\n-        let where_clause_str =\n-            try_opt!(rewrite_where_clause(context,\n-                                          &generics.where_clause,\n-                                          brace_style,\n-                                          Shape::legacy(budget, offset.block_only()),\n-                                          Density::Tall,\n-                                          terminator,\n-                                          false,\n-                                          trimmed_last_line_width(&result) == 1,\n-                                          Some(span.hi)));\n+        let budget = try_opt!(context.config.max_width().checked_sub(\n+            last_line_width(&result),\n+        ));\n+        let where_clause_str = try_opt!(rewrite_where_clause(\n+            context,\n+            &generics.where_clause,\n+            brace_style,\n+            Shape::legacy(budget, offset.block_only()),\n+            Density::Tall,\n+            terminator,\n+            false,\n+            trimmed_last_line_width(&result) == 1,\n+            Some(span.hi),\n+        ));\n         result.push_str(&where_clause_str);\n         let same_line_brace = force_same_line_brace ||\n-                              (generics.where_clause.predicates.is_empty() &&\n-                               trimmed_last_line_width(&result) == 1);\n+            (generics.where_clause.predicates.is_empty() && trimmed_last_line_width(&result) == 1);\n         if !same_line_brace &&\n-           (brace_style == BraceStyle::SameLineWhere || brace_style == BraceStyle::AlwaysNextLine) {\n+            (brace_style == BraceStyle::SameLineWhere || brace_style == BraceStyle::AlwaysNextLine)\n+        {\n             result.push('\\n');\n             result.push_str(&offset.block_only().to_string(context.config));\n         } else {\n@@ -2469,7 +2627,8 @@ fn format_generics(context: &RewriteContext,\n         result.push_str(opener);\n     } else {\n         if force_same_line_brace || trimmed_last_line_width(&result) == 1 ||\n-           brace_style != BraceStyle::AlwaysNextLine {\n+            brace_style != BraceStyle::AlwaysNextLine\n+        {\n             result.push(' ');\n         } else {\n             result.push('\\n');"}, {"sha": "2ede6d9a2f095539a49c8ddf7394565cf3160404", "filename": "src/lib.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -189,8 +189,10 @@ impl Sub for Indent {\n     type Output = Indent;\n \n     fn sub(self, rhs: Indent) -> Indent {\n-        Indent::new(self.block_indent - rhs.block_indent,\n-                    self.alignment - rhs.alignment)\n+        Indent::new(\n+            self.block_indent - rhs.block_indent,\n+            self.alignment - rhs.alignment,\n+        )\n     }\n }\n \n@@ -315,17 +317,17 @@ impl Shape {\n \n     pub fn sub_width(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n-                 width: try_opt!(self.width.checked_sub(width)),\n-                 ..*self\n-             })\n+            width: try_opt!(self.width.checked_sub(width)),\n+            ..*self\n+        })\n     }\n \n     pub fn shrink_left(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n-                 width: try_opt!(self.width.checked_sub(width)),\n-                 indent: self.indent + width,\n-                 offset: self.offset + width,\n-             })\n+            width: try_opt!(self.width.checked_sub(width)),\n+            indent: self.indent + width,\n+            offset: self.offset + width,\n+        })\n     }\n \n     pub fn offset_left(&self, width: usize) -> Option<Shape> {\n@@ -350,10 +352,12 @@ impl fmt::Display for ErrorKind {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n             ErrorKind::LineOverflow(found, maximum) => {\n-                write!(fmt,\n-                       \"line exceeded maximum length (maximum: {}, found: {})\",\n-                       maximum,\n-                       found)\n+                write!(\n+                    fmt,\n+                    \"line exceeded maximum length (maximum: {}, found: {})\",\n+                    maximum,\n+                    found\n+                )\n             }\n             ErrorKind::TrailingWhitespace => write!(fmt, \"left behind trailing whitespace\"),\n             ErrorKind::BadIssue(issue) => write!(fmt, \"found {}\", issue),\n@@ -412,28 +416,32 @@ impl fmt::Display for FormatReport {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         for (file, errors) in &self.file_error_map {\n             for error in errors {\n-                write!(fmt,\n-                       \"{} {}:{}: {} {}\\n\",\n-                       error.msg_prefix(),\n-                       file,\n-                       error.line,\n-                       error.kind,\n-                       error.msg_suffix())?;\n+                write!(\n+                    fmt,\n+                    \"{} {}:{}: {} {}\\n\",\n+                    error.msg_prefix(),\n+                    file,\n+                    error.line,\n+                    error.kind,\n+                    error.msg_suffix()\n+                )?;\n             }\n         }\n         Ok(())\n     }\n }\n \n // Formatting which depends on the AST.\n-fn format_ast<F>(krate: &ast::Crate,\n-                 mut parse_session: &mut ParseSess,\n-                 main_file: &Path,\n-                 config: &Config,\n-                 codemap: &Rc<CodeMap>,\n-                 mut after_file: F)\n-                 -> Result<(FileMap, bool), io::Error>\n-    where F: FnMut(&str, &mut StringBuffer) -> Result<bool, io::Error>\n+fn format_ast<F>(\n+    krate: &ast::Crate,\n+    mut parse_session: &mut ParseSess,\n+    main_file: &Path,\n+    config: &Config,\n+    codemap: &Rc<CodeMap>,\n+    mut after_file: F,\n+) -> Result<(FileMap, bool), io::Error>\n+where\n+    F: FnMut(&str, &mut StringBuffer) -> Result<bool, io::Error>,\n {\n     let mut result = FileMap::new();\n     // diff mode: check if any files are differing\n@@ -493,9 +501,9 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n             // Add warnings for bad todos/ fixmes\n             if let Some(issue) = issue_seeker.inspect(c) {\n                 errors.push(FormattingError {\n-                                line: cur_line,\n-                                kind: ErrorKind::BadIssue(issue),\n-                            });\n+                    line: cur_line,\n+                    kind: ErrorKind::BadIssue(issue),\n+                });\n             }\n         }\n \n@@ -510,9 +518,9 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n                 // Check for any line width errors we couldn't correct.\n                 if config.error_on_line_overflow() && line_len > config.max_width() {\n                     errors.push(FormattingError {\n-                                    line: cur_line,\n-                                    kind: ErrorKind::LineOverflow(line_len, config.max_width()),\n-                                });\n+                        line: cur_line,\n+                        kind: ErrorKind::LineOverflow(line_len, config.max_width()),\n+                    });\n                 }\n             }\n \n@@ -541,17 +549,18 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n \n     for &(l, _, _) in &trims {\n         errors.push(FormattingError {\n-                        line: l,\n-                        kind: ErrorKind::TrailingWhitespace,\n-                    });\n+            line: l,\n+            kind: ErrorKind::TrailingWhitespace,\n+        });\n     }\n \n     report.file_error_map.insert(name.to_owned(), errors);\n }\n \n-fn parse_input(input: Input,\n-               parse_session: &ParseSess)\n-               -> Result<ast::Crate, Option<DiagnosticBuilder>> {\n+fn parse_input(\n+    input: Input,\n+    parse_session: &ParseSess,\n+) -> Result<ast::Crate, Option<DiagnosticBuilder>> {\n     let result = match input {\n         Input::File(file) => {\n             let mut parser = parse::new_parser_from_file(parse_session, &file);\n@@ -579,10 +588,11 @@ fn parse_input(input: Input,\n     }\n }\n \n-pub fn format_input<T: Write>(input: Input,\n-                              config: &Config,\n-                              mut out: Option<&mut T>)\n-                              -> Result<(Summary, FileMap, FormatReport), (io::Error, Summary)> {\n+pub fn format_input<T: Write>(\n+    input: Input,\n+    config: &Config,\n+    mut out: Option<&mut T>,\n+) -> Result<(Summary, FileMap, FormatReport), (io::Error, Summary)> {\n     let mut summary = Summary::new();\n     if config.disable_all_formatting() {\n         return Ok((summary, FileMap::new(), FormatReport::new()));\n@@ -614,7 +624,10 @@ pub fn format_input<T: Write>(input: Input,\n     }\n \n     // Suppress error output after parsing.\n-    let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), Some(codemap.clone())));\n+    let silent_emitter = Box::new(EmitterWriter::new(\n+        Box::new(Vec::new()),\n+        Some(codemap.clone()),\n+    ));\n     parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n     let mut report = FormatReport::new();"}, {"sha": "37acff692a4137f499fb3b6928e43a16d93b12c6", "filename": "src/lists.rs", "status": "modified", "additions": 133, "deletions": 101, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -69,22 +69,27 @@ pub struct ListFormatting<'a> {\n }\n \n pub fn format_fn_args<I>(items: I, shape: Shape, config: &Config) -> Option<String>\n-    where I: Iterator<Item = ListItem>\n+where\n+    I: Iterator<Item = ListItem>,\n {\n-    list_helper(items,\n-                shape,\n-                config,\n-                ListTactic::LimitedHorizontalVertical(config.fn_call_width()))\n+    list_helper(\n+        items,\n+        shape,\n+        config,\n+        ListTactic::LimitedHorizontalVertical(config.fn_call_width()),\n+    )\n }\n \n pub fn format_item_list<I>(items: I, shape: Shape, config: &Config) -> Option<String>\n-    where I: Iterator<Item = ListItem>\n+where\n+    I: Iterator<Item = ListItem>,\n {\n     list_helper(items, shape, config, ListTactic::HorizontalVertical)\n }\n \n pub fn list_helper<I>(items: I, shape: Shape, config: &Config, tactic: ListTactic) -> Option<String>\n-    where I: Iterator<Item = ListItem>\n+where\n+    I: Iterator<Item = ListItem>,\n {\n     let item_vec: Vec<_> = items.collect();\n     let tactic = definitive_tactic(&item_vec, tactic, shape.width);\n@@ -120,15 +125,16 @@ pub struct ListItem {\n impl ListItem {\n     pub fn is_multiline(&self) -> bool {\n         self.item.as_ref().map_or(false, |s| s.contains('\\n')) || self.pre_comment.is_some() ||\n-        self.post_comment\n-            .as_ref()\n-            .map_or(false, |s| s.contains('\\n'))\n+            self.post_comment.as_ref().map_or(\n+                false,\n+                |s| s.contains('\\n'),\n+            )\n     }\n \n     pub fn has_line_pre_comment(&self) -> bool {\n-        self.pre_comment\n-            .as_ref()\n-            .map_or(false, |comment| comment.starts_with(\"//\"))\n+        self.pre_comment.as_ref().map_or(false, |comment| {\n+            comment.starts_with(\"//\")\n+        })\n     }\n \n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n@@ -150,13 +156,13 @@ pub enum DefinitiveListTactic {\n }\n \n pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> DefinitiveListTactic\n-    where I: IntoIterator<Item = T> + Clone,\n-          T: AsRef<ListItem>\n+where\n+    I: IntoIterator<Item = T> + Clone,\n+    T: AsRef<ListItem>,\n {\n-    let pre_line_comments = items\n-        .clone()\n-        .into_iter()\n-        .any(|item| item.as_ref().has_line_pre_comment());\n+    let pre_line_comments = items.clone().into_iter().any(|item| {\n+        item.as_ref().has_line_pre_comment()\n+    });\n \n     let limit = match tactic {\n         _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n@@ -173,7 +179,8 @@ pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> De\n     let real_total = total_width + total_sep_len;\n \n     if real_total <= limit && !pre_line_comments &&\n-       !items.into_iter().any(|item| item.as_ref().is_multiline()) {\n+        !items.into_iter().any(|item| item.as_ref().is_multiline())\n+    {\n         DefinitiveListTactic::Horizontal\n     } else {\n         DefinitiveListTactic::Vertical\n@@ -183,8 +190,9 @@ pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> De\n // Format a list of commented items into a string.\n // TODO: add unit tests\n pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n-    where I: IntoIterator<Item = T>,\n-          T: AsRef<ListItem>\n+where\n+    I: IntoIterator<Item = T>,\n+    T: AsRef<ListItem>,\n {\n     let tactic = formatting.tactic;\n     let sep_len = formatting.separator.len();\n@@ -250,8 +258,12 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n             // Block style in non-vertical mode.\n             let block_mode = tactic != DefinitiveListTactic::Vertical;\n             // Width restriction is only relevant in vertical mode.\n-            let comment =\n-                try_opt!(rewrite_comment(comment, block_mode, formatting.shape, formatting.config));\n+            let comment = try_opt!(rewrite_comment(\n+                comment,\n+                block_mode,\n+                formatting.shape,\n+                formatting.config,\n+            ));\n             result.push_str(&comment);\n \n             if tactic == DefinitiveListTactic::Vertical {\n@@ -267,11 +279,12 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n         // Post-comments\n         if tactic != DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n-            let formatted_comment =\n-                try_opt!(rewrite_comment(comment,\n-                                         true,\n-                                         Shape::legacy(formatting.shape.width, Indent::empty()),\n-                                         formatting.config));\n+            let formatted_comment = try_opt!(rewrite_comment(\n+                comment,\n+                true,\n+                Shape::legacy(formatting.shape.width, Indent::empty()),\n+                formatting.config,\n+            ));\n \n             result.push(' ');\n             result.push_str(&formatted_comment);\n@@ -295,13 +308,15 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n             debug!(\"Width = {}, offset = {:?}\", width, offset);\n             // Use block-style only for the last item or multiline comments.\n             let block_style = !formatting.ends_with_newline && last ||\n-                              comment.trim().contains('\\n') ||\n-                              comment.trim().len() > width;\n+                comment.trim().contains('\\n') ||\n+                comment.trim().len() > width;\n \n-            let formatted_comment = try_opt!(rewrite_comment(comment,\n-                                                             block_style,\n-                                                             Shape::legacy(width, offset),\n-                                                             formatting.config));\n+            let formatted_comment = try_opt!(rewrite_comment(\n+                comment,\n+                block_style,\n+                Shape::legacy(width, offset),\n+                formatting.config,\n+            ));\n \n             if !formatted_comment.starts_with('\\n') {\n                 result.push(' ');\n@@ -318,7 +333,8 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n }\n \n pub struct ListItems<'a, I, F1, F2, F3>\n-    where I: Iterator\n+where\n+    I: Iterator,\n {\n     codemap: &'a CodeMap,\n     inner: Peekable<I>,\n@@ -331,10 +347,11 @@ pub struct ListItems<'a, I, F1, F2, F3>\n }\n \n impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n-    where I: Iterator<Item = T>,\n-          F1: Fn(&T) -> BytePos,\n-          F2: Fn(&T) -> BytePos,\n-          F3: Fn(&T) -> Option<String>\n+where\n+    I: Iterator<Item = T>,\n+    F1: Fn(&T) -> BytePos,\n+    F2: Fn(&T) -> BytePos,\n+    F3: Fn(&T) -> Option<String>,\n {\n     type Item = ListItem;\n \n@@ -349,7 +366,7 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                 .unwrap();\n             let trimmed_pre_snippet = pre_snippet.trim();\n             let has_pre_comment = trimmed_pre_snippet.contains(\"//\") ||\n-                                  trimmed_pre_snippet.contains(\"/*\");\n+                trimmed_pre_snippet.contains(\"/*\");\n             let pre_comment = if has_pre_comment {\n                 Some(trimmed_pre_snippet.to_owned())\n             } else {\n@@ -383,23 +400,28 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                         (Some(i), None) if i > separator_index => separator_index + 1,\n                         // Block-style post-comment before the separator.\n                         (Some(i), None) => {\n-                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                     separator_index + 1)\n+                            cmp::max(\n+                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                separator_index + 1,\n+                            )\n                         }\n                         // Block-style post-comment. Either before or after the separator.\n                         (Some(i), Some(j)) if i < j => {\n-                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                     separator_index + 1)\n+                            cmp::max(\n+                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                separator_index + 1,\n+                            )\n                         }\n                         // Potential *single* line comment.\n                         (_, Some(j)) if j > separator_index => j + 1,\n                         _ => post_snippet.len(),\n                     }\n                 }\n                 None => {\n-                    post_snippet\n-                        .find_uncommented(self.terminator)\n-                        .unwrap_or(post_snippet.len())\n+                    post_snippet.find_uncommented(self.terminator).unwrap_or(\n+                        post_snippet\n+                            .len(),\n+                    )\n                 }\n             };\n \n@@ -412,9 +434,10 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                 let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n                 // From the end of the first line of comments.\n                 let test_snippet = &test_snippet[first_newline..];\n-                let first = test_snippet\n-                    .find(|c: char| !c.is_whitespace())\n-                    .unwrap_or(test_snippet.len());\n+                let first = test_snippet.find(|c: char| !c.is_whitespace()).unwrap_or(\n+                    test_snippet\n+                        .len(),\n+                );\n                 // From the end of the first line of comments to the next non-whitespace char.\n                 let test_snippet = &test_snippet[..first];\n \n@@ -453,19 +476,21 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n }\n \n // Creates an iterator over a list's items with associated comments.\n-pub fn itemize_list<'a, T, I, F1, F2, F3>(codemap: &'a CodeMap,\n-                                          inner: I,\n-                                          terminator: &'a str,\n-                                          get_lo: F1,\n-                                          get_hi: F2,\n-                                          get_item_string: F3,\n-                                          prev_span_end: BytePos,\n-                                          next_span_start: BytePos)\n-                                          -> ListItems<'a, I, F1, F2, F3>\n-    where I: Iterator<Item = T>,\n-          F1: Fn(&T) -> BytePos,\n-          F2: Fn(&T) -> BytePos,\n-          F3: Fn(&T) -> Option<String>\n+pub fn itemize_list<'a, T, I, F1, F2, F3>(\n+    codemap: &'a CodeMap,\n+    inner: I,\n+    terminator: &'a str,\n+    get_lo: F1,\n+    get_hi: F2,\n+    get_item_string: F3,\n+    prev_span_end: BytePos,\n+    next_span_start: BytePos,\n+) -> ListItems<'a, I, F1, F2, F3>\n+where\n+    I: Iterator<Item = T>,\n+    F1: Fn(&T) -> BytePos,\n+    F2: Fn(&T) -> BytePos,\n+    F3: Fn(&T) -> Option<String>,\n {\n     ListItems {\n         codemap: codemap,\n@@ -479,9 +504,10 @@ pub fn itemize_list<'a, T, I, F1, F2, F3>(codemap: &'a CodeMap,\n     }\n }\n \n-fn needs_trailing_separator(separator_tactic: SeparatorTactic,\n-                            list_tactic: DefinitiveListTactic)\n-                            -> bool {\n+fn needs_trailing_separator(\n+    separator_tactic: SeparatorTactic,\n+    list_tactic: DefinitiveListTactic,\n+) -> bool {\n     match separator_tactic {\n         SeparatorTactic::Always => true,\n         SeparatorTactic::Vertical => list_tactic == DefinitiveListTactic::Vertical,\n@@ -491,8 +517,9 @@ fn needs_trailing_separator(separator_tactic: SeparatorTactic,\n \n /// Returns the count and total width of the list items.\n fn calculate_width<I, T>(items: I) -> (usize, usize)\n-    where I: IntoIterator<Item = T>,\n-          T: AsRef<ListItem>\n+where\n+    I: IntoIterator<Item = T>,\n+    T: AsRef<ListItem>,\n {\n     items\n         .into_iter()\n@@ -502,8 +529,8 @@ fn calculate_width<I, T>(items: I) -> (usize, usize)\n \n fn total_item_width(item: &ListItem) -> usize {\n     comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..])) +\n-    comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) +\n-    item.item.as_ref().map_or(0, |str| str.len())\n+        comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) +\n+        item.item.as_ref().map_or(0, |str| str.len())\n }\n \n fn comment_len(comment: Option<&str>) -> usize {\n@@ -522,33 +549,36 @@ fn comment_len(comment: Option<&str>) -> usize {\n }\n \n // Compute horizontal and vertical shapes for a struct-lit-like thing.\n-pub fn struct_lit_shape(shape: Shape,\n-                        context: &RewriteContext,\n-                        prefix_width: usize,\n-                        suffix_width: usize)\n-                        -> Option<(Option<Shape>, Shape)> {\n-    let v_shape = match context.config.struct_lit_style() {\n-        IndentStyle::Visual => {\n-            try_opt!(try_opt!(shape.visual_indent(0).shrink_left(prefix_width))\n+pub fn struct_lit_shape(\n+    shape: Shape,\n+    context: &RewriteContext,\n+    prefix_width: usize,\n+    suffix_width: usize,\n+) -> Option<(Option<Shape>, Shape)> {\n+    let v_shape =\n+        match context.config.struct_lit_style() {\n+            IndentStyle::Visual => {\n+                try_opt!(try_opt!(shape.visual_indent(0).shrink_left(prefix_width))\n                          .sub_width(suffix_width))\n-        }\n-        IndentStyle::Block => {\n-            let shape = shape.block_indent(context.config.tab_spaces());\n-            Shape {\n-                width: try_opt!(context.config.max_width().checked_sub(shape.indent.width())),\n-                ..shape\n             }\n-        }\n-    };\n+            IndentStyle::Block => {\n+                let shape = shape.block_indent(context.config.tab_spaces());\n+                Shape {\n+                    width: try_opt!(context.config.max_width().checked_sub(shape.indent.width())),\n+                    ..shape\n+                }\n+            }\n+        };\n     let h_shape = shape.sub_width(prefix_width + suffix_width);\n     Some((h_shape, v_shape))\n }\n \n // Compute the tactic for the internals of a struct-lit-like thing.\n-pub fn struct_lit_tactic(h_shape: Option<Shape>,\n-                         context: &RewriteContext,\n-                         items: &[ListItem])\n-                         -> DefinitiveListTactic {\n+pub fn struct_lit_tactic(\n+    h_shape: Option<Shape>,\n+    context: &RewriteContext,\n+    items: &[ListItem],\n+) -> DefinitiveListTactic {\n     if let Some(h_shape) = h_shape {\n         let mut prelim_tactic = match (context.config.struct_lit_style(), items.len()) {\n             (IndentStyle::Visual, 1) => ListTactic::HorizontalVertical,\n@@ -568,10 +598,11 @@ pub fn struct_lit_tactic(h_shape: Option<Shape>,\n \n // Given a tactic and possible shapes for horizontal and vertical layout,\n // come up with the actual shape to use.\n-pub fn shape_for_tactic(tactic: DefinitiveListTactic,\n-                        h_shape: Option<Shape>,\n-                        v_shape: Shape)\n-                        -> Shape {\n+pub fn shape_for_tactic(\n+    tactic: DefinitiveListTactic,\n+    h_shape: Option<Shape>,\n+    v_shape: Shape,\n+) -> Shape {\n     match tactic {\n         DefinitiveListTactic::Horizontal => h_shape.unwrap(),\n         _ => v_shape,\n@@ -580,13 +611,14 @@ pub fn shape_for_tactic(tactic: DefinitiveListTactic,\n \n // Create a ListFormatting object for formatting the internals of a\n // struct-lit-like thing, that is a series of fields.\n-pub fn struct_lit_formatting<'a>(shape: Shape,\n-                                 tactic: DefinitiveListTactic,\n-                                 context: &'a RewriteContext,\n-                                 force_no_trailing_comma: bool)\n-                                 -> ListFormatting<'a> {\n+pub fn struct_lit_formatting<'a>(\n+    shape: Shape,\n+    tactic: DefinitiveListTactic,\n+    context: &'a RewriteContext,\n+    force_no_trailing_comma: bool,\n+) -> ListFormatting<'a> {\n     let ends_with_newline = context.config.struct_lit_style() != IndentStyle::Visual &&\n-                            tactic == DefinitiveListTactic::Vertical;\n+        tactic == DefinitiveListTactic::Vertical;\n     ListFormatting {\n         tactic: tactic,\n         separator: \",\","}, {"sha": "562e776f8d3bf93f743e79e803a7dfb3bae8d293", "filename": "src/macros.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -61,12 +61,13 @@ impl MacroStyle {\n     }\n }\n \n-pub fn rewrite_macro(mac: &ast::Mac,\n-                     extra_ident: Option<ast::Ident>,\n-                     context: &RewriteContext,\n-                     shape: Shape,\n-                     position: MacroPosition)\n-                     -> Option<String> {\n+pub fn rewrite_macro(\n+    mac: &ast::Mac,\n+    extra_ident: Option<ast::Ident>,\n+    context: &RewriteContext,\n+    shape: Shape,\n+    position: MacroPosition,\n+) -> Option<String> {\n     let mut context = &mut context.clone();\n     context.inside_macro = true;\n     if context.config.use_try_shorthand() {\n@@ -191,24 +192,29 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                 } else {\n                     (\"[\", \"]\")\n                 };\n-                rewrite_pair(&*expr_vec[0],\n-                             &*expr_vec[1],\n-                             lbr,\n-                             \"; \",\n-                             rbr,\n-                             context,\n-                             mac_shape)\n-                    .map(|s| format!(\"{}{}\", macro_name, s))\n+                rewrite_pair(\n+                    &*expr_vec[0],\n+                    &*expr_vec[1],\n+                    lbr,\n+                    \"; \",\n+                    rbr,\n+                    context,\n+                    mac_shape,\n+                ).map(|s| format!(\"{}{}\", macro_name, s))\n             } else {\n                 // Format macro invocation as array literal.\n-                let rewrite =\n-                    try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n-                                           mk_sp(context\n-                                                     .codemap\n-                                                     .span_after(mac.span, original_style.opener()),\n-                                               mac.span.hi - BytePos(1)),\n-                                           context,\n-                                           mac_shape));\n+                let rewrite = try_opt!(rewrite_array(\n+                    expr_vec.iter().map(|x| &**x),\n+                    mk_sp(\n+                        context.codemap.span_after(\n+                            mac.span,\n+                            original_style.opener(),\n+                        ),\n+                        mac.span.hi - BytePos(1),\n+                    ),\n+                    context,\n+                    mac_shape,\n+                ));\n \n                 Some(format!(\"{}{}\", macro_name, rewrite))\n             }\n@@ -229,11 +235,11 @@ pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::\n         let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n \n         Some(ast::Expr {\n-                 id: ast::NodeId::new(0), // dummy value\n-                 node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n-                 span: mac.span, // incorrect span, but shouldn't matter too much\n-                 attrs: ThinVec::new(),\n-             })\n+            id: ast::NodeId::new(0), // dummy value\n+            node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n+            span: mac.span, // incorrect span, but shouldn't matter too much\n+            attrs: ThinVec::new(),\n+        })\n     } else {\n         None\n     }"}, {"sha": "17b75a344276edcacb5a7ae3bc75651c1773342f", "filename": "src/missed_spans.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -47,9 +47,11 @@ impl<'a> FmtVisitor<'a> {\n         })\n     }\n \n-    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,\n-                                                                end: BytePos,\n-                                                                process_last_snippet: F) {\n+    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, &str)>(\n+        &mut self,\n+        end: BytePos,\n+        process_last_snippet: F,\n+    ) {\n         let start = self.last_pos;\n \n         if start == end {\n@@ -60,10 +62,12 @@ impl<'a> FmtVisitor<'a> {\n             return;\n         }\n \n-        assert!(start < end,\n-                \"Request to format inverted span: {:?} to {:?}\",\n-                self.codemap.lookup_char_pos(start),\n-                self.codemap.lookup_char_pos(end));\n+        assert!(\n+            start < end,\n+            \"Request to format inverted span: {:?} to {:?}\",\n+            self.codemap.lookup_char_pos(start),\n+            self.codemap.lookup_char_pos(end)\n+        );\n \n         self.last_pos = end;\n         let span = mk_sp(start, end);\n@@ -72,7 +76,8 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     fn write_snippet<F>(&mut self, span: Span, process_last_snippet: F)\n-        where F: Fn(&mut FmtVisitor, &str, &str)\n+    where\n+        F: Fn(&mut FmtVisitor, &str, &str),\n     {\n         // Get a snippet from the file start to the span's hi without allocating.\n         // We need it to determine what precedes the current comment. If the comment\n@@ -92,13 +97,15 @@ impl<'a> FmtVisitor<'a> {\n         self.write_snippet_inner(big_snippet, big_diff, &snippet, span, process_last_snippet);\n     }\n \n-    fn write_snippet_inner<F>(&mut self,\n-                              big_snippet: &str,\n-                              big_diff: usize,\n-                              old_snippet: &str,\n-                              span: Span,\n-                              process_last_snippet: F)\n-        where F: Fn(&mut FmtVisitor, &str, &str)\n+    fn write_snippet_inner<F>(\n+        &mut self,\n+        big_snippet: &str,\n+        big_diff: usize,\n+        old_snippet: &str,\n+        span: Span,\n+        process_last_snippet: F,\n+    ) where\n+        F: Fn(&mut FmtVisitor, &str, &str),\n     {\n         // Trim whitespace from the right hand side of each line.\n         // Annoyingly, the library functions for splitting by lines etc. are not\n@@ -139,9 +146,12 @@ impl<'a> FmtVisitor<'a> {\n                 let subslice_num_lines = subslice.chars().filter(|c| *c == '\\n').count();\n \n                 if rewrite_next_comment &&\n-                   !self.config\n-                       .file_lines()\n-                       .intersects_range(file_name, cur_line, cur_line + subslice_num_lines) {\n+                    !self.config.file_lines().intersects_range(\n+                        file_name,\n+                        cur_line,\n+                        cur_line + subslice_num_lines,\n+                    )\n+                {\n                     rewrite_next_comment = false;\n                 }\n \n@@ -150,32 +160,34 @@ impl<'a> FmtVisitor<'a> {\n                         if let Some('{') = last_char {\n                             self.buffer.push_str(\"\\n\");\n                         }\n-                        self.buffer\n-                            .push_str(&self.block_indent.to_string(self.config));\n+                        self.buffer.push_str(\n+                            &self.block_indent.to_string(self.config),\n+                        );\n                     } else {\n                         self.buffer.push_str(\" \");\n                     }\n \n-                    let comment_width = ::std::cmp::min(self.config.comment_width(),\n-                                                        self.config.max_width() -\n-                                                        self.block_indent.width());\n+                    let comment_width = ::std::cmp::min(\n+                        self.config.comment_width(),\n+                        self.config.max_width() - self.block_indent.width(),\n+                    );\n \n-                    self.buffer.push_str(&rewrite_comment(subslice,\n-                                                          false,\n-                                                          Shape::legacy(comment_width,\n-                                                                        self.block_indent),\n-                                                          self.config)\n-                                             .unwrap());\n+                    self.buffer.push_str(&rewrite_comment(\n+                        subslice,\n+                        false,\n+                        Shape::legacy(comment_width, self.block_indent),\n+                        self.config,\n+                    ).unwrap());\n \n                     last_wspace = None;\n                     line_start = offset + subslice.len();\n \n                     if let Some('/') = subslice.chars().skip(1).next() {\n                         // check that there are no contained block comments\n-                        if !subslice\n-                               .split('\\n')\n-                               .map(|s| s.trim_left())\n-                               .any(|s| s.len() >= 2 && &s[0..2] == \"/*\") {\n+                        if !subslice.split('\\n').map(|s| s.trim_left()).any(|s| {\n+                            s.len() >= 2 && &s[0..2] == \"/*\"\n+                        })\n+                        {\n                             // Add a newline after line comments\n                             self.buffer.push_str(\"\\n\");\n                         }"}, {"sha": "5b5050d51c9641576029b8731246c6d8e006228d", "filename": "src/modules.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -20,30 +20,35 @@ use syntax::parse::parser;\n \n /// List all the files containing modules of a crate.\n /// If a file is used twice in a crate, it appears only once.\n-pub fn list_files<'a>(krate: &'a ast::Crate,\n-                      codemap: &codemap::CodeMap)\n-                      -> BTreeMap<PathBuf, &'a ast::Mod> {\n+pub fn list_files<'a>(\n+    krate: &'a ast::Crate,\n+    codemap: &codemap::CodeMap,\n+) -> BTreeMap<PathBuf, &'a ast::Mod> {\n     let mut result = BTreeMap::new(); // Enforce file order determinism\n     let root_filename: PathBuf = codemap.span_to_filename(krate.span).into();\n-    list_submodules(&krate.module,\n-                    root_filename.parent().unwrap(),\n-                    codemap,\n-                    &mut result);\n+    list_submodules(\n+        &krate.module,\n+        root_filename.parent().unwrap(),\n+        codemap,\n+        &mut result,\n+    );\n     result.insert(root_filename, &krate.module);\n     result\n }\n \n /// Recursively list all external modules included in a module.\n-fn list_submodules<'a>(module: &'a ast::Mod,\n-                       search_dir: &Path,\n-                       codemap: &codemap::CodeMap,\n-                       result: &mut BTreeMap<PathBuf, &'a ast::Mod>) {\n+fn list_submodules<'a>(\n+    module: &'a ast::Mod,\n+    search_dir: &Path,\n+    codemap: &codemap::CodeMap,\n+    result: &mut BTreeMap<PathBuf, &'a ast::Mod>,\n+) {\n     debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n     for item in &module.items {\n         if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n             if !utils::contains_skip(&item.attrs) {\n                 let is_internal = codemap.span_to_filename(item.span) ==\n-                                  codemap.span_to_filename(sub_mod.inner);\n+                    codemap.span_to_filename(sub_mod.inner);\n                 let dir_path = if is_internal {\n                     search_dir.join(&item.ident.to_string())\n                 } else {\n@@ -59,11 +64,12 @@ fn list_submodules<'a>(module: &'a ast::Mod,\n }\n \n /// Find the file corresponding to an external mod\n-fn module_file(id: ast::Ident,\n-               attrs: &[ast::Attribute],\n-               dir_path: &Path,\n-               codemap: &codemap::CodeMap)\n-               -> PathBuf {\n+fn module_file(\n+    id: ast::Ident,\n+    attrs: &[ast::Attribute],\n+    dir_path: &Path,\n+    codemap: &codemap::CodeMap,\n+) -> PathBuf {\n     if let Some(path) = parser::Parser::submod_path_from_attr(attrs, dir_path) {\n         return path;\n     }"}, {"sha": "67e4870f66012b03210a957b8ed5e6961421eef5", "filename": "src/patterns.rs", "status": "modified", "additions": 112, "deletions": 82, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -39,12 +39,13 @@ impl Rewrite for Pat {\n                 let sub_pat = match *sub_pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n-                        let width =\n-                            try_opt!(shape.width.checked_sub(prefix.len() + mut_infix.len() +\n-                                                             id_str.len() +\n-                                                             3));\n-                        format!(\" @ {}\",\n-                                try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent))))\n+                        let width = try_opt!(shape.width.checked_sub(\n+                            prefix.len() + mut_infix.len() + id_str.len() + 3,\n+                        ));\n+                        format!(\n+                            \" @ {}\",\n+                            try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent)))\n+                        )\n                     }\n                     None => \"\".to_owned(),\n                 };\n@@ -80,23 +81,23 @@ impl Rewrite for Pat {\n                 rewrite_path(context, PathContext::Expr, q_self.as_ref(), path, shape)\n             }\n             PatKind::TupleStruct(ref path, ref pat_vec, dotdot_pos) => {\n-                let path_str =\n-                    try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n-                rewrite_tuple_pat(pat_vec,\n-                                  dotdot_pos,\n-                                  Some(path_str),\n-                                  self.span,\n-                                  context,\n-                                  shape)\n+                let path_str = try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n+                rewrite_tuple_pat(\n+                    pat_vec,\n+                    dotdot_pos,\n+                    Some(path_str),\n+                    self.span,\n+                    context,\n+                    shape,\n+                )\n             }\n             PatKind::Lit(ref expr) => expr.rewrite(context, shape),\n             PatKind::Slice(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, shape));\n-                let slice_pat =\n-                    slice_pat\n-                        .as_ref()\n-                        .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape)))));\n+                let slice_pat = slice_pat.as_ref().map(|p| {\n+                    Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape))))\n+                });\n                 let suffix = suffix.iter().map(|p| p.rewrite(context, shape));\n \n                 // Munge them together.\n@@ -119,24 +120,33 @@ impl Rewrite for Pat {\n             }\n             // FIXME(#819) format pattern macros.\n             PatKind::Mac(..) => {\n-                wrap_str(context.snippet(self.span),\n-                         context.config.max_width(),\n-                         shape)\n+                wrap_str(\n+                    context.snippet(self.span),\n+                    context.config.max_width(),\n+                    shape,\n+                )\n             }\n         }\n     }\n }\n \n-fn rewrite_struct_pat(path: &ast::Path,\n-                      fields: &[codemap::Spanned<ast::FieldPat>],\n-                      elipses: bool,\n-                      span: Span,\n-                      context: &RewriteContext,\n-                      shape: Shape)\n-                      -> Option<String> {\n+fn rewrite_struct_pat(\n+    path: &ast::Path,\n+    fields: &[codemap::Spanned<ast::FieldPat>],\n+    elipses: bool,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     // 2 =  ` {`\n     let path_shape = try_opt!(shape.sub_width(2));\n-    let path_str = try_opt!(rewrite_path(context, PathContext::Expr, None, path, path_shape));\n+    let path_str = try_opt!(rewrite_path(\n+        context,\n+        PathContext::Expr,\n+        None,\n+        path,\n+        path_shape,\n+    ));\n \n     if fields.len() == 0 && !elipses {\n         return Some(format!(\"{} {{}}\", path_str));\n@@ -145,17 +155,23 @@ fn rewrite_struct_pat(path: &ast::Path,\n     let (elipses_str, terminator) = if elipses { (\", ..\", \"..\") } else { (\"\", \"}\") };\n \n     // 3 = ` { `, 2 = ` }`.\n-    let (h_shape, v_shape) =\n-        try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, elipses_str.len() + 2));\n-\n-    let items = itemize_list(context.codemap,\n-                             fields.iter(),\n-                             terminator,\n-                             |f| f.span.lo,\n-                             |f| f.span.hi,\n-                             |f| f.node.rewrite(context, v_shape),\n-                             context.codemap.span_after(span, \"{\"),\n-                             span.hi);\n+    let (h_shape, v_shape) = try_opt!(struct_lit_shape(\n+        shape,\n+        context,\n+        path_str.len() + 3,\n+        elipses_str.len() + 2,\n+    ));\n+\n+    let items = itemize_list(\n+        context.codemap,\n+        fields.iter(),\n+        terminator,\n+        |f| f.span.lo,\n+        |f| f.span.hi,\n+        |f| f.node.rewrite(context, v_shape),\n+        context.codemap.span_after(span, \"{\"),\n+        span.hi,\n+    );\n     let item_vec = items.collect::<Vec<_>>();\n \n     let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n@@ -189,14 +205,16 @@ fn rewrite_struct_pat(path: &ast::Path,\n \n \n     let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n-                        (fields_str.contains('\\n') ||\n-                         context.config.struct_lit_multiline_style() ==\n-                         MultilineStyle::ForceMulti ||\n-                         fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n-        format!(\"\\n{}{}\\n{}\",\n-                v_shape.indent.to_string(context.config),\n-                fields_str,\n-                shape.indent.to_string(context.config))\n+        (fields_str.contains('\\n') ||\n+             context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti ||\n+             fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0))\n+    {\n+        format!(\n+            \"\\n{}{}\\n{}\",\n+            v_shape.indent.to_string(context.config),\n+            fields_str,\n+            shape.indent.to_string(context.config)\n+        )\n     } else {\n         // One liner or visual indent.\n         format!(\" {} \", fields_str)\n@@ -211,9 +229,11 @@ impl Rewrite for FieldPat {\n         if self.is_shorthand {\n             pat\n         } else {\n-            wrap_str(format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n-                     context.config.max_width(),\n-                     shape)\n+            wrap_str(\n+                format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n+                context.config.max_width(),\n+                shape,\n+            )\n         }\n     }\n }\n@@ -241,13 +261,14 @@ impl<'a> Spanned for TuplePatField<'a> {\n     }\n }\n \n-fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n-                     dotdot_pos: Option<usize>,\n-                     path_str: Option<String>,\n-                     span: Span,\n-                     context: &RewriteContext,\n-                     shape: Shape)\n-                     -> Option<String> {\n+fn rewrite_tuple_pat(\n+    pats: &[ptr::P<ast::Pat>],\n+    dotdot_pos: Option<usize>,\n+    path_str: Option<String>,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let mut pat_vec: Vec<_> = pats.into_iter().map(|x| TuplePatField::Pat(x)).collect();\n \n     if let Some(pos) = dotdot_pos {\n@@ -285,15 +306,16 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n     let nested_shape = try_opt!(shape.sub_width(path_len + if add_comma { 3 } else { 2 }));\n     // 1 = \"(\".len()\n     let nested_shape = nested_shape.visual_indent(path_len + 1);\n-    let mut items: Vec<_> = itemize_list(context.codemap,\n-                                         pat_vec.iter(),\n-                                         if add_comma { \",)\" } else { \")\" },\n-                                         |item| item.span().lo,\n-                                         |item| item.span().hi,\n-                                         |item| item.rewrite(context, nested_shape),\n-                                         context.codemap.span_after(span, \"(\"),\n-                                         span.hi - BytePos(1))\n-        .collect();\n+    let mut items: Vec<_> = itemize_list(\n+        context.codemap,\n+        pat_vec.iter(),\n+        if add_comma { \",)\" } else { \")\" },\n+        |item| item.span().lo,\n+        |item| item.span().hi,\n+        |item| item.rewrite(context, nested_shape),\n+        context.codemap.span_after(span, \"(\"),\n+        span.hi - BytePos(1),\n+    ).collect();\n \n     // Condense wildcard string suffix into a single ..\n     let wildcard_suffix_len = count_wildcard_suffix_len(&items);\n@@ -305,24 +327,32 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n         let da_iter = items.into_iter().take(new_item_count);\n         try_opt!(format_item_list(da_iter, nested_shape, context.config))\n     } else {\n-        try_opt!(format_item_list(items.into_iter(), nested_shape, context.config))\n+        try_opt!(format_item_list(\n+            items.into_iter(),\n+            nested_shape,\n+            context.config,\n+        ))\n     };\n \n     match path_str {\n         Some(path_str) => {\n-            Some(if context.config.spaces_within_parens() {\n-                     format!(\"{}( {} )\", path_str, list)\n-                 } else {\n-                     format!(\"{}({})\", path_str, list)\n-                 })\n+            Some(\n+                if context.config.spaces_within_parens() {\n+                    format!(\"{}( {} )\", path_str, list)\n+                } else {\n+                    format!(\"{}({})\", path_str, list)\n+                },\n+            )\n         }\n         None => {\n             let comma = if add_comma { \",\" } else { \"\" };\n-            Some(if context.config.spaces_within_parens() {\n-                     format!(\"( {}{} )\", list, comma)\n-                 } else {\n-                     format!(\"({}{})\", list, comma)\n-                 })\n+            Some(\n+                if context.config.spaces_within_parens() {\n+                    format!(\"( {}{} )\", list, comma)\n+                } else {\n+                    format!(\"({}{})\", list, comma)\n+                },\n+            )\n         }\n     }\n }\n@@ -331,10 +361,10 @@ fn count_wildcard_suffix_len(items: &[ListItem]) -> usize {\n     let mut suffix_len = 0;\n \n     for item in items.iter().rev().take_while(|i| match i.item {\n-                                                  Some(ref internal_string) if internal_string ==\n-                                                                               \"_\" => true,\n-                                                  _ => false,\n-                                              }) {\n+        Some(ref internal_string) if internal_string == \"_\" => true,\n+        _ => false,\n+    })\n+    {\n         suffix_len += 1;\n \n         if item.pre_comment.is_some() || item.post_comment.is_some() {"}, {"sha": "ff35a83cc63b6228789b2ab724fecaf7bd901f49", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -86,7 +86,8 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n }\n \n pub fn print_diff<F>(diff: Vec<Mismatch>, get_section_title: F)\n-    where F: Fn(u32) -> String\n+where\n+    F: Fn(u32) -> String,\n {\n     match term::stdout() {\n         Some(ref t) if isatty() && t.supports_color() => {\n@@ -115,10 +116,12 @@ pub fn print_diff<F>(diff: Vec<Mismatch>, get_section_title: F)\n     }\n }\n \n-fn print_diff_fancy<F>(diff: Vec<Mismatch>,\n-                       get_section_title: F,\n-                       mut t: Box<term::Terminal<Output = io::Stdout>>)\n-    where F: Fn(u32) -> String\n+fn print_diff_fancy<F>(\n+    diff: Vec<Mismatch>,\n+    get_section_title: F,\n+    mut t: Box<term::Terminal<Output = io::Stdout>>,\n+) where\n+    F: Fn(u32) -> String,\n {\n     for mismatch in diff {\n         let title = get_section_title(mismatch.line_number);\n@@ -145,7 +148,8 @@ fn print_diff_fancy<F>(diff: Vec<Mismatch>,\n }\n \n pub fn print_diff_basic<F>(diff: Vec<Mismatch>, get_section_title: F)\n-    where F: Fn(u32) -> String\n+where\n+    F: Fn(u32) -> String,\n {\n     for mismatch in diff {\n         let title = get_section_title(mismatch.line_number);"}, {"sha": "904260e81820462c987f9b27c07f7fd2c00d1b8a", "filename": "src/string.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -42,10 +42,12 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n \n     // `cur_start` is the position in `orig` of the start of the current line.\n     let mut cur_start = 0;\n-    let mut result = String::with_capacity(stripped_str\n-                                               .len()\n-                                               .checked_next_power_of_two()\n-                                               .unwrap_or(usize::max_value()));\n+    let mut result = String::with_capacity(\n+        stripped_str\n+            .len()\n+            .checked_next_power_of_two()\n+            .unwrap_or(usize::max_value()),\n+    );\n     result.push_str(fmt.opener);\n \n     let ender_length = fmt.line_end.len();\n@@ -81,7 +83,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n                     if cur_end < cur_start + MIN_STRING {\n                         cur_end = cur_start + max_chars;\n                         while !(punctuation.contains(graphemes[cur_end - 1]) ||\n-                                graphemes[cur_end - 1].trim().is_empty()) {\n+                              graphemes[cur_end - 1].trim().is_empty())\n+                        {\n                             if cur_end >= graphemes.len() {\n                                 let line = &graphemes[cur_start..].join(\"\");\n                                 result.push_str(line);"}, {"sha": "5a169f8b80c314cc75ff8ca3567b448973662b3a", "filename": "src/summary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsummary.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -54,7 +54,7 @@ impl Summary {\n \n     pub fn has_no_errors(&self) -> bool {\n         !(self.has_operational_errors || self.has_parsing_errors || self.has_formatting_errors ||\n-          self.has_diff)\n+              self.has_diff)\n     }\n \n     pub fn add(&mut self, other: Summary) {"}, {"sha": "f54e1c96edac7f45c8374895abd3e24be3d3ac6e", "filename": "src/types.rs", "status": "modified", "additions": 267, "deletions": 202, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -34,20 +34,21 @@ pub enum PathContext {\n }\n \n // Does not wrap on simple segments.\n-pub fn rewrite_path(context: &RewriteContext,\n-                    path_context: PathContext,\n-                    qself: Option<&ast::QSelf>,\n-                    path: &ast::Path,\n-                    shape: Shape)\n-                    -> Option<String> {\n+pub fn rewrite_path(\n+    context: &RewriteContext,\n+    path_context: PathContext,\n+    qself: Option<&ast::QSelf>,\n+    path: &ast::Path,\n+    shape: Shape,\n+) -> Option<String> {\n     let skip_count = qself.map_or(0, |x| x.position);\n \n-    let mut result = if path.is_global() && qself.is_none() &&\n-                        path_context != PathContext::Import {\n-        \"::\".to_owned()\n-    } else {\n-        String::new()\n-    };\n+    let mut result =\n+        if path.is_global() && qself.is_none() && path_context != PathContext::Import {\n+            \"::\".to_owned()\n+        } else {\n+            String::new()\n+        };\n \n     let mut span_lo = path.span.lo;\n \n@@ -70,13 +71,15 @@ pub fn rewrite_path(context: &RewriteContext,\n             // 3 = \">::\".len()\n             let shape = try_opt!(try_opt!(shape.shrink_left(extra_offset)).sub_width(3));\n \n-            result = try_opt!(rewrite_path_segments(PathContext::Type,\n-                                                    result,\n-                                                    path.segments.iter().take(skip_count),\n-                                                    span_lo,\n-                                                    path.span.hi,\n-                                                    context,\n-                                                    shape));\n+            result = try_opt!(rewrite_path_segments(\n+                PathContext::Type,\n+                result,\n+                path.segments.iter().take(skip_count),\n+                span_lo,\n+                path.span.hi,\n+                context,\n+                shape,\n+            ));\n         }\n \n         if context.config.spaces_within_angle_brackets() {\n@@ -87,24 +90,28 @@ pub fn rewrite_path(context: &RewriteContext,\n         span_lo = qself.ty.span.hi + BytePos(1);\n     }\n \n-    rewrite_path_segments(path_context,\n-                          result,\n-                          path.segments.iter().skip(skip_count),\n-                          span_lo,\n-                          path.span.hi,\n-                          context,\n-                          shape)\n+    rewrite_path_segments(\n+        path_context,\n+        result,\n+        path.segments.iter().skip(skip_count),\n+        span_lo,\n+        path.span.hi,\n+        context,\n+        shape,\n+    )\n }\n \n-fn rewrite_path_segments<'a, I>(path_context: PathContext,\n-                                mut buffer: String,\n-                                iter: I,\n-                                mut span_lo: BytePos,\n-                                span_hi: BytePos,\n-                                context: &RewriteContext,\n-                                shape: Shape)\n-                                -> Option<String>\n-    where I: Iterator<Item = &'a ast::PathSegment>\n+fn rewrite_path_segments<'a, I>(\n+    path_context: PathContext,\n+    mut buffer: String,\n+    iter: I,\n+    mut span_lo: BytePos,\n+    span_hi: BytePos,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String>\n+where\n+    I: Iterator<Item = &'a ast::PathSegment>,\n {\n     let mut first = true;\n     let shape = shape.visual_indent(0);\n@@ -122,12 +129,14 @@ fn rewrite_path_segments<'a, I>(path_context: PathContext,\n \n         let extra_offset = extra_offset(&buffer, shape);\n         let new_shape = try_opt!(shape.shrink_left(extra_offset));\n-        let segment_string = try_opt!(rewrite_segment(path_context,\n-                                                      segment,\n-                                                      &mut span_lo,\n-                                                      span_hi,\n-                                                      context,\n-                                                      new_shape));\n+        let segment_string = try_opt!(rewrite_segment(\n+            path_context,\n+            segment,\n+            &mut span_lo,\n+            span_hi,\n+            context,\n+            new_shape,\n+        ));\n \n         buffer.push_str(&segment_string);\n     }\n@@ -163,10 +172,10 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n                 let budget = try_opt!(shape.width.checked_sub(result.len()));\n-                let rewrite = try_opt!(binding.ty.rewrite(context,\n-                                                          Shape::legacy(budget,\n-                                                                        shape.indent +\n-                                                                        result.len())));\n+                let rewrite = try_opt!(binding.ty.rewrite(\n+                    context,\n+                    Shape::legacy(budget, shape.indent + result.len()),\n+                ));\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -184,21 +193,22 @@ impl<'a> Rewrite for SegmentParam<'a> {\n //\n // When the segment contains a positive number of parameters, we update span_lo\n // so that invariants described above will hold for the next segment.\n-fn rewrite_segment(path_context: PathContext,\n-                   segment: &ast::PathSegment,\n-                   span_lo: &mut BytePos,\n-                   span_hi: BytePos,\n-                   context: &RewriteContext,\n-                   shape: Shape)\n-                   -> Option<String> {\n+fn rewrite_segment(\n+    path_context: PathContext,\n+    segment: &ast::PathSegment,\n+    span_lo: &mut BytePos,\n+    span_hi: BytePos,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let ident_len = segment.identifier.to_string().len();\n     let shape = try_opt!(shape.shrink_left(ident_len));\n \n     let params = if let Some(ref params) = segment.parameters {\n         match **params {\n             ast::PathParameters::AngleBracketed(ref data) if !data.lifetimes.is_empty() ||\n-                                                             !data.types.is_empty() ||\n-                                                             !data.bindings.is_empty() => {\n+                                                                 !data.types.is_empty() ||\n+                                                                 !data.bindings.is_empty() => {\n                 let param_list = data.lifetimes\n                     .iter()\n                     .map(SegmentParam::LifeTime)\n@@ -239,12 +249,14 @@ fn rewrite_segment(path_context: PathContext,\n                     Some(ref ty) => FunctionRetTy::Ty(ty.clone()),\n                     None => FunctionRetTy::Default(codemap::DUMMY_SP),\n                 };\n-                try_opt!(format_function_type(data.inputs.iter().map(|x| &**x),\n-                                              &output,\n-                                              false,\n-                                              data.span,\n-                                              context,\n-                                              shape))\n+                try_opt!(format_function_type(\n+                    data.inputs.iter().map(|x| &**x),\n+                    &output,\n+                    false,\n+                    data.span,\n+                    context,\n+                    shape,\n+                ))\n             }\n             _ => String::new(),\n         }\n@@ -255,22 +267,25 @@ fn rewrite_segment(path_context: PathContext,\n     Some(format!(\"{}{}\", segment.identifier, params))\n }\n \n-fn format_function_type<'a, I>(inputs: I,\n-                               output: &FunctionRetTy,\n-                               variadic: bool,\n-                               span: Span,\n-                               context: &RewriteContext,\n-                               shape: Shape)\n-                               -> Option<String>\n-    where I: ExactSizeIterator,\n-          <I as Iterator>::Item: Deref,\n-          <I::Item as Deref>::Target: Rewrite + Spanned + 'a\n+fn format_function_type<'a, I>(\n+    inputs: I,\n+    output: &FunctionRetTy,\n+    variadic: bool,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String>\n+where\n+    I: ExactSizeIterator,\n+    <I as Iterator>::Item: Deref,\n+    <I::Item as Deref>::Target: Rewrite + Spanned + 'a,\n {\n     // Code for handling variadics is somewhat duplicated for items, but they\n     // are different enough to need some serious refactoring to share code.\n     enum ArgumentKind<T>\n-        where T: Deref,\n-              <T as Deref>::Target: Rewrite + Spanned\n+    where\n+        T: Deref,\n+        <T as Deref>::Target: Rewrite + Spanned,\n     {\n         Regular(Box<T>),\n         Variadic(BytePos),\n@@ -288,31 +303,35 @@ fn format_function_type<'a, I>(inputs: I,\n     // 1 for (\n     let offset = shape.indent + 1;\n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let items = itemize_list(context.codemap,\n-                             // FIXME Would be nice to avoid this allocation,\n-                             // but I couldn't get the types to work out.\n-                             inputs\n-                                 .map(|i| ArgumentKind::Regular(Box::new(i)))\n-                                 .chain(variadic_arg),\n-                             \")\",\n-                             |arg| match *arg {\n-                                 ArgumentKind::Regular(ref ty) => ty.span().lo,\n-                                 ArgumentKind::Variadic(start) => start,\n-                             },\n-                             |arg| match *arg {\n-                                 ArgumentKind::Regular(ref ty) => ty.span().hi,\n-                                 ArgumentKind::Variadic(start) => start + BytePos(3),\n-                             },\n-                             |arg| match *arg {\n-                                 ArgumentKind::Regular(ref ty) => {\n-                                     ty.rewrite(context, Shape::legacy(budget, offset))\n-                                 }\n-                                 ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n-                             },\n-                             list_lo,\n-                             span.hi);\n-\n-    let list_str = try_opt!(format_fn_args(items, Shape::legacy(budget, offset), context.config));\n+    let items = itemize_list(\n+        context.codemap,\n+        // FIXME Would be nice to avoid this allocation,\n+        // but I couldn't get the types to work out.\n+        inputs\n+            .map(|i| ArgumentKind::Regular(Box::new(i)))\n+            .chain(variadic_arg),\n+        \")\",\n+        |arg| match *arg {\n+            ArgumentKind::Regular(ref ty) => ty.span().lo,\n+            ArgumentKind::Variadic(start) => start,\n+        },\n+        |arg| match *arg {\n+            ArgumentKind::Regular(ref ty) => ty.span().hi,\n+            ArgumentKind::Variadic(start) => start + BytePos(3),\n+        },\n+        |arg| match *arg {\n+            ArgumentKind::Regular(ref ty) => ty.rewrite(context, Shape::legacy(budget, offset)),\n+            ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n+        },\n+        list_lo,\n+        span.hi,\n+    );\n+\n+    let list_str = try_opt!(format_fn_args(\n+        items,\n+        Shape::legacy(budget, offset),\n+        context.config,\n+    ));\n \n     let output = match *output {\n         FunctionRetTy::Ty(ref ty) => {\n@@ -329,16 +348,20 @@ fn format_function_type<'a, I>(inputs: I,\n         String::new()\n     };\n \n-    Some(if context.config.spaces_within_parens() {\n-             format!(\"( {} ){}{}\", list_str, infix, output)\n-         } else {\n-             format!(\"({}){}{}\", list_str, infix, output)\n-         })\n+    Some(\n+        if context.config.spaces_within_parens() {\n+            format!(\"( {} ){}{}\", list_str, infix, output)\n+        } else {\n+            format!(\"({}){}{}\", list_str, infix, output)\n+        },\n+    )\n }\n \n fn type_bound_colon(context: &RewriteContext) -> &'static str {\n-    colon_spaces(context.config.space_before_bound(),\n-                 context.config.space_after_bound_colon())\n+    colon_spaces(\n+        context.config.space_before_bound(),\n+        context.config.space_after_bound_colon(),\n+    )\n }\n \n impl Rewrite for ast::WherePredicate {\n@@ -356,11 +379,12 @@ impl Rewrite for ast::WherePredicate {\n                 let colon = type_bound_colon(context);\n \n                 if !bound_lifetimes.is_empty() {\n-                    let lifetime_str: String = try_opt!(bound_lifetimes\n-                                                            .iter()\n-                                                            .map(|lt| lt.rewrite(context, shape))\n-                                                            .collect::<Option<Vec<_>>>())\n-                        .join(\", \");\n+                    let lifetime_str: String = try_opt!(\n+                        bound_lifetimes\n+                            .iter()\n+                            .map(|lt| lt.rewrite(context, shape))\n+                            .collect::<Option<Vec<_>>>()\n+                    ).join(\", \");\n \n                     // 6 = \"for<> \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n@@ -373,11 +397,13 @@ impl Rewrite for ast::WherePredicate {\n                     let bounds_str = join_bounds(context, ty_shape, &bounds);\n \n                     if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n-                        format!(\"for< {} > {}{}{}\",\n-                                lifetime_str,\n-                                type_str,\n-                                colon,\n-                                bounds_str)\n+                        format!(\n+                            \"for< {} > {}{}{}\",\n+                            lifetime_str,\n+                            type_str,\n+                            colon,\n+                            bounds_str\n+                        )\n                     } else {\n                         format!(\"for<{}> {}{}{}\", lifetime_str, type_str, colon, bounds_str)\n                     }\n@@ -402,7 +428,12 @@ impl Rewrite for ast::WherePredicate {\n                                                      ref bounds,\n                                                      ..\n                                                  }) => {\n-                try_opt!(rewrite_bounded_lifetime(lifetime, bounds.iter(), context, shape))\n+                try_opt!(rewrite_bounded_lifetime(\n+                    lifetime,\n+                    bounds.iter(),\n+                    context,\n+                    shape,\n+                ))\n             }\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                                                  ref lhs_ty,\n@@ -413,9 +444,10 @@ impl Rewrite for ast::WherePredicate {\n                 // 3 = \" = \".len()\n                 let used_width = 3 + lhs_ty_str.len();\n                 let budget = try_opt!(shape.width.checked_sub(used_width));\n-                let rhs_ty_str = try_opt!(rhs_ty.rewrite(context,\n-                                                         Shape::legacy(budget,\n-                                                                       shape.indent + used_width)));\n+                let rhs_ty_str = try_opt!(rhs_ty.rewrite(\n+                    context,\n+                    Shape::legacy(budget, shape.indent + used_width),\n+                ));\n                 format!(\"{} = {}\", lhs_ty_str, rhs_ty_str)\n             }\n         };\n@@ -430,22 +462,26 @@ impl Rewrite for ast::LifetimeDef {\n     }\n }\n \n-fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n-                                   bounds: I,\n-                                   context: &RewriteContext,\n-                                   shape: Shape)\n-                                   -> Option<String>\n-    where I: ExactSizeIterator<Item = &'b ast::Lifetime>\n+fn rewrite_bounded_lifetime<'b, I>(\n+    lt: &ast::Lifetime,\n+    bounds: I,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String>\n+where\n+    I: ExactSizeIterator<Item = &'b ast::Lifetime>,\n {\n     let result = try_opt!(lt.rewrite(context, shape));\n \n     if bounds.len() == 0 {\n         Some(result)\n     } else {\n-        let appendix: Vec<_> = try_opt!(bounds\n-                                            .into_iter()\n-                                            .map(|b| b.rewrite(context, shape))\n-                                            .collect());\n+        let appendix: Vec<_> = try_opt!(\n+            bounds\n+                .into_iter()\n+                .map(|b| b.rewrite(context, shape))\n+                .collect()\n+        );\n         let colon = type_bound_colon(context);\n         let overhead = last_line_width(&result) + colon.len();\n         let result = format!(\"{}{}{}\",\n@@ -464,9 +500,13 @@ impl Rewrite for ast::TyParamBound {\n             }\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n                 let budget = try_opt!(shape.width.checked_sub(1));\n-                Some(format!(\"?{}\",\n-                             try_opt!(tref.rewrite(context,\n-                                                   Shape::legacy(budget, shape.indent + 1)))))\n+                Some(format!(\n+                    \"?{}\",\n+                    try_opt!(tref.rewrite(\n+                        context,\n+                        Shape::legacy(budget, shape.indent + 1),\n+                    ))\n+                ))\n             }\n             ast::TyParamBound::RegionTyParamBound(ref l) => l.rewrite(context, shape),\n         }\n@@ -475,9 +515,11 @@ impl Rewrite for ast::TyParamBound {\n \n impl Rewrite for ast::Lifetime {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        wrap_str(pprust::lifetime_to_string(self),\n-                 context.config.max_width(),\n-                 shape)\n+        wrap_str(\n+            pprust::lifetime_to_string(self),\n+            context.config.max_width(),\n+            shape,\n+        )\n     }\n }\n \n@@ -514,8 +556,10 @@ impl Rewrite for ast::TyParam {\n             };\n             result.push_str(eq_str);\n             let budget = try_opt!(shape.width.checked_sub(result.len()));\n-            let rewrite = try_opt!(def.rewrite(context,\n-                                               Shape::legacy(budget, shape.indent + result.len())));\n+            let rewrite = try_opt!(def.rewrite(\n+                context,\n+                Shape::legacy(budget, shape.indent + result.len()),\n+            ));\n             result.push_str(&rewrite);\n         }\n \n@@ -526,25 +570,31 @@ impl Rewrite for ast::TyParam {\n impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n-            let lifetime_str: String = try_opt!(self.bound_lifetimes\n-                                                    .iter()\n-                                                    .map(|lt| lt.rewrite(context, shape))\n-                                                    .collect::<Option<Vec<_>>>())\n-                .join(\", \");\n+            let lifetime_str: String = try_opt!(\n+                self.bound_lifetimes\n+                    .iter()\n+                    .map(|lt| lt.rewrite(context, shape))\n+                    .collect::<Option<Vec<_>>>()\n+            ).join(\", \");\n \n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(shape.width.checked_sub(extra_offset));\n-            let path_str = try_opt!(self.trait_ref.rewrite(context,\n-                                                           Shape::legacy(max_path_width,\n-                                                                         shape.indent +\n-                                                                         extra_offset)));\n-\n-            Some(if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n-                     format!(\"for< {} > {}\", lifetime_str, path_str)\n-                 } else {\n-                     format!(\"for<{}> {}\", lifetime_str, path_str)\n-                 })\n+            let path_str = try_opt!(self.trait_ref.rewrite(\n+                context,\n+                Shape::legacy(\n+                    max_path_width,\n+                    shape.indent + extra_offset,\n+                ),\n+            ));\n+\n+            Some(\n+                if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n+                    format!(\"for< {} > {}\", lifetime_str, path_str)\n+                } else {\n+                    format!(\"for<{}> {}\", lifetime_str, path_str)\n+                },\n+            )\n         } else {\n             self.trait_ref.rewrite(context, shape)\n         }\n@@ -573,44 +623,50 @@ impl Rewrite for ast::Ty {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n-                         Some(ref lifetime) => {\n-                             let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n-                             let lt_str = try_opt!(lifetime.rewrite(context,\n-                                                                    Shape::legacy(lt_budget,\n-                                                                                  shape.indent + 2 +\n-                                                                                  mut_len)));\n-                             let lt_len = lt_str.len();\n-                             let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n-                             format!(\"&{} {}{}\",\n-                                     lt_str,\n-                                     mut_str,\n-                                     try_opt!(mt.ty.rewrite(context,\n-                                                            Shape::legacy(budget,\n-                                                                          shape.indent + 2 +\n-                                                                          mut_len +\n-                                                                          lt_len))))\n-                         }\n-                         None => {\n-                             let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n-                             format!(\"&{}{}\",\n-                                     mut_str,\n-                                     try_opt!(mt.ty.rewrite(context,\n-                                                            Shape::legacy(budget,\n-                                                                          shape.indent + 1 +\n-                                                                          mut_len))))\n-                         }\n-                     })\n+                    Some(ref lifetime) => {\n+                        let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n+                        let lt_str = try_opt!(lifetime.rewrite(\n+                            context,\n+                            Shape::legacy(lt_budget, shape.indent + 2 + mut_len),\n+                        ));\n+                        let lt_len = lt_str.len();\n+                        let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n+                        format!(\n+                            \"&{} {}{}\",\n+                            lt_str,\n+                            mut_str,\n+                            try_opt!(mt.ty.rewrite(\n+                                context,\n+                                Shape::legacy(\n+                                    budget,\n+                                    shape.indent + 2 + mut_len + lt_len,\n+                                ),\n+                            ))\n+                        )\n+                    }\n+                    None => {\n+                        let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n+                        format!(\n+                            \"&{}{}\",\n+                            mut_str,\n+                            try_opt!(mt.ty.rewrite(\n+                                context,\n+                                Shape::legacy(budget, shape.indent + 1 + mut_len),\n+                            ))\n+                        )\n+                    }\n+                })\n             }\n             // FIXME: we drop any comments here, even though it's a silly place to put\n             // comments.\n             ast::TyKind::Paren(ref ty) => {\n                 let budget = try_opt!(shape.width.checked_sub(2));\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_parens() {\n-                             format!(\"( {} )\", ty_str)\n-                         } else {\n-                             format!(\"({})\", ty_str)\n-                         })\n+                        format!(\"( {} )\", ty_str)\n+                    } else {\n+                        format!(\"({})\", ty_str)\n+                    })\n             }\n             ast::TyKind::Slice(ref ty) => {\n                 let budget = if context.config.spaces_within_square_brackets() {\n@@ -620,10 +676,10 @@ impl Rewrite for ast::Ty {\n                 };\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_square_brackets() {\n-                             format!(\"[ {} ]\", ty_str)\n-                         } else {\n-                             format!(\"[{}]\", ty_str)\n-                         })\n+                        format!(\"[ {} ]\", ty_str)\n+                    } else {\n+                        format!(\"[{}]\", ty_str)\n+                    })\n             }\n             ast::TyKind::Tup(ref items) => {\n                 rewrite_tuple_type(context, items.iter().map(|x| &**x), self.span, shape)\n@@ -649,20 +705,22 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Mac(..) => None,\n             ast::TyKind::ImplicitSelf => Some(String::from(\"\")),\n             ast::TyKind::ImplTrait(ref it) => {\n-                it.rewrite(context, shape)\n-                    .map(|it_str| format!(\"impl {}\", it_str))\n+                it.rewrite(context, shape).map(|it_str| {\n+                    format!(\"impl {}\", it_str)\n+                })\n             }\n             ast::TyKind::Err |\n             ast::TyKind::Typeof(..) => unreachable!(),\n         }\n     }\n }\n \n-fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n-                   span: Span,\n-                   context: &RewriteContext,\n-                   shape: Shape)\n-                   -> Option<String> {\n+fn rewrite_bare_fn(\n+    bare_fn: &ast::BareFnTy,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n     let mut result = String::with_capacity(128);\n \n     if !bare_fn.lifetimes.is_empty() {\n@@ -675,8 +733,10 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n                 .lifetimes\n                 .iter()\n                 .map(|l| {\n-                    l.rewrite(context,\n-                              Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4))\n+                    l.rewrite(\n+                        context,\n+                        Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4),\n+                    )\n                 })\n                 .collect::<Option<Vec<_>>>()\n         ).join(\", \"));\n@@ -686,20 +746,25 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n     result.push_str(::utils::format_unsafety(bare_fn.unsafety));\n \n     if bare_fn.abi != abi::Abi::Rust {\n-        result.push_str(&::utils::format_abi(bare_fn.abi, context.config.force_explicit_abi()));\n+        result.push_str(&::utils::format_abi(\n+            bare_fn.abi,\n+            context.config.force_explicit_abi(),\n+        ));\n     }\n \n     result.push_str(\"fn\");\n \n     let budget = try_opt!(shape.width.checked_sub(result.len()));\n     let indent = shape.indent + result.len();\n \n-    let rewrite = try_opt!(format_function_type(bare_fn.decl.inputs.iter(),\n-                                                &bare_fn.decl.output,\n-                                                bare_fn.decl.variadic,\n-                                                span,\n-                                                context,\n-                                                Shape::legacy(budget, indent)));\n+    let rewrite = try_opt!(format_function_type(\n+        bare_fn.decl.inputs.iter(),\n+        &bare_fn.decl.output,\n+        bare_fn.decl.variadic,\n+        span,\n+        context,\n+        Shape::legacy(budget, indent),\n+    ));\n \n     result.push_str(&rewrite);\n "}, {"sha": "0d1b32570c8312aec62c27b5352c2db11ae38492", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -44,9 +44,9 @@ pub fn format_visibility(vis: &Visibility) -> Cow<'static, str> {\n             let Path { ref segments, .. } = **path;\n             let mut segments_iter = segments.iter().map(|seg| seg.identifier.name.to_string());\n             if path.is_global() {\n-                segments_iter\n-                    .next()\n-                    .expect(\"Non-global path in pub(restricted)?\");\n+                segments_iter.next().expect(\n+                    \"Non-global path in pub(restricted)?\",\n+                );\n             }\n             let is_keyword = |s: &str| s == \"self\" || s == \"super\";\n             let path = segments_iter.collect::<Vec<_>>().join(\"::\");\n@@ -128,9 +128,9 @@ fn is_skip_nested(meta_item: &NestedMetaItem) -> bool {\n \n #[inline]\n pub fn contains_skip(attrs: &[Attribute]) -> bool {\n-    attrs\n-        .iter()\n-        .any(|a| a.meta().map_or(false, |a| is_skip(&a)))\n+    attrs.iter().any(\n+        |a| a.meta().map_or(false, |a| is_skip(&a)),\n+    )\n }\n \n // Find the end of a TyParam\n@@ -333,7 +333,8 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n                 // A special check for the last line, since the caller may\n                 // place trailing characters on this line.\n                 if snippet.lines().rev().next().unwrap().len() >\n-                   shape.indent.width() + shape.width {\n+                    shape.indent.width() + shape.width\n+                {\n                     return None;\n                 }\n             }\n@@ -355,7 +356,8 @@ impl Rewrite for String {\n // whether the `guess' was too high (Ordering::Less), or too low.\n // This function is guaranteed to try to the hi value first.\n pub fn binary_search<C, T>(mut lo: usize, mut hi: usize, callback: C) -> Option<T>\n-    where C: Fn(usize) -> Result<T, Ordering>\n+where\n+    C: Fn(usize) -> Result<T, Ordering>,\n {\n     let mut middle = hi;\n "}, {"sha": "6358cc7531fa382b715eddb8210e12d3dd894feb", "filename": "src/visitor.rs", "status": "modified", "additions": 270, "deletions": 222, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f512948a03cd24c2f8a056be0a2f53675802fd2/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=1f512948a03cd24c2f8a056be0a2f53675802fd2", "patch": "@@ -36,16 +36,16 @@ fn is_use_item(item: &ast::Item) -> bool {\n }\n \n fn item_bound(item: &ast::Item) -> Span {\n-    item.attrs\n-        .iter()\n-        .map(|attr| attr.span)\n-        .fold(item.span, |bound, span| {\n+    item.attrs.iter().map(|attr| attr.span).fold(\n+        item.span,\n+        |bound, span| {\n             Span {\n                 lo: cmp::min(bound.lo, span.lo),\n                 hi: cmp::max(bound.hi, span.hi),\n                 ctxt: span.ctxt,\n             }\n-        })\n+        },\n+    )\n }\n \n pub struct FmtVisitor<'a> {\n@@ -62,14 +62,19 @@ pub struct FmtVisitor<'a> {\n \n impl<'a> FmtVisitor<'a> {\n     fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n-        debug!(\"visit_stmt: {:?} {:?}\",\n-               self.codemap.lookup_char_pos(stmt.span.lo),\n-               self.codemap.lookup_char_pos(stmt.span.hi));\n+        debug!(\n+            \"visit_stmt: {:?} {:?}\",\n+            self.codemap.lookup_char_pos(stmt.span.lo),\n+            self.codemap.lookup_char_pos(stmt.span.hi)\n+        );\n \n         // FIXME(#434): Move this check to somewhere more central, eg Rewrite.\n-        if !self.config\n-               .file_lines()\n-               .intersects(&self.codemap.lookup_line_range(stmt.span)) {\n+        if !self.config.file_lines().intersects(\n+            &self.codemap.lookup_line_range(\n+                stmt.span,\n+            ),\n+        )\n+        {\n             return;\n         }\n \n@@ -80,9 +85,10 @@ impl<'a> FmtVisitor<'a> {\n             ast::StmtKind::Local(..) |\n             ast::StmtKind::Expr(..) |\n             ast::StmtKind::Semi(..) => {\n-                let rewrite =\n-                    stmt.rewrite(&self.get_context(),\n-                                 Shape::indented(self.block_indent, self.config));\n+                let rewrite = stmt.rewrite(\n+                    &self.get_context(),\n+                    Shape::indented(self.block_indent, self.config),\n+                );\n                 self.push_rewrite(stmt.span, rewrite);\n             }\n             ast::StmtKind::Mac(ref mac) => {\n@@ -94,9 +100,11 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     pub fn visit_block(&mut self, b: &ast::Block) {\n-        debug!(\"visit_block: {:?} {:?}\",\n-               self.codemap.lookup_char_pos(b.span.lo),\n-               self.codemap.lookup_char_pos(b.span.hi));\n+        debug!(\n+            \"visit_block: {:?} {:?}\",\n+            self.codemap.lookup_char_pos(b.span.lo),\n+            self.codemap.lookup_char_pos(b.span.hi)\n+        );\n \n         // Check if this block has braces.\n         let snippet = self.snippet(b.span);\n@@ -157,42 +165,48 @@ impl<'a> FmtVisitor<'a> {\n \n     // Note that this only gets called for function definitions. Required methods\n     // on traits do not get handled here.\n-    fn visit_fn(&mut self,\n-                fk: visit::FnKind,\n-                fd: &ast::FnDecl,\n-                s: Span,\n-                _: ast::NodeId,\n-                defaultness: ast::Defaultness) {\n+    fn visit_fn(\n+        &mut self,\n+        fk: visit::FnKind,\n+        fd: &ast::FnDecl,\n+        s: Span,\n+        _: ast::NodeId,\n+        defaultness: ast::Defaultness,\n+    ) {\n         let indent = self.block_indent;\n         let block;\n         let rewrite = match fk {\n             visit::FnKind::ItemFn(ident, generics, unsafety, constness, abi, vis, b) => {\n                 block = b;\n-                self.rewrite_fn(indent,\n-                                ident,\n-                                fd,\n-                                generics,\n-                                unsafety,\n-                                constness.node,\n-                                defaultness,\n-                                abi,\n-                                vis,\n-                                mk_sp(s.lo, b.span.lo),\n-                                &b)\n+                self.rewrite_fn(\n+                    indent,\n+                    ident,\n+                    fd,\n+                    generics,\n+                    unsafety,\n+                    constness.node,\n+                    defaultness,\n+                    abi,\n+                    vis,\n+                    mk_sp(s.lo, b.span.lo),\n+                    &b,\n+                )\n             }\n             visit::FnKind::Method(ident, sig, vis, b) => {\n                 block = b;\n-                self.rewrite_fn(indent,\n-                                ident,\n-                                fd,\n-                                &sig.generics,\n-                                sig.unsafety,\n-                                sig.constness.node,\n-                                defaultness,\n-                                sig.abi,\n-                                vis.unwrap_or(&ast::Visibility::Inherited),\n-                                mk_sp(s.lo, b.span.lo),\n-                                &b)\n+                self.rewrite_fn(\n+                    indent,\n+                    ident,\n+                    fd,\n+                    &sig.generics,\n+                    sig.unsafety,\n+                    sig.constness.node,\n+                    defaultness,\n+                    sig.abi,\n+                    vis.unwrap_or(&ast::Visibility::Inherited),\n+                    mk_sp(s.lo, b.span.lo),\n+                    &b,\n+                )\n             }\n             visit::FnKind::Closure(_) => unreachable!(),\n         };\n@@ -267,23 +281,28 @@ impl<'a> FmtVisitor<'a> {\n             ast::ItemKind::Impl(..) => {\n                 self.format_missing_with_indent(source!(self, item.span).lo);\n                 let snippet = self.get_context().snippet(item.span);\n-                let where_span_end =\n-                    snippet\n-                        .find_uncommented(\"{\")\n-                        .map(|x| (BytePos(x as u32)) + source!(self, item.span).lo);\n-                if let Some(impl_str) = format_impl(&self.get_context(),\n-                                                    item,\n-                                                    self.block_indent,\n-                                                    where_span_end) {\n+                let where_span_end = snippet.find_uncommented(\"{\").map(|x| {\n+                    (BytePos(x as u32)) + source!(self, item.span).lo\n+                });\n+                if let Some(impl_str) = format_impl(\n+                    &self.get_context(),\n+                    item,\n+                    self.block_indent,\n+                    where_span_end,\n+                )\n+                {\n                     self.buffer.push_str(&impl_str);\n                     self.last_pos = source!(self, item.span).hi;\n                 }\n             }\n             ast::ItemKind::Trait(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                if let Some(trait_str) = format_trait(&self.get_context(),\n-                                                      item,\n-                                                      self.block_indent) {\n+                if let Some(trait_str) = format_trait(\n+                    &self.get_context(),\n+                    item,\n+                    self.block_indent,\n+                )\n+                {\n                     self.buffer.push_str(&trait_str);\n                     self.last_pos = source!(self, item.span).hi;\n                 }\n@@ -298,19 +317,20 @@ impl<'a> FmtVisitor<'a> {\n                 let rewrite = {\n                     let indent = self.block_indent;\n                     let context = self.get_context();\n-                    ::items::format_struct(&context,\n-                                           \"struct \",\n-                                           item.ident,\n-                                           &item.vis,\n-                                           def,\n-                                           Some(generics),\n-                                           item.span,\n-                                           indent,\n-                                           None)\n-                        .map(|s| match *def {\n-                                 ast::VariantData::Tuple(..) => s + \";\",\n-                                 _ => s,\n-                             })\n+                    ::items::format_struct(\n+                        &context,\n+                        \"struct \",\n+                        item.ident,\n+                        &item.vis,\n+                        def,\n+                        Some(generics),\n+                        item.span,\n+                        indent,\n+                        None,\n+                    ).map(|s| match *def {\n+                        ast::VariantData::Tuple(..) => s + \";\",\n+                        _ => s,\n+                    })\n                 };\n                 self.push_rewrite(item.span, rewrite);\n             }\n@@ -331,53 +351,63 @@ impl<'a> FmtVisitor<'a> {\n                 self.format_foreign_mod(foreign_mod, item.span);\n             }\n             ast::ItemKind::Static(ref ty, mutability, ref expr) => {\n-                let rewrite = rewrite_static(\"static\",\n-                                             &item.vis,\n-                                             item.ident,\n-                                             ty,\n-                                             mutability,\n-                                             Some(expr),\n-                                             self.block_indent,\n-                                             item.span,\n-                                             &self.get_context());\n+                let rewrite = rewrite_static(\n+                    \"static\",\n+                    &item.vis,\n+                    item.ident,\n+                    ty,\n+                    mutability,\n+                    Some(expr),\n+                    self.block_indent,\n+                    item.span,\n+                    &self.get_context(),\n+                );\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::ItemKind::Const(ref ty, ref expr) => {\n-                let rewrite = rewrite_static(\"const\",\n-                                             &item.vis,\n-                                             item.ident,\n-                                             ty,\n-                                             ast::Mutability::Immutable,\n-                                             Some(expr),\n-                                             self.block_indent,\n-                                             item.span,\n-                                             &self.get_context());\n+                let rewrite = rewrite_static(\n+                    \"const\",\n+                    &item.vis,\n+                    item.ident,\n+                    ty,\n+                    ast::Mutability::Immutable,\n+                    Some(expr),\n+                    self.block_indent,\n+                    item.span,\n+                    &self.get_context(),\n+                );\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::ItemKind::DefaultImpl(..) => {\n                 // FIXME(#78): format impl definitions.\n             }\n             ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-                self.visit_fn(visit::FnKind::ItemFn(item.ident,\n-                                                    generics,\n-                                                    unsafety,\n-                                                    constness,\n-                                                    abi,\n-                                                    &item.vis,\n-                                                    body),\n-                              decl,\n-                              item.span,\n-                              item.id,\n-                              ast::Defaultness::Final)\n+                self.visit_fn(\n+                    visit::FnKind::ItemFn(\n+                        item.ident,\n+                        generics,\n+                        unsafety,\n+                        constness,\n+                        abi,\n+                        &item.vis,\n+                        body,\n+                    ),\n+                    decl,\n+                    item.span,\n+                    item.id,\n+                    ast::Defaultness::Final,\n+                )\n             }\n             ast::ItemKind::Ty(ref ty, ref generics) => {\n-                let rewrite = rewrite_type_alias(&self.get_context(),\n-                                                 self.block_indent,\n-                                                 item.ident,\n-                                                 ty,\n-                                                 generics,\n-                                                 &item.vis,\n-                                                 item.span);\n+                let rewrite = rewrite_type_alias(\n+                    &self.get_context(),\n+                    self.block_indent,\n+                    item.ident,\n+                    ty,\n+                    generics,\n+                    &item.vis,\n+                    item.span,\n+                );\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::ItemKind::Union(..) => {\n@@ -403,15 +433,17 @@ impl<'a> FmtVisitor<'a> {\n \n         match ti.node {\n             ast::TraitItemKind::Const(ref ty, ref expr_opt) => {\n-                let rewrite = rewrite_static(\"const\",\n-                                             &ast::Visibility::Inherited,\n-                                             ti.ident,\n-                                             ty,\n-                                             ast::Mutability::Immutable,\n-                                             expr_opt.as_ref(),\n-                                             self.block_indent,\n-                                             ti.span,\n-                                             &self.get_context());\n+                let rewrite = rewrite_static(\n+                    \"const\",\n+                    &ast::Visibility::Inherited,\n+                    ti.ident,\n+                    ty,\n+                    ast::Mutability::Immutable,\n+                    expr_opt.as_ref(),\n+                    self.block_indent,\n+                    ti.span,\n+                    &self.get_context(),\n+                );\n                 self.push_rewrite(ti.span, rewrite);\n             }\n             ast::TraitItemKind::Method(ref sig, None) => {\n@@ -420,18 +452,22 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(ti.span, rewrite);\n             }\n             ast::TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                self.visit_fn(visit::FnKind::Method(ti.ident, sig, None, body),\n-                              &sig.decl,\n-                              ti.span,\n-                              ti.id,\n-                              ast::Defaultness::Final);\n+                self.visit_fn(\n+                    visit::FnKind::Method(ti.ident, sig, None, body),\n+                    &sig.decl,\n+                    ti.span,\n+                    ti.id,\n+                    ast::Defaultness::Final,\n+                );\n             }\n             ast::TraitItemKind::Type(ref type_param_bounds, ref type_default) => {\n-                let rewrite = rewrite_associated_type(ti.ident,\n-                                                      type_default.as_ref(),\n-                                                      Some(type_param_bounds),\n-                                                      &self.get_context(),\n-                                                      self.block_indent);\n+                let rewrite = rewrite_associated_type(\n+                    ti.ident,\n+                    type_default.as_ref(),\n+                    Some(type_param_bounds),\n+                    &self.get_context(),\n+                    self.block_indent,\n+                );\n                 self.push_rewrite(ti.span, rewrite);\n             }\n             ast::TraitItemKind::Macro(ref mac) => {\n@@ -448,31 +484,37 @@ impl<'a> FmtVisitor<'a> {\n \n         match ii.node {\n             ast::ImplItemKind::Method(ref sig, ref body) => {\n-                self.visit_fn(visit::FnKind::Method(ii.ident, sig, Some(&ii.vis), body),\n-                              &sig.decl,\n-                              ii.span,\n-                              ii.id,\n-                              ii.defaultness);\n+                self.visit_fn(\n+                    visit::FnKind::Method(ii.ident, sig, Some(&ii.vis), body),\n+                    &sig.decl,\n+                    ii.span,\n+                    ii.id,\n+                    ii.defaultness,\n+                );\n             }\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n-                let rewrite = rewrite_static(\"const\",\n-                                             &ii.vis,\n-                                             ii.ident,\n-                                             ty,\n-                                             ast::Mutability::Immutable,\n-                                             Some(expr),\n-                                             self.block_indent,\n-                                             ii.span,\n-                                             &self.get_context());\n+                let rewrite = rewrite_static(\n+                    \"const\",\n+                    &ii.vis,\n+                    ii.ident,\n+                    ty,\n+                    ast::Mutability::Immutable,\n+                    Some(expr),\n+                    self.block_indent,\n+                    ii.span,\n+                    &self.get_context(),\n+                );\n                 self.push_rewrite(ii.span, rewrite);\n             }\n             ast::ImplItemKind::Type(ref ty) => {\n-                let rewrite = rewrite_associated_impl_type(ii.ident,\n-                                                           ii.defaultness,\n-                                                           Some(ty),\n-                                                           None,\n-                                                           &self.get_context(),\n-                                                           self.block_indent);\n+                let rewrite = rewrite_associated_impl_type(\n+                    ii.ident,\n+                    ii.defaultness,\n+                    Some(ty),\n+                    None,\n+                    &self.get_context(),\n+                    self.block_indent,\n+                );\n                 self.push_rewrite(ii.span, rewrite);\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n@@ -493,9 +535,10 @@ impl<'a> FmtVisitor<'a> {\n     fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n         self.format_missing_with_indent(source!(self, span).lo);\n         self.failed = match rewrite {\n-            Some(ref s) if s.rewrite(&self.get_context(),\n-                                     Shape::indented(self.block_indent, self.config))\n-                               .is_none() => true,\n+            Some(ref s) if s.rewrite(\n+                &self.get_context(),\n+                Shape::indented(self.block_indent, self.config),\n+            ).is_none() => true,\n             None => true,\n             _ => self.failed,\n         };\n@@ -521,9 +564,11 @@ impl<'a> FmtVisitor<'a> {\n         match self.codemap.span_to_snippet(span) {\n             Ok(s) => s,\n             Err(_) => {\n-                println!(\"Couldn't make snippet for span {:?}->{:?}\",\n-                         self.codemap.lookup_char_pos(span.lo),\n-                         self.codemap.lookup_char_pos(span.hi));\n+                println!(\n+                    \"Couldn't make snippet for span {:?}->{:?}\",\n+                    self.codemap.lookup_char_pos(span.lo),\n+                    self.codemap.lookup_char_pos(span.hi)\n+                );\n                 \"\".to_owned()\n             }\n         }\n@@ -548,8 +593,10 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing_with_indent(source!(self, first.span).lo);\n \n         let rewrite = outers\n-            .rewrite(&self.get_context(),\n-                     Shape::indented(self.block_indent, self.config))\n+            .rewrite(\n+                &self.get_context(),\n+                Shape::indented(self.block_indent, self.config),\n+            )\n             .unwrap();\n         self.buffer.push_str(&rewrite);\n         let last = outers.last().unwrap();\n@@ -570,13 +617,13 @@ impl<'a> FmtVisitor<'a> {\n                     .iter()\n                     .take_while(|ppi| {\n                         is_use_item(&***ppi) &&\n-                        (!reorder_imports_in_group ||\n-                         {\n-                             let current = self.codemap.lookup_line_range(item_bound(&ppi));\n-                             let in_same_group = current.lo < last.hi + 2;\n-                             last = current;\n-                             in_same_group\n-                         })\n+                            (!reorder_imports_in_group ||\n+                                 {\n+                                     let current = self.codemap.lookup_line_range(item_bound(&ppi));\n+                                     let in_same_group = current.lo < last.hi + 2;\n+                                     last = current;\n+                                     in_same_group\n+                                 })\n                     })\n                     .count();\n                 let (use_items, rest) = items_left.split_at(use_item_length);\n@@ -597,7 +644,7 @@ impl<'a> FmtVisitor<'a> {\n         let local_file_name = self.codemap.span_to_filename(s);\n         let inner_span = source!(self, m.inner);\n         let is_internal = !(inner_span.lo.0 == 0 && inner_span.hi.0 == 0) &&\n-                          local_file_name == self.codemap.span_to_filename(inner_span);\n+            local_file_name == self.codemap.span_to_filename(inner_span);\n \n         self.buffer.push_str(&*utils::format_visibility(vis));\n         self.buffer.push_str(\"mod \");\n@@ -658,66 +705,65 @@ impl Rewrite for ast::NestedMetaItem {\n impl Rewrite for ast::MetaItem {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         Some(match self.node {\n-                 ast::MetaItemKind::Word => String::from(&*self.name.as_str()),\n-                 ast::MetaItemKind::List(ref list) => {\n-                     let name = self.name.as_str();\n-                     // 3 = `#[` and `(`, 2 = `]` and `)`\n-                     let item_shape = try_opt!(shape\n-                                                   .shrink_left(name.len() + 3)\n-                                                   .and_then(|s| s.sub_width(2)));\n-                     let items = itemize_list(context.codemap,\n-                                              list.iter(),\n-                                              \")\",\n-                                              |nested_meta_item| nested_meta_item.span.lo,\n-                                              |nested_meta_item| nested_meta_item.span.hi,\n-                                              |nested_meta_item| {\n-                                                  nested_meta_item.rewrite(context, item_shape)\n-                                              },\n-                                              self.span.lo,\n-                                              self.span.hi);\n-                     let item_vec = items.collect::<Vec<_>>();\n-                     let fmt = ListFormatting {\n-                         tactic: DefinitiveListTactic::Mixed,\n-                         separator: \",\",\n-                         trailing_separator: SeparatorTactic::Never,\n-                         shape: item_shape,\n-                         ends_with_newline: false,\n-                         config: context.config,\n-                     };\n-                     format!(\"{}({})\", name, try_opt!(write_list(&item_vec, &fmt)))\n-                 }\n-                 ast::MetaItemKind::NameValue(ref literal) => {\n-                     let name = self.name.as_str();\n-                     let value = context.snippet(literal.span);\n-                     if &*name == \"doc\" && value.starts_with(\"///\") {\n-                         let doc_shape = Shape {\n-                             width: cmp::min(shape.width, context.config.comment_width())\n-                                 .checked_sub(shape.indent.width())\n-                                 .unwrap_or(0),\n-                             ..shape\n-                         };\n-                         format!(\"{}\",\n-                                 try_opt!(rewrite_comment(&value,\n-                                                          false,\n-                                                          doc_shape,\n-                                                          context.config)))\n-                     } else {\n-                         format!(\"{} = {}\", name, value)\n-                     }\n-                 }\n-             })\n+            ast::MetaItemKind::Word => String::from(&*self.name.as_str()),\n+            ast::MetaItemKind::List(ref list) => {\n+                let name = self.name.as_str();\n+                // 3 = `#[` and `(`, 2 = `]` and `)`\n+                let item_shape = try_opt!(shape.shrink_left(name.len() + 3).and_then(\n+                    |s| s.sub_width(2),\n+                ));\n+                let items = itemize_list(\n+                    context.codemap,\n+                    list.iter(),\n+                    \")\",\n+                    |nested_meta_item| nested_meta_item.span.lo,\n+                    |nested_meta_item| nested_meta_item.span.hi,\n+                    |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n+                    self.span.lo,\n+                    self.span.hi,\n+                );\n+                let item_vec = items.collect::<Vec<_>>();\n+                let fmt = ListFormatting {\n+                    tactic: DefinitiveListTactic::Mixed,\n+                    separator: \",\",\n+                    trailing_separator: SeparatorTactic::Never,\n+                    shape: item_shape,\n+                    ends_with_newline: false,\n+                    config: context.config,\n+                };\n+                format!(\"{}({})\", name, try_opt!(write_list(&item_vec, &fmt)))\n+            }\n+            ast::MetaItemKind::NameValue(ref literal) => {\n+                let name = self.name.as_str();\n+                let value = context.snippet(literal.span);\n+                if &*name == \"doc\" && value.starts_with(\"///\") {\n+                    let doc_shape = Shape {\n+                        width: cmp::min(shape.width, context.config.comment_width())\n+                            .checked_sub(shape.indent.width())\n+                            .unwrap_or(0),\n+                        ..shape\n+                    };\n+                    format!(\n+                        \"{}\",\n+                        try_opt!(rewrite_comment(&value, false, doc_shape, context.config))\n+                    )\n+                } else {\n+                    format!(\"{} = {}\", name, value)\n+                }\n+            }\n+        })\n     }\n }\n \n impl Rewrite for ast::Attribute {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        try_opt!(self.meta())\n-            .rewrite(context, shape)\n-            .map(|rw| if rw.starts_with(\"///\") {\n-                     rw\n-                 } else {\n-                     format!(\"#[{}]\", rw)\n-                 })\n+        try_opt!(self.meta()).rewrite(context, shape).map(|rw| {\n+            if rw.starts_with(\"///\") {\n+                rw\n+            } else {\n+                format!(\"#[{}]\", rw)\n+            }\n+        })\n     }\n }\n \n@@ -741,13 +787,15 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 let multi_line = a_str.starts_with(\"//\") && comment.matches('\\n').count() > 1;\n                 let comment = comment.trim();\n                 if !comment.is_empty() {\n-                    let comment =\n-                        try_opt!(rewrite_comment(comment,\n-                                                 false,\n-                                                 Shape::legacy(context.config.comment_width() -\n-                                                               shape.indent.width(),\n-                                                               shape.indent),\n-                                                 context.config));\n+                    let comment = try_opt!(rewrite_comment(\n+                        comment,\n+                        false,\n+                        Shape::legacy(\n+                            context.config.comment_width() - shape.indent.width(),\n+                            shape.indent,\n+                        ),\n+                        context.config,\n+                    ));\n                     result.push_str(&indent);\n                     result.push_str(&comment);\n                     result.push('\\n');"}]}