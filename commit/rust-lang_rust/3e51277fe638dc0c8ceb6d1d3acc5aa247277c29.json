{"sha": "3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "node_id": "C_kwDOAAsO6NoAKDNlNTEyNzdmZTYzOGRjMGM4Y2ViNmQxZDNhY2M1YWEyNDcyNzdjMjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-07T15:08:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-07T15:08:27Z"}, "message": "Auto merge of #99014 - Dylan-DPC:rollup-n84y0jk, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #96856 (Fix ProjectionElem validation)\n - #97711 (Improve soundness of rustc_arena)\n - #98507 (Finishing touches for `#[expect]` (RFC 2383))\n - #98692 (rustdoc: Cleanup more FIXMEs)\n - #98901 (incr: cache dwarf objects in work products)\n - #98930 (Make MIR basic blocks field public)\n - #98973 (Remove (unused) inherent impl anchors)\n - #98981 ( Edit `rustc_mir_dataflow::framework` documentation )\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "154863a8b942fdd94d5122362deeea3f47d75a00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/154863a8b942fdd94d5122362deeea3f47d75a00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "html_url": "https://github.com/rust-lang/rust/commit/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20dd6930134d07a5ef90393a040a1594ac8d714c", "url": "https://api.github.com/repos/rust-lang/rust/commits/20dd6930134d07a5ef90393a040a1594ac8d714c", "html_url": "https://github.com/rust-lang/rust/commit/20dd6930134d07a5ef90393a040a1594ac8d714c"}, {"sha": "6910d84bc4be42806bcc975d4089409f53438416", "url": "https://api.github.com/repos/rust-lang/rust/commits/6910d84bc4be42806bcc975d4089409f53438416", "html_url": "https://github.com/rust-lang/rust/commit/6910d84bc4be42806bcc975d4089409f53438416"}], "stats": {"total": 989, "additions": 634, "deletions": 355}, "files": [{"sha": "a5f1cbc96daa7ea19a1151f27924eb067290b32e", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -19,6 +19,7 @@\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n+#![feature(ptr_const_cast)]\n \n use smallvec::SmallVec;\n \n@@ -27,7 +28,7 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::marker::{PhantomData, Send};\n use std::mem::{self, MaybeUninit};\n-use std::ptr;\n+use std::ptr::{self, NonNull};\n use std::slice;\n \n #[inline(never)]\n@@ -55,15 +56,24 @@ pub struct TypedArena<T> {\n \n struct ArenaChunk<T = u8> {\n     /// The raw storage for the arena chunk.\n-    storage: Box<[MaybeUninit<T>]>,\n+    storage: NonNull<[MaybeUninit<T>]>,\n     /// The number of valid entries in the chunk.\n     entries: usize,\n }\n \n+unsafe impl<#[may_dangle] T> Drop for ArenaChunk<T> {\n+    fn drop(&mut self) {\n+        unsafe { Box::from_raw(self.storage.as_mut()) };\n+    }\n+}\n+\n impl<T> ArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n-        ArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n+        ArenaChunk {\n+            storage: NonNull::new(Box::into_raw(Box::new_uninit_slice(capacity))).unwrap(),\n+            entries: 0,\n+        }\n     }\n \n     /// Destroys this arena chunk.\n@@ -72,14 +82,15 @@ impl<T> ArenaChunk<T> {\n         // The branch on needs_drop() is an -O1 performance optimization.\n         // Without the branch, dropping TypedArena<u8> takes linear time.\n         if mem::needs_drop::<T>() {\n-            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut self.storage[..len]));\n+            let slice = &mut *(self.storage.as_mut());\n+            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n         }\n     }\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n     fn start(&mut self) -> *mut T {\n-        MaybeUninit::slice_as_mut_ptr(&mut self.storage)\n+        self.storage.as_ptr() as *mut T\n     }\n \n     // Returns a pointer to the end of the allocated space.\n@@ -90,7 +101,7 @@ impl<T> ArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 ptr::invalid_mut(!0)\n             } else {\n-                self.start().add(self.storage.len())\n+                self.start().add((*self.storage.as_ptr()).len())\n             }\n         }\n     }\n@@ -274,7 +285,7 @@ impl<T> TypedArena<T> {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.len().min(HUGE_PAGE / elem_size / 2);\n+                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / elem_size / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE / elem_size;\n@@ -382,7 +393,7 @@ impl DroplessArena {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.len().min(HUGE_PAGE / 2);\n+                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE;"}, {"sha": "ad61464343a4a852194420160d717d19e1c6b8ac", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -79,7 +79,11 @@ fn test_arena_alloc_nested() {\n #[test]\n pub fn test_copy() {\n     let arena = TypedArena::default();\n-    for _ in 0..100000 {\n+    #[cfg(not(miri))]\n+    const N: usize = 100000;\n+    #[cfg(miri)]\n+    const N: usize = 1000;\n+    for _ in 0..N {\n         arena.alloc(Point { x: 1, y: 2, z: 3 });\n     }\n }\n@@ -106,15 +110,23 @@ struct Noncopy {\n #[test]\n pub fn test_noncopy() {\n     let arena = TypedArena::default();\n-    for _ in 0..100000 {\n+    #[cfg(not(miri))]\n+    const N: usize = 100000;\n+    #[cfg(miri)]\n+    const N: usize = 1000;\n+    for _ in 0..N {\n         arena.alloc(Noncopy { string: \"hello world\".to_string(), array: vec![1, 2, 3, 4, 5] });\n     }\n }\n \n #[test]\n pub fn test_typed_arena_zero_sized() {\n     let arena = TypedArena::default();\n-    for _ in 0..100000 {\n+    #[cfg(not(miri))]\n+    const N: usize = 100000;\n+    #[cfg(miri)]\n+    const N: usize = 1000;\n+    for _ in 0..N {\n         arena.alloc(());\n     }\n }\n@@ -124,7 +136,11 @@ pub fn test_typed_arena_clear() {\n     let mut arena = TypedArena::default();\n     for _ in 0..10 {\n         arena.clear();\n-        for _ in 0..10000 {\n+        #[cfg(not(miri))]\n+        const N: usize = 10000;\n+        #[cfg(miri)]\n+        const N: usize = 100;\n+        for _ in 0..N {\n             arena.alloc(Point { x: 1, y: 2, z: 3 });\n         }\n     }"}, {"sha": "d2a54a646ec6d538b3ac91f1ca3cae5469acc0de", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -1628,7 +1628,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location: Location,\n         ) -> impl Iterator<Item = Location> + Captures<'tcx> + 'a {\n             if location.statement_index == 0 {\n-                let predecessors = body.predecessors()[location.block].to_vec();\n+                let predecessors = body.basic_blocks.predecessors()[location.block].to_vec();\n                 Either::Left(predecessors.into_iter().map(move |bb| body.terminator_loc(bb)))\n             } else {\n                 Either::Right(std::iter::once(Location {"}, {"sha": "721fd3e1c0fde01162cf6e186b241bbafe481bae", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -26,7 +26,7 @@ pub(super) fn generate_invalidates<'tcx>(\n \n     if let Some(all_facts) = all_facts {\n         let _prof_timer = tcx.prof.generic_activity(\"polonius_fact_generation\");\n-        let dominators = body.dominators();\n+        let dominators = body.basic_blocks.dominators();\n         let mut ig = InvalidationGenerator {\n             all_facts,\n             borrow_set,"}, {"sha": "338df3c70e340551a1fbb6e1c8109f6fb4dabfec", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -334,7 +334,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         };\n     }\n \n-    let dominators = body.dominators();\n+    let dominators = body.basic_blocks.dominators();\n \n     let mut mbcx = MirBorrowckCtxt {\n         infcx,"}, {"sha": "3795378b56861a426f354fbcaaadaa2a8593605d", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -258,7 +258,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n \n                 let block = self.cx.elements.to_location(block_start).block;\n                 self.stack.extend(\n-                    self.cx.body.predecessors()[block]\n+                    self.cx.body.basic_blocks.predecessors()[block]\n                         .iter()\n                         .map(|&pred_bb| self.cx.body.terminator_loc(pred_bb))\n                         .map(|pred_loc| self.cx.elements.point_from_location(pred_loc)),\n@@ -354,7 +354,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n \n         let body = self.cx.body;\n-        for &pred_block in body.predecessors()[block].iter() {\n+        for &pred_block in body.basic_blocks.predecessors()[block].iter() {\n             debug!(\"compute_drop_live_points_for_block: pred_block = {:?}\", pred_block,);\n \n             // Check whether the variable is (at least partially)"}, {"sha": "50d8fc30d7d7cabe13275e9a3c099834abb37c69", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -66,7 +66,11 @@ fn emit_module(\n     let work_product = if backend_config.disable_incr_cache {\n         None\n     } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(tcx.sess, &name, &tmp_file)\n+        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+            tcx.sess,\n+            &name,\n+            &[(\"o\", &tmp_file)],\n+        )\n     };\n \n     ModuleCodegenResult(\n@@ -82,7 +86,10 @@ fn reuse_workproduct_for_cgu(\n ) -> CompiledModule {\n     let work_product = cgu.previous_work_product(tcx);\n     let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-    let source_file = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, &work_product.saved_file);\n+    let source_file = rustc_incremental::in_incr_comp_dir_sess(\n+        &tcx.sess,\n+        &work_product.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n+    );\n     if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n         tcx.sess.err(&format!(\n             \"unable to copy {} to {}: {}\","}, {"sha": "960e98243ac727b8c8d8904d4271812fb9f8fe0b", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -151,11 +151,23 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n             return;\n         }\n \n-        let remove_temps_from_module = |module: &CompiledModule| {\n-            if let Some(ref obj) = module.object {\n-                ensure_removed(sess.diagnostic(), obj);\n-            }\n-        };\n+        let maybe_remove_temps_from_module =\n+            |preserve_objects: bool, preserve_dwarf_objects: bool, module: &CompiledModule| {\n+                if !preserve_objects {\n+                    if let Some(ref obj) = module.object {\n+                        ensure_removed(sess.diagnostic(), obj);\n+                    }\n+                }\n+\n+                if !preserve_dwarf_objects {\n+                    if let Some(ref dwo_obj) = module.dwarf_object {\n+                        ensure_removed(sess.diagnostic(), dwo_obj);\n+                    }\n+                }\n+            };\n+\n+        let remove_temps_from_module =\n+            |module: &CompiledModule| maybe_remove_temps_from_module(false, false, module);\n \n         // Otherwise, always remove the metadata and allocator module temporaries.\n         if let Some(ref metadata_module) = codegen_results.metadata_module {\n@@ -177,15 +189,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         debug!(?preserve_objects, ?preserve_dwarf_objects);\n \n         for module in &codegen_results.modules {\n-            if !preserve_objects {\n-                remove_temps_from_module(module);\n-            }\n-\n-            if !preserve_dwarf_objects {\n-                if let Some(ref obj) = module.dwarf_object {\n-                    ensure_removed(sess.diagnostic(), obj);\n-                }\n-            }\n+            maybe_remove_temps_from_module(preserve_objects, preserve_dwarf_objects, module);\n         }\n     });\n \n@@ -649,6 +653,7 @@ fn link_dwarf_object<'a>(\n             sess.struct_err(\"linking dwarf objects with thorin failed\")\n                 .note(&format!(\"{:?}\", e))\n                 .emit();\n+            sess.abort_if_errors();\n         }\n     }\n }"}, {"sha": "f4a5cac872e0516c2d5b7e483bd6ad3f9840fbaf", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -494,12 +494,18 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n     let _timer = sess.timer(\"copy_all_cgu_workproducts_to_incr_comp_cache_dir\");\n \n     for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        if let Some(path) = &module.object {\n-            if let Some((id, product)) =\n-                copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, path)\n-            {\n-                work_products.insert(id, product);\n-            }\n+        let mut files = Vec::new();\n+        if let Some(object_file_path) = &module.object {\n+            files.push((\"o\", object_file_path.as_path()));\n+        }\n+        if let Some(dwarf_object_file_path) = &module.dwarf_object {\n+            files.push((\"dwo\", dwarf_object_file_path.as_path()));\n+        }\n+\n+        if let Some((id, product)) =\n+            copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, files.as_slice())\n+        {\n+            work_products.insert(id, product);\n         }\n     }\n \n@@ -856,29 +862,50 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     assert!(module_config.emit_obj != EmitObj::None);\n \n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n-    let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name));\n-    let source_file = in_incr_comp_dir(&incr_comp_session_dir, &module.source.saved_file);\n-    debug!(\n-        \"copying pre-existing module `{}` from {:?} to {}\",\n-        module.name,\n-        source_file,\n-        obj_out.display()\n+\n+    let load_from_incr_comp_dir = |output_path: PathBuf, saved_path: &str| {\n+        let source_file = in_incr_comp_dir(&incr_comp_session_dir, saved_path);\n+        debug!(\n+            \"copying pre-existing module `{}` from {:?} to {}\",\n+            module.name,\n+            source_file,\n+            output_path.display()\n+        );\n+        match link_or_copy(&source_file, &output_path) {\n+            Ok(_) => Some(output_path),\n+            Err(err) => {\n+                let diag_handler = cgcx.create_diag_handler();\n+                diag_handler.err(&format!(\n+                    \"unable to copy {} to {}: {}\",\n+                    source_file.display(),\n+                    output_path.display(),\n+                    err\n+                ));\n+                None\n+            }\n+        }\n+    };\n+\n+    let object = load_from_incr_comp_dir(\n+        cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name)),\n+        &module.source.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n     );\n-    if let Err(err) = link_or_copy(&source_file, &obj_out) {\n-        let diag_handler = cgcx.create_diag_handler();\n-        diag_handler.err(&format!(\n-            \"unable to copy {} to {}: {}\",\n-            source_file.display(),\n-            obj_out.display(),\n-            err\n-        ));\n-    }\n+    let dwarf_object =\n+        module.source.saved_files.get(\"dwo\").as_ref().and_then(|saved_dwarf_object_file| {\n+            let dwarf_obj_out = cgcx\n+                .output_filenames\n+                .split_dwarf_path(cgcx.split_debuginfo, cgcx.split_dwarf_kind, Some(&module.name))\n+                .expect(\n+                    \"saved dwarf object in work product but `split_dwarf_path` returned `None`\",\n+                );\n+            load_from_incr_comp_dir(dwarf_obj_out, &saved_dwarf_object_file)\n+        });\n \n     WorkItemResult::Compiled(CompiledModule {\n         name: module.name,\n         kind: ModuleKind::Regular,\n-        object: Some(obj_out),\n-        dwarf_object: None,\n+        object,\n+        dwarf_object,\n         bytecode: None,\n     })\n }"}, {"sha": "24da48ead63a24bca4e41ec5c2e484e6b6cc00db", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -15,7 +15,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n ) -> BitSet<mir::Local> {\n     let mir = fx.mir;\n-    let dominators = mir.dominators();\n+    let dominators = mir.basic_blocks.dominators();\n     let locals = mir\n         .local_decls\n         .iter()"}, {"sha": "12527a9b2ae6602e5e2d4506b490c48c27585917", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -856,7 +856,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     literal: ConstantKind::from_const(_const, tcx),\n                 }))\n             };\n-            let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n+            let blocks = self.source.basic_blocks.as_mut();\n+            let local_decls = &mut self.source.local_decls;\n             let loc = candidate.location;\n             let statement = &mut blocks[loc.block].statements[loc.statement_index];\n             match statement.kind {\n@@ -865,7 +866,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n                 )) => {\n                     // Use the underlying local for this (necessarily interior) borrow.\n-                    let ty = local_decls.local_decls()[place.local].ty;\n+                    let ty = local_decls[place.local].ty;\n                     let span = statement.source_info.span;\n \n                     let ref_ty = tcx.mk_ref("}, {"sha": "56ecc5535285bcc5393f71d18a6b7bd6069b33e0", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::mir::{\n     Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_live_locals;\n@@ -275,7 +276,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     }\n                 };\n \n-                match parent_ty.ty.kind() {\n+                let kind = match parent_ty.ty.kind() {\n+                    &ty::Opaque(def_id, substs) => {\n+                        self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n+                    }\n+                    kind => kind,\n+                };\n+\n+                match kind {\n                     ty::Tuple(fields) => {\n                         let Some(f_ty) = fields.get(f.as_usize()) else {\n                             fail_out_of_bounds(self, location);\n@@ -299,12 +307,39 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         };\n                         check_equal(self, location, f_ty);\n                     }\n-                    ty::Generator(_, substs, _) => {\n-                        let substs = substs.as_generator();\n-                        let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n-                            fail_out_of_bounds(self, location);\n-                            return;\n+                    &ty::Generator(def_id, substs, _) => {\n+                        let f_ty = if let Some(var) = parent_ty.variant_index {\n+                            let gen_body = if def_id == self.body.source.def_id() {\n+                                self.body\n+                            } else {\n+                                self.tcx.optimized_mir(def_id)\n+                            };\n+\n+                            let Some(layout) = gen_body.generator_layout() else {\n+                                self.fail(location, format!(\"No generator layout for {:?}\", parent_ty));\n+                                return;\n+                            };\n+\n+                            let Some(&local) = layout.variant_fields[var].get(f) else {\n+                                fail_out_of_bounds(self, location);\n+                                return;\n+                            };\n+\n+                            let Some(&f_ty) = layout.field_tys.get(local) else {\n+                                self.fail(location, format!(\"Out of bounds local {:?} for {:?}\", local, parent_ty));\n+                                return;\n+                            };\n+\n+                            f_ty\n+                        } else {\n+                            let Some(f_ty) = substs.as_generator().prefix_tys().nth(f.index()) else {\n+                                fail_out_of_bounds(self, location);\n+                                return;\n+                            };\n+\n+                            f_ty\n                         };\n+\n                         check_equal(self, location, f_ty);\n                     }\n                     _ => {\n@@ -328,6 +363,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         {\n             self.fail(location, format!(\"{:?}, has deref at the wrong place\", place));\n         }\n+\n+        self.super_place(place, cntxt, location);\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {"}, {"sha": "f59d8d596b98ec1f9bcf8d50a36d0967465d7ce7", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -161,19 +161,13 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n                 Decodable::decode(&mut work_product_decoder);\n \n             for swp in work_products {\n-                let mut all_files_exist = true;\n-                let path = in_incr_comp_dir_sess(sess, &swp.work_product.saved_file);\n-                if !path.exists() {\n-                    all_files_exist = false;\n-\n-                    if sess.opts.debugging_opts.incremental_info {\n-                        eprintln!(\n-                            \"incremental: could not find file for work \\\n-                                    product: {}\",\n-                            path.display()\n-                        );\n+                let all_files_exist = swp.work_product.saved_files.iter().all(|(_, path)| {\n+                    let exists = in_incr_comp_dir_sess(sess, path).exists();\n+                    if !exists && sess.opts.debugging_opts.incremental_info {\n+                        eprintln!(\"incremental: could not find file for work product: {path}\",);\n                     }\n-                }\n+                    exists\n+                });\n \n                 if all_files_exist {\n                     debug!(\"reconcile_work_products: all files for {:?} exist\", swp);"}, {"sha": "4059b7cfc8eb9eb3d2ca072b795fffe2e619996a", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -108,16 +108,17 @@ pub fn save_work_product_index(\n     for (id, wp) in previous_work_products.iter() {\n         if !new_work_products.contains_key(id) {\n             work_product::delete_workproduct_files(sess, wp);\n-            debug_assert!(!in_incr_comp_dir_sess(sess, &wp.saved_file).exists());\n+            debug_assert!(\n+                !wp.saved_files.iter().all(|(_, path)| in_incr_comp_dir_sess(sess, path).exists())\n+            );\n         }\n     }\n \n     // Check that we did not delete one of the current work-products:\n     debug_assert!({\n-        new_work_products\n-            .iter()\n-            .map(|(_, wp)| in_incr_comp_dir_sess(sess, &wp.saved_file))\n-            .all(|path| path.exists())\n+        new_work_products.iter().all(|(_, wp)| {\n+            wp.saved_files.iter().all(|(_, path)| in_incr_comp_dir_sess(sess, path).exists())\n+        })\n     });\n }\n "}, {"sha": "1b184eca964c34fa5247205613f3aadd9ea94f36", "filename": "compiler/rustc_incremental/src/persist/work_product.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -3,6 +3,7 @@\n //! [work products]: WorkProduct\n \n use crate::persist::fs::*;\n+use rustc_data_structures::stable_map::FxHashMap;\n use rustc_fs_util::link_or_copy;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_session::Session;\n@@ -13,38 +14,41 @@ use std::path::Path;\n pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n     sess: &Session,\n     cgu_name: &str,\n-    path: &Path,\n+    files: &[(&'static str, &Path)],\n ) -> Option<(WorkProductId, WorkProduct)> {\n-    debug!(\"copy_cgu_workproduct_to_incr_comp_cache_dir({:?},{:?})\", cgu_name, path);\n+    debug!(?cgu_name, ?files);\n     sess.opts.incremental.as_ref()?;\n \n-    let file_name = format!(\"{}.o\", cgu_name);\n-    let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n-    let saved_file = match link_or_copy(path, &path_in_incr_dir) {\n-        Ok(_) => file_name,\n-        Err(err) => {\n-            sess.warn(&format!(\n-                \"error copying object file `{}` to incremental directory as `{}`: {}\",\n-                path.display(),\n-                path_in_incr_dir.display(),\n-                err\n-            ));\n-            return None;\n+    let mut saved_files = FxHashMap::default();\n+    for (ext, path) in files {\n+        let file_name = format!(\"{cgu_name}.{ext}\");\n+        let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n+        match link_or_copy(path, &path_in_incr_dir) {\n+            Ok(_) => {\n+                let _ = saved_files.insert(ext.to_string(), file_name);\n+            }\n+            Err(err) => {\n+                sess.warn(&format!(\n+                    \"error copying object file `{}` to incremental directory as `{}`: {}\",\n+                    path.display(),\n+                    path_in_incr_dir.display(),\n+                    err\n+                ));\n+            }\n         }\n-    };\n-\n-    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_file };\n+    }\n \n+    let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_files };\n+    debug!(?work_product);\n     let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n     Some((work_product_id, work_product))\n }\n \n /// Removes files for a given work product.\n pub fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) {\n-    let path = in_incr_comp_dir_sess(sess, &work_product.saved_file);\n-    match std_fs::remove_file(&path) {\n-        Ok(()) => {}\n-        Err(err) => {\n+    for (_, path) in &work_product.saved_files {\n+        let path = in_incr_comp_dir_sess(sess, path);\n+        if let Err(err) = std_fs::remove_file(&path) {\n             sess.warn(&format!(\n                 \"file-system error deleting outdated file `{}`: {}\",\n                 path.display(),"}, {"sha": "5725c240320ad779a68d36f6f12e75890edce3ed", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -34,7 +34,7 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, print::Printer, subst::GenericArg, RegisteredTools, Ty, TyCtxt};\n-use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_session::lint::{BuiltinLintDiagnostics, LintExpectationId};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -906,6 +906,29 @@ pub trait LintContext: Sized {\n     ) {\n         self.lookup(lint, None as Option<Span>, decorate);\n     }\n+\n+    /// This returns the lint level for the given lint at the current location.\n+    fn get_lint_level(&self, lint: &'static Lint) -> Level;\n+\n+    /// This function can be used to manually fulfill an expectation. This can\n+    /// be used for lints which contain several spans, and should be suppressed,\n+    /// if either location was marked with an expectation.\n+    ///\n+    /// Note that this function should only be called for [`LintExpectationId`]s\n+    /// retrieved from the current lint pass. Buffered or manually created ids can\n+    /// cause ICEs.\n+    fn fulfill_expectation(&self, expectation: LintExpectationId) {\n+        // We need to make sure that submitted expectation ids are correctly fulfilled suppressed\n+        // and stored between compilation sessions. To not manually do these steps, we simply create\n+        // a dummy diagnostic and emit is as usual, which will be suppressed and stored like a normal\n+        // expected lint diagnostic.\n+        self.sess()\n+            .struct_expect(\n+                \"this is a dummy diagnostic, to submit and store an expectation\",\n+                expectation,\n+            )\n+            .emit();\n+    }\n }\n \n impl<'a> EarlyContext<'a> {\n@@ -953,6 +976,10 @@ impl LintContext for LateContext<'_> {\n             None => self.tcx.struct_lint_node(lint, hir_id, decorate),\n         }\n     }\n+\n+    fn get_lint_level(&self, lint: &'static Lint) -> Level {\n+        self.tcx.lint_level_at_node(lint, self.last_node_with_lint_attrs).0\n+    }\n }\n \n impl LintContext for EarlyContext<'_> {\n@@ -975,6 +1002,10 @@ impl LintContext for EarlyContext<'_> {\n     ) {\n         self.builder.struct_lint(lint, span.map(|s| s.into()), decorate)\n     }\n+\n+    fn get_lint_level(&self, lint: &'static Lint) -> Level {\n+        self.builder.lint_level(lint).0\n+    }\n }\n \n impl<'tcx> LateContext<'tcx> {"}, {"sha": "9fc2249b29019dfa3d5647eccfb230a800d33949", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -520,6 +520,11 @@ declare_lint! {\n     /// The `expect` attribute can be removed if this is intended behavior otherwise\n     /// it should be investigated why the expected lint is no longer issued.\n     ///\n+    /// In rare cases, the expectation might be emitted at a different location than\n+    /// shown in the shown code snippet. In most cases, the `#[expect]` attribute\n+    /// works when added to the outer scope. A few lints can only be expected\n+    /// on a crate level.\n+    ///\n     /// Part of RFC 2383. The progress is being tracked in [#54503]\n     ///\n     /// [#54503]: https://github.com/rust-lang/rust/issues/54503"}, {"sha": "48f441e69d64204254504175aa69cb0d3a5aafce", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -232,6 +232,13 @@ impl Level {\n             Level::Deny | Level::Forbid => true,\n         }\n     }\n+\n+    pub fn get_expectation_id(&self) -> Option<LintExpectationId> {\n+        match self {\n+            Level::Expect(id) | Level::ForceWarn(Some(id)) => Some(*id),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Specification of a single lint."}, {"sha": "78080fcd581f6e0cdca918dd399939a61945d8ca", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1,147 @@\n+use crate::mir::graph_cyclic_cache::GraphIsCyclicCache;\n+use crate::mir::predecessors::{PredecessorCache, Predecessors};\n+use crate::mir::switch_sources::{SwitchSourceCache, SwitchSources};\n+use crate::mir::traversal::PostorderCache;\n+use crate::mir::{BasicBlock, BasicBlockData, Successors, START_BLOCK};\n+\n+use rustc_data_structures::graph;\n+use rustc_data_structures::graph::dominators::{dominators, Dominators};\n+use rustc_index::vec::IndexVec;\n+\n+#[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable, TypeVisitable)]\n+pub struct BasicBlocks<'tcx> {\n+    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    predecessor_cache: PredecessorCache,\n+    switch_source_cache: SwitchSourceCache,\n+    is_cyclic: GraphIsCyclicCache,\n+    postorder_cache: PostorderCache,\n+}\n+\n+impl<'tcx> BasicBlocks<'tcx> {\n+    #[inline]\n+    pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n+        BasicBlocks {\n+            basic_blocks,\n+            predecessor_cache: PredecessorCache::new(),\n+            switch_source_cache: SwitchSourceCache::new(),\n+            is_cyclic: GraphIsCyclicCache::new(),\n+            postorder_cache: PostorderCache::new(),\n+        }\n+    }\n+\n+    /// Returns true if control-flow graph contains a cycle reachable from the `START_BLOCK`.\n+    #[inline]\n+    pub fn is_cfg_cyclic(&self) -> bool {\n+        self.is_cyclic.is_cyclic(self)\n+    }\n+\n+    #[inline]\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(&self)\n+    }\n+\n+    /// Returns predecessors for each basic block.\n+    #[inline]\n+    pub fn predecessors(&self) -> &Predecessors {\n+        self.predecessor_cache.compute(&self.basic_blocks)\n+    }\n+\n+    /// Returns basic blocks in a postorder.\n+    #[inline]\n+    pub fn postorder(&self) -> &[BasicBlock] {\n+        self.postorder_cache.compute(&self.basic_blocks)\n+    }\n+\n+    /// `switch_sources()[&(target, switch)]` returns a list of switch\n+    /// values that lead to a `target` block from a `switch` block.\n+    #[inline]\n+    pub fn switch_sources(&self) -> &SwitchSources {\n+        self.switch_source_cache.compute(&self.basic_blocks)\n+    }\n+\n+    /// Returns mutable reference to basic blocks. Invalidates CFG cache.\n+    #[inline]\n+    pub fn as_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        self.invalidate_cfg_cache();\n+        &mut self.basic_blocks\n+    }\n+\n+    /// Get mutable access to basic blocks without invalidating the CFG cache.\n+    ///\n+    /// By calling this method instead of e.g. [`BasicBlocks::as_mut`] you promise not to change\n+    /// the CFG. This means that\n+    ///\n+    ///  1) The number of basic blocks remains unchanged\n+    ///  2) The set of successors of each terminator remains unchanged.\n+    ///  3) For each `TerminatorKind::SwitchInt`, the `targets` remains the same and the terminator\n+    ///     kind is not changed.\n+    ///\n+    /// If any of these conditions cannot be upheld, you should call [`BasicBlocks::invalidate_cfg_cache`].\n+    #[inline]\n+    pub fn as_mut_preserves_cfg(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &mut self.basic_blocks\n+    }\n+\n+    /// Invalidates cached information about the CFG.\n+    ///\n+    /// You will only ever need this if you have also called [`BasicBlocks::as_mut_preserves_cfg`].\n+    /// All other methods that allow you to mutate the basic blocks also call this method\n+    /// themselves, thereby avoiding any risk of accidentaly cache invalidation.\n+    pub fn invalidate_cfg_cache(&mut self) {\n+        self.predecessor_cache.invalidate();\n+        self.switch_source_cache.invalidate();\n+        self.is_cyclic.invalidate();\n+        self.postorder_cache.invalidate();\n+    }\n+}\n+\n+impl<'tcx> std::ops::Deref for BasicBlocks<'tcx> {\n+    type Target = IndexVec<BasicBlock, BasicBlockData<'tcx>>;\n+\n+    #[inline]\n+    fn deref(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.basic_blocks\n+    }\n+}\n+\n+impl<'tcx> graph::DirectedGraph for BasicBlocks<'tcx> {\n+    type Node = BasicBlock;\n+}\n+\n+impl<'tcx> graph::WithNumNodes for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn num_nodes(&self) -> usize {\n+        self.basic_blocks.len()\n+    }\n+}\n+\n+impl<'tcx> graph::WithStartNode for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn start_node(&self) -> Self::Node {\n+        START_BLOCK\n+    }\n+}\n+\n+impl<'tcx> graph::WithSuccessors for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn successors(&self, node: Self::Node) -> <Self as graph::GraphSuccessors<'_>>::Iter {\n+        self.basic_blocks[node].terminator().successors()\n+    }\n+}\n+\n+impl<'a, 'b> graph::GraphSuccessors<'b> for BasicBlocks<'a> {\n+    type Item = BasicBlock;\n+    type Iter = Successors<'b>;\n+}\n+\n+impl<'tcx, 'graph> graph::GraphPredecessors<'graph> for BasicBlocks<'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = std::iter::Copied<std::slice::Iter<'graph, BasicBlock>>;\n+}\n+\n+impl<'tcx> graph::WithPredecessors for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n+        self.predecessors()[node].iter().copied()\n+    }\n+}"}, {"sha": "93686128101982c040652482e721cc3e1ddf7067", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 159, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -5,7 +5,6 @@\n use crate::mir::interpret::{\n     AllocRange, ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar,\n };\n-use crate::mir::traversal::PostorderCache;\n use crate::mir::visit::MirVisitable;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable};\n@@ -27,8 +26,7 @@ use rustc_target::abi::{Size, VariantIdx};\n use polonius_engine::Atom;\n pub use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::graph::{self, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::{Decodable, Encodable};\n@@ -43,11 +41,10 @@ use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{ControlFlow, Index, IndexMut};\n use std::{iter, mem};\n \n-use self::graph_cyclic_cache::GraphIsCyclicCache;\n-use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n-use self::switch_sources::{SwitchSourceCache, SwitchSources};\n+pub use basic_blocks::BasicBlocks;\n \n+mod basic_blocks;\n pub mod coverage;\n mod generic_graph;\n pub mod generic_graphviz;\n@@ -189,7 +186,7 @@ pub struct GeneratorInfo<'tcx> {\n pub struct Body<'tcx> {\n     /// A list of basic blocks. References to basic block use a newtyped index type [`BasicBlock`]\n     /// that indexes into this vector.\n-    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    pub basic_blocks: BasicBlocks<'tcx>,\n \n     /// Records how far through the \"desugaring and optimization\" process this particular\n     /// MIR has traversed. This is particularly useful when inlining, since in that context\n@@ -257,11 +254,6 @@ pub struct Body<'tcx> {\n     /// potentially allow things like `[u8; std::mem::size_of::<T>() * 0]` due to this.\n     pub is_polymorphic: bool,\n \n-    predecessor_cache: PredecessorCache,\n-    switch_source_cache: SwitchSourceCache,\n-    is_cyclic: GraphIsCyclicCache,\n-    postorder_cache: PostorderCache,\n-\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n }\n \n@@ -289,7 +281,7 @@ impl<'tcx> Body<'tcx> {\n         let mut body = Body {\n             phase: MirPhase::Built,\n             source,\n-            basic_blocks,\n+            basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes,\n             generator: generator_kind.map(|generator_kind| {\n                 Box::new(GeneratorInfo {\n@@ -307,10 +299,6 @@ impl<'tcx> Body<'tcx> {\n             span,\n             required_consts: Vec::new(),\n             is_polymorphic: false,\n-            predecessor_cache: PredecessorCache::new(),\n-            switch_source_cache: SwitchSourceCache::new(),\n-            is_cyclic: GraphIsCyclicCache::new(),\n-            postorder_cache: PostorderCache::new(),\n             tainted_by_errors,\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n@@ -326,7 +314,7 @@ impl<'tcx> Body<'tcx> {\n         let mut body = Body {\n             phase: MirPhase::Built,\n             source: MirSource::item(CRATE_DEF_ID.to_def_id()),\n-            basic_blocks,\n+            basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes: IndexVec::new(),\n             generator: None,\n             local_decls: IndexVec::new(),\n@@ -337,10 +325,6 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             var_debug_info: Vec::new(),\n             is_polymorphic: false,\n-            predecessor_cache: PredecessorCache::new(),\n-            switch_source_cache: SwitchSourceCache::new(),\n-            is_cyclic: GraphIsCyclicCache::new(),\n-            postorder_cache: PostorderCache::new(),\n             tainted_by_errors: None,\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n@@ -354,74 +338,7 @@ impl<'tcx> Body<'tcx> {\n \n     #[inline]\n     pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        // Because the user could mutate basic block terminators via this reference, we need to\n-        // invalidate the caches.\n-        //\n-        // FIXME: Use a finer-grained API for this, so only transformations that alter terminators\n-        // invalidate the caches.\n-        self.invalidate_cfg_cache();\n-        &mut self.basic_blocks\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_and_local_decls_mut(\n-        &mut self,\n-    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n-        self.invalidate_cfg_cache();\n-        (&mut self.basic_blocks, &mut self.local_decls)\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_local_decls_mut_and_var_debug_info(\n-        &mut self,\n-    ) -> (\n-        &mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-        &mut LocalDecls<'tcx>,\n-        &mut Vec<VarDebugInfo<'tcx>>,\n-    ) {\n-        self.invalidate_cfg_cache();\n-        (&mut self.basic_blocks, &mut self.local_decls, &mut self.var_debug_info)\n-    }\n-\n-    /// Get mutable access to parts of the Body without invalidating the CFG cache.\n-    ///\n-    /// By calling this method instead of eg [`Body::basic_blocks_mut`], you promise not to change\n-    /// the CFG. This means that\n-    ///\n-    ///  1) The number of basic blocks remains unchanged\n-    ///  2) The set of successors of each terminator remains unchanged.\n-    ///  3) For each `TerminatorKind::SwitchInt`, the `targets` remains the same and the terminator\n-    ///     kind is not changed.\n-    ///\n-    /// If any of these conditions cannot be upheld, you should call [`Body::invalidate_cfg_cache`].\n-    #[inline]\n-    pub fn basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate(\n-        &mut self,\n-    ) -> (\n-        &mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-        &mut LocalDecls<'tcx>,\n-        &mut Vec<VarDebugInfo<'tcx>>,\n-    ) {\n-        (&mut self.basic_blocks, &mut self.local_decls, &mut self.var_debug_info)\n-    }\n-\n-    /// Invalidates cached information about the CFG.\n-    ///\n-    /// You will only ever need this if you have also called\n-    /// [`Body::basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate`]. All other methods\n-    /// that allow you to mutate the body also call this method themselves, thereby avoiding any\n-    /// risk of accidentaly cache invalidation.\n-    pub fn invalidate_cfg_cache(&mut self) {\n-        self.predecessor_cache.invalidate();\n-        self.switch_source_cache.invalidate();\n-        self.is_cyclic.invalidate();\n-        self.postorder_cache.invalidate();\n-    }\n-\n-    /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n-    /// `START_BLOCK`.\n-    pub fn is_cfg_cyclic(&self) -> bool {\n-        self.is_cyclic.is_cyclic(self)\n+        self.basic_blocks.as_mut()\n     }\n \n     #[inline]\n@@ -495,14 +412,6 @@ impl<'tcx> Body<'tcx> {\n         self.local_decls.drain(self.arg_count + 1..)\n     }\n \n-    /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n-    /// invalidating statement indices in `Location`s.\n-    pub fn make_statement_nop(&mut self, location: Location) {\n-        let block = &mut self.basic_blocks[location.block];\n-        debug_assert!(location.statement_index < block.statements.len());\n-        block.statements[location.statement_index].make_nop()\n-    }\n-\n     /// Returns the source info associated with `location`.\n     pub fn source_info(&self, location: Location) -> &SourceInfo {\n         let block = &self[location.block];\n@@ -538,23 +447,6 @@ impl<'tcx> Body<'tcx> {\n             .unwrap_or_else(|| Either::Right(block_data.terminator()))\n     }\n \n-    #[inline]\n-    pub fn predecessors(&self) -> &Predecessors {\n-        self.predecessor_cache.compute(&self.basic_blocks)\n-    }\n-\n-    /// `body.switch_sources()[&(target, switch)]` returns a list of switch\n-    /// values that lead to a `target` block from a `switch` block.\n-    #[inline]\n-    pub fn switch_sources(&self) -> &SwitchSources {\n-        self.switch_source_cache.compute(&self.basic_blocks)\n-    }\n-\n-    #[inline]\n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(self)\n-    }\n-\n     #[inline]\n     pub fn yield_ty(&self) -> Option<Ty<'tcx>> {\n         self.generator.as_ref().and_then(|generator| generator.yield_ty)\n@@ -599,7 +491,7 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n     #[inline]\n     fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks_mut()[index]\n+        &mut self.basic_blocks.as_mut()[index]\n     }\n }\n \n@@ -2890,48 +2782,6 @@ fn pretty_print_const_value<'tcx>(\n     })\n }\n \n-impl<'tcx> graph::DirectedGraph for Body<'tcx> {\n-    type Node = BasicBlock;\n-}\n-\n-impl<'tcx> graph::WithNumNodes for Body<'tcx> {\n-    #[inline]\n-    fn num_nodes(&self) -> usize {\n-        self.basic_blocks.len()\n-    }\n-}\n-\n-impl<'tcx> graph::WithStartNode for Body<'tcx> {\n-    #[inline]\n-    fn start_node(&self) -> Self::Node {\n-        START_BLOCK\n-    }\n-}\n-\n-impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n-    #[inline]\n-    fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n-        self.basic_blocks[node].terminator().successors()\n-    }\n-}\n-\n-impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n-    type Item = BasicBlock;\n-    type Iter = Successors<'b>;\n-}\n-\n-impl<'tcx, 'graph> graph::GraphPredecessors<'graph> for Body<'tcx> {\n-    type Item = BasicBlock;\n-    type Iter = std::iter::Copied<std::slice::Iter<'graph, BasicBlock>>;\n-}\n-\n-impl<'tcx> graph::WithPredecessors for Body<'tcx> {\n-    #[inline]\n-    fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n-        self.predecessors()[node].iter().copied()\n-    }\n-}\n-\n /// `Location` represents the position of the start of the statement; or, if\n /// `statement_index` equals the number of statements, then the start of the\n /// terminator.\n@@ -2968,7 +2818,7 @@ impl Location {\n             return true;\n         }\n \n-        let predecessors = body.predecessors();\n+        let predecessors = body.basic_blocks.predecessors();\n \n         // If we're in another block, then we want to check that block is a predecessor of `other`.\n         let mut queue: Vec<BasicBlock> = predecessors[other.block].to_vec();"}, {"sha": "627dc32f37eb571cceaea53daef6480589b29a04", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -104,22 +104,25 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n ///\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n+    basic_blocks: &'a IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     visited: BitSet<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>,\n     root_is_start_block: bool,\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n-    pub fn new(body: &'a Body<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n+    pub fn new(\n+        basic_blocks: &'a IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+        root: BasicBlock,\n+    ) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n-            body,\n-            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            basic_blocks,\n+            visited: BitSet::new_empty(basic_blocks.len()),\n             visit_stack: Vec::new(),\n             root_is_start_block: root == START_BLOCK,\n         };\n \n-        let data = &po.body[root];\n+        let data = &po.basic_blocks[root];\n \n         if let Some(ref term) = data.terminator {\n             po.visited.insert(root);\n@@ -190,7 +193,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n             };\n \n             if self.visited.insert(bb) {\n-                if let Some(term) = &self.body[bb].terminator {\n+                if let Some(term) = &self.basic_blocks[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));\n                 }\n             }\n@@ -199,7 +202,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n }\n \n pub fn postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> Postorder<'a, 'tcx> {\n-    Postorder::new(body, START_BLOCK)\n+    Postorder::new(&body.basic_blocks, START_BLOCK)\n }\n \n impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n@@ -211,12 +214,12 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n             self.traverse_successor();\n         }\n \n-        next.map(|(bb, _)| (bb, &self.body[bb]))\n+        next.map(|(bb, _)| (bb, &self.basic_blocks[bb]))\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         // All the blocks, minus the number of blocks we've visited.\n-        let upper = self.body.basic_blocks().len() - self.visited.count();\n+        let upper = self.basic_blocks.len() - self.visited.count();\n \n         let lower = if self.root_is_start_block {\n             // We will visit all remaining blocks exactly once.\n@@ -263,10 +266,8 @@ pub struct ReversePostorder<'a, 'tcx> {\n \n impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n     pub fn new(body: &'a Body<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n-        let blocks: Vec<_> = Postorder::new(body, root).map(|(bb, _)| bb).collect();\n-\n+        let blocks: Vec<_> = Postorder::new(&body.basic_blocks, root).map(|(bb, _)| bb).collect();\n         let len = blocks.len();\n-\n         ReversePostorder { body, blocks, idx: len }\n     }\n }\n@@ -334,10 +335,8 @@ impl<'a, 'tcx> Iterator for ReversePostorderIter<'a, 'tcx> {\n impl<'a, 'tcx> ExactSizeIterator for ReversePostorderIter<'a, 'tcx> {}\n \n pub fn reverse_postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> ReversePostorderIter<'a, 'tcx> {\n-    let blocks = body.postorder_cache.compute(body);\n-\n+    let blocks = body.basic_blocks.postorder();\n     let len = blocks.len();\n-\n     ReversePostorderIter { body, blocks, idx: len }\n }\n \n@@ -360,7 +359,7 @@ impl PostorderCache {\n \n     /// Returns the `&[BasicBlocks]` represents the postorder graph for this MIR.\n     #[inline]\n-    pub(super) fn compute(&self, body: &Body<'_>) -> &[BasicBlock] {\n+    pub(super) fn compute(&self, body: &IndexVec<BasicBlock, BasicBlockData<'_>>) -> &[BasicBlock] {\n         self.cache.get_or_init(|| Postorder::new(body, START_BLOCK).map(|(bb, _)| bb).collect())\n     }\n }"}, {"sha": "d21a8c4f9b9a3e2a410d32e1d067046b7f3e501e", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::graph::iterate::{\n     NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n use rustc_hir::intravisit::FnKind;\n-use rustc_middle::mir::{BasicBlock, Body, Operand, TerminatorKind};\n+use rustc_middle::mir::{BasicBlock, BasicBlocks, Body, Operand, TerminatorKind};\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n@@ -30,7 +30,9 @@ pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n         };\n \n         let mut vis = Search { tcx, body, reachable_recursive_calls: vec![], trait_substs };\n-        if let Some(NonRecursive) = TriColorDepthFirstSearch::new(&body).run_from_start(&mut vis) {\n+        if let Some(NonRecursive) =\n+            TriColorDepthFirstSearch::new(&body.basic_blocks).run_from_start(&mut vis)\n+        {\n             return;\n         }\n         if vis.reachable_recursive_calls.is_empty() {\n@@ -101,7 +103,7 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx> TriColorVisitor<&'mir Body<'tcx>> for Search<'mir, 'tcx> {\n+impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n     type BreakVal = NonRecursive;\n \n     fn node_examined("}, {"sha": "5c77f3ea395334abc0d5f0c891b11a606ae1bcc1", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -228,7 +228,7 @@ impl Direction for Backward {\n     ) where\n         A: Analysis<'tcx>,\n     {\n-        for pred in body.predecessors()[bb].iter().copied() {\n+        for pred in body.basic_blocks.predecessors()[bb].iter().copied() {\n             match body[pred].terminator().kind {\n                 // Apply terminator-specific edge effects.\n                 //\n@@ -316,7 +316,7 @@ where\n     fn apply(&mut self, mut apply_edge_effect: impl FnMut(&mut D, SwitchIntTarget)) {\n         assert!(!self.effects_applied);\n \n-        let values = &self.body.switch_sources()[&(self.bb, self.pred)];\n+        let values = &self.body.basic_blocks.switch_sources()[&(self.bb, self.pred)];\n         let targets = values.iter().map(|&value| SwitchIntTarget { value, target: self.bb });\n \n         let mut tmp = None;"}, {"sha": "180376d648a1cf0b501ef17b5206982ecbec488a", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -101,7 +101,7 @@ where\n         // transfer function for each block exactly once (assuming that we process blocks in RPO).\n         //\n         // In this case, there's no need to compute the block transfer functions ahead of time.\n-        if !body.is_cfg_cyclic() {\n+        if !body.basic_blocks.is_cfg_cyclic() {\n             return Self::new(tcx, body, analysis, None);\n         }\n "}, {"sha": "f9fd6c9c56b424333800c62248928d2637c94875", "filename": "compiler/rustc_mir_dataflow/src/framework/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fmod.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -1,7 +1,7 @@\n //! A framework that can express both [gen-kill] and generic dataflow problems.\n //!\n-//! To actually use this framework, you must implement either the `Analysis` or the\n-//! `GenKillAnalysis` trait. If your transfer function can be expressed with only gen/kill\n+//! To use this framework, implement either the [`Analysis`] or the\n+//! [`GenKillAnalysis`] trait. If your transfer function can be expressed with only gen/kill\n //! operations, prefer `GenKillAnalysis` since it will run faster while iterating to fixpoint. The\n //! `impls` module contains several examples of gen/kill dataflow analyses.\n //!\n@@ -96,7 +96,7 @@ impl<T: Idx> BitSetExt<T> for ChunkedBitSet<T> {\n     }\n }\n \n-/// Define the domain of a dataflow problem.\n+/// Defines the domain of a dataflow problem.\n ///\n /// This trait specifies the lattice on which this analysis operates (the domain) as well as its\n /// initial value at the entry point of each basic block.\n@@ -113,12 +113,12 @@ pub trait AnalysisDomain<'tcx> {\n     /// suitable as part of a filename.\n     const NAME: &'static str;\n \n-    /// The initial value of the dataflow state upon entry to each basic block.\n+    /// Returns the initial value of the dataflow state upon entry to each basic block.\n     fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain;\n \n     /// Mutates the initial value of the dataflow state upon entry to the `START_BLOCK`.\n     ///\n-    /// For backward analyses, initial state besides the bottom value is not yet supported. Trying\n+    /// For backward analyses, initial state (besides the bottom value) is not yet supported. Trying\n     /// to mutate the initial state will result in a panic.\n     //\n     // FIXME: For backward dataflow analyses, the initial state should be applied to every basic\n@@ -155,9 +155,9 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// Updates the current dataflow state with an effect that occurs immediately *before* the\n     /// given statement.\n     ///\n-    /// This method is useful if the consumer of the results of this analysis needs only to observe\n+    /// This method is useful if the consumer of the results of this analysis only needs to observe\n     /// *part* of the effect of a statement (e.g. for two-phase borrows). As a general rule,\n-    /// analyses should not implement this without implementing `apply_statement_effect`.\n+    /// analyses should not implement this without also implementing `apply_statement_effect`.\n     fn apply_before_statement_effect(\n         &self,\n         _state: &mut Self::Domain,\n@@ -184,7 +184,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     ///\n     /// This method is useful if the consumer of the results of this analysis needs only to observe\n     /// *part* of the effect of a terminator (e.g. for two-phase borrows). As a general rule,\n-    /// analyses should not implement this without implementing `apply_terminator_effect`.\n+    /// analyses should not implement this without also implementing `apply_terminator_effect`.\n     fn apply_before_terminator_effect(\n         &self,\n         _state: &mut Self::Domain,"}, {"sha": "f12c8560c0e82bd0a3d041dc4d8ce3b8e314628b", "filename": "compiler/rustc_mir_transform/src/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -39,7 +39,7 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n impl AddCallGuards {\n     pub fn add_call_guards(&self, body: &mut Body<'_>) {\n         let mut pred_count: IndexVec<_, _> =\n-            body.predecessors().iter().map(|ps| ps.len()).collect();\n+            body.basic_blocks.predecessors().iter().map(|ps| ps.len()).collect();\n         pred_count[START_BLOCK] += 1;\n \n         // We need a place to store the new blocks generated"}, {"sha": "5d15f03491d79fa8b6e06fcfa8df4ece7a4fc486", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -91,7 +91,8 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         super::add_call_guards::AllCallEdges.run_pass(tcx, body);\n \n         let (span, arg_count) = (body.span, body.arg_count);\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        let basic_blocks = body.basic_blocks.as_mut();\n+        let local_decls = &body.local_decls;\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that."}, {"sha": "759ea7cd32820b9d5c1ae3d16d3e6014580c55f3", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -80,7 +80,7 @@ impl CoverageGraph {\n         IndexVec<BasicCoverageBlock, BasicCoverageBlockData>,\n         IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n     ) {\n-        let num_basic_blocks = mir_body.num_nodes();\n+        let num_basic_blocks = mir_body.basic_blocks.len();\n         let mut bcbs = IndexVec::with_capacity(num_basic_blocks);\n         let mut bb_to_bcb = IndexVec::from_elem_n(None, num_basic_blocks);\n \n@@ -95,7 +95,7 @@ impl CoverageGraph {\n         let mut basic_blocks = Vec::new();\n         for (bb, data) in mir_cfg_without_unwind {\n             if let Some(last) = basic_blocks.last() {\n-                let predecessors = &mir_body.predecessors()[bb];\n+                let predecessors = &mir_body.basic_blocks.predecessors()[bb];\n                 if predecessors.len() > 1 || !predecessors.contains(last) {\n                     // The `bb` has more than one _incoming_ edge, and should start its own\n                     // `BasicCoverageBlockData`. (Note, the `basic_blocks` vector does not yet"}, {"sha": "423e78317aadbc1f21639b2a6ea0f7af77f6b28b", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -321,7 +321,8 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n \n     fn mir_to_initial_sorted_coverage_spans(&self) -> Vec<CoverageSpan> {\n-        let mut initial_spans = Vec::<CoverageSpan>::with_capacity(self.mir_body.num_nodes() * 2);\n+        let mut initial_spans =\n+            Vec::<CoverageSpan>::with_capacity(self.mir_body.basic_blocks.len() * 2);\n         for (bcb, bcb_data) in self.basic_coverage_blocks.iter_enumerated() {\n             initial_spans.extend(self.bcb_to_initial_coverage_spans(bcb, bcb_data));\n         }"}, {"sha": "6380f03528ae8dc6a58936dc5d84b2710ace47bd", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -222,6 +222,7 @@ fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n                         bb,\n                         debug::term_type(&data.terminator().kind),\n                         mir_body\n+                            .basic_blocks\n                             .successors(bb)\n                             .map(|successor| { format!(\"    {:?} -> {:?};\", bb, successor) })\n                             .join(\"\\n\")"}, {"sha": "9163672f570396113e372faf60addc21b5e3278d", "filename": "compiler/rustc_mir_transform/src/dead_store_elimination.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -66,7 +66,7 @@ pub fn eliminate<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, borrowed: &BitS\n         return;\n     }\n \n-    let bbs = body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate().0;\n+    let bbs = body.basic_blocks.as_mut_preserves_cfg();\n     for Location { block, statement_index } in patch {\n         bbs[block].statements[statement_index].make_nop();\n     }"}, {"sha": "b93fe5879f4fd99a7bc388bf008cb2465b3f4c0f", "filename": "compiler/rustc_mir_transform/src/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -11,9 +11,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls, _) =\n-            body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n-        let local_decls = &*local_decls;\n+        let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n         for bb in basic_blocks {\n             bb.expand_statements(|stmt| {\n                 // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n@@ -38,7 +36,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n                 Some(expand_aggregate(\n                     lhs,\n                     operands.into_iter().map(|op| {\n-                        let ty = op.ty(local_decls, tcx);\n+                        let ty = op.ty(&body.local_decls, tcx);\n                         (op, ty)\n                     }),\n                     *kind,"}, {"sha": "44e3945d6fc8905e1b0bc5023cb7a52793ea16a2", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -110,13 +110,13 @@ impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n \n             let patch = MirPatch::new(body);\n \n-            let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+            let local_decls = &mut body.local_decls;\n \n             let mut visitor =\n                 ElaborateBoxDerefVisitor { tcx, unique_did, nonnull_did, local_decls, patch };\n \n             for (block, BasicBlockData { statements, terminator, .. }) in\n-                basic_blocks.iter_enumerated_mut()\n+                body.basic_blocks.as_mut().iter_enumerated_mut()\n             {\n                 let mut index = 0;\n                 for statement in statements {"}, {"sha": "2f3c65869ef3b2ce275ef446af389d6eeb259e39", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -16,9 +16,8 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        let ctx = InstCombineContext { tcx, local_decls };\n-        for block in basic_blocks.iter_mut() {\n+        let ctx = InstCombineContext { tcx, local_decls: &body.local_decls };\n+        for block in body.basic_blocks.as_mut() {\n             for statement in block.statements.iter_mut() {\n                 match statement.kind {\n                     StatementKind::Assign(box (_place, ref mut rvalue)) => {"}, {"sha": "b7ba616510c28874b2356f294ba7155b6a7f8bb7", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -11,8 +11,8 @@ pub struct LowerIntrinsics;\n \n impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        for block in basic_blocks {\n+        let local_decls = &body.local_decls;\n+        for block in body.basic_blocks.as_mut() {\n             let terminator = block.terminator.as_mut().unwrap();\n             if let TerminatorKind::Call { func, args, destination, target, .. } =\n                 &mut terminator.kind"}, {"sha": "47848cfa497f3bee5b64b99cecc6075e7ed32e35", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -27,12 +27,10 @@ pub fn lower_slice_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     };\n \n     // The one successor remains unchanged, so no need to invalidate\n-    let (basic_blocks, local_decls, _) =\n-        body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n-\n+    let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n     for block in basic_blocks {\n         // lower `<[_]>::len` calls\n-        lower_slice_len_call(tcx, block, &*local_decls, slice_len_fn_item_def_id);\n+        lower_slice_len_call(tcx, block, &body.local_decls, slice_len_fn_item_def_id);\n     }\n }\n "}, {"sha": "a0ba69c89b048491f9840a9cd6806f91bf2fd46f", "filename": "compiler/rustc_mir_transform/src/match_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n         let def_id = body.source.def_id();\n         let param_env = tcx.param_env(def_id);\n \n-        let (bbs, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        let bbs = body.basic_blocks.as_mut();\n         let mut should_cleanup = false;\n         'outer: for bb_idx in bbs.indices() {\n             if !tcx.consider_optimizing(|| format!(\"MatchBranchSimplification {:?} \", def_id)) {\n@@ -108,7 +108,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n \n             // Introduce a temporary for the discriminant value.\n             let source_info = bbs[bb_idx].terminator().source_info;\n-            let discr_local = local_decls.push(LocalDecl::new(switch_ty, source_info.span));\n+            let discr_local = body.local_decls.push(LocalDecl::new(switch_ty, source_info.span));\n \n             // We already checked that first and second are different blocks,\n             // and bb_idx has a different terminator from both of them."}, {"sha": "c0217a105414b65ff9fb20292f3d54aa3a1234d1", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -33,8 +33,8 @@ impl<'tcx> MirPass<'tcx> for NormalizeArrayLen {\n \n pub fn normalize_array_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     // We don't ever touch terminators, so no need to invalidate the CFG cache\n-    let (basic_blocks, local_decls, _) =\n-        body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n+    let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n+    let local_decls = &mut body.local_decls;\n \n     // do a preliminary analysis to see if we ever have locals of type `[T;N]` or `&[T;N]`\n     let mut interesting_locals = BitSet::new_empty(local_decls.len());"}, {"sha": "bb063915f55a907f8119f617e9c20b5433481e82", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -133,7 +133,7 @@ fn find_local_assigned_to_return_place(\n             return local;\n         }\n \n-        match body.predecessors()[block].as_slice() {\n+        match body.basic_blocks.predecessors()[block].as_slice() {\n             &[pred] => block = pred,\n             _ => return None,\n         }"}, {"sha": "dbe082e909371f57adf1c3563d29a9e96391d7a6", "filename": "compiler/rustc_mir_transform/src/remove_storage_markers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_storage_markers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_storage_markers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_storage_markers.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -17,7 +17,7 @@ impl<'tcx> MirPass<'tcx> for RemoveStorageMarkers {\n         }\n \n         trace!(\"Running RemoveStorageMarkers on {:?}\", body.source);\n-        for data in body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate().0 {\n+        for data in body.basic_blocks.as_mut_preserves_cfg() {\n             data.statements.retain(|statement| match statement.kind {\n                 StatementKind::StorageLive(..)\n                 | StatementKind::StorageDead(..)"}, {"sha": "84ccf6e1f61d492d9393134640ecaf5ef99a5296", "filename": "compiler/rustc_mir_transform/src/remove_unneeded_drops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -20,11 +20,10 @@ impl<'tcx> MirPass<'tcx> for RemoveUnneededDrops {\n         let param_env = tcx.param_env_reveal_all_normalized(did);\n         let mut should_simplify = false;\n \n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        for block in basic_blocks {\n+        for block in body.basic_blocks.as_mut() {\n             let terminator = block.terminator_mut();\n             if let TerminatorKind::Drop { place, target, .. } = terminator.kind {\n-                let ty = place.ty(local_decls, tcx);\n+                let ty = place.ty(&body.local_decls, tcx);\n                 if ty.ty.needs_drop(tcx, param_env) {\n                     continue;\n                 }"}, {"sha": "40be4f146db98ffefec45920ffeca6e460609786", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -18,9 +18,9 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n             return;\n         }\n         let param_env = tcx.param_env(body.source.def_id());\n-        let (basic_blocks, local_decls, _) =\n-            body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n-        for block in basic_blocks.iter_mut() {\n+        let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n+        let local_decls = &body.local_decls;\n+        for block in basic_blocks {\n             for statement in block.statements.iter_mut() {\n                 if let StatementKind::Assign(box (place, _)) | StatementKind::Deinit(box place) =\n                     statement.kind"}, {"sha": "194c2794aacb60e22c904db8a56c3f3051257d19", "filename": "compiler/rustc_mir_transform/src/separate_const_switch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> MirPass<'tcx> for SeparateConstSwitch {\n /// Returns the amount of blocks that were duplicated\n pub fn separate_const_switch(body: &mut Body<'_>) -> usize {\n     let mut new_blocks: SmallVec<[(BasicBlock, BasicBlock); 6]> = SmallVec::new();\n-    let predecessors = body.predecessors();\n+    let predecessors = body.basic_blocks.predecessors();\n     'block_iter: for (block_id, block) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::SwitchInt {\n             discr: Operand::Copy(switch_place) | Operand::Move(switch_place),"}, {"sha": "fca9f7eeb24613cff074538de800b7f2e1afe507", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -386,14 +386,17 @@ impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n         trace!(\"running SimplifyArmIdentity on {:?}\", source);\n \n         let local_uses = LocalUseCounter::get_local_uses(body);\n-        let (basic_blocks, local_decls, debug_info) =\n-            body.basic_blocks_local_decls_mut_and_var_debug_info();\n-        for bb in basic_blocks {\n+        for bb in body.basic_blocks.as_mut() {\n             if let Some(opt_info) =\n-                get_arm_identity_info(&bb.statements, local_decls.len(), debug_info)\n+                get_arm_identity_info(&bb.statements, body.local_decls.len(), &body.var_debug_info)\n             {\n                 trace!(\"got opt_info = {:#?}\", opt_info);\n-                if !optimization_applies(&opt_info, local_decls, &local_uses, &debug_info) {\n+                if !optimization_applies(\n+                    &opt_info,\n+                    &body.local_decls,\n+                    &local_uses,\n+                    &body.var_debug_info,\n+                ) {\n                     debug!(\"optimization skipped for {:?}\", source);\n                     continue;\n                 }\n@@ -431,7 +434,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n \n                 // Fix the debug info to point to the right local\n                 for dbg_index in opt_info.dbg_info_to_adjust {\n-                    let dbg_info = &mut debug_info[dbg_index];\n+                    let dbg_info = &mut body.var_debug_info[dbg_index];\n                     assert!(\n                         matches!(dbg_info.value, VarDebugInfoContents::Place(_)),\n                         \"value was not a Place\""}, {"sha": "3291717c550df27d2a5a7b3f3ba51b61c1d0f2f2", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -886,8 +886,12 @@ impl<K: DepKind> DepGraph<K> {\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Saved file associated with this CGU.\n-    pub saved_file: String,\n+    /// Saved files associated with this CGU. In each key/value pair, the value is the path to the\n+    /// saved file and the key is some identifier for the type of file being saved.\n+    ///\n+    /// By convention, file extensions are currently used as identifiers, i.e. the key \"o\" maps to\n+    /// the object file's path, and \"dwo\" to the dwarf object file's path.\n+    pub saved_files: FxHashMap<String, String>,\n }\n \n // Index type for `DepNodeData`'s edges."}, {"sha": "efa73a79e9973e8b38a81c1c6411d20dccac4402", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -1705,8 +1705,8 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefI\n             ImplTrait(bounds)\n         }\n \n-        ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n-\n+        ty::Closure(..) => panic!(\"Closure\"),\n+        ty::Generator(..) => panic!(\"Generator\"),\n         ty::Bound(..) => panic!(\"Bound\"),\n         ty::Placeholder(..) => panic!(\"Placeholder\"),\n         ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n@@ -1760,7 +1760,6 @@ fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     match tcx.def_kind(parent) {\n         DefKind::Struct | DefKind::Union => false,\n         DefKind::Variant => true,\n-        // FIXME: what about DefKind::Ctor?\n         parent_kind => panic!(\"unexpected parent kind: {:?}\", parent_kind),\n     }\n }"}, {"sha": "7ec6eb0be652744ed614ae105ed71857a785d409", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -237,9 +237,6 @@ pub(crate) struct RenderOptions {\n     pub(crate) resource_suffix: String,\n     /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n     /// default.\n-    //\n-    // FIXME(misdreavus): the flag name is `--disable-minification` but the meaning is inverted\n-    // once read.\n     pub(crate) enable_minification: bool,\n     /// Whether to create an index page in the root of the output directory. If this is true but\n     /// `enable_index_page` is None, generate a static listing of crates instead."}, {"sha": "796bd7715180cf1675c5c6d7b0f320f052024fa6", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -1412,7 +1412,10 @@ fn render_impl(\n                         id, item_type, in_trait_class,\n                     );\n                     render_rightside(w, cx, item, containing_item, render_mode);\n-                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                    if trait_.is_some() {\n+                        // Anchors are only used on trait impls.\n+                        write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                    }\n                     w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                     render_assoc_item(\n                         w,\n@@ -1435,7 +1438,10 @@ fn render_impl(\n                     id, item_type, in_trait_class\n                 );\n                 render_rightside(w, cx, item, containing_item, render_mode);\n-                write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                if trait_.is_some() {\n+                    // Anchors are only used on trait impls.\n+                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                }\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_const(\n                     w,\n@@ -1457,7 +1463,10 @@ fn render_impl(\n                 let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n                 write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class);\n-                write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                if trait_.is_some() {\n+                    // Anchors are only used on trait impls.\n+                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                }\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_type(\n                     w,\n@@ -1480,7 +1489,10 @@ fn render_impl(\n                     \"<section id=\\\"{}\\\" class=\\\"{}{} has-srclink\\\">\",\n                     id, item_type, in_trait_class\n                 );\n-                write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                if trait_.is_some() {\n+                    // Anchors are only used on trait impls.\n+                    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+                }\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_type(\n                     w,"}, {"sha": "25c802d5a1d2e35471c6f143c7a263f724c4c33c", "filename": "src/test/incremental/split_debuginfo_cached.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fsplit_debuginfo_cached.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1,25 @@\n+// Check that compiling with packed Split DWARF twice succeeds. This should confirm that DWARF\n+// objects are cached as work products and available to the incremental compilation for `thorin` to\n+// pack into a DWARF package.\n+\n+// ignore-tidy-linelength\n+// only-x86_64-unknown-linux-gnu\n+// revisions:rpass1 rpass2\n+\n+// [rpass1]compile-flags: -g -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split\n+// [rpass2]compile-flags: -g -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split\n+\n+#![feature(rustc_attrs)]\n+// For `rpass2`, nothing has changed so everything should re-used.\n+#![rustc_partition_reused(module = \"split_debuginfo_cached\", cfg = \"rpass2\")]\n+#![rustc_partition_reused(module = \"split_debuginfo_cached-another_module\", cfg = \"rpass2\")]\n+\n+mod another_module {\n+    pub fn foo() -> &'static str {\n+        \"hello world\"\n+    }\n+}\n+\n+pub fn main() {\n+    println!(\"{}\", another_module::foo());\n+}"}, {"sha": "98f47e53038a99a0918f1b3b6ee2199930ea0c52", "filename": "src/test/rustdoc/anchors.no_const_anchor.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_const_anchor.html", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_const_anchor.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.no_const_anchor.html?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1 @@\n+<div id=\"associatedconstant.YOLO\" class=\"method has-srclink\"><div class=\"rightside\"><a class=\"srclink\" href=\"../src/foo/anchors.rs.html#16\">source</a></div><h4 class=\"code-header\">const <a href=\"#associatedconstant.YOLO\" class=\"constant\">YOLO</a>: <a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a></h4></div>"}, {"sha": "6d37e8e5eee5e1cd0b79a2f15728b3b3dce724d0", "filename": "src/test/rustdoc/anchors.no_const_anchor2.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_const_anchor2.html", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_const_anchor2.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.no_const_anchor2.html?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1 @@\n+<section id=\"associatedconstant.X\" class=\"associatedconstant has-srclink\"><span class=\"rightside\"><a class=\"srclink\" href=\"../src/foo/anchors.rs.html#42\">source</a></span><h4 class=\"code-header\">pub const <a href=\"#associatedconstant.X\" class=\"constant\">X</a>: <a class=\"primitive\" href=\"{{channel}}/std/primitive.i32.html\">i32</a> = 0i32</h4></section>"}, {"sha": "f46d3090ed37054ec5bbd86c69d510747f28f22d", "filename": "src/test/rustdoc/anchors.no_method_anchor.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_method_anchor.html", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_method_anchor.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.no_method_anchor.html?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1 @@\n+<section id=\"method.new\" class=\"method has-srclink\"><span class=\"rightside\"><a class=\"srclink\" href=\"../src/foo/anchors.rs.html#48\">source</a></span><h4 class=\"code-header\">pub fn <a href=\"#method.new\" class=\"fnname\">new</a>() -&gt; Self</h4></section>\n\\ No newline at end of file"}, {"sha": "445a7bb560acaf4baeb3a66a59603dc9bb1973d8", "filename": "src/test/rustdoc/anchors.no_trait_method_anchor.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_trait_method_anchor.html", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_trait_method_anchor.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.no_trait_method_anchor.html?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1 @@\n+<div id=\"method.bar\" class=\"method has-srclink\"><div class=\"rightside\"><a class=\"srclink\" href=\"../src/foo/anchors.rs.html#23\">source</a></div><h4 class=\"code-header\">fn <a href=\"#method.bar\" class=\"fnname\">bar</a>()</h4></div>\n\\ No newline at end of file"}, {"sha": "bb0771b10035dfe3867003cf49b5223f179ce690", "filename": "src/test/rustdoc/anchors.no_tymethod_anchor.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_tymethod_anchor.html", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_tymethod_anchor.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.no_tymethod_anchor.html?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1 @@\n+<div id=\"tymethod.foo\" class=\"method has-srclink\"><div class=\"rightside\"><a class=\"srclink\" href=\"../src/foo/anchors.rs.html#20\">source</a></div><h4 class=\"code-header\">fn <a href=\"#tymethod.foo\" class=\"fnname\">foo</a>()</h4></div>\n\\ No newline at end of file"}, {"sha": "d317eb5005017cb26f81b556d01236a02c83e8d4", "filename": "src/test/rustdoc/anchors.no_type_anchor.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_type_anchor.html", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_type_anchor.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.no_type_anchor.html?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1 @@\n+<div id=\"associatedtype.T\" class=\"method has-srclink\"><div class=\"rightside\"><a class=\"srclink\" href=\"../src/foo/anchors.rs.html#13\">source</a></div><h4 class=\"code-header\">type <a href=\"#associatedtype.T\" class=\"associatedtype\">T</a></h4></div>\n\\ No newline at end of file"}, {"sha": "72a1186bf7e301853072bcc0ec84267971911fba", "filename": "src/test/rustdoc/anchors.no_type_anchor2.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_type_anchor2.html", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.no_type_anchor2.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.no_type_anchor2.html?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1 @@\n+<section id=\"associatedtype.Y\" class=\"associatedtype has-srclink\"><h4 class=\"code-header\">type <a href=\"#associatedtype.Y\" class=\"associatedtype\">Y</a> = <a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a></h4></section>"}, {"sha": "034cf8eaf4ff7a5e34948cb552b2f5531587d531", "filename": "src/test/rustdoc/anchors.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Frustdoc%2Fanchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanchors.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -0,0 +1,49 @@\n+// This test ensures that anchors are generated in the right places.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+#![crate_name = \"foo\"]\n+\n+pub struct Foo;\n+\n+// @has 'foo/trait.Bar.html'\n+pub trait Bar {\n+    // There should be no anchors here.\n+    // @snapshot no_type_anchor - '//*[@id=\"associatedtype.T\"]'\n+    type T;\n+    // There should be no anchors here.\n+    // @snapshot no_const_anchor - '//*[@id=\"associatedconstant.YOLO\"]'\n+    const YOLO: u32;\n+\n+    // There should be no anchors here.\n+    // @snapshot no_tymethod_anchor - '//*[@id=\"tymethod.foo\"]'\n+    fn foo();\n+    // There should be no anchors here.\n+    // @snapshot no_trait_method_anchor - '//*[@id=\"method.bar\"]'\n+    fn bar() {}\n+}\n+\n+// @has 'foo/struct.Foo.html'\n+impl Bar for Foo {\n+    // @has - '//*[@id=\"associatedtype.T\"]/a[@class=\"anchor\"]' ''\n+    type T = u32;\n+    // @has - '//*[@id=\"associatedconstant.YOLO\"]/a[@class=\"anchor\"]' ''\n+    const YOLO: u32 = 0;\n+\n+    // @has - '//*[@id=\"method.foo\"]/a[@class=\"anchor\"]' ''\n+    fn foo() {}\n+    // Same check for provided \"bar\" method.\n+    // @has - '//*[@id=\"method.bar\"]/a[@class=\"anchor\"]' ''\n+}\n+\n+impl Foo {\n+    // @snapshot no_const_anchor2 - '//*[@id=\"associatedconstant.X\"]'\n+    // There should be no anchors here.\n+    pub const X: i32 = 0;\n+    // @snapshot no_type_anchor2 - '//*[@id=\"associatedtype.Y\"]'\n+    // There should be no anchors here.\n+    pub type Y = u32;\n+    // @snapshot no_method_anchor - '//*[@id=\"method.new\"]'\n+    // There should be no anchors here.\n+    pub fn new() -> Self { Self }\n+}"}, {"sha": "ebc3e2f8c0e314fcf2beba517bca0b533699ff2b", "filename": "src/test/ui/mir/ssa-analysis-regression-50041.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -5,7 +5,7 @@\n #![feature(lang_items)]\n #![no_std]\n \n-struct NonNull<T: ?Sized>(*mut T);\n+struct NonNull<T: ?Sized>(*const T);\n \n struct Unique<T: ?Sized>(NonNull<T>);\n \n@@ -23,7 +23,7 @@ unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n }\n \n #[inline(never)]\n-fn dealloc<T: ?Sized>(_: *mut T) {}\n+fn dealloc<T: ?Sized>(_: *const T) {}\n \n pub struct Foo<T>(T);\n "}, {"sha": "4f49bb879f5035c9b66e07a354089d681046e5e9", "filename": "src/tools/clippy/clippy_lints/src/duplicate_mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduplicate_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduplicate_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduplicate_mod.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{Crate, Inline, Item, ItemKind, ModKind};\n use rustc_errors::MultiSpan;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext, Level};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{FileName, Span};\n use std::collections::BTreeMap;\n@@ -49,6 +49,7 @@ declare_clippy_lint! {\n struct Modules {\n     local_path: PathBuf,\n     spans: Vec<Span>,\n+    lint_levels: Vec<Level>,\n }\n \n #[derive(Default)]\n@@ -70,13 +71,30 @@ impl EarlyLintPass for DuplicateMod {\n             let modules = self.modules.entry(absolute_path).or_insert(Modules {\n                 local_path,\n                 spans: Vec::new(),\n+                lint_levels: Vec::new(),\n             });\n             modules.spans.push(item.span_with_attributes());\n+            modules.lint_levels.push(cx.get_lint_level(DUPLICATE_MOD));\n         }\n     }\n \n     fn check_crate_post(&mut self, cx: &EarlyContext<'_>, _: &Crate) {\n-        for Modules { local_path, spans } in self.modules.values() {\n+        for Modules { local_path, spans, lint_levels } in self.modules.values() {\n+            if spans.len() < 2 {\n+                continue;\n+            }\n+\n+            // At this point the lint would be emitted\n+            assert_eq!(spans.len(), lint_levels.len());\n+            let spans: Vec<_> = spans.into_iter().zip(lint_levels).filter_map(|(span, lvl)|{\n+                if let Some(id) = lvl.get_expectation_id() {\n+                    cx.fulfill_expectation(id);\n+                }\n+\n+                (!matches!(lvl, Level::Allow | Level::Expect(_))).then_some(*span)\n+            })\n+            .collect();\n+\n             if spans.len() < 2 {\n                 continue;\n             }"}, {"sha": "eddca60457574822fb1917afc8fc9ac81f3233ce", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -161,7 +161,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 // `arg` is a reference as it is `.deref()`ed in the previous block.\n                 // Look into the predecessor block and find out the source of deref.\n \n-                let ps = &mir.predecessors()[bb];\n+                let ps = &mir.basic_blocks.predecessors()[bb];\n                 if ps.len() != 1 {\n                     continue;\n                 }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/clippy/tests/ui-cargo/duplicate_mod/fail/src/d.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fd.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29"}, {"sha": "99ca538b6e4a58bcecd21c2ea8bc7dc04037a9d5", "filename": "src/tools/clippy/tests/ui-cargo/duplicate_mod/fail/src/main.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fmain.rs?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -1,3 +1,5 @@\n+#[feature(lint_reasons)]\n+\n mod a;\n \n mod b;\n@@ -13,4 +15,15 @@ mod c3;\n mod from_other_module;\n mod other_module;\n \n+mod d;\n+#[path = \"d.rs\"]\n+mod d2;\n+#[path = \"d.rs\"]\n+#[expect(clippy::duplicate_mod)]\n+mod d3;\n+#[path = \"d.rs\"]\n+#[allow(clippy::duplicate_mod)]\n+mod d4;\n+\n+\n fn main() {}"}, {"sha": "61df1ad5d501aad6d95ea089f282af0e639d7ce0", "filename": "src/tools/clippy/tests/ui-cargo/duplicate_mod/fail/src/main.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fduplicate_mod%2Ffail%2Fsrc%2Fmain.stderr?ref=3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "patch": "@@ -1,5 +1,5 @@\n error: file is loaded as a module multiple times: `$DIR/b.rs`\n-  --> $DIR/main.rs:3:1\n+  --> $DIR/main.rs:5:1\n    |\n LL |   mod b;\n    |   ^^^^^^ first loaded here\n@@ -11,7 +11,7 @@ LL | | mod b2;\n    = help: replace all but one `mod` item with `use` items\n \n error: file is loaded as a module multiple times: `$DIR/c.rs`\n-  --> $DIR/main.rs:7:1\n+  --> $DIR/main.rs:9:1\n    |\n LL |   mod c;\n    |   ^^^^^^ first loaded here\n@@ -25,7 +25,7 @@ LL | | mod c3;\n    = help: replace all but one `mod` item with `use` items\n \n error: file is loaded as a module multiple times: `$DIR/from_other_module.rs`\n-  --> $DIR/main.rs:13:1\n+  --> $DIR/main.rs:15:1\n    |\n LL |   mod from_other_module;\n    |   ^^^^^^^^^^^^^^^^^^^^^^ first loaded here\n@@ -38,5 +38,16 @@ LL | | mod m;\n    |\n    = help: replace all but one `mod` item with `use` items\n \n-error: aborting due to 3 previous errors\n+error: file is loaded as a module multiple times: `$DIR/b.rs`\n+  --> $DIR/main.rs:18:1\n+   |\n+LL |   mod d;\n+   |   ^^^^^^ first loaded here\n+LL | / #[path = \"d.rs\"]\n+LL | | mod d2;\n+   | |_______^ loaded again here\n+   |\n+   = help: replace all but one `mod` item with `use` items\n+\n+error: aborting due to 4 previous errors\n "}]}