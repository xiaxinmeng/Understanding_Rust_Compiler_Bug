{"sha": "f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YmZkYTBhNmYzODUzZTQ4MjU1YjU1NTljY2JhNzZmYmNiZmNjNWE=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-04-21T10:55:43Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-05-06T05:21:48Z"}, "message": "core: tweaked flt2dec to match the casing of the older formatting code.", "tree": {"sha": "cfd71d878d2570bd363c87c86b5ac6df99ac691a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfd71d878d2570bd363c87c86b5ac6df99ac691a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a", "html_url": "https://github.com/rust-lang/rust/commit/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aa9f38285b47e2eadaaac0e343da90b922994f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa9f38285b47e2eadaaac0e343da90b922994f1", "html_url": "https://github.com/rust-lang/rust/commit/5aa9f38285b47e2eadaaac0e343da90b922994f1"}], "stats": {"total": 100, "additions": 50, "deletions": 50}, "files": [{"sha": "74b190085b3d30851087cc4181807a7e6048d875", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a", "patch": "@@ -396,10 +396,10 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n \n /// Formats given floating point number into the decimal form with at least\n /// given number of fractional digits. The result is stored to the supplied parts\n-/// array while utilizing given byte buffer as a scratch. `upper` is only used to\n-/// determine the case of non-finite values, i.e. `inf` and `nan`. The first part\n-/// to be rendered is always a `Part::Sign` (which can be an empty string\n-/// if no sign is rendered).\n+/// array while utilizing given byte buffer as a scratch. `upper` is currently\n+/// unused but left for the future decision to change the case of non-finite values,\n+/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// (which can be an empty string if no sign is rendered).\n ///\n /// `format_shortest` should be the underlying digit-generation function.\n /// You probably would want `strategy::grisu::format_shortest` for this.\n@@ -413,7 +413,7 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// There should be at least 5 parts available, due to the worst case like\n /// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n-                                 sign: Sign, frac_digits: usize, upper: bool,\n+                                 sign: Sign, frac_digits: usize, _upper: bool,\n                                  buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n         where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n     assert!(parts.len() >= 4);\n@@ -423,11 +423,11 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(if upper { b\"NAN\" } else { b\"nan\" });\n+            parts[0] = Part::Copy(b\"NaN\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(if upper { b\"INF\" } else { b\"inf\" });\n+            parts[0] = Part::Copy(b\"inf\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n@@ -479,11 +479,11 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(if upper { b\"NAN\" } else { b\"nan\" });\n+            parts[0] = Part::Copy(b\"NaN\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(if upper { b\"INF\" } else { b\"inf\" });\n+            parts[0] = Part::Copy(b\"inf\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n@@ -557,11 +557,11 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(if upper { b\"NAN\" } else { b\"nan\" });\n+            parts[0] = Part::Copy(b\"NaN\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(if upper { b\"INF\" } else { b\"inf\" });\n+            parts[0] = Part::Copy(b\"inf\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n@@ -589,10 +589,10 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n \n /// Formats given floating point number into the decimal form with exactly\n /// given number of fractional digits. The result is stored to the supplied parts\n-/// array while utilizing given byte buffer as a scratch. `upper` is only used to\n-/// determine the case of non-finite values, i.e. `inf` and `nan`. The first part\n-/// to be rendered is always a `Part::Sign` (which can be an empty string\n-/// if no sign is rendered).\n+/// array while utilizing given byte buffer as a scratch. `upper` is currently\n+/// unused but left for the future decision to change the case of non-finite values,\n+/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// (which can be an empty string if no sign is rendered).\n ///\n /// `format_exact` should be the underlying digit-generation function.\n /// You probably would want `strategy::grisu::format_exact` for this.\n@@ -603,7 +603,7 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n /// There should be at least 5 parts available, due to the worst case like\n /// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n-                                    sign: Sign, frac_digits: usize, upper: bool,\n+                                    sign: Sign, frac_digits: usize, _upper: bool,\n                                     buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n         where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     assert!(parts.len() >= 4);\n@@ -612,11 +612,11 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n     let sign = determine_sign(sign, &full_decoded, negative);\n     match full_decoded {\n         FullDecoded::Nan => {\n-            parts[0] = Part::Copy(if upper { b\"NAN\" } else { b\"nan\" });\n+            parts[0] = Part::Copy(b\"NaN\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n-            parts[0] = Part::Copy(if upper { b\"INF\" } else { b\"inf\" });\n+            parts[0] = Part::Copy(b\"inf\");\n             Formatted { sign: sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {"}, {"sha": "3ffec7c007e5fe8a556c5771fd6b145ffed3612a", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=f9bfda0a6f3853e48255b5559ccba76fbcbfcc5a", "patch": "@@ -544,17 +544,17 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8,  true), \"-0.00000000\");\n \n     assert_eq!(to_string(f,  1.0/0.0, Minus,         0, false), \"inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      0,  true), \"INF\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      0,  true), \"inf\");\n     assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     0, false), \"+inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  0,  true), \"+INF\");\n-    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NAN\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NAN\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  0,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NaN\");\n     assert_eq!(to_string(f, -1.0/0.0, Minus,         0, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-inf\");\n     assert_eq!(to_string(f, -1.0/0.0, MinusPlus,     8, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n \n     assert_eq!(to_string(f,  3.14, Minus,        0, false), \"3.14\");\n     assert_eq!(to_string(f,  3.14, MinusRaw,     0, false), \"3.14\");\n@@ -638,17 +638,17 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, -0.0, MinusPlusRaw, ( 5,  9), false), \"-0e0\");\n \n     assert_eq!(to_string(f,  1.0/0.0, Minus,        (-4, 16), false), \"inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,     (-4, 16),  true), \"INF\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,     (-4, 16),  true), \"inf\");\n     assert_eq!(to_string(f,  1.0/0.0, MinusPlus,    (-4, 16), false), \"+inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, (-4, 16),  true), \"+INF\");\n-    assert_eq!(to_string(f,  0.0/0.0, Minus,        ( 0,  0), false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,     ( 0,  0),  true), \"NAN\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,    (-9, -5), false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"NAN\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, (-4, 16),  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,        ( 0,  0), false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,     ( 0,  0),  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,    (-9, -5), false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"NaN\");\n     assert_eq!(to_string(f, -1.0/0.0, Minus,        ( 0,  0), false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     ( 0,  0),  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     ( 0,  0),  true), \"-inf\");\n     assert_eq!(to_string(f, -1.0/0.0, MinusPlus,    (-9, -5), false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"-inf\");\n \n     assert_eq!(to_string(f,  3.14, Minus,        (-4, 16), false), \"3.14\");\n     assert_eq!(to_string(f,  3.14, MinusRaw,     (-4, 16), false), \"3.14\");\n@@ -752,17 +752,17 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8, false), \"-0.0000000e0\");\n \n     assert_eq!(to_string(f,  1.0/0.0, Minus,         1, false), \"inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"INF\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"inf\");\n     assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     1, false), \"+inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  1,  true), \"+INF\");\n-    assert_eq!(to_string(f,  0.0/0.0, Minus,         8, false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      8,  true), \"NAN\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw,  8,  true), \"NAN\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  1,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      8,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw,  8,  true), \"NaN\");\n     assert_eq!(to_string(f, -1.0/0.0, Minus,        64, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     64,  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     64,  true), \"-inf\");\n     assert_eq!(to_string(f, -1.0/0.0, MinusPlus,    64, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n \n     assert_eq!(to_string(f,  3.14, Minus,        1,  true), \"3E0\");\n     assert_eq!(to_string(f,  3.14, MinusRaw,     1, false), \"3e0\");\n@@ -973,17 +973,17 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8,  true), \"-0.00000000\");\n \n     assert_eq!(to_string(f,  1.0/0.0, Minus,         0, false), \"inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"INF\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"inf\");\n     assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     8, false), \"+inf\");\n-    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, 64,  true), \"+INF\");\n-    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NAN\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"nan\");\n-    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NAN\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, 64,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NaN\");\n     assert_eq!(to_string(f, -1.0/0.0, Minus,         0, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-inf\");\n     assert_eq!(to_string(f, -1.0/0.0, MinusPlus,     8, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-INF\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n \n     assert_eq!(to_string(f,  3.14, Minus,        0, false), \"3\");\n     assert_eq!(to_string(f,  3.14, MinusRaw,     0, false), \"3\");"}]}