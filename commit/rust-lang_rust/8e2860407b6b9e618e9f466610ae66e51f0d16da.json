{"sha": "8e2860407b6b9e618e9f466610ae66e51f0d16da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMjg2MDQwN2I2YjllNjE4ZTlmNDY2NjEwYWU2NmU1MWYwZDE2ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-15T15:11:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-15T15:11:12Z"}, "message": "auto merge of #16887 : steveklabnik/rust/guide_iterators, r=alexcrichton\n\nThis isn't ready to merge yet.\r\n\r\nThe 'containers and iterators' guide is basically just a collection of stuff that should be in the module definitions. So I'm moving the guide to just an 'iterators' guide, and moved the info that was there into the right places.\r\n\r\nSo, is this a good path forward, and is all of the information still correct?", "tree": {"sha": "be2956a827d673ecf2fdd8573ded0908ccc60b06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be2956a827d673ecf2fdd8573ded0908ccc60b06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e2860407b6b9e618e9f466610ae66e51f0d16da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e2860407b6b9e618e9f466610ae66e51f0d16da", "html_url": "https://github.com/rust-lang/rust/commit/8e2860407b6b9e618e9f466610ae66e51f0d16da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e2860407b6b9e618e9f466610ae66e51f0d16da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e73156fe323e761b3bed4a20a1deb21fb4b9ec5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e73156fe323e761b3bed4a20a1deb21fb4b9ec5f", "html_url": "https://github.com/rust-lang/rust/commit/e73156fe323e761b3bed4a20a1deb21fb4b9ec5f"}, {"sha": "1b818020a062383c810170b18860caca553b5289", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b818020a062383c810170b18860caca553b5289", "html_url": "https://github.com/rust-lang/rust/commit/1b818020a062383c810170b18860caca553b5289"}], "stats": {"total": 457, "additions": 29, "deletions": 428}, "files": [{"sha": "e9bda17f4bc7d9956d5dadd65c8ccf0cb9fdc108", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 3, "deletions": 411, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -1,414 +1,6 @@\n % The Rust Containers and Iterators Guide\n \n-# Containers\n+This guide has been removed, with no direct replacement.\n \n-The container traits are defined in the `std::container` module.\n-\n-## Unique vectors\n-\n-Vectors have `O(1)` indexing, push (to the end) and pop (from the end). Vectors\n-are the most common container in Rust, and are flexible enough to fit many use\n-cases.\n-\n-Vectors can also be sorted and used as efficient lookup tables with the\n-`bsearch()` method, if all the elements are inserted at one time and\n-deletions are unnecessary.\n-\n-## Maps and sets\n-\n-Maps are collections of unique keys with corresponding values, and sets are\n-just unique keys without a corresponding value. The `Map` and `Set` traits in\n-`std::container` define the basic interface.\n-\n-The standard library provides three owned map/set types:\n-\n-* `collections::HashMap` and `collections::HashSet`, requiring the keys to\n-  implement `Eq` and `Hash`\n-* `collections::TrieMap` and `collections::TrieSet`, requiring the keys to be `uint`\n-* `collections::TreeMap` and `collections::TreeSet`, requiring the keys\n-  to implement `Ord`\n-\n-These maps do not use managed pointers so they can be sent between tasks as\n-long as the key and value types are sendable. Neither the key or value type has\n-to be copyable.\n-\n-The `TrieMap` and `TreeMap` maps are ordered, while `HashMap` uses an arbitrary\n-order.\n-\n-Each `HashMap` instance has a random 128-bit key to use with a keyed hash,\n-making the order of a set of keys in a given hash table randomized. Rust\n-provides a [SipHash](https://131002.net/siphash/) implementation for any type\n-implementing the `Hash` trait.\n-\n-## Double-ended queues\n-\n-The `collections::ringbuf` module implements a double-ended queue with `O(1)`\n-amortized inserts and removals from both ends of the container. It also has\n-`O(1)` indexing like a vector. The contained elements are not required to be\n-copyable, and the queue will be sendable if the contained type is sendable.\n-Its interface `Deque` is defined in `collections`.\n-\n-The `extra::dlist` module implements a double-ended linked list, also\n-implementing the `Deque` trait, with `O(1)` removals and inserts at either end,\n-and `O(1)` concatenation.\n-\n-## Priority queues\n-\n-The `collections::priority_queue` module implements a queue ordered by a key.  The\n-contained elements are not required to be copyable, and the queue will be\n-sendable if the contained type is sendable.\n-\n-Insertions have `O(log n)` time complexity and checking or popping the largest\n-element is `O(1)`. Converting a vector to a priority queue can be done\n-in-place, and has `O(n)` complexity. A priority queue can also be converted to\n-a sorted vector in-place, allowing it to be used for an `O(n log n)` in-place\n-heapsort.\n-\n-# Iterators\n-\n-## Iteration protocol\n-\n-The iteration protocol is defined by the `Iterator` trait in the\n-`std::iter` module. The minimal implementation of the trait is a `next`\n-method, yielding the next element from an iterator object:\n-\n-~~~\n-/// An infinite stream of zeroes\n-struct ZeroStream;\n-\n-impl Iterator<int> for ZeroStream {\n-    fn next(&mut self) -> Option<int> {\n-        Some(0)\n-    }\n-}\n-~~~\n-\n-Reaching the end of the iterator is signalled by returning `None` instead of\n-`Some(item)`:\n-\n-~~~\n-# fn main() {}\n-/// A stream of N zeroes\n-struct ZeroStream {\n-    remaining: uint\n-}\n-\n-impl ZeroStream {\n-    fn new(n: uint) -> ZeroStream {\n-        ZeroStream { remaining: n }\n-    }\n-}\n-\n-impl Iterator<int> for ZeroStream {\n-    fn next(&mut self) -> Option<int> {\n-        if self.remaining == 0 {\n-            None\n-        } else {\n-            self.remaining -= 1;\n-            Some(0)\n-        }\n-    }\n-}\n-~~~\n-\n-In general, you cannot rely on the behavior of the `next()` method after it has\n-returned `None`. Some iterators may return `None` forever. Others may behave\n-differently.\n-\n-## Container iterators\n-\n-Containers implement iteration over the contained elements by returning an\n-iterator object. For example, for vector slices several iterators are available:\n-\n-* `iter()` for immutable references to the elements\n-* `mut_iter()` for mutable references to the elements\n-* `move_iter()` to move the elements out by-value\n-\n-A typical mutable container will implement at least `iter()`, `mut_iter()` and\n-`move_iter()`. If it maintains an order, the returned iterators will be\n-`DoubleEndedIterator`s, which are described below.\n-\n-### Freezing\n-\n-Unlike most other languages with external iterators, Rust has no *iterator\n-invalidation*. As long as an iterator is still in scope, the compiler will prevent\n-modification of the container through another handle.\n-\n-~~~\n-let mut xs = [1i, 2, 3];\n-{\n-    let _it = xs.iter();\n-\n-    // the vector is frozen for this scope, the compiler will statically\n-    // prevent modification\n-}\n-// the vector becomes unfrozen again at the end of the scope\n-~~~\n-\n-These semantics are due to most container iterators being implemented with `&`\n-and `&mut`.\n-\n-## Iterator adaptors\n-\n-The `Iterator` trait provides many common algorithms as default methods. For\n-example, the `fold` method will accumulate the items yielded by an `Iterator`\n-into a single value:\n-\n-~~~\n-let xs = [1i, 9, 2, 3, 14, 12];\n-let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n-assert_eq!(result, -41);\n-~~~\n-\n-Most adaptors return an adaptor object implementing the `Iterator` trait itself:\n-\n-~~~\n-let xs = [1i, 9, 2, 3, 14, 12];\n-let ys = [5i, 2, 1, 8];\n-let sum = xs.iter().chain(ys.iter()).fold(0, |a, b| a + *b);\n-assert_eq!(sum, 57);\n-~~~\n-\n-Some iterator adaptors may return `None` before exhausting the underlying\n-iterator. Additionally, if these iterator adaptors are called again after\n-returning `None`, they may call their underlying iterator again even if the\n-adaptor will continue to return `None` forever. This may not be desired if the\n-underlying iterator has side-effects.\n-\n-In order to provide a guarantee about behavior once `None` has been returned, an\n-iterator adaptor named `fuse()` is provided. This returns an iterator that will\n-never call its underlying iterator again once `None` has been returned:\n-\n-~~~\n-let xs = [1i,2,3,4,5];\n-let mut calls = 0i;\n-\n-{\n-    let it = xs.iter().scan((), |_, x| {\n-        calls += 1;\n-        if *x < 3 { Some(x) } else { None }});\n-\n-    // the iterator will only yield 1 and 2 before returning None\n-    // If we were to call it 5 times, calls would end up as 5, despite\n-    // only 2 values being yielded (and therefore 3 unique calls being\n-    // made). The fuse() adaptor can fix this.\n-\n-    let mut it = it.fuse();\n-    it.next();\n-    it.next();\n-    it.next();\n-    it.next();\n-    it.next();\n-}\n-\n-assert_eq!(calls, 3);\n-~~~\n-\n-## For loops\n-\n-The function `range` (or `range_inclusive`) allows to simply iterate through a given range:\n-\n-~~~\n-for i in range(0i, 5) {\n-  print!(\"{} \", i) // prints \"0 1 2 3 4\"\n-}\n-\n-for i in std::iter::range_inclusive(0i, 5) { // needs explicit import\n-  print!(\"{} \", i) // prints \"0 1 2 3 4 5\"\n-}\n-~~~\n-\n-The `for` keyword can be used as sugar for iterating through any iterator:\n-\n-~~~\n-let xs = [2u, 3, 5, 7, 11, 13, 17];\n-\n-// print out all the elements in the vector\n-for x in xs.iter() {\n-    println!(\"{}\", *x)\n-}\n-\n-// print out all but the first 3 elements in the vector\n-for x in xs.iter().skip(3) {\n-    println!(\"{}\", *x)\n-}\n-~~~\n-\n-For loops are *often* used with a temporary iterator object, as above. They can\n-also advance the state of an iterator in a mutable location:\n-\n-~~~\n-let xs = [1i, 2, 3, 4, 5];\n-let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n-\n-// create an iterator yielding tuples of elements from both vectors\n-let mut it = xs.iter().zip(ys.iter());\n-\n-// print out the pairs of elements up to (&3, &\"baz\")\n-for (x, y) in it {\n-    println!(\"{} {}\", *x, *y);\n-\n-    if *x == 3 {\n-        break;\n-    }\n-}\n-\n-// yield and print the last pair from the iterator\n-println!(\"last: {}\", it.next());\n-\n-// the iterator is now fully consumed\n-assert!(it.next().is_none());\n-~~~\n-\n-## Conversion\n-\n-Iterators offer generic conversion to containers with the `collect` adaptor:\n-\n-~~~\n-let xs = [0i, 1, 1, 2, 3, 5, 8];\n-let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<Vec<int>>();\n-assert_eq!(ys, vec![10, 6, 4, 2, 2, 0]);\n-~~~\n-\n-The method requires a type hint for the container type, if the surrounding code\n-does not provide sufficient information.\n-\n-Containers can provide conversion from iterators through `collect` by\n-implementing the `FromIterator` trait. For example, the implementation for\n-vectors is as follows:\n-\n-~~~ {.ignore}\n-impl<T> FromIterator<T> for Vec<T> {\n-    fn from_iter<I:Iterator<A>>(mut iterator: I) -> Vec<T> {\n-        let (lower, _) = iterator.size_hint();\n-        let mut vector = Vec::with_capacity(lower);\n-        for element in iterator {\n-            vector.push(element);\n-        }\n-        vector\n-    }\n-}\n-~~~\n-\n-### Size hints\n-\n-The `Iterator` trait provides a `size_hint` default method, returning a lower\n-bound and optionally on upper bound on the length of the iterator:\n-\n-~~~ {.ignore}\n-fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n-~~~\n-\n-The vector implementation of `FromIterator` from above uses the lower bound\n-to pre-allocate enough space to hold the minimum number of elements the\n-iterator will yield.\n-\n-The default implementation is always correct, but it should be overridden if\n-the iterator can provide better information.\n-\n-The `ZeroStream` from earlier can provide an exact lower and upper bound:\n-\n-~~~\n-# fn main() {}\n-/// A stream of N zeroes\n-struct ZeroStream {\n-    remaining: uint\n-}\n-\n-impl ZeroStream {\n-    fn new(n: uint) -> ZeroStream {\n-        ZeroStream { remaining: n }\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining, Some(self.remaining))\n-    }\n-}\n-\n-impl Iterator<int> for ZeroStream {\n-    fn next(&mut self) -> Option<int> {\n-        if self.remaining == 0 {\n-            None\n-        } else {\n-            self.remaining -= 1;\n-            Some(0)\n-        }\n-    }\n-}\n-~~~\n-\n-## Double-ended iterators\n-\n-The `DoubleEndedIterator` trait represents an iterator able to yield elements\n-from either end of a range. It inherits from the `Iterator` trait and extends\n-it with the `next_back` function.\n-\n-A `DoubleEndedIterator` can have its direction changed with the `rev` adaptor,\n-returning another `DoubleEndedIterator` with `next` and `next_back` exchanged.\n-\n-~~~\n-let xs = [1i, 2, 3, 4, 5, 6];\n-let mut it = xs.iter();\n-println!(\"{}\", it.next()); // prints `Some(1)`\n-println!(\"{}\", it.next()); // prints `Some(2)`\n-println!(\"{}\", it.next_back()); // prints `Some(6)`\n-\n-// prints `5`, `4` and `3`\n-for &x in it.rev() {\n-    println!(\"{}\", x)\n-}\n-~~~\n-\n-The `chain`, `map`, `filter`, `filter_map` and `inspect` adaptors are\n-`DoubleEndedIterator` implementations if the underlying iterators are.\n-\n-~~~\n-let xs = [1i, 2, 3, 4];\n-let ys = [5i, 6, 7, 8];\n-let mut it = xs.iter().chain(ys.iter()).map(|&x| x * 2);\n-\n-println!(\"{}\", it.next()); // prints `Some(2)`\n-\n-// prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\n-for x in it.rev() {\n-    println!(\"{}\", x);\n-}\n-~~~\n-\n-The `reverse_` method is also available for any double-ended iterator yielding\n-mutable references. It can be used to reverse a container in-place. Note that\n-the trailing underscore is a workaround for issue #5898 and will be removed.\n-\n-~~~\n-let mut ys = [1i, 2, 3, 4, 5];\n-ys.mut_iter().reverse_();\n-assert!(ys == [5i, 4, 3, 2, 1]);\n-~~~\n-\n-## Random-access iterators\n-\n-The `RandomAccessIterator` trait represents an iterator offering random access\n-to the whole range. The `indexable` method retrieves the number of elements\n-accessible with the `idx` method.\n-\n-The `chain` adaptor is an implementation of `RandomAccessIterator` if the\n-underlying iterators are.\n-\n-~~~\n-let xs = [1i, 2, 3, 4, 5];\n-let ys = [7i, 9, 11];\n-let mut it = xs.iter().chain(ys.iter());\n-println!(\"{}\", it.idx(0)); // prints `Some(1)`\n-println!(\"{}\", it.idx(5)); // prints `Some(7)`\n-println!(\"{}\", it.idx(7)); // prints `Some(11)`\n-println!(\"{}\", it.idx(8)); // prints `None`\n-\n-// yield two elements from the beginning, and one from the end\n-it.next();\n-it.next();\n-it.next_back();\n-\n-println!(\"{}\", it.idx(0)); // prints `Some(3)`\n-println!(\"{}\", it.idx(4)); // prints `Some(9)`\n-println!(\"{}\", it.idx(6)); // prints `None`\n-~~~\n+You may enjoy reading the [iterator](std/iter/index.html) and\n+[collections](std/collections/index.html) documentation."}, {"sha": "475c3b748db7ff292fd29595ef9828dc66e16e97", "filename": "src/doc/index.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -57,7 +57,6 @@ a guide that can help you out:\n * [Strings](guide-strings.html)\n * [Pointers](guide-pointers.html)\n * [References and Lifetimes](guide-lifetimes.html)\n-* [Containers and Iterators](guide-container.html)\n * [Tasks and Communication](guide-tasks.html)\n * [Foreign Function Interface](guide-ffi.html)\n * [Writing Unsafe and Low-Level Code](guide-unsafe.html)"}, {"sha": "68e2086d042a36e45789949d7c10c096bf79ab3c", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -10,6 +10,11 @@\n \n //! A priority queue implemented with a binary heap.\n //!\n+//! Insertions have `O(log n)` time complexity and checking or popping the largest element is\n+//! `O(1)`. Converting a vector to a priority queue can be done in-place, and has `O(n)`\n+//! complexity. A priority queue can also be converted to a sorted vector in-place, allowing it to\n+//! be used for an `O(n log n)` in-place heapsort.\n+//!\n //! # Example\n //!\n //! This is a larger example which implements [Dijkstra's algorithm][dijkstra]"}, {"sha": "aa745ef39ee13a23d44da8b96573d30b2a0cb154", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A double-ended queue implemented as a circular buffer.\n-//!\n-//! `RingBuf` implements the trait `Deque`. It should be imported with\n-//! `use collections::Deque`.\n+//! This crate implements a double-ended queue with `O(1)` amortized inserts and removals from both\n+//! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n+//! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n+//! Its interface `Deque` is defined in `collections`.\n \n use core::prelude::*;\n "}, {"sha": "354edae473fd58450e86eed411b3f05ae5b65ba2", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! An ordered map and set implemented as self-balancing binary search\n-//! trees. The only requirement for the types is that the key implements\n-//! `Ord`.\n+//! Maps are collections of unique keys with corresponding values, and sets are\n+//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n+//! `std::container` define the basic interface.\n+//!\n+//! This crate defines the `TreeMap` and `TreeSet` types. Their keys must implement `Ord`.\n+//!\n+//! `TreeMap`s are ordered.\n //!\n //! ## Example\n //!"}, {"sha": "7d60d3a85e1288483d7997f73ef7bcbbc26bac4b", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Ordered containers with unsigned integer keys,\n-//! implemented as radix tries (`TrieSet` and `TrieMap` types).\n+//! Maps are collections of unique keys with corresponding values, and sets are\n+//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n+//! `std::container` define the basic interface.\n+//!\n+//! This crate defines `TrieMap` and `TrieSet`, which require `uint` keys.\n+//!\n+//! `TrieMap` is ordered.\n \n use core::prelude::*;\n "}, {"sha": "14b74c17e9bd06183e98caa497352a7857618e8f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! An owned, growable vector.\n+//! A growable list type, written `Vec<T>` but pronounced 'vector.'\n+//!\n+//! Vectors have `O(1)` indexing, push (to the end) and pop (from the end).\n \n use core::prelude::*;\n "}, {"sha": "cf977a6ebe60377594cf3eebcfc2e38e58c4622a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2860407b6b9e618e9f466610ae66e51f0d16da/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=8e2860407b6b9e618e9f466610ae66e51f0d16da", "patch": "@@ -56,12 +56,6 @@ loop {\n \n This `for` loop syntax can be applied to any iterator over any type.\n \n-## Iteration protocol and more\n-\n-More detailed information about iterators can be found in the [container\n-guide](http://doc.rust-lang.org/guide-container.html) with\n-the rest of the rust manuals.\n-\n */\n \n use clone::Clone;"}]}