{"sha": "61f35f0641efe60c4e804be046922aa232666797", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZjM1ZjA2NDFlZmU2MGM0ZTgwNGJlMDQ2OTIyYWEyMzI2NjY3OTc=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-07T09:10:51Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-07T14:03:20Z"}, "message": "Adjust generic const param resolution", "tree": {"sha": "27c79727623fe127b15030263bb7fd36d4b4fddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27c79727623fe127b15030263bb7fd36d4b4fddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61f35f0641efe60c4e804be046922aa232666797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61f35f0641efe60c4e804be046922aa232666797", "html_url": "https://github.com/rust-lang/rust/commit/61f35f0641efe60c4e804be046922aa232666797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61f35f0641efe60c4e804be046922aa232666797/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4", "html_url": "https://github.com/rust-lang/rust/commit/bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4"}], "stats": {"total": 217, "additions": 65, "deletions": 152}, "files": [{"sha": "5c095994a1bbd422f3a55d4b883b7de11db6ec37", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61f35f0641efe60c4e804be046922aa232666797/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f35f0641efe60c4e804be046922aa232666797/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=61f35f0641efe60c4e804be046922aa232666797", "patch": "@@ -1642,20 +1642,6 @@ fn main() {\n ```\n \"##,\n \n-E0670: r##\"\n-Const parameters cannot depend on type parameters.\n-The following is therefore invalid:\n-\n-```compile_fail,E0670\n-#![feature(const_generics)]\n-\n-fn const_id<T, const N: T>() -> T {\n-    // ERROR: const parameters cannot depend on type parameters\n-    N\n-}\n-```\n-\"##,\n-\n }\n \n register_diagnostics! {"}, {"sha": "ebd6b0eb5dab0b29fbc40303b80fada1c9710a77", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 65, "deletions": 110, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/61f35f0641efe60c4e804be046922aa232666797/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f35f0641efe60c4e804be046922aa232666797/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=61f35f0641efe60c4e804be046922aa232666797", "patch": "@@ -15,7 +15,7 @@ use rustc_errors as errors;\n \n pub use rustc::hir::def::{Namespace, PerNS};\n \n-use TypeParameters::*;\n+use GenericParameters::*;\n use RibKind::*;\n \n use rustc::hir::map::{Definitions, DefCollector};\n@@ -51,7 +51,6 @@ use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generi\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n-use syntax::ast::ParamKindOrd;\n use syntax::ptr::P;\n use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n \n@@ -143,8 +142,8 @@ impl Ord for BindingError {\n }\n \n enum ResolutionError<'a> {\n-    /// error E0401: can't use type or const parameters from outer function\n-    ParametersFromOuterFunction(Def, ParamKindOrd),\n+    /// error E0401: can't use type parameters from outer function\n+    TypeParametersFromOuterFunction(Def),\n     /// error E0403: the name is already used for a type/const parameter in this list of\n     /// generic parameters\n     NameAlreadyUsedInParameterList(Name, &'a Span),\n@@ -180,8 +179,6 @@ enum ResolutionError<'a> {\n     BindingShadowsSomethingUnacceptable(&'a str, Name, &'a NameBinding<'a>),\n     /// error E0128: type parameters with a default cannot use forward declared identifiers\n     ForwardDeclaredTyParam, // FIXME(const_generics:defaults)\n-    /// error E0670: const parameter cannot depend on type parameter\n-    ConstParamDependentOnTypeParam,\n }\n \n /// Combines an error with provided span and emits it\n@@ -199,14 +196,13 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                                    resolution_error: ResolutionError<'a>)\n                                    -> DiagnosticBuilder<'sess> {\n     match resolution_error {\n-        ResolutionError::ParametersFromOuterFunction(outer_def, kind) => {\n+        ResolutionError::TypeParametersFromOuterFunction(outer_def) => {\n             let mut err = struct_span_err!(resolver.session,\n                 span,\n                 E0401,\n-                \"can't use {} parameters from outer function\",\n-                kind,\n+                \"can't use type parameters from outer function\",\n             );\n-            err.span_label(span, format!(\"use of {} variable from outer function\", kind));\n+            err.span_label(span, format!(\"use of type variable from outer function\"));\n \n             let cm = resolver.session.source_map();\n             match outer_def {\n@@ -235,20 +231,15 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                         err.span_label(span, \"type variable from outer function\");\n                     }\n                 }\n-                Def::ConstParam(def_id) => {\n-                    if let Some(span) = resolver.definitions.opt_span(def_id) {\n-                        err.span_label(span, \"const variable from outer function\");\n-                    }\n-                }\n                 _ => {\n                     bug!(\"TypeParametersFromOuterFunction should only be used with Def::SelfTy, \\\n-                         Def::TyParam or Def::ConstParam\");\n+                         Def::TyParam\");\n                 }\n             }\n \n             // Try to retrieve the span of the function signature and generate a new message with\n             // a local type or const parameter.\n-            let sugg_msg = &format!(\"try using a local {} parameter instead\", kind);\n+            let sugg_msg = &format!(\"try using a local type parameter instead\");\n             if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n                 // Suggest the modification to the user\n                 err.span_suggestion(\n@@ -259,9 +250,9 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                 );\n             } else if let Some(sp) = cm.generate_fn_name_span(span) {\n                 err.span_label(sp,\n-                    format!(\"try adding a local {} parameter in this method instead\", kind));\n+                    format!(\"try adding a local type parameter in this method instead\"));\n             } else {\n-                err.help(&format!(\"try using a local {} parameter instead\", kind));\n+                err.help(&format!(\"try using a local type parameter instead\"));\n             }\n \n             err\n@@ -428,12 +419,6 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                 span, \"defaulted type parameters cannot be forward declared\".to_string());\n             err\n         }\n-        ResolutionError::ConstParamDependentOnTypeParam => {\n-            let mut err = struct_span_err!(resolver.session, span, E0670,\n-                                           \"const parameters cannot depend on type parameters\");\n-            err.span_label(span, format!(\"const parameter depends on type parameter\"));\n-            err\n-        }\n     }\n }\n \n@@ -766,6 +751,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         self.resolve_block(block);\n     }\n     fn visit_anon_const(&mut self, constant: &'tcx ast::AnonConst) {\n+        debug!(\"visit_anon_const {:?}\", constant);\n         self.with_constant_rib(|this| {\n             visit::walk_anon_const(this, constant);\n         });\n@@ -799,15 +785,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n-        let type_parameters = match foreign_item.node {\n+        let generic_params = match foreign_item.node {\n             ForeignItemKind::Fn(_, ref generics) => {\n-                HasTypeParameters(generics, ItemRibKind)\n+                HasGenericParams(generics, ItemRibKind)\n             }\n-            ForeignItemKind::Static(..) => NoTypeParameters,\n-            ForeignItemKind::Ty => NoTypeParameters,\n-            ForeignItemKind::Macro(..) => NoTypeParameters,\n+            ForeignItemKind::Static(..) => NoGenericParams,\n+            ForeignItemKind::Ty => NoGenericParams,\n+            ForeignItemKind::Macro(..) => NoGenericParams,\n         };\n-        self.with_type_parameter_rib(type_parameters, |this| {\n+        self.with_generic_param_rib(generic_params, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n@@ -896,16 +882,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 }\n             }));\n \n-        // We also ban access to type parameters for use as the types of const parameters.\n-        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n-        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n-            .filter(|param| if let GenericParamKind::Type { .. } = param.kind {\n-                true\n-            } else {\n-                false\n-            })\n-            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Def::Err)));\n-\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n@@ -924,15 +900,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                     default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n-                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n-\n                     for bound in &param.bounds {\n                         self.visit_param_bound(bound);\n                     }\n \n                     self.visit_ty(ty);\n-\n-                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n                 }\n             }\n         }\n@@ -943,9 +915,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n }\n \n #[derive(Copy, Clone)]\n-enum TypeParameters<'a, 'b> {\n-    NoTypeParameters,\n-    HasTypeParameters(// Type parameters.\n+enum GenericParameters<'a, 'b> {\n+    NoGenericParams,\n+    HasGenericParams(// Type parameters.\n                       &'b Generics,\n \n                       // The kind of the rib used for type parameters.\n@@ -985,9 +957,6 @@ enum RibKind<'a> {\n     /// from the default of a type parameter because they're not declared\n     /// before said type parameter. Also see the `visit_generics` override.\n     ForwardTyParamBanRibKind,\n-\n-    /// We forbid the use of type parameters as the types of const parameters.\n-    TyParamAsConstParamTy,\n }\n \n /// One local scope.\n@@ -2405,8 +2374,9 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n+        debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n-            this.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n+            this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n                 let item_def_id = this.definitions.local_def_id(item.id);\n                 this.with_self_rib(Def::SelfTy(None, Some(item_def_id)), |this| {\n                     visit::walk_item(this, item);\n@@ -2459,13 +2429,13 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.ident.name;\n-        debug!(\"(resolving item) resolving {}\", name);\n+        debug!(\"(resolving item) resolving {} ({:?})\", name, item.node);\n \n         match item.node {\n             ItemKind::Ty(_, ref generics) |\n             ItemKind::Fn(_, _, ref generics, _) |\n             ItemKind::Existential(_, ref generics) => {\n-                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind),\n+                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind),\n                                              |this| visit::walk_item(this, item));\n             }\n \n@@ -2484,16 +2454,16 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n+                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n \n                         for trait_item in trait_items {\n-                            let type_parameters = HasTypeParameters(&trait_item.generics,\n+                            let generic_params = HasGenericParams(&trait_item.generics,\n                                                                     TraitOrImplItemRibKind);\n-                            this.with_type_parameter_rib(type_parameters, |this| {\n+                            this.with_generic_param_rib(generic_params, |this| {\n                                 match trait_item.node {\n                                     TraitItemKind::Const(ref ty, ref default) => {\n                                         this.visit_ty(ty);\n@@ -2525,7 +2495,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n+                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n@@ -2542,6 +2512,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Static(ref ty, _, ref expr) |\n             ItemKind::Const(ref ty, ref expr) => {\n+                debug!(\"resolve_item ItemKind::Const\");\n                 self.with_item_rib(|this| {\n                     this.visit_ty(ty);\n                     this.with_constant_rib(|this| {\n@@ -2563,19 +2534,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_type_parameter_rib<'b, F>(&'b mut self, type_parameters: TypeParameters<'a, 'b>, f: F)\n+    fn with_generic_param_rib<'b, F>(&'b mut self, generic_params: GenericParameters<'a, 'b>, f: F)\n         where F: FnOnce(&mut Resolver<'_>)\n     {\n-        match type_parameters {\n-            HasTypeParameters(generics, rib_kind) => {\n+        debug!(\"with_generic_param_rib\");\n+        match generic_params {\n+            HasGenericParams(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n+                let mut function_value_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap::default();\n                 for param in &generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {}\n                         GenericParamKind::Type { .. } => {\n                             let ident = param.ident.modern();\n-                            debug!(\"with_type_parameter_rib: {}\", param.id);\n+                            debug!(\"with_generic_param_rib: {}\", param.id);\n \n                             if seen_bindings.contains_key(&ident) {\n                                 let span = seen_bindings.get(&ident).unwrap();\n@@ -2594,7 +2567,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         GenericParamKind::Const { .. } => {\n                             let ident = param.ident.modern();\n-                            debug!(\"with_type_parameter_rib: {}\", param.id);\n+                            debug!(\"with_generic_param_rib: {}\", param.id);\n \n                             if seen_bindings.contains_key(&ident) {\n                                 let span = seen_bindings.get(&ident).unwrap();\n@@ -2607,23 +2580,25 @@ impl<'a> Resolver<'a> {\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n                             let def = Def::ConstParam(self.definitions.local_def_id(param.id));\n-                            function_type_rib.bindings.insert(ident, def);\n+                            function_value_rib.bindings.insert(ident, def);\n                             self.record_def(param.id, PathResolution::new(def));\n                         }\n                     }\n                 }\n+                self.ribs[ValueNS].push(function_value_rib);\n                 self.ribs[TypeNS].push(function_type_rib);\n             }\n \n-            NoTypeParameters => {\n+            NoGenericParams => {\n                 // Nothing to do.\n             }\n         }\n \n         f(self);\n \n-        if let HasTypeParameters(..) = type_parameters {\n+        if let HasGenericParams(..) = generic_params {\n             self.ribs[TypeNS].pop();\n+            self.ribs[ValueNS].pop();\n         }\n     }\n \n@@ -2648,6 +2623,7 @@ impl<'a> Resolver<'a> {\n     fn with_constant_rib<F>(&mut self, f: F)\n         where F: FnOnce(&mut Resolver<'_>)\n     {\n+        debug!(\"with_constant_rib\");\n         self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n         self.label_ribs.push(Rib::new(ConstantItemRibKind));\n         f(self);\n@@ -2741,8 +2717,9 @@ impl<'a> Resolver<'a> {\n                               self_type: &Ty,\n                               item_id: NodeId,\n                               impl_items: &[ImplItem]) {\n+        debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n+        self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n             this.with_self_rib(Def::SelfTy(None, None), |this| {\n                 // Resolve the trait reference, if necessary.\n@@ -2755,30 +2732,37 @@ impl<'a> Resolver<'a> {\n                         }\n                         // Resolve the self type.\n                         this.visit_ty(self_type);\n-                        // Resolve the type parameters.\n+                        // Resolve the generic parameters.\n                         this.visit_generics(generics);\n                         // Resolve the items within the impl.\n                         this.with_current_self_type(self_type, |this| {\n                             this.with_self_struct_ctor_rib(item_def_id, |this| {\n+                                debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n                                 for impl_item in impl_items {\n                                     this.resolve_visibility(&impl_item.vis);\n \n                                     // We also need a new scope for the impl item type parameters.\n-                                    let type_parameters = HasTypeParameters(&impl_item.generics,\n-                                                                            TraitOrImplItemRibKind);\n-                                    this.with_type_parameter_rib(type_parameters, |this| {\n+                                    let generic_params = HasGenericParams(&impl_item.generics,\n+                                                                          TraitOrImplItemRibKind);\n+                                    this.with_generic_param_rib(generic_params, |this| {\n                                         use self::ResolutionError::*;\n                                         match impl_item.node {\n                                             ImplItemKind::Const(..) => {\n+                                                debug!(\n+                                                    \"resolve_implementation ImplItemKind::Const\",\n+                                                );\n                                                 // If this is a trait impl, ensure the const\n                                                 // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      ValueNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| ConstNotMemberOfTrait(n, s));\n-                                                this.with_constant_rib(|this|\n-                                                    visit::walk_impl_item(this, impl_item)\n+                                                this.check_trait_item(\n+                                                    impl_item.ident,\n+                                                    ValueNS,\n+                                                    impl_item.span,\n+                                                    |n, s| ConstNotMemberOfTrait(n, s),\n                                                 );\n+\n+                                                this.with_constant_rib(|this| {\n+                                                    visit::walk_impl_item(this, impl_item)\n+                                                });\n                                             }\n                                             ImplItemKind::Method(..) => {\n                                                 // If this is a trait impl, ensure the method\n@@ -4157,6 +4141,7 @@ impl<'a> Resolver<'a> {\n                         mut def: Def,\n                         record_used: bool,\n                         span: Span) -> Def {\n+        debug!(\"adjust_local_def\");\n         let ribs = &self.ribs[ns][rib_index + 1..];\n \n         // An invalid forward use of a type parameter from a previous default.\n@@ -4168,15 +4153,6 @@ impl<'a> Resolver<'a> {\n             return Def::Err;\n         }\n \n-        // An invalid use of a type parameter as the type of a const parameter.\n-        if let TyParamAsConstParamTy = self.ribs[ns][rib_index].kind {\n-            if record_used {\n-                resolve_error(self, span, ResolutionError::ConstParamDependentOnTypeParam);\n-            }\n-            assert_eq!(def, Def::Err);\n-            return Def::Err;\n-        }\n-\n         match def {\n             Def::Upvar(..) => {\n                 span_bug!(span, \"unexpected {:?} in bindings\", def)\n@@ -4185,7 +4161,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n-                        ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n+                        ForwardTyParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -4238,7 +4214,7 @@ impl<'a> Resolver<'a> {\n                     match rib.kind {\n                         NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n-                        ConstantItemRibKind | TyParamAsConstParamTy => {\n+                        ConstantItemRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind => {\n@@ -4247,35 +4223,14 @@ impl<'a> Resolver<'a> {\n                                 resolve_error(\n                                     self,\n                                     span,\n-                                    ResolutionError::ParametersFromOuterFunction(\n-                                        def,\n-                                        ParamKindOrd::Type,\n-                                    ),\n+                                    ResolutionError::TypeParametersFromOuterFunction(def),\n                                 );\n                             }\n                             return Def::Err;\n                         }\n                     }\n                 }\n             }\n-            Def::ConstParam(..) => {\n-                for rib in ribs {\n-                    if let ItemRibKind = rib.kind {\n-                        // This was an attempt to use a const parameter outside its scope.\n-                        if record_used {\n-                            resolve_error(\n-                                self,\n-                                span,\n-                                ResolutionError::ParametersFromOuterFunction(\n-                                    def,\n-                                    ParamKindOrd::Const,\n-                                ),\n-                            );\n-                        }\n-                        return Def::Err;\n-                    }\n-                }\n-            }\n             _ => {}\n         }\n         def"}, {"sha": "06ee523be48538c41a05bde639b02840559be232", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs?ref=bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4", "patch": "@@ -1,7 +0,0 @@\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n-\n-pub struct Dependent<T, const X: T>([(); X]); //~ ERROR const parameters\n-//~^ ERROR const generics in any position are currently unsupported\n-\n-fn main() {}"}, {"sha": "375c9fa53219dac6770132e076d6df1887b88d43", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr?ref=bbdcc4e7ce697bbd6ad398987c5e4ec4928f5da4", "patch": "@@ -1,21 +0,0 @@\n-warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n-  --> $DIR/const-param-type-depends-on-type-param.rs:1:12\n-   |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n-\n-error[E0670]: const parameters cannot depend on type parameters\n-  --> $DIR/const-param-type-depends-on-type-param.rs:4:34\n-   |\n-LL | pub struct Dependent<T, const X: T>([(); X]); //~ ERROR const parameters\n-   |                                  ^ const parameter depends on type parameter\n-\n-error: const generics in any position are currently unsupported\n-  --> $DIR/const-param-type-depends-on-type-param.rs:4:31\n-   |\n-LL | pub struct Dependent<T, const X: T>([(); X]); //~ ERROR const parameters\n-   |                               ^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0670`."}]}