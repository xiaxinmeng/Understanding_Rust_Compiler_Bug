{"sha": "93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZGM2ZjUxMWJlZGI3YzE4MzE5YmJmM2VmZTQ3YTdkYjRiMmFhNTM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-23T17:27:04Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-23T17:27:04Z"}, "message": "Diagnose #[cfg]s in bodies", "tree": {"sha": "c12c45372521a19b24c749e41f7472906afff037", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c12c45372521a19b24c749e41f7472906afff037"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "html_url": "https://github.com/rust-lang/rust/commit/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd8a75b2cf46a967b3449652fe17c19a8fcc4e41", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd8a75b2cf46a967b3449652fe17c19a8fcc4e41", "html_url": "https://github.com/rust-lang/rust/commit/dd8a75b2cf46a967b3449652fe17c19a8fcc4e41"}], "stats": {"total": 316, "additions": 218, "deletions": 98}, "files": [{"sha": "864f9c0c84f109bfc625cdea339ebe5068b24765", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -781,6 +781,7 @@ impl Function {\n     }\n \n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+        hir_def::diagnostics::validate_body(db.upcast(), self.id.into(), sink);\n         hir_ty::diagnostics::validate_module_item(db, self.id.into(), sink);\n         hir_ty::diagnostics::validate_body(db, self.id.into(), sink);\n     }"}, {"sha": "d10b1af0192b4bb2a1e9de2ce7ba8b5bb525db60", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -1,6 +1,9 @@\n //! Defines `Body`: a lowered representation of bodies of functions, statics and\n //! consts.\n mod lower;\n+mod diagnostics;\n+#[cfg(test)]\n+mod tests;\n pub mod scope;\n \n use std::{mem, ops::Index, sync::Arc};\n@@ -10,7 +13,10 @@ use base_db::CrateId;\n use cfg::CfgOptions;\n use drop_bomb::DropBomb;\n use either::Either;\n-use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile, MacroDefId};\n+use hir_expand::{\n+    ast_id_map::AstIdMap, diagnostics::DiagnosticSink, hygiene::Hygiene, AstId, HirFileId, InFile,\n+    MacroDefId,\n+};\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstNode, AstPtr};\n use test_utils::mark;\n@@ -150,8 +156,12 @@ impl Expander {\n         InFile { file_id: self.current_file_id, value }\n     }\n \n-    pub(crate) fn is_cfg_enabled(&self, owner: &dyn ast::AttrsOwner) -> bool {\n-        self.cfg_expander.is_cfg_enabled(owner)\n+    pub(crate) fn parse_attrs(&self, owner: &dyn ast::AttrsOwner) -> Attrs {\n+        self.cfg_expander.parse_attrs(owner)\n+    }\n+\n+    pub(crate) fn cfg_options(&self) -> &CfgOptions {\n+        &self.cfg_expander.cfg_options\n     }\n \n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n@@ -219,6 +229,10 @@ pub struct BodySourceMap {\n     pat_map_back: ArenaMap<PatId, Result<PatSource, SyntheticSyntax>>,\n     field_map: FxHashMap<(ExprId, usize), InFile<AstPtr<ast::RecordExprField>>>,\n     expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n+\n+    /// Diagnostics accumulated during body lowering. These contain `AstPtr`s and so are stored in\n+    /// the source map (since they're just as volatile).\n+    diagnostics: Vec<diagnostics::BodyDiagnostic>,\n }\n \n #[derive(Default, Debug, Eq, PartialEq, Clone, Copy)]\n@@ -318,45 +332,10 @@ impl BodySourceMap {\n     pub fn field_syntax(&self, expr: ExprId, field: usize) -> InFile<AstPtr<ast::RecordExprField>> {\n         self.field_map[&(expr, field)].clone()\n     }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use base_db::{fixture::WithFixture, SourceDatabase};\n-    use test_utils::mark;\n \n-    use crate::ModuleDefId;\n-\n-    use super::*;\n-\n-    fn lower(ra_fixture: &str) -> Arc<Body> {\n-        let (db, file_id) = crate::test_db::TestDB::with_single_file(ra_fixture);\n-\n-        let krate = db.crate_graph().iter().next().unwrap();\n-        let def_map = db.crate_def_map(krate);\n-        let module = def_map.modules_for_file(file_id).next().unwrap();\n-        let module = &def_map[module];\n-        let fn_def = match module.scope.declarations().next().unwrap() {\n-            ModuleDefId::FunctionId(it) => it,\n-            _ => panic!(),\n-        };\n-\n-        db.body(fn_def.into())\n-    }\n-\n-    #[test]\n-    fn your_stack_belongs_to_me() {\n-        mark::check!(your_stack_belongs_to_me);\n-        lower(\n-            \"\n-macro_rules! n_nuple {\n-    ($e:tt) => ();\n-    ($($rest:tt)*) => {{\n-        (n_nuple!($($rest)*)None,)\n-    }};\n-}\n-fn main() { n_nuple!(1,2,3); }\n-\",\n-        );\n+    pub(crate) fn add_diagnostics(&self, _db: &dyn DefDatabase, sink: &mut DiagnosticSink<'_>) {\n+        for diag in &self.diagnostics {\n+            diag.add_to(sink);\n+        }\n     }\n }"}, {"sha": "cfa47d189baceee75dadaf5c5860292d1e9d5668", "filename": "crates/hir_def/src/body/diagnostics.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fdiagnostics.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -0,0 +1,20 @@\n+//! Diagnostics emitted during body lowering.\n+\n+use hir_expand::diagnostics::DiagnosticSink;\n+\n+use crate::diagnostics::InactiveCode;\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub enum BodyDiagnostic {\n+    InactiveCode(InactiveCode),\n+}\n+\n+impl BodyDiagnostic {\n+    pub fn add_to(&self, sink: &mut DiagnosticSink<'_>) {\n+        match self {\n+            BodyDiagnostic::InactiveCode(diag) => {\n+                sink.push(diag.clone());\n+            }\n+        }\n+    }\n+}"}, {"sha": "ddc267b83b71f916a705ef33c8919d1aee174c64", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -16,7 +16,7 @@ use syntax::{\n         self, ArgListOwner, ArrayExprKind, AstChildren, LiteralKind, LoopBodyOwner, NameOwner,\n         SlicePatComponents,\n     },\n-    AstNode, AstPtr,\n+    AstNode, AstPtr, SyntaxNodePtr,\n };\n use test_utils::mark;\n \n@@ -25,6 +25,7 @@ use crate::{\n     body::{Body, BodySourceMap, Expander, PatPtr, SyntheticSyntax},\n     builtin_type::{BuiltinFloat, BuiltinInt},\n     db::DefDatabase,\n+    diagnostics::InactiveCode,\n     expr::{\n         dummy_expr_id, ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal,\n         LogicOp, MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n@@ -37,7 +38,7 @@ use crate::{\n     StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n-use super::{ExprSource, PatSource};\n+use super::{diagnostics::BodyDiagnostic, ExprSource, PatSource};\n \n pub(crate) struct LowerCtx {\n     hygiene: Hygiene,\n@@ -176,7 +177,7 @@ impl ExprCollector<'_> {\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = AstPtr::new(&expr);\n-        if !self.expander.is_cfg_enabled(&expr) {\n+        if self.check_cfg(&expr).is_none() {\n             return self.missing_expr();\n         }\n \n@@ -354,13 +355,15 @@ impl ExprCollector<'_> {\n                 let arms = if let Some(match_arm_list) = e.match_arm_list() {\n                     match_arm_list\n                         .arms()\n-                        .map(|arm| MatchArm {\n-                            pat: self.collect_pat_opt(arm.pat()),\n-                            expr: self.collect_expr_opt(arm.expr()),\n-                            guard: arm\n-                                .guard()\n-                                .and_then(|guard| guard.expr())\n-                                .map(|e| self.collect_expr(e)),\n+                        .filter_map(|arm| {\n+                            self.check_cfg(&arm).map(|()| MatchArm {\n+                                pat: self.collect_pat_opt(arm.pat()),\n+                                expr: self.collect_expr_opt(arm.expr()),\n+                                guard: arm\n+                                    .guard()\n+                                    .and_then(|guard| guard.expr())\n+                                    .map(|e| self.collect_expr(e)),\n+                            })\n                         })\n                         .collect()\n                 } else {\n@@ -406,9 +409,8 @@ impl ExprCollector<'_> {\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n                         .filter_map(|field| {\n-                            if !self.expander.is_cfg_enabled(&field) {\n-                                return None;\n-                            }\n+                            self.check_cfg(&field)?;\n+\n                             let name = field.field_name()?.as_name();\n \n                             Some(RecordLitField {\n@@ -620,15 +622,23 @@ impl ExprCollector<'_> {\n             .filter_map(|s| {\n                 let stmt = match s {\n                     ast::Stmt::LetStmt(stmt) => {\n+                        self.check_cfg(&stmt)?;\n+\n                         let pat = self.collect_pat_opt(stmt.pat());\n                         let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                         let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                         Statement::Let { pat, type_ref, initializer }\n                     }\n                     ast::Stmt::ExprStmt(stmt) => {\n+                        self.check_cfg(&stmt)?;\n+\n                         Statement::Expr(self.collect_expr_opt(stmt.expr()))\n                     }\n-                    ast::Stmt::Item(_) => return None,\n+                    ast::Stmt::Item(item) => {\n+                        self.check_cfg(&item)?;\n+\n+                        return None;\n+                    }\n                 };\n                 Some(stmt)\n             })\n@@ -872,6 +882,28 @@ impl ExprCollector<'_> {\n \n         (args, ellipsis)\n     }\n+\n+    /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when\n+    /// not.\n+    fn check_cfg(&mut self, owner: &dyn ast::AttrsOwner) -> Option<()> {\n+        match self.expander.parse_attrs(owner).cfg() {\n+            Some(cfg) => {\n+                if self.expander.cfg_options().check(&cfg) != Some(false) {\n+                    return Some(());\n+                }\n+\n+                self.source_map.diagnostics.push(BodyDiagnostic::InactiveCode(InactiveCode {\n+                    file: self.expander.current_file_id,\n+                    node: SyntaxNodePtr::new(owner.syntax()),\n+                    cfg,\n+                    opts: self.expander.cfg_options().clone(),\n+                }));\n+\n+                None\n+            }\n+            None => Some(()),\n+        }\n+    }\n }\n \n impl From<ast::BinOp> for BinaryOp {"}, {"sha": "f07df5cee551f4bf9fde45ee0aee9de0a6914dae", "filename": "crates/hir_def/src/body/tests.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -0,0 +1,75 @@\n+use base_db::{fixture::WithFixture, SourceDatabase};\n+use test_utils::mark;\n+\n+use crate::{test_db::TestDB, ModuleDefId};\n+\n+use super::*;\n+\n+fn lower(ra_fixture: &str) -> Arc<Body> {\n+    let (db, file_id) = crate::test_db::TestDB::with_single_file(ra_fixture);\n+\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n+    let module = def_map.modules_for_file(file_id).next().unwrap();\n+    let module = &def_map[module];\n+    let fn_def = match module.scope.declarations().next().unwrap() {\n+        ModuleDefId::FunctionId(it) => it,\n+        _ => panic!(),\n+    };\n+\n+    db.body(fn_def.into())\n+}\n+\n+fn check_diagnostics(ra_fixture: &str) {\n+    let db: TestDB = TestDB::with_files(ra_fixture);\n+    db.check_diagnostics();\n+}\n+\n+#[test]\n+fn your_stack_belongs_to_me() {\n+    mark::check!(your_stack_belongs_to_me);\n+    lower(\n+        \"\n+macro_rules! n_nuple {\n+    ($e:tt) => ();\n+    ($($rest:tt)*) => {{\n+        (n_nuple!($($rest)*)None,)\n+    }};\n+}\n+fn main() { n_nuple!(1,2,3); }\n+\",\n+    );\n+}\n+\n+#[test]\n+fn cfg_diagnostics() {\n+    check_diagnostics(\n+        r\"\n+fn f() {\n+    // The three g\u0336e\u0336n\u0336d\u0336e\u0336r\u0336s\u0336 statements:\n+\n+    #[cfg(a)] fn f() {}  // Item statement\n+  //^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    #[cfg(a)] {}         // Expression statement\n+  //^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    #[cfg(a)] let x = 0; // let statement\n+  //^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+\n+    abc(#[cfg(a)] 0);\n+      //^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    let x = Struct {\n+        #[cfg(a)] f: 0,\n+      //^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    };\n+    match () {\n+        () => (),\n+        #[cfg(a)] () => (),\n+      //^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+    }\n+\n+    #[cfg(a)] 0          // Trailing expression of block\n+  //^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+}\n+    \",\n+    );\n+}"}, {"sha": "90d9cdcbaafdbbb3d67f34bdd8c849d5f9c75932", "filename": "crates/hir_def/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -4,10 +4,17 @@ use std::any::Any;\n use stdx::format_to;\n \n use cfg::{CfgExpr, CfgOptions, DnfExpr};\n-use hir_expand::diagnostics::{Diagnostic, DiagnosticCode};\n+use hir_expand::diagnostics::{Diagnostic, DiagnosticCode, DiagnosticSink};\n use hir_expand::{HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n+use crate::{db::DefDatabase, DefWithBodyId};\n+\n+pub fn validate_body(db: &dyn DefDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n+    let source_map = db.body_with_source_map(owner).1;\n+    source_map.add_diagnostics(db, sink);\n+}\n+\n // Diagnostic: unresolved-module\n //\n // This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n@@ -91,7 +98,7 @@ impl Diagnostic for UnresolvedImport {\n // Diagnostic: unconfigured-code\n //\n // This diagnostic is shown for code with inactive `#[cfg]` attributes.\n-#[derive(Debug)]\n+#[derive(Debug, Clone, Eq, PartialEq)]\n pub struct InactiveCode {\n     pub file: HirFileId,\n     pub node: SyntaxNodePtr,"}, {"sha": "1a7b988318e895ee0103779dafcb66d0c3d7ca25", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -1,42 +1,10 @@\n use base_db::fixture::WithFixture;\n-use base_db::FileId;\n-use base_db::SourceDatabaseExt;\n-use hir_expand::db::AstDatabase;\n-use rustc_hash::FxHashMap;\n-use syntax::TextRange;\n-use syntax::TextSize;\n \n use crate::test_db::TestDB;\n \n fn check_diagnostics(ra_fixture: &str) {\n     let db: TestDB = TestDB::with_files(ra_fixture);\n-    let annotations = db.extract_annotations();\n-    assert!(!annotations.is_empty());\n-\n-    let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n-    db.diagnostics(|d| {\n-        let src = d.display_source();\n-        let root = db.parse_or_expand(src.file_id).unwrap();\n-        // FIXME: macros...\n-        let file_id = src.file_id.original_file(&db);\n-        let range = src.value.to_node(&root).text_range();\n-        let message = d.message().to_owned();\n-        actual.entry(file_id).or_default().push((range, message));\n-    });\n-\n-    for (file_id, diags) in actual.iter_mut() {\n-        diags.sort_by_key(|it| it.0.start());\n-        let text = db.file_text(*file_id);\n-        // For multiline spans, place them on line start\n-        for (range, content) in diags {\n-            if text[*range].contains('\\n') {\n-                *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n-                *content = format!(\"... {}\", content);\n-            }\n-        }\n-    }\n-\n-    assert_eq!(annotations, actual);\n+    db.check_diagnostics();\n }\n \n #[test]"}, {"sha": "2b36c824a764e3857c3261d5b2973d95aa996387", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -12,10 +12,10 @@ use hir_expand::diagnostics::Diagnostic;\n use hir_expand::diagnostics::DiagnosticSinkBuilder;\n use rustc_hash::FxHashMap;\n use rustc_hash::FxHashSet;\n-use syntax::TextRange;\n+use syntax::{TextRange, TextSize};\n use test_utils::extract_annotations;\n \n-use crate::db::DefDatabase;\n+use crate::{db::DefDatabase, ModuleDefId};\n \n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n@@ -135,9 +135,47 @@ impl TestDB {\n             let crate_def_map = self.crate_def_map(krate);\n \n             let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n-            for (module_id, _) in crate_def_map.modules.iter() {\n+            for (module_id, module) in crate_def_map.modules.iter() {\n                 crate_def_map.add_diagnostics(self, module_id, &mut sink);\n+\n+                for decl in module.scope.declarations() {\n+                    if let ModuleDefId::FunctionId(it) = decl {\n+                        let source_map = self.body_with_source_map(it.into()).1;\n+                        source_map.add_diagnostics(self, &mut sink);\n+                    }\n+                }\n             }\n         }\n     }\n+\n+    pub fn check_diagnostics(&self) {\n+        let db: &TestDB = self;\n+        let annotations = db.extract_annotations();\n+        assert!(!annotations.is_empty());\n+\n+        let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n+        db.diagnostics(|d| {\n+            let src = d.display_source();\n+            let root = db.parse_or_expand(src.file_id).unwrap();\n+            // FIXME: macros...\n+            let file_id = src.file_id.original_file(db);\n+            let range = src.value.to_node(&root).text_range();\n+            let message = d.message().to_owned();\n+            actual.entry(file_id).or_default().push((range, message));\n+        });\n+\n+        for (file_id, diags) in actual.iter_mut() {\n+            diags.sort_by_key(|it| it.0.start());\n+            let text = db.file_text(*file_id);\n+            // For multiline spans, place them on line start\n+            for (range, content) in diags {\n+                if text[*range].contains('\\n') {\n+                    *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n+                    *content = format!(\"... {}\", content);\n+                }\n+            }\n+        }\n+\n+        assert_eq!(annotations, actual);\n+    }\n }"}, {"sha": "0b3cbcdde1b4f334277ce7f6e70f4d4d8f3573f4", "filename": "docs/user/generated_diagnostic.adoc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/docs%2Fuser%2Fgenerated_diagnostic.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/93dc6f511bedb7c18319bbf3efe47a7db4b2aa53/docs%2Fuser%2Fgenerated_diagnostic.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_diagnostic.adoc?ref=93dc6f511bedb7c18319bbf3efe47a7db4b2aa53", "patch": "@@ -82,24 +82,24 @@ This diagnostic is triggered if created structure does not have field provided i\n \n \n === unconfigured-code\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L90[diagnostics.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L98[diagnostics.rs]\n \n This diagnostic is shown for code with inactive `#[cfg]` attributes.\n \n \n === unresolved-extern-crate\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L35[diagnostics.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L43[diagnostics.rs]\n \n This diagnostic is triggered if rust-analyzer is unable to discover referred extern crate.\n \n \n === unresolved-import\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L59[diagnostics.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L67[diagnostics.rs]\n \n This diagnostic is triggered if rust-analyzer is unable to discover imported module.\n \n \n === unresolved-module\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L10[diagnostics.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L18[diagnostics.rs]\n \n This diagnostic is triggered if rust-analyzer is unable to discover referred module."}]}