{"sha": "4876693708975a9ae3076512a4f76238907fd15b", "node_id": "C_kwDOAAsO6NoAKDQ4NzY2OTM3MDg5NzVhOWFlMzA3NjUxMmE0Zjc2MjM4OTA3ZmQxNWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T10:57:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T10:57:23Z"}, "message": "Auto merge of #13408 - lowr:patch/bump-chalk-0.86, r=Veykril\n\nBump chalk\n\nThere's a bug in current chalk that prevents us from properly supporting GATs, which is supposed to be fixed in v0.86. Note the following:\n- v0.86 is only going to be released next Sunday so I'll keep this PR as draft until then.\n- This doesn't compile without https://github.com/rust-lang/chalk/pull/779, which I hope will be included in v0.86. I confirmed this compiles with it locally.\n\nTwo breaking changes from v0.84:\n- `TypeFolder` has been split into `TypeFolder` and `FallibleTypeFolder` (https://github.com/rust-lang/chalk/pull/772)\n- `ProjectionTy::self_type_parameter()` has been removed (https://github.com/rust-lang/chalk/pull/778)", "tree": {"sha": "b463d2ed22f1cacf031dd4c8358594f15dcd2053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b463d2ed22f1cacf031dd4c8358594f15dcd2053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4876693708975a9ae3076512a4f76238907fd15b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4876693708975a9ae3076512a4f76238907fd15b", "html_url": "https://github.com/rust-lang/rust/commit/4876693708975a9ae3076512a4f76238907fd15b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4876693708975a9ae3076512a4f76238907fd15b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8406380b5a4c0686a4147cb3b50ad70dfb38a4d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8406380b5a4c0686a4147cb3b50ad70dfb38a4d9", "html_url": "https://github.com/rust-lang/rust/commit/8406380b5a4c0686a4147cb3b50ad70dfb38a4d9"}, {"sha": "310a72bf472901ff238aa499dc7175353de67528", "url": "https://api.github.com/repos/rust-lang/rust/commits/310a72bf472901ff238aa499dc7175353de67528", "html_url": "https://github.com/rust-lang/rust/commit/310a72bf472901ff238aa499dc7175353de67528"}], "stats": {"total": 205, "additions": 103, "deletions": 102}, "files": [{"sha": "0ddea2f728d7806bb5d363b95a6214de6c88c5b4", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -171,9 +171,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf29c109d57f8d57b0e7675391be37a9285d86dd93278bd5f14a0ad3c447a6c2\"\n+checksum = \"5499d415d855b5094366a824815341893ad3de0ecb6048c430118bdae6d27402\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -183,9 +183,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d391763027b5e50a5e15caf6d2857ec585fd68160367bbeac9e1804209620918\"\n+checksum = \"3800118c76a48507b0eece3a01f3a429b5c478d203c493096e6040c67ab960e1\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -194,9 +194,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afafd92dcdc7fe0ea940ee94bdd8cc5bd18f4a4a84c593d6d7025fe16c150478\"\n+checksum = \"1baf60628fd73104d1f8562586a52d48f37f1e84435aab2e62674b1fd935b8c8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -207,9 +207,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3af1d111f11c91c48ace02e93e470c5bae6d2631bd112e4545317da53660d7fc\"\n+checksum = \"0e9c3c068f9358786348e58a1b94ef0a5cf90a9810fc1f10fda896f0b5d80185\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -544,6 +544,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"base-db\",\n+ \"chalk-derive\",\n  \"chalk-ir\",\n  \"chalk-recursive\",\n  \"chalk-solve\","}, {"sha": "286ef1e7dcb4dfde854c8ee20ab38575fed61264", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -27,6 +27,7 @@ debug = 0\n # chalk-solve = { path = \"../chalk/chalk-solve\" }\n # chalk-ir = { path = \"../chalk/chalk-ir\" }\n # chalk-recursive = { path = \"../chalk/chalk-recursive\" }\n+# chalk-derive = { path = \"../chalk/chalk-derive\" }\n \n # ungrammar = { path = \"../ungrammar\" }\n "}, {"sha": "ed13275bab8fecd36b516048b8c8d17188123805", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -18,9 +18,10 @@ ena = \"0.14.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\"\n-chalk-solve = { version = \"0.84.0\", default-features = false }\n-chalk-ir = \"0.84.0\"\n-chalk-recursive = { version = \"0.84.0\", default-features = false }\n+chalk-solve = { version = \"0.86.0\", default-features = false }\n+chalk-ir = \"0.86.0\"\n+chalk-recursive = { version = \"0.86.0\", default-features = false }\n+chalk-derive = \"0.86.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.15.0\"\n typed-arena = \"2.0.1\""}, {"sha": "43c3451cab37bb865c74e65b0cf39027f0354892", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -823,10 +823,10 @@ pub(super) fn generic_predicate_to_inline_bound(\n             Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n-            if projection_ty.self_type_parameter(Interner) != self_ty_shifted_in {\n+            let trait_ = projection_ty.trait_(db);\n+            if projection_ty.self_type_parameter(db) != self_ty_shifted_in {\n                 return None;\n             }\n-            let trait_ = projection_ty.trait_(db);\n             let args_no_self = projection_ty.substitution.as_slice(Interner)[1..]\n                 .iter()\n                 .map(|ty| ty.clone().cast(Interner))"}, {"sha": "e2099d7e509278b9b8ce8cb031c89d107f6c0972", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -262,7 +262,7 @@ impl TyExt for Ty {\n                                     WhereClause::AliasEq(AliasEq {\n                                         alias: AliasTy::Projection(proj),\n                                         ty: _,\n-                                    }) => &proj.self_type_parameter(Interner) == self,\n+                                    }) => &proj.self_type_parameter(db) == self,\n                                     _ => false,\n                                 })\n                                 .collect::<Vec<_>>();\n@@ -333,6 +333,7 @@ impl TyExt for Ty {\n pub trait ProjectionTyExt {\n     fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef;\n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId;\n+    fn self_type_parameter(&self, db: &dyn HirDatabase) -> Ty;\n }\n \n impl ProjectionTyExt for ProjectionTy {\n@@ -349,6 +350,10 @@ impl ProjectionTyExt for ProjectionTy {\n             _ => panic!(\"projection ty without parent trait\"),\n         }\n     }\n+\n+    fn self_type_parameter(&self, db: &dyn HirDatabase) -> Ty {\n+        self.trait_ref(db).self_type_parameter(Interner)\n+    }\n }\n \n pub trait TraitRefExt {"}, {"sha": "0221f922feb2ff396a2c602880eb1ad363dab60e", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -291,7 +291,7 @@ impl HirDisplay for ProjectionTy {\n \n         let trait_ = f.db.trait_data(self.trait_(f.db));\n         write!(f, \"<\")?;\n-        self.self_type_parameter(Interner).hir_fmt(f)?;\n+        self.self_type_parameter(f.db).hir_fmt(f)?;\n         write!(f, \" as {}\", trait_.name)?;\n         if self.substitution.len(Interner) > 1 {\n             write!(f, \"<\")?;\n@@ -731,7 +731,7 @@ impl HirDisplay for Ty {\n                                         WhereClause::AliasEq(AliasEq {\n                                             alias: AliasTy::Projection(proj),\n                                             ty: _,\n-                                        }) => &proj.self_type_parameter(Interner) == self,\n+                                        }) => &proj.self_type_parameter(f.db) == self,\n                                         _ => false,\n                                     })\n                                     .collect::<Vec<_>>();"}, {"sha": "b00e3216b2d2ce7c384c09ff42f71f152a80bf1a", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -4,7 +4,7 @@ use std::{fmt, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::TypeFoldable, interner::HasInterner, zip::Zip, CanonicalVarKind, FloatTy,\n-    IntTy, NoSolution, TyVariableKind, UniverseIndex,\n+    IntTy, TyVariableKind, UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n@@ -331,7 +331,6 @@ impl<'a> InferenceTable<'a> {\n             &mut resolve::Resolver { table: self, var_stack, fallback },\n             DebruijnIndex::INNERMOST,\n         )\n-        .expect(\"fold failed unexpectedly\")\n     }\n \n     pub(crate) fn resolve_completely<T>(&mut self, t: T) -> T\n@@ -452,13 +451,14 @@ impl<'a> InferenceTable<'a> {\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         use chalk_ir::fold::TypeFolder;\n+\n+        #[derive(chalk_derive::FallibleTypeFolder)]\n+        #[has_interner(Interner)]\n         struct VarFudger<'a, 'b> {\n             table: &'a mut InferenceTable<'b>,\n             highest_known_var: InferenceVar,\n         }\n         impl<'a, 'b> TypeFolder<Interner> for VarFudger<'a, 'b> {\n-            type Error = NoSolution;\n-\n             fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n                 self\n             }\n@@ -472,37 +472,37 @@ impl<'a> InferenceTable<'a> {\n                 var: chalk_ir::InferenceVar,\n                 kind: TyVariableKind,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Ty<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Ty<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_ty(Interner, kind)\n                 } else {\n                     self.table.new_type_var()\n-                })\n+                }\n             }\n \n             fn fold_inference_lifetime(\n                 &mut self,\n                 var: chalk_ir::InferenceVar,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Lifetime<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Lifetime<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_lifetime(Interner)\n                 } else {\n                     self.table.new_lifetime_var()\n-                })\n+                }\n             }\n \n             fn fold_inference_const(\n                 &mut self,\n                 ty: chalk_ir::Ty<Interner>,\n                 var: chalk_ir::InferenceVar,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Const<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Const<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_const(Interner, ty)\n                 } else {\n                     self.table.new_const_var(ty)\n-                })\n+                }\n             }\n         }\n \n@@ -512,7 +512,6 @@ impl<'a> InferenceTable<'a> {\n         self.rollback_to(snapshot);\n         result\n             .fold_with(&mut VarFudger { table: self, highest_known_var }, DebruijnIndex::INNERMOST)\n-            .expect(\"fold_with with VarFudger\")\n     }\n \n     /// This checks whether any of the free variables in the `canonicalized`\n@@ -639,21 +638,24 @@ mod resolve {\n     use chalk_ir::{\n         cast::Cast,\n         fold::{TypeFoldable, TypeFolder},\n-        Fallible, NoSolution,\n     };\n     use hir_def::type_ref::ConstScalar;\n \n-    pub(super) struct Resolver<'a, 'b, F> {\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    pub(super) struct Resolver<\n+        'a,\n+        'b,\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n+    > {\n         pub(super) table: &'a mut InferenceTable<'b>,\n         pub(super) var_stack: &'a mut Vec<InferenceVar>,\n         pub(super) fallback: F,\n     }\n-    impl<'a, 'b, 'i, F> TypeFolder<Interner> for Resolver<'a, 'b, F>\n+    impl<'a, 'b, F> TypeFolder<Interner> for Resolver<'a, 'b, F>\n     where\n-        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg + 'i,\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -667,20 +669,19 @@ mod resolve {\n             var: InferenceVar,\n             kind: TyVariableKind,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Ty> {\n+        ) -> Ty {\n             let var = self.table.var_unification_table.inference_var_root(var);\n             if self.var_stack.contains(&var) {\n                 // recursive type\n                 let default = self.table.fallback_value(var, kind).cast(Interner);\n-                return Ok((self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n+                return (self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n                     .assert_ty_ref(Interner)\n-                    .clone());\n+                    .clone();\n             }\n             let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n-                let result =\n-                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                let result = known_ty.fold_with(self, outer_binder);\n                 self.var_stack.pop();\n                 result.assert_ty_ref(Interner).clone()\n             } else {\n@@ -689,15 +690,15 @@ mod resolve {\n                     .assert_ty_ref(Interner)\n                     .clone()\n             };\n-            Ok(result)\n+            result\n         }\n \n         fn fold_inference_const(\n             &mut self,\n             ty: Ty,\n             var: InferenceVar,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Const> {\n+        ) -> Const {\n             let var = self.table.var_unification_table.inference_var_root(var);\n             let default = ConstData {\n                 ty: ty.clone(),\n@@ -707,35 +708,33 @@ mod resolve {\n             .cast(Interner);\n             if self.var_stack.contains(&var) {\n                 // recursive\n-                return Ok((self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n+                return (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n                     .assert_const_ref(Interner)\n-                    .clone());\n+                    .clone();\n             }\n-            let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n+            if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n-                let result =\n-                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                let result = known_ty.fold_with(self, outer_binder);\n                 self.var_stack.pop();\n                 result.assert_const_ref(Interner).clone()\n             } else {\n                 (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n                     .assert_const_ref(Interner)\n                     .clone()\n-            };\n-            Ok(result)\n+            }\n         }\n \n         fn fold_inference_lifetime(\n             &mut self,\n             _var: InferenceVar,\n             _outer_binder: DebruijnIndex,\n-        ) -> Fallible<Lifetime> {\n+        ) -> Lifetime {\n             // fall back all lifetimes to 'static -- currently we don't deal\n             // with any lifetimes, but we can sometimes get some lifetime\n             // variables through Chalk's unification, and this at least makes\n             // sure we don't leak them outside of inference\n-            Ok(crate::static_lifetime())\n+            crate::static_lifetime()\n         }\n     }\n }"}, {"sha": "c4b700cbce6db78284321f80bd956e9a4e5f5165", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -254,13 +254,13 @@ impl CallableSig {\n }\n \n impl TypeFoldable<Interner> for CallableSig {\n-    fn fold_with<E>(\n+    fn try_fold_with<E>(\n         self,\n-        folder: &mut dyn chalk_ir::fold::TypeFolder<Interner, Error = E>,\n+        folder: &mut dyn chalk_ir::fold::FallibleTypeFolder<Interner, Error = E>,\n         outer_binder: DebruijnIndex,\n     ) -> Result<Self, E> {\n         let vec = self.params_and_return.to_vec();\n-        let folded = vec.fold_with(folder, outer_binder)?;\n+        let folded = vec.try_fold_with(folder, outer_binder)?;\n         Ok(CallableSig { params_and_return: folded.into(), is_varargs: self.is_varargs })\n     }\n }\n@@ -292,16 +292,19 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + TypeFoldable<\n     for_ty: impl FnMut(BoundVar, DebruijnIndex) -> Ty,\n     for_const: impl FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n ) -> T {\n-    use chalk_ir::{fold::TypeFolder, Fallible};\n-    struct FreeVarFolder<F1, F2>(F1, F2);\n+    use chalk_ir::fold::TypeFolder;\n+\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    struct FreeVarFolder<\n+        F1: FnMut(BoundVar, DebruijnIndex) -> Ty,\n+        F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n+    >(F1, F2);\n     impl<\n-            'i,\n-            F1: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i,\n-            F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const + 'i,\n+            F1: FnMut(BoundVar, DebruijnIndex) -> Ty,\n+            F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n         > TypeFolder<Interner> for FreeVarFolder<F1, F2>\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -310,25 +313,20 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + TypeFoldable<\n             Interner\n         }\n \n-        fn fold_free_var_ty(\n-            &mut self,\n-            bound_var: BoundVar,\n-            outer_binder: DebruijnIndex,\n-        ) -> Fallible<Ty> {\n-            Ok(self.0(bound_var, outer_binder))\n+        fn fold_free_var_ty(&mut self, bound_var: BoundVar, outer_binder: DebruijnIndex) -> Ty {\n+            self.0(bound_var, outer_binder)\n         }\n \n         fn fold_free_var_const(\n             &mut self,\n             ty: Ty,\n             bound_var: BoundVar,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Const> {\n-            Ok(self.1(ty, bound_var, outer_binder))\n+        ) -> Const {\n+            self.1(ty, bound_var, outer_binder)\n         }\n     }\n     t.fold_with(&mut FreeVarFolder(for_ty, for_const), DebruijnIndex::INNERMOST)\n-        .expect(\"fold failed unexpectedly\")\n }\n \n pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + TypeFoldable<Interner>>(\n@@ -351,16 +349,13 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n     f: impl FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>,\n     binders: DebruijnIndex,\n ) -> T {\n-    use chalk_ir::{\n-        fold::{TypeFolder, TypeSuperFoldable},\n-        Fallible,\n-    };\n-    struct TyFolder<F>(F);\n-    impl<'i, F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const> + 'i>\n-        TypeFolder<Interner> for TyFolder<F>\n+    use chalk_ir::fold::{TypeFolder, TypeSuperFoldable};\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    struct TyFolder<F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>>(F);\n+    impl<F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>> TypeFolder<Interner>\n+        for TyFolder<F>\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -369,16 +364,16 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n             Interner\n         }\n \n-        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n-            let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n-            Ok(self.0(Either::Left(ty), outer_binder).left().unwrap())\n+        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Ty {\n+            let ty = ty.super_fold_with(self.as_dyn(), outer_binder);\n+            self.0(Either::Left(ty), outer_binder).left().unwrap()\n         }\n \n-        fn fold_const(&mut self, c: Const, outer_binder: DebruijnIndex) -> Fallible<Const> {\n-            Ok(self.0(Either::Right(c), outer_binder).right().unwrap())\n+        fn fold_const(&mut self, c: Const, outer_binder: DebruijnIndex) -> Const {\n+            self.0(Either::Right(c), outer_binder).right().unwrap()\n         }\n     }\n-    t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")\n+    t.fold_with(&mut TyFolder(f), binders)\n }\n \n /// 'Canonicalizes' the `t` by replacing any errors with new variables. Also\n@@ -390,35 +385,34 @@ where\n     T: HasInterner<Interner = Interner>,\n {\n     use chalk_ir::{\n-        fold::{TypeFolder, TypeSuperFoldable},\n+        fold::{FallibleTypeFolder, TypeSuperFoldable},\n         Fallible,\n     };\n     struct ErrorReplacer {\n         vars: usize,\n     }\n-    impl TypeFolder<Interner> for ErrorReplacer {\n+    impl FallibleTypeFolder<Interner> for ErrorReplacer {\n         type Error = NoSolution;\n \n-        fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n+        fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n \n         fn interner(&self) -> Interner {\n             Interner\n         }\n \n-        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n+        fn try_fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n             if let TyKind::Error = ty.kind(Interner) {\n                 let index = self.vars;\n                 self.vars += 1;\n                 Ok(TyKind::BoundVar(BoundVar::new(outer_binder, index)).intern(Interner))\n             } else {\n-                let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n-                Ok(ty)\n+                ty.try_super_fold_with(self.as_dyn(), outer_binder)\n             }\n         }\n \n-        fn fold_inference_ty(\n+        fn try_fold_inference_ty(\n             &mut self,\n             _var: InferenceVar,\n             _kind: TyVariableKind,\n@@ -433,7 +427,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_ty(\n+        fn try_fold_free_var_ty(\n             &mut self,\n             _bound_var: BoundVar,\n             _outer_binder: DebruijnIndex,\n@@ -447,7 +441,7 @@ where\n             }\n         }\n \n-        fn fold_inference_const(\n+        fn try_fold_inference_const(\n             &mut self,\n             ty: Ty,\n             _var: InferenceVar,\n@@ -460,7 +454,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_const(\n+        fn try_fold_free_var_const(\n             &mut self,\n             ty: Ty,\n             _bound_var: BoundVar,\n@@ -473,7 +467,7 @@ where\n             }\n         }\n \n-        fn fold_inference_lifetime(\n+        fn try_fold_inference_lifetime(\n             &mut self,\n             _var: InferenceVar,\n             _outer_binder: DebruijnIndex,\n@@ -485,7 +479,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_lifetime(\n+        fn try_fold_free_var_lifetime(\n             &mut self,\n             _bound_var: BoundVar,\n             _outer_binder: DebruijnIndex,\n@@ -498,7 +492,7 @@ where\n         }\n     }\n     let mut error_replacer = ErrorReplacer { vars: 0 };\n-    let value = match t.clone().fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n+    let value = match t.clone().try_fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n         Ok(t) => t,\n         Err(_) => panic!(\"Encountered unbound or inference vars in {:?}\", t),\n     };"}, {"sha": "c425f35acfe7e188612bbd3827104793987eca5c", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4876693708975a9ae3076512a4f76238907fd15b/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=4876693708975a9ae3076512a4f76238907fd15b", "patch": "@@ -13,8 +13,8 @@ use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n-    Guidance, InEnvironment, Interner, ProjectionTy, Solution, TraitRefExt, Ty, TyKind,\n-    WhereClause,\n+    Guidance, InEnvironment, Interner, ProjectionTy, ProjectionTyExt, Solution, TraitRefExt, Ty,\n+    TyKind, WhereClause,\n };\n \n /// This controls how much 'time' we give the Chalk solver before giving up.\n@@ -95,7 +95,7 @@ pub(crate) fn trait_solve_query(\n         ..\n     }))) = &goal.value.goal.data(Interner)\n     {\n-        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(Interner).kind(Interner) {\n+        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(db).kind(Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}]}