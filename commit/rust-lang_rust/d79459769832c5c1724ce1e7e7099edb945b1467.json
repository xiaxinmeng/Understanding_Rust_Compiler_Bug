{"sha": "d79459769832c5c1724ce1e7e7099edb945b1467", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3OTQ1OTc2OTgzMmM1YzE3MjRjZTFlN2U3MDk5ZWRiOTQ1YjE0Njc=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-11-01T20:06:50Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-11-01T20:09:02Z"}, "message": "Remove checks for LLVM < 4.0\n\nWhile we still have to support LLVM 4.0 for Emscripten, we can\ndrop checks for LLVM >= 4.0 and < 4.0.", "tree": {"sha": "29284ef386e33ccb2c0339a32ee94bd985a3667a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29284ef386e33ccb2c0339a32ee94bd985a3667a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d79459769832c5c1724ce1e7e7099edb945b1467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d79459769832c5c1724ce1e7e7099edb945b1467", "html_url": "https://github.com/rust-lang/rust/commit/d79459769832c5c1724ce1e7e7099edb945b1467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d79459769832c5c1724ce1e7e7099edb945b1467/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e9a6e41cd9b1fb687e296b5a6d4c6ad399f862", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e9a6e41cd9b1fb687e296b5a6d4c6ad399f862", "html_url": "https://github.com/rust-lang/rust/commit/f6e9a6e41cd9b1fb687e296b5a6d4c6ad399f862"}], "stats": {"total": 221, "additions": 6, "deletions": 215}, "files": [{"sha": "dabfa4c540b19589f5c4bfc5aef25b2e34182cf6", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -10,7 +10,7 @@\n \n use attributes;\n use back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n-use back::lto::{self, ModuleBuffer, ThinBuffer, SerializedModule};\n+use back::lto::{self, ThinBuffer, SerializedModule};\n use back::link::{self, get_linker, remove};\n use back::command::Command;\n use back::linker::LinkerInfo;\n@@ -564,8 +564,8 @@ unsafe fn optimize(cgcx: &CodegenContext,\n             // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n             // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n             // we'll get errors in LLVM.\n-            let using_thin_buffers = llvm::LLVMRustThinLTOAvailable() && (config.emit_bc\n-                || config.obj_is_bitcode || config.emit_bc_compressed || config.embed_bitcode);\n+            let using_thin_buffers = config.emit_bc || config.obj_is_bitcode\n+                || config.emit_bc_compressed || config.embed_bitcode;\n             let mut have_name_anon_globals_pass = false;\n             if !config.no_prepopulate_passes {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n@@ -729,15 +729,8 @@ unsafe fn codegen(cgcx: &CodegenContext,\n \n \n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-            let thin;\n-            let old;\n-            let data = if llvm::LLVMRustThinLTOAvailable() {\n-                thin = ThinBuffer::new(llmod);\n-                thin.data()\n-            } else {\n-                old = ModuleBuffer::new(llmod);\n-                old.data()\n-            };\n+            let thin = ThinBuffer::new(llmod);\n+            let data = thin.data();\n             timeline.record(\"make-bc\");\n \n             if write_bc {\n@@ -1385,12 +1378,8 @@ fn execute_optimize_work_item(cgcx: &CodegenContext,\n         // builds we don't actually want to LTO the allocator modules if\n         // it shows up. This is due to various linker shenanigans that\n         // we'll encounter later.\n-        //\n-        // Additionally here's where we also factor in the current LLVM\n-        // version. If it doesn't support ThinLTO we skip this.\n         Lto::ThinLocal => {\n-            module.kind != ModuleKind::Allocator &&\n-                unsafe { llvm::LLVMRustThinLTOAvailable() }\n+            module.kind != ModuleKind::Allocator\n         }\n     };\n "}, {"sha": "ecdff946bf3857fc4568e6accf6d1d5ac0c9a8ab", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -738,19 +738,6 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     check_for_rustc_errors_attr(tcx);\n \n-    if let Some(true) = tcx.sess.opts.debugging_opts.thinlto {\n-        if unsafe { !llvm::LLVMRustThinLTOAvailable() } {\n-            tcx.sess.fatal(\"this compiler's LLVM does not support ThinLTO\");\n-        }\n-    }\n-\n-    if (tcx.sess.opts.debugging_opts.pgo_gen.is_some() ||\n-        !tcx.sess.opts.debugging_opts.pgo_use.is_empty()) &&\n-        unsafe { !llvm::LLVMRustPGOAvailable() }\n-    {\n-        tcx.sess.fatal(\"this compiler's LLVM does not support PGO\");\n-    }\n-\n     let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n \n     // Codegen the metadata."}, {"sha": "12d4670e4be4bed52973273fdaf37e5b3bb2b598", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -1626,8 +1626,6 @@ extern \"C\" {\n     pub fn LLVMRustModuleBufferFree(p: &'static mut ModuleBuffer);\n     pub fn LLVMRustModuleCost(M: &Module) -> u64;\n \n-    pub fn LLVMRustThinLTOAvailable() -> bool;\n-    pub fn LLVMRustPGOAvailable() -> bool;\n     pub fn LLVMRustThinLTOBufferCreate(M: &Module) -> &'static mut ThinLTOBuffer;\n     pub fn LLVMRustThinLTOBufferFree(M: &'static mut ThinLTOBuffer);\n     pub fn LLVMRustThinLTOBufferPtr(M: &ThinLTOBuffer) -> *const c_char;"}, {"sha": "390450a520526cfd25b2a76ea5739139f502bbf1", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -145,7 +145,6 @@ extern \"C\" void LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef RAI) {\n \n extern \"C\" const char *\n LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef Child, size_t *Size) {\n-#if LLVM_VERSION_GE(4, 0)\n   Expected<StringRef> NameOrErr = Child->getName();\n   if (!NameOrErr) {\n     // rustc_codegen_llvm currently doesn't use this error string, but it might be\n@@ -154,11 +153,6 @@ LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef Child, size_t *Size) {\n     LLVMRustSetLastError(toString(NameOrErr.takeError()).c_str());\n     return nullptr;\n   }\n-#else\n-  ErrorOr<StringRef> NameOrErr = Child->getName();\n-  if (NameOrErr.getError())\n-    return nullptr;\n-#endif\n   StringRef Name = NameOrErr.get();\n   *Size = Name.size();\n   return Name.data();\n@@ -167,19 +161,11 @@ LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef Child, size_t *Size) {\n extern \"C\" const char *LLVMRustArchiveChildData(LLVMRustArchiveChildRef Child,\n                                                 size_t *Size) {\n   StringRef Buf;\n-#if LLVM_VERSION_GE(4, 0)\n   Expected<StringRef> BufOrErr = Child->getBuffer();\n   if (!BufOrErr) {\n     LLVMRustSetLastError(toString(BufOrErr.takeError()).c_str());\n     return nullptr;\n   }\n-#else\n-  ErrorOr<StringRef> BufOrErr = Child->getBuffer();\n-  if (BufOrErr.getError()) {\n-    LLVMRustSetLastError(BufOrErr.getError().message().c_str());\n-    return nullptr;\n-  }\n-#endif\n   Buf = BufOrErr.get();\n   *Size = Buf.size();\n   return Buf.data();"}, {"sha": "59f0b23361e540313f9ef491d79d72cd9e0222e7", "filename": "src/rustllvm/Linker.cpp", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FLinker.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FLinker.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FLinker.cpp?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -42,7 +42,6 @@ LLVMRustLinkerAdd(RustLinker *L, char *BC, size_t Len) {\n   std::unique_ptr<MemoryBuffer> Buf =\n       MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n \n-#if LLVM_VERSION_GE(4, 0)\n   Expected<std::unique_ptr<Module>> SrcOrError =\n       llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), L->Ctx);\n   if (!SrcOrError) {\n@@ -51,20 +50,8 @@ LLVMRustLinkerAdd(RustLinker *L, char *BC, size_t Len) {\n   }\n \n   auto Src = std::move(*SrcOrError);\n-#else\n-  ErrorOr<std::unique_ptr<Module>> Src =\n-      llvm::getLazyBitcodeModule(std::move(Buf), L->Ctx);\n-  if (!Src) {\n-    LLVMRustSetLastError(Src.getError().message().c_str());\n-    return false;\n-  }\n-#endif\n \n-#if LLVM_VERSION_GE(4, 0)\n   if (L->L.linkInModule(std::move(Src))) {\n-#else\n-  if (L->L.linkInModule(std::move(Src.get()))) {\n-#endif\n     LLVMRustSetLastError(\"\");\n     return false;\n   }"}, {"sha": "200175da1bf2a57d7387db7a79e0866a667eb5b2", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -32,22 +32,16 @@\n #include \"llvm/Target/TargetSubtargetInfo.h\"\n #endif\n \n-#if LLVM_VERSION_GE(4, 0)\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n #include \"llvm/Transforms/IPO/FunctionImport.h\"\n #include \"llvm/Transforms/Utils/FunctionImportUtils.h\"\n #include \"llvm/LTO/LTO.h\"\n #if LLVM_VERSION_LE(4, 0)\n #include \"llvm/Object/ModuleSummaryIndexObjectFile.h\"\n #endif\n-#endif\n \n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n-#if LLVM_VERSION_GE(4, 0)\n-#define PGO_AVAILABLE\n-#endif\n-\n using namespace llvm;\n using namespace llvm::legacy;\n \n@@ -121,12 +115,8 @@ bool LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n   LLVMPassManagerBuilderRef PMBR,\n   LLVMPassManagerRef PMR\n ) {\n-#if LLVM_VERSION_GE(4, 0)\n   unwrap(PMBR)->populateThinLTOPassManager(*unwrap(PMR));\n   return true;\n-#else\n-  return false;\n-#endif\n }\n \n #ifdef LLVM_COMPONENT_X86\n@@ -288,17 +278,12 @@ static Optional<Reloc::Model> fromRust(LLVMRustRelocMode RustReloc) {\n     return Reloc::PIC_;\n   case LLVMRustRelocMode::DynamicNoPic:\n     return Reloc::DynamicNoPIC;\n-#if LLVM_VERSION_GE(4, 0)\n   case LLVMRustRelocMode::ROPI:\n     return Reloc::ROPI;\n   case LLVMRustRelocMode::RWPI:\n     return Reloc::RWPI;\n   case LLVMRustRelocMode::ROPIRWPI:\n     return Reloc::ROPI_RWPI;\n-#else\n-  default:\n-    break;\n-#endif\n   }\n   report_fatal_error(\"Bad RelocModel.\");\n }\n@@ -450,11 +435,8 @@ extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n   unwrap(PMBR)->SLPVectorize = SLPVectorize;\n   unwrap(PMBR)->OptLevel = fromRust(OptLevel);\n   unwrap(PMBR)->LoopVectorize = LoopVectorize;\n-#if LLVM_VERSION_GE(4, 0)\n   unwrap(PMBR)->PrepareForThinLTO = PrepareForThinLTO;\n-#endif\n \n-#ifdef PGO_AVAILABLE\n   if (PGOGenPath) {\n     assert(!PGOUsePath);\n     unwrap(PMBR)->EnablePGOInstrGen = true;\n@@ -464,9 +446,6 @@ extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n     assert(!PGOGenPath);\n     unwrap(PMBR)->PGOInstrUse = PGOUsePath;\n   }\n-#else\n-  assert(!PGOGenPath && !PGOUsePath && \"Should've caught earlier\");\n-#endif\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n@@ -716,7 +695,6 @@ extern \"C\" void LLVMRustPrintPasses() {\n   LLVMInitializePasses();\n   struct MyListener : PassRegistrationListener {\n     void passEnumerate(const PassInfo *Info) {\n-#if LLVM_VERSION_GE(4, 0)\n       StringRef PassArg = Info->getPassArgument();\n       StringRef PassName = Info->getPassName();\n       if (!PassArg.empty()) {\n@@ -726,11 +704,6 @@ extern \"C\" void LLVMRustPrintPasses() {\n         printf(\"%15.*s - %.*s\\n\", (int)PassArg.size(), PassArg.data(),\n                (int)PassName.size(), PassName.data());\n       }\n-#else\n-      if (Info->getPassArgument() && *Info->getPassArgument()) {\n-        printf(\"%15s - %s\\n\", Info->getPassArgument(), Info->getPassName());\n-      }\n-#endif\n     }\n   } Listener;\n \n@@ -740,11 +713,7 @@ extern \"C\" void LLVMRustPrintPasses() {\n \n extern \"C\" void LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMBR,\n                                             bool AddLifetimes) {\n-#if LLVM_VERSION_GE(4, 0)\n   unwrap(PMBR)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n-#else\n-  unwrap(PMBR)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n-#endif\n }\n \n extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,\n@@ -795,26 +764,6 @@ extern \"C\" void LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n   unwrap(M)->setPIELevel(PIELevel::Level::Large);\n }\n \n-extern \"C\" bool\n-LLVMRustThinLTOAvailable() {\n-#if LLVM_VERSION_GE(4, 0)\n-  return true;\n-#else\n-  return false;\n-#endif\n-}\n-\n-extern \"C\" bool\n-LLVMRustPGOAvailable() {\n-#ifdef PGO_AVAILABLE\n-  return true;\n-#else\n-  return false;\n-#endif\n-}\n-\n-#if LLVM_VERSION_GE(4, 0)\n-\n // Here you'll find an implementation of ThinLTO as used by the Rust compiler\n // right now. This ThinLTO support is only enabled on \"recent ish\" versions of\n // LLVM, and otherwise it's just blanket rejected from other compilers.\n@@ -1276,94 +1225,3 @@ LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n   MD->clearOperands();\n   MD->addOperand(Unit);\n }\n-\n-#else\n-\n-struct LLVMRustThinLTOData {\n-};\n-\n-struct LLVMRustThinLTOModule {\n-};\n-\n-extern \"C\" LLVMRustThinLTOData*\n-LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n-                          int num_modules,\n-                          const char **preserved_symbols,\n-                          int num_symbols) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" bool\n-LLVMRustPrepareThinLTORename(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" bool\n-LLVMRustPrepareThinLTOResolveWeak(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" bool\n-LLVMRustPrepareThinLTOInternalize(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" bool\n-LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" LLVMRustThinLTOModuleImports\n-LLVMRustGetLLVMRustThinLTOModuleImports(const LLVMRustThinLTOData *Data) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" void\n-LLVMRustFreeThinLTOData(LLVMRustThinLTOData *Data) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-struct LLVMRustThinLTOBuffer {\n-};\n-\n-extern \"C\" LLVMRustThinLTOBuffer*\n-LLVMRustThinLTOBufferCreate(LLVMModuleRef M) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" void\n-LLVMRustThinLTOBufferFree(LLVMRustThinLTOBuffer *Buffer) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" const void*\n-LLVMRustThinLTOBufferPtr(const LLVMRustThinLTOBuffer *Buffer) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" size_t\n-LLVMRustThinLTOBufferLen(const LLVMRustThinLTOBuffer *Buffer) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" LLVMModuleRef\n-LLVMRustParseBitcodeForThinLTO(LLVMContextRef Context,\n-                               const char *data,\n-                               size_t len,\n-                               const char *identifier) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" void\n-LLVMRustThinLTOGetDICompileUnit(LLVMModuleRef Mod,\n-                                DICompileUnit **A,\n-                                DICompileUnit **B) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-extern \"C\" void\n-LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n-#endif // LLVM_VERSION_GE(4, 0)"}, {"sha": "3dbde46f762411598632ce24b23b7df7c877d0dc", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -907,10 +907,8 @@ LLVMRustDIBuilderCreateNameSpace(LLVMRustDIBuilderRef Builder,\n       ,\n       unwrapDI<DIFile>(File), LineNo\n #endif\n-#if LLVM_VERSION_GE(4, 0)\n       ,\n       false // ExportSymbols (only relevant for C++ anonymous namespaces)\n-#endif\n       ));\n }\n \n@@ -1547,14 +1545,6 @@ LLVMRustBuildVectorReduceFMax(LLVMBuilderRef, LLVMValueRef, bool) {\n }\n #endif\n \n-#if LLVM_VERSION_LT(4, 0)\n-extern \"C\" LLVMValueRef\n-LLVMBuildExactUDiv(LLVMBuilderRef B, LLVMValueRef LHS,\n-                   LLVMValueRef RHS, const char *Name) {\n-  return wrap(unwrap(B)->CreateExactUDiv(unwrap(LHS), unwrap(RHS), Name));\n-}\n-#endif\n-\n #if LLVM_VERSION_GE(6, 0)\n extern \"C\" LLVMValueRef\n LLVMRustBuildMinNum(LLVMBuilderRef B, LLVMValueRef LHS, LLVMValueRef RHS) {"}, {"sha": "2fd72fa749a840390fd811503f20ed2cc221e9aa", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/d79459769832c5c1724ce1e7e7099edb945b1467/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=d79459769832c5c1724ce1e7e7099edb945b1467", "patch": "@@ -57,12 +57,8 @@\n \n #include \"llvm/IR/LegacyPassManager.h\"\n \n-#if LLVM_VERSION_GE(4, 0)\n #include \"llvm/Bitcode/BitcodeReader.h\"\n #include \"llvm/Bitcode/BitcodeWriter.h\"\n-#else\n-#include \"llvm/Bitcode/ReaderWriter.h\"\n-#endif\n \n #include \"llvm/IR/DIBuilder.h\"\n #include \"llvm/IR/DebugInfo.h\""}]}