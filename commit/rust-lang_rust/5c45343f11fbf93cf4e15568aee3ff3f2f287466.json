{"sha": "5c45343f11fbf93cf4e15568aee3ff3f2f287466", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNDUzNDNmMTFmYmY5M2NmNGUxNTU2OGFlZTNmZjNmMmYyODc0NjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-08T13:02:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-08T13:02:49Z"}, "message": "Auto merge of #61625 - RalfJung:eval-interp, r=oli-obk\n\nRename remaining \"Eval\" to \"Interp\"\n\nRenaming done by sed.\n\nr? @oli-obk\n\nFixes https://github.com/rust-lang/rust/issues/54395.", "tree": {"sha": "7ce17cd37d3255ae7e3f0cec57194172069e8d65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ce17cd37d3255ae7e3f0cec57194172069e8d65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c45343f11fbf93cf4e15568aee3ff3f2f287466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c45343f11fbf93cf4e15568aee3ff3f2f287466", "html_url": "https://github.com/rust-lang/rust/commit/5c45343f11fbf93cf4e15568aee3ff3f2f287466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c45343f11fbf93cf4e15568aee3ff3f2f287466/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb7cca33f861b47738d232a91e3655f1f9b1a421", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7cca33f861b47738d232a91e3655f1f9b1a421", "html_url": "https://github.com/rust-lang/rust/commit/fb7cca33f861b47738d232a91e3655f1f9b1a421"}, {"sha": "b86c050f64b871348bdd09ee097c7b03f8538b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86c050f64b871348bdd09ee097c7b03f8538b03", "html_url": "https://github.com/rust-lang/rust/commit/b86c050f64b871348bdd09ee097c7b03f8538b03"}], "stats": {"total": 545, "additions": 274, "deletions": 271}, "files": [{"sha": "d7caf950dcebde2e9ee0fcc9063ae5ec2ef31e86", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -1,7 +1,7 @@\n //! The virtual memory representation of the MIR interpreter.\n \n use super::{\n-    Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n+    Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n use crate::ty::layout::{Size, Align};\n@@ -82,7 +82,7 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n         _alloc: &Allocation<Tag, Self>,\n         _ptr: Pointer<Tag>,\n         _size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n@@ -92,7 +92,7 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n         _alloc: &mut Allocation<Tag, Self>,\n         _ptr: Pointer<Tag>,\n         _size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n@@ -103,7 +103,7 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n         _alloc: &mut Allocation<Tag, Self>,\n         _ptr: Pointer<Tag>,\n         _size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n }\n@@ -156,7 +156,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         &self,\n         ptr: Pointer<Tag>,\n         msg: CheckInAllocMsg,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let allocation_size = self.bytes.len() as u64;\n         ptr.check_in_alloc(Size::from_bytes(allocation_size), msg)\n     }\n@@ -169,7 +169,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n         msg: CheckInAllocMsg,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_bounds_ptr(ptr.offset(size, cx)?, msg)\n     }\n@@ -191,7 +191,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n         check_defined_and_ptr: bool,\n         msg: CheckInAllocMsg,\n-    ) -> EvalResult<'tcx, &[u8]>\n+    ) -> InterpResult<'tcx, &[u8]>\n     {\n         self.check_bounds(cx, ptr, size, msg)?;\n \n@@ -217,7 +217,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[u8]>\n+    ) -> InterpResult<'tcx, &[u8]>\n     {\n         self.get_bytes_internal(cx, ptr, size, true, CheckInAllocMsg::MemoryAccessTest)\n     }\n@@ -230,7 +230,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[u8]>\n+    ) -> InterpResult<'tcx, &[u8]>\n     {\n         self.get_bytes_internal(cx, ptr, size, false, CheckInAllocMsg::MemoryAccessTest)\n     }\n@@ -242,7 +242,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &mut [u8]>\n+    ) -> InterpResult<'tcx, &mut [u8]>\n     {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_bounds(cx, ptr, size, CheckInAllocMsg::MemoryAccessTest)?;\n@@ -267,7 +267,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-    ) -> EvalResult<'tcx, &[u8]>\n+    ) -> InterpResult<'tcx, &[u8]>\n     {\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -292,7 +292,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n         allow_ptr_and_undef: bool,\n-    ) -> EvalResult<'tcx>\n+    ) -> InterpResult<'tcx>\n     {\n         // Check bounds and relocations on the edges\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n@@ -312,7 +312,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         src: &[u8],\n-    ) -> EvalResult<'tcx>\n+    ) -> InterpResult<'tcx>\n     {\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n         bytes.clone_from_slice(src);\n@@ -326,7 +326,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         val: u8,\n         count: Size\n-    ) -> EvalResult<'tcx>\n+    ) -> InterpResult<'tcx>\n     {\n         let bytes = self.get_bytes_mut(cx, ptr, count)?;\n         for b in bytes {\n@@ -348,7 +348,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n+    ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>>\n     {\n         // get_bytes_unchecked tests relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n@@ -383,7 +383,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n+    ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>>\n     {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n@@ -402,7 +402,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>,\n         type_size: Size,\n-    ) -> EvalResult<'tcx>\n+    ) -> InterpResult<'tcx>\n     {\n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n@@ -438,7 +438,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>\n-    ) -> EvalResult<'tcx>\n+    ) -> InterpResult<'tcx>\n     {\n         let ptr_size = cx.data_layout().pointer_size;\n         self.write_scalar(cx, ptr.into(), val, ptr_size)\n@@ -468,7 +468,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if self.relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n@@ -487,7 +487,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n@@ -525,7 +525,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         self.check_relocations(cx, ptr, Size::ZERO)?;\n         self.check_relocations(cx, ptr.offset(size, cx)?, Size::ZERO)?;\n         Ok(())\n@@ -538,7 +538,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n     #[inline]\n-    fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n@@ -550,7 +550,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n         new_state: bool,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if size.bytes() == 0 {\n             return Ok(());\n         }"}, {"sha": "a9a34f78f54d78c06ee58bdd1b41fadee70253b7", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -185,12 +185,12 @@ pub fn struct_error<'a, 'gcx, 'tcx>(\n /// a `InterpError`. In `librustc_mir::interpret`, we have the `err!`\n /// macro for this\n #[derive(Debug, Clone)]\n-pub struct EvalError<'tcx> {\n+pub struct InterpErrorInfo<'tcx> {\n     pub kind: InterpError<'tcx, u64>,\n     backtrace: Option<Box<Backtrace>>,\n }\n \n-impl<'tcx> EvalError<'tcx> {\n+impl<'tcx> InterpErrorInfo<'tcx> {\n     pub fn print_backtrace(&mut self) {\n         if let Some(ref mut backtrace) = self.backtrace {\n             print_backtrace(&mut *backtrace);\n@@ -203,7 +203,7 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n-impl<'tcx> From<InterpError<'tcx, u64>> for EvalError<'tcx> {\n+impl<'tcx> From<InterpError<'tcx, u64>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx, u64>) -> Self {\n         let backtrace = match env::var(\"RUST_CTFE_BACKTRACE\") {\n             // Matching `RUST_BACKTRACE` -- we treat \"0\" the same as \"not present\".\n@@ -220,7 +220,7 @@ impl<'tcx> From<InterpError<'tcx, u64>> for EvalError<'tcx> {\n             },\n             _ => None,\n         };\n-        EvalError {\n+        InterpErrorInfo {\n             kind,\n             backtrace,\n         }\n@@ -320,7 +320,7 @@ pub enum InterpError<'tcx, O> {\n     InfiniteLoop,\n }\n \n-pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n+pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n \n impl<'tcx, O> InterpError<'tcx, O> {\n     pub fn description(&self) -> &str {\n@@ -456,7 +456,7 @@ impl<'tcx, O> InterpError<'tcx, O> {\n     }\n }\n \n-impl<'tcx> fmt::Display for EvalError<'tcx> {\n+impl<'tcx> fmt::Display for InterpErrorInfo<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.kind)\n     }"}, {"sha": "15b09f65c74c9b6ddb2175f140ce3b27599e45f7", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -11,7 +11,7 @@ mod allocation;\n mod pointer;\n \n pub use self::error::{\n-    EvalError, EvalResult, InterpError, AssertMessage, ConstEvalErr, struct_error,\n+    InterpErrorInfo, InterpResult, InterpError, AssertMessage, ConstEvalErr, struct_error,\n     FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n };\n "}, {"sha": "a6c47ff5ca0f77128b14f87c7cf2c2125c7b3c49", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -5,7 +5,7 @@ use crate::ty::layout::{self, HasDataLayout, Size};\n use rustc_macros::HashStable;\n \n use super::{\n-    AllocId, EvalResult, CheckInAllocMsg\n+    AllocId, InterpResult, CheckInAllocMsg\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -52,13 +52,13 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     }\n \n     #[inline]\n-    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n         if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     #[inline]\n-    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n         if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n@@ -125,7 +125,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n     }\n \n     #[inline]\n-    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n         Ok(Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n@@ -145,7 +145,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n     }\n \n     #[inline]\n-    pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n         Ok(Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n@@ -174,7 +174,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n         self,\n         allocation_size: Size,\n         msg: CheckInAllocMsg,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> InterpResult<'tcx, ()> {\n         if self.offset > allocation_size {\n             err!(PointerOutOfBounds {\n                 ptr: self.erase_tag(),"}, {"sha": "454a4e2111a9cfb8d5ca41ef77e3c927cdaba551", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -5,7 +5,7 @@ use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n \n-use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n+use super::{InterpResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n /// Represents the result of a raw const operation, pre-validation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n@@ -176,7 +176,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Raw { data, size } => {\n@@ -206,7 +206,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Raw { data, size } => {\n@@ -322,7 +322,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n+    pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         match self {\n             Scalar::Raw { data, size } => {\n                 assert_eq!(target_size.bytes(), size as u64);\n@@ -335,7 +335,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n+    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n             Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n             Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n@@ -359,80 +359,80 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n-    pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n+    pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         match self {\n             Scalar::Raw { data: 0, size: 1 } => Ok(false),\n             Scalar::Raw { data: 1, size: 1 } => Ok(true),\n             _ => err!(InvalidBool),\n         }\n     }\n \n-    pub fn to_char(self) -> EvalResult<'tcx, char> {\n+    pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n             None => err!(InvalidChar(val as u128)),\n         }\n     }\n \n-    pub fn to_u8(self) -> EvalResult<'static, u8> {\n+    pub fn to_u8(self) -> InterpResult<'static, u8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n         Ok(b as u8)\n     }\n \n-    pub fn to_u32(self) -> EvalResult<'static, u32> {\n+    pub fn to_u32(self) -> InterpResult<'static, u32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n         Ok(b as u32)\n     }\n \n-    pub fn to_u64(self) -> EvalResult<'static, u64> {\n+    pub fn to_u64(self) -> InterpResult<'static, u64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n         Ok(b as u64)\n     }\n \n-    pub fn to_usize(self, cx: &impl HasDataLayout) -> EvalResult<'static, u64> {\n+    pub fn to_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         Ok(b as u64)\n     }\n \n-    pub fn to_i8(self) -> EvalResult<'static, i8> {\n+    pub fn to_i8(self) -> InterpResult<'static, i8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n         Ok(b as i8)\n     }\n \n-    pub fn to_i32(self) -> EvalResult<'static, i32> {\n+    pub fn to_i32(self) -> InterpResult<'static, i32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n         Ok(b as i32)\n     }\n \n-    pub fn to_i64(self) -> EvalResult<'static, i64> {\n+    pub fn to_i64(self) -> InterpResult<'static, i64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n         Ok(b as i64)\n     }\n \n-    pub fn to_isize(self, cx: &impl HasDataLayout) -> EvalResult<'static, i64> {\n+    pub fn to_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n         let sz = cx.data_layout().pointer_size;\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n         Ok(b as i64)\n     }\n \n     #[inline]\n-    pub fn to_f32(self) -> EvalResult<'static, f32> {\n+    pub fn to_f32(self) -> InterpResult<'static, f32> {\n         Ok(f32::from_bits(self.to_u32()?))\n     }\n \n     #[inline]\n-    pub fn to_f64(self) -> EvalResult<'static, f64> {\n+    pub fn to_f64(self) -> InterpResult<'static, f64> {\n         Ok(f64::from_bits(self.to_u64()?))\n     }\n }\n@@ -489,80 +489,80 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n \n     #[inline]\n-    pub fn not_undef(self) -> EvalResult<'static, Scalar<Tag>> {\n+    pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUndef::Undef => err!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n+    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         self.not_undef()?.to_ptr()\n     }\n \n     #[inline(always)]\n-    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n+    pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         self.not_undef()?.to_bits(target_size)\n     }\n \n     #[inline(always)]\n-    pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n+    pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         self.not_undef()?.to_bool()\n     }\n \n     #[inline(always)]\n-    pub fn to_char(self) -> EvalResult<'tcx, char> {\n+    pub fn to_char(self) -> InterpResult<'tcx, char> {\n         self.not_undef()?.to_char()\n     }\n \n     #[inline(always)]\n-    pub fn to_f32(self) -> EvalResult<'tcx, f32> {\n+    pub fn to_f32(self) -> InterpResult<'tcx, f32> {\n         self.not_undef()?.to_f32()\n     }\n \n     #[inline(always)]\n-    pub fn to_f64(self) -> EvalResult<'tcx, f64> {\n+    pub fn to_f64(self) -> InterpResult<'tcx, f64> {\n         self.not_undef()?.to_f64()\n     }\n \n     #[inline(always)]\n-    pub fn to_u8(self) -> EvalResult<'tcx, u8> {\n+    pub fn to_u8(self) -> InterpResult<'tcx, u8> {\n         self.not_undef()?.to_u8()\n     }\n \n     #[inline(always)]\n-    pub fn to_u32(self) -> EvalResult<'tcx, u32> {\n+    pub fn to_u32(self) -> InterpResult<'tcx, u32> {\n         self.not_undef()?.to_u32()\n     }\n \n     #[inline(always)]\n-    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n+    pub fn to_u64(self) -> InterpResult<'tcx, u64> {\n         self.not_undef()?.to_u64()\n     }\n \n     #[inline(always)]\n-    pub fn to_usize(self, cx: &impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+    pub fn to_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         self.not_undef()?.to_usize(cx)\n     }\n \n     #[inline(always)]\n-    pub fn to_i8(self) -> EvalResult<'tcx, i8> {\n+    pub fn to_i8(self) -> InterpResult<'tcx, i8> {\n         self.not_undef()?.to_i8()\n     }\n \n     #[inline(always)]\n-    pub fn to_i32(self) -> EvalResult<'tcx, i32> {\n+    pub fn to_i32(self) -> InterpResult<'tcx, i32> {\n         self.not_undef()?.to_i32()\n     }\n \n     #[inline(always)]\n-    pub fn to_i64(self) -> EvalResult<'tcx, i64> {\n+    pub fn to_i64(self) -> InterpResult<'tcx, i64> {\n         self.not_undef()?.to_i64()\n     }\n \n     #[inline(always)]\n-    pub fn to_isize(self, cx: &impl HasDataLayout) -> EvalResult<'tcx, i64> {\n+    pub fn to_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n         self.not_undef()?.to_isize(cx)\n     }\n }"}, {"sha": "bb48f25a2c404cb2642c76ec51237f25e4ce4466", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -24,7 +24,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n-    EvalResult, EvalError, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n+    InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n };\n@@ -57,7 +57,7 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = mk_eval_cx(tcx, span, param_env);\n     eval_body_using_ecx(&mut ecx, cid, mir, param_env)\n@@ -141,7 +141,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n@@ -176,8 +176,8 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     Ok(ret)\n }\n \n-impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n-    fn into(self) -> EvalError<'tcx> {\n+impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n+    fn into(self) -> InterpErrorInfo<'tcx> {\n         InterpError::MachineError(self.to_string()).into()\n     }\n }\n@@ -333,7 +333,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         // Only check non-glue functions\n         if let ty::InstanceDef::Item(def_id) = instance.def {\n@@ -372,7 +372,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if ecx.emulate_intrinsic(instance, args, dest)? {\n             return Ok(());\n         }\n@@ -388,7 +388,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar, bool)> {\n         Err(\n             ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n         )\n@@ -397,7 +397,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn find_foreign_static(\n         _def_id: DefId,\n         _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n \n@@ -423,13 +423,13 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn box_alloc(\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n \n-    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n+    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         {\n             let steps = &mut ecx.machine.steps_since_detector_enabled;\n \n@@ -456,7 +456,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     #[inline(always)]\n     fn stack_push(\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n@@ -465,7 +465,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn stack_pop(\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _extra: (),\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n }\n@@ -511,7 +511,7 @@ pub fn const_variant_index<'a, 'tcx>(\n \n pub fn error_to_const_error<'a, 'mir, 'tcx>(\n     ecx: &InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n-    mut error: EvalError<'tcx>\n+    mut error: InterpErrorInfo<'tcx>\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace(None);"}, {"sha": "5bc8b931ae86764e605704403a343ffef8560e81", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -6,7 +6,7 @@ use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n-    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError,\n+    Scalar, InterpResult, Pointer, PointerArithmetic, InterpError,\n };\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n@@ -28,7 +28,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         src: OpTy<'tcx, M::PointerTag>,\n         kind: CastKind,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         use rustc::mir::CastKind::*;\n         match kind {\n             Pointer(PointerCast::Unsize) => {\n@@ -80,7 +80,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                         if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n                             bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n-                        let instance: EvalResult<'tcx, _> = ty::Instance::resolve(\n+                        let instance: InterpResult<'tcx, _> = ty::Instance::resolve(\n                             *self.tcx,\n                             self.param_env,\n                             def_id,\n@@ -131,7 +131,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         val: Scalar<M::PointerTag>,\n         src_layout: TyLayout<'tcx>,\n         dest_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n@@ -151,7 +151,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         v: u128,\n         src_layout: TyLayout<'tcx>,\n         dest_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         let signed = src_layout.abi.is_signed();\n         let v = if signed {\n             self.sign_extend(v, src_layout)\n@@ -199,7 +199,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         bits: u128,\n         fty: FloatTy,\n         dest_ty: Ty<'tcx>\n-    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n         use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n@@ -247,7 +247,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         ptr: Pointer<M::PointerTag>,\n         ty: Ty<'tcx>\n-    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc,\n@@ -267,7 +267,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         // The pointee types\n         sty: Ty<'tcx>,\n         dty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n         let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n \n@@ -305,7 +305,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"Unsizing {:?} into {:?}\", src, dest);\n         match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, d, _)) |"}, {"sha": "366d31849c2743ebbed2ae4600e336fa57f1e9f0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -16,7 +16,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n     ErrorHandled,\n     GlobalId, Scalar, Pointer, FrameInfo, AllocId,\n-    EvalResult, InterpError,\n+    InterpResult, InterpError,\n     truncate, sign_extend,\n };\n use rustc_data_structures::fx::FxHashMap;\n@@ -135,7 +135,7 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n }\n \n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n-    pub fn access(&self) -> EvalResult<'tcx, Operand<Tag>> {\n+    pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n             LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Uninitialized =>\n@@ -148,7 +148,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     /// to do so; otherwise return the `MemPlace` to consult instead.\n     pub fn access_mut(\n         &mut self,\n-    ) -> EvalResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n+    ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n             LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n@@ -190,7 +190,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n     for InterpretCx<'a, 'mir, 'tcx, M>\n {\n     type Ty = Ty<'tcx>;\n-    type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n+    type TyLayout = InterpResult<'tcx, TyLayout<'tcx>>;\n \n     #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n@@ -259,7 +259,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n         substs: T,\n-    ) -> EvalResult<'tcx, T> {\n+    ) -> InterpResult<'tcx, T> {\n         match self.stack.last() {\n             Some(frame) => Ok(self.tcx.subst_and_normalize_erasing_regions(\n                 frame.instance.substs,\n@@ -278,7 +278,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         &self,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>\n-    ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n         trace!(\"param_env: {:#?}\", self.param_env);\n         let substs = self.subst_and_normalize_erasing_regions(substs)?;\n@@ -302,7 +302,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n-    ) -> EvalResult<'tcx, &'tcx mir::Body<'tcx>> {\n+    ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n         if did.is_local()\n@@ -325,7 +325,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub(super) fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n         &self,\n         t: T,\n-    ) -> EvalResult<'tcx, T> {\n+    ) -> InterpResult<'tcx, T> {\n         match self.stack.last() {\n             Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)),\n             None => if t.needs_subst() {\n@@ -352,7 +352,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n         layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n+    ) -> InterpResult<'tcx, TyLayout<'tcx>> {\n         match frame.locals[local].layout.get() {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n@@ -375,7 +375,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         &self,\n         metadata: Option<Scalar<M::PointerTag>>,\n         layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n+    ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n             return Ok(Some((layout.size, layout.align.abi)));\n         }\n@@ -467,7 +467,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub fn size_and_align_of_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n+    ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         self.size_and_align_of(mplace.meta, mplace.layout)\n     }\n \n@@ -478,7 +478,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         mir: &'mir mir::Body<'tcx>,\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if self.stack.len() > 0 {\n             info!(\"PAUSING({}) {}\", self.cur_frame(), self.frame().instance);\n         }\n@@ -546,7 +546,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         }\n     }\n \n-    pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n+    pub(super) fn pop_stack_frame(&mut self) -> InterpResult<'tcx> {\n         info!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\n@@ -611,7 +611,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub fn storage_live(\n         &mut self,\n         local: mir::Local\n-    ) -> EvalResult<'tcx, LocalValue<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, LocalValue<M::PointerTag>> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n@@ -634,7 +634,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub(super) fn deallocate_local(\n         &mut self,\n         local: LocalValue<M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");\n@@ -648,7 +648,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub fn const_eval_raw(\n         &self,\n         gid: GlobalId<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let param_env = if self.tcx.is_static(gid.instance.def_id()) {\n             ty::ParamEnv::reveal_all()\n         } else {"}, {"sha": "8888d7ded8bb4fa2a8407a9f89d6a4be48ab9c6f", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -7,7 +7,7 @@ use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::mir::BinOp;\n use rustc::mir::interpret::{\n-    EvalResult, InterpError, Scalar,\n+    InterpResult, InterpError, Scalar,\n };\n \n use super::{\n@@ -22,7 +22,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n     name: &str,\n     bits: u128,\n     kind: Primitive,\n-) -> EvalResult<'tcx, Scalar<Tag>> {\n+) -> InterpResult<'tcx, Scalar<Tag>> {\n     let size = match kind {\n         Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n@@ -46,7 +46,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n@@ -231,7 +231,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n-    ) -> EvalResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n         // Some fn calls are actually BinOp intrinsics\n         if let Some((op, oflo)) = self.tcx.is_binop_lang_item(def_id) {"}, {"sha": "7ee77a9a05f8b323145c51d963d3370c0b14c88c", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -10,7 +10,7 @@ use rustc::mir;\n use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n-    Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n+    Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n     InterpretCx, PlaceTy, OpTy, ImmTy, MemoryKind,\n };\n \n@@ -99,7 +99,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;\n+    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -117,7 +117,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n@@ -126,7 +126,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n-    ) -> EvalResult<'tcx>;\n+    ) -> InterpResult<'tcx>;\n \n     /// Called for read access to a foreign static item.\n     ///\n@@ -138,7 +138,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn find_foreign_static(\n         def_id: DefId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>>;\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n@@ -149,13 +149,13 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n-    ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n+    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n-    ) -> EvalResult<'tcx>;\n+    ) -> InterpResult<'tcx>;\n \n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n@@ -196,18 +196,18 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: PlaceTy<'tcx, Self::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a new stack frame got pushed\n     fn stack_push(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-    ) -> EvalResult<'tcx, Self::FrameExtra>;\n+    ) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n-    ) -> EvalResult<'tcx>;\n+    ) -> InterpResult<'tcx>;\n }"}, {"sha": "7126cd86a19599e6aac579798ca40b8c6385cc38", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -18,7 +18,7 @@ use syntax::ast::Mutability;\n \n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n-    EvalResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n+    InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InboundsCheck,\n };\n \n@@ -156,7 +156,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -178,7 +178,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Deallocate a local, or do nothing if that local has been made into a static\n-    pub fn deallocate_local(&mut self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx> {\n+    pub fn deallocate_local(&mut self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx> {\n         // The allocation might be already removed by static interning.\n         // This can only really happen in the CTFE instance, not in miri.\n         if self.alloc_map.contains_key(&ptr.alloc_id) {\n@@ -193,7 +193,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         ptr: Pointer<M::PointerTag>,\n         size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n@@ -257,7 +257,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: Scalar<M::PointerTag>,\n         required_align: Align\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr.to_bits_or_ptr(self.pointer_size(), self) {\n             Err(ptr) => {\n@@ -304,7 +304,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         ptr: Pointer<M::PointerTag>,\n         liveness: InboundsCheck,\n         msg: CheckInAllocMsg,\n-    ) -> EvalResult<'tcx, Align> {\n+    ) -> InterpResult<'tcx, Align> {\n         let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id, liveness)?;\n         ptr.check_in_alloc(allocation_size, msg)?;\n         Ok(align)\n@@ -331,7 +331,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         id: AllocId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         memory_extra: &M::MemoryExtra,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let alloc = match alloc {\n             Some(GlobalAlloc::Memory(mem)) =>\n@@ -381,11 +381,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         ).0)\n     }\n \n-    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n+    pub fn get(\n+        &self,\n+        id: AllocId,\n+    ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n-        // So the error type is `EvalResult<'tcx, &Allocation<M::PointerTag>>`.\n+        // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n             let alloc = Self::get_static_alloc(id, self.tcx, &self.extra).map_err(Err)?;\n             match alloc {\n@@ -414,7 +417,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> EvalResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n+    ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n         let tcx = self.tcx;\n         let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n@@ -450,7 +453,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n         liveness: InboundsCheck,\n-    ) -> EvalResult<'static, (Size, Align)> {\n+    ) -> InterpResult<'static, (Size, Align)> {\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n         }\n@@ -477,7 +480,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx, Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx, Instance<'tcx>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n@@ -488,7 +491,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn mark_immutable(&mut self, id: AllocId) -> EvalResult<'tcx> {\n+    pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n         self.get_mut(id)?.mutability = Mutability::Immutable;\n         Ok(())\n     }\n@@ -625,7 +628,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: Scalar<M::PointerTag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> InterpResult<'tcx, &[u8]> {\n         if size.bytes() == 0 {\n             Ok(&[])\n         } else {\n@@ -647,7 +650,7 @@ where\n         &mut self,\n         alloc_id: AllocId,\n         mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\n             \"mark_static_initialized {:?}, mutability: {:?}\",\n             alloc_id,\n@@ -695,7 +698,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n     }\n \n@@ -708,7 +711,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         length: u64,\n         nonoverlapping: bool,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         self.check_align(src, src_align)?;\n         self.check_align(dest, dest_align)?;\n         if size.bytes() == 0 {\n@@ -811,7 +814,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         dest: Pointer<M::PointerTag>,\n         size: Size,\n         repeat: u64,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n "}, {"sha": "7c83bf1d27d941c2571ee23def2fc053e8bd0bd0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerEx\n use rustc::mir::interpret::{\n     GlobalId, AllocId, CheckInAllocMsg,\n     ConstValue, Pointer, Scalar,\n-    EvalResult, InterpError, InboundsCheck,\n+    InterpResult, InterpError, InboundsCheck,\n     sign_extend, truncate,\n };\n use super::{\n@@ -61,12 +61,12 @@ impl<'tcx, Tag> Immediate<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar(self) -> EvalResult<'tcx, Scalar<Tag>> {\n+    pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n         self.to_scalar_or_undef().not_undef()\n     }\n \n     #[inline]\n-    pub fn to_scalar_pair(self) -> EvalResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n         match self {\n             Immediate::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n             Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n@@ -76,7 +76,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n     /// Converts the immediate into a pointer (or a pointer-sized integer).\n     /// Throws away the second half of a ScalarPair!\n     #[inline]\n-    pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar<Tag>> {\n+    pub fn to_scalar_ptr(self) -> InterpResult<'tcx, Scalar<Tag>> {\n         match self {\n             Immediate::Scalar(ptr) |\n             Immediate::ScalarPair(ptr, _) => ptr.not_undef(),\n@@ -86,7 +86,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n     /// Converts the value into its metadata.\n     /// Throws away the first half of a ScalarPair!\n     #[inline]\n-    pub fn to_meta(self) -> EvalResult<'tcx, Option<Scalar<Tag>>> {\n+    pub fn to_meta(self) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n         Ok(match self {\n             Immediate::Scalar(_) => None,\n             Immediate::ScalarPair(_, meta) => Some(meta.not_undef()?),\n@@ -185,7 +185,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n     }\n \n     #[inline]\n-    pub fn to_bits(self) -> EvalResult<'tcx, u128> {\n+    pub fn to_bits(self) -> InterpResult<'tcx, u128> {\n         self.to_scalar()?.to_bits(self.layout.size)\n     }\n }\n@@ -195,8 +195,8 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n #[inline(always)]\n pub(super) fn from_known_layout<'tcx>(\n     layout: Option<TyLayout<'tcx>>,\n-    compute: impl FnOnce() -> EvalResult<'tcx, TyLayout<'tcx>>\n-) -> EvalResult<'tcx, TyLayout<'tcx>> {\n+    compute: impl FnOnce() -> InterpResult<'tcx, TyLayout<'tcx>>\n+) -> InterpResult<'tcx, TyLayout<'tcx>> {\n     match layout {\n         None => compute(),\n         Some(layout) => {\n@@ -217,7 +217,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, Option<Immediate<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Option<Immediate<M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n             return Ok(None);\n@@ -271,7 +271,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub(crate) fn try_read_immediate(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n@@ -289,7 +289,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub fn read_immediate(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         if let Ok(imm) = self.try_read_immediate(op)? {\n             Ok(ImmTy { imm, layout: op.layout })\n         } else {\n@@ -301,15 +301,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub fn read_scalar(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n         Ok(self.read_immediate(op)?.to_scalar_or_undef())\n     }\n \n     // Turn the MPlace into a string (must already be dereferenced!)\n     pub fn read_str(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, &str> {\n+    ) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n         let str = ::std::str::from_utf8(bytes)\n@@ -322,7 +322,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         field: u64,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace() {\n             Ok(mplace) => {\n                 // The easy case\n@@ -357,7 +357,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         Ok(match op.try_as_mplace() {\n             Ok(mplace) => {\n@@ -374,7 +374,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         base: OpTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::PlaceElem<'tcx>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n@@ -401,7 +401,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n         layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         assert_ne!(local, mir::RETURN_PLACE);\n         let layout = self.layout_of_local(frame, local, layout)?;\n         let op = if layout.is_zst() {\n@@ -418,7 +418,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub fn place_to_op(\n         &self,\n         place: PlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let op = match *place {\n             Place::Ptr(mplace) => {\n                 Operand::Indirect(mplace)\n@@ -435,7 +435,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place;\n         use rustc::mir::PlaceBase;\n \n@@ -475,7 +475,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         mir_op: &mir::Operand<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Operand::*;\n         let op = match *mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n@@ -493,7 +493,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub(super) fn eval_operands(\n         &self,\n         ops: &[mir::Operand<'tcx>],\n-    ) -> EvalResult<'tcx, Vec<OpTy<'tcx, M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Vec<OpTy<'tcx, M::PointerTag>>> {\n         ops.into_iter()\n             .map(|op| self.eval_operand(op, None))\n             .collect()\n@@ -505,7 +505,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         val: &'tcx ty::Const<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let tag_scalar = |scalar| match scalar {\n             Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_static_base_pointer(ptr)),\n             Scalar::Raw { data, size } => Scalar::Raw { data, size },\n@@ -561,7 +561,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub fn read_discriminant(\n         &self,\n         rval: OpTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, (u128, VariantIdx)> {\n+    ) -> InterpResult<'tcx, (u128, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n         let (discr_kind, discr_index) = match rval.layout.variants {"}, {"sha": "4f13eeb6fa450d80c914c00b4e72bd3e906b1449", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, layout::{Size, TyLayout}};\n use syntax::ast::FloatTy;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n-use rustc::mir::interpret::{EvalResult, Scalar};\n+use rustc::mir::interpret::{InterpResult, Scalar};\n \n use super::{InterpretCx, PlaceTy, Immediate, Machine, ImmTy};\n \n@@ -17,7 +17,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let (val, overflowed) = self.binary_op(op, left, right)?;\n         let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_immediate(val, dest)\n@@ -31,7 +31,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let (val, _overflowed) = self.binary_op(op, left, right)?;\n         self.write_scalar(val, dest)\n     }\n@@ -43,7 +43,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -63,7 +63,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -88,7 +88,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         // passing in raw bits\n         l: u128,\n         r: u128,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         macro_rules! float_math {\n@@ -128,7 +128,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         left_layout: TyLayout<'tcx>,\n         r: u128,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         // Shift ops can have an RHS with a different numeric type.\n@@ -279,7 +279,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n@@ -329,7 +329,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &self,\n         un_op: mir::UnOp,\n         val: ImmTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n \n         let layout = val.layout;"}, {"sha": "05642e3cad445ec039a5a63488b686451b1640e3", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -12,7 +12,7 @@ use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, Va\n use rustc::ty::TypeFoldable;\n \n use super::{\n-    GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n+    GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n     InterpretCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue\n };\n@@ -130,7 +130,7 @@ impl<Tag> MemPlace<Tag> {\n \n     /// metact the ptr part of the mplace\n     #[inline(always)]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n+    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         // At this point, we forget about the alignment information --\n         // the place has been turned into a reference, and no matter where it came from,\n         // it now must be aligned.\n@@ -152,7 +152,7 @@ impl<Tag> MemPlace<Tag> {\n         offset: Size,\n         meta: Option<Scalar<Tag>>,\n         cx: &impl HasDataLayout,\n-    ) -> EvalResult<'tcx, Self> {\n+    ) -> InterpResult<'tcx, Self> {\n         Ok(MemPlace {\n             ptr: self.ptr.ptr_offset(offset, cx)?,\n             align: self.align.restrict_for_offset(offset),\n@@ -190,7 +190,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         meta: Option<Scalar<Tag>>,\n         layout: TyLayout<'tcx>,\n         cx: &impl HasDataLayout,\n-    ) -> EvalResult<'tcx, Self> {\n+    ) -> InterpResult<'tcx, Self> {\n         Ok(MPlaceTy {\n             mplace: self.mplace.offset(offset, meta, cx)?,\n             layout,\n@@ -203,7 +203,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn len(self, cx: &impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+    pub(super) fn len(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.sty {\n@@ -222,7 +222,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn vtable(self) -> EvalResult<'tcx, Pointer<Tag>> {\n+    pub(super) fn vtable(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self.layout.ty.sty {\n             ty::Dynamic(..) => self.mplace.meta.unwrap().to_ptr(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n@@ -277,7 +277,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n+    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         self.to_mem_place().to_ptr()\n     }\n }\n@@ -306,7 +306,7 @@ where\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n \n@@ -327,7 +327,7 @@ where\n     pub fn deref_operand(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n         self.ref_to_mplace(val)\n@@ -341,7 +341,7 @@ where\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         field: u64,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Not using the layout method because we want to compute on u64\n         let offset = match base.layout.fields {\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } =>\n@@ -397,7 +397,7 @@ where\n         &self,\n         base: MPlaceTy<'tcx, Tag>,\n     ) ->\n-        EvalResult<'tcx, impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n+        InterpResult<'tcx, impl Iterator<Item=InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n@@ -414,7 +414,7 @@ where\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n         to: u64,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         assert!(from <= len - to);\n \n@@ -448,7 +448,7 @@ where\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         assert!(base.meta.is_none());\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n@@ -459,7 +459,7 @@ where\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::PlaceElem<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n             Field(field, _) => self.mplace_field(base, field.index() as u64)?,\n@@ -504,7 +504,7 @@ where\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n         field: u64,\n-    ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let mplace = self.force_allocation(base)?;\n@@ -515,7 +515,7 @@ where\n         &self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n-    ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n         Ok(match base.place {\n             Place::Ptr(mplace) =>\n@@ -532,7 +532,7 @@ where\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n-    ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n             Field(field, _) =>  self.place_field(base, field.index() as u64)?,\n@@ -552,7 +552,7 @@ where\n     pub(super) fn eval_static_to_mplace(\n         &self,\n         place_static: &mir::Static<'tcx>\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::StaticKind;\n \n         Ok(match place_static.kind {\n@@ -600,7 +600,7 @@ where\n     pub fn eval_place(\n         &mut self,\n         mir_place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::PlaceBase;\n \n         mir_place.iterate(|place_base, place_projection| {\n@@ -642,7 +642,7 @@ where\n         &mut self,\n         val: impl Into<ScalarMaybeUndef<M::PointerTag>>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         self.write_immediate(Immediate::Scalar(val.into()), dest)\n     }\n \n@@ -652,7 +652,7 @@ where\n         &mut self,\n         src: Immediate<M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         self.write_immediate_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n@@ -669,7 +669,7 @@ where\n         &mut self,\n         src: Immediate<M::PointerTag>,\n         dest: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         self.write_immediate_to_mplace_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n@@ -687,7 +687,7 @@ where\n         &mut self,\n         src: Immediate<M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if cfg!(debug_assertions) {\n             // This is a very common path, avoid some checks in release mode\n             assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n@@ -737,7 +737,7 @@ where\n         &mut self,\n         value: Immediate<M::PointerTag>,\n         dest: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n@@ -801,7 +801,7 @@ where\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         self.copy_op_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n@@ -820,7 +820,7 @@ where\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n         assert!(src.layout.details == dest.layout.details,\n@@ -865,7 +865,7 @@ where\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if src.layout.details == dest.layout.details {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n@@ -912,7 +912,7 @@ where\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n         meta: Option<Scalar<M::PointerTag>>,\n-    ) -> EvalResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n                 match self.stack[frame].locals[local].access_mut()? {\n@@ -965,7 +965,7 @@ where\n     pub fn force_allocation(\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         Ok(self.force_allocation_maybe_sized(place, None)?.0)\n     }\n \n@@ -982,7 +982,7 @@ where\n         &mut self,\n         variant_index: VariantIdx,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         match dest.layout.variants {\n             layout::Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n@@ -1038,7 +1038,7 @@ where\n     pub fn raw_const_to_mplace(\n         &self,\n         raw: RawConst<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n         assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n         let ptr = self.tag_static_base_pointer(Pointer::from(raw.alloc_id));\n@@ -1049,7 +1049,7 @@ where\n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx, M::PointerTag>)\n-    -> EvalResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n+    -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n         let vtable = mplace.vtable()?; // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;"}, {"sha": "ae09ae0a19836f7dee947a01fe380ed726e15d9b", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -12,7 +12,7 @@ use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n     Relocations, Allocation, UndefMask,\n-    EvalResult, InterpError,\n+    InterpResult, InterpError,\n };\n \n use rustc::ty::{self, TyCtxt};\n@@ -29,18 +29,18 @@ use crate::const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n-    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n+    /// The set of all `InterpSnapshot` *hashes* observed by this detector.\n     ///\n     /// When a collision occurs in this table, we store the full snapshot in\n     /// `snapshots`.\n     hashes: FxHashSet<u64>,\n \n-    /// The set of all `EvalSnapshot`s observed by this detector.\n+    /// The set of all `InterpSnapshot`s observed by this detector.\n     ///\n-    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n+    /// An `InterpSnapshot` will only be fully cloned once it has caused a\n     /// collision in `hashes`. As a result, the detector must observe at least\n     /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx>>,\n+    snapshots: FxHashSet<InterpSnapshot<'a, 'mir, 'tcx>>,\n }\n \n impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n@@ -51,7 +51,7 @@ impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n         span: Span,\n         memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>],\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> InterpResult<'tcx, ()> {\n         // Compute stack's hash before copying anything\n         let mut hcx = tcx.get_stable_hashing_context();\n         let mut hasher = StableHasher::<u64>::new();\n@@ -72,7 +72,7 @@ impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n         // We need to make a full copy. NOW things that to get really expensive.\n         info!(\"snapshotting the state of the interpreter\");\n \n-        if self.snapshots.insert(EvalSnapshot::new(memory, stack)) {\n+        if self.snapshots.insert(InterpSnapshot::new(memory, stack)) {\n             // Spurious collision or first cycle\n             return Ok(())\n         }\n@@ -384,18 +384,18 @@ impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n /// The virtual machine state during const-evaluation at a given point in time.\n /// We assume the `CompileTimeInterpreter` has no interesting extra state that\n /// is worth considering here.\n-struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n+struct InterpSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n     memory: Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx: 'a + 'mir> EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx: 'a + 'mir> InterpSnapshot<'a, 'mir, 'tcx>\n {\n     fn new(\n         memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>]\n     ) -> Self {\n-        EvalSnapshot {\n+        InterpSnapshot {\n             memory: memory.clone(),\n             stack: stack.into(),\n         }\n@@ -411,7 +411,7 @@ impl<'a, 'mir, 'tcx: 'a + 'mir> EvalSnapshot<'a, 'mir, 'tcx>\n \n }\n \n-impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx> Hash for InterpSnapshot<'a, 'mir, 'tcx>\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n@@ -422,16 +422,16 @@ impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n     }\n }\n \n-impl_stable_hash_for!(impl<'tcx, 'b, 'mir> for struct EvalSnapshot<'b, 'mir, 'tcx> {\n+impl_stable_hash_for!(impl<'tcx, 'b, 'mir> for struct InterpSnapshot<'b, 'mir, 'tcx> {\n     // Not hashing memory: Avoid hashing memory all the time during execution\n     memory -> _,\n     stack,\n });\n \n-impl<'a, 'mir, 'tcx> Eq for EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx> Eq for InterpSnapshot<'a, 'mir, 'tcx>\n {}\n \n-impl<'a, 'mir, 'tcx> PartialEq for EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx> PartialEq for InterpSnapshot<'a, 'mir, 'tcx>\n {\n     fn eq(&self, other: &Self) -> bool {\n         // FIXME: This looks to be a *ridiculously expensive* comparison operation."}, {"sha": "8070b86c522c4dc4c4bc395272a729c2d81e79a0", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -4,7 +4,7 @@\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n-use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n+use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic};\n \n use super::{InterpretCx, Machine};\n \n@@ -36,15 +36,15 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n-    pub fn run(&mut self) -> EvalResult<'tcx> {\n+    pub fn run(&mut self) -> InterpResult<'tcx> {\n         while self.step()? {}\n         Ok(())\n     }\n \n     /// Returns `true` as long as there are more things to do.\n     ///\n     /// This is used by [priroda](https://github.com/oli-obk/priroda)\n-    pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n+    pub fn step(&mut self) -> InterpResult<'tcx, bool> {\n         if self.stack.is_empty() {\n             return Ok(false);\n         }\n@@ -70,7 +70,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         Ok(true)\n     }\n \n-    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx> {\n+    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", stmt);\n \n         use rustc::mir::StatementKind::*;\n@@ -136,7 +136,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n         place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let dest = self.eval_place(place)?;\n \n         use rustc::mir::Rvalue::*;\n@@ -277,7 +277,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         Ok(())\n     }\n \n-    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n+    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", terminator.kind);\n         self.tcx.span = terminator.source_info.span;\n         self.memory.tcx.span = terminator.source_info.span;"}, {"sha": "452aa75e3b3dedc30eba5d7e007a8c66dd454924", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -6,14 +6,14 @@ use rustc::ty::layout::{self, TyLayout, LayoutOf};\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, PointerArithmetic, InterpError, Scalar};\n+use rustc::mir::interpret::{InterpResult, PointerArithmetic, InterpError, Scalar};\n use super::{\n     InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     #[inline]\n-    pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> EvalResult<'tcx> {\n+    pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {\n             self.frame_mut().block = target;\n             self.frame_mut().stmt = 0;\n@@ -26,7 +26,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         use rustc::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n@@ -206,7 +206,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         rust_abi: bool,\n         caller_arg: &mut impl Iterator<Item=OpTy<'tcx, M::PointerTag>>,\n         callee_arg: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if rust_abi && callee_arg.layout.is_zst() {\n             // Nothing to do.\n             trace!(\"Skipping callee ZST\");\n@@ -234,7 +234,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n \n         match instance.def {\n@@ -337,7 +337,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                                 .chain((0..untuple_arg.layout.fields.count()).into_iter()\n                                     .map(|i| self.operand_field(untuple_arg, i as u64))\n                                 )\n-                                .collect::<EvalResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>()?)\n+                                .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>()?)\n                         } else {\n                             // Plain arg passing\n                             Cow::from(args)\n@@ -457,7 +457,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         instance: ty::Instance<'tcx>,\n         span: Span,\n         target: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n         // We take the address of the object.  This may well be unaligned, which is fine\n         // for us here.  However, unaligned accesses will probably make the actual drop"}, {"sha": "220f3e8b936419f99717bae1edbd19898aca0b13", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n-use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n+use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n use super::{InterpretCx, InterpError, Machine, MemoryKind};\n \n@@ -15,7 +15,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         &mut self,\n         ty: Ty<'tcx>,\n         poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         trace!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n@@ -102,7 +102,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub fn read_drop_type_from_vtable(\n         &self,\n         vtable: Pointer<M::PointerTag>,\n-    ) -> EvalResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n+    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n         self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n         let drop_fn = self.memory\n@@ -121,7 +121,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     pub fn read_size_and_align_from_vtable(\n         &self,\n         vtable: Pointer<M::PointerTag>,\n-    ) -> EvalResult<'tcx, (Size, Align)> {\n+    ) -> InterpResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n         self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n         let alloc = self.memory.get(vtable.alloc_id)?;"}, {"sha": "21704bf66e8d26ba07c734d1282bb21d5b3162ca", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -8,7 +8,7 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, GlobalAlloc, EvalResult, InterpError, CheckInAllocMsg,\n+    Scalar, GlobalAlloc, InterpResult, InterpError, CheckInAllocMsg,\n };\n \n use super::{\n@@ -223,7 +223,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n         &mut self,\n         new_op: OpTy<'tcx, M::PointerTag>,\n         elem: PathElem,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // Remember the old state\n         let path_len = self.path.len();\n         // Perform operation\n@@ -251,7 +251,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         old_op: OpTy<'tcx, M::PointerTag>,\n         field: usize,\n         new_op: OpTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let elem = self.aggregate_field_path_elem(old_op.layout, field);\n         self.visit_elem(new_op, elem)\n     }\n@@ -262,7 +262,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         old_op: OpTy<'tcx, M::PointerTag>,\n         variant_id: VariantIdx,\n         new_op: OpTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let name = match old_op.layout.ty.sty {\n             ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n             // Generators also have variants\n@@ -273,7 +273,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     }\n \n     #[inline]\n-    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx>\n     {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n         // Translate some possible errors to something nicer.\n@@ -293,7 +293,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         }\n     }\n \n-    fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+    fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx>\n     {\n         let value = self.ecx.read_immediate(value)?;\n         // Go over all the primitive types\n@@ -449,7 +449,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         Ok(())\n     }\n \n-    fn visit_uninhabited(&mut self) -> EvalResult<'tcx>\n+    fn visit_uninhabited(&mut self) -> InterpResult<'tcx>\n     {\n         validation_failure!(\"a value of an uninhabited type\", self.path)\n     }\n@@ -458,7 +458,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         &mut self,\n         op: OpTy<'tcx, M::PointerTag>,\n         layout: &layout::Scalar,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let value = self.ecx.read_scalar(op)?;\n         // Determine the allowed range\n         let (lo, hi) = layout.valid_range.clone().into_inner();\n@@ -526,8 +526,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     fn visit_aggregate(\n         &mut self,\n         op: OpTy<'tcx, M::PointerTag>,\n-        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n-    ) -> EvalResult<'tcx> {\n+        fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n+    ) -> InterpResult<'tcx> {\n         match op.layout.ty.sty {\n             ty::Str => {\n                 let mplace = op.to_mem_place(); // strings are never immediate\n@@ -621,7 +621,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         path: Vec<PathElem>,\n         ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n         const_mode: bool,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor"}, {"sha": "b5477c68610195878a5243a7661614451ec01bf0", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -4,7 +4,7 @@\n use rustc::ty::layout::{self, TyLayout, VariantIdx};\n use rustc::ty;\n use rustc::mir::interpret::{\n-    EvalResult,\n+    InterpResult,\n };\n \n use super::{\n@@ -23,7 +23,7 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     fn to_op(\n         self,\n         ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n     fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self;\n@@ -33,14 +33,14 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n         self,\n         ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n-    ) -> EvalResult<'tcx, Self>;\n+    ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n     fn project_field(\n         self,\n         ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n-    ) -> EvalResult<'tcx, Self>;\n+    ) -> InterpResult<'tcx, Self>;\n }\n \n // Operands and memory-places are both values.\n@@ -57,7 +57,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     fn to_op(\n         self,\n         _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self)\n     }\n \n@@ -71,7 +71,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n         self,\n         ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n-    ) -> EvalResult<'tcx, Self> {\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n     }\n \n@@ -80,7 +80,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n         self,\n         ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n-    ) -> EvalResult<'tcx, Self> {\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n     }\n }\n@@ -96,7 +96,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     fn to_op(\n         self,\n         _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n \n@@ -110,7 +110,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n         self,\n         ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n-    ) -> EvalResult<'tcx, Self> {\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n     }\n \n@@ -119,7 +119,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n         self,\n         ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n-    ) -> EvalResult<'tcx, Self> {\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n     }\n }\n@@ -137,25 +137,25 @@ macro_rules! make_value_visitor {\n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors.\n             #[inline(always)]\n-            fn visit_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n+            fn visit_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n             {\n                 self.walk_value(v)\n             }\n             /// Visits the given value as a union. No automatic recursion can happen here.\n             #[inline(always)]\n-            fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n+            fn visit_union(&mut self, _v: Self::V) -> InterpResult<'tcx>\n             {\n                 Ok(())\n             }\n             /// Visits this value as an aggregate, you are getting an iterator yielding\n-            /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n+            /// all the fields (still in an `InterpResult`, you have to do error handling yourself).\n             /// Recurses into the fields.\n             #[inline(always)]\n             fn visit_aggregate(\n                 &mut self,\n                 v: Self::V,\n-                fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n-            ) -> EvalResult<'tcx> {\n+                fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n+            ) -> InterpResult<'tcx> {\n                 self.walk_aggregate(v, fields)\n             }\n \n@@ -170,7 +170,7 @@ macro_rules! make_value_visitor {\n                 _old_val: Self::V,\n                 _field: usize,\n                 new_val: Self::V,\n-            ) -> EvalResult<'tcx> {\n+            ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n \n@@ -181,7 +181,7 @@ macro_rules! make_value_visitor {\n                 _old_val: Self::V,\n                 _variant: VariantIdx,\n                 new_val: Self::V,\n-            ) -> EvalResult<'tcx> {\n+            ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n \n@@ -191,7 +191,7 @@ macro_rules! make_value_visitor {\n             /// it is meant to provide the chance for additional checks when a value of uninhabited\n             /// layout is detected.\n             #[inline(always)]\n-            fn visit_uninhabited(&mut self) -> EvalResult<'tcx>\n+            fn visit_uninhabited(&mut self) -> InterpResult<'tcx>\n             { Ok(()) }\n             /// Called whenever we reach a value with scalar layout.\n             /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory if the\n@@ -201,30 +201,30 @@ macro_rules! make_value_visitor {\n             /// it is meant to provide the chance for additional checks when a value of scalar\n             /// layout is detected.\n             #[inline(always)]\n-            fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> EvalResult<'tcx>\n+            fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> InterpResult<'tcx>\n             { Ok(()) }\n \n             /// Called whenever we reach a value of primitive type. There can be no recursion\n             /// below such a value. This is the leaf function.\n             /// We do *not* provide an `ImmTy` here because some implementations might want\n             /// to write to the place this primitive lives in.\n             #[inline(always)]\n-            fn visit_primitive(&mut self, _v: Self::V) -> EvalResult<'tcx>\n+            fn visit_primitive(&mut self, _v: Self::V) -> InterpResult<'tcx>\n             { Ok(()) }\n \n             // Default recursors. Not meant to be overloaded.\n             fn walk_aggregate(\n                 &mut self,\n                 v: Self::V,\n-                fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n-            ) -> EvalResult<'tcx> {\n+                fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n+            ) -> InterpResult<'tcx> {\n                 // Now iterate over it.\n                 for (idx, field_val) in fields.enumerate() {\n                     self.visit_field(v, idx, field_val?)?;\n                 }\n                 Ok(())\n             }\n-            fn walk_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n+            fn walk_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n             {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n                 // If this is a multi-variant layout, we have to find the right one and proceed with\n@@ -306,7 +306,7 @@ macro_rules! make_value_visitor {\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n-                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                        let fields: Vec<InterpResult<'tcx, Self::V>> =\n                             (0..offsets.len()).map(|i| {\n                                 v.project_field(self.ecx(), i as u64)\n                             })"}, {"sha": "ce460ccaaa5c23a1ca29dc48ffcd7847dfc6ecc6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c45343f11fbf93cf4e15568aee3ff3f2f287466/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5c45343f11fbf93cf4e15568aee3ff3f2f287466", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::{\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n };\n-use rustc::mir::interpret::{InterpError, Scalar, GlobalId, EvalResult};\n+use rustc::mir::interpret::{InterpError, Scalar, GlobalId, InterpResult};\n use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n@@ -156,7 +156,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         f: F\n     ) -> Option<T>\n     where\n-        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n+        F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n         self.ecx.tcx.span = source_info.span;\n         let lint_root = match self.source_scope_local_data {"}]}