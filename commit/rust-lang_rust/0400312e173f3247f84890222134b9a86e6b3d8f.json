{"sha": "0400312e173f3247f84890222134b9a86e6b3d8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MDAzMTJlMTczZjMyNDdmODQ4OTAyMjIxMzRiOWE4NmU2YjNkOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-26T14:10:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-26T14:10:38Z"}, "message": "Auto merge of #46203 - nikomatsakis:type-foldable-macro, r=eddyb\n\nintroduce macros for type-foldable and lift, convert stuff to use them\n\nA random commit from a branch I've shelved for the time being that made `TypeFoldable` stuff a bit less annoying to write.\n\nr? @eddyb", "tree": {"sha": "7b59ddbf50ce44fe53e1bca3f584fae980499000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b59ddbf50ce44fe53e1bca3f584fae980499000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0400312e173f3247f84890222134b9a86e6b3d8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0400312e173f3247f84890222134b9a86e6b3d8f", "html_url": "https://github.com/rust-lang/rust/commit/0400312e173f3247f84890222134b9a86e6b3d8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0400312e173f3247f84890222134b9a86e6b3d8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ca00a948934766950167e997903a2cc0243c5cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca00a948934766950167e997903a2cc0243c5cf", "html_url": "https://github.com/rust-lang/rust/commit/2ca00a948934766950167e997903a2cc0243c5cf"}, {"sha": "27d5872025e0fe9376e7428d197f4810fb7bb0b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d5872025e0fe9376e7428d197f4810fb7bb0b0", "html_url": "https://github.com/rust-lang/rust/commit/27d5872025e0fe9376e7428d197f4810fb7bb0b0"}], "stats": {"total": 359, "additions": 203, "deletions": 156}, "files": [{"sha": "438511281ba47ff7468bc8f6cdcd7a12ab967e55", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 203, "deletions": 156, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/0400312e173f3247f84890222134b9a86e6b3d8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0400312e173f3247f84890222134b9a86e6b3d8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0400312e173f3247f84890222134b9a86e6b3d8f", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! This module contains implements of the `Lift` and `TypeFoldable`\n+//! traits for various types in the Rust compiler. Most are written by\n+//! hand, though we've recently added some macros (e.g.,\n+//! `BraceStructLiftImpl!`) to help with the tedium.\n+\n use infer::type_variable;\n use middle::const_val::{self, ConstVal, ConstAggregate, ConstEvalErr};\n use ty::{self, Lift, Ty, TyCtxt};\n@@ -16,9 +21,158 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use std::rc::Rc;\n-use syntax::abi;\n \n-use hir;\n+///////////////////////////////////////////////////////////////////////////\n+// Atomic structs\n+//\n+// For things that don't carry any arena-allocated data (and are\n+// copy...), just add them to this list.\n+\n+macro_rules! CopyImpls {\n+    ($($ty:ty,)+) => {\n+        $(\n+            impl<'tcx> Lift<'tcx> for $ty {\n+                type Lifted = Self;\n+                fn lift_to_tcx<'a, 'gcx>(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self> {\n+                    Some(*self)\n+                }\n+            }\n+\n+            impl<'tcx> TypeFoldable<'tcx> for $ty {\n+                fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n+                    *self\n+                }\n+\n+                fn super_visit_with<F: TypeVisitor<'tcx>>(&self, _: &mut F) -> bool {\n+                    false\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+CopyImpls! {\n+    (),\n+    ::hir::Unsafety,\n+    ::syntax::abi::Abi,\n+    ::hir::def_id::DefId,\n+    ::mir::Local,\n+    ::traits::Reveal,\n+    ::syntax_pos::Span,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Macros\n+//\n+// When possible, use one of these (relatively) convenient macros to write\n+// the impls for you.\n+\n+#[macro_export]\n+macro_rules! BraceStructLiftImpl {\n+    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n+        type Lifted = $lifted:ty;\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            type Lifted = $lifted;\n+\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+                $(let $field = tcx.lift(&self.$field)?;)*\n+                Some(Self::Lifted { $($field),* })\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! EnumLiftImpl {\n+    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n+        type Lifted = $lifted:ty;\n+        $(\n+            ($variant:path) ( $( $variant_arg:ident),* )\n+        ),*\n+        $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            type Lifted = $lifted;\n+\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+                match self {\n+                    $($variant ( $($variant_arg),* ) => {\n+                        Some($variant ( $(tcx.lift($variant_arg)?),* ))\n+                    })*\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! BraceStructTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                let $s { $($field,)* } = self;\n+                $s { $($field: $field.fold_with(folder),)* }\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                let $s { $($field,)* } = self;\n+                false $(|| $field.visit_with(visitor))*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! EnumTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $(\n+            ($variant:path) ( $( $variant_arg:ident),* )\n+        ),*\n+        $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                match self {\n+                    $($variant ( $($variant_arg),* ) => {\n+                        $variant ( $($variant_arg.fold_with(folder)),* )\n+                    })*\n+                }\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                match self {\n+                    $($variant ( $($variant_arg),* ) => {\n+                        false $(|| $variant_arg.visit_with(visitor))*\n+                    })*\n+                }\n+            }\n+        }\n+    };\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n@@ -90,6 +244,15 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     }\n }\n \n+impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n+    type Lifted = IndexVec<I, T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        self.iter()\n+            .map(|e| tcx.lift(e))\n+            .collect()\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -384,16 +547,10 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for type_variable::Default<'a> {\n-    type Lifted = type_variable::Default<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.ty).map(|ty| {\n-            type_variable::Default {\n-                ty,\n-                origin_span: self.origin_span,\n-                def_id: self.def_id\n-            }\n-        })\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for type_variable::Default<'a> {\n+        type Lifted = type_variable::Default<'tcx>;\n+        ty, origin_span, def_id\n     }\n }\n \n@@ -507,31 +664,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::layout::LayoutError<'a> {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n-macro_rules! CopyImpls {\n-    ($($ty:ty),+) => {\n-        $(\n-            impl<'tcx> Lift<'tcx> for $ty {\n-                type Lifted = Self;\n-                fn lift_to_tcx<'a, 'gcx>(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self> {\n-                    Some(*self)\n-                }\n-            }\n-\n-            impl<'tcx> TypeFoldable<'tcx> for $ty {\n-                fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n-                    *self\n-                }\n-\n-                fn super_visit_with<F: TypeVisitor<'tcx>>(&self, _: &mut F) -> bool {\n-                    false\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-CopyImpls! { (), hir::Unsafety, abi::Abi, hir::def_id::DefId, ::mir::Local }\n-\n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n@@ -601,18 +733,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ParamEnv {\n-            reveal: self.reveal,\n-            caller_bounds: self.caller_bounds.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        let &ty::ParamEnv { reveal: _, ref caller_bounds } = self;\n-        caller_bounds.super_visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n@@ -734,17 +856,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::GenSig<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GenSig {\n-            yield_ty: self.yield_ty.fold_with(folder),\n-            return_ty: self.return_ty.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.yield_ty.visit_with(visitor) ||\n-        self.return_ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::GenSig<'tcx> {\n+        yield_ty, return_ty\n     }\n }\n \n@@ -765,46 +879,20 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitRef {\n-            def_id: self.def_id,\n-            substs: self.substs.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> { def_id, substs }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ExistentialTraitRef {\n-            def_id: self.def_id,\n-            substs: self.substs.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> { def_id, substs }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ImplHeader {\n-            impl_def_id: self.impl_def_id,\n-            self_ty: self.self_ty.fold_with(folder),\n-            trait_ref: self.trait_ref.map(|t| t.fold_with(folder)),\n-            predicates: self.predicates.iter().map(|p| p.fold_with(folder)).collect(),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.self_ty.visit_with(visitor) ||\n-            self.trait_ref.map(|r| r.visit_with(visitor)).unwrap_or(false) ||\n-            self.predicates.iter().any(|p| p.visit_with(visitor))\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n+        impl_def_id,\n+        self_ty,\n+        trait_ref,\n+        predicates,\n     }\n }\n \n@@ -848,17 +936,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::adjustment::Adjustment {\n-            kind: self.kind.fold_with(folder),\n-            target: self.target.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.kind.visit_with(visitor) ||\n-        self.target.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n+        kind,\n+        target,\n     }\n }\n \n@@ -929,16 +1010,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GenericPredicates {\n-            parent: self.parent,\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicates.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+        parent, predicates\n     }\n }\n \n@@ -996,55 +1071,27 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ProjectionPredicate {\n-            projection_ty: self.projection_ty.fold_with(folder),\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.projection_ty.visit_with(visitor) || self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n+        projection_ty, ty\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialProjection<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ExistentialProjection {\n-            ty: self.ty.fold_with(folder),\n-            substs: self.substs.fold_with(folder),\n-            item_def_id: self.item_def_id,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor) || self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialProjection<'tcx> {\n+        ty, substs, item_def_id\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ProjectionTy {\n-            substs: self.substs.fold_with(folder),\n-            item_def_id: self.item_def_id,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n+        substs, item_def_id\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::InstantiatedPredicates {\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicates.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n+        predicates\n     }\n }\n "}]}