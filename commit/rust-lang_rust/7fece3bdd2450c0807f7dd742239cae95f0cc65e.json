{"sha": "7fece3bdd2450c0807f7dd742239cae95f0cc65e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZWNlM2JkZDI0NTBjMDgwN2Y3ZGQ3NDIyMzljYWU5NWYwY2M2NWU=", "commit": {"author": {"name": "Galil\u00e9e 'Bill' Enguehard", "email": "galilee.enguehard@gmail.com", "date": "2020-05-21T21:27:38Z"}, "committer": {"name": "Galil\u00e9e 'Bill' Enguehard", "email": "galilee.enguehard@gmail.com", "date": "2020-05-21T21:27:38Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer into modname_spacing", "tree": {"sha": "866c4db826c959e79c63a6727bdb9f2c61e6fc4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/866c4db826c959e79c63a6727bdb9f2c61e6fc4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fece3bdd2450c0807f7dd742239cae95f0cc65e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fece3bdd2450c0807f7dd742239cae95f0cc65e", "html_url": "https://github.com/rust-lang/rust/commit/7fece3bdd2450c0807f7dd742239cae95f0cc65e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fece3bdd2450c0807f7dd742239cae95f0cc65e/comments", "author": {"login": "Arthamys", "id": 11710698, "node_id": "MDQ6VXNlcjExNzEwNjk4", "avatar_url": "https://avatars.githubusercontent.com/u/11710698?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Arthamys", "html_url": "https://github.com/Arthamys", "followers_url": "https://api.github.com/users/Arthamys/followers", "following_url": "https://api.github.com/users/Arthamys/following{/other_user}", "gists_url": "https://api.github.com/users/Arthamys/gists{/gist_id}", "starred_url": "https://api.github.com/users/Arthamys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Arthamys/subscriptions", "organizations_url": "https://api.github.com/users/Arthamys/orgs", "repos_url": "https://api.github.com/users/Arthamys/repos", "events_url": "https://api.github.com/users/Arthamys/events{/privacy}", "received_events_url": "https://api.github.com/users/Arthamys/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Arthamys", "id": 11710698, "node_id": "MDQ6VXNlcjExNzEwNjk4", "avatar_url": "https://avatars.githubusercontent.com/u/11710698?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Arthamys", "html_url": "https://github.com/Arthamys", "followers_url": "https://api.github.com/users/Arthamys/followers", "following_url": "https://api.github.com/users/Arthamys/following{/other_user}", "gists_url": "https://api.github.com/users/Arthamys/gists{/gist_id}", "starred_url": "https://api.github.com/users/Arthamys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Arthamys/subscriptions", "organizations_url": "https://api.github.com/users/Arthamys/orgs", "repos_url": "https://api.github.com/users/Arthamys/repos", "events_url": "https://api.github.com/users/Arthamys/events{/privacy}", "received_events_url": "https://api.github.com/users/Arthamys/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db926218b2082077750291f8426ddd28b284cd08", "url": "https://api.github.com/repos/rust-lang/rust/commits/db926218b2082077750291f8426ddd28b284cd08", "html_url": "https://github.com/rust-lang/rust/commit/db926218b2082077750291f8426ddd28b284cd08"}, {"sha": "59732df8d40dfadc6dcf5951265416576399712a", "url": "https://api.github.com/repos/rust-lang/rust/commits/59732df8d40dfadc6dcf5951265416576399712a", "html_url": "https://github.com/rust-lang/rust/commit/59732df8d40dfadc6dcf5951265416576399712a"}], "stats": {"total": 44740, "additions": 26819, "deletions": 17921}, "files": [{"sha": "29ac895493acde85e249d5828b4456e4ed5a3dc6", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -20,7 +20,7 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     strategy:\n       matrix:\n-        os: [ubuntu-latest, windows-latest, macos-latest]\n+        os: [ubuntu-16.04, windows-latest, macos-latest]\n \n     steps:\n     - name: Checkout repository\n@@ -42,25 +42,25 @@ jobs:\n         override: true\n \n     - name: Install Nodejs\n-      if: matrix.os == 'ubuntu-latest'\n+      if: matrix.os == 'ubuntu-16.04'\n       uses: actions/setup-node@v1\n       with:\n         node-version: 12.x\n \n     - name: Dist\n-      if: matrix.os == 'ubuntu-latest' && github.ref == 'refs/heads/release'\n+      if: matrix.os == 'ubuntu-16.04' && github.ref == 'refs/heads/release'\n       run: cargo xtask dist --client 0.2.$GITHUB_RUN_NUMBER\n \n     - name: Dist\n-      if: matrix.os == 'ubuntu-latest' && github.ref != 'refs/heads/release'\n+      if: matrix.os == 'ubuntu-16.04' && github.ref != 'refs/heads/release'\n       run: cargo xtask dist --nightly --client 0.3.$GITHUB_RUN_NUMBER-nightly\n \n     - name: Dist\n-      if: matrix.os != 'ubuntu-latest'\n+      if: matrix.os != 'ubuntu-16.04'\n       run: cargo xtask dist\n \n     - name: Nightly analysis-stats check\n-      if: matrix.os == 'ubuntu-latest' && github.ref != 'refs/heads/release'\n+      if: matrix.os == 'ubuntu-16.04' && github.ref != 'refs/heads/release'\n       run: ./dist/rust-analyzer-linux analysis-stats .\n \n     - name: Upload artifacts\n@@ -71,7 +71,7 @@ jobs:\n \n   publish:\n     name: publish\n-    runs-on: ubuntu-latest\n+    runs-on: ubuntu-16.04\n     needs: ['dist']\n     steps:\n     - name: Install Nodejs\n@@ -94,7 +94,7 @@ jobs:\n         path: dist\n     - uses: actions/download-artifact@v1\n       with:\n-        name: dist-ubuntu-latest\n+        name: dist-ubuntu-16.04\n         path: dist\n     - uses: actions/download-artifact@v1\n       with:"}, {"sha": "c062366923dd6c2856ff1b5d38414c7bb61be7ca", "filename": "Cargo.lock", "status": "modified", "additions": 114, "deletions": 85, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,5 +1,14 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+[[package]]\n+name = \"addr2line\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a49806b9dadc843c61e7c97e72490ad7f7220ae249012fbda9ad0609457c0543\"\n+dependencies = [\n+ \"gimli\",\n+]\n+\n [[package]]\n name = \"aho-corasick\"\n version = \"0.7.10\"\n@@ -11,9 +20,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.28\"\n+version = \"1.0.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9a60d744a80c30fcb657dfe2c1b22bcb3e814c1a1e3674f32bf5820b570fbff\"\n+checksum = \"85bb70cc08ec97ca5450e6eba421deeea5f172c0fc61f78b5357b2a8e8be195f\"\n \n [[package]]\n name = \"anymap\"\n@@ -46,31 +55,22 @@ checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.46\"\n+version = \"0.3.48\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1e692897359247cc6bb902933361652380af0f1b7651ae5c5013407f30e109e\"\n+checksum = \"0df2f85c8a2abbe3b7d7e748052fdd9b76a0458fdeb16ad4223f5eca78c7c130\"\n dependencies = [\n- \"backtrace-sys\",\n+ \"addr2line\",\n  \"cfg-if\",\n  \"libc\",\n+ \"object\",\n  \"rustc-demangle\",\n ]\n \n-[[package]]\n-name = \"backtrace-sys\"\n-version = \"0.1.37\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18fbebbe1c9d1f383a9cc7e8ccdb471b91c8d024ee9c2ca5b5346121fe8b4399\"\n-dependencies = [\n- \"cc\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"base64\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d5ca2cd0adc3f48f9e9ea5a6bbdf9ccc0bfade884847e484d452414c7ccffb3\"\n+checksum = \"53d1ccbaf7d9ec9537465a97bf19edc1a4e158ecb49fc16178202238c569cc42\"\n \n [[package]]\n name = \"bitflags\"\n@@ -80,18 +80,18 @@ checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n [[package]]\n name = \"bstr\"\n-version = \"0.2.12\"\n+version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2889e6d50f394968c8bf4240dc3f2a7eb4680844d27308f798229ac9d4725f41\"\n+checksum = \"31accafdb70df7871592c058eca3985b71104e15ac32f64706022c58867da931\"\n dependencies = [\n  \"memchr\",\n ]\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.9.1\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"46e3374c604fb39d1a2f35ed5e4a4e30e60d01fab49446e08f1b3e9a90aef202\"\n+checksum = \"b8de60b887edf6d74370fc8eb177040da4847d971d6234c7b13a6da324ef0caf\"\n dependencies = [\n  \"semver\",\n  \"serde\",\n@@ -101,9 +101,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.52\"\n+version = \"1.0.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c3d87b23d6a92cd03af510a5ade527033f6aa6fa92161e2d5863a907d4c5e31d\"\n+checksum = \"404b1fe4f65288577753b17e3b36a04596ee784493ec249bf81c7f2d2acd751c\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -113,8 +113,8 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n+version = \"0.10.1-dev\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=3e9c2503ae9c5277c2acb74624dc267876dd89b3#3e9c2503ae9c5277c2acb74624dc267876dd89b3\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -124,17 +124,17 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n+version = \"0.10.1-dev\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=3e9c2503ae9c5277c2acb74624dc267876dd89b3#3e9c2503ae9c5277c2acb74624dc267876dd89b3\"\n dependencies = [\n  \"chalk-macros\",\n  \"rustc-hash\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n+version = \"0.10.1-dev\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=3e9c2503ae9c5277c2acb74624dc267876dd89b3#3e9c2503ae9c5277c2acb74624dc267876dd89b3\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -143,16 +143,16 @@ dependencies = [\n \n [[package]]\n name = \"chalk-macros\"\n-version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n+version = \"0.10.1-dev\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=3e9c2503ae9c5277c2acb74624dc267876dd89b3#3e9c2503ae9c5277c2acb74624dc267876dd89b3\"\n dependencies = [\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n+version = \"0.10.1-dev\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=3e9c2503ae9c5277c2acb74624dc267876dd89b3#3e9c2503ae9c5277c2acb74624dc267876dd89b3\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -162,8 +162,8 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n+version = \"0.10.1-dev\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=3e9c2503ae9c5277c2acb74624dc267876dd89b3#3e9c2503ae9c5277c2acb74624dc267876dd89b3\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -342,9 +342,9 @@ dependencies = [\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.9\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f59efc38004c988e4201d11d263b8171f49a2e7ec0bdbb71773433f271504a5e\"\n+checksum = \"affc17579b132fc2461adf7c575cc6e8b134ebca52c51f5411388965227dc695\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -360,9 +360,9 @@ checksum = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \n [[package]]\n name = \"fnv\"\n-version = \"1.0.6\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n+checksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n \n [[package]]\n name = \"fs_extra\"\n@@ -422,6 +422,12 @@ dependencies = [\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"gimli\"\n+version = \"0.21.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bcc8e0c9bce37868955864dbecd2b1ab2bdf967e6f28066d65aaac620444b65c\"\n+\n [[package]]\n name = \"globset\"\n version = \"0.4.5\"\n@@ -437,9 +443,9 @@ dependencies = [\n \n [[package]]\n name = \"goblin\"\n-version = \"0.2.1\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ddd5e3132801a1ac34ac53b97acde50c4685414dd2f291b9ea52afa6f07468c8\"\n+checksum = \"d20fd25aa456527ce4f544271ae4fea65d2eda4a6561ea56f39fb3ee4f7e3884\"\n dependencies = [\n  \"log\",\n  \"plain\",\n@@ -457,13 +463,22 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.12\"\n+version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61565ff7aaace3525556587bd2dc31d4a07071957be715e63ce7b1eccf51a8f4\"\n+checksum = \"91780f809e750b0a89f5544be56617ff6b1227ee485bcb06ebe10cdf89bd3b71\"\n dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"home\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2456aef2e6b6a9784192ae780c0f15bc57df0e918585282325e8c8ac27737654\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"idna\"\n version = \"0.2.0\"\n@@ -604,24 +619,24 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.69\"\n+version = \"0.2.70\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005\"\n+checksum = \"3baa92041a6fec78c687fa0cc2b3fae8884f743d672cf551bed1d6dac6988d0f\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.1\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3c4f51b790f5bdb65acb4cc94bb81d7b2ee60348a5431ac1467d390b017600b0\"\n+checksum = \"2cadb8e769f070c45df05c78c7520eb4cd17061d4ab262e43cfc68b4d00ac71c\"\n dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"linked-hash-map\"\n-version = \"0.5.2\"\n+version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n+checksum = \"8dd5a6d5999d9907cda8ed67bbd137d3af8085216c2ac62de5be860bd41f304a\"\n \n [[package]]\n name = \"lock_api\"\n@@ -655,9 +670,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.74.0\"\n+version = \"0.74.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"820f746e5716ab9a2d664794636188bd003023b72e55404ee27105dc22869922\"\n+checksum = \"57c0e6a2b8837d27b29deb3f3e6dc1c6d2f57947677f9be1024e482ec5b59525\"\n dependencies = [\n  \"base64\",\n  \"bitflags\",\n@@ -706,9 +721,9 @@ dependencies = [\n \n [[package]]\n name = \"mio\"\n-version = \"0.6.21\"\n+version = \"0.6.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"302dec22bcf6bae6dfb69c647187f4b4d0fb6f535521f7bc022430ce8e12008f\"\n+checksum = \"fce347092656428bc8eaf6201042cb551b8d67855af7374542a92a0fbfcac430\"\n dependencies = [\n  \"cfg-if\",\n  \"fuchsia-zircon\",\n@@ -749,9 +764,9 @@ dependencies = [\n \n [[package]]\n name = \"net2\"\n-version = \"0.2.33\"\n+version = \"0.2.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88\"\n+checksum = \"2ba7c918ac76704fb42afcbbb43891e72731f3dcca3bef2a19786297baf14af7\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -786,11 +801,17 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.19.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9cbca9424c482ee628fa549d9c812e2cd22f1180b9222c9200fdfa6eb31aecb2\"\n+\n [[package]]\n name = \"once_cell\"\n-version = \"1.3.1\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1c601810575c99596d4afc46f78a678c80105117c379eb3650cf99b8a21ce5b\"\n+checksum = \"0b631f7e854af39a1739f401cf34a8a013dfe09eac4fa4dba91e9768bd28168d\"\n \n [[package]]\n name = \"ordermap\"\n@@ -824,19 +845,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3c897744f63f34f7ae3a024d9162bb5001f4ad661dd24bea0dc9f075d2de1c6\"\n+checksum = \"0a229b1c58c692edcaa5b9b0948084f130f55d2dcc15b02fcc5340b2b4521476\"\n dependencies = [\n  \"paste-impl\",\n  \"proc-macro-hack\",\n ]\n \n [[package]]\n name = \"paste-impl\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"66fd6f92e3594f2dd7b3fc23e42d82e292f7bcda6d8e5dcd167072327234ab89\"\n+checksum = \"2e0bf239e447e67ff6d16a8bb5e4d4bd2343acf5066061c0e8e06ac5ba8ca68c\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"proc-macro2\",\n@@ -874,9 +895,9 @@ checksum = \"b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6\"\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.6\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"74490b50b9fbe561ac330df47c08f3f33073d2d00c150f719147d7c54522fa1b\"\n+checksum = \"237a5ed80e274dbc66f86bd59c1e25edc039660be53194b5fe0a482e0f2612ea\"\n \n [[package]]\n name = \"proc-macro-hack\"\n@@ -886,18 +907,18 @@ checksum = \"0d659fe7c6d27f25e9d80a1a094c223f5246f6a6596453e09d7229bf42750b63\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.10\"\n+version = \"1.0.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df246d292ff63439fea9bc8c0a270bed0e390d5ebd4db4ba15aba81111b5abe3\"\n+checksum = \"53f5ffe53a6b28e37c9c1ce74893477864d64f74778a93a4beb43c8fa167f639\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.4\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c1f4b0efa5fc5e8ceb705136bfee52cfdb6a4e3509f770b478cd6ed434232a7\"\n+checksum = \"54a21852a652ad6f610c9510194f398ff6f8692e334fd1145fed931f7fbe44ea\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -954,10 +975,9 @@ version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"crossbeam-channel\",\n- \"insta\",\n  \"jod-thread\",\n  \"log\",\n- \"lsp-types\",\n+ \"ra_toolchain\",\n  \"serde_json\",\n ]\n \n@@ -1163,6 +1183,7 @@ dependencies = [\n  \"ra_cfg\",\n  \"ra_db\",\n  \"ra_proc_macro\",\n+ \"ra_toolchain\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n@@ -1194,6 +1215,13 @@ dependencies = [\n  \"text-size\",\n ]\n \n+[[package]]\n+name = \"ra_toolchain\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"home\",\n+]\n+\n [[package]]\n name = \"ra_tt\"\n version = \"0.1.0\"\n@@ -1203,9 +1231,9 @@ dependencies = [\n \n [[package]]\n name = \"ra_vfs\"\n-version = \"0.6.0\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fcaa5615f420134aea7667253db101d03a5c5f300eac607872dc2a36407b2ac9\"\n+checksum = \"cbf31a173fc77ec59c27cf39af6baa137b40f4dbd45a8b3eccb1b2e4cfc922c1\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n@@ -1351,6 +1379,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"env_logger\",\n  \"globset\",\n+ \"insta\",\n  \"itertools\",\n  \"jod-thread\",\n  \"log\",\n@@ -1469,9 +1498,9 @@ dependencies = [\n \n [[package]]\n name = \"scroll_derive\"\n-version = \"0.10.1\"\n+version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f8584eea9b9ff42825b46faf46a8c24d2cff13ec152fa2a50df788b87c07ee28\"\n+checksum = \"e367622f934864ffa1c704ba2b82280aab856e3d8213c84c5720257eb34b15b9\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1496,18 +1525,18 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.106\"\n+version = \"1.0.110\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"36df6ac6412072f67cf767ebbde4133a5b2e88e76dc6187fa7104cd16f783399\"\n+checksum = \"99e7b308464d16b56eba9964e4972a3eee817760ab60d88c3f86e1fecb08204c\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.106\"\n+version = \"1.0.110\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n+checksum = \"818fbf6bfa9a42d3bfcaca148547aa00c7b915bec71d1757aa2d44ca68771984\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1516,9 +1545,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.52\"\n+version = \"1.0.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7894c8ed05b7a3a279aeb79025fdec1d3158080b75b98a08faf2806bb799edd\"\n+checksum = \"993948e75b189211a9b31a7528f950c6adc21f9720b6438ff80a7fa2f864cea2\"\n dependencies = [\n  \"itoa\",\n  \"ryu\",\n@@ -1538,9 +1567,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_yaml\"\n-version = \"0.8.11\"\n+version = \"0.8.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"691b17f19fc1ec9d94ec0b5864859290dff279dbd7b03f017afda54eb36c3c35\"\n+checksum = \"16c7a592a1ec97c9c1c68d75b6e537dcbf60c7618e038e7841e00af1d9ccf0c4\"\n dependencies = [\n  \"dtoa\",\n  \"linked-hash-map\",\n@@ -1581,9 +1610,9 @@ checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.18\"\n+version = \"1.0.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"410a7488c0a728c7ceb4ad59b9567eb4053d02e8cc7f5c0e0eeeb39518369213\"\n+checksum = \"1425de3c33b0941002740a420b1a906a350b88d08b82b2c8a01035a3f9447bac\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1667,9 +1696,9 @@ dependencies = [\n \n [[package]]\n name = \"threadpool\"\n-version = \"1.8.0\"\n+version = \"1.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e8dae184447c15d5a6916d973c642aec485105a13cd238192a6927ae3e077d66\"\n+checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n dependencies = [\n  \"num_cpus\",\n ]"}, {"sha": "c0a0226fb247bb4aa96a57d501556ccfe32ae219", "filename": "crates/ra_assists/src/assist_config.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_config.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,27 @@\n+//! Settings for tweaking assists.\n+//!\n+//! The fun thing here is `SnippetCap` -- this type can only be created in this\n+//! module, and we use to statically check that we only produce snippet\n+//! assists if we are allowed to.\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct AssistConfig {\n+    pub snippet_cap: Option<SnippetCap>,\n+}\n+\n+impl AssistConfig {\n+    pub fn allow_snippets(&mut self, yes: bool) {\n+        self.snippet_cap = if yes { Some(SnippetCap { _private: () }) } else { None }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub struct SnippetCap {\n+    _private: (),\n+}\n+\n+impl Default for AssistConfig {\n+    fn default() -> Self {\n+        AssistConfig { snippet_cap: Some(SnippetCap { _private: () }) }\n+    }\n+}"}, {"sha": "f3af70a3ec9e7d21f46a099f287de236e1b6e6ea", "filename": "crates/ra_assists/src/assist_context.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,257 @@\n+//! See `AssistContext`\n+\n+use algo::find_covering_element;\n+use hir::Semantics;\n+use ra_db::{FileId, FileRange};\n+use ra_fmt::{leading_indent, reindent};\n+use ra_ide_db::{\n+    source_change::{SingleFileChange, SourceChange},\n+    RootDatabase,\n+};\n+use ra_syntax::{\n+    algo::{self, find_node_at_offset, SyntaxRewriter},\n+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    TokenAtOffset,\n+};\n+use ra_text_edit::TextEditBuilder;\n+\n+use crate::{\n+    assist_config::{AssistConfig, SnippetCap},\n+    Assist, AssistId, GroupLabel, ResolvedAssist,\n+};\n+\n+/// `AssistContext` allows to apply an assist or check if it could be applied.\n+///\n+/// Assists use a somewhat over-engineered approach, given the current needs.\n+/// The assists workflow consists of two phases. In the first phase, a user asks\n+/// for the list of available assists. In the second phase, the user picks a\n+/// particular assist and it gets applied.\n+///\n+/// There are two peculiarities here:\n+///\n+/// * first, we ideally avoid computing more things then necessary to answer \"is\n+///   assist applicable\" in the first phase.\n+/// * second, when we are applying assist, we don't have a guarantee that there\n+///   weren't any changes between the point when user asked for assists and when\n+///   they applied a particular assist. So, when applying assist, we need to do\n+///   all the checks from scratch.\n+///\n+/// To avoid repeating the same code twice for both \"check\" and \"apply\"\n+/// functions, we use an approach reminiscent of that of Django's function based\n+/// views dealing with forms. Each assist receives a runtime parameter,\n+/// `resolve`. It first check if an edit is applicable (potentially computing\n+/// info required to compute the actual edit). If it is applicable, and\n+/// `resolve` is `true`, it then computes the actual edit.\n+///\n+/// So, to implement the original assists workflow, we can first apply each edit\n+/// with `resolve = false`, and then applying the selected edit again, with\n+/// `resolve = true` this time.\n+///\n+/// Note, however, that we don't actually use such two-phase logic at the\n+/// moment, because the LSP API is pretty awkward in this place, and it's much\n+/// easier to just compute the edit eagerly :-)\n+pub(crate) struct AssistContext<'a> {\n+    pub(crate) config: &'a AssistConfig,\n+    pub(crate) sema: Semantics<'a, RootDatabase>,\n+    pub(crate) db: &'a RootDatabase,\n+    pub(crate) frange: FileRange,\n+    source_file: SourceFile,\n+}\n+\n+impl<'a> AssistContext<'a> {\n+    pub(crate) fn new(\n+        sema: Semantics<'a, RootDatabase>,\n+        config: &'a AssistConfig,\n+        frange: FileRange,\n+    ) -> AssistContext<'a> {\n+        let source_file = sema.parse(frange.file_id);\n+        let db = sema.db;\n+        AssistContext { config, sema, db, frange, source_file }\n+    }\n+\n+    // NB, this ignores active selection.\n+    pub(crate) fn offset(&self) -> TextSize {\n+        self.frange.range.start()\n+    }\n+\n+    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n+        self.source_file.syntax().token_at_offset(self.offset())\n+    }\n+    pub(crate) fn find_token_at_offset(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n+        self.token_at_offset().find(|it| it.kind() == kind)\n+    }\n+    pub(crate) fn find_node_at_offset<N: AstNode>(&self) -> Option<N> {\n+        find_node_at_offset(self.source_file.syntax(), self.offset())\n+    }\n+    pub(crate) fn find_node_at_offset_with_descend<N: AstNode>(&self) -> Option<N> {\n+        self.sema.find_node_at_offset_with_descend(self.source_file.syntax(), self.offset())\n+    }\n+    pub(crate) fn covering_element(&self) -> SyntaxElement {\n+        find_covering_element(self.source_file.syntax(), self.frange.range)\n+    }\n+    // FIXME: remove\n+    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n+        find_covering_element(self.source_file.syntax(), range)\n+    }\n+}\n+\n+pub(crate) struct Assists {\n+    resolve: bool,\n+    file: FileId,\n+    buf: Vec<(Assist, Option<SourceChange>)>,\n+}\n+\n+impl Assists {\n+    pub(crate) fn new_resolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: true, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+    pub(crate) fn new_unresolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: false, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+\n+    pub(crate) fn finish_unresolved(self) -> Vec<Assist> {\n+        assert!(!self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| {\n+                assert!(edit.is_none());\n+                label\n+            })\n+            .collect()\n+    }\n+\n+    pub(crate) fn finish_resolved(self) -> Vec<ResolvedAssist> {\n+        assert!(self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| ResolvedAssist { assist: label, source_change: edit.unwrap() })\n+            .collect()\n+    }\n+\n+    pub(crate) fn add(\n+        &mut self,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), None, target);\n+        self.add_impl(label, f)\n+    }\n+    pub(crate) fn add_group(\n+        &mut self,\n+        group: &GroupLabel,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), Some(group.clone()), target);\n+        self.add_impl(label, f)\n+    }\n+    fn add_impl(&mut self, label: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n+        let change_label = label.label.clone();\n+        let source_change = if self.resolve {\n+            let mut builder = AssistBuilder::new(self.file);\n+            f(&mut builder);\n+            Some(builder.finish(change_label))\n+        } else {\n+            None\n+        };\n+\n+        self.buf.push((label, source_change));\n+        Some(())\n+    }\n+\n+    fn finish(mut self) -> Vec<(Assist, Option<SourceChange>)> {\n+        self.buf.sort_by_key(|(label, _edit)| label.target.len());\n+        self.buf\n+    }\n+}\n+\n+pub(crate) struct AssistBuilder {\n+    edit: TextEditBuilder,\n+    file: FileId,\n+    is_snippet: bool,\n+}\n+\n+impl AssistBuilder {\n+    pub(crate) fn new(file: FileId) -> AssistBuilder {\n+        AssistBuilder { edit: TextEditBuilder::default(), file, is_snippet: false }\n+    }\n+\n+    /// Remove specified `range` of text.\n+    pub(crate) fn delete(&mut self, range: TextRange) {\n+        self.edit.delete(range)\n+    }\n+    /// Append specified `text` at the given `offset`\n+    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n+        self.edit.insert(offset, text.into())\n+    }\n+    /// Append specified `snippet` at the given `offset`\n+    pub(crate) fn insert_snippet(\n+        &mut self,\n+        _cap: SnippetCap,\n+        offset: TextSize,\n+        snippet: impl Into<String>,\n+    ) {\n+        self.is_snippet = true;\n+        self.insert(offset, snippet);\n+    }\n+    /// Replaces specified `range` of text with a given string.\n+    pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n+        self.edit.replace(range, replace_with.into())\n+    }\n+    /// Replaces specified `range` of text with a given `snippet`.\n+    pub(crate) fn replace_snippet(\n+        &mut self,\n+        _cap: SnippetCap,\n+        range: TextRange,\n+        snippet: impl Into<String>,\n+    ) {\n+        self.is_snippet = true;\n+        self.replace(range, snippet);\n+    }\n+    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n+        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n+    }\n+    /// Replaces specified `node` of text with a given string, reindenting the\n+    /// string to maintain `node`'s existing indent.\n+    // FIXME: remove in favor of ra_syntax::edit::IndentLevel::increase_indent\n+    pub(crate) fn replace_node_and_indent(\n+        &mut self,\n+        node: &SyntaxNode,\n+        replace_with: impl Into<String>,\n+    ) {\n+        let mut replace_with = replace_with.into();\n+        if let Some(indent) = leading_indent(node) {\n+            replace_with = reindent(&replace_with, &indent)\n+        }\n+        self.replace(node.text_range(), replace_with)\n+    }\n+    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n+        let node = rewriter.rewrite_root().unwrap();\n+        let new = rewriter.rewrite(&node);\n+        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n+    }\n+\n+    // FIXME: better API\n+    pub(crate) fn set_file(&mut self, assist_file: FileId) {\n+        self.file = assist_file;\n+    }\n+\n+    // FIXME: kill this API\n+    /// Get access to the raw `TextEditBuilder`.\n+    pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n+        &mut self.edit\n+    }\n+\n+    fn finish(self, change_label: String) -> SourceChange {\n+        let edit = self.edit.finish();\n+        let mut res = SingleFileChange { label: change_label, edit }.into_source_change(self.file);\n+        if self.is_snippet {\n+            res.is_snippet = true;\n+        }\n+        res\n+    }\n+}"}, {"sha": "2fe7c3de3d1424ae5fe927d4b7efde645fe2ea2c", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,257 +0,0 @@\n-//! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n-use hir::Semantics;\n-use ra_db::FileRange;\n-use ra_fmt::{leading_indent, reindent};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    algo::{self, find_covering_element, find_node_at_offset},\n-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n-    TokenAtOffset,\n-};\n-use ra_text_edit::TextEditBuilder;\n-\n-use crate::{AssistAction, AssistFile, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n-use algo::SyntaxRewriter;\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct AssistInfo {\n-    pub(crate) label: AssistLabel,\n-    pub(crate) group_label: Option<GroupLabel>,\n-    pub(crate) action: Option<AssistAction>,\n-}\n-\n-impl AssistInfo {\n-    fn new(label: AssistLabel) -> AssistInfo {\n-        AssistInfo { label, group_label: None, action: None }\n-    }\n-\n-    fn resolved(self, action: AssistAction) -> AssistInfo {\n-        AssistInfo { action: Some(action), ..self }\n-    }\n-\n-    fn with_group(self, group_label: GroupLabel) -> AssistInfo {\n-        AssistInfo { group_label: Some(group_label), ..self }\n-    }\n-\n-    pub(crate) fn into_resolved(self) -> Option<ResolvedAssist> {\n-        let label = self.label;\n-        let group_label = self.group_label;\n-        self.action.map(|action| ResolvedAssist { label, group_label, action })\n-    }\n-}\n-\n-pub(crate) type AssistHandler = fn(AssistCtx) -> Option<Assist>;\n-\n-/// `AssistCtx` allows to apply an assist or check if it could be applied.\n-///\n-/// Assists use a somewhat over-engineered approach, given the current needs. The\n-/// assists workflow consists of two phases. In the first phase, a user asks for\n-/// the list of available assists. In the second phase, the user picks a\n-/// particular assist and it gets applied.\n-///\n-/// There are two peculiarities here:\n-///\n-/// * first, we ideally avoid computing more things then necessary to answer\n-///   \"is assist applicable\" in the first phase.\n-/// * second, when we are applying assist, we don't have a guarantee that there\n-///   weren't any changes between the point when user asked for assists and when\n-///   they applied a particular assist. So, when applying assist, we need to do\n-///   all the checks from scratch.\n-///\n-/// To avoid repeating the same code twice for both \"check\" and \"apply\"\n-/// functions, we use an approach reminiscent of that of Django's function based\n-/// views dealing with forms. Each assist receives a runtime parameter,\n-/// `should_compute_edit`. It first check if an edit is applicable (potentially\n-/// computing info required to compute the actual edit). If it is applicable,\n-/// and `should_compute_edit` is `true`, it then computes the actual edit.\n-///\n-/// So, to implement the original assists workflow, we can first apply each edit\n-/// with `should_compute_edit = false`, and then applying the selected edit\n-/// again, with `should_compute_edit = true` this time.\n-///\n-/// Note, however, that we don't actually use such two-phase logic at the\n-/// moment, because the LSP API is pretty awkward in this place, and it's much\n-/// easier to just compute the edit eagerly :-)\n-#[derive(Clone)]\n-pub(crate) struct AssistCtx<'a> {\n-    pub(crate) sema: &'a Semantics<'a, RootDatabase>,\n-    pub(crate) db: &'a RootDatabase,\n-    pub(crate) frange: FileRange,\n-    source_file: SourceFile,\n-    should_compute_edit: bool,\n-}\n-\n-impl<'a> AssistCtx<'a> {\n-    pub fn new(\n-        sema: &'a Semantics<'a, RootDatabase>,\n-        frange: FileRange,\n-        should_compute_edit: bool,\n-    ) -> AssistCtx<'a> {\n-        let source_file = sema.parse(frange.file_id);\n-        AssistCtx { sema, db: sema.db, frange, source_file, should_compute_edit }\n-    }\n-\n-    pub(crate) fn add_assist(\n-        self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) -> Option<Assist> {\n-        let label = AssistLabel::new(label.into(), id);\n-\n-        let mut info = AssistInfo::new(label);\n-        if self.should_compute_edit {\n-            let action = {\n-                let mut edit = ActionBuilder::default();\n-                f(&mut edit);\n-                edit.build()\n-            };\n-            info = info.resolved(action)\n-        };\n-\n-        Some(Assist(vec![info]))\n-    }\n-\n-    pub(crate) fn add_assist_group(self, group_name: impl Into<String>) -> AssistGroup<'a> {\n-        AssistGroup { ctx: self, group_name: group_name.into(), assists: Vec::new() }\n-    }\n-\n-    pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n-        self.source_file.syntax().token_at_offset(self.frange.range.start())\n-    }\n-\n-    pub(crate) fn find_token_at_offset(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n-        self.token_at_offset().find(|it| it.kind() == kind)\n-    }\n-\n-    pub(crate) fn find_node_at_offset<N: AstNode>(&self) -> Option<N> {\n-        find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n-    }\n-    pub(crate) fn covering_element(&self) -> SyntaxElement {\n-        find_covering_element(self.source_file.syntax(), self.frange.range)\n-    }\n-    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n-        find_covering_element(self.source_file.syntax(), range)\n-    }\n-}\n-\n-pub(crate) struct AssistGroup<'a> {\n-    ctx: AssistCtx<'a>,\n-    group_name: String,\n-    assists: Vec<AssistInfo>,\n-}\n-\n-impl<'a> AssistGroup<'a> {\n-    pub(crate) fn add_assist(\n-        &mut self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) {\n-        let label = AssistLabel::new(label.into(), id);\n-\n-        let mut info = AssistInfo::new(label).with_group(GroupLabel(self.group_name.clone()));\n-        if self.ctx.should_compute_edit {\n-            let action = {\n-                let mut edit = ActionBuilder::default();\n-                f(&mut edit);\n-                edit.build()\n-            };\n-            info = info.resolved(action)\n-        };\n-\n-        self.assists.push(info)\n-    }\n-\n-    pub(crate) fn finish(self) -> Option<Assist> {\n-        if self.assists.is_empty() {\n-            None\n-        } else {\n-            Some(Assist(self.assists))\n-        }\n-    }\n-}\n-\n-#[derive(Default)]\n-pub(crate) struct ActionBuilder {\n-    edit: TextEditBuilder,\n-    cursor_position: Option<TextSize>,\n-    target: Option<TextRange>,\n-    file: AssistFile,\n-}\n-\n-impl ActionBuilder {\n-    /// Replaces specified `range` of text with a given string.\n-    pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n-        self.edit.replace(range, replace_with.into())\n-    }\n-\n-    /// Replaces specified `node` of text with a given string, reindenting the\n-    /// string to maintain `node`'s existing indent.\n-    // FIXME: remove in favor of ra_syntax::edit::IndentLevel::increase_indent\n-    pub(crate) fn replace_node_and_indent(\n-        &mut self,\n-        node: &SyntaxNode,\n-        replace_with: impl Into<String>,\n-    ) {\n-        let mut replace_with = replace_with.into();\n-        if let Some(indent) = leading_indent(node) {\n-            replace_with = reindent(&replace_with, &indent)\n-        }\n-        self.replace(node.text_range(), replace_with)\n-    }\n-\n-    /// Remove specified `range` of text.\n-    #[allow(unused)]\n-    pub(crate) fn delete(&mut self, range: TextRange) {\n-        self.edit.delete(range)\n-    }\n-\n-    /// Append specified `text` at the given `offset`\n-    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n-        self.edit.insert(offset, text.into())\n-    }\n-\n-    /// Specify desired position of the cursor after the assist is applied.\n-    pub(crate) fn set_cursor(&mut self, offset: TextSize) {\n-        self.cursor_position = Some(offset)\n-    }\n-\n-    /// Specify that the assist should be active withing the `target` range.\n-    ///\n-    /// Target ranges are used to sort assists: the smaller the target range,\n-    /// the more specific assist is, and so it should be sorted first.\n-    pub(crate) fn target(&mut self, target: TextRange) {\n-        self.target = Some(target)\n-    }\n-\n-    /// Get access to the raw `TextEditBuilder`.\n-    pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n-        &mut self.edit\n-    }\n-\n-    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n-        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n-    }\n-    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n-        let node = rewriter.rewrite_root().unwrap();\n-        let new = rewriter.rewrite(&node);\n-        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n-    }\n-\n-    pub(crate) fn set_file(&mut self, assist_file: AssistFile) {\n-        self.file = assist_file\n-    }\n-\n-    fn build(self) -> AssistAction {\n-        AssistAction {\n-            edit: self.edit.finish(),\n-            cursor_position: self.cursor_position,\n-            target: self.target,\n-            file: self.file,\n-        }\n-    }\n-}"}, {"sha": "3079a02a2d89e42f40e1d4bec41ce11abb26859f", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,7 +1,7 @@\n //! `AstTransformer`s are functions that replace nodes in an AST and can be easily combined.\n use rustc_hash::FxHashMap;\n \n-use hir::{PathResolution, SemanticsScope};\n+use hir::{HirDisplay, PathResolution, SemanticsScope};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::SyntaxRewriter,\n@@ -51,7 +51,27 @@ impl<'a> SubstituteTypeParams<'a> {\n             .into_iter()\n             // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n             .skip(1)\n-            .zip(substs.into_iter())\n+            // The actual list of trait type parameters may be longer than the one\n+            // used in the `impl` block due to trailing default type parametrs.\n+            // For that case we extend the `substs` with an empty iterator so we\n+            // can still hit those trailing values and check if they actually have\n+            // a default type. If they do, go for that type from `hir` to `ast` so\n+            // the resulting change can be applied correctly.\n+            .zip(substs.into_iter().map(Some).chain(std::iter::repeat(None)))\n+            .filter_map(|(k, v)| match v {\n+                Some(v) => Some((k, v)),\n+                None => {\n+                    let default = k.default(source_scope.db)?;\n+                    Some((\n+                        k,\n+                        ast::make::type_ref(\n+                            &default\n+                                .display_source_code(source_scope.db, source_scope.module()?.into())\n+                                .ok()?,\n+                        ),\n+                    ))\n+                }\n+            })\n             .collect();\n         return SubstituteTypeParams {\n             source_scope,"}, {"sha": "c0f9bc1fbe75e25bf04dbc0a44c23f326cef52cc", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,35 +0,0 @@\n-//! Each assist definition has a special comment, which specifies docs and\n-//! example.\n-//!\n-//! We collect all the example and write the as tests in this module.\n-\n-mod generated;\n-\n-use ra_db::FileRange;\n-use test_utils::{assert_eq_text, extract_range_or_offset};\n-\n-use crate::resolved_assists;\n-\n-fn check(assist_id: &str, before: &str, after: &str) {\n-    let (selection, before) = extract_range_or_offset(before);\n-    let (db, file_id) = crate::helpers::with_single_file(&before);\n-    let frange = FileRange { file_id, range: selection.into() };\n-\n-    let assist = resolved_assists(&db, frange)\n-        .into_iter()\n-        .find(|assist| assist.label.id.0 == assist_id)\n-        .unwrap_or_else(|| {\n-            panic!(\n-                \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n-                assist_id,\n-                resolved_assists(&db, frange)\n-                    .into_iter()\n-                    .map(|assist| assist.label.id.0)\n-                    .collect::<Vec<_>>()\n-                    .join(\", \")\n-            )\n-        });\n-\n-    let actual = assist.action.edit.apply(&before);\n-    assert_eq_text!(after, &actual);\n-}"}, {"sha": "fa70c849684a625b70989b0684358911f664ba0c", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n };\n use stdx::SepBy;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: add_custom_impl\n //\n@@ -22,10 +25,10 @@ use crate::{Assist, AssistCtx, AssistId};\n // struct S;\n //\n // impl Debug for S {\n-//\n+//     $0\n // }\n // ```\n-pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let input = ctx.find_node_at_offset::<ast::AttrInput>()?;\n     let attr = input.syntax().parent().and_then(ast::Attr::cast)?;\n \n@@ -46,11 +49,10 @@ pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n     let start_offset = annotated.syntax().parent()?.text_range().end();\n \n     let label =\n-        format!(\"Add custom impl '{}' for '{}'\", trait_token.text().as_str(), annotated_name);\n-\n-    ctx.add_assist(AssistId(\"add_custom_impl\"), label, |edit| {\n-        edit.target(attr.syntax().text_range());\n+        format!(\"Add custom impl `{}` for `{}`\", trait_token.text().as_str(), annotated_name);\n \n+    let target = attr.syntax().text_range();\n+    acc.add(AssistId(\"add_custom_impl\"), label, target, |builder| {\n         let new_attr_input = input\n             .syntax()\n             .descendants_with_tokens()\n@@ -61,41 +63,42 @@ pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n         let has_more_derives = !new_attr_input.is_empty();\n         let new_attr_input = new_attr_input.iter().sep_by(\", \").surround_with(\"(\", \")\").to_string();\n \n-        let mut buf = String::new();\n-        buf.push_str(\"\\n\\nimpl \");\n-        buf.push_str(trait_token.text().as_str());\n-        buf.push_str(\" for \");\n-        buf.push_str(annotated_name.as_str());\n-        buf.push_str(\" {\\n\");\n-\n-        let cursor_delta = if has_more_derives {\n-            let delta = input.syntax().text_range().len() - TextSize::of(&new_attr_input);\n-            edit.replace(input.syntax().text_range(), new_attr_input);\n-            delta\n+        if has_more_derives {\n+            builder.replace(input.syntax().text_range(), new_attr_input);\n         } else {\n             let attr_range = attr.syntax().text_range();\n-            edit.delete(attr_range);\n+            builder.delete(attr_range);\n \n             let line_break_range = attr\n                 .syntax()\n                 .next_sibling_or_token()\n                 .filter(|t| t.kind() == WHITESPACE)\n                 .map(|t| t.text_range())\n                 .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n-            edit.delete(line_break_range);\n-\n-            attr_range.len() + line_break_range.len()\n-        };\n-\n-        edit.set_cursor(start_offset + TextSize::of(&buf) - cursor_delta);\n-        buf.push_str(\"\\n}\");\n-        edit.insert(start_offset, buf);\n+            builder.delete(line_break_range);\n+        }\n+\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                builder.insert_snippet(\n+                    cap,\n+                    start_offset,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_token, annotated_name),\n+                );\n+            }\n+            None => {\n+                builder.insert(\n+                    start_offset,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_token, annotated_name),\n+                );\n+            }\n+        }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -115,7 +118,7 @@ struct Foo {\n }\n \n impl Debug for Foo {\n-<|>\n+    $0\n }\n             \",\n         )\n@@ -137,7 +140,7 @@ pub struct Foo {\n }\n \n impl Debug for Foo {\n-<|>\n+    $0\n }\n             \",\n         )\n@@ -156,7 +159,7 @@ struct Foo {}\n struct Foo {}\n \n impl Debug for Foo {\n-<|>\n+    $0\n }\n             \",\n         )"}, {"sha": "b123b84988cf4e730a9a68b1488b69ddc16463dd", "filename": "crates/ra_assists/src/handlers/add_derive.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_derive\n //\n@@ -18,31 +18,37 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // ->\n // ```\n-// #[derive()]\n+// #[derive($0)]\n // struct Point {\n //     x: u32,\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let cap = ctx.config.snippet_cap?;\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n-    ctx.add_assist(AssistId(\"add_derive\"), \"Add `#[derive]`\", |edit| {\n+    let target = nominal.syntax().text_range();\n+    acc.add(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |builder| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_simple_call())\n             .filter(|(name, _arg)| name == \"derive\")\n             .map(|(_name, arg)| arg)\n             .next();\n-        let offset = match derive_attr {\n+        match derive_attr {\n             None => {\n-                edit.insert(node_start, \"#[derive()]\\n\");\n-                node_start + TextSize::of(\"#[derive(\")\n+                builder.insert_snippet(cap, node_start, \"#[derive($0)]\\n\");\n+            }\n+            Some(tt) => {\n+                // Just move the cursor.\n+                builder.insert_snippet(\n+                    cap,\n+                    tt.syntax().text_range().end() - TextSize::of(')'),\n+                    \"$0\",\n+                )\n             }\n-            Some(tt) => tt.syntax().text_range().end() - TextSize::of(')'),\n         };\n-        edit.target(nominal.syntax().text_range());\n-        edit.set_cursor(offset)\n     })\n }\n \n@@ -57,20 +63,21 @@ fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextSize> {\n \n #[cfg(test)]\n mod tests {\n+    use crate::tests::{check_assist, check_assist_target};\n+\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn add_derive_new() {\n         check_assist(\n             add_derive,\n             \"struct Foo { a: i32, <|>}\",\n-            \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n+            \"#[derive($0)]\\nstruct Foo { a: i32, }\",\n         );\n         check_assist(\n             add_derive,\n             \"struct Foo { <|> a: i32, }\",\n-            \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n+            \"#[derive($0)]\\nstruct Foo {  a: i32, }\",\n         );\n     }\n \n@@ -79,7 +86,7 @@ mod tests {\n         check_assist(\n             add_derive,\n             \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n-            \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\",\n+            \"#[derive(Clone$0)]\\nstruct Foo { a: i32, }\",\n         );\n     }\n \n@@ -95,7 +102,7 @@ struct Foo { a: i32<|>, }\n             \"\n /// `Foo` is a pretty important struct.\n /// It does stuff.\n-#[derive(<|>)]\n+#[derive($0)]\n struct Foo { a: i32, }\n             \",\n         );"}, {"sha": "ab20c66493c1b5213ac36d4cfe616dd30e013d86", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_explicit_type\n //\n@@ -21,12 +21,12 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let x: i32 = 92;\n // }\n // ```\n-pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n+    let module = ctx.sema.scope(stmt.syntax()).module()?;\n     let expr = stmt.initializer()?;\n-    let pat = stmt.pat()?;\n     // Must be a binding\n-    let pat = match pat {\n+    let pat = match stmt.pat()? {\n         ast::Pat::BindPat(bind_pat) => bind_pat,\n         _ => return None,\n     };\n@@ -45,7 +45,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n     // Assist not applicable if the type has already been specified\n     // and it has no placeholders\n     let ascribed_ty = stmt.ascribed_type();\n-    if let Some(ref ty) = ascribed_ty {\n+    if let Some(ty) = &ascribed_ty {\n         if ty.syntax().descendants().find_map(ast::PlaceholderType::cast).is_none() {\n             return None;\n         }\n@@ -57,17 +57,17 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    let db = ctx.db;\n-    let new_type_string = ty.display_truncated(db, None).to_string();\n-    ctx.add_assist(\n+    let inferred_type = ty.display_source_code(ctx.db, module.into()).ok()?;\n+    acc.add(\n         AssistId(\"add_explicit_type\"),\n-        format!(\"Insert explicit type '{}'\", new_type_string),\n-        |edit| {\n-            edit.target(pat_range);\n-            if let Some(ascribed_ty) = ascribed_ty {\n-                edit.replace(ascribed_ty.syntax().text_range(), new_type_string);\n-            } else {\n-                edit.insert(name_range.end(), format!(\": {}\", new_type_string));\n+        format!(\"Insert explicit type `{}`\", inferred_type),\n+        pat_range,\n+        |builder| match ascribed_ty {\n+            Some(ascribed_ty) => {\n+                builder.replace(ascribed_ty.syntax().text_range(), inferred_type);\n+            }\n+            None => {\n+                builder.insert(name_range.end(), format!(\": {}\", inferred_type));\n             }\n         },\n     )\n@@ -77,7 +77,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn add_explicit_type_target() {\n@@ -86,19 +86,15 @@ mod tests {\n \n     #[test]\n     fn add_explicit_type_works_for_simple_expr() {\n-        check_assist(\n-            add_explicit_type,\n-            \"fn f() { let a<|> = 1; }\",\n-            \"fn f() { let a<|>: i32 = 1; }\",\n-        );\n+        check_assist(add_explicit_type, \"fn f() { let a<|> = 1; }\", \"fn f() { let a: i32 = 1; }\");\n     }\n \n     #[test]\n     fn add_explicit_type_works_for_underscore() {\n         check_assist(\n             add_explicit_type,\n             \"fn f() { let a<|>: _ = 1; }\",\n-            \"fn f() { let a<|>: i32 = 1; }\",\n+            \"fn f() { let a: i32 = 1; }\",\n         );\n     }\n \n@@ -122,7 +118,7 @@ mod tests {\n             }\n \n             fn f() {\n-                let a<|>: Option<i32> = Option::Some(1);\n+                let a: Option<i32> = Option::Some(1);\n             }\"#,\n         );\n     }\n@@ -132,16 +128,16 @@ mod tests {\n         check_assist(\n             add_explicit_type,\n             r\"macro_rules! v { () => {0u64} } fn f() { let a<|> = v!(); }\",\n-            r\"macro_rules! v { () => {0u64} } fn f() { let a<|>: u64 = v!(); }\",\n+            r\"macro_rules! v { () => {0u64} } fn f() { let a: u64 = v!(); }\",\n         );\n     }\n \n     #[test]\n     fn add_explicit_type_works_for_macro_call_recursive() {\n         check_assist(\n             add_explicit_type,\n-            \"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a<|> = v!(); }\",\n-            \"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a<|>: u64 = v!(); }\",\n+            r#\"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a<|> = v!(); }\"#,\n+            r#\"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a: u64 = v!(); }\"#,\n         );\n     }\n \n@@ -208,7 +204,7 @@ struct Test<K, T = u8> {\n }\n \n fn main() {\n-    let test<|>: Test<i32> = Test { t: 23, k: 33 };\n+    let test: Test<i32> = Test { t: 23, k: 33 };\n }\"#,\n         );\n     }"}, {"sha": "6a675e8126dd812f0c0cdb66eefceb1e20a469e0", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,12 +1,8 @@\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    ast::{self, AstNode, NameOwner},\n-    TextSize,\n-};\n-use stdx::format_to;\n+use ra_syntax::ast::{self, AstNode, NameOwner};\n+use test_utils::mark;\n \n-use crate::{utils::FamousDefs, Assist, AssistCtx, AssistId};\n-use test_utils::tested_by;\n+use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n \n // Assist add_from_impl_for_enum\n //\n@@ -25,7 +21,7 @@ use test_utils::tested_by;\n //     }\n // }\n // ```\n-pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n     let variant_name = variant.name()?;\n     let enum_name = variant.parent_enum().name()?;\n@@ -38,23 +34,23 @@ pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n     }\n     let field_type = field_list.fields().next()?.type_ref()?;\n     let path = match field_type {\n-        ast::TypeRef::PathType(p) => p,\n+        ast::TypeRef::PathType(it) => it,\n         _ => return None,\n     };\n \n-    if existing_from_impl(ctx.sema, &variant).is_some() {\n-        tested_by!(test_add_from_impl_already_exists);\n+    if existing_from_impl(&ctx.sema, &variant).is_some() {\n+        mark::hit!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n-    ctx.add_assist(\n+    let target = variant.syntax().text_range();\n+    acc.add(\n         AssistId(\"add_from_impl_for_enum\"),\n         \"Add From impl for this enum variant\",\n+        target,\n         |edit| {\n             let start_offset = variant.parent_enum().syntax().text_range().end();\n-            let mut buf = String::new();\n-            format_to!(\n-                buf,\n+            let buf = format!(\n                 r#\"\n \n impl From<{0}> for {1} {{\n@@ -67,7 +63,6 @@ impl From<{0}> for {1} {{\n                 variant_name\n             );\n             edit.insert(start_offset, buf);\n-            edit.set_cursor(start_offset + TextSize::of(\"\\n\\n\"));\n         },\n     )\n }\n@@ -95,10 +90,11 @@ fn existing_from_impl(\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n+    use test_utils::mark;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n-    use test_utils::covers;\n+    use super::*;\n \n     #[test]\n     fn test_add_from_impl_for_enum() {\n@@ -107,7 +103,7 @@ mod tests {\n             \"enum A { <|>One(u32) }\",\n             r#\"enum A { One(u32) }\n \n-<|>impl From<u32> for A {\n+impl From<u32> for A {\n     fn from(v: u32) -> Self {\n         A::One(v)\n     }\n@@ -119,10 +115,10 @@ mod tests {\n     fn test_add_from_impl_for_enum_complicated_path() {\n         check_assist(\n             add_from_impl_for_enum,\n-            \"enum A { <|>One(foo::bar::baz::Boo) }\",\n+            r#\"enum A { <|>One(foo::bar::baz::Boo) }\"#,\n             r#\"enum A { One(foo::bar::baz::Boo) }\n \n-<|>impl From<foo::bar::baz::Boo> for A {\n+impl From<foo::bar::baz::Boo> for A {\n     fn from(v: foo::bar::baz::Boo) -> Self {\n         A::One(v)\n     }\n@@ -153,7 +149,7 @@ mod tests {\n \n     #[test]\n     fn test_add_from_impl_already_exists() {\n-        covers!(test_add_from_impl_already_exists);\n+        mark::check!(test_add_from_impl_already_exists);\n         check_not_applicable(\n             r#\"\n enum A { <|>One(u32), }\n@@ -184,7 +180,7 @@ pub trait From<T> {\n }\"#,\n             r#\"enum A { One(u32), Two(String), }\n \n-<|>impl From<u32> for A {\n+impl From<u32> for A {\n     fn from(v: u32) -> Self {\n         A::One(v)\n     }"}, {"sha": "24f931a85e195a8bc0cfd386c9084960bfad2980", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 219, "deletions": 136, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,13 +1,21 @@\n+use hir::HirDisplay;\n+use ra_db::FileId;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make, ArgListOwner, AstNode, ModuleItemOwner,\n+    },\n     SyntaxKind, SyntaxNode, TextSize,\n };\n-\n-use crate::{Assist, AssistCtx, AssistFile, AssistId};\n-use ast::{edit::IndentLevel, ArgListOwner, ModuleItemOwner};\n-use hir::HirDisplay;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n+use crate::{\n+    assist_config::SnippetCap,\n+    utils::{render_snippet, Cursor},\n+    AssistContext, AssistId, Assists,\n+};\n+\n // Assist: add_function\n //\n // Adds a stub function with a signature matching the function under the cursor.\n@@ -29,11 +37,11 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // }\n //\n // fn bar(arg: &str, baz: Baz) {\n-//     todo!()\n+//     ${0:todo!()}\n // }\n //\n // ```\n-pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n@@ -43,105 +51,123 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    let target_module = if let Some(qualifier) = path.qualifier() {\n-        if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) =\n-            ctx.sema.resolve_path(&qualifier)\n-        {\n-            Some(module.definition_source(ctx.sema.db))\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        None\n+    let target_module = match path.qualifier() {\n+        Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => Some(module),\n+            _ => return None,\n+        },\n+        None => None,\n     };\n \n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n-    ctx.add_assist(AssistId(\"add_function\"), \"Add function\", |edit| {\n-        edit.target(call.syntax().text_range());\n-\n-        if let Some(function_template) = function_builder.render() {\n-            edit.set_file(function_template.file);\n-            edit.set_cursor(function_template.cursor_offset);\n-            edit.insert(function_template.insert_offset, function_template.fn_def.to_string());\n+    let target = call.syntax().text_range();\n+    acc.add(AssistId(\"add_function\"), \"Add function\", target, |builder| {\n+        let function_template = function_builder.render();\n+        builder.set_file(function_template.file);\n+        let new_fn = function_template.to_string(ctx.config.snippet_cap);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+            None => builder.insert(function_template.insert_offset, new_fn),\n         }\n     })\n }\n \n struct FunctionTemplate {\n     insert_offset: TextSize,\n-    cursor_offset: TextSize,\n-    fn_def: ast::SourceFile,\n-    file: AssistFile,\n+    placeholder_expr: ast::MacroCall,\n+    leading_ws: String,\n+    fn_def: ast::FnDef,\n+    trailing_ws: String,\n+    file: FileId,\n+}\n+\n+impl FunctionTemplate {\n+    fn to_string(&self, cap: Option<SnippetCap>) -> String {\n+        let f = match cap {\n+            Some(cap) => render_snippet(\n+                cap,\n+                self.fn_def.syntax(),\n+                Cursor::Replace(self.placeholder_expr.syntax()),\n+            ),\n+            None => self.fn_def.to_string(),\n+        };\n+        format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n+    }\n }\n \n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n     type_params: Option<ast::TypeParamList>,\n     params: ast::ParamList,\n-    file: AssistFile,\n+    file: FileId,\n     needs_pub: bool,\n }\n \n impl FunctionBuilder {\n-    /// Prepares a generated function that matches `call` in `generate_in`\n-    /// (or as close to `call` as possible, if `generate_in` is `None`)\n+    /// Prepares a generated function that matches `call`.\n+    /// The function is generated in `target_module` or next to `call`\n     fn from_call(\n-        ctx: &AssistCtx,\n+        ctx: &AssistContext,\n         call: &ast::CallExpr,\n         path: &ast::Path,\n-        target_module: Option<hir::InFile<hir::ModuleSource>>,\n+        target_module: Option<hir::Module>,\n     ) -> Option<Self> {\n-        let needs_pub = target_module.is_some();\n-        let mut file = AssistFile::default();\n-        let target = if let Some(target_module) = target_module {\n-            let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, target_module)?;\n-            file = in_file;\n-            target\n-        } else {\n-            next_space_for_fn_after_call_site(&call)?\n+        let mut file = ctx.frange.file_id;\n+        let target = match &target_module {\n+            Some(target_module) => {\n+                let module_source = target_module.definition_source(ctx.db);\n+                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n+                file = in_file;\n+                target\n+            }\n+            None => next_space_for_fn_after_call_site(&call)?,\n         };\n+        let needs_pub = target_module.is_some();\n+        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n         let fn_name = fn_name(&path)?;\n-        let (type_params, params) = fn_args(ctx, &call)?;\n+        let (type_params, params) = fn_args(ctx, target_module, &call)?;\n+\n         Some(Self { target, fn_name, type_params, params, file, needs_pub })\n     }\n \n-    fn render(self) -> Option<FunctionTemplate> {\n-        let placeholder_expr = ast::make::expr_todo();\n-        let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n-        let mut fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n-        if self.needs_pub {\n-            fn_def = ast::make::add_pub_crate_modifier(fn_def);\n-        }\n+    fn render(self) -> FunctionTemplate {\n+        let placeholder_expr = make::expr_todo();\n+        let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n+        let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n+        let mut fn_def =\n+            make::fn_def(visibility, self.fn_name, self.type_params, self.params, fn_body);\n+        let leading_ws;\n+        let trailing_ws;\n \n-        let (fn_def, insert_offset) = match self.target {\n+        let insert_offset = match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n-                let with_leading_blank_line = ast::make::add_leading_newlines(2, fn_def);\n-                let indented = IndentLevel::from_node(&it).increase_indent(with_leading_blank_line);\n-                (indented, it.text_range().end())\n+                let indent = IndentLevel::from_node(&it);\n+                leading_ws = format!(\"\\n\\n{}\", indent);\n+                fn_def = fn_def.indent(indent);\n+                trailing_ws = String::new();\n+                it.text_range().end()\n             }\n             GeneratedFunctionTarget::InEmptyItemList(it) => {\n-                let indent_once = IndentLevel(1);\n                 let indent = IndentLevel::from_node(it.syntax());\n-\n-                let fn_def = ast::make::add_leading_newlines(1, fn_def);\n-                let fn_def = indent_once.increase_indent(fn_def);\n-                let fn_def = ast::make::add_trailing_newlines(1, fn_def);\n-                let fn_def = indent.increase_indent(fn_def);\n-                (fn_def, it.syntax().text_range().start() + TextSize::of('{'))\n+                leading_ws = format!(\"\\n{}\", indent + 1);\n+                fn_def = fn_def.indent(indent + 1);\n+                trailing_ws = format!(\"\\n{}\", indent);\n+                it.syntax().text_range().start() + TextSize::of('{')\n             }\n         };\n \n-        let cursor_offset_from_fn_start = fn_def\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::MacroCall::cast)?\n-            .syntax()\n-            .text_range()\n-            .start();\n-        let cursor_offset = insert_offset + cursor_offset_from_fn_start;\n-        Some(FunctionTemplate { insert_offset, cursor_offset, fn_def, file: self.file })\n+        let placeholder_expr =\n+            fn_def.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+        FunctionTemplate {\n+            insert_offset,\n+            placeholder_expr,\n+            leading_ws,\n+            fn_def,\n+            trailing_ws,\n+            file: self.file,\n+        }\n     }\n }\n \n@@ -150,32 +176,41 @@ enum GeneratedFunctionTarget {\n     InEmptyItemList(ast::ItemList),\n }\n \n+impl GeneratedFunctionTarget {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            GeneratedFunctionTarget::BehindItem(it) => it,\n+            GeneratedFunctionTarget::InEmptyItemList(it) => it.syntax(),\n+        }\n+    }\n+}\n+\n fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n     let name = call.segment()?.syntax().to_string();\n-    Some(ast::make::name(&name))\n+    Some(make::name(&name))\n }\n \n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n-    ctx: &AssistCtx,\n+    ctx: &AssistContext,\n+    target_module: hir::Module,\n     call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n-        let arg_name = match fn_arg_name(&arg) {\n+        arg_names.push(match fn_arg_name(&arg) {\n             Some(name) => name,\n             None => String::from(\"arg\"),\n-        };\n-        arg_names.push(arg_name);\n-        arg_types.push(match fn_arg_type(ctx, &arg) {\n+        });\n+        arg_types.push(match fn_arg_type(ctx, target_module, &arg) {\n             Some(ty) => ty,\n             None => String::from(\"()\"),\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| ast::make::param(name, ty));\n-    Some((None, ast::make::param_list(params)))\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| make::param(name, ty));\n+    Some((None, make::param_list(params)))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers.\n@@ -224,12 +259,21 @@ fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistCtx, fn_arg: &ast::Expr) -> Option<String> {\n+fn fn_arg_type(\n+    ctx: &AssistContext,\n+    target_module: hir::Module,\n+    fn_arg: &ast::Expr,\n+) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;\n     }\n-    Some(ty.display(ctx.sema.db).to_string())\n+\n+    if let Ok(rendered) = ty.display_source_code(ctx.db, target_module.into()) {\n+        Some(rendered)\n+    } else {\n+        None\n+    }\n }\n \n /// Returns the position inside the current mod or file\n@@ -258,11 +302,10 @@ fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFu\n \n fn next_space_for_fn_in_module(\n     db: &dyn hir::db::AstDatabase,\n-    module: hir::InFile<hir::ModuleSource>,\n-) -> Option<(AssistFile, GeneratedFunctionTarget)> {\n-    let file = module.file_id.original_file(db);\n-    let assist_file = AssistFile::TargetFile(file);\n-    let assist_item = match module.value {\n+    module_source: &hir::InFile<hir::ModuleSource>,\n+) -> Option<(FileId, GeneratedFunctionTarget)> {\n+    let file = module_source.file_id.original_file(db);\n+    let assist_item = match &module_source.value {\n         hir::ModuleSource::SourceFile(it) => {\n             if let Some(last_item) = it.items().last() {\n                 GeneratedFunctionTarget::BehindItem(last_item.syntax().clone())\n@@ -278,12 +321,12 @@ fn next_space_for_fn_in_module(\n             }\n         }\n     };\n-    Some((assist_file, assist_item))\n+    Some((file, assist_item))\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -302,7 +345,7 @@ fn foo() {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -329,7 +372,7 @@ impl Foo {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -353,7 +396,7 @@ fn foo1() {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \n fn foo2() {}\n@@ -379,7 +422,7 @@ mod baz {\n     }\n \n     fn bar() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \",\n@@ -405,7 +448,7 @@ fn foo() {\n }\n \n fn bar(baz: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         );\n@@ -438,7 +481,7 @@ impl Baz {\n }\n \n fn bar(baz: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -459,7 +502,7 @@ fn foo() {\n }\n \n fn bar(arg: &str) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -480,7 +523,7 @@ fn foo() {\n }\n \n fn bar(arg: char) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -501,7 +544,7 @@ fn foo() {\n }\n \n fn bar(arg: i32) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -522,7 +565,7 @@ fn foo() {\n }\n \n fn bar(arg: u8) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -547,7 +590,7 @@ fn foo() {\n }\n \n fn bar(x: u8) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -570,7 +613,7 @@ fn foo() {\n }\n \n fn bar(worble: ()) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -599,15 +642,40 @@ fn baz() {\n }\n \n fn bar(foo: impl Foo) {\n-    <|>todo!()\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn borrowed_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar<|>(&baz())\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar(&baz())\n+}\n+\n+fn bar(baz: &Baz) {\n+    ${0:todo!()}\n }\n \",\n         )\n     }\n \n     #[test]\n-    #[ignore]\n-    // FIXME print paths properly to make this test pass\n     fn add_function_with_qualified_path_arg() {\n         check_assist(\n             add_function,\n@@ -616,25 +684,21 @@ mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        <|>bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    <|>bar(Baz::baz())\n }\n \",\n             r\"\n mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    bar(Baz::baz())\n+}\n \n-    fn bar(baz: super::Baz::Bof) {\n-        <|>todo!()\n-    }\n+fn bar(baz: Baz::Bof) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -657,7 +721,7 @@ fn foo<T>(t: T) {\n }\n \n fn bar<T>(t: T) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -688,7 +752,7 @@ fn foo() {\n }\n \n fn bar(arg: fn() -> Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -713,7 +777,7 @@ fn foo() {\n }\n \n fn bar(closure: impl Fn(i64) -> i64) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -734,7 +798,7 @@ fn foo() {\n }\n \n fn bar(baz: ()) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -759,7 +823,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -784,7 +848,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -804,7 +868,7 @@ fn foo() {\n             r\"\n mod bar {\n     pub(crate) fn my_fn() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \n@@ -815,6 +879,40 @@ fn foo() {\n         )\n     }\n \n+    #[test]\n+    #[ignore]\n+    // Ignored until local imports are supported.\n+    // See https://github.com/rust-analyzer/rust-analyzer/issues/1165\n+    fn qualified_path_uses_correct_scope() {\n+        check_assist(\n+            add_function,\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz<|>(foo)\n+}\n+\",\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz(foo)\n+}\n+\n+fn baz(foo: foo::Foo) {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n@@ -833,7 +931,7 @@ mod bar {\n     fn something_else() {}\n \n     pub(crate) fn my_fn() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \n@@ -861,7 +959,7 @@ fn foo() {\n mod bar {\n     mod baz {\n         pub(crate) fn my_fn() {\n-            <|>todo!()\n+            ${0:todo!()}\n         }\n     }\n }\n@@ -890,7 +988,7 @@ fn main() {\n \n \n pub(crate) fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\",\n         )\n     }\n@@ -926,21 +1024,6 @@ fn bar(baz: ()) {}\n         )\n     }\n \n-    #[test]\n-    fn add_function_not_applicable_if_function_path_not_singleton() {\n-        // In the future this assist could be extended to generate functions\n-        // if the path is in the same crate (or even the same workspace).\n-        // For the beginning, I think this is fine.\n-        check_assist_not_applicable(\n-            add_function,\n-            r\"\n-fn foo() {\n-    other_crate::bar<|>();\n-}\n-        \",\n-        )\n-    }\n-\n     #[test]\n     #[ignore]\n     fn create_method_with_no_args() {"}, {"sha": "eceba7d0ae671c11d8de5cb7aa29892762a2e4f7", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,35 +1,32 @@\n-use ra_syntax::{\n-    ast::{self, AstNode, NameOwner, TypeParamsOwner},\n-    TextSize,\n-};\n+use ra_syntax::ast::{self, AstNode, NameOwner, TypeParamsOwner};\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_impl\n //\n // Adds a new inherent impl for a type.\n //\n // ```\n // struct Ctx<T: Clone> {\n-//      data: T,<|>\n+//     data: T,<|>\n // }\n // ```\n // ->\n // ```\n // struct Ctx<T: Clone> {\n-//      data: T,\n+//     data: T,\n // }\n //\n // impl<T: Clone> Ctx<T> {\n-//\n+//     $0\n // }\n // ```\n-pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n-    ctx.add_assist(AssistId(\"add_impl\"), format!(\"Implement {}\", name.text().as_str()), |edit| {\n-        edit.target(nominal.syntax().text_range());\n+    let target = nominal.syntax().text_range();\n+    acc.add(AssistId(\"add_impl\"), format!(\"Implement {}\", name.text().as_str()), target, |edit| {\n         let type_params = nominal.type_param_list();\n         let start_offset = nominal.syntax().text_range().end();\n         let mut buf = String::new();\n@@ -50,30 +47,37 @@ pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n             let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n             format_to!(buf, \"<{}>\", generic_params)\n         }\n-        buf.push_str(\" {\\n\");\n-        edit.set_cursor(start_offset + TextSize::of(&buf));\n-        buf.push_str(\"\\n}\");\n-        edit.insert(start_offset, buf);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                buf.push_str(\" {\\n    $0\\n}\");\n+                edit.insert_snippet(cap, start_offset, buf);\n+            }\n+            None => {\n+                buf.push_str(\" {\\n}\");\n+                edit.insert(start_offset, buf);\n+            }\n+        }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n+    use crate::tests::{check_assist, check_assist_target};\n+\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn test_add_impl() {\n-        check_assist(add_impl, \"struct Foo {<|>}\\n\", \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\");\n+        check_assist(add_impl, \"struct Foo {<|>}\\n\", \"struct Foo {}\\n\\nimpl Foo {\\n    $0\\n}\\n\");\n         check_assist(\n             add_impl,\n             \"struct Foo<T: Clone> {<|>}\",\n-            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n<|>\\n}\",\n+            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n    $0\\n}\",\n         );\n         check_assist(\n             add_impl,\n             \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n-            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n<|>\\n}\",\n+            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n    $0\\n}\",\n         );\n     }\n "}, {"sha": "abacd4065fc9f4a20fc93b0341f33362135e1aa3", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 223, "deletions": 118, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,13 +1,18 @@\n use hir::HasSource;\n use ra_syntax::{\n-    ast::{self, edit, make, AstNode, NameOwner},\n+    ast::{\n+        self,\n+        edit::{self, AstNodeEdit, IndentLevel},\n+        make, AstNode, NameOwner,\n+    },\n     SmolStr,\n };\n \n use crate::{\n+    assist_context::{AssistContext, Assists},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n-    utils::{get_missing_impl_items, resolve_target_trait},\n-    Assist, AssistCtx, AssistId,\n+    utils::{get_missing_assoc_items, render_snippet, resolve_target_trait, Cursor},\n+    AssistId,\n };\n \n #[derive(PartialEq)]\n@@ -40,12 +45,15 @@ enum AddMissingImplMembersMode {\n // }\n //\n // impl Trait<u32> for () {\n-//     fn foo(&self) -> u32 { todo!() }\n+//     fn foo(&self) -> u32 {\n+//         ${0:todo!()}\n+//     }\n //\n // }\n // ```\n-pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::NoDefaultMethods,\n         \"add_impl_missing_members\",\n@@ -81,12 +89,13 @@ pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n // impl Trait for () {\n //     Type X = ();\n //     fn foo(&self) {}\n-//     fn bar(&self) {}\n+//     $0fn bar(&self) {}\n //\n // }\n // ```\n-pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::DefaultMethodsOnly,\n         \"add_impl_default_members\",\n@@ -95,36 +104,37 @@ pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n }\n \n fn add_missing_impl_members_inner(\n-    ctx: AssistCtx,\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n     mode: AddMissingImplMembersMode,\n     assist_id: &'static str,\n     label: &'static str,\n-) -> Option<Assist> {\n+) -> Option<()> {\n     let _p = ra_prof::profile(\"add_missing_impl_members_inner\");\n-    let impl_node = ctx.find_node_at_offset::<ast::ImplDef>()?;\n-    let impl_item_list = impl_node.item_list()?;\n+    let impl_def = ctx.find_node_at_offset::<ast::ImplDef>()?;\n+    let impl_item_list = impl_def.item_list()?;\n \n-    let trait_ = resolve_target_trait(&ctx.sema, &impl_node)?;\n+    let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n \n-    let def_name = |item: &ast::ImplItem| -> Option<SmolStr> {\n+    let def_name = |item: &ast::AssocItem| -> Option<SmolStr> {\n         match item {\n-            ast::ImplItem::FnDef(def) => def.name(),\n-            ast::ImplItem::TypeAliasDef(def) => def.name(),\n-            ast::ImplItem::ConstDef(def) => def.name(),\n+            ast::AssocItem::FnDef(def) => def.name(),\n+            ast::AssocItem::TypeAliasDef(def) => def.name(),\n+            ast::AssocItem::ConstDef(def) => def.name(),\n         }\n         .map(|it| it.text().clone())\n     };\n \n-    let missing_items = get_missing_impl_items(&ctx.sema, &impl_node)\n+    let missing_items = get_missing_assoc_items(&ctx.sema, &impl_def)\n         .iter()\n         .map(|i| match i {\n-            hir::AssocItem::Function(i) => ast::ImplItem::FnDef(i.source(ctx.db).value),\n-            hir::AssocItem::TypeAlias(i) => ast::ImplItem::TypeAliasDef(i.source(ctx.db).value),\n-            hir::AssocItem::Const(i) => ast::ImplItem::ConstDef(i.source(ctx.db).value),\n+            hir::AssocItem::Function(i) => ast::AssocItem::FnDef(i.source(ctx.db).value),\n+            hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAliasDef(i.source(ctx.db).value),\n+            hir::AssocItem::Const(i) => ast::AssocItem::ConstDef(i.source(ctx.db).value),\n         })\n         .filter(|t| def_name(&t).is_some())\n         .filter(|t| match t {\n-            ast::ImplItem::FnDef(def) => match mode {\n+            ast::AssocItem::FnDef(def) => match mode {\n                 AddMissingImplMembersMode::DefaultMethodsOnly => def.body().is_some(),\n                 AddMissingImplMembersMode::NoDefaultMethods => def.body().is_none(),\n             },\n@@ -136,52 +146,67 @@ fn add_missing_impl_members_inner(\n         return None;\n     }\n \n-    let sema = ctx.sema;\n-\n-    ctx.add_assist(AssistId(assist_id), label, |edit| {\n-        let n_existing_items = impl_item_list.impl_items().count();\n-        let source_scope = sema.scope_for_def(trait_);\n-        let target_scope = sema.scope(impl_item_list.syntax());\n+    let target = impl_def.syntax().text_range();\n+    acc.add(AssistId(assist_id), label, target, |builder| {\n+        let n_existing_items = impl_item_list.assoc_items().count();\n+        let source_scope = ctx.sema.scope_for_def(trait_);\n+        let target_scope = ctx.sema.scope(impl_item_list.syntax());\n         let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n-            .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_node));\n+            .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def));\n         let items = missing_items\n             .into_iter()\n             .map(|it| ast_transform::apply(&*ast_transform, it))\n             .map(|it| match it {\n-                ast::ImplItem::FnDef(def) => ast::ImplItem::FnDef(add_body(def)),\n+                ast::AssocItem::FnDef(def) => ast::AssocItem::FnDef(add_body(def)),\n                 _ => it,\n             })\n             .map(|it| edit::remove_attrs_and_docs(&it));\n         let new_impl_item_list = impl_item_list.append_items(items);\n-        let cursor_position = {\n-            let first_new_item = new_impl_item_list.impl_items().nth(n_existing_items).unwrap();\n-            first_new_item.syntax().text_range().start()\n+        let first_new_item = new_impl_item_list.assoc_items().nth(n_existing_items).unwrap();\n+\n+        let original_range = impl_item_list.syntax().text_range();\n+        match ctx.config.snippet_cap {\n+            None => builder.replace(original_range, new_impl_item_list.to_string()),\n+            Some(cap) => {\n+                let mut cursor = Cursor::Before(first_new_item.syntax());\n+                let placeholder;\n+                if let ast::AssocItem::FnDef(func) = &first_new_item {\n+                    if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast) {\n+                        if m.syntax().text() == \"todo!()\" {\n+                            placeholder = m;\n+                            cursor = Cursor::Replace(placeholder.syntax());\n+                        }\n+                    }\n+                }\n+                builder.replace_snippet(\n+                    cap,\n+                    original_range,\n+                    render_snippet(cap, new_impl_item_list.syntax(), cursor),\n+                )\n+            }\n         };\n-\n-        edit.replace_ast(impl_item_list, new_impl_item_list);\n-        edit.set_cursor(cursor_position);\n     })\n }\n \n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n-    if fn_def.body().is_none() {\n-        fn_def.with_body(make::block_from_expr(make::expr_todo()))\n-    } else {\n-        fn_def\n+    if fn_def.body().is_some() {\n+        return fn_def;\n     }\n+    let body = make::block_expr(None, Some(make::expr_todo())).indent(IndentLevel(1));\n+    fn_def.with_body(body)\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n     #[test]\n     fn test_add_missing_impl_members() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo {\n     type Output;\n \n@@ -197,8 +222,8 @@ struct S;\n impl Foo for S {\n     fn bar(&self) {}\n <|>\n-}\",\n-            \"\n+}\"#,\n+            r#\"\n trait Foo {\n     type Output;\n \n@@ -213,20 +238,24 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>type Output;\n+    $0type Output;\n     const CONST: usize = 42;\n-    fn foo(&self) { todo!() }\n-    fn baz(&self) { todo!() }\n+    fn foo(&self) {\n+        todo!()\n+    }\n+    fn baz(&self) {\n+        todo!()\n+    }\n \n-}\",\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_copied_overriden_members() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo {\n     fn foo(&self);\n     fn bar(&self) -> bool { true }\n@@ -238,8 +267,8 @@ struct S;\n impl Foo for S {\n     fn bar(&self) {}\n <|>\n-}\",\n-            \"\n+}\"#,\n+            r#\"\n trait Foo {\n     fn foo(&self);\n     fn bar(&self) -> bool { true }\n@@ -250,146 +279,162 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>fn foo(&self) { todo!() }\n+    fn foo(&self) {\n+        ${0:todo!()}\n+    }\n \n-}\",\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_empty_impl_def() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo { fn foo(&self); }\n struct S;\n-impl Foo for S { <|> }\",\n-            \"\n+impl Foo for S { <|> }\"#,\n+            r#\"\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    <|>fn foo(&self) { todo!() }\n-}\",\n+    fn foo(&self) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn fill_in_type_params_1() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo<T> { fn foo(&self, t: T) -> &T; }\n struct S;\n-impl Foo<u32> for S { <|> }\",\n-            \"\n+impl Foo<u32> for S { <|> }\"#,\n+            r#\"\n trait Foo<T> { fn foo(&self, t: T) -> &T; }\n struct S;\n impl Foo<u32> for S {\n-    <|>fn foo(&self, t: u32) -> &u32 { todo!() }\n-}\",\n+    fn foo(&self, t: u32) -> &u32 {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn fill_in_type_params_2() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo<T> { fn foo(&self, t: T) -> &T; }\n struct S;\n-impl<U> Foo<U> for S { <|> }\",\n-            \"\n+impl<U> Foo<U> for S { <|> }\"#,\n+            r#\"\n trait Foo<T> { fn foo(&self, t: T) -> &T; }\n struct S;\n impl<U> Foo<U> for S {\n-    <|>fn foo(&self, t: U) -> &U { todo!() }\n-}\",\n+    fn foo(&self, t: U) -> &U {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_cursor_after_empty_impl_def() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo { fn foo(&self); }\n struct S;\n-impl Foo for S {}<|>\",\n-            \"\n+impl Foo for S {}<|>\"#,\n+            r#\"\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    <|>fn foo(&self) { todo!() }\n-}\",\n+    fn foo(&self) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         )\n     }\n \n     #[test]\n     fn test_qualify_path_1() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n mod foo {\n     pub struct Bar;\n     trait Foo { fn foo(&self, bar: Bar); }\n }\n struct S;\n-impl foo::Foo for S { <|> }\",\n-            \"\n+impl foo::Foo for S { <|> }\"#,\n+            r#\"\n mod foo {\n     pub struct Bar;\n     trait Foo { fn foo(&self, bar: Bar); }\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar) { todo!() }\n-}\",\n+    fn foo(&self, bar: foo::Bar) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_qualify_path_generic() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     trait Foo { fn foo(&self, bar: Bar<u32>); }\n }\n struct S;\n-impl foo::Foo for S { <|> }\",\n-            \"\n+impl foo::Foo for S { <|> }\"#,\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     trait Foo { fn foo(&self, bar: Bar<u32>); }\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar<u32>) { todo!() }\n-}\",\n+    fn foo(&self, bar: foo::Bar<u32>) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_qualify_path_and_substitute_param() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n }\n struct S;\n-impl foo::Foo<u32> for S { <|> }\",\n-            \"\n+impl foo::Foo<u32> for S { <|> }\"#,\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n }\n struct S;\n impl foo::Foo<u32> for S {\n-    <|>fn foo(&self, bar: foo::Bar<u32>) { todo!() }\n-}\",\n+    fn foo(&self, bar: foo::Bar<u32>) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n@@ -398,122 +443,130 @@ impl foo::Foo<u32> for S {\n         // when substituting params, the substituted param should not be qualified!\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n mod foo {\n     trait Foo<T> { fn foo(&self, bar: T); }\n     pub struct Param;\n }\n struct Param;\n struct S;\n-impl foo::Foo<Param> for S { <|> }\",\n-            \"\n+impl foo::Foo<Param> for S { <|> }\"#,\n+            r#\"\n mod foo {\n     trait Foo<T> { fn foo(&self, bar: T); }\n     pub struct Param;\n }\n struct Param;\n struct S;\n impl foo::Foo<Param> for S {\n-    <|>fn foo(&self, bar: Param) { todo!() }\n-}\",\n+    fn foo(&self, bar: Param) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_qualify_path_associated_item() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     impl Bar<T> { type Assoc = u32; }\n     trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n }\n struct S;\n-impl foo::Foo for S { <|> }\",\n-            \"\n+impl foo::Foo for S { <|> }\"#,\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     impl Bar<T> { type Assoc = u32; }\n     trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar<u32>::Assoc) { todo!() }\n-}\",\n+    fn foo(&self, bar: foo::Bar<u32>::Assoc) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_qualify_path_nested() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     pub struct Baz;\n     trait Foo { fn foo(&self, bar: Bar<Baz>); }\n }\n struct S;\n-impl foo::Foo for S { <|> }\",\n-            \"\n+impl foo::Foo for S { <|> }\"#,\n+            r#\"\n mod foo {\n     pub struct Bar<T>;\n     pub struct Baz;\n     trait Foo { fn foo(&self, bar: Bar<Baz>); }\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar<foo::Baz>) { todo!() }\n-}\",\n+    fn foo(&self, bar: foo::Bar<foo::Baz>) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_qualify_path_fn_trait_notation() {\n         check_assist(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n mod foo {\n     pub trait Fn<Args> { type Output; }\n     trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n }\n struct S;\n-impl foo::Foo for S { <|> }\",\n-            \"\n+impl foo::Foo for S { <|> }\"#,\n+            r#\"\n mod foo {\n     pub trait Fn<Args> { type Output; }\n     trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: dyn Fn(u32) -> i32) { todo!() }\n-}\",\n+    fn foo(&self, bar: dyn Fn(u32) -> i32) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn test_empty_trait() {\n         check_assist_not_applicable(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo;\n struct S;\n-impl Foo for S { <|> }\",\n+impl Foo for S { <|> }\"#,\n         )\n     }\n \n     #[test]\n     fn test_ignore_unnamed_trait_members_and_default_methods() {\n         check_assist_not_applicable(\n             add_missing_impl_members,\n-            \"\n+            r#\"\n trait Foo {\n     fn (arg: u32);\n     fn valid(some: u32) -> bool { false }\n }\n struct S;\n-impl Foo for S { <|> }\",\n+impl Foo for S { <|> }\"#,\n         )\n     }\n \n@@ -543,8 +596,10 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    <|>type Output;\n-    fn foo(&self) { todo!() }\n+    $0type Output;\n+    fn foo(&self) {\n+        todo!()\n+    }\n }\"#,\n         )\n     }\n@@ -553,7 +608,7 @@ impl Foo for S {\n     fn test_default_methods() {\n         check_assist(\n             add_missing_default_members,\n-            \"\n+            r#\"\n trait Foo {\n     type Output;\n \n@@ -563,8 +618,8 @@ trait Foo {\n     fn foo(some: u32) -> bool;\n }\n struct S;\n-impl Foo for S { <|> }\",\n-            \"\n+impl Foo for S { <|> }\"#,\n+            r#\"\n trait Foo {\n     type Output;\n \n@@ -575,8 +630,58 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    <|>fn valid(some: u32) -> bool { false }\n-}\",\n+    $0fn valid(some: u32) -> bool { false }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_generic_single_default_parameter() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Foo<T = Self> {\n+    fn bar(&self, other: &T);\n+}\n+\n+struct S;\n+impl Foo for S { <|> }\"#,\n+            r#\"\n+trait Foo<T = Self> {\n+    fn bar(&self, other: &T);\n+}\n+\n+struct S;\n+impl Foo for S {\n+    fn bar(&self, other: &Self) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_generic_default_parameter_is_second() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Foo<T1, T2 = Self> {\n+    fn bar(&self, this: &T1, that: &T2);\n+}\n+\n+struct S<T>;\n+impl Foo<T> for S<T> { <|> }\"#,\n+            r#\"\n+trait Foo<T1, T2 = Self> {\n+    fn bar(&self, this: &T1, that: &T2);\n+}\n+\n+struct S<T>;\n+impl Foo<T> for S<T> {\n+    fn bar(&self, this: &T, that: &Self) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n         )\n     }\n }"}, {"sha": "837aa83774ee7fe384f5cc97f021c559b8a86b74", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,11 +3,11 @@ use ra_syntax::{\n     ast::{\n         self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n     },\n-    TextSize, T,\n+    T,\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_new\n //\n@@ -25,11 +25,11 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n //\n // impl<T: Clone> Ctx<T> {\n-//     fn new(data: T) -> Self { Self { data } }\n+//     fn $0new(data: T) -> Self { Self { data } }\n // }\n //\n // ```\n-pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n \n     // We want to only apply this to non-union structs with named fields\n@@ -41,33 +41,27 @@ pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n     // Return early if we've found an existing new fn\n     let impl_def = find_struct_impl(&ctx, &strukt)?;\n \n-    ctx.add_assist(AssistId(\"add_new\"), \"Add default constructor\", |edit| {\n-        edit.target(strukt.syntax().text_range());\n-\n+    let target = strukt.syntax().text_range();\n+    acc.add(AssistId(\"add_new\"), \"Add default constructor\", target, |builder| {\n         let mut buf = String::with_capacity(512);\n \n         if impl_def.is_some() {\n             buf.push('\\n');\n         }\n \n-        let vis = strukt.visibility().map(|v| format!(\"{} \", v));\n-        let vis = vis.as_deref().unwrap_or(\"\");\n+        let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n \n         let params = field_list\n             .fields()\n             .filter_map(|f| {\n-                Some(format!(\n-                    \"{}: {}\",\n-                    f.name()?.syntax().text(),\n-                    f.ascribed_type()?.syntax().text()\n-                ))\n+                Some(format!(\"{}: {}\", f.name()?.syntax(), f.ascribed_type()?.syntax()))\n             })\n             .sep_by(\", \");\n         let fields = field_list.fields().filter_map(|f| f.name()).sep_by(\", \");\n \n         format_to!(buf, \"    {}fn new({}) -> Self {{ Self {{ {} }} }}\", vis, params, fields);\n \n-        let (start_offset, end_offset) = impl_def\n+        let start_offset = impl_def\n             .and_then(|impl_def| {\n                 buf.push('\\n');\n                 let start = impl_def\n@@ -77,17 +71,20 @@ pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n                     .text_range()\n                     .end();\n \n-                Some((start, TextSize::of(\"\\n\")))\n+                Some(start)\n             })\n             .unwrap_or_else(|| {\n                 buf = generate_impl_text(&strukt, &buf);\n-                let start = strukt.syntax().text_range().end();\n-\n-                (start, TextSize::of(\"\\n}\\n\"))\n+                strukt.syntax().text_range().end()\n             });\n \n-        edit.set_cursor(start_offset + TextSize::of(&buf) - end_offset);\n-        edit.insert(start_offset, buf);\n+        match ctx.config.snippet_cap {\n+            None => builder.insert(start_offset, buf),\n+            Some(cap) => {\n+                buf = buf.replace(\"fn new\", \"fn $0new\");\n+                builder.insert_snippet(cap, start_offset, buf);\n+            }\n+        }\n     })\n }\n \n@@ -124,7 +121,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n //\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(ctx: &AssistCtx, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n+fn find_struct_impl(ctx: &AssistContext, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n     let db = ctx.db;\n     let module = strukt.syntax().ancestors().find(|node| {\n         ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n@@ -162,8 +159,8 @@ fn find_struct_impl(ctx: &AssistCtx, strukt: &ast::StructDef) -> Option<Option<a\n \n fn has_new_fn(imp: &ast::ImplDef) -> bool {\n     if let Some(il) = imp.item_list() {\n-        for item in il.impl_items() {\n-            if let ast::ImplItem::FnDef(f) = item {\n+        for item in il.assoc_items() {\n+            if let ast::AssocItem::FnDef(f) = item {\n                 if let Some(name) = f.name() {\n                     if name.text().eq_ignore_ascii_case(\"new\") {\n                         return true;\n@@ -178,7 +175,7 @@ fn has_new_fn(imp: &ast::ImplDef) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n \n@@ -192,7 +189,7 @@ mod tests {\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -202,7 +199,7 @@ impl Foo {\n \"struct Foo<T: Clone> {}\n \n impl<T: Clone> Foo<T> {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -212,7 +209,7 @@ impl<T: Clone> Foo<T> {\n \"struct Foo<'a, T: Foo<'a>> {}\n \n impl<'a, T: Foo<'a>> Foo<'a, T> {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -222,7 +219,7 @@ impl<'a, T: Foo<'a>> Foo<'a, T> {\n \"struct Foo { baz: String }\n \n impl Foo {\n-    fn new(baz: String) -> Self { Self { baz } }<|>\n+    fn $0new(baz: String) -> Self { Self { baz } }\n }\n \",\n         );\n@@ -232,7 +229,7 @@ impl Foo {\n \"struct Foo { baz: String, qux: Vec<i32> }\n \n impl Foo {\n-    fn new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }<|>\n+    fn $0new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }\n }\n \",\n         );\n@@ -244,7 +241,7 @@ impl Foo {\n \"struct Foo { pub baz: String, pub qux: Vec<i32> }\n \n impl Foo {\n-    fn new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }<|>\n+    fn $0new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }\n }\n \",\n         );\n@@ -259,7 +256,7 @@ impl Foo {}\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -274,7 +271,7 @@ impl Foo {\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n \n     fn qux(&self) {}\n }\n@@ -295,7 +292,7 @@ impl Foo {\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n \n     fn qux(&self) {}\n     fn baz() -> i32 {\n@@ -312,7 +309,7 @@ impl Foo {\n \"pub struct Foo {}\n \n impl Foo {\n-    pub fn new() -> Self { Self {  } }<|>\n+    pub fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -322,7 +319,7 @@ impl Foo {\n \"pub(crate) struct Foo {}\n \n impl Foo {\n-    pub(crate) fn new() -> Self { Self {  } }<|>\n+    pub(crate) fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -415,7 +412,7 @@ pub struct Source<T> {\n }\n \n impl<T> Source<T> {\n-    pub fn new(file_id: HirFileId, ast: T) -> Self { Self { file_id, ast } }<|>\n+    pub fn $0new(file_id: HirFileId, ast: T) -> Self { Self { file_id, ast } }\n \n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n         Source { file_id: self.file_id, ast: f(self.ast) }"}, {"sha": "26acf81f284bedf453899dde13478df1e63c8c85", "filename": "crates/ra_assists/src/handlers/add_turbo_fish.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,134 @@\n+use ra_ide_db::defs::{classify_name_ref, Definition, NameRefClass};\n+use ra_syntax::{ast, AstNode, SyntaxKind, T};\n+use test_utils::mark;\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n+\n+// Assist: add_turbo_fish\n+//\n+// Adds `::<_>` to a call of a generic method or function.\n+//\n+// ```\n+// fn make<T>() -> T { todo!() }\n+// fn main() {\n+//     let x = make<|>();\n+// }\n+// ```\n+// ->\n+// ```\n+// fn make<T>() -> T { todo!() }\n+// fn main() {\n+//     let x = make::<${0:_}>();\n+// }\n+// ```\n+pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let ident = ctx.find_token_at_offset(SyntaxKind::IDENT)?;\n+    let next_token = ident.next_token()?;\n+    if next_token.kind() == T![::] {\n+        mark::hit!(add_turbo_fish_one_fish_is_enough);\n+        return None;\n+    }\n+    let name_ref = ast::NameRef::cast(ident.parent())?;\n+    let def = match classify_name_ref(&ctx.sema, &name_ref)? {\n+        NameRefClass::Definition(def) => def,\n+        NameRefClass::FieldShorthand { .. } => return None,\n+    };\n+    let fun = match def {\n+        Definition::ModuleDef(hir::ModuleDef::Function(it)) => it,\n+        _ => return None,\n+    };\n+    let generics = hir::GenericDef::Function(fun).params(ctx.sema.db);\n+    if generics.is_empty() {\n+        mark::hit!(add_turbo_fish_non_generic);\n+        return None;\n+    }\n+    acc.add(AssistId(\"add_turbo_fish\"), \"Add `::<>`\", ident.text_range(), |builder| {\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, ident.text_range().end(), \"::<${0:_}>\"),\n+            None => builder.insert(ident.text_range().end(), \"::<_>\"),\n+        }\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+    use test_utils::mark;\n+\n+    #[test]\n+    fn add_turbo_fish_function() {\n+        check_assist(\n+            add_turbo_fish,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make<|>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make::<${0:_}>();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_turbo_fish_method() {\n+        check_assist(\n+            add_turbo_fish,\n+            r#\"\n+struct S;\n+impl S {\n+    fn make<T>(&self) -> T {}\n+}\n+fn main() {\n+    S.make<|>();\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn make<T>(&self) -> T {}\n+}\n+fn main() {\n+    S.make::<${0:_}>();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_turbo_fish_one_fish_is_enough() {\n+        mark::check!(add_turbo_fish_one_fish_is_enough);\n+        check_assist_not_applicable(\n+            add_turbo_fish,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make<|>::<()>();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_turbo_fish_non_generic() {\n+        mark::check!(add_turbo_fish_non_generic);\n+        check_assist_not_applicable(\n+            add_turbo_fish,\n+            r#\"\n+fn make() -> () {}\n+fn main() {\n+    make<|>();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "233e8fb8e65ce2c91e3795648e764fd9675d70d3", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{utils::invert_boolean_expression, AssistContext, AssistId, Assists};\n \n // Assist: apply_demorgan\n //\n@@ -21,7 +21,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n //     if !(x == 4 && y) {}\n // }\n // ```\n-pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n@@ -39,8 +39,7 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n     let rhs_range = rhs.syntax().text_range();\n     let not_rhs = invert_boolean_expression(rhs);\n \n-    ctx.add_assist(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", |edit| {\n-        edit.target(op_range);\n+    acc.add(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n         edit.replace(op_range, opposite_op);\n         edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n         edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));\n@@ -60,26 +59,26 @@ fn opposite_logic_op(kind: ast::BinOp) -> Option<&'static str> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     #[test]\n     fn demorgan_turns_and_into_or() {\n-        check_assist(apply_demorgan, \"fn f() { !x &&<|> !x }\", \"fn f() { !(x ||<|> x) }\")\n+        check_assist(apply_demorgan, \"fn f() { !x &&<|> !x }\", \"fn f() { !(x || x) }\")\n     }\n \n     #[test]\n     fn demorgan_turns_or_into_and() {\n-        check_assist(apply_demorgan, \"fn f() { !x ||<|> !x }\", \"fn f() { !(x &&<|> x) }\")\n+        check_assist(apply_demorgan, \"fn f() { !x ||<|> !x }\", \"fn f() { !(x && x) }\")\n     }\n \n     #[test]\n     fn demorgan_removes_inequality() {\n-        check_assist(apply_demorgan, \"fn f() { x != x ||<|> !x }\", \"fn f() { !(x == x &&<|> x) }\")\n+        check_assist(apply_demorgan, \"fn f() { x != x ||<|> !x }\", \"fn f() { !(x == x && x) }\")\n     }\n \n     #[test]\n     fn demorgan_general_case() {\n-        check_assist(apply_demorgan, \"fn f() { x ||<|> x }\", \"fn f() { !(!x &&<|> !x) }\")\n+        check_assist(apply_demorgan, \"fn f() { x ||<|> x }\", \"fn f() { !(!x && !x) }\")\n     }\n \n     #[test]"}, {"sha": "edf96d50ec144de79f2453b3a1278a089e4776d8", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BTreeSet;\n \n+use either::Either;\n use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n@@ -12,12 +13,7 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashSet;\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n-use either::Either;\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists, GroupLabel};\n \n // Assist: auto_import\n //\n@@ -38,25 +34,32 @@ use either::Either;\n // }\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n-pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let auto_import_assets = AutoImportAssets::new(&ctx)?;\n     let proposed_imports = auto_import_assets.search_for_imports(ctx.db);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n-    let mut group = ctx.add_assist_group(auto_import_assets.get_import_group_message());\n+    let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n+    let group = auto_import_assets.get_import_group_message();\n     for import in proposed_imports {\n-        group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), |edit| {\n-            edit.target(auto_import_assets.syntax_under_caret.text_range());\n-            insert_use_statement(\n-                &auto_import_assets.syntax_under_caret,\n-                &import,\n-                edit.text_edit_builder(),\n-            );\n-        });\n-    }\n-    group.finish()\n+        acc.add_group(\n+            &group,\n+            AssistId(\"auto_import\"),\n+            format!(\"Import `{}`\", &import),\n+            range,\n+            |builder| {\n+                insert_use_statement(\n+                    &auto_import_assets.syntax_under_caret,\n+                    &import,\n+                    ctx,\n+                    builder.text_edit_builder(),\n+                );\n+            },\n+        );\n+    }\n+    Some(())\n }\n \n #[derive(Debug)]\n@@ -67,15 +70,15 @@ struct AutoImportAssets {\n }\n \n impl AutoImportAssets {\n-    fn new(ctx: &AssistCtx) -> Option<Self> {\n-        if let Some(path_under_caret) = ctx.find_node_at_offset::<ast::Path>() {\n+    fn new(ctx: &AssistContext) -> Option<Self> {\n+        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n             Self::for_regular_path(path_under_caret, &ctx)\n         } else {\n-            Self::for_method_call(ctx.find_node_at_offset()?, &ctx)\n+            Self::for_method_call(ctx.find_node_at_offset_with_descend()?, &ctx)\n         }\n     }\n \n-    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = method_call.syntax().to_owned();\n         let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n@@ -85,7 +88,7 @@ impl AutoImportAssets {\n         })\n     }\n \n-    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = path_under_caret.syntax().to_owned();\n         if syntax_under_caret.ancestors().find_map(ast::UseItem::cast).is_some() {\n             return None;\n@@ -108,8 +111,8 @@ impl AutoImportAssets {\n         }\n     }\n \n-    fn get_import_group_message(&self) -> String {\n-        match &self.import_candidate {\n+    fn get_import_group_message(&self) -> GroupLabel {\n+        let name = match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n             ImportCandidate::QualifierStart(qualifier_start) => {\n                 format!(\"Import {}\", qualifier_start)\n@@ -120,7 +123,8 @@ impl AutoImportAssets {\n             ImportCandidate::TraitMethod(_, trait_method_name) => {\n                 format!(\"Import a trait for method {}\", trait_method_name)\n             }\n-        }\n+        };\n+        GroupLabel(name)\n     }\n \n     fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n@@ -280,7 +284,7 @@ impl ImportCandidate {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn applicable_when_found_an_import() {\n@@ -294,7 +298,7 @@ mod tests {\n             }\n             \",\n             r\"\n-            <|>use PubMod::PubStruct;\n+            use PubMod::PubStruct;\n \n             PubStruct\n \n@@ -305,6 +309,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn applicable_when_found_an_import_in_macros() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            macro_rules! foo {\n+                ($i:ident) => { fn foo(a: $i) {} }\n+            }\n+            foo!(Pub<|>Struct);\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            use PubMod::PubStruct;\n+\n+            macro_rules! foo {\n+                ($i:ident) => { fn foo(a: $i) {} }\n+            }\n+            foo!(PubStruct);\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn auto_imports_are_merged() {\n         check_assist(\n@@ -327,7 +360,7 @@ mod tests {\n             use PubMod::{PubStruct2, PubStruct1};\n \n             struct Test {\n-                test: Pub<|>Struct2<u8>,\n+                test: PubStruct2<u8>,\n             }\n \n             pub mod PubMod {\n@@ -358,9 +391,9 @@ mod tests {\n             }\n             \",\n             r\"\n-            use PubMod1::PubStruct;\n+            use PubMod3::PubStruct;\n \n-            PubSt<|>ruct\n+            PubStruct\n \n             pub mod PubMod1 {\n                 pub struct PubStruct;\n@@ -441,7 +474,7 @@ mod tests {\n             r\"\n             use PubMod::test_function;\n \n-            test_function<|>\n+            test_function\n \n             pub mod PubMod {\n                 pub fn test_function() {};\n@@ -468,7 +501,7 @@ mod tests {\n             r\"use crate_with_macro::foo;\n \n fn main() {\n-    foo<|>\n+    foo\n }\n \",\n         );\n@@ -554,7 +587,7 @@ fn main() {\n             }\n \n             fn main() {\n-                TestStruct::test_function<|>\n+                TestStruct::test_function\n             }\n             \",\n         );\n@@ -587,7 +620,7 @@ fn main() {\n             }\n \n             fn main() {\n-                TestStruct::TEST_CONST<|>\n+                TestStruct::TEST_CONST\n             }\n             \",\n         );\n@@ -626,7 +659,7 @@ fn main() {\n             }\n \n             fn main() {\n-                test_mod::TestStruct::test_function<|>\n+                test_mod::TestStruct::test_function\n             }\n             \",\n         );\n@@ -697,7 +730,7 @@ fn main() {\n             }\n \n             fn main() {\n-                test_mod::TestStruct::TEST_CONST<|>\n+                test_mod::TestStruct::TEST_CONST\n             }\n             \",\n         );\n@@ -770,7 +803,7 @@ fn main() {\n \n             fn main() {\n                 let test_struct = test_mod::TestStruct {};\n-                test_struct.test_meth<|>od()\n+                test_struct.test_method()\n             }\n             \",\n         );"}, {"sha": "c6baa0a57c6c6d6eb5dd84c4ca1f93e9437e3b73", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "added", "additions": 961, "deletions": 0, "changes": 961, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,961 @@\n+use ra_syntax::{\n+    ast::{self, BlockExpr, Expr, LoopBodyOwner},\n+    AstNode, SyntaxNode,\n+};\n+\n+use crate::{AssistContext, AssistId, Assists};\n+\n+// Assist: change_return_type_to_result\n+//\n+// Change the function's return type to Result.\n+//\n+// ```\n+// fn foo() -> i32<|> { 42i32 }\n+// ```\n+// ->\n+// ```\n+// fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n+// ```\n+pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n+    // FIXME: extend to lambdas as well\n+    let fn_def = ret_type.syntax().parent().and_then(ast::FnDef::cast)?;\n+\n+    let type_ref = &ret_type.type_ref()?;\n+    if type_ref.syntax().text().to_string().starts_with(\"Result<\") {\n+        return None;\n+    }\n+\n+    let block_expr = &fn_def.body()?;\n+\n+    acc.add(\n+        AssistId(\"change_return_type_to_result\"),\n+        \"Change return type to Result\",\n+        type_ref.syntax().text_range(),\n+        |builder| {\n+            let mut tail_return_expr_collector = TailReturnCollector::new();\n+            tail_return_expr_collector.collect_jump_exprs(block_expr, false);\n+            tail_return_expr_collector.collect_tail_exprs(block_expr);\n+\n+            for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n+                builder.replace_node_and_indent(&ret_expr_arg, format!(\"Ok({})\", ret_expr_arg));\n+            }\n+\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snippet = format!(\"Result<{}, ${{0:_}}>\", type_ref);\n+                    builder.replace_snippet(cap, type_ref.syntax().text_range(), snippet)\n+                }\n+                None => builder\n+                    .replace(type_ref.syntax().text_range(), format!(\"Result<{}, _>\", type_ref)),\n+            }\n+        },\n+    )\n+}\n+\n+struct TailReturnCollector {\n+    exprs_to_wrap: Vec<SyntaxNode>,\n+}\n+\n+impl TailReturnCollector {\n+    fn new() -> Self {\n+        Self { exprs_to_wrap: vec![] }\n+    }\n+    /// Collect all`return` expression\n+    fn collect_jump_exprs(&mut self, block_expr: &BlockExpr, collect_break: bool) {\n+        let statements = block_expr.statements();\n+        for stmt in statements {\n+            let expr = match &stmt {\n+                ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+            };\n+            if let Some(expr) = &expr {\n+                self.handle_exprs(expr, collect_break);\n+            }\n+        }\n+\n+        // Browse tail expressions for each block\n+        if let Some(expr) = block_expr.expr() {\n+            if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n+                for last_expr in last_exprs {\n+                    let last_expr = match last_expr {\n+                        NodeType::Node(expr) | NodeType::Leaf(expr) => expr,\n+                    };\n+\n+                    if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n+                        self.handle_exprs(&last_expr, collect_break);\n+                    } else if let Some(expr_stmt) = ast::Stmt::cast(last_expr) {\n+                        let expr_stmt = match &expr_stmt {\n+                            ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                            ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                        };\n+                        if let Some(expr) = &expr_stmt {\n+                            self.handle_exprs(expr, collect_break);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn handle_exprs(&mut self, expr: &Expr, collect_break: bool) {\n+        match expr {\n+            Expr::BlockExpr(block_expr) => {\n+                self.collect_jump_exprs(&block_expr, collect_break);\n+            }\n+            Expr::ReturnExpr(ret_expr) => {\n+                if let Some(ret_expr_arg) = &ret_expr.expr() {\n+                    self.exprs_to_wrap.push(ret_expr_arg.syntax().clone());\n+                }\n+            }\n+            Expr::BreakExpr(break_expr) if collect_break => {\n+                if let Some(break_expr_arg) = &break_expr.expr() {\n+                    self.exprs_to_wrap.push(break_expr_arg.syntax().clone());\n+                }\n+            }\n+            Expr::IfExpr(if_expr) => {\n+                for block in if_expr.blocks() {\n+                    self.collect_jump_exprs(&block, collect_break);\n+                }\n+            }\n+            Expr::LoopExpr(loop_expr) => {\n+                if let Some(block_expr) = loop_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::ForExpr(for_expr) => {\n+                if let Some(block_expr) = for_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::WhileExpr(while_expr) => {\n+                if let Some(block_expr) = while_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::MatchExpr(match_expr) => {\n+                if let Some(arm_list) = match_expr.match_arm_list() {\n+                    arm_list.arms().filter_map(|match_arm| match_arm.expr()).for_each(|expr| {\n+                        self.handle_exprs(&expr, collect_break);\n+                    });\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn collect_tail_exprs(&mut self, block: &BlockExpr) {\n+        if let Some(expr) = block.expr() {\n+            self.handle_exprs(&expr, true);\n+            self.fetch_tail_exprs(&expr);\n+        }\n+    }\n+\n+    fn fetch_tail_exprs(&mut self, expr: &Expr) {\n+        if let Some(exprs) = get_tail_expr_from_block(expr) {\n+            for node_type in &exprs {\n+                match node_type {\n+                    NodeType::Leaf(expr) => {\n+                        self.exprs_to_wrap.push(expr.clone());\n+                    }\n+                    NodeType::Node(expr) => match &Expr::cast(expr.clone()) {\n+                        Some(last_expr) => {\n+                            self.fetch_tail_exprs(last_expr);\n+                        }\n+                        None => {\n+                            self.exprs_to_wrap.push(expr.clone());\n+                        }\n+                    },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum NodeType {\n+    Leaf(SyntaxNode),\n+    Node(SyntaxNode),\n+}\n+\n+/// Get a tail expression inside a block\n+fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n+    match expr {\n+        Expr::IfExpr(if_expr) => {\n+            let mut nodes = vec![];\n+            for block in if_expr.blocks() {\n+                if let Some(block_expr) = block.expr() {\n+                    if let Some(tail_exprs) = get_tail_expr_from_block(&block_expr) {\n+                        nodes.extend(tail_exprs);\n+                    }\n+                } else if let Some(last_expr) = block.syntax().last_child() {\n+                    nodes.push(NodeType::Node(last_expr));\n+                } else {\n+                    nodes.push(NodeType::Node(block.syntax().clone()));\n+                }\n+            }\n+            Some(nodes)\n+        }\n+        Expr::LoopExpr(loop_expr) => {\n+            loop_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::ForExpr(for_expr) => {\n+            for_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::WhileExpr(while_expr) => {\n+            while_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::BlockExpr(block_expr) => {\n+            block_expr.expr().map(|lc| vec![NodeType::Node(lc.syntax().clone())])\n+        }\n+        Expr::MatchExpr(match_expr) => {\n+            let arm_list = match_expr.match_arm_list()?;\n+            let arms: Vec<NodeType> = arm_list\n+                .arms()\n+                .filter_map(|match_arm| match_arm.expr())\n+                .map(|expr| match expr {\n+                    Expr::ReturnExpr(ret_expr) => NodeType::Node(ret_expr.syntax().clone()),\n+                    Expr::BreakExpr(break_expr) => NodeType::Node(break_expr.syntax().clone()),\n+                    _ => match expr.syntax().last_child() {\n+                        Some(last_expr) => NodeType::Node(last_expr),\n+                        None => NodeType::Node(expr.syntax().clone()),\n+                    },\n+                })\n+                .collect();\n+\n+            Some(arms)\n+        }\n+        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e.syntax().clone())]),\n+        Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n+        Expr::CallExpr(call_expr) => Some(vec![NodeType::Leaf(call_expr.syntax().clone())]),\n+        Expr::Literal(lit_expr) => Some(vec![NodeType::Leaf(lit_expr.syntax().clone())]),\n+        Expr::TupleExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::ArrayExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::ParenExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::PathExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::Label(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RecordLit(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::IndexExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::MethodCallExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::AwaitExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::CastExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RefExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::PrefixExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::RangeExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::BinExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::MacroCall(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        Expr::BoxExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+        _ => None,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn change_return_type_to_result_simple() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i3<|>2 {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_return_type() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_return_type_bad_cursor() {\n+        check_assist_not_applicable(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32 {\n+                let test = \"test\";<|>\n+                return 42i32;\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_cursor() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> <|>i32 {\n+                let test = \"test\";\n+                return 42i32;\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                return Ok(42i32);\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -><|> i32 {\n+                let test = \"test\";\n+                42i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                Ok(42i32)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_only() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                42i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                Ok(42i32)\n+            }\"#,\n+        );\n+    }\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                if true {\n+                    42i32\n+                } else {\n+                    24i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                if true {\n+                    Ok(42i32)\n+                } else {\n+                    Ok(24i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_nested_if() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                if true {\n+                    if false {\n+                        1\n+                    } else {\n+                        2\n+                    }\n+                } else {\n+                    24i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                if true {\n+                    if false {\n+                        Ok(1)\n+                    } else {\n+                        Ok(2)\n+                    }\n+                } else {\n+                    Ok(24i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_await() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"async fn foo() -> i<|>32 {\n+                if true {\n+                    if false {\n+                        1.await\n+                    } else {\n+                        2.await\n+                    }\n+                } else {\n+                    24i32.await\n+                }\n+            }\"#,\n+            r#\"async fn foo() -> Result<i32, ${0:_}> {\n+                if true {\n+                    if false {\n+                        Ok(1.await)\n+                    } else {\n+                        Ok(2.await)\n+                    }\n+                } else {\n+                    Ok(24i32.await)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_array() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> [i32;<|> 3] {\n+                [1, 2, 3]\n+            }\"#,\n+            r#\"fn foo() -> Result<[i32; 3], ${0:_}> {\n+                Ok([1, 2, 3])\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_cast() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -<|>> i32 {\n+                if true {\n+                    if false {\n+                        1 as i32\n+                    } else {\n+                        2 as i32\n+                    }\n+                } else {\n+                    24 as i32\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                if true {\n+                    if false {\n+                        Ok(1 as i32)\n+                    } else {\n+                        Ok(2 as i32)\n+                    }\n+                } else {\n+                    Ok(24 as i32)\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => 42i32,\n+                    _ => 24i32,\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => Ok(42i32),\n+                    _ => Ok(24i32),\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_loop_with_tail() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                loop {\n+                    println!(\"test\");\n+                    5\n+                }\n+\n+                my_var\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let my_var = 5;\n+                loop {\n+                    println!(\"test\");\n+                    5\n+                }\n+\n+                Ok(my_var)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_loop_in_let_stmt() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = let x = loop {\n+                    break 1;\n+                };\n+\n+                my_var\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let my_var = let x = loop {\n+                    break 1;\n+                };\n+\n+                Ok(my_var)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match_return_expr() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                let res = match my_var {\n+                    5 => 42i32,\n+                    _ => return 24i32,\n+                };\n+\n+                res\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let my_var = 5;\n+                let res = match my_var {\n+                    5 => 42i32,\n+                    _ => return Ok(24i32),\n+                };\n+\n+                Ok(res)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                let res = if my_var == 5 {\n+                    42i32\n+                } else {\n+                    return 24i32;\n+                };\n+\n+                res\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let my_var = 5;\n+                let res = if my_var == 5 {\n+                    42i32\n+                } else {\n+                    return Ok(24i32);\n+                };\n+\n+                Ok(res)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_match_deeper() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => {\n+                        if true {\n+                            42i32\n+                        } else {\n+                            25i32\n+                        }\n+                    },\n+                    _ => {\n+                        let test = \"test\";\n+                        if test == \"test\" {\n+                            return bar();\n+                        }\n+                        53i32\n+                    },\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let my_var = 5;\n+                match my_var {\n+                    5 => {\n+                        if true {\n+                            Ok(42i32)\n+                        } else {\n+                            Ok(25i32)\n+                        }\n+                    },\n+                    _ => {\n+                        let test = \"test\";\n+                        if test == \"test\" {\n+                            return Ok(bar());\n+                        }\n+                        Ok(53i32)\n+                    },\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_tail_block_like_early_return() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i<|>32 {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                53i32\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                Ok(53i32)\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_closure() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -><|> u32 {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+                let t = None;\n+\n+                t.unwrap_or_else(|| the_field)\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+                let t = None;\n+\n+                Ok(t.unwrap_or_else(|| the_field))\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn change_return_type_to_result_simple_with_weird_forms() {\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                let mut i = 0;\n+                loop {\n+                    if i == 1 {\n+                        break 55;\n+                    }\n+                    i += 1;\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                let mut i = 0;\n+                loop {\n+                    if i == 1 {\n+                        break Ok(55);\n+                    }\n+                    i += 1;\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i32<|> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return 24i32;\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break 55;\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                if test == \"test\" {\n+                    return Ok(24i32);\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break Ok(55);\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo() -> i3<|>2 {\n+                let test = \"test\";\n+                let other = 5;\n+                if test == \"test\" {\n+                    let res = match other {\n+                        5 => 43,\n+                        _ => return 56,\n+                    };\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break 55;\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n+                let test = \"test\";\n+                let other = 5;\n+                if test == \"test\" {\n+                    let res = match other {\n+                        5 => 43,\n+                        _ => return Ok(56),\n+                    };\n+                }\n+                let mut i = 0;\n+                loop {\n+                    loop {\n+                        if i == 1 {\n+                            break Ok(55);\n+                        }\n+                        i += 1;\n+                    }\n+                }\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+                    loop {\n+                        if i > 5 {\n+                            return 55u32;\n+                        }\n+                        i += 3;\n+                    }\n+\n+                    match i {\n+                        5 => return 99,\n+                        _ => return 0,\n+                    };\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+                    loop {\n+                        if i > 5 {\n+                            return Ok(55u32);\n+                        }\n+                        i += 3;\n+                    }\n+\n+                    match i {\n+                        5 => return Ok(99),\n+                        _ => return Ok(0),\n+                    };\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u3<|>2 {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    match i {\n+                        5 => return 99,\n+                        _ => return 0,\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    match i {\n+                        5 => return Ok(99),\n+                        _ => return Ok(0),\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> u32<|> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return 99\n+                    } else {\n+                        return 0\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return Ok(99)\n+                    } else {\n+                        return Ok(0)\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+\n+        check_assist(\n+            change_return_type_to_result,\n+            r#\"fn foo(the_field: u32) -> <|>u32 {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+\n+                the_field\n+            }\"#,\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+                    if i == 5 {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+\n+                Ok(the_field)\n+            }\"#,\n+        );\n+    }\n+}"}, {"sha": "c21d75be080ca760b3074fbeda173963378032d7", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 55, "deletions": 41, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -7,9 +7,9 @@ use ra_syntax::{\n     },\n     SyntaxNode, TextSize, T,\n };\n+use test_utils::mark;\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use test_utils::tested_by;\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: change_visibility\n //\n@@ -22,14 +22,14 @@ use test_utils::tested_by;\n // ```\n // pub(crate) fn frobnicate() {}\n // ```\n-pub(crate) fn change_visibility(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {\n-        return change_vis(ctx, vis);\n+        return change_vis(acc, vis);\n     }\n-    add_vis(ctx)\n+    add_vis(acc, ctx)\n }\n \n-fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n+fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| match leaf.kind() {\n         T![const] | T![fn] | T![mod] | T![struct] | T![enum] | T![trait] => true,\n         _ => false,\n@@ -47,23 +47,27 @@ fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n             return None;\n         }\n         (vis_offset(&parent), keyword.text_range())\n-    } else {\n-        let field_name: ast::Name = ctx.find_node_at_offset()?;\n+    } else if let Some(field_name) = ctx.find_node_at_offset::<ast::Name>() {\n         let field = field_name.syntax().ancestors().find_map(ast::RecordFieldDef::cast)?;\n         if field.name()? != field_name {\n-            tested_by!(change_visibility_field_false_positive);\n+            mark::hit!(change_visibility_field_false_positive);\n             return None;\n         }\n         if field.visibility().is_some() {\n             return None;\n         }\n         (vis_offset(field.syntax()), field_name.syntax().text_range())\n+    } else if let Some(field) = ctx.find_node_at_offset::<ast::TupleFieldDef>() {\n+        if field.visibility().is_some() {\n+            return None;\n+        }\n+        (vis_offset(field.syntax()), field.syntax().text_range())\n+    } else {\n+        return None;\n     };\n \n-    ctx.add_assist(AssistId(\"change_visibility\"), \"Change visibility to pub(crate)\", |edit| {\n-        edit.target(target);\n+    acc.add(AssistId(\"change_visibility\"), \"Change visibility to pub(crate)\", target, |edit| {\n         edit.insert(offset, \"pub(crate) \");\n-        edit.set_cursor(offset);\n     })\n }\n \n@@ -78,63 +82,64 @@ fn vis_offset(node: &SyntaxNode) -> TextSize {\n         .unwrap_or_else(|| node.text_range().start())\n }\n \n-fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n     if vis.syntax().text() == \"pub\" {\n-        return ctx.add_assist(\n+        let target = vis.syntax().text_range();\n+        return acc.add(\n             AssistId(\"change_visibility\"),\n             \"Change Visibility to pub(crate)\",\n+            target,\n             |edit| {\n-                edit.target(vis.syntax().text_range());\n                 edit.replace(vis.syntax().text_range(), \"pub(crate)\");\n-                edit.set_cursor(vis.syntax().text_range().start())\n             },\n         );\n     }\n     if vis.syntax().text() == \"pub(crate)\" {\n-        return ctx.add_assist(AssistId(\"change_visibility\"), \"Change visibility to pub\", |edit| {\n-            edit.target(vis.syntax().text_range());\n-            edit.replace(vis.syntax().text_range(), \"pub\");\n-            edit.set_cursor(vis.syntax().text_range().start());\n-        });\n+        let target = vis.syntax().text_range();\n+        return acc.add(\n+            AssistId(\"change_visibility\"),\n+            \"Change visibility to pub\",\n+            target,\n+            |edit| {\n+                edit.replace(vis.syntax().text_range(), \"pub\");\n+            },\n+        );\n     }\n     None\n }\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n \n     #[test]\n     fn change_visibility_adds_pub_crate_to_items() {\n-        check_assist(change_visibility, \"<|>fn foo() {}\", \"<|>pub(crate) fn foo() {}\");\n-        check_assist(change_visibility, \"f<|>n foo() {}\", \"<|>pub(crate) fn foo() {}\");\n-        check_assist(change_visibility, \"<|>struct Foo {}\", \"<|>pub(crate) struct Foo {}\");\n-        check_assist(change_visibility, \"<|>mod foo {}\", \"<|>pub(crate) mod foo {}\");\n-        check_assist(change_visibility, \"<|>trait Foo {}\", \"<|>pub(crate) trait Foo {}\");\n-        check_assist(change_visibility, \"m<|>od {}\", \"<|>pub(crate) mod {}\");\n-        check_assist(\n-            change_visibility,\n-            \"unsafe f<|>n foo() {}\",\n-            \"<|>pub(crate) unsafe fn foo() {}\",\n-        );\n+        check_assist(change_visibility, \"<|>fn foo() {}\", \"pub(crate) fn foo() {}\");\n+        check_assist(change_visibility, \"f<|>n foo() {}\", \"pub(crate) fn foo() {}\");\n+        check_assist(change_visibility, \"<|>struct Foo {}\", \"pub(crate) struct Foo {}\");\n+        check_assist(change_visibility, \"<|>mod foo {}\", \"pub(crate) mod foo {}\");\n+        check_assist(change_visibility, \"<|>trait Foo {}\", \"pub(crate) trait Foo {}\");\n+        check_assist(change_visibility, \"m<|>od {}\", \"pub(crate) mod {}\");\n+        check_assist(change_visibility, \"unsafe f<|>n foo() {}\", \"pub(crate) unsafe fn foo() {}\");\n     }\n \n     #[test]\n     fn change_visibility_works_with_struct_fields() {\n         check_assist(\n             change_visibility,\n             r\"struct S { <|>field: u32 }\",\n-            r\"struct S { <|>pub(crate) field: u32 }\",\n-        )\n+            r\"struct S { pub(crate) field: u32 }\",\n+        );\n+        check_assist(change_visibility, r\"struct S ( <|>u32 )\", r\"struct S ( pub(crate) u32 )\");\n     }\n \n     #[test]\n     fn change_visibility_field_false_positive() {\n-        covers!(change_visibility_field_false_positive);\n+        mark::check!(change_visibility_field_false_positive);\n         check_assist_not_applicable(\n             change_visibility,\n             r\"struct S { field: [(); { let <|>x = ();}] }\",\n@@ -143,17 +148,17 @@ mod tests {\n \n     #[test]\n     fn change_visibility_pub_to_pub_crate() {\n-        check_assist(change_visibility, \"<|>pub fn foo() {}\", \"<|>pub(crate) fn foo() {}\")\n+        check_assist(change_visibility, \"<|>pub fn foo() {}\", \"pub(crate) fn foo() {}\")\n     }\n \n     #[test]\n     fn change_visibility_pub_crate_to_pub() {\n-        check_assist(change_visibility, \"<|>pub(crate) fn foo() {}\", \"<|>pub fn foo() {}\")\n+        check_assist(change_visibility, \"<|>pub(crate) fn foo() {}\", \"pub fn foo() {}\")\n     }\n \n     #[test]\n     fn change_visibility_const() {\n-        check_assist(change_visibility, \"<|>const FOO = 3u8;\", \"<|>pub(crate) const FOO = 3u8;\");\n+        check_assist(change_visibility, \"<|>const FOO = 3u8;\", \"pub(crate) const FOO = 3u8;\");\n     }\n \n     #[test]\n@@ -174,11 +179,20 @@ mod tests {\n             // comments\n \n             #[derive(Debug)]\n-            <|>pub(crate) struct Foo;\n+            pub(crate) struct Foo;\n             \",\n         )\n     }\n \n+    #[test]\n+    fn not_applicable_for_enum_variants() {\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub enum Foo {Foo1} }\n+              fn main() { foo::Foo::Foo1<|> } \",\n+        );\n+    }\n+\n     #[test]\n     fn change_visibility_target() {\n         check_assist_target(change_visibility, \"<|>fn foo() {}\", \"fn\");"}, {"sha": "4cc75a7ce2dcda9733ff936908485520aa0b0808", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -2,14 +2,18 @@ use std::{iter::once, ops::RangeInclusive};\n \n use ra_syntax::{\n     algo::replace_children,\n-    ast::{self, edit::IndentLevel, make, Block, Pat::TupleStructPat},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make,\n+    },\n     AstNode,\n     SyntaxKind::{FN_DEF, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n     SyntaxNode,\n };\n \n use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n+    assist_context::{AssistContext, Assists},\n     utils::invert_boolean_expression,\n     AssistId,\n };\n@@ -36,7 +40,7 @@ use crate::{\n //     bar();\n // }\n // ```\n-pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -47,7 +51,7 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n     // Check if there is an IfLet that we can handle.\n     let if_let_pat = match cond.pat() {\n         None => None, // No IfLet, supported.\n-        Some(TupleStructPat(pat)) if pat.args().count() == 1 => {\n+        Some(ast::Pat::TupleStructPat(pat)) if pat.args().count() == 1 => {\n             let path = pat.path()?;\n             match path.qualifier() {\n                 None => {\n@@ -61,9 +65,9 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let cond_expr = cond.expr()?;\n-    let then_block = if_expr.then_branch()?.block()?;\n+    let then_block = if_expr.then_branch()?;\n \n-    let parent_block = if_expr.syntax().parent()?.ancestors().find_map(ast::Block::cast)?;\n+    let parent_block = if_expr.syntax().parent()?.ancestors().find_map(ast::BlockExpr::cast)?;\n \n     if parent_block.expr()? != if_expr.clone().into() {\n         return None;\n@@ -80,7 +84,7 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    let parent_container = parent_block.syntax().parent()?.parent()?;\n+    let parent_container = parent_block.syntax().parent()?;\n \n     let early_expression: ast::Expr = match parent_container.kind() {\n         WHILE_EXPR | LOOP_EXPR => make::expr_continue(),\n@@ -93,9 +97,9 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n-    let cursor_position = ctx.frange.range.start();\n \n-    ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"Convert to guarded return\", |edit| {\n+    let target = if_expr.syntax().text_range();\n+    acc.add(AssistId(\"convert_to_guarded_return\"), \"Convert to guarded return\", target, |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n         let new_block = match if_let_pat {\n             None => {\n@@ -104,8 +108,7 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n                     let then_branch =\n                         make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n                     let cond = invert_boolean_expression(cond_expr);\n-                    let e = make::expr_if(make::condition(cond, None), then_branch);\n-                    if_indent_level.increase_indent(e)\n+                    make::expr_if(make::condition(cond, None), then_branch).indent(if_indent_level)\n                 };\n                 replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n             }\n@@ -139,21 +142,19 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n                     make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n                     Some(match_expr),\n                 );\n-                let let_stmt = if_indent_level.increase_indent(let_stmt);\n+                let let_stmt = let_stmt.indent(if_indent_level);\n                 replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n             }\n         };\n-        edit.target(if_expr.syntax().text_range());\n-        edit.replace_ast(parent_block, ast::Block::cast(new_block).unwrap());\n-        edit.set_cursor(cursor_position);\n+        edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n \n         fn replace(\n             new_expr: &SyntaxNode,\n-            then_block: &Block,\n-            parent_block: &Block,\n+            then_block: &ast::BlockExpr,\n+            parent_block: &ast::BlockExpr,\n             if_expr: &ast::IfExpr,\n         ) -> SyntaxNode {\n-            let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n+            let then_block_items = then_block.dedent(IndentLevel::from(1));\n             let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n             let end_of_then =\n                 if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n@@ -182,7 +183,7 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -204,7 +205,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 bar();\n-                if<|> !true {\n+                if !true {\n                     return;\n                 }\n                 foo();\n@@ -234,7 +235,7 @@ mod tests {\n             r#\"\n             fn main(n: Option<String>) {\n                 bar();\n-                le<|>t n = match n {\n+                let n = match n {\n                     Some(it) => it,\n                     _ => return,\n                 };\n@@ -260,7 +261,7 @@ mod tests {\n             \"#,\n             r#\"\n             fn main() {\n-                le<|>t x = match Err(92) {\n+                let x = match Err(92) {\n                     Ok(it) => it,\n                     _ => return,\n                 };\n@@ -288,7 +289,7 @@ mod tests {\n             r#\"\n             fn main(n: Option<String>) {\n                 bar();\n-                le<|>t n = match n {\n+                let n = match n {\n                     Ok(it) => it,\n                     _ => return,\n                 };\n@@ -318,7 +319,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 while true {\n-                    if<|> !true {\n+                    if !true {\n                         continue;\n                     }\n                     foo();\n@@ -346,7 +347,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 while true {\n-                    le<|>t n = match n {\n+                    let n = match n {\n                         Some(it) => it,\n                         _ => continue,\n                     };\n@@ -375,7 +376,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 loop {\n-                    if<|> !true {\n+                    if !true {\n                         continue;\n                     }\n                     foo();\n@@ -403,7 +404,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 loop {\n-                    le<|>t n = match n {\n+                    let n = match n {\n                         Some(it) => it,\n                         _ => continue,\n                     };"}, {"sha": "cc303285b35d77d2d235676bc9e287f1265e8115", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 117, "deletions": 120, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,8 +4,12 @@ use hir::{Adt, HasSource, ModuleDef, Semantics};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n+use test_utils::mark;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    utils::{render_snippet, Cursor, FamousDefs},\n+    AssistContext, AssistId, Assists,\n+};\n \n // Assist: fill_match_arms\n //\n@@ -26,12 +30,12 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // fn handle(action: Action) {\n //     match action {\n-//         Action::Move { distance } => {}\n+//         $0Action::Move { distance } => {}\n //         Action::Stop => {}\n //     }\n // }\n // ```\n-pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n \n@@ -49,12 +53,18 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n         let variants = enum_def.variants(ctx.db);\n \n-        variants\n+        let mut variants = variants\n             .into_iter()\n             .filter_map(|variant| build_pat(ctx.db, module, variant))\n             .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n-            .collect()\n+            .collect::<Vec<_>>();\n+        if Some(enum_def) == FamousDefs(&ctx.sema, module.krate()).core_option_Option() {\n+            // Match `Some` variant first.\n+            mark::hit!(option_order);\n+            variants.reverse()\n+        }\n+        variants\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n         // Partial fill not currently supported for tuple of enums.\n         if !arms.is_empty() {\n@@ -92,12 +102,24 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", |edit| {\n-        let new_arm_list = match_arm_list.remove_placeholder().append_arms(missing_arms);\n-\n-        edit.target(match_expr.syntax().text_range());\n-        edit.set_cursor(expr.syntax().text_range().start());\n-        edit.replace_ast(match_arm_list, new_arm_list);\n+    let target = match_expr.syntax().text_range();\n+    acc.add(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |builder| {\n+        let new_arm_list = match_arm_list.remove_placeholder();\n+        let n_old_arms = new_arm_list.arms().count();\n+        let new_arm_list = new_arm_list.append_arms(missing_arms);\n+        let first_new_arm = new_arm_list.arms().nth(n_old_arms);\n+        let old_range = match_arm_list.syntax().text_range();\n+        match (first_new_arm, ctx.config.snippet_cap) {\n+            (Some(first_new_arm), Some(cap)) => {\n+                let snippet = render_snippet(\n+                    cap,\n+                    new_arm_list.syntax(),\n+                    Cursor::Before(first_new_arm.syntax()),\n+                );\n+                builder.replace_snippet(cap, old_range, snippet);\n+            }\n+            _ => builder.replace(old_range, new_arm_list.to_string()),\n+        }\n     })\n }\n \n@@ -168,7 +190,12 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> O\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use test_utils::mark;\n+\n+    use crate::{\n+        tests::{check_assist, check_assist_not_applicable, check_assist_target},\n+        utils::FamousDefs,\n+    };\n \n     use super::fill_match_arms;\n \n@@ -215,27 +242,27 @@ mod tests {\n             r#\"\n             enum A {\n                 As,\n-                Bs{x:i32, y:Option<i32>},\n+                Bs { x: i32, y: Option<i32> },\n                 Cs(i32, Option<i32>),\n             }\n             fn main() {\n                 match A::As<|> {\n-                    A::Bs{x,y:Some(_)} => {}\n+                    A::Bs { x, y: Some(_) } => {}\n                     A::Cs(_, Some(_)) => {}\n                 }\n             }\n             \"#,\n             r#\"\n             enum A {\n                 As,\n-                Bs{x:i32, y:Option<i32>},\n+                Bs { x: i32, y: Option<i32> },\n                 Cs(i32, Option<i32>),\n             }\n             fn main() {\n-                match <|>A::As {\n-                    A::Bs{x,y:Some(_)} => {}\n+                match A::As {\n+                    A::Bs { x, y: Some(_) } => {}\n                     A::Cs(_, Some(_)) => {}\n-                    A::As => {}\n+                    $0A::As => {}\n                 }\n             }\n             \"#,\n@@ -265,9 +292,9 @@ mod tests {\n                 Cs(Option<i32>),\n             }\n             fn main() {\n-                match <|>A::As {\n+                match A::As {\n                     A::Cs(_) | A::Bs => {}\n-                    A::As => {}\n+                    $0A::As => {}\n                 }\n             }\n             \"#,\n@@ -311,11 +338,11 @@ mod tests {\n                 Ys,\n             }\n             fn main() {\n-                match <|>A::As {\n+                match A::As {\n                     A::Bs if 0 < 1 => {}\n                     A::Ds(_value) => { let x = 1; }\n                     A::Es(B::Xs) => (),\n-                    A::As => {}\n+                    $0A::As => {}\n                     A::Cs => {}\n                 }\n             }\n@@ -333,7 +360,7 @@ mod tests {\n                 Bs,\n                 Cs(String),\n                 Ds(String, String),\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn main() {\n@@ -347,13 +374,13 @@ mod tests {\n                 Bs,\n                 Cs(String),\n                 Ds(String, String),\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn main() {\n                 let a = A::As;\n-                match <|>a {\n-                    A::As => {}\n+                match a {\n+                    $0A::As => {}\n                     A::Bs => {}\n                     A::Cs(_) => {}\n                     A::Ds(_, _) => {}\n@@ -369,14 +396,8 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -385,20 +406,14 @@ mod tests {\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n                 let b = B::One;\n-                match <|>(a, b) {\n-                    (A::One, B::One) => {}\n+                match (a, b) {\n+                    $0(A::One, B::One) => {}\n                     (A::One, B::Two) => {}\n                     (A::Two, B::One) => {}\n                     (A::Two, B::Two) => {}\n@@ -413,14 +428,8 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -429,20 +438,14 @@ mod tests {\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n                 let b = B::One;\n-                match <|>(&a, &b) {\n-                    (A::One, B::One) => {}\n+                match (&a, &b) {\n+                    $0(A::One, B::One) => {}\n                     (A::One, B::Two) => {}\n                     (A::Two, B::One) => {}\n                     (A::Two, B::Two) => {}\n@@ -457,14 +460,8 @@ mod tests {\n         check_assist_not_applicable(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -482,14 +479,8 @@ mod tests {\n         check_assist_not_applicable(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -513,10 +504,7 @@ mod tests {\n         check_assist_not_applicable(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -532,23 +520,19 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                As,\n-            }\n+            enum A { As }\n \n             fn foo(a: &A) {\n                 match a<|> {\n                 }\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                As,\n-            }\n+            enum A { As }\n \n             fn foo(a: &A) {\n-                match <|>a {\n-                    A::As => {}\n+                match a {\n+                    $0A::As => {}\n                 }\n             }\n             \"#,\n@@ -558,7 +542,7 @@ mod tests {\n             fill_match_arms,\n             r#\"\n             enum A {\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn foo(a: &mut A) {\n@@ -568,12 +552,12 @@ mod tests {\n             \"#,\n             r#\"\n             enum A {\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn foo(a: &mut A) {\n-                match <|>a {\n-                    A::Es { x, y } => {}\n+                match a {\n+                    $0A::Es { x, y } => {}\n                 }\n             }\n             \"#,\n@@ -612,8 +596,8 @@ mod tests {\n             enum E { X, Y }\n \n             fn main() {\n-                match <|>E::X {\n-                    E::X => {}\n+                match E::X {\n+                    $0E::X => {}\n                     E::Y => {}\n                 }\n             }\n@@ -640,8 +624,8 @@ mod tests {\n             use foo::E::X;\n \n             fn main() {\n-                match <|>X {\n-                    X => {}\n+                match X {\n+                    $0X => {}\n                     foo::E::Y => {}\n                 }\n             }\n@@ -654,10 +638,7 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n                 match a {\n                     // foo bar baz<|>\n@@ -667,16 +648,13 @@ mod tests {\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n-                match <|>a {\n+                match a {\n                     // foo bar baz\n                     A::One => {}\n                     // This is where the rest should be\n-                    A::Two => {}\n+                    $0A::Two => {}\n                 }\n             }\n             \"#,\n@@ -688,25 +666,19 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n                 match a {\n                     // foo bar baz<|>\n                 }\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n-                match <|>a {\n+                match a {\n                     // foo bar baz\n-                    A::One => {}\n+                    $0A::One => {}\n                     A::Two => {}\n                 }\n             }\n@@ -729,12 +701,37 @@ mod tests {\n             r#\"\n             enum A { One, Two, }\n             fn foo(a: A) {\n-                match <|>a {\n-                    A::One => {}\n+                match a {\n+                    $0A::One => {}\n                     A::Two => {}\n                 }\n             }\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn option_order() {\n+        mark::check!(option_order);\n+        let before = r#\"\n+fn foo(opt: Option<i32>) {\n+    match opt<|> {\n+    }\n+}\"#;\n+        let before =\n+            &format!(\"//- main.rs crate:main deps:core\\n{}{}\", before, FamousDefs::FIXTURE);\n+\n+        check_assist(\n+            fill_match_arms,\n+            before,\n+            r#\"\n+fn foo(opt: Option<i32>) {\n+    match opt {\n+        $0Some(_) => {}\n+        None => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "9ec42f568c5957ca17ba21992a03fab4f522f5f6", "filename": "crates/ra_assists/src/handlers/fix_visibility.rs", "status": "added", "additions": 559, "deletions": 0, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,559 @@\n+use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n+use ra_db::FileId;\n+use ra_syntax::{\n+    ast, AstNode,\n+    SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n+    SyntaxNode, TextRange, TextSize,\n+};\n+\n+use crate::{AssistContext, AssistId, Assists};\n+\n+// FIXME: this really should be a fix for diagnostic, rather than an assist.\n+\n+// Assist: fix_visibility\n+//\n+// Makes inaccessible item public.\n+//\n+// ```\n+// mod m {\n+//     fn frobnicate() {}\n+// }\n+// fn main() {\n+//     m::frobnicate<|>() {}\n+// }\n+// ```\n+// ->\n+// ```\n+// mod m {\n+//     $0pub(crate) fn frobnicate() {}\n+// }\n+// fn main() {\n+//     m::frobnicate() {}\n+// }\n+// ```\n+pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    add_vis_to_referenced_module_def(acc, ctx)\n+        .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n+}\n+\n+fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let path_res = ctx.sema.resolve_path(&path)?;\n+    let def = match path_res {\n+        PathResolution::Def(def) => def,\n+        _ => return None,\n+    };\n+\n+    let current_module = ctx.sema.scope(&path.syntax()).module()?;\n+    let target_module = def.module(ctx.db)?;\n+\n+    let vis = target_module.visibility_of(ctx.db, &def)?;\n+    if vis.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    };\n+\n+    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+\n+    let assist_label = match target_name {\n+        None => format!(\"Change visibility to {}\", missing_visibility),\n+        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n+    };\n+\n+    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n+        builder.set_file(target_file);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+            None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+        }\n+    })\n+}\n+\n+fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n+    let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n+\n+    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n+    let visibility = record_field_def.visibility(ctx.db);\n+    if visibility.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    }\n+\n+    let parent = record_field_def.parent_def(ctx.db);\n+    let parent_name = parent.name(ctx.db);\n+    let target_module = parent.module(ctx.db);\n+\n+    let in_file_source = record_field_def.source(ctx.db);\n+    let (offset, target) = match in_file_source.value {\n+        hir::FieldSource::Named(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+        hir::FieldSource::Pos(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+    };\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+    let target_file = in_file_source.file_id.original_file(ctx.db);\n+\n+    let target_name = record_field_def.name(ctx.db);\n+    let assist_label =\n+        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n+\n+    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n+        builder.set_file(target_file);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+            None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+        }\n+    })\n+}\n+\n+fn target_data_for_def(\n+    db: &dyn HirDatabase,\n+    def: hir::ModuleDef,\n+) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n+    fn offset_target_and_file_id<S, Ast>(\n+        db: &dyn HirDatabase,\n+        x: S,\n+    ) -> (TextSize, TextRange, FileId)\n+    where\n+        S: HasSource<Ast = Ast>,\n+        Ast: AstNode,\n+    {\n+        let source = x.source(db);\n+        let in_file_syntax = source.syntax();\n+        let file_id = in_file_syntax.file_id;\n+        let syntax = in_file_syntax.value;\n+        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n+    }\n+\n+    let target_name;\n+    let (offset, target, target_file) = match def {\n+        hir::ModuleDef::Function(f) => {\n+            target_name = Some(f.name(db));\n+            offset_target_and_file_id(db, f)\n+        }\n+        hir::ModuleDef::Adt(adt) => {\n+            target_name = Some(adt.name(db));\n+            match adt {\n+                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n+                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n+                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n+            }\n+        }\n+        hir::ModuleDef::Const(c) => {\n+            target_name = c.name(db);\n+            offset_target_and_file_id(db, c)\n+        }\n+        hir::ModuleDef::Static(s) => {\n+            target_name = s.name(db);\n+            offset_target_and_file_id(db, s)\n+        }\n+        hir::ModuleDef::Trait(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::TypeAlias(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::Module(m) => {\n+            target_name = m.name(db);\n+            let in_file_source = m.declaration_source(db)?;\n+            let file_id = in_file_source.file_id.original_file(db.upcast());\n+            let syntax = in_file_source.value.syntax();\n+            (vis_offset(syntax), syntax.text_range(), file_id)\n+        }\n+        // Enum variants can't be private, we can't modify builtin types\n+        hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n+    };\n+\n+    Some((offset, target, target_file, target_name))\n+}\n+\n+fn vis_offset(node: &SyntaxNode) -> TextSize {\n+    node.children_with_tokens()\n+        .skip_while(|it| match it.kind() {\n+            WHITESPACE | COMMENT | ATTR => true,\n+            _ => false,\n+        })\n+        .next()\n+        .map(|it| it.text_range().start())\n+        .unwrap_or_else(|| node.text_range().start())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn fix_visibility_of_fn() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+            r\"mod foo { $0pub(crate) fn foo() {} }\n+              fn main() { foo::foo() } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+        )\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_adt_in_submodule() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { $0pub(crate) struct Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { $0pub(crate) enum Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { $0pub(crate) union Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_adt_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+              //- /main.rs\n+              mod foo;\n+              fn main() { foo::Foo<|> }\n+\n+              //- /foo.rs\n+              struct Foo;\n+              \",\n+            r\"$0pub(crate) struct Foo;\n+\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_struct_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub struct Foo { $0pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { bar: () }\n+              \",\n+            r\"pub struct Foo { $0pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_enum_variant_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub enum Foo { Bar { bar: () } } }\n+              fn main() { foo::Foo::Bar { <|>bar: () }; } \",\n+            r\"mod foo { pub enum Foo { Bar { $0pub(crate) bar: () } } }\n+              fn main() { foo::Foo::Bar { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo::Bar { <|>bar: () }; }\n+              //- /foo.rs\n+              pub enum Foo { Bar { bar: () } }\n+              \",\n+            r\"pub enum Foo { Bar { $0pub(crate) bar: () } }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME reenable this test when `Semantics::resolve_record_field` works with union fields\n+    fn fix_visibility_of_union_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub union Foo { $0pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { bar: () }\n+              \",\n+            r\"pub union Foo { $0pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_const() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { $0pub(crate) const FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_static() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { $0pub(crate) static FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_trait() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::<|>Foo; } \",\n+            r\"mod foo { $0pub(crate) trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_type_alias() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+            r\"mod foo { $0pub(crate) type Foo = (); }\n+              fn main() { let x: foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_module() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { mod bar { fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+            r\"mod foo { $0pub(crate) mod bar { fn bar() {} } }\n+              fn main() { foo::bar::bar(); } \",\n+        );\n+\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar {\n+                pub fn baz() {}\n+            }\n+            \",\n+            r\"$0pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\n+\",\n+        );\n+\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub mod bar { pub fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_inline_module_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar;\n+\n+            //- /foo/bar.rs\n+            pub fn baz() {}\n+            }\n+            \",\n+            r\"$0pub(crate) mod bar;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_module_declaration_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /main.rs\n+              mod foo;\n+              fn main() { foo::bar<|>>::baz(); }\n+\n+              //- /foo.rs\n+              mod bar {\n+                  pub fn baz() {}\n+              }\",\n+            r\"$0pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn adds_pub_when_target_is_in_another_crate() {\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /main.rs crate:a deps:foo\n+              foo::Bar<|>\n+              //- /lib.rs crate:foo\n+              struct Bar;\",\n+            r\"$0pub struct Bar;\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME handle reexports properly\n+    fn fix_visibility_of_reexport() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            mod foo {\n+                use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz<|>\n+            \",\n+            r\"\n+            mod foo {\n+                $0pub(crate) use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz\n+            \",\n+        )\n+    }\n+}"}, {"sha": "5731965766b048c1d42fc55aadef98cbb6226bfc", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_binexpr\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let _ = 2 + 90;\n // }\n // ```\n-pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<BinExpr>()?;\n     let lhs = expr.lhs()?.syntax().clone();\n     let rhs = expr.rhs()?.syntax().clone();\n@@ -33,8 +33,7 @@ pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_binexpr\"), \"Flip binary expression\", |edit| {\n-        edit.target(op_range);\n+    acc.add(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n         if let FlipAction::FlipAndReplaceOp(new_op) = action {\n             edit.replace(op_range, new_op);\n         }\n@@ -69,7 +68,7 @@ impl From<BinOp> for FlipAction {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn flip_binexpr_target_is_the_op() {\n@@ -86,25 +85,21 @@ mod tests {\n         check_assist(\n             flip_binexpr,\n             \"fn f() { let res = 1 ==<|> 2; }\",\n-            \"fn f() { let res = 2 ==<|> 1; }\",\n+            \"fn f() { let res = 2 == 1; }\",\n         )\n     }\n \n     #[test]\n     fn flip_binexpr_works_for_gt() {\n-        check_assist(\n-            flip_binexpr,\n-            \"fn f() { let res = 1 ><|> 2; }\",\n-            \"fn f() { let res = 2 <<|> 1; }\",\n-        )\n+        check_assist(flip_binexpr, \"fn f() { let res = 1 ><|> 2; }\", \"fn f() { let res = 2 < 1; }\")\n     }\n \n     #[test]\n     fn flip_binexpr_works_for_lteq() {\n         check_assist(\n             flip_binexpr,\n             \"fn f() { let res = 1 <=<|> 2; }\",\n-            \"fn f() { let res = 2 >=<|> 1; }\",\n+            \"fn f() { let res = 2 >= 1; }\",\n         )\n     }\n \n@@ -113,7 +108,7 @@ mod tests {\n         check_assist(\n             flip_binexpr,\n             \"fn f() { let res = (1 + 1) ==<|> (2 + 2); }\",\n-            \"fn f() { let res = (2 + 2) ==<|> (1 + 1); }\",\n+            \"fn f() { let res = (2 + 2) == (1 + 1); }\",\n         )\n     }\n \n@@ -133,7 +128,7 @@ mod tests {\n             fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n                 match other.downcast_ref::<Self>() {\n                     None => false,\n-                    Some(it) => self ==<|> it,\n+                    Some(it) => self == it,\n                 }\n             }\n             \"#,"}, {"sha": "a57a1c463c4416a63687766e03eb4111036688c9", "filename": "crates/ra_assists/src/handlers/flip_comma.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_comma\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     ((3, 4), (1, 2));\n // }\n // ```\n-pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_comma(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let comma = ctx.find_token_at_offset(T![,])?;\n     let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;\n@@ -28,8 +28,7 @@ pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_comma\"), \"Flip comma\", |edit| {\n-        edit.target(comma.text_range());\n+    acc.add(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n         edit.replace(prev.text_range(), next.to_string());\n         edit.replace(next.text_range(), prev.to_string());\n     })\n@@ -39,14 +38,14 @@ pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_target};\n \n     #[test]\n     fn flip_comma_works_for_function_parameters() {\n         check_assist(\n             flip_comma,\n             \"fn foo(x: i32,<|> y: Result<(), ()>) {}\",\n-            \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n+            \"fn foo(y: Result<(), ()>, x: i32) {}\",\n         )\n     }\n "}, {"sha": "0115adc8b53ab32d965ed204e62d276dc3629ccf", "filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     Direction, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_trait_bound\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // fn foo<T: Copy + Clone>() { }\n // ```\n-pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     // We want to replicate the behavior of `flip_binexpr` by only suggesting\n     // the assist when the cursor is on a `+`\n     let plus = ctx.find_token_at_offset(T![+])?;\n@@ -32,8 +32,8 @@ pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n         non_trivia_sibling(plus.clone().into(), Direction::Next)?,\n     );\n \n-    ctx.add_assist(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", |edit| {\n-        edit.target(plus.text_range());\n+    let target = plus.text_range();\n+    acc.add(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n         edit.replace(before.text_range(), after.to_string());\n         edit.replace(after.text_range(), before.to_string());\n     })\n@@ -43,7 +43,7 @@ pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn flip_trait_bound_assist_available() {\n@@ -60,7 +60,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"struct S<T> where T: A <|>+ B { }\",\n-            \"struct S<T> where T: B <|>+ A { }\",\n+            \"struct S<T> where T: B + A { }\",\n         )\n     }\n \n@@ -69,21 +69,21 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"impl X for S<T> where T: A +<|> B { }\",\n-            \"impl X for S<T> where T: B +<|> A { }\",\n+            \"impl X for S<T> where T: B + A { }\",\n         )\n     }\n \n     #[test]\n     fn flip_trait_bound_works_for_fn() {\n-        check_assist(flip_trait_bound, \"fn f<T: A <|>+ B>(t: T) { }\", \"fn f<T: B <|>+ A>(t: T) { }\")\n+        check_assist(flip_trait_bound, \"fn f<T: A <|>+ B>(t: T) { }\", \"fn f<T: B + A>(t: T) { }\")\n     }\n \n     #[test]\n     fn flip_trait_bound_works_for_fn_where_clause() {\n         check_assist(\n             flip_trait_bound,\n             \"fn f<T>(t: T) where T: A +<|> B { }\",\n-            \"fn f<T>(t: T) where T: B +<|> A { }\",\n+            \"fn f<T>(t: T) where T: B + A { }\",\n         )\n     }\n \n@@ -92,7 +92,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"fn f<T>(t: T) where T: A <|>+ 'static { }\",\n-            \"fn f<T>(t: T) where T: 'static <|>+ A { }\",\n+            \"fn f<T>(t: T) where T: 'static + A { }\",\n         )\n     }\n \n@@ -101,7 +101,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"struct S<T> where T: A<T> <|>+ b_mod::B<T> + C<T> { }\",\n-            \"struct S<T> where T: b_mod::B<T> <|>+ A<T> + C<T> { }\",\n+            \"struct S<T> where T: b_mod::B<T> + A<T> + C<T> { }\",\n         )\n     }\n \n@@ -110,7 +110,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"struct S<T> where T: A + B + C + D + E + F +<|> G + H + I + J { }\",\n-            \"struct S<T> where T: A + B + C + D + E + G +<|> F + H + I + J { }\",\n+            \"struct S<T> where T: A + B + C + D + E + G + F + H + I + J { }\",\n         )\n     }\n }"}, {"sha": "d26e68847984a20b0e63fcfbb266986a9c8b9fa4", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,9 +3,12 @@ use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n-use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: inline_local_variable\n //\n@@ -23,18 +26,18 @@ use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n //     (1 + 2) * 4;\n // }\n // ```\n-pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n     let bind_pat = match let_stmt.pat()? {\n         ast::Pat::BindPat(pat) => pat,\n         _ => return None,\n     };\n     if bind_pat.mut_token().is_some() {\n-        tested_by!(test_not_inline_mut_variable);\n+        mark::hit!(test_not_inline_mut_variable);\n         return None;\n     }\n-    if !bind_pat.syntax().text_range().contains_inclusive(ctx.frange.range.start()) {\n-        tested_by!(not_applicable_outside_of_bind_pat);\n+    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n+        mark::hit!(not_applicable_outside_of_bind_pat);\n         return None;\n     }\n     let initializer_expr = let_stmt.initializer()?;\n@@ -43,7 +46,7 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n     let def = Definition::Local(def);\n     let refs = def.find_usages(ctx.db, None);\n     if refs.is_empty() {\n-        tested_by!(test_not_applicable_if_variable_unused);\n+        mark::hit!(test_not_applicable_if_variable_unused);\n         return None;\n     };\n \n@@ -89,6 +92,7 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n             | (ast::Expr::ParenExpr(_), _)\n             | (ast::Expr::PathExpr(_), _)\n             | (ast::Expr::BlockExpr(_), _)\n+            | (ast::Expr::EffectExpr(_), _)\n             | (_, ast::Expr::CallExpr(_))\n             | (_, ast::Expr::TupleExpr(_))\n             | (_, ast::Expr::ArrayExpr(_))\n@@ -105,26 +109,21 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n \n-    ctx.add_assist(\n-        AssistId(\"inline_local_variable\"),\n-        \"Inline variable\",\n-        move |edit: &mut ActionBuilder| {\n-            edit.delete(delete_range);\n-            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n-                let replacement =\n-                    if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                edit.replace(desc.file_range.range, replacement)\n-            }\n-            edit.set_cursor(delete_range.start())\n-        },\n-    )\n+    let target = bind_pat.syntax().text_range();\n+    acc.add(AssistId(\"inline_local_variable\"), \"Inline variable\", target, move |builder| {\n+        builder.delete(delete_range);\n+        for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+            let replacement = if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n+            builder.replace(desc.file_range.range, replacement)\n+        }\n+    })\n }\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -149,7 +148,7 @@ fn foo() {\n             r\"\n fn bar(a: usize) {}\n fn foo() {\n-    <|>1 + 1;\n+    1 + 1;\n     if 1 > 10 {\n     }\n \n@@ -183,7 +182,7 @@ fn foo() {\n             r\"\n fn bar(a: usize) {}\n fn foo() {\n-    <|>(1 + 1) + 1;\n+    (1 + 1) + 1;\n     if (1 + 1) > 10 {\n     }\n \n@@ -217,7 +216,7 @@ fn foo() {\n             r\"\n fn bar(a: usize) {}\n fn foo() {\n-    <|>bar(1) + 1;\n+    bar(1) + 1;\n     if bar(1) > 10 {\n     }\n \n@@ -251,7 +250,7 @@ fn foo() {\n             r\"\n fn bar(a: usize): usize { a }\n fn foo() {\n-    <|>(bar(1) as u64) + 1;\n+    (bar(1) as u64) + 1;\n     if (bar(1) as u64) > 10 {\n     }\n \n@@ -283,7 +282,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>{ 10 + 1 } + 1;\n+    { 10 + 1 } + 1;\n     if { 10 + 1 } > 10 {\n     }\n \n@@ -315,7 +314,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>( 10 + 1 ) + 1;\n+    ( 10 + 1 ) + 1;\n     if ( 10 + 1 ) > 10 {\n     }\n \n@@ -330,7 +329,7 @@ fn foo() {\n \n     #[test]\n     fn test_not_inline_mut_variable() {\n-        covers!(test_not_inline_mut_variable);\n+        mark::check!(test_not_inline_mut_variable);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\"\n@@ -353,7 +352,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = bar(10 + 1) * 10;\n+    let b = bar(10 + 1) * 10;\n     let c = bar(10 + 1) as usize;\n }\",\n         );\n@@ -373,7 +372,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let x = vec![1, 2, 3];\n-    <|>let b = x[0] * 10;\n+    let b = x[0] * 10;\n     let c = x[0] as usize;\n }\",\n         );\n@@ -393,7 +392,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let bar = vec![1];\n-    <|>let b = bar.len() * 10;\n+    let b = bar.len() * 10;\n     let c = bar.len() as usize;\n }\",\n         );\n@@ -421,7 +420,7 @@ struct Bar {\n \n fn foo() {\n     let bar = Bar { foo: 1 };\n-    <|>let b = bar.foo * 10;\n+    let b = bar.foo * 10;\n     let c = bar.foo as usize;\n }\",\n         );\n@@ -442,7 +441,7 @@ fn foo() -> Option<usize> {\n             r\"\n fn foo() -> Option<usize> {\n     let bar = Some(1);\n-    <|>let b = bar? * 10;\n+    let b = bar? * 10;\n     let c = bar? as usize;\n     None\n }\",\n@@ -462,7 +461,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let bar = 10;\n-    <|>let b = &bar * 10;\n+    let b = &bar * 10;\n }\",\n         );\n     }\n@@ -478,7 +477,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = (10, 20)[0];\n+    let b = (10, 20)[0];\n }\",\n         );\n     }\n@@ -494,7 +493,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = [1, 2, 3].len();\n+    let b = [1, 2, 3].len();\n }\",\n         );\n     }\n@@ -511,7 +510,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = (10 + 20) * 10;\n+    let b = (10 + 20) * 10;\n     let c = (10 + 20) as usize;\n }\",\n         );\n@@ -531,7 +530,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let d = 10;\n-    <|>let b = d * 10;\n+    let b = d * 10;\n     let c = d as usize;\n }\",\n         );\n@@ -549,7 +548,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = { 10 } * 10;\n+    let b = { 10 } * 10;\n     let c = { 10 } as usize;\n }\",\n         );\n@@ -569,7 +568,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = (10 + 20) * 10;\n+    let b = (10 + 20) * 10;\n     let c = (10 + 20, 20);\n     let d = [10 + 20, 10];\n     let e = (10 + 20);\n@@ -588,7 +587,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>for i in vec![10, 20] {}\n+    for i in vec![10, 20] {}\n }\",\n         );\n     }\n@@ -604,7 +603,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>while 1 > 0 {}\n+    while 1 > 0 {}\n }\",\n         );\n     }\n@@ -622,7 +621,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>loop {\n+    loop {\n         break 1 + 1;\n     }\n }\",\n@@ -640,7 +639,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>return 1 > 0;\n+    return 1 > 0;\n }\",\n         );\n     }\n@@ -656,14 +655,14 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>match 1 > 0 {}\n+    match 1 > 0 {}\n }\",\n         );\n     }\n \n     #[test]\n     fn test_not_applicable_if_variable_unused() {\n-        covers!(test_not_applicable_if_variable_unused);\n+        mark::check!(test_not_applicable_if_variable_unused);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\"\n@@ -676,7 +675,7 @@ fn foo() {\n \n     #[test]\n     fn not_applicable_outside_of_bind_pat() {\n-        covers!(not_applicable_outside_of_bind_pat);\n+        mark::check!(not_applicable_outside_of_bind_pat);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\""}, {"sha": "31d6539f7a77b46866102aefe0e553903aef6162", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 77, "deletions": 63, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,12 +4,12 @@ use ra_syntax::{\n         BLOCK_EXPR, BREAK_EXPR, COMMENT, LAMBDA_EXPR, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n         WHITESPACE,\n     },\n-    SyntaxNode, TextSize,\n+    SyntaxNode,\n };\n use stdx::format_to;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: introduce_variable\n //\n@@ -23,17 +23,17 @@ use crate::{Assist, AssistCtx, AssistId};\n // ->\n // ```\n // fn main() {\n-//     let var_name = (1 + 2);\n+//     let $0var_name = (1 + 2);\n //     var_name * 4;\n // }\n // ```\n-pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn introduce_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if ctx.frange.range.is_empty() {\n         return None;\n     }\n     let node = ctx.covering_element();\n     if node.kind() == COMMENT {\n-        tested_by!(introduce_var_in_comment_is_not_applicable);\n+        mark::hit!(introduce_var_in_comment_is_not_applicable);\n         return None;\n     }\n     let expr = node.ancestors().find_map(valid_target_expr)?;\n@@ -42,51 +42,65 @@ pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n     if indent.kind() != WHITESPACE {\n         return None;\n     }\n-    ctx.add_assist(AssistId(\"introduce_variable\"), \"Extract into variable\", move |edit| {\n+    let target = expr.syntax().text_range();\n+    acc.add(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n         let mut buf = String::new();\n \n-        let cursor_offset = if wrap_in_block {\n+        if wrap_in_block {\n             buf.push_str(\"{ let var_name = \");\n-            TextSize::of(\"{ let \")\n         } else {\n             buf.push_str(\"let var_name = \");\n-            TextSize::of(\"let \")\n         };\n         format_to!(buf, \"{}\", expr.syntax());\n+\n         let full_stmt = ast::ExprStmt::cast(anchor_stmt.clone());\n         let is_full_stmt = if let Some(expr_stmt) = &full_stmt {\n             Some(expr.syntax().clone()) == expr_stmt.expr().map(|e| e.syntax().clone())\n         } else {\n             false\n         };\n         if is_full_stmt {\n-            tested_by!(test_introduce_var_expr_stmt);\n+            mark::hit!(test_introduce_var_expr_stmt);\n             if full_stmt.unwrap().semicolon_token().is_none() {\n                 buf.push_str(\";\");\n             }\n-            edit.replace(expr.syntax().text_range(), buf);\n-        } else {\n-            buf.push_str(\";\");\n-\n-            // We want to maintain the indent level,\n-            // but we do not want to duplicate possible\n-            // extra newlines in the indent block\n-            let text = indent.text();\n-            if text.starts_with('\\n') {\n-                buf.push_str(\"\\n\");\n-                buf.push_str(text.trim_start_matches('\\n'));\n-            } else {\n-                buf.push_str(text);\n+            let offset = expr.syntax().text_range();\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snip = buf.replace(\"let var_name\", \"let $0var_name\");\n+                    edit.replace_snippet(cap, offset, snip)\n+                }\n+                None => edit.replace(offset, buf),\n             }\n+            return;\n+        }\n \n-            edit.target(expr.syntax().text_range());\n-            edit.replace(expr.syntax().text_range(), \"var_name\".to_string());\n-            edit.insert(anchor_stmt.text_range().start(), buf);\n-            if wrap_in_block {\n-                edit.insert(anchor_stmt.text_range().end(), \" }\");\n+        buf.push_str(\";\");\n+\n+        // We want to maintain the indent level,\n+        // but we do not want to duplicate possible\n+        // extra newlines in the indent block\n+        let text = indent.text();\n+        if text.starts_with('\\n') {\n+            buf.push_str(\"\\n\");\n+            buf.push_str(text.trim_start_matches('\\n'));\n+        } else {\n+            buf.push_str(text);\n+        }\n+\n+        edit.replace(expr.syntax().text_range(), \"var_name\".to_string());\n+        let offset = anchor_stmt.text_range().start();\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                let snip = buf.replace(\"let var_name\", \"let $0var_name\");\n+                edit.insert_snippet(cap, offset, snip)\n             }\n+            None => edit.insert(offset, buf),\n+        }\n+\n+        if wrap_in_block {\n+            edit.insert(anchor_stmt.text_range().end(), \" }\");\n         }\n-        edit.set_cursor(anchor_stmt.text_range().start() + cursor_offset);\n     })\n }\n \n@@ -111,9 +125,9 @@ fn valid_target_expr(node: SyntaxNode) -> Option<ast::Expr> {\n /// expression like a lambda or match arm.\n fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n     expr.syntax().ancestors().find_map(|node| {\n-        if let Some(expr) = node.parent().and_then(ast::Block::cast).and_then(|it| it.expr()) {\n+        if let Some(expr) = node.parent().and_then(ast::BlockExpr::cast).and_then(|it| it.expr()) {\n             if expr.syntax() == &node {\n-                tested_by!(test_introduce_var_last_expr);\n+                mark::hit!(test_introduce_var_last_expr);\n                 return Some((node, false));\n             }\n         }\n@@ -134,47 +148,47 @@ fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n \n     #[test]\n     fn test_introduce_var_simple() {\n         check_assist(\n             introduce_variable,\n-            \"\n+            r#\"\n fn foo() {\n     foo(<|>1 + 1<|>);\n-}\",\n-            \"\n+}\"#,\n+            r#\"\n fn foo() {\n-    let <|>var_name = 1 + 1;\n+    let $0var_name = 1 + 1;\n     foo(var_name);\n-}\",\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn introduce_var_in_comment_is_not_applicable() {\n-        covers!(introduce_var_in_comment_is_not_applicable);\n+        mark::check!(introduce_var_in_comment_is_not_applicable);\n         check_assist_not_applicable(introduce_variable, \"fn main() { 1 + /* <|>comment<|> */ 1; }\");\n     }\n \n     #[test]\n     fn test_introduce_var_expr_stmt() {\n-        covers!(test_introduce_var_expr_stmt);\n+        mark::check!(test_introduce_var_expr_stmt);\n         check_assist(\n             introduce_variable,\n-            \"\n+            r#\"\n fn foo() {\n     <|>1 + 1<|>;\n-}\",\n-            \"\n+}\"#,\n+            r#\"\n fn foo() {\n-    let <|>var_name = 1 + 1;\n-}\",\n+    let $0var_name = 1 + 1;\n+}\"#,\n         );\n         check_assist(\n             introduce_variable,\n@@ -185,7 +199,7 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = { let x = 0; x };\n+    let $0var_name = { let x = 0; x };\n     something_else();\n }\",\n         );\n@@ -201,15 +215,15 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = 1;\n+    let $0var_name = 1;\n     var_name + 1;\n }\",\n         );\n     }\n \n     #[test]\n     fn test_introduce_var_last_expr() {\n-        covers!(test_introduce_var_last_expr);\n+        mark::check!(test_introduce_var_last_expr);\n         check_assist(\n             introduce_variable,\n             \"\n@@ -218,7 +232,7 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = 1 + 1;\n+    let $0var_name = 1 + 1;\n     bar(var_name)\n }\",\n         );\n@@ -230,7 +244,7 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = bar(1 + 1);\n+    let $0var_name = bar(1 + 1);\n     var_name\n }\",\n         )\n@@ -253,7 +267,7 @@ fn main() {\n fn main() {\n     let x = true;\n     let tuple = match x {\n-        true => { let <|>var_name = 2 + 2; (var_name, true) }\n+        true => { let $0var_name = 2 + 2; (var_name, true) }\n         _ => (0, false)\n     };\n }\n@@ -283,7 +297,7 @@ fn main() {\n     let tuple = match x {\n         true => {\n             let y = 1;\n-            let <|>var_name = 2 + y;\n+            let $0var_name = 2 + y;\n             (var_name, true)\n         }\n         _ => (0, false)\n@@ -304,7 +318,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+    let lambda = |x: u32| { let $0var_name = x * 2; var_name };\n }\n \",\n         );\n@@ -321,7 +335,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+    let lambda = |x: u32| { let $0var_name = x * 2; var_name };\n }\n \",\n         );\n@@ -338,7 +352,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let <|>var_name = Some(true);\n+    let $0var_name = Some(true);\n     let o = var_name;\n }\n \",\n@@ -356,7 +370,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let <|>var_name = bar.foo();\n+    let $0var_name = bar.foo();\n     let v = var_name;\n }\n \",\n@@ -374,7 +388,7 @@ fn foo() -> u32 {\n \",\n             \"\n fn foo() -> u32 {\n-    let <|>var_name = 2 + 2;\n+    let $0var_name = 2 + 2;\n     return var_name;\n }\n \",\n@@ -396,7 +410,7 @@ fn foo() -> u32 {\n fn foo() -> u32 {\n \n \n-    let <|>var_name = 2 + 2;\n+    let $0var_name = 2 + 2;\n     return var_name;\n }\n \",\n@@ -413,7 +427,7 @@ fn foo() -> u32 {\n             \"\n fn foo() -> u32 {\n \n-        let <|>var_name = 2 + 2;\n+        let $0var_name = 2 + 2;\n         return var_name;\n }\n \",\n@@ -438,7 +452,7 @@ fn foo() -> u32 {\n     // bar\n \n \n-    let <|>var_name = 2 + 2;\n+    let $0var_name = 2 + 2;\n     return var_name;\n }\n \",\n@@ -459,7 +473,7 @@ fn main() {\n             \"\n fn main() {\n     let result = loop {\n-        let <|>var_name = 2 + 2;\n+        let $0var_name = 2 + 2;\n         break var_name;\n     };\n }\n@@ -478,7 +492,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let <|>var_name = 0f32 as u32;\n+    let $0var_name = 0f32 as u32;\n     let v = var_name;\n }\n \","}, {"sha": "59d278eb9bed8c03466ced60fce54599420093a2", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,7 +3,11 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils::invert_boolean_expression,\n+    AssistId,\n+};\n \n // Assist: invert_if\n //\n@@ -24,7 +28,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n // }\n // ```\n \n-pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_keyword = ctx.find_token_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent())?;\n     let if_range = if_keyword.text_range();\n@@ -40,36 +44,35 @@ pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n \n     let cond = expr.condition()?.expr()?;\n     let then_node = expr.then_branch()?.syntax().clone();\n+    let else_block = match expr.else_branch()? {\n+        ast::ElseBranch::Block(it) => it,\n+        ast::ElseBranch::IfExpr(_) => return None,\n+    };\n \n-    if let ast::ElseBranch::Block(else_block) = expr.else_branch()? {\n-        let cond_range = cond.syntax().text_range();\n-        let flip_cond = invert_boolean_expression(cond);\n-        let else_node = else_block.syntax();\n-        let else_range = else_node.text_range();\n-        let then_range = then_node.text_range();\n-        return ctx.add_assist(AssistId(\"invert_if\"), \"Invert if\", |edit| {\n-            edit.target(if_range);\n-            edit.replace(cond_range, flip_cond.syntax().text());\n-            edit.replace(else_range, then_node.text());\n-            edit.replace(then_range, else_node.text());\n-        });\n-    }\n-\n-    None\n+    let cond_range = cond.syntax().text_range();\n+    let flip_cond = invert_boolean_expression(cond);\n+    let else_node = else_block.syntax();\n+    let else_range = else_node.text_range();\n+    let then_range = then_node.text_range();\n+    acc.add(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n+        edit.replace(cond_range, flip_cond.syntax().text());\n+        edit.replace(else_range, then_node.text());\n+        edit.replace(then_range, else_node.text());\n+    })\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     #[test]\n     fn invert_if_remove_inequality() {\n         check_assist(\n             invert_if,\n             \"fn f() { i<|>f x != 3 { 1 } else { 3 + 2 } }\",\n-            \"fn f() { i<|>f x == 3 { 3 + 2 } else { 1 } }\",\n+            \"fn f() { if x == 3 { 3 + 2 } else { 1 } }\",\n         )\n     }\n \n@@ -78,7 +81,7 @@ mod tests {\n         check_assist(\n             invert_if,\n             \"fn f() { <|>if !cond { 3 * 2 } else { 1 } }\",\n-            \"fn f() { <|>if cond { 1 } else { 3 * 2 } }\",\n+            \"fn f() { if cond { 1 } else { 3 * 2 } }\",\n         )\n     }\n \n@@ -87,7 +90,7 @@ mod tests {\n         check_assist(\n             invert_if,\n             \"fn f() { i<|>f cond { 3 * 2 } else { 1 } }\",\n-            \"fn f() { i<|>f !cond { 1 } else { 3 * 2 } }\",\n+            \"fn f() { if !cond { 1 } else { 3 * 2 } }\",\n         )\n     }\n "}, {"sha": "972d162419468d830b8aa08ea6595b4db840b791", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n     AstNode, Direction, InsertPosition, SyntaxElement, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: merge_imports\n //\n@@ -20,10 +23,10 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{fmt::Formatter, io};\n // ```\n-pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let tree: ast::UseTree = ctx.find_node_at_offset()?;\n     let mut rewriter = SyntaxRewriter::default();\n-    let mut offset = ctx.frange.range.start();\n+    let mut offset = ctx.offset();\n \n     if let Some(use_item) = tree.syntax().parent().and_then(ast::UseItem::cast) {\n         let (merged, to_delete) = next_prev()\n@@ -52,10 +55,9 @@ pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n         }\n     };\n \n-    ctx.add_assist(AssistId(\"merge_imports\"), \"Merge imports\", |edit| {\n-        edit.rewrite(rewriter);\n-        // FIXME: we only need because our diff is imprecise\n-        edit.set_cursor(offset);\n+    let target = tree.syntax().text_range();\n+    acc.add(AssistId(\"merge_imports\"), \"Merge imports\", target, |builder| {\n+        builder.rewrite(rewriter);\n     })\n }\n \n@@ -125,7 +127,7 @@ fn first_path(path: &ast::Path) -> ast::Path {\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::check_assist;\n+    use crate::tests::check_assist;\n \n     use super::*;\n \n@@ -138,7 +140,7 @@ use std::fmt<|>::Debug;\n use std::fmt::Display;\n \",\n             r\"\n-use std::fmt<|>::{Debug, Display};\n+use std::fmt::{Debug, Display};\n \",\n         )\n     }\n@@ -152,7 +154,7 @@ use std::fmt::Debug;\n use std::fmt<|>::Display;\n \",\n             r\"\n-use std::fmt:<|>:{Display, Debug};\n+use std::fmt::{Display, Debug};\n \",\n         );\n     }\n@@ -165,7 +167,7 @@ use std::fmt:<|>:{Display, Debug};\n use std::{fmt<|>::Debug, fmt::Display};\n \",\n             r\"\n-use std::{fmt<|>::{Debug, Display}};\n+use std::{fmt::{Debug, Display}};\n \",\n         );\n         check_assist(\n@@ -174,7 +176,7 @@ use std::{fmt<|>::{Debug, Display}};\n use std::{fmt::Debug, fmt<|>::Display};\n \",\n             r\"\n-use std::{fmt::<|>{Display, Debug}};\n+use std::{fmt::{Display, Debug}};\n \",\n         );\n     }\n@@ -188,7 +190,7 @@ use std<|>::cell::*;\n use std::str;\n \",\n             r\"\n-use std<|>::{cell::*, str};\n+use std::{cell::*, str};\n \",\n         )\n     }\n@@ -202,7 +204,7 @@ use std<|>::cell::*;\n use std::str::*;\n \",\n             r\"\n-use std<|>::{cell::*, str::*};\n+use std::{cell::*, str::*};\n \",\n         )\n     }\n@@ -218,7 +220,7 @@ use foo::baz;\n /// Doc comment\n \",\n             r\"\n-use foo<|>::{bar, baz};\n+use foo::{bar, baz};\n \n /// Doc comment\n \",\n@@ -237,7 +239,7 @@ use {\n \",\n             r\"\n use {\n-    foo<|>::{bar, baz},\n+    foo::{bar, baz},\n };\n \",\n         );\n@@ -251,7 +253,7 @@ use {\n \",\n             r\"\n use {\n-    foo::{bar<|>, baz},\n+    foo::{bar, baz},\n };\n \",\n         );\n@@ -268,7 +270,7 @@ use foo::<|>{\n };\n \",\n             r\"\n-use foo::{<|>\n+use foo::{\n     FooBar,\n bar::baz};\n \","}, {"sha": "ca04ec671a0f0761cd6568c0d71b3ef6a74fd81f", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,10 +3,10 @@ use std::iter::successors;\n use ra_syntax::{\n     algo::neighbor,\n     ast::{self, AstNode},\n-    Direction, TextSize,\n+    Direction,\n };\n \n-use crate::{Assist, AssistCtx, AssistId, TextRange};\n+use crate::{AssistContext, AssistId, Assists, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -32,7 +32,7 @@ use crate::{Assist, AssistCtx, AssistId, TextRange};\n //     }\n // }\n // ```\n-pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n     // Don't try to handle arms with guards for now - can add support for this later\n     if current_arm.guard().is_some() {\n@@ -41,17 +41,6 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let current_expr = current_arm.expr()?;\n     let current_text_range = current_arm.syntax().text_range();\n \n-    enum CursorPos {\n-        InExpr(TextSize),\n-        InPat(TextSize),\n-    }\n-    let cursor_pos = ctx.frange.range.start();\n-    let cursor_pos = if current_expr.syntax().text_range().contains(cursor_pos) {\n-        CursorPos::InExpr(current_text_range.end() - cursor_pos)\n-    } else {\n-        CursorPos::InPat(cursor_pos)\n-    };\n-\n     // We check if the following match arms match this one. We could, but don't,\n     // compare to the previous match arm as well.\n     let arms_to_merge = successors(Some(current_arm), |it| neighbor(it, Direction::Next))\n@@ -70,7 +59,7 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"merge_match_arms\"), \"Merge match arms\", |edit| {\n+    acc.add(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n         let pats = if arms_to_merge.iter().any(contains_placeholder) {\n             \"_\".into()\n         } else {\n@@ -87,11 +76,6 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         let start = arms_to_merge.first().unwrap().syntax().text_range().start();\n         let end = arms_to_merge.last().unwrap().syntax().text_range().end();\n \n-        edit.target(current_text_range);\n-        edit.set_cursor(match cursor_pos {\n-            CursorPos::InExpr(back_offset) => start + TextSize::of(&arm) - back_offset,\n-            CursorPos::InPat(offset) => offset,\n-        });\n         edit.replace(TextRange::new(start, end), arm);\n     })\n }\n@@ -105,7 +89,7 @@ fn contains_placeholder(a: &ast::MatchArm) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -133,7 +117,7 @@ mod tests {\n             fn main() {\n                 let x = X::A;\n                 let y = match x {\n-                    X::A | X::B => { 1i32<|> }\n+                    X::A | X::B => { 1i32 }\n                     X::C => { 2i32 }\n                 }\n             }\n@@ -165,7 +149,7 @@ mod tests {\n             fn main() {\n                 let x = X::A;\n                 let y = match x {\n-                    X::A | X::B | X::C | X::D => {<|> 1i32 },\n+                    X::A | X::B | X::C | X::D => { 1i32 },\n                     X::E => { 2i32 },\n                 }\n             }\n@@ -198,7 +182,7 @@ mod tests {\n                 let x = X::A;\n                 let y = match x {\n                     X::A => { 1i32 },\n-                    _ => { 2i<|>32 }\n+                    _ => { 2i32 }\n                 }\n             }\n             \"#,\n@@ -227,7 +211,7 @@ mod tests {\n \n             fn main() {\n                 match X::A {\n-                    X::A<|> | X::B | X::C => 92,\n+                    X::A | X::B | X::C => 92,\n                     X::D => 62,\n                     _ => panic!(),\n                 }"}, {"sha": "be2a7eddcfad3999dc071dcfb795047e6bed146f", "filename": "crates/ra_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_bounds_to_where_clause\n //\n@@ -22,7 +22,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     f(x)\n // }\n // ```\n-pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let type_param_list = ctx.find_node_at_offset::<ast::TypeParamList>()?;\n \n     let mut type_params = type_param_list.type_params();\n@@ -49,7 +49,8 @@ pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n         }\n     };\n \n-    ctx.add_assist(AssistId(\"move_bounds_to_where_clause\"), \"Move to where clause\", |edit| {\n+    let target = type_param_list.syntax().text_range();\n+    acc.add(AssistId(\"move_bounds_to_where_clause\"), \"Move to where clause\", target, |edit| {\n         let new_params = type_param_list\n             .type_params()\n             .filter(|it| it.type_bound_list().is_some())\n@@ -71,7 +72,6 @@ pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n             _ => format!(\" {}\", where_clause.syntax()),\n         };\n         edit.insert(anchor.text_range().start(), to_insert);\n-        edit.target(type_param_list.syntax().text_range());\n     })\n }\n \n@@ -89,7 +89,7 @@ fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::check_assist;\n+    use crate::tests::check_assist;\n \n     #[test]\n     fn move_bounds_to_where_clause_fn() {\n@@ -99,7 +99,7 @@ mod tests {\n             fn foo<T: u32, <|>F: FnOnce(T) -> T>() {}\n             \"#,\n             r#\"\n-            fn foo<T, <|>F>() where T: u32, F: FnOnce(T) -> T {}\n+            fn foo<T, F>() where T: u32, F: FnOnce(T) -> T {}\n             \"#,\n         );\n     }\n@@ -112,7 +112,7 @@ mod tests {\n             impl<U: u32, <|>T> A<U, T> {}\n             \"#,\n             r#\"\n-            impl<U, <|>T> A<U, T> where U: u32 {}\n+            impl<U, T> A<U, T> where U: u32 {}\n             \"#,\n         );\n     }\n@@ -125,7 +125,7 @@ mod tests {\n             struct A<<|>T: Iterator<Item = u32>> {}\n             \"#,\n             r#\"\n-            struct A<<|>T> where T: Iterator<Item = u32> {}\n+            struct A<T> where T: Iterator<Item = u32> {}\n             \"#,\n         );\n     }\n@@ -138,7 +138,7 @@ mod tests {\n             struct Pair<<|>T: u32>(T, T);\n             \"#,\n             r#\"\n-            struct Pair<<|>T>(T, T) where T: u32;\n+            struct Pair<T>(T, T) where T: u32;\n             \"#,\n         );\n     }"}, {"sha": "7edcf07489584d1df0571c38c2f33b14db33faeb", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,10 +1,9 @@\n use ra_syntax::{\n-    ast,\n-    ast::{AstNode, AstToken, IfExpr, MatchArm},\n-    TextSize,\n+    ast::{AstNode, IfExpr, MatchArm},\n+    SyntaxKind::WHITESPACE,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_guard_to_arm_body\n //\n@@ -31,7 +30,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n@@ -40,26 +39,17 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n     let arm_expr = match_arm.expr()?;\n     let buf = format!(\"if {} {{ {} }}\", guard_conditions.syntax().text(), arm_expr.syntax().text());\n \n-    ctx.add_assist(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", |edit| {\n-        edit.target(guard.syntax().text_range());\n-        let offseting_amount = match space_before_guard.and_then(|it| it.into_token()) {\n-            Some(tok) => {\n-                if ast::Whitespace::cast(tok.clone()).is_some() {\n-                    let ele = tok.text_range();\n-                    edit.delete(ele);\n-                    ele.len()\n-                } else {\n-                    TextSize::from(0)\n-                }\n+    let target = guard.syntax().text_range();\n+    acc.add(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n+        match space_before_guard {\n+            Some(element) if element.kind() == WHITESPACE => {\n+                edit.delete(element.text_range());\n             }\n-            _ => TextSize::from(0),\n+            _ => (),\n         };\n \n         edit.delete(guard.syntax().text_range());\n         edit.replace_node_and_indent(arm_expr.syntax(), buf);\n-        edit.set_cursor(\n-            arm_expr.syntax().text_range().start() + TextSize::from(3) - offseting_amount,\n-        );\n     })\n }\n \n@@ -88,7 +78,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n //     }\n // }\n // ```\n-pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n     let match_pat = match_arm.pat()?;\n \n@@ -108,22 +98,22 @@ pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n \n     let buf = format!(\" if {}\", cond.syntax().text());\n \n-    ctx.add_assist(\n+    let target = if_expr.syntax().text_range();\n+    acc.add(\n         AssistId(\"move_arm_cond_to_match_guard\"),\n         \"Move condition to match guard\",\n+        target,\n         |edit| {\n-            edit.target(if_expr.syntax().text_range());\n-            let then_only_expr = then_block.block().and_then(|it| it.statements().next()).is_none();\n+            let then_only_expr = then_block.statements().next().is_none();\n \n-            match &then_block.block().and_then(|it| it.expr()) {\n+            match &then_block.expr() {\n                 Some(then_expr) if then_only_expr => {\n                     edit.replace(if_expr.syntax().text_range(), then_expr.syntax().text())\n                 }\n                 _ => edit.replace(if_expr.syntax().text_range(), then_block.syntax().text()),\n             }\n \n             edit.insert(match_pat.syntax().text_range().end(), buf);\n-            edit.set_cursor(match_pat.syntax().text_range().end() + TextSize::from(1));\n         },\n     )\n }\n@@ -132,7 +122,7 @@ pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn move_guard_to_arm_body_target() {\n@@ -171,7 +161,7 @@ mod tests {\n                 let t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' => if chars.clone().next() == Some('\\n') { <|>false },\n+                    '\\r' => if chars.clone().next() == Some('\\n') { false },\n                     _ => true\n                 }\n             }\n@@ -194,7 +184,7 @@ mod tests {\n             r#\"\n             fn f() {\n                 match x {\n-                    y @ 4 | y @ 5 => if y > 5 { <|>true },\n+                    y @ 4 | y @ 5 => if y > 5 { true },\n                     _ => false\n                 }\n             }\n@@ -221,7 +211,7 @@ mod tests {\n                 let t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' <|>if chars.clone().next() == Some('\\n') => false,\n+                    '\\r' if chars.clone().next() == Some('\\n') => false,\n                     _ => true\n                 }\n             }\n@@ -265,7 +255,7 @@ mod tests {\n                 let t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' <|>if chars.clone().next().is_some() => {  },\n+                    '\\r' if chars.clone().next().is_some() => {  },\n                     _ => true\n                 }\n             }\n@@ -295,7 +285,7 @@ mod tests {\n                 let mut t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' <|>if chars.clone().next().is_some() => {\n+                    '\\r' if chars.clone().next().is_some() => {\n                         t = 'e';\n                         false\n                     },"}, {"sha": "16002d2acec52b6d6e6e3b1cd119fe61f4b38d07", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: make_raw_string\n //\n@@ -22,11 +22,11 @@ use crate::{Assist, AssistCtx, AssistId};\n //     r#\"Hello, World!\"#;\n // }\n // ```\n-pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n     let value = token.value()?;\n-    ctx.add_assist(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", |edit| {\n-        edit.target(token.syntax().text_range());\n+    let target = token.syntax().text_range();\n+    acc.add(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n         let max_hash_streak = count_hashes(&value);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n@@ -51,11 +51,11 @@ pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n //     \"Hello, \\\"World!\\\"\";\n // }\n // ```\n-pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n     let value = token.value()?;\n-    ctx.add_assist(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", |edit| {\n-        edit.target(token.syntax().text_range());\n+    let target = token.syntax().text_range();\n+    acc.add(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n         // parse inside string to escape `\"`\n         let escaped = value.escape_default().to_string();\n         edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n@@ -77,10 +77,10 @@ pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n //     r##\"Hello, World!\"##;\n // }\n // ```\n-pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n-    ctx.add_assist(AssistId(\"add_hash\"), \"Add # to raw string\", |edit| {\n-        edit.target(token.text_range());\n+    let target = token.text_range();\n+    acc.add(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n         edit.insert(token.text_range().start() + TextSize::of('r'), \"#\");\n         edit.insert(token.text_range().end(), \"#\");\n     })\n@@ -101,15 +101,15 @@ pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n //     r\"Hello, World!\";\n // }\n // ```\n-pub(crate) fn remove_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let text = token.text().as_str();\n     if text.starts_with(\"r\\\"\") {\n         // no hash to remove\n         return None;\n     }\n-    ctx.add_assist(AssistId(\"remove_hash\"), \"Remove hash from raw string\", |edit| {\n-        edit.target(token.text_range());\n+    let target = token.text_range();\n+    acc.add(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n         let result = &text[2..text.len() - 1];\n         let result = if result.starts_with('\\\"') {\n             // FIXME: this logic is wrong, not only the last has has to handled specially\n@@ -138,7 +138,7 @@ fn count_hashes(s: &str) -> usize {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn make_raw_string_target() {\n@@ -164,7 +164,7 @@ mod test {\n             \"#,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random\n+                let s = r#\"random\n string\"#;\n             }\n             \"##,\n@@ -182,7 +182,7 @@ string\"#;\n             \"#,\n             r##\"\n             fn f() {\n-                format!(<|>r#\"x = {}\"#, 92)\n+                format!(r#\"x = {}\"#, 92)\n             }\n             \"##,\n         )\n@@ -199,7 +199,7 @@ string\"#;\n             \"###,\n             r####\"\n             fn f() {\n-                let s = <|>r#\"#random##\n+                let s = r#\"#random##\n string\"#;\n             }\n             \"####,\n@@ -217,7 +217,7 @@ string\"#;\n             \"###,\n             r####\"\n             fn f() {\n-                let s = <|>r###\"#random\"##\n+                let s = r###\"#random\"##\n string\"###;\n             }\n             \"####,\n@@ -235,7 +235,7 @@ string\"###;\n             \"#,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random string\"#;\n+                let s = r#\"random string\"#;\n             }\n             \"##,\n         )\n@@ -289,7 +289,7 @@ string\"###;\n             \"#,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random string\"#;\n+                let s = r#\"random string\"#;\n             }\n             \"##,\n         )\n@@ -306,7 +306,7 @@ string\"###;\n             \"##,\n             r###\"\n             fn f() {\n-                let s = <|>r##\"random\"string\"##;\n+                let s = r##\"random\"string\"##;\n             }\n             \"###,\n         )\n@@ -348,7 +348,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>r\"random string\";\n+                let s = r\"random string\";\n             }\n             \"#,\n         )\n@@ -365,7 +365,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>r\"random\\\"str\\\"ing\";\n+                let s = r\"random\\\"str\\\"ing\";\n             }\n             \"#,\n         )\n@@ -382,7 +382,7 @@ string\"###;\n             \"###,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random string\"#;\n+                let s = r#\"random string\"#;\n             }\n             \"##,\n         )\n@@ -436,7 +436,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>\"random string\";\n+                let s = \"random string\";\n             }\n             \"#,\n         )\n@@ -453,7 +453,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>\"random\\\"str\\\"ing\";\n+                let s = \"random\\\"str\\\"ing\";\n             }\n             \"#,\n         )\n@@ -470,7 +470,7 @@ string\"###;\n             \"###,\n             r##\"\n             fn f() {\n-                let s = <|>\"random string\";\n+                let s = \"random string\";\n             }\n             \"##,\n         )"}, {"sha": "961ee1731ad0f79106552985f59cd62e50ed60e3", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 13, "deletions": 34, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     TextSize, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_dbg\n //\n@@ -20,7 +20,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     92;\n // }\n // ```\n-pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n \n     if !is_valid_macrocall(&macro_call, \"dbg\")? {\n@@ -29,26 +29,6 @@ pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n \n     let macro_range = macro_call.syntax().text_range();\n \n-    // If the cursor is inside the macro call, we'll try to maintain the cursor\n-    // position by subtracting the length of dbg!( from the start of the file\n-    // range, otherwise we'll default to using the start of the macro call\n-    let cursor_pos = {\n-        let file_range = ctx.frange.range;\n-\n-        let offset_start = file_range\n-            .start()\n-            .checked_sub(macro_range.start())\n-            .unwrap_or_else(|| TextSize::from(0));\n-\n-        let dbg_size = TextSize::of(\"dbg!(\");\n-\n-        if offset_start > dbg_size {\n-            file_range.start() - dbg_size\n-        } else {\n-            macro_range.start()\n-        }\n-    };\n-\n     let macro_content = {\n         let macro_args = macro_call.token_tree()?.syntax().clone();\n \n@@ -57,10 +37,9 @@ pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n         text.slice(without_parens).to_string()\n     };\n \n-    ctx.add_assist(AssistId(\"remove_dbg\"), \"Remove dbg!()\", |edit| {\n-        edit.target(macro_call.syntax().text_range());\n-        edit.replace(macro_range, macro_content);\n-        edit.set_cursor(cursor_pos);\n+    let target = macro_call.syntax().text_range();\n+    acc.add(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |builder| {\n+        builder.replace(macro_range, macro_content);\n     })\n }\n \n@@ -90,17 +69,17 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn test_remove_dbg() {\n-        check_assist(remove_dbg, \"<|>dbg!(1 + 1)\", \"<|>1 + 1\");\n+        check_assist(remove_dbg, \"<|>dbg!(1 + 1)\", \"1 + 1\");\n \n-        check_assist(remove_dbg, \"dbg!<|>((1 + 1))\", \"<|>(1 + 1)\");\n+        check_assist(remove_dbg, \"dbg!<|>((1 + 1))\", \"(1 + 1)\");\n \n-        check_assist(remove_dbg, \"dbg!(1 <|>+ 1)\", \"1 <|>+ 1\");\n+        check_assist(remove_dbg, \"dbg!(1 <|>+ 1)\", \"1 + 1\");\n \n-        check_assist(remove_dbg, \"let _ = <|>dbg!(1 + 1)\", \"let _ = <|>1 + 1\");\n+        check_assist(remove_dbg, \"let _ = <|>dbg!(1 + 1)\", \"let _ = 1 + 1\");\n \n         check_assist(\n             remove_dbg,\n@@ -113,7 +92,7 @@ fn foo(n: usize) {\n \",\n             \"\n fn foo(n: usize) {\n-    if let Some(_) = n.<|>checked_sub(4) {\n+    if let Some(_) = n.checked_sub(4) {\n         // ...\n     }\n }\n@@ -122,8 +101,8 @@ fn foo(n: usize) {\n     }\n     #[test]\n     fn test_remove_dbg_with_brackets_and_braces() {\n-        check_assist(remove_dbg, \"dbg![<|>1 + 1]\", \"<|>1 + 1\");\n-        check_assist(remove_dbg, \"dbg!{<|>1 + 1}\", \"<|>1 + 1\");\n+        check_assist(remove_dbg, \"dbg![<|>1 + 1]\", \"1 + 1\");\n+        check_assist(remove_dbg, \"dbg!{<|>1 + 1}\", \"1 + 1\");\n     }\n \n     #[test]"}, {"sha": "fe4eada0340876ef9bbc9d5fd2bae8bf1ec99538", "filename": "crates/ra_assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{SyntaxKind, TextRange, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_mut\n //\n@@ -17,16 +17,16 @@ use crate::{Assist, AssistCtx, AssistId};\n //     fn feed(&self, amount: u32) {}\n // }\n // ```\n-pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let mut_token = ctx.find_token_at_offset(T![mut])?;\n     let delete_from = mut_token.text_range().start();\n     let delete_to = match mut_token.next_token() {\n         Some(it) if it.kind() == SyntaxKind::WHITESPACE => it.text_range().end(),\n         _ => mut_token.text_range().end(),\n     };\n \n-    ctx.add_assist(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", |edit| {\n-        edit.set_cursor(delete_from);\n-        edit.delete(TextRange::new(delete_from, delete_to));\n+    let target = mut_token.text_range();\n+    acc.add(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |builder| {\n+        builder.delete(TextRange::new(delete_from, delete_to));\n     })\n }"}, {"sha": "30229edc2f24a7091436dc47afd7308e0294d720", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,18 +3,9 @@ use std::collections::HashMap;\n use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    algo,\n-    ast::{self, Path, RecordLit, RecordPat},\n-    match_ast, AstNode, SyntaxKind,\n-    SyntaxKind::*,\n-    SyntaxNode,\n-};\n-\n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    AssistId,\n-};\n+use ra_syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n+\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: reorder_fields\n //\n@@ -31,13 +22,13 @@ use crate::{\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n //\n-pub(crate) fn reorder_fields(ctx: AssistCtx) -> Option<Assist> {\n-    reorder::<RecordLit>(ctx.clone()).or_else(|| reorder::<RecordPat>(ctx))\n+pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    reorder::<ast::RecordLit>(acc, ctx.clone()).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n }\n \n-fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n+fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let record = ctx.find_node_at_offset::<R>()?;\n-    let path = record.syntax().children().find_map(Path::cast)?;\n+    let path = record.syntax().children().find_map(ast::Path::cast)?;\n \n     let ranks = compute_fields_ranks(&path, &ctx)?;\n \n@@ -50,11 +41,11 @@ fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"reorder_fields\"), \"Reorder record fields\", |edit| {\n+    let target = record.syntax().text_range();\n+    acc.add(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n         for (old, new) in fields.iter().zip(&sorted_fields) {\n             algo::diff(old, new).into_text_edit(edit.text_edit_builder());\n         }\n-        edit.target(record.syntax().text_range())\n     })\n }\n \n@@ -96,9 +87,9 @@ fn struct_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option\n     }\n }\n \n-fn compute_fields_ranks(path: &Path, ctx: &AssistCtx) -> Option<HashMap<String, usize>> {\n+fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<HashMap<String, usize>> {\n     Some(\n-        struct_definition(path, ctx.sema)?\n+        struct_definition(path, &ctx.sema)?\n             .fields(ctx.db)\n             .iter()\n             .enumerate()\n@@ -109,7 +100,7 @@ fn compute_fields_ranks(path: &Path, ctx: &AssistCtx) -> Option<HashMap<String,\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -149,7 +140,7 @@ mod tests {\n         \"#,\n             r#\"\n         struct Foo {foo: i32, bar: i32};\n-        const test: Foo = <|>Foo {foo: 1, bar: 0}\n+        const test: Foo = Foo {foo: 1, bar: 0}\n         \"#,\n         )\n     }\n@@ -173,7 +164,7 @@ mod tests {\n \n         fn f(f: Foo) -> {\n             match f {\n-                <|>Foo { ref mut bar, baz: 0, .. } => (),\n+                Foo { ref mut bar, baz: 0, .. } => (),\n                 _ => ()\n             }\n         }\n@@ -211,7 +202,7 @@ mod tests {\n             impl Foo {\n                 fn new() -> Foo {\n                     let foo = String::new();\n-                    <|>Foo {\n+                    Foo {\n                         foo,\n                         bar: foo.clone(),\n                         extra: \"Extra field\","}, {"sha": "e016f51c3eb490883dfe4a5563b525e17134f2cf", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,10 +1,14 @@\n use ra_fmt::unwrap_trivial_block;\n use ra_syntax::{\n-    ast::{self, edit::IndentLevel, make},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make,\n+    },\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_if_let_with_match\n //\n@@ -32,7 +36,7 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n@@ -43,29 +47,27 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n         ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n-    let sema = ctx.sema;\n-    ctx.add_assist(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", move |edit| {\n+    let target = if_expr.syntax().text_range();\n+    acc.add(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", target, move |edit| {\n         let match_expr = {\n             let then_arm = {\n                 let then_expr = unwrap_trivial_block(then_block);\n                 make::match_arm(vec![pat.clone()], then_expr)\n             };\n             let else_arm = {\n-                let pattern = sema\n+                let pattern = ctx\n+                    .sema\n                     .type_of_pat(&pat)\n-                    .and_then(|ty| TryEnum::from_ty(sema, &ty))\n+                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n                     .map(|it| it.sad_pattern())\n                     .unwrap_or_else(|| make::placeholder_pat().into());\n                 let else_expr = unwrap_trivial_block(else_block);\n                 make::match_arm(vec![pattern], else_expr)\n             };\n             make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+                .indent(IndentLevel::from_node(if_expr.syntax()))\n         };\n \n-        let match_expr = IndentLevel::from_node(if_expr.syntax()).increase_indent(match_expr);\n-\n-        edit.target(if_expr.syntax().text_range());\n-        edit.set_cursor(if_expr.syntax().text_range().start());\n         edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n     })\n }\n@@ -74,13 +76,13 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::{check_assist, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_target};\n \n     #[test]\n     fn test_replace_if_let_with_match_unwraps_simple_expressions() {\n         check_assist(\n             replace_if_let_with_match,\n-            \"\n+            r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n         if <|>let VariantData::Struct(..) = *self {\n@@ -89,24 +91,24 @@ impl VariantData {\n             false\n         }\n     }\n-}           \",\n-            \"\n+}           \"#,\n+            r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n-        <|>match *self {\n+        match *self {\n             VariantData::Struct(..) => true,\n             _ => false,\n         }\n     }\n-}           \",\n+}           \"#,\n         )\n     }\n \n     #[test]\n     fn test_replace_if_let_with_match_doesnt_unwrap_multiline_expressions() {\n         check_assist(\n             replace_if_let_with_match,\n-            \"\n+            r#\"\n fn foo() {\n     if <|>let VariantData::Struct(..) = a {\n         bar(\n@@ -115,26 +117,26 @@ fn foo() {\n     } else {\n         false\n     }\n-}           \",\n-            \"\n+}           \"#,\n+            r#\"\n fn foo() {\n-    <|>match a {\n+    match a {\n         VariantData::Struct(..) => {\n             bar(\n                 123\n             )\n         }\n         _ => false,\n     }\n-}           \",\n+}           \"#,\n         )\n     }\n \n     #[test]\n     fn replace_if_let_with_match_target() {\n         check_assist_target(\n             replace_if_let_with_match,\n-            \"\n+            r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n         if <|>let VariantData::Struct(..) = *self {\n@@ -143,7 +145,7 @@ impl VariantData {\n             false\n         }\n     }\n-}           \",\n+}           \"#,\n             \"if let VariantData::Struct(..) = *self {\n             true\n         } else {\n@@ -173,7 +175,7 @@ enum Option<T> { Some(T), None }\n use Option::*;\n \n fn foo(x: Option<i32>) {\n-    <|>match x {\n+    match x {\n         Some(x) => println!(\"{}\", x),\n         None => println!(\"none\"),\n     }\n@@ -203,7 +205,7 @@ enum Result<T, E> { Ok(T), Err(E) }\n use Result::*;\n \n fn foo(x: Result<i32, ()>) {\n-    <|>match x {\n+    match x {\n         Ok(x) => println!(\"{}\", x),\n         Err(_) => println!(\"none\"),\n     }"}, {"sha": "761557ac05c8c5813b323c7b3bc193ae437c0571", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -9,11 +9,7 @@ use ra_syntax::{\n     AstNode, T,\n };\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::TryEnum,\n-    AssistId,\n-};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_let_with_if_let\n //\n@@ -39,15 +35,16 @@ use crate::{\n //\n // fn compute() -> Option<i32> { None }\n // ```\n-pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_kw = ctx.find_token_at_offset(T![let])?;\n     let let_stmt = let_kw.ancestors().find_map(ast::LetStmt::cast)?;\n     let init = let_stmt.initializer()?;\n     let original_pat = let_stmt.pat()?;\n     let ty = ctx.sema.type_of_expr(&init)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty).map(|it| it.happy_case());\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty).map(|it| it.happy_case());\n \n-    ctx.add_assist(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", |edit| {\n+    let target = let_kw.text_range();\n+    acc.add(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n         let with_placeholder: ast::Pat = match happy_variant {\n             None => make::placeholder_pat().into(),\n             Some(var_name) => make::tuple_struct_pat(\n@@ -56,25 +53,20 @@ pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n             )\n             .into(),\n         };\n-        let block =\n-            IndentLevel::from_node(let_stmt.syntax()).increase_indent(make::block_expr(None, None));\n+        let block = make::block_expr(None, None).indent(IndentLevel::from_node(let_stmt.syntax()));\n         let if_ = make::expr_if(make::condition(init, Some(with_placeholder)), block);\n         let stmt = make::expr_stmt(if_);\n \n         let placeholder = stmt.syntax().descendants().find_map(ast::PlaceholderPat::cast).unwrap();\n-        let target_offset =\n-            let_stmt.syntax().text_range().start() + placeholder.syntax().text_range().start();\n         let stmt = stmt.replace_descendant(placeholder.into(), original_pat);\n \n         edit.replace_ast(ast::Stmt::from(let_stmt), ast::Stmt::from(stmt));\n-        edit.target(let_kw.text_range());\n-        edit.set_cursor(target_offset);\n     })\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::check_assist;\n+    use crate::tests::check_assist;\n \n     use super::*;\n \n@@ -93,7 +85,7 @@ fn main() {\n enum E<T> { X(T), Y(T) }\n \n fn main() {\n-    if let <|>x = E::X(92) {\n+    if let x = E::X(92) {\n     }\n }\n             \","}, {"sha": "0197a8cf06788f01f321fd31fdacf9790e4fcf77", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,11 +1,7 @@\n use hir;\n use ra_syntax::{ast, AstNode, SmolStr, TextRange};\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists};\n \n // Assist: replace_qualified_name_with_use\n //\n@@ -20,7 +16,10 @@ use crate::{\n //\n // fn process(map: HashMap<String, String>) {}\n // ```\n-pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_qualified_name_with_use(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n@@ -33,17 +32,19 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n         return None;\n     }\n \n-    ctx.add_assist(\n+    let target = path.syntax().text_range();\n+    acc.add(\n         AssistId(\"replace_qualified_name_with_use\"),\n         \"Replace qualified path with use\",\n-        |edit| {\n+        target,\n+        |builder| {\n             let path_to_import = hir_path.mod_path().clone();\n-            insert_use_statement(path.syntax(), &path_to_import, edit.text_edit_builder());\n+            insert_use_statement(path.syntax(), &path_to_import, ctx, builder.text_edit_builder());\n \n             if let Some(last) = path.segment() {\n                 // Here we are assuming the assist will provide a correct use statement\n                 // so we can delete the path qualifier\n-                edit.delete(TextRange::new(\n+                builder.delete(TextRange::new(\n                     path.syntax().text_range().start(),\n                     last.syntax().text_range().start(),\n                 ));\n@@ -74,7 +75,7 @@ fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -88,7 +89,7 @@ std::fmt::Debug<|>\n             \"\n use std::fmt::Debug;\n \n-Debug<|>\n+Debug\n     \",\n         );\n     }\n@@ -105,7 +106,7 @@ fn main() {\n             \"\n use std::fmt::Debug;\n \n-Debug<|>\n+Debug\n \n fn main() {\n }\n@@ -129,7 +130,7 @@ use std::fmt::Debug;\n fn main() {\n }\n \n-Debug<|>\n+Debug\n     \",\n         );\n     }\n@@ -144,7 +145,7 @@ std::fmt<|>::Debug\n             \"\n use std::fmt;\n \n-fmt<|>::Debug\n+fmt::Debug\n     \",\n         );\n     }\n@@ -163,7 +164,7 @@ impl std::fmt::Debug<|> for Foo {\n use stdx;\n use std::fmt::Debug;\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n     \",\n         );\n@@ -180,7 +181,7 @@ impl std::fmt::Debug<|> for Foo {\n             \"\n use std::fmt::Debug;\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n     \",\n         );\n@@ -197,7 +198,7 @@ impl Debug<|> for Foo {\n             \"\n     use std::fmt::Debug;\n \n-    impl Debug<|> for Foo {\n+    impl Debug for Foo {\n     }\n     \",\n         );\n@@ -216,7 +217,7 @@ impl std::io<|> for Foo {\n             \"\n use std::{io, fmt};\n \n-impl io<|> for Foo {\n+impl io for Foo {\n }\n     \",\n         );\n@@ -235,7 +236,7 @@ impl std::fmt::Debug<|> for Foo {\n             \"\n use std::fmt::{self, Debug, };\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n     \",\n         );\n@@ -254,7 +255,7 @@ impl std::fmt<|> for Foo {\n             \"\n use std::fmt::{self, Debug};\n \n-impl fmt<|> for Foo {\n+impl fmt for Foo {\n }\n     \",\n         );\n@@ -273,7 +274,7 @@ impl std::fmt::nested<|> for Foo {\n             \"\n use std::fmt::{Debug, nested::{Display, self}};\n \n-impl nested<|> for Foo {\n+impl nested for Foo {\n }\n \",\n         );\n@@ -292,7 +293,7 @@ impl std::fmt::nested<|> for Foo {\n             \"\n use std::fmt::{Debug, nested::{self, Display}};\n \n-impl nested<|> for Foo {\n+impl nested for Foo {\n }\n \",\n         );\n@@ -311,7 +312,7 @@ impl std::fmt::nested::Debug<|> for Foo {\n             \"\n use std::fmt::{Debug, nested::{Display, Debug}};\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n \",\n         );\n@@ -330,7 +331,7 @@ impl std::fmt::nested::Display<|> for Foo {\n             \"\n use std::fmt::{nested::Display, Debug};\n \n-impl Display<|> for Foo {\n+impl Display for Foo {\n }\n \",\n         );\n@@ -349,7 +350,7 @@ impl std::fmt::Display<|> for Foo {\n             \"\n use std::fmt::{Display, nested::Debug};\n \n-impl Display<|> for Foo {\n+impl Display for Foo {\n }\n \",\n         );\n@@ -373,7 +374,7 @@ use crate::{\n     AssocItem,\n };\n \n-fn foo() { lower<|>::trait_env() }\n+fn foo() { lower::trait_env() }\n \",\n         );\n     }\n@@ -391,7 +392,7 @@ impl foo::Debug<|> for Foo {\n             \"\n use std::fmt as foo;\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n \",\n         );\n@@ -434,7 +435,7 @@ mod foo {\n     mod bar {\n         use std::fmt::Debug;\n \n-        Debug<|>\n+        Debug\n     }\n }\n     \",\n@@ -457,7 +458,7 @@ fn main() {\n use std::fmt::Debug;\n \n fn main() {\n-    Debug<|>\n+    Debug\n }\n     \",\n         );"}, {"sha": "cff7dfb81215a29415cbc1e6b575a93b29c04b0f", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,11 +1,18 @@\n use std::iter;\n \n use ra_syntax::{\n-    ast::{self, edit::IndentLevel, make},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make,\n+    },\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{\n+    utils::{render_snippet, Cursor, TryEnum},\n+    AssistContext, AssistId, Assists,\n+};\n \n // Assist: replace_unwrap_with_match\n //\n@@ -25,45 +32,58 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     let x: Result<i32, i32> = Result::Ok(92);\n //     let y = match x {\n //         Ok(a) => a,\n-//         _ => unreachable!(),\n+//         $0_ => unreachable!(),\n //     };\n // }\n // ```\n-pub(crate) fn replace_unwrap_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let method_call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n     let name = method_call.name_ref()?;\n     if name.text() != \"unwrap\" {\n         return None;\n     }\n     let caller = method_call.expr()?;\n     let ty = ctx.sema.type_of_expr(&caller)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty)?.happy_case();\n-\n-    ctx.add_assist(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", |edit| {\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty)?.happy_case();\n+    let target = method_call.syntax().text_range();\n+    acc.add(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", target, |builder| {\n         let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n         let it = make::bind_pat(make::name(\"a\")).into();\n         let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n         let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n         let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-        let unreachable_call = make::unreachable_macro_call().into();\n+        let unreachable_call = make::expr_unreachable();\n         let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n         let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n-        let match_expr = make::expr_match(caller.clone(), match_arm_list);\n-        let match_expr = IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n+        let match_expr = make::expr_match(caller.clone(), match_arm_list)\n+            .indent(IndentLevel::from_node(method_call.syntax()));\n \n-        edit.target(method_call.syntax().text_range());\n-        edit.set_cursor(caller.syntax().text_range().start());\n-        edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n+        let range = method_call.syntax().text_range();\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                let err_arm = match_expr\n+                    .syntax()\n+                    .descendants()\n+                    .filter_map(ast::MatchArm::cast)\n+                    .last()\n+                    .unwrap();\n+                let snippet =\n+                    render_snippet(cap, match_expr.syntax(), Cursor::Before(err_arm.syntax()));\n+                builder.replace_snippet(cap, range, snippet)\n+            }\n+            None => builder.replace(range, match_expr.to_string()),\n+        }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n+    use crate::tests::{check_assist, check_assist_target};\n+\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn test_replace_result_unwrap_with_match() {\n@@ -82,9 +102,9 @@ enum Result<T, E> { Ok(T), Err(E) }\n fn i<T>(a: T) -> T { a }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n-    let y = <|>match i(x) {\n+    let y = match i(x) {\n         Ok(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     };\n }\n             \",\n@@ -108,9 +128,9 @@ enum Option<T> { Some(T), None }\n fn i<T>(a: T) -> T { a }\n fn main() {\n     let x = Option::Some(92);\n-    let y = <|>match i(x) {\n+    let y = match i(x) {\n         Some(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     };\n }\n             \",\n@@ -134,9 +154,9 @@ enum Result<T, E> { Ok(T), Err(E) }\n fn i<T>(a: T) -> T { a }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n-    let y = <|>match i(x) {\n+    let y = match i(x) {\n         Ok(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     }.count_zeroes();\n }\n             \","}, {"sha": "c7a8744802dccb6ac7ad1b055dc4c6626f2b15f3", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -2,7 +2,7 @@ use std::iter::successors;\n \n use ra_syntax::{ast, AstNode, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: split_import\n //\n@@ -15,7 +15,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{collections::HashMap};\n // ```\n-pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let colon_colon = ctx.find_token_at_offset(T![::])?;\n     let path = ast::Path::cast(colon_colon.parent())?.qualifier()?;\n     let top_path = successors(Some(path.clone()), |it| it.parent_path()).last()?;\n@@ -26,18 +26,16 @@ pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n     if new_tree == use_tree {\n         return None;\n     }\n-    let cursor = ctx.frange.range.start();\n \n-    ctx.add_assist(AssistId(\"split_import\"), \"Split import\", |edit| {\n-        edit.target(colon_colon.text_range());\n+    let target = colon_colon.text_range();\n+    acc.add(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n         edit.replace_ast(use_tree, new_tree);\n-        edit.set_cursor(cursor);\n     })\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n \n@@ -46,7 +44,7 @@ mod tests {\n         check_assist(\n             split_import,\n             \"use crate::<|>db::RootDatabase;\",\n-            \"use crate::<|>{db::RootDatabase};\",\n+            \"use crate::{db::RootDatabase};\",\n         )\n     }\n \n@@ -55,7 +53,7 @@ mod tests {\n         check_assist(\n             split_import,\n             \"use crate:<|>:db::{RootDatabase, FileSymbol}\",\n-            \"use crate:<|>:{db::{RootDatabase, FileSymbol}}\",\n+            \"use crate::{db::{RootDatabase, FileSymbol}}\",\n         )\n     }\n "}, {"sha": "8440c7d0f43e37e98fa4b4fa1f1716740c17f992", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,512 @@\n+use ra_fmt::unwrap_trivial_block;\n+use ra_syntax::{\n+    ast::{self, ElseBranch, Expr, LoopBodyOwner},\n+    match_ast, AstNode, TextRange, T,\n+};\n+\n+use crate::{AssistContext, AssistId, Assists};\n+\n+// Assist: unwrap_block\n+//\n+// This assist removes if...else, for, while and loop control statements to just keep the body.\n+//\n+// ```\n+// fn foo() {\n+//     if true {<|>\n+//         println!(\"foo\");\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     println!(\"foo\");\n+// }\n+// ```\n+pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let l_curly_token = ctx.find_token_at_offset(T!['{'])?;\n+    let block = ast::BlockExpr::cast(l_curly_token.parent())?;\n+    let parent = block.syntax().parent()?;\n+    let assist_id = AssistId(\"unwrap_block\");\n+    let assist_label = \"Unwrap block\";\n+\n+    let (expr, expr_to_unwrap) = match_ast! {\n+        match parent {\n+            ast::ForExpr(for_expr) => {\n+                let block_expr = for_expr.loop_body()?;\n+                let expr_to_unwrap = extract_expr(ctx.frange.range, block_expr)?;\n+                (ast::Expr::ForExpr(for_expr), expr_to_unwrap)\n+            },\n+            ast::WhileExpr(while_expr) => {\n+                let block_expr = while_expr.loop_body()?;\n+                let expr_to_unwrap = extract_expr(ctx.frange.range, block_expr)?;\n+                (ast::Expr::WhileExpr(while_expr), expr_to_unwrap)\n+            },\n+            ast::LoopExpr(loop_expr) => {\n+                let block_expr = loop_expr.loop_body()?;\n+                let expr_to_unwrap = extract_expr(ctx.frange.range, block_expr)?;\n+                (ast::Expr::LoopExpr(loop_expr), expr_to_unwrap)\n+            },\n+            ast::IfExpr(if_expr) => {\n+                let mut resp = None;\n+\n+                let then_branch = if_expr.then_branch()?;\n+                if then_branch.l_curly_token()?.text_range().contains_range(ctx.frange.range) {\n+                    if let Some(ancestor) = if_expr.syntax().parent().and_then(ast::IfExpr::cast) {\n+                        // For `else if` blocks\n+                        let ancestor_then_branch = ancestor.then_branch()?;\n+                        let l_curly_token = then_branch.l_curly_token()?;\n+\n+                        let target = then_branch.syntax().text_range();\n+                        return acc.add(assist_id, assist_label, target, |edit| {\n+                            let range_to_del_else_if = TextRange::new(ancestor_then_branch.syntax().text_range().end(), l_curly_token.text_range().start());\n+                            let range_to_del_rest = TextRange::new(then_branch.syntax().text_range().end(), if_expr.syntax().text_range().end());\n+\n+                            edit.delete(range_to_del_rest);\n+                            edit.delete(range_to_del_else_if);\n+                            edit.replace(target, update_expr_string(then_branch.to_string(), &[' ', '{']));\n+                        });\n+                    } else {\n+                        resp = Some((ast::Expr::IfExpr(if_expr.clone()), Expr::BlockExpr(then_branch)));\n+                    }\n+                } else if let Some(else_branch) = if_expr.else_branch() {\n+                    match else_branch {\n+                        ElseBranch::Block(else_block) => {\n+                            let l_curly_token = else_block.l_curly_token()?;\n+                            if l_curly_token.text_range().contains_range(ctx.frange.range) {\n+                                let target = else_block.syntax().text_range();\n+                                return acc.add(assist_id, assist_label, target, |edit| {\n+                                    let range_to_del = TextRange::new(then_branch.syntax().text_range().end(), l_curly_token.text_range().start());\n+\n+                                    edit.delete(range_to_del);\n+                                    edit.replace(target, update_expr_string(else_block.to_string(), &[' ', '{']));\n+                                });\n+                            }\n+                        },\n+                        ElseBranch::IfExpr(_) => {},\n+                    }\n+                }\n+\n+                resp?\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let target = expr_to_unwrap.syntax().text_range();\n+    acc.add(assist_id, assist_label, target, |edit| {\n+        edit.replace(\n+            expr.syntax().text_range(),\n+            update_expr_string(expr_to_unwrap.to_string(), &[' ', '{', '\\n']),\n+        );\n+    })\n+}\n+\n+fn extract_expr(cursor_range: TextRange, block: ast::BlockExpr) -> Option<ast::Expr> {\n+    let cursor_in_range = block.l_curly_token()?.text_range().contains_range(cursor_range);\n+\n+    if cursor_in_range {\n+        Some(unwrap_trivial_block(block))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn update_expr_string(expr_str: String, trim_start_pat: &[char]) -> String {\n+    let expr_string = expr_str.trim_start_matches(trim_start_pat);\n+    let mut expr_string_lines: Vec<&str> = expr_string.lines().collect();\n+    expr_string_lines.pop(); // Delete last line\n+\n+    expr_string_lines\n+        .into_iter()\n+        .map(|line| line.replacen(\"    \", \"\", 1)) // Delete indentation\n+        .collect::<Vec<String>>()\n+        .join(\"\\n\")\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn simple_if() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                bar();\n+                if true {<|>\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                bar();\n+                foo();\n+\n+                //comment\n+                bar();\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_else() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                bar();\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {<|>\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                bar();\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                }\n+                println!(\"bar\");\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_else_if() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {<|>\n+                    println!(\"bar\");\n+                } else {\n+                    println!(\"foo\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                }\n+                println!(\"bar\");\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_else_if_nested() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {\n+                    println!(\"bar\");\n+                } else if true {<|>\n+                    println!(\"foo\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {\n+                    println!(\"bar\");\n+                }\n+                println!(\"foo\");\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_else_if_nested_else() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {\n+                    println!(\"bar\");\n+                } else if true {\n+                    println!(\"foo\");\n+                } else {<|>\n+                    println!(\"else\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {\n+                    println!(\"bar\");\n+                } else if true {\n+                    println!(\"foo\");\n+                }\n+                println!(\"else\");\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_else_if_nested_middle() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {\n+                    println!(\"bar\");\n+                } else if true {<|>\n+                    println!(\"foo\");\n+                } else {\n+                    println!(\"else\");\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                //bar();\n+                if true {\n+                    println!(\"true\");\n+\n+                    //comment\n+                    //bar();\n+                } else if false {\n+                    println!(\"bar\");\n+                }\n+                println!(\"foo\");\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_bad_cursor_position() {\n+        check_assist_not_applicable(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                bar();<|>\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_for() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                for i in 0..5 {<|>\n+                    if true {\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_in_for() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                for i in 0..5 {\n+                    if true {<|>\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                for i in 0..5 {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_loop() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                loop {<|>\n+                    if true {\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_while() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                while true {<|>\n+                    if true {\n+                        foo();\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                if true {\n+                    foo();\n+\n+                    //comment\n+                    bar();\n+                } else {\n+                    println!(\"bar\");\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_if_in_while_bad_cursor_position() {\n+        check_assist_not_applicable(\n+            unwrap_block,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    if true {\n+                        foo();<|>\n+\n+                        //comment\n+                        bar();\n+                    } else {\n+                        println!(\"bar\");\n+                    }\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "464bc03dde9e77e0ca2359786424da8014f39675", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 78, "deletions": 229, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -10,119 +10,113 @@ macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n }\n \n-mod assist_ctx;\n-mod marks;\n+mod assist_config;\n+mod assist_context;\n #[cfg(test)]\n-mod doc_tests;\n+mod tests;\n pub mod utils;\n pub mod ast_transform;\n \n-use ra_db::{FileId, FileRange};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{TextRange, TextSize};\n-use ra_text_edit::TextEdit;\n-\n-pub(crate) use crate::assist_ctx::{Assist, AssistCtx, AssistHandler};\n use hir::Semantics;\n+use ra_db::FileRange;\n+use ra_ide_db::{source_change::SourceChange, RootDatabase};\n+use ra_syntax::TextRange;\n+\n+pub(crate) use crate::assist_context::{AssistContext, Assists};\n+\n+pub use assist_config::AssistConfig;\n \n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct AssistId(pub &'static str);\n \n-#[derive(Debug, Clone)]\n-pub struct AssistLabel {\n-    /// Short description of the assist, as shown in the UI.\n-    pub label: String,\n-    pub id: AssistId,\n-}\n-\n #[derive(Clone, Debug)]\n pub struct GroupLabel(pub String);\n \n-impl AssistLabel {\n-    pub(crate) fn new(label: String, id: AssistId) -> AssistLabel {\n-        // FIXME: make fields private, so that this invariant can't be broken\n-        assert!(label.starts_with(|c: char| c.is_uppercase()));\n-        AssistLabel { label, id }\n-    }\n-}\n-\n #[derive(Debug, Clone)]\n-pub struct AssistAction {\n-    pub edit: TextEdit,\n-    pub cursor_position: Option<TextSize>,\n-    // FIXME: This belongs to `AssistLabel`\n-    pub target: Option<TextRange>,\n-    pub file: AssistFile,\n+pub struct Assist {\n+    pub id: AssistId,\n+    /// Short description of the assist, as shown in the UI.\n+    pub label: String,\n+    pub group: Option<GroupLabel>,\n+    /// Target ranges are used to sort assists: the smaller the target range,\n+    /// the more specific assist is, and so it should be sorted first.\n+    pub target: TextRange,\n }\n \n #[derive(Debug, Clone)]\n pub struct ResolvedAssist {\n-    pub label: AssistLabel,\n-    pub group_label: Option<GroupLabel>,\n-    pub action: AssistAction,\n+    pub assist: Assist,\n+    pub source_change: SourceChange,\n }\n \n-#[derive(Debug, Clone, Copy)]\n-pub enum AssistFile {\n-    CurrentFile,\n-    TargetFile(FileId),\n-}\n-\n-impl Default for AssistFile {\n-    fn default() -> Self {\n-        Self::CurrentFile\n+impl Assist {\n+    /// Return all the assists applicable at the given position.\n+    ///\n+    /// Assists are returned in the \"unresolved\" state, that is only labels are\n+    /// returned, without actual edits.\n+    pub fn unresolved(db: &RootDatabase, config: &AssistConfig, range: FileRange) -> Vec<Assist> {\n+        let sema = Semantics::new(db);\n+        let ctx = AssistContext::new(sema, config, range);\n+        let mut acc = Assists::new_unresolved(&ctx);\n+        handlers::all().iter().for_each(|handler| {\n+            handler(&mut acc, &ctx);\n+        });\n+        acc.finish_unresolved()\n     }\n-}\n \n-/// Return all the assists applicable at the given position.\n-///\n-/// Assists are returned in the \"unresolved\" state, that is only labels are\n-/// returned, without actual edits.\n-pub fn unresolved_assists(db: &RootDatabase, range: FileRange) -> Vec<AssistLabel> {\n-    let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, false);\n-    handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|a| a.label)\n-        .collect()\n-}\n+    /// Return all the assists applicable at the given position.\n+    ///\n+    /// Assists are returned in the \"resolved\" state, that is with edit fully\n+    /// computed.\n+    pub fn resolved(\n+        db: &RootDatabase,\n+        config: &AssistConfig,\n+        range: FileRange,\n+    ) -> Vec<ResolvedAssist> {\n+        let sema = Semantics::new(db);\n+        let ctx = AssistContext::new(sema, config, range);\n+        let mut acc = Assists::new_resolved(&ctx);\n+        handlers::all().iter().for_each(|handler| {\n+            handler(&mut acc, &ctx);\n+        });\n+        acc.finish_resolved()\n+    }\n \n-/// Return all the assists applicable at the given position.\n-///\n-/// Assists are returned in the \"resolved\" state, that is with edit fully\n-/// computed.\n-pub fn resolved_assists(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n-    let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, true);\n-    let mut a = handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|it| it.into_resolved().unwrap())\n-        .collect::<Vec<_>>();\n-    a.sort_by_key(|it| it.action.target.map_or(TextSize::from(!0u32), |it| it.len()));\n-    a\n+    pub(crate) fn new(\n+        id: AssistId,\n+        label: String,\n+        group: Option<GroupLabel>,\n+        target: TextRange,\n+    ) -> Assist {\n+        // FIXME: make fields private, so that this invariant can't be broken\n+        assert!(label.starts_with(|c: char| c.is_uppercase()));\n+        Assist { id, label, group, target }\n+    }\n }\n \n mod handlers {\n-    use crate::AssistHandler;\n+    use crate::{AssistContext, Assists};\n+\n+    pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n     mod add_custom_impl;\n     mod add_derive;\n     mod add_explicit_type;\n+    mod add_from_impl_for_enum;\n     mod add_function;\n     mod add_impl;\n     mod add_missing_impl_members;\n     mod add_new;\n+    mod add_turbo_fish;\n     mod apply_demorgan;\n     mod auto_import;\n+    mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n     mod fill_match_arms;\n+    mod fix_visibility;\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n@@ -136,28 +130,32 @@ mod handlers {\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n+    mod reorder_fields;\n     mod replace_if_let_with_match;\n     mod replace_let_with_if_let;\n     mod replace_qualified_name_with_use;\n     mod replace_unwrap_with_match;\n     mod split_import;\n-    mod add_from_impl_for_enum;\n-    mod reorder_fields;\n+    mod unwrap_block;\n \n-    pub(crate) fn all() -> &'static [AssistHandler] {\n+    pub(crate) fn all() -> &'static [Handler] {\n         &[\n             // These are alphabetic for the foolish consistency\n             add_custom_impl::add_custom_impl,\n             add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n+            add_from_impl_for_enum::add_from_impl_for_enum,\n             add_function::add_function,\n             add_impl::add_impl,\n             add_new::add_new,\n+            add_turbo_fish::add_turbo_fish,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n+            change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n             fill_match_arms::fill_match_arms,\n+            fix_visibility::fix_visibility,\n             flip_binexpr::flip_binexpr,\n             flip_comma::flip_comma,\n             flip_trait_bound::flip_trait_bound,\n@@ -175,167 +173,18 @@ mod handlers {\n             raw_string::remove_hash,\n             remove_dbg::remove_dbg,\n             remove_mut::remove_mut,\n+            reorder_fields::reorder_fields,\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_let_with_if_let::replace_let_with_if_let,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             replace_unwrap_with_match::replace_unwrap_with_match,\n             split_import::split_import,\n-            add_from_impl_for_enum::add_from_impl_for_enum,\n+            unwrap_block::unwrap_block,\n             // These are manually sorted for better priorities\n             add_missing_impl_members::add_missing_impl_members,\n             add_missing_impl_members::add_missing_default_members,\n-            reorder_fields::reorder_fields,\n+            // Are you sure you want to add new assist here, and not to the\n+            // sorted list above?\n         ]\n     }\n }\n-\n-#[cfg(test)]\n-mod helpers {\n-    use std::sync::Arc;\n-\n-    use ra_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt};\n-    use ra_ide_db::{symbol_index::SymbolsDatabase, RootDatabase};\n-    use test_utils::{add_cursor, assert_eq_text, extract_range_or_offset, RangeOrOffset};\n-\n-    use crate::{AssistCtx, AssistFile, AssistHandler};\n-    use hir::Semantics;\n-\n-    pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n-        let (mut db, file_id) = RootDatabase::with_single_file(text);\n-        // FIXME: ideally, this should be done by the above `RootDatabase::with_single_file`,\n-        // but it looks like this might need specialization? :(\n-        db.set_local_roots(Arc::new(vec![db.file_source_root(file_id)]));\n-        (db, file_id)\n-    }\n-\n-    pub(crate) fn check_assist(\n-        assist: AssistHandler,\n-        ra_fixture_before: &str,\n-        ra_fixture_after: &str,\n-    ) {\n-        check(assist, ra_fixture_before, ExpectedResult::After(ra_fixture_after));\n-    }\n-\n-    // FIXME: instead of having a separate function here, maybe use\n-    // `extract_ranges` and mark the target as `<target> </target>` in the\n-    // fixuture?\n-    pub(crate) fn check_assist_target(assist: AssistHandler, ra_fixture: &str, target: &str) {\n-        check(assist, ra_fixture, ExpectedResult::Target(target));\n-    }\n-\n-    pub(crate) fn check_assist_not_applicable(assist: AssistHandler, ra_fixture: &str) {\n-        check(assist, ra_fixture, ExpectedResult::NotApplicable);\n-    }\n-\n-    enum ExpectedResult<'a> {\n-        NotApplicable,\n-        After(&'a str),\n-        Target(&'a str),\n-    }\n-\n-    fn check(assist: AssistHandler, before: &str, expected: ExpectedResult) {\n-        let (text_without_caret, file_with_caret_id, range_or_offset, db) =\n-            if before.contains(\"//-\") {\n-                let (mut db, position) = RootDatabase::with_position(before);\n-                db.set_local_roots(Arc::new(vec![db.file_source_root(position.file_id)]));\n-                (\n-                    db.file_text(position.file_id).as_ref().to_owned(),\n-                    position.file_id,\n-                    RangeOrOffset::Offset(position.offset),\n-                    db,\n-                )\n-            } else {\n-                let (range_or_offset, text_without_caret) = extract_range_or_offset(before);\n-                let (db, file_id) = with_single_file(&text_without_caret);\n-                (text_without_caret, file_id, range_or_offset, db)\n-            };\n-\n-        let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n-\n-        let sema = Semantics::new(&db);\n-        let assist_ctx = AssistCtx::new(&sema, frange, true);\n-\n-        match (assist(assist_ctx), expected) {\n-            (Some(assist), ExpectedResult::After(after)) => {\n-                let action = assist.0[0].action.clone().unwrap();\n-\n-                let assisted_file_text = if let AssistFile::TargetFile(file_id) = action.file {\n-                    db.file_text(file_id).as_ref().to_owned()\n-                } else {\n-                    text_without_caret\n-                };\n-\n-                let mut actual = action.edit.apply(&assisted_file_text);\n-                match action.cursor_position {\n-                    None => {\n-                        if let RangeOrOffset::Offset(before_cursor_pos) = range_or_offset {\n-                            let off = action\n-                                .edit\n-                                .apply_to_offset(before_cursor_pos)\n-                                .expect(\"cursor position is affected by the edit\");\n-                            actual = add_cursor(&actual, off)\n-                        }\n-                    }\n-                    Some(off) => actual = add_cursor(&actual, off),\n-                };\n-\n-                assert_eq_text!(after, &actual);\n-            }\n-            (Some(assist), ExpectedResult::Target(target)) => {\n-                let action = assist.0[0].action.clone().unwrap();\n-                let range = action.target.expect(\"expected target on action\");\n-                assert_eq_text!(&text_without_caret[range], target);\n-            }\n-            (Some(_), ExpectedResult::NotApplicable) => panic!(\"assist should not be applicable!\"),\n-            (None, ExpectedResult::After(_)) | (None, ExpectedResult::Target(_)) => {\n-                panic!(\"code action is not applicable\")\n-            }\n-            (None, ExpectedResult::NotApplicable) => (),\n-        };\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_db::FileRange;\n-    use ra_syntax::TextRange;\n-    use test_utils::{extract_offset, extract_range};\n-\n-    use crate::{helpers, resolved_assists};\n-\n-    #[test]\n-    fn assist_order_field_struct() {\n-        let before = \"struct Foo { <|>bar: u32 }\";\n-        let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, file_id) = helpers::with_single_file(&before);\n-        let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n-        let assists = resolved_assists(&db, frange);\n-        let mut assists = assists.iter();\n-\n-        assert_eq!(\n-            assists.next().expect(\"expected assist\").label.label,\n-            \"Change visibility to pub(crate)\"\n-        );\n-        assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Add `#[derive]`\");\n-    }\n-\n-    #[test]\n-    fn assist_order_if_expr() {\n-        let before = \"\n-        pub fn test_some_range(a: int) -> bool {\n-            if let 2..6 = <|>5<|> {\n-                true\n-            } else {\n-                false\n-            }\n-        }\";\n-        let (range, before) = extract_range(before);\n-        let (db, file_id) = helpers::with_single_file(&before);\n-        let frange = FileRange { file_id, range };\n-        let assists = resolved_assists(&db, frange);\n-        let mut assists = assists.iter();\n-\n-        assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Extract into variable\");\n-        assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Replace with match\");\n-    }\n-}"}, {"sha": "8d910205f0ab332d9fecc40cc94909e3c242abee", "filename": "crates/ra_assists/src/marks.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmarks.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,12 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks![\n-    introduce_var_in_comment_is_not_applicable\n-    test_introduce_var_expr_stmt\n-    test_introduce_var_last_expr\n-    not_applicable_outside_of_bind_pat\n-    test_not_inline_mut_variable\n-    test_not_applicable_if_variable_unused\n-    change_visibility_field_false_positive\n-    test_add_from_impl_already_exists\n-];"}, {"sha": "62dd3547fa23f6f5556367e22e807384d8de6870", "filename": "crates/ra_assists/src/tests.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,153 @@\n+mod generated;\n+\n+use std::sync::Arc;\n+\n+use hir::Semantics;\n+use ra_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt};\n+use ra_ide_db::{symbol_index::SymbolsDatabase, RootDatabase};\n+use ra_syntax::TextRange;\n+use test_utils::{\n+    assert_eq_text, extract_offset, extract_range, extract_range_or_offset, RangeOrOffset,\n+};\n+\n+use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, Assists};\n+\n+pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n+    let (mut db, file_id) = RootDatabase::with_single_file(text);\n+    // FIXME: ideally, this should be done by the above `RootDatabase::with_single_file`,\n+    // but it looks like this might need specialization? :(\n+    db.set_local_roots(Arc::new(vec![db.file_source_root(file_id)]));\n+    (db, file_id)\n+}\n+\n+pub(crate) fn check_assist(assist: Handler, ra_fixture_before: &str, ra_fixture_after: &str) {\n+    check(assist, ra_fixture_before, ExpectedResult::After(ra_fixture_after));\n+}\n+\n+// FIXME: instead of having a separate function here, maybe use\n+// `extract_ranges` and mark the target as `<target> </target>` in the\n+// fixuture?\n+pub(crate) fn check_assist_target(assist: Handler, ra_fixture: &str, target: &str) {\n+    check(assist, ra_fixture, ExpectedResult::Target(target));\n+}\n+\n+pub(crate) fn check_assist_not_applicable(assist: Handler, ra_fixture: &str) {\n+    check(assist, ra_fixture, ExpectedResult::NotApplicable);\n+}\n+\n+fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n+    let (selection, before) = extract_range_or_offset(before);\n+    let (db, file_id) = crate::tests::with_single_file(&before);\n+    let frange = FileRange { file_id, range: selection.into() };\n+\n+    let mut assist = Assist::resolved(&db, &AssistConfig::default(), frange)\n+        .into_iter()\n+        .find(|assist| assist.assist.id.0 == assist_id)\n+        .unwrap_or_else(|| {\n+            panic!(\n+                \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n+                assist_id,\n+                Assist::resolved(&db, &AssistConfig::default(), frange)\n+                    .into_iter()\n+                    .map(|assist| assist.assist.id.0)\n+                    .collect::<Vec<_>>()\n+                    .join(\", \")\n+            )\n+        });\n+\n+    let actual = {\n+        let change = assist.source_change.source_file_edits.pop().unwrap();\n+        let mut actual = before.clone();\n+        change.edit.apply(&mut actual);\n+        actual\n+    };\n+    assert_eq_text!(after, &actual);\n+}\n+\n+enum ExpectedResult<'a> {\n+    NotApplicable,\n+    After(&'a str),\n+    Target(&'a str),\n+}\n+\n+fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n+    let (text_without_caret, file_with_caret_id, range_or_offset, db) = if before.contains(\"//-\") {\n+        let (mut db, position) = RootDatabase::with_position(before);\n+        db.set_local_roots(Arc::new(vec![db.file_source_root(position.file_id)]));\n+        (\n+            db.file_text(position.file_id).as_ref().to_owned(),\n+            position.file_id,\n+            RangeOrOffset::Offset(position.offset),\n+            db,\n+        )\n+    } else {\n+        let (range_or_offset, text_without_caret) = extract_range_or_offset(before);\n+        let (db, file_id) = with_single_file(&text_without_caret);\n+        (text_without_caret, file_id, range_or_offset, db)\n+    };\n+\n+    let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n+\n+    let sema = Semantics::new(&db);\n+    let config = AssistConfig::default();\n+    let ctx = AssistContext::new(sema, &config, frange);\n+    let mut acc = Assists::new_resolved(&ctx);\n+    handler(&mut acc, &ctx);\n+    let mut res = acc.finish_resolved();\n+    let assist = res.pop();\n+    match (assist, expected) {\n+        (Some(assist), ExpectedResult::After(after)) => {\n+            let mut source_change = assist.source_change;\n+            let change = source_change.source_file_edits.pop().unwrap();\n+\n+            let mut actual = db.file_text(change.file_id).as_ref().to_owned();\n+            change.edit.apply(&mut actual);\n+            assert_eq_text!(after, &actual);\n+        }\n+        (Some(assist), ExpectedResult::Target(target)) => {\n+            let range = assist.assist.target;\n+            assert_eq_text!(&text_without_caret[range], target);\n+        }\n+        (Some(_), ExpectedResult::NotApplicable) => panic!(\"assist should not be applicable!\"),\n+        (None, ExpectedResult::After(_)) | (None, ExpectedResult::Target(_)) => {\n+            panic!(\"code action is not applicable\")\n+        }\n+        (None, ExpectedResult::NotApplicable) => (),\n+    };\n+}\n+\n+#[test]\n+fn assist_order_field_struct() {\n+    let before = \"struct Foo { <|>bar: u32 }\";\n+    let (before_cursor_pos, before) = extract_offset(before);\n+    let (db, file_id) = with_single_file(&before);\n+    let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n+    let assists = Assist::resolved(&db, &AssistConfig::default(), frange);\n+    let mut assists = assists.iter();\n+\n+    assert_eq!(\n+        assists.next().expect(\"expected assist\").assist.label,\n+        \"Change visibility to pub(crate)\"\n+    );\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Add `#[derive]`\");\n+}\n+\n+#[test]\n+fn assist_order_if_expr() {\n+    let before = \"\n+    pub fn test_some_range(a: int) -> bool {\n+        if let 2..6 = <|>5<|> {\n+            true\n+        } else {\n+            false\n+        }\n+    }\";\n+    let (range, before) = extract_range(before);\n+    let (db, file_id) = with_single_file(&before);\n+    let frange = FileRange { file_id, range };\n+    let assists = Assist::resolved(&db, &AssistConfig::default(), frange);\n+    let mut assists = assists.iter();\n+\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Replace with match\");\n+}"}, {"sha": "250e56a6962468193c3abe38681e596f1dd6b3a3", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "renamed", "additions": 125, "deletions": 49, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,10 +1,10 @@\n //! Generated file, do not edit by hand, see `xtask/src/codegen`\n \n-use super::check;\n+use super::check_doc_test;\n \n #[test]\n fn doctest_add_custom_impl() {\n-    check(\n+    check_doc_test(\n         \"add_custom_impl\",\n         r#####\"\n #[derive(Deb<|>ug, Display)]\n@@ -15,15 +15,15 @@ struct S;\n struct S;\n \n impl Debug for S {\n-\n+    $0\n }\n \"#####,\n     )\n }\n \n #[test]\n fn doctest_add_derive() {\n-    check(\n+    check_doc_test(\n         \"add_derive\",\n         r#####\"\n struct Point {\n@@ -32,7 +32,7 @@ struct Point {\n }\n \"#####,\n         r#####\"\n-#[derive()]\n+#[derive($0)]\n struct Point {\n     x: u32,\n     y: u32,\n@@ -43,7 +43,7 @@ struct Point {\n \n #[test]\n fn doctest_add_explicit_type() {\n-    check(\n+    check_doc_test(\n         \"add_explicit_type\",\n         r#####\"\n fn main() {\n@@ -60,7 +60,7 @@ fn main() {\n \n #[test]\n fn doctest_add_function() {\n-    check(\n+    check_doc_test(\n         \"add_function\",\n         r#####\"\n struct Baz;\n@@ -78,7 +78,7 @@ fn foo() {\n }\n \n fn bar(arg: &str, baz: Baz) {\n-    todo!()\n+    ${0:todo!()}\n }\n \n \"#####,\n@@ -87,7 +87,7 @@ fn bar(arg: &str, baz: Baz) {\n \n #[test]\n fn doctest_add_hash() {\n-    check(\n+    check_doc_test(\n         \"add_hash\",\n         r#####\"\n fn main() {\n@@ -104,28 +104,28 @@ fn main() {\n \n #[test]\n fn doctest_add_impl() {\n-    check(\n+    check_doc_test(\n         \"add_impl\",\n         r#####\"\n struct Ctx<T: Clone> {\n-     data: T,<|>\n+    data: T,<|>\n }\n \"#####,\n         r#####\"\n struct Ctx<T: Clone> {\n-     data: T,\n+    data: T,\n }\n \n impl<T: Clone> Ctx<T> {\n-\n+    $0\n }\n \"#####,\n     )\n }\n \n #[test]\n fn doctest_add_impl_default_members() {\n-    check(\n+    check_doc_test(\n         \"add_impl_default_members\",\n         r#####\"\n trait Trait {\n@@ -150,7 +150,7 @@ trait Trait {\n impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\n-    fn bar(&self) {}\n+    $0fn bar(&self) {}\n \n }\n \"#####,\n@@ -159,7 +159,7 @@ impl Trait for () {\n \n #[test]\n fn doctest_add_impl_missing_members() {\n-    check(\n+    check_doc_test(\n         \"add_impl_missing_members\",\n         r#####\"\n trait Trait<T> {\n@@ -180,7 +180,9 @@ trait Trait<T> {\n }\n \n impl Trait<u32> for () {\n-    fn foo(&self) -> u32 { todo!() }\n+    fn foo(&self) -> u32 {\n+        ${0:todo!()}\n+    }\n \n }\n \"#####,\n@@ -189,7 +191,7 @@ impl Trait<u32> for () {\n \n #[test]\n fn doctest_add_new() {\n-    check(\n+    check_doc_test(\n         \"add_new\",\n         r#####\"\n struct Ctx<T: Clone> {\n@@ -202,16 +204,35 @@ struct Ctx<T: Clone> {\n }\n \n impl<T: Clone> Ctx<T> {\n-    fn new(data: T) -> Self { Self { data } }\n+    fn $0new(data: T) -> Self { Self { data } }\n }\n \n \"#####,\n     )\n }\n \n+#[test]\n+fn doctest_add_turbo_fish() {\n+    check_doc_test(\n+        \"add_turbo_fish\",\n+        r#####\"\n+fn make<T>() -> T { todo!() }\n+fn main() {\n+    let x = make<|>();\n+}\n+\"#####,\n+        r#####\"\n+fn make<T>() -> T { todo!() }\n+fn main() {\n+    let x = make::<${0:_}>();\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_apply_demorgan() {\n-    check(\n+    check_doc_test(\n         \"apply_demorgan\",\n         r#####\"\n fn main() {\n@@ -228,7 +249,7 @@ fn main() {\n \n #[test]\n fn doctest_auto_import() {\n-    check(\n+    check_doc_test(\n         \"auto_import\",\n         r#####\"\n fn main() {\n@@ -247,9 +268,22 @@ pub mod std { pub mod collections { pub struct HashMap { } } }\n     )\n }\n \n+#[test]\n+fn doctest_change_return_type_to_result() {\n+    check_doc_test(\n+        \"change_return_type_to_result\",\n+        r#####\"\n+fn foo() -> i32<|> { 42i32 }\n+\"#####,\n+        r#####\"\n+fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_change_visibility() {\n-    check(\n+    check_doc_test(\n         \"change_visibility\",\n         r#####\"\n <|>fn frobnicate() {}\n@@ -262,7 +296,7 @@ pub(crate) fn frobnicate() {}\n \n #[test]\n fn doctest_convert_to_guarded_return() {\n-    check(\n+    check_doc_test(\n         \"convert_to_guarded_return\",\n         r#####\"\n fn main() {\n@@ -286,7 +320,7 @@ fn main() {\n \n #[test]\n fn doctest_fill_match_arms() {\n-    check(\n+    check_doc_test(\n         \"fill_match_arms\",\n         r#####\"\n enum Action { Move { distance: u32 }, Stop }\n@@ -302,17 +336,40 @@ enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n     match action {\n-        Action::Move { distance } => {}\n+        $0Action::Move { distance } => {}\n         Action::Stop => {}\n     }\n }\n \"#####,\n     )\n }\n \n+#[test]\n+fn doctest_fix_visibility() {\n+    check_doc_test(\n+        \"fix_visibility\",\n+        r#####\"\n+mod m {\n+    fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate<|>() {}\n+}\n+\"#####,\n+        r#####\"\n+mod m {\n+    $0pub(crate) fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate() {}\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_flip_binexpr() {\n-    check(\n+    check_doc_test(\n         \"flip_binexpr\",\n         r#####\"\n fn main() {\n@@ -329,7 +386,7 @@ fn main() {\n \n #[test]\n fn doctest_flip_comma() {\n-    check(\n+    check_doc_test(\n         \"flip_comma\",\n         r#####\"\n fn main() {\n@@ -346,7 +403,7 @@ fn main() {\n \n #[test]\n fn doctest_flip_trait_bound() {\n-    check(\n+    check_doc_test(\n         \"flip_trait_bound\",\n         r#####\"\n fn foo<T: Clone +<|> Copy>() { }\n@@ -359,7 +416,7 @@ fn foo<T: Copy + Clone>() { }\n \n #[test]\n fn doctest_inline_local_variable() {\n-    check(\n+    check_doc_test(\n         \"inline_local_variable\",\n         r#####\"\n fn main() {\n@@ -377,7 +434,7 @@ fn main() {\n \n #[test]\n fn doctest_introduce_variable() {\n-    check(\n+    check_doc_test(\n         \"introduce_variable\",\n         r#####\"\n fn main() {\n@@ -386,7 +443,7 @@ fn main() {\n \"#####,\n         r#####\"\n fn main() {\n-    let var_name = (1 + 2);\n+    let $0var_name = (1 + 2);\n     var_name * 4;\n }\n \"#####,\n@@ -395,7 +452,7 @@ fn main() {\n \n #[test]\n fn doctest_invert_if() {\n-    check(\n+    check_doc_test(\n         \"invert_if\",\n         r#####\"\n fn main() {\n@@ -412,7 +469,7 @@ fn main() {\n \n #[test]\n fn doctest_make_raw_string() {\n-    check(\n+    check_doc_test(\n         \"make_raw_string\",\n         r#####\"\n fn main() {\n@@ -429,7 +486,7 @@ fn main() {\n \n #[test]\n fn doctest_make_usual_string() {\n-    check(\n+    check_doc_test(\n         \"make_usual_string\",\n         r#####\"\n fn main() {\n@@ -446,7 +503,7 @@ fn main() {\n \n #[test]\n fn doctest_merge_imports() {\n-    check(\n+    check_doc_test(\n         \"merge_imports\",\n         r#####\"\n use std::<|>fmt::Formatter;\n@@ -460,7 +517,7 @@ use std::{fmt::Formatter, io};\n \n #[test]\n fn doctest_merge_match_arms() {\n-    check(\n+    check_doc_test(\n         \"merge_match_arms\",\n         r#####\"\n enum Action { Move { distance: u32 }, Stop }\n@@ -486,7 +543,7 @@ fn handle(action: Action) {\n \n #[test]\n fn doctest_move_arm_cond_to_match_guard() {\n-    check(\n+    check_doc_test(\n         \"move_arm_cond_to_match_guard\",\n         r#####\"\n enum Action { Move { distance: u32 }, Stop }\n@@ -513,7 +570,7 @@ fn handle(action: Action) {\n \n #[test]\n fn doctest_move_bounds_to_where_clause() {\n-    check(\n+    check_doc_test(\n         \"move_bounds_to_where_clause\",\n         r#####\"\n fn apply<T, U, <|>F: FnOnce(T) -> U>(f: F, x: T) -> U {\n@@ -530,7 +587,7 @@ fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n \n #[test]\n fn doctest_move_guard_to_arm_body() {\n-    check(\n+    check_doc_test(\n         \"move_guard_to_arm_body\",\n         r#####\"\n enum Action { Move { distance: u32 }, Stop }\n@@ -557,7 +614,7 @@ fn handle(action: Action) {\n \n #[test]\n fn doctest_remove_dbg() {\n-    check(\n+    check_doc_test(\n         \"remove_dbg\",\n         r#####\"\n fn main() {\n@@ -574,7 +631,7 @@ fn main() {\n \n #[test]\n fn doctest_remove_hash() {\n-    check(\n+    check_doc_test(\n         \"remove_hash\",\n         r#####\"\n fn main() {\n@@ -591,7 +648,7 @@ fn main() {\n \n #[test]\n fn doctest_remove_mut() {\n-    check(\n+    check_doc_test(\n         \"remove_mut\",\n         r#####\"\n impl Walrus {\n@@ -608,7 +665,7 @@ impl Walrus {\n \n #[test]\n fn doctest_reorder_fields() {\n-    check(\n+    check_doc_test(\n         \"reorder_fields\",\n         r#####\"\n struct Foo {foo: i32, bar: i32};\n@@ -623,7 +680,7 @@ const test: Foo = Foo {foo: 1, bar: 0}\n \n #[test]\n fn doctest_replace_if_let_with_match() {\n-    check(\n+    check_doc_test(\n         \"replace_if_let_with_match\",\n         r#####\"\n enum Action { Move { distance: u32 }, Stop }\n@@ -651,7 +708,7 @@ fn handle(action: Action) {\n \n #[test]\n fn doctest_replace_let_with_if_let() {\n-    check(\n+    check_doc_test(\n         \"replace_let_with_if_let\",\n         r#####\"\n enum Option<T> { Some(T), None }\n@@ -677,7 +734,7 @@ fn compute() -> Option<i32> { None }\n \n #[test]\n fn doctest_replace_qualified_name_with_use() {\n-    check(\n+    check_doc_test(\n         \"replace_qualified_name_with_use\",\n         r#####\"\n fn process(map: std::collections::<|>HashMap<String, String>) {}\n@@ -692,7 +749,7 @@ fn process(map: HashMap<String, String>) {}\n \n #[test]\n fn doctest_replace_unwrap_with_match() {\n-    check(\n+    check_doc_test(\n         \"replace_unwrap_with_match\",\n         r#####\"\n enum Result<T, E> { Ok(T), Err(E) }\n@@ -707,7 +764,7 @@ fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n     let y = match x {\n         Ok(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     };\n }\n \"#####,\n@@ -716,7 +773,7 @@ fn main() {\n \n #[test]\n fn doctest_split_import() {\n-    check(\n+    check_doc_test(\n         \"split_import\",\n         r#####\"\n use std::<|>collections::HashMap;\n@@ -726,3 +783,22 @@ use std::{collections::HashMap};\n \"#####,\n     )\n }\n+\n+#[test]\n+fn doctest_unwrap_block() {\n+    check_doc_test(\n+        \"unwrap_block\",\n+        r#####\"\n+fn foo() {\n+    if true {<|>\n+        println!(\"foo\");\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    println!(\"foo\");\n+}\n+\"#####,\n+    )\n+}", "previous_filename": "crates/ra_assists/src/doc_tests/generated.rs"}, {"sha": "0038a9764b15da65f5a82c61404afd9f66c2b871", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 77, "deletions": 17, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,19 +1,58 @@\n //! Assorted functions shared by several assists.\n pub(crate) mod insert_use;\n \n-use std::iter;\n+use std::{iter, ops};\n \n-use hir::{Adt, Crate, Semantics, Trait, Type};\n+use hir::{Adt, Crate, Enum, ScopeDef, Semantics, Trait, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, make, NameOwner},\n-    AstNode, T,\n+    AstNode, SyntaxNode, T,\n };\n use rustc_hash::FxHashSet;\n \n-pub use insert_use::insert_use_statement;\n+use crate::assist_config::SnippetCap;\n \n-pub fn get_missing_impl_items(\n+pub(crate) use insert_use::insert_use_statement;\n+\n+#[derive(Clone, Copy, Debug)]\n+pub(crate) enum Cursor<'a> {\n+    Replace(&'a SyntaxNode),\n+    Before(&'a SyntaxNode),\n+}\n+\n+impl<'a> Cursor<'a> {\n+    fn node(self) -> &'a SyntaxNode {\n+        match self {\n+            Cursor::Replace(node) | Cursor::Before(node) => node,\n+        }\n+    }\n+}\n+\n+pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor) -> String {\n+    assert!(cursor.node().ancestors().any(|it| it == *node));\n+    let range = cursor.node().text_range() - node.text_range().start();\n+    let range: ops::Range<usize> = range.into();\n+\n+    let mut placeholder = cursor.node().to_string();\n+    escape(&mut placeholder);\n+    let tab_stop = match cursor {\n+        Cursor::Replace(placeholder) => format!(\"${{0:{}}}\", placeholder),\n+        Cursor::Before(placeholder) => format!(\"$0{}\", placeholder),\n+    };\n+\n+    let mut buf = node.to_string();\n+    buf.replace_range(range, &tab_stop);\n+    return buf;\n+\n+    fn escape(buf: &mut String) {\n+        stdx::replace(buf, '{', r\"\\{\");\n+        stdx::replace(buf, '}', r\"\\}\");\n+        stdx::replace(buf, '$', r\"\\$\");\n+    }\n+}\n+\n+pub fn get_missing_assoc_items(\n     sema: &Semantics<RootDatabase>,\n     impl_def: &ast::ImplDef,\n ) -> Vec<hir::AssocItem> {\n@@ -23,21 +62,21 @@ pub fn get_missing_impl_items(\n     let mut impl_type = FxHashSet::default();\n \n     if let Some(item_list) = impl_def.item_list() {\n-        for item in item_list.impl_items() {\n+        for item in item_list.assoc_items() {\n             match item {\n-                ast::ImplItem::FnDef(f) => {\n+                ast::AssocItem::FnDef(f) => {\n                     if let Some(n) = f.name() {\n                         impl_fns_consts.insert(n.syntax().to_string());\n                     }\n                 }\n \n-                ast::ImplItem::TypeAliasDef(t) => {\n+                ast::AssocItem::TypeAliasDef(t) => {\n                     if let Some(n) = t.name() {\n                         impl_type.insert(n.syntax().to_string());\n                     }\n                 }\n \n-                ast::ImplItem::ConstDef(c) => {\n+                ast::AssocItem::ConstDef(c) => {\n                     if let Some(n) = c.name() {\n                         impl_fns_consts.insert(n.syntax().to_string());\n                     }\n@@ -103,15 +142,15 @@ fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n }\n \n #[derive(Clone, Copy)]\n-pub(crate) enum TryEnum {\n+pub enum TryEnum {\n     Result,\n     Option,\n }\n \n impl TryEnum {\n     const ALL: [TryEnum; 2] = [TryEnum::Option, TryEnum::Result];\n \n-    pub(crate) fn from_ty(sema: &Semantics<RootDatabase>, ty: &Type) -> Option<TryEnum> {\n+    pub fn from_ty(sema: &Semantics<RootDatabase>, ty: &Type) -> Option<TryEnum> {\n         let enum_ = match ty.as_adt() {\n             Some(Adt::Enum(it)) => it,\n             _ => return None,\n@@ -161,13 +200,19 @@ impl FamousDefs<'_, '_> {\n     #[cfg(test)]\n     pub(crate) const FIXTURE: &'static str = r#\"\n //- /libcore.rs crate:core\n-pub mod convert{\n+pub mod convert {\n     pub trait From<T> {\n         fn from(T) -> Self;\n     }\n }\n \n-pub mod prelude { pub use crate::convert::From }\n+pub mod option {\n+    pub enum Option<T> { None, Some(T)}\n+}\n+\n+pub mod prelude {\n+    pub use crate::{convert::From, option::Option::{self, *}};\n+}\n #[prelude_import]\n pub use prelude::*;\n \"#;\n@@ -176,7 +221,25 @@ pub use prelude::*;\n         self.find_trait(\"core:convert:From\")\n     }\n \n+    pub(crate) fn core_option_Option(&self) -> Option<Enum> {\n+        self.find_enum(\"core:option:Option\")\n+    }\n+\n     fn find_trait(&self, path: &str) -> Option<Trait> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find_enum(&self, path: &str) -> Option<Enum> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(it))) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find_def(&self, path: &str) -> Option<ScopeDef> {\n         let db = self.0.db;\n         let mut path = path.split(':');\n         let trait_ = path.next_back()?;\n@@ -201,9 +264,6 @@ pub use prelude::*;\n         }\n         let def =\n             module.scope(db, None).into_iter().find(|(name, _def)| &name.to_string() == trait_)?.1;\n-        match def {\n-            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n-            _ => None,\n-        }\n+        Some(def)\n     }\n }"}, {"sha": "0ee43482f79856a7a1f7fa963d6e89cdd3d6ac39", "filename": "crates/ra_assists/src/utils/insert_use.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -11,17 +11,20 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n+use crate::assist_context::AssistContext;\n+\n /// Creates and inserts a use statement for the given path to import.\n /// The use statement is inserted in the scope most appropriate to the\n /// the cursor position given, additionally merged with the existing use imports.\n-pub fn insert_use_statement(\n+pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n     path_to_import: &ModPath,\n-    edit: &mut TextEditBuilder,\n+    ctx: &AssistContext,\n+    builder: &mut TextEditBuilder,\n ) {\n     let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n-    let container = position.ancestors().find_map(|n| {\n+    let container = ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n         if let Some(module) = ast::Module::cast(n.clone()) {\n             return module.item_list().map(|it| it.syntax().clone());\n         }\n@@ -30,7 +33,7 @@ pub fn insert_use_statement(\n \n     if let Some(container) = container {\n         let action = best_action_for_target(container, position.clone(), &target);\n-        make_assist(&action, &target, edit);\n+        make_assist(&action, &target, builder);\n     }\n }\n "}, {"sha": "57feabcb27cb57e981aa2898113716ff94cdb971", "filename": "crates/ra_cfg/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -2,8 +2,6 @@\n \n mod cfg_expr;\n \n-use std::iter::IntoIterator;\n-\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n@@ -48,9 +46,4 @@ impl CfgOptions {\n     pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n         self.key_values.insert((key, value));\n     }\n-\n-    /// Shortcut to set features\n-    pub fn insert_features(&mut self, iter: impl IntoIterator<Item = SmolStr>) {\n-        iter.into_iter().for_each(|feat| self.insert_key_value(\"feature\".into(), feat));\n-    }\n }"}, {"sha": "f8f7670919c28d1f886df868aeab9f13adbdede6", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,4 +1,62 @@\n-//! FIXME: write short doc here\n+//! Fixtures are strings containing rust source code with optional metadata.\n+//! A fixture without metadata is parsed into a single source file.\n+//! Use this to test functionality local to one file.\n+//!\n+//! Simple Example:\n+//! ```\n+//! r#\"\n+//! fn main() {\n+//!     println!(\"Hello World\")\n+//! }\n+//! \"#\n+//! ```\n+//!\n+//! Metadata can be added to a fixture after a `//-` comment.\n+//! The basic form is specifying filenames,\n+//! which is also how to define multiple files in a single test fixture\n+//!\n+//! Example using two files in the same crate:\n+//! ```\n+//! \"\n+//! //- /main.rs\n+//! mod foo;\n+//! fn main() {\n+//!     foo::bar();\n+//! }\n+//!\n+//! //- /foo.rs\n+//! pub fn bar() {}\n+//! \"\n+//! ```\n+//!\n+//! Example using two crates with one file each, with one crate depending on the other:\n+//! ```\n+//! r#\"\n+//! //- /main.rs crate:a deps:b\n+//! fn main() {\n+//!     b::foo();\n+//! }\n+//! //- /lib.rs crate:b\n+//! pub fn b() {\n+//!     println!(\"Hello World\")\n+//! }\n+//! \"#\n+//! ```\n+//!\n+//! Metadata allows specifying all settings and variables\n+//! that are available in a real rust project:\n+//! - crate names via `crate:cratename`\n+//! - dependencies via `deps:dep1,dep2`\n+//! - configuration settings via `cfg:dbg=false,opt_level=2`\n+//! - environment variables via `env:PATH=/bin,RUST_LOG=debug`\n+//!\n+//! Example using all available metadata:\n+//! ```\n+//! \"\n+//! //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n+//! fn insert_source_code_here() {}\n+//! \"\n+//! ```\n \n use std::str::FromStr;\n use std::sync::Arc;"}, {"sha": "1aa39badea967a560418fc0f76ad8b7d85d54ef6", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,13 +4,13 @@ name = \"ra_flycheck\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n crossbeam-channel = \"0.4.0\"\n-lsp-types = { version = \"0.74.0\", features = [\"proposed\"] }\n log = \"0.4.8\"\n-cargo_metadata = \"0.9.1\"\n+cargo_metadata = \"0.10.0\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n-\n-[dev-dependencies]\n-insta = \"0.16.0\"\n+ra_toolchain = { path = \"../ra_toolchain\" }"}, {"sha": "817543deb1977c288420326cf5f4b1234d56cefc", "filename": "crates/ra_flycheck/src/conv.rs", "status": "removed", "additions": 0, "deletions": 341, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_flycheck%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_flycheck%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Fconv.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,341 +0,0 @@\n-//! This module provides the functionality needed to convert diagnostics from\n-//! `cargo check` json format to the LSP diagnostic format.\n-use cargo_metadata::diagnostic::{\n-    Applicability, Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan,\n-    DiagnosticSpanMacroExpansion,\n-};\n-use lsp_types::{\n-    CodeAction, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag,\n-    Location, NumberOrString, Position, Range, TextEdit, Url, WorkspaceEdit,\n-};\n-use std::{\n-    collections::HashMap,\n-    fmt::Write,\n-    path::{Component, Path, PathBuf, Prefix},\n-    str::FromStr,\n-};\n-\n-#[cfg(test)]\n-mod test;\n-\n-/// Converts a Rust level string to a LSP severity\n-fn map_level_to_severity(val: DiagnosticLevel) -> Option<DiagnosticSeverity> {\n-    match val {\n-        DiagnosticLevel::Ice => Some(DiagnosticSeverity::Error),\n-        DiagnosticLevel::Error => Some(DiagnosticSeverity::Error),\n-        DiagnosticLevel::Warning => Some(DiagnosticSeverity::Warning),\n-        DiagnosticLevel::Note => Some(DiagnosticSeverity::Information),\n-        DiagnosticLevel::Help => Some(DiagnosticSeverity::Hint),\n-        DiagnosticLevel::Unknown => None,\n-    }\n-}\n-\n-/// Check whether a file name is from macro invocation\n-fn is_from_macro(file_name: &str) -> bool {\n-    file_name.starts_with('<') && file_name.ends_with('>')\n-}\n-\n-/// Converts a Rust macro span to a LSP location recursively\n-fn map_macro_span_to_location(\n-    span_macro: &DiagnosticSpanMacroExpansion,\n-    workspace_root: &PathBuf,\n-) -> Option<Location> {\n-    if !is_from_macro(&span_macro.span.file_name) {\n-        return Some(map_span_to_location(&span_macro.span, workspace_root));\n-    }\n-\n-    if let Some(expansion) = &span_macro.span.expansion {\n-        return map_macro_span_to_location(&expansion, workspace_root);\n-    }\n-\n-    None\n-}\n-\n-/// Converts a Rust span to a LSP location, resolving macro expansion site if neccesary\n-fn map_span_to_location(span: &DiagnosticSpan, workspace_root: &PathBuf) -> Location {\n-    if span.expansion.is_some() {\n-        let expansion = span.expansion.as_ref().unwrap();\n-        if let Some(macro_range) = map_macro_span_to_location(&expansion, workspace_root) {\n-            return macro_range;\n-        }\n-    }\n-\n-    map_span_to_location_naive(span, workspace_root)\n-}\n-\n-/// Converts a Rust span to a LSP location\n-fn map_span_to_location_naive(span: &DiagnosticSpan, workspace_root: &PathBuf) -> Location {\n-    let mut file_name = workspace_root.clone();\n-    file_name.push(&span.file_name);\n-    let uri = url_from_path_with_drive_lowercasing(file_name).unwrap();\n-\n-    let range = Range::new(\n-        Position::new(span.line_start as u64 - 1, span.column_start as u64 - 1),\n-        Position::new(span.line_end as u64 - 1, span.column_end as u64 - 1),\n-    );\n-\n-    Location { uri, range }\n-}\n-\n-/// Converts a secondary Rust span to a LSP related information\n-///\n-/// If the span is unlabelled this will return `None`.\n-fn map_secondary_span_to_related(\n-    span: &DiagnosticSpan,\n-    workspace_root: &PathBuf,\n-) -> Option<DiagnosticRelatedInformation> {\n-    if let Some(label) = &span.label {\n-        let location = map_span_to_location(span, workspace_root);\n-        Some(DiagnosticRelatedInformation { location, message: label.clone() })\n-    } else {\n-        // Nothing to label this with\n-        None\n-    }\n-}\n-\n-/// Determines if diagnostic is related to unused code\n-fn is_unused_or_unnecessary(rd: &RustDiagnostic) -> bool {\n-    if let Some(code) = &rd.code {\n-        match code.code.as_str() {\n-            \"dead_code\" | \"unknown_lints\" | \"unreachable_code\" | \"unused_attributes\"\n-            | \"unused_imports\" | \"unused_macros\" | \"unused_variables\" => true,\n-            _ => false,\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Determines if diagnostic is related to deprecated code\n-fn is_deprecated(rd: &RustDiagnostic) -> bool {\n-    if let Some(code) = &rd.code {\n-        match code.code.as_str() {\n-            \"deprecated\" => true,\n-            _ => false,\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-enum MappedRustChildDiagnostic {\n-    Related(DiagnosticRelatedInformation),\n-    SuggestedFix(CodeAction),\n-    MessageLine(String),\n-}\n-\n-fn map_rust_child_diagnostic(\n-    rd: &RustDiagnostic,\n-    workspace_root: &PathBuf,\n-) -> MappedRustChildDiagnostic {\n-    let spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n-    if spans.is_empty() {\n-        // `rustc` uses these spanless children as a way to print multi-line\n-        // messages\n-        return MappedRustChildDiagnostic::MessageLine(rd.message.clone());\n-    }\n-\n-    let mut edit_map: HashMap<Url, Vec<TextEdit>> = HashMap::new();\n-    for &span in &spans {\n-        match (&span.suggestion_applicability, &span.suggested_replacement) {\n-            (Some(Applicability::MachineApplicable), Some(suggested_replacement)) => {\n-                let location = map_span_to_location(span, workspace_root);\n-                let edit = TextEdit::new(location.range, suggested_replacement.clone());\n-                edit_map.entry(location.uri).or_default().push(edit);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    if !edit_map.is_empty() {\n-        MappedRustChildDiagnostic::SuggestedFix(CodeAction {\n-            title: rd.message.clone(),\n-            kind: Some(\"quickfix\".to_string()),\n-            diagnostics: None,\n-            edit: Some(WorkspaceEdit::new(edit_map)),\n-            command: None,\n-            is_preferred: None,\n-        })\n-    } else {\n-        MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n-            location: map_span_to_location(spans[0], workspace_root),\n-            message: rd.message.clone(),\n-        })\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct MappedRustDiagnostic {\n-    pub location: Location,\n-    pub diagnostic: Diagnostic,\n-    pub fixes: Vec<CodeAction>,\n-}\n-\n-/// Converts a Rust root diagnostic to LSP form\n-///\n-/// This flattens the Rust diagnostic by:\n-///\n-/// 1. Creating a LSP diagnostic with the root message and primary span.\n-/// 2. Adding any labelled secondary spans to `relatedInformation`\n-/// 3. Categorising child diagnostics as either `SuggestedFix`es,\n-///    `relatedInformation` or additional message lines.\n-///\n-/// If the diagnostic has no primary span this will return `None`\n-pub(crate) fn map_rust_diagnostic_to_lsp(\n-    rd: &RustDiagnostic,\n-    workspace_root: &PathBuf,\n-) -> Vec<MappedRustDiagnostic> {\n-    let primary_spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n-    if primary_spans.is_empty() {\n-        return vec![];\n-    }\n-\n-    let severity = map_level_to_severity(rd.level);\n-\n-    let mut source = String::from(\"rustc\");\n-    let mut code = rd.code.as_ref().map(|c| c.code.clone());\n-    if let Some(code_val) = &code {\n-        // See if this is an RFC #2103 scoped lint (e.g. from Clippy)\n-        let scoped_code: Vec<&str> = code_val.split(\"::\").collect();\n-        if scoped_code.len() == 2 {\n-            source = String::from(scoped_code[0]);\n-            code = Some(String::from(scoped_code[1]));\n-        }\n-    }\n-\n-    let mut needs_primary_span_label = true;\n-    let mut related_information = vec![];\n-    let mut tags = vec![];\n-\n-    for secondary_span in rd.spans.iter().filter(|s| !s.is_primary) {\n-        let related = map_secondary_span_to_related(secondary_span, workspace_root);\n-        if let Some(related) = related {\n-            related_information.push(related);\n-        }\n-    }\n-\n-    let mut fixes = vec![];\n-    let mut message = rd.message.clone();\n-    for child in &rd.children {\n-        let child = map_rust_child_diagnostic(&child, workspace_root);\n-        match child {\n-            MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n-            MappedRustChildDiagnostic::SuggestedFix(code_action) => fixes.push(code_action),\n-            MappedRustChildDiagnostic::MessageLine(message_line) => {\n-                write!(&mut message, \"\\n{}\", message_line).unwrap();\n-\n-                // These secondary messages usually duplicate the content of the\n-                // primary span label.\n-                needs_primary_span_label = false;\n-            }\n-        }\n-    }\n-\n-    if is_unused_or_unnecessary(rd) {\n-        tags.push(DiagnosticTag::Unnecessary);\n-    }\n-\n-    if is_deprecated(rd) {\n-        tags.push(DiagnosticTag::Deprecated);\n-    }\n-\n-    primary_spans\n-        .iter()\n-        .map(|primary_span| {\n-            let location = map_span_to_location(&primary_span, workspace_root);\n-\n-            let mut message = message.clone();\n-            if needs_primary_span_label {\n-                if let Some(primary_span_label) = &primary_span.label {\n-                    write!(&mut message, \"\\n{}\", primary_span_label).unwrap();\n-                }\n-            }\n-\n-            // If error occurs from macro expansion, add related info pointing to\n-            // where the error originated\n-            if !is_from_macro(&primary_span.file_name) && primary_span.expansion.is_some() {\n-                let def_loc = map_span_to_location_naive(&primary_span, workspace_root);\n-                related_information.push(DiagnosticRelatedInformation {\n-                    location: def_loc,\n-                    message: \"Error originated from macro here\".to_string(),\n-                });\n-            }\n-\n-            let diagnostic = Diagnostic {\n-                range: location.range,\n-                severity,\n-                code: code.clone().map(NumberOrString::String),\n-                source: Some(source.clone()),\n-                message,\n-                related_information: if !related_information.is_empty() {\n-                    Some(related_information.clone())\n-                } else {\n-                    None\n-                },\n-                tags: if !tags.is_empty() { Some(tags.clone()) } else { None },\n-            };\n-\n-            MappedRustDiagnostic { location, diagnostic, fixes: fixes.clone() }\n-        })\n-        .collect()\n-}\n-\n-/// Returns a `Url` object from a given path, will lowercase drive letters if present.\n-/// This will only happen when processing windows paths.\n-///\n-/// When processing non-windows path, this is essentially the same as `Url::from_file_path`.\n-pub fn url_from_path_with_drive_lowercasing(\n-    path: impl AsRef<Path>,\n-) -> Result<Url, Box<dyn std::error::Error + Send + Sync>> {\n-    let component_has_windows_drive = path.as_ref().components().any(|comp| {\n-        if let Component::Prefix(c) = comp {\n-            match c.kind() {\n-                Prefix::Disk(_) | Prefix::VerbatimDisk(_) => return true,\n-                _ => return false,\n-            }\n-        }\n-        false\n-    });\n-\n-    // VSCode expects drive letters to be lowercased, where rust will uppercase the drive letters.\n-    if component_has_windows_drive {\n-        let url_original = Url::from_file_path(&path)\n-            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?;\n-\n-        let drive_partition: Vec<&str> = url_original.as_str().rsplitn(2, ':').collect();\n-\n-        // There is a drive partition, but we never found a colon.\n-        // This should not happen, but in this case we just pass it through.\n-        if drive_partition.len() == 1 {\n-            return Ok(url_original);\n-        }\n-\n-        let joined = drive_partition[1].to_ascii_lowercase() + \":\" + drive_partition[0];\n-        let url = Url::from_str(&joined).expect(\"This came from a valid `Url`\");\n-\n-        Ok(url)\n-    } else {\n-        Ok(Url::from_file_path(&path)\n-            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?)\n-    }\n-}\n-\n-// `Url` is not able to parse windows paths on unix machines.\n-#[cfg(target_os = \"windows\")]\n-#[cfg(test)]\n-mod path_conversion_windows_tests {\n-    use super::url_from_path_with_drive_lowercasing;\n-    #[test]\n-    fn test_lowercase_drive_letter_with_drive() {\n-        let url = url_from_path_with_drive_lowercasing(\"C:\\\\Test\").unwrap();\n-\n-        assert_eq!(url.to_string(), \"file:///c:/Test\");\n-    }\n-\n-    #[test]\n-    fn test_drive_without_colon_passthrough() {\n-        let url = url_from_path_with_drive_lowercasing(r#\"\\\\localhost\\C$\\my_dir\"#).unwrap();\n-\n-        assert_eq!(url.to_string(), \"file://localhost/C$/my_dir\");\n-    }\n-}"}, {"sha": "4e81455ca177b5f9165540dad4b085fd26be72b9", "filename": "crates/ra_flycheck/src/conv/test.rs", "status": "removed", "additions": 0, "deletions": 1072, "changes": 1072, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_flycheck%2Fsrc%2Fconv%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_flycheck%2Fsrc%2Fconv%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Fconv%2Ftest.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,1072 +0,0 @@\n-//! This module contains the large and verbose snapshot tests for the\n-//! conversions between `cargo check` json and LSP diagnostics.\n-#[cfg(not(windows))]\n-use crate::*;\n-\n-#[cfg(not(windows))]\n-fn parse_diagnostic(val: &str) -> cargo_metadata::diagnostic::Diagnostic {\n-    serde_json::from_str::<cargo_metadata::diagnostic::Diagnostic>(val).unwrap()\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_incompatible_type_for_trait() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-            \"message\": \"method `next` has an incompatible type for trait\",\n-            \"code\": {\n-                \"code\": \"E0053\",\n-                \"explanation\": \"\\nThe parameters of any trait method must match between a trait implementation\\nand the trait definition.\\n\\nHere are a couple examples of this error:\\n\\n```compile_fail,E0053\\ntrait Foo {\\n    fn foo(x: u16);\\n    fn bar(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, expected u16, found i16\\n    fn foo(x: i16) { }\\n\\n    // error, types differ in mutability\\n    fn bar(&mut self) { }\\n}\\n```\\n\"\n-            },\n-            \"level\": \"error\",\n-            \"spans\": [\n-                {\n-                    \"file_name\": \"compiler/ty/list_iter.rs\",\n-                    \"byte_start\": 1307,\n-                    \"byte_end\": 1350,\n-                    \"line_start\": 52,\n-                    \"line_end\": 52,\n-                    \"column_start\": 5,\n-                    \"column_end\": 48,\n-                    \"is_primary\": true,\n-                    \"text\": [\n-                        {\n-                            \"text\": \"    fn next(&self) -> Option<&'list ty::Ref<M>> {\",\n-                            \"highlight_start\": 5,\n-                            \"highlight_end\": 48\n-                        }\n-                    ],\n-                    \"label\": \"types differ in mutability\",\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"expansion\": null\n-                }\n-            ],\n-            \"children\": [\n-                {\n-                    \"message\": \"expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n   found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\",\n-                    \"code\": null,\n-                    \"level\": \"note\",\n-                    \"spans\": [],\n-                    \"children\": [],\n-                    \"rendered\": null\n-                }\n-            ],\n-            \"rendered\": \"error[E0053]: method `next` has an incompatible type for trait\\n  --> compiler/ty/list_iter.rs:52:5\\n   |\\n52 |     fn next(&self) -> Option<&'list ty::Ref<M>> {\\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\\n   |\\n   = note: expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n              found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\\n\\n\"\n-        }\n-        \"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_unused_variable() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"unused variable: `foo`\",\n-\"code\": {\n-    \"code\": \"unused_variables\",\n-    \"explanation\": null\n-},\n-\"level\": \"warning\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"driver/subcommand/repl.rs\",\n-        \"byte_start\": 9228,\n-        \"byte_end\": 9231,\n-        \"line_start\": 291,\n-        \"line_end\": 291,\n-        \"column_start\": 9,\n-        \"column_end\": 12,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"    let foo = 42;\",\n-                \"highlight_start\": 9,\n-                \"highlight_end\": 12\n-            }\n-        ],\n-        \"label\": null,\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [\n-    {\n-        \"message\": \"#[warn(unused_variables)] on by default\",\n-        \"code\": null,\n-        \"level\": \"note\",\n-        \"spans\": [],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"consider prefixing with an underscore\",\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"spans\": [\n-            {\n-                \"file_name\": \"driver/subcommand/repl.rs\",\n-                \"byte_start\": 9228,\n-                \"byte_end\": 9231,\n-                \"line_start\": 291,\n-                \"line_end\": 291,\n-                \"column_start\": 9,\n-                \"column_end\": 12,\n-                \"is_primary\": true,\n-                \"text\": [\n-                    {\n-                        \"text\": \"    let foo = 42;\",\n-                        \"highlight_start\": 9,\n-                        \"highlight_end\": 12\n-                    }\n-                ],\n-                \"label\": null,\n-                \"suggested_replacement\": \"_foo\",\n-                \"suggestion_applicability\": \"MachineApplicable\",\n-                \"expansion\": null\n-            }\n-        ],\n-        \"children\": [],\n-        \"rendered\": null\n-    }\n-],\n-\"rendered\": \"warning: unused variable: `foo`\\n   --> driver/subcommand/repl.rs:291:9\\n    |\\n291 |     let foo = 42;\\n    |         ^^^ help: consider prefixing with an underscore: `_foo`\\n    |\\n    = note: #[warn(unused_variables)] on by default\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_wrong_number_of_parameters() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"this function takes 2 parameters but 3 parameters were supplied\",\n-\"code\": {\n-    \"code\": \"E0061\",\n-    \"explanation\": \"\\nThe number of arguments passed to a function must match the number of arguments\\nspecified in the function signature.\\n\\nFor example, a function like:\\n\\n```\\nfn f(a: u16, b: &str) {}\\n```\\n\\nMust always be called with exactly two arguments, e.g., `f(2, \\\"test\\\")`.\\n\\nNote that Rust does not have a notion of optional function arguments or\\nvariadic functions (except for its C-FFI).\\n\"\n-},\n-\"level\": \"error\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"compiler/ty/select.rs\",\n-        \"byte_start\": 8787,\n-        \"byte_end\": 9241,\n-        \"line_start\": 219,\n-        \"line_end\": 231,\n-        \"column_start\": 5,\n-        \"column_end\": 6,\n-        \"is_primary\": false,\n-        \"text\": [\n-            {\n-                \"text\": \"    pub fn add_evidence(\",\n-                \"highlight_start\": 5,\n-                \"highlight_end\": 25\n-            },\n-            {\n-                \"text\": \"        &mut self,\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 19\n-            },\n-            {\n-                \"text\": \"        target_poly: &ty::Ref<ty::Poly>,\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 41\n-            },\n-            {\n-                \"text\": \"        evidence_poly: &ty::Ref<ty::Poly>,\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 43\n-            },\n-            {\n-                \"text\": \"    ) {\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 8\n-            },\n-            {\n-                \"text\": \"        match target_poly {\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 28\n-            },\n-            {\n-                \"text\": \"            ty::Ref::Var(tvar, _) => self.add_var_evidence(tvar, evidence_poly),\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 81\n-            },\n-            {\n-                \"text\": \"            ty::Ref::Fixed(target_ty) => {\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 43\n-            },\n-            {\n-                \"text\": \"                let evidence_ty = evidence_poly.resolve_to_ty();\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 65\n-            },\n-            {\n-                \"text\": \"                self.add_evidence_ty(target_ty, evidence_poly, evidence_ty)\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 76\n-            },\n-            {\n-                \"text\": \"            }\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 14\n-            },\n-            {\n-                \"text\": \"        }\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 10\n-            },\n-            {\n-                \"text\": \"    }\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 6\n-            }\n-        ],\n-        \"label\": \"defined here\",\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    },\n-    {\n-        \"file_name\": \"compiler/ty/select.rs\",\n-        \"byte_start\": 4045,\n-        \"byte_end\": 4057,\n-        \"line_start\": 104,\n-        \"line_end\": 104,\n-        \"column_start\": 18,\n-        \"column_end\": 30,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"            self.add_evidence(target_fixed, evidence_fixed, false);\",\n-                \"highlight_start\": 18,\n-                \"highlight_end\": 30\n-            }\n-        ],\n-        \"label\": \"expected 2 parameters\",\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [],\n-\"rendered\": \"error[E0061]: this function takes 2 parameters but 3 parameters were supplied\\n   --> compiler/ty/select.rs:104:18\\n    |\\n104 |               self.add_evidence(target_fixed, evidence_fixed, false);\\n    |                    ^^^^^^^^^^^^ expected 2 parameters\\n...\\n219 | /     pub fn add_evidence(\\n220 | |         &mut self,\\n221 | |         target_poly: &ty::Ref<ty::Poly>,\\n222 | |         evidence_poly: &ty::Ref<ty::Poly>,\\n...   |\\n230 | |         }\\n231 | |     }\\n    | |_____- defined here\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_clippy_pass_by_ref() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"this argument is passed by reference, but would be more efficient if passed by value\",\n-\"code\": {\n-    \"code\": \"clippy::trivially_copy_pass_by_ref\",\n-    \"explanation\": null\n-},\n-\"level\": \"warning\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"compiler/mir/tagset.rs\",\n-        \"byte_start\": 941,\n-        \"byte_end\": 946,\n-        \"line_start\": 42,\n-        \"line_end\": 42,\n-        \"column_start\": 24,\n-        \"column_end\": 29,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n-                \"highlight_start\": 24,\n-                \"highlight_end\": 29\n-            }\n-        ],\n-        \"label\": null,\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [\n-    {\n-        \"message\": \"lint level defined here\",\n-        \"code\": null,\n-        \"level\": \"note\",\n-        \"spans\": [\n-            {\n-                \"file_name\": \"compiler/lib.rs\",\n-                \"byte_start\": 8,\n-                \"byte_end\": 19,\n-                \"line_start\": 1,\n-                \"line_end\": 1,\n-                \"column_start\": 9,\n-                \"column_end\": 20,\n-                \"is_primary\": true,\n-                \"text\": [\n-                    {\n-                        \"text\": \"#![warn(clippy::all)]\",\n-                        \"highlight_start\": 9,\n-                        \"highlight_end\": 20\n-                    }\n-                ],\n-                \"label\": null,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"expansion\": null\n-            }\n-        ],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"#[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\",\n-        \"code\": null,\n-        \"level\": \"note\",\n-        \"spans\": [],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\",\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"spans\": [],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"consider passing by value instead\",\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"spans\": [\n-            {\n-                \"file_name\": \"compiler/mir/tagset.rs\",\n-                \"byte_start\": 941,\n-                \"byte_end\": 946,\n-                \"line_start\": 42,\n-                \"line_end\": 42,\n-                \"column_start\": 24,\n-                \"column_end\": 29,\n-                \"is_primary\": true,\n-                \"text\": [\n-                    {\n-                        \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n-                        \"highlight_start\": 24,\n-                        \"highlight_end\": 29\n-                    }\n-                ],\n-                \"label\": null,\n-                \"suggested_replacement\": \"self\",\n-                \"suggestion_applicability\": \"Unspecified\",\n-                \"expansion\": null\n-            }\n-        ],\n-        \"children\": [],\n-        \"rendered\": null\n-    }\n-],\n-\"rendered\": \"warning: this argument is passed by reference, but would be more efficient if passed by value\\n  --> compiler/mir/tagset.rs:42:24\\n   |\\n42 |     pub fn is_disjoint(&self, other: Self) -> bool {\\n   |                        ^^^^^ help: consider passing by value instead: `self`\\n   |\\nnote: lint level defined here\\n  --> compiler/lib.rs:1:9\\n   |\\n1  | #![warn(clippy::all)]\\n   |         ^^^^^^^^^^^\\n   = note: #[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_mismatched_type() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"mismatched types\",\n-\"code\": {\n-    \"code\": \"E0308\",\n-    \"explanation\": \"\\nThis error occurs when the compiler was unable to infer the concrete type of a\\nvariable. It can occur for several cases, the most common of which is a\\nmismatch in the expected type that the compiler inferred for a variable's\\ninitializing expression, and the actual type explicitly assigned to the\\nvariable.\\n\\nFor example:\\n\\n```compile_fail,E0308\\nlet x: i32 = \\\"I am not a number!\\\";\\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\\n//      |             |\\n//      |    initializing expression;\\n//      |    compiler infers type `&str`\\n//      |\\n//    type `i32` assigned to variable `x`\\n```\\n\"\n-},\n-\"level\": \"error\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"runtime/compiler_support.rs\",\n-        \"byte_start\": 1589,\n-        \"byte_end\": 1594,\n-        \"line_start\": 48,\n-        \"line_end\": 48,\n-        \"column_start\": 65,\n-        \"column_end\": 70,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"    let layout = alloc::Layout::from_size_align_unchecked(size, align);\",\n-                \"highlight_start\": 65,\n-                \"highlight_end\": 70\n-            }\n-        ],\n-        \"label\": \"expected usize, found u32\",\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [],\n-\"rendered\": \"error[E0308]: mismatched types\\n  --> runtime/compiler_support.rs:48:65\\n   |\\n48 |     let layout = alloc::Layout::from_size_align_unchecked(size, align);\\n   |                                                                 ^^^^^ expected usize, found u32\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_handles_macro_location() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"rendered\": \"error[E0277]: can't compare `{integer}` with `&str`\\n --> src/main.rs:2:5\\n  |\\n2 |     assert_eq!(1, \\\"love\\\");\\n  |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &str`\\n  |\\n  = help: the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\\n  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\\n\\n\",\n-\"children\": [\n-    {\n-        \"children\": [],\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"message\": \"the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\",\n-        \"rendered\": null,\n-        \"spans\": []\n-    }\n-],\n-\"code\": {\n-    \"code\": \"E0277\",\n-    \"explanation\": \"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail,E0277\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n\\n```compile_fail,E0277\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n```\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n\"\n-},\n-\"level\": \"error\",\n-\"message\": \"can't compare `{integer}` with `&str`\",\n-\"spans\": [\n-    {\n-        \"byte_end\": 155,\n-        \"byte_start\": 153,\n-        \"column_end\": 33,\n-        \"column_start\": 31,\n-        \"expansion\": {\n-            \"def_site_span\": {\n-                \"byte_end\": 940,\n-                \"byte_start\": 0,\n-                \"column_end\": 6,\n-                \"column_start\": 1,\n-                \"expansion\": null,\n-                \"file_name\": \"<::core::macros::assert_eq macros>\",\n-                \"is_primary\": false,\n-                \"label\": null,\n-                \"line_end\": 36,\n-                \"line_start\": 1,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                        \"highlight_end\": 35,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"($ left : expr, $ right : expr) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 3,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"({\"\n-                    },\n-                    {\n-                        \"highlight_end\": 33,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     match (& $ left, & $ right)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 34,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         (left_val, right_val) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 46,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             if ! (* left_val == * right_val)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 25,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 panic !\"\n-                    },\n-                    {\n-                        \"highlight_end\": 57,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n-                    },\n-                    {\n-                        \"highlight_end\": 16,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"  left: `{:?}`,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 18,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" right: `{:?}`\\\"#,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 47,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                  & * left_val, & * right_val)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 42,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" }) ; ($ left : expr, $ right : expr,) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 49,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"({ $ crate :: assert_eq ! ($ left, $ right) }) ;\"\n-                    },\n-                    {\n-                        \"highlight_end\": 53,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"($ left : expr, $ right : expr, $ ($ arg : tt) +) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 3,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"({\"\n-                    },\n-                    {\n-                        \"highlight_end\": 37,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     match (& ($ left), & ($ right))\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 34,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         (left_val, right_val) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 46,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             if ! (* left_val == * right_val)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 25,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 panic !\"\n-                    },\n-                    {\n-                        \"highlight_end\": 57,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n-                    },\n-                    {\n-                        \"highlight_end\": 16,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"  left: `{:?}`,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 22,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" right: `{:?}`: {}\\\"#,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 72,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                  & * left_val, & * right_val, $ crate :: format_args !\"\n-                    },\n-                    {\n-                        \"highlight_end\": 33,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                  ($ ($ arg) +))\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 6,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" }) ;\"\n-                    }\n-                ]\n-            },\n-            \"macro_decl_name\": \"assert_eq!\",\n-            \"span\": {\n-                \"byte_end\": 38,\n-                \"byte_start\": 16,\n-                \"column_end\": 27,\n-                \"column_start\": 5,\n-                \"expansion\": null,\n-                \"file_name\": \"src/main.rs\",\n-                \"is_primary\": false,\n-                \"label\": null,\n-                \"line_end\": 2,\n-                \"line_start\": 2,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                        \"highlight_end\": 27,\n-                        \"highlight_start\": 5,\n-                        \"text\": \"    assert_eq!(1, \\\"love\\\");\"\n-                    }\n-                ]\n-            }\n-        },\n-        \"file_name\": \"<::core::macros::assert_eq macros>\",\n-        \"is_primary\": true,\n-        \"label\": \"no implementation for `{integer} == &str`\",\n-        \"line_end\": 7,\n-        \"line_start\": 7,\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"text\": [\n-            {\n-                \"highlight_end\": 33,\n-                \"highlight_start\": 31,\n-                \"text\": \"             if ! (* left_val == * right_val)\"\n-            }\n-        ]\n-    }\n-]\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_macro_compiler_error() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-    \"rendered\": \"error: Please register your known path in the path module\\n   --> crates/ra_hir_def/src/path.rs:265:9\\n    |\\n265 |         compile_error!(\\\"Please register your known path in the path module\\\")\\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    | \\n   ::: crates/ra_hir_def/src/data.rs:80:16\\n    |\\n80  |     let path = path![std::future::Future];\\n    |                -------------------------- in this macro invocation\\n\\n\",\n-    \"children\": [],\n-    \"code\": null,\n-    \"level\": \"error\",\n-    \"message\": \"Please register your known path in the path module\",\n-    \"spans\": [\n-        {\n-            \"byte_end\": 8285,\n-            \"byte_start\": 8217,\n-            \"column_end\": 77,\n-            \"column_start\": 9,\n-            \"expansion\": {\n-                \"def_site_span\": {\n-                    \"byte_end\": 8294,\n-                    \"byte_start\": 7858,\n-                    \"column_end\": 2,\n-                    \"column_start\": 1,\n-                    \"expansion\": null,\n-                    \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-                    \"is_primary\": false,\n-                    \"label\": null,\n-                    \"line_end\": 267,\n-                    \"line_start\": 254,\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"text\": [\n-                        {\n-                            \"highlight_end\": 28,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"macro_rules! __known_path {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 37,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::iter::IntoIterator) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::result::Result) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 29,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::Range) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeFrom) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeFull) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 31,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeTo) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 40,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeToInclusive) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 38,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeInclusive) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 27,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::Try) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 22,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    ($path:path) => {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 77,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"        compile_error!(\\\"Please register your known path in the path module\\\")\"\n-                        },\n-                        {\n-                            \"highlight_end\": 7,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    };\"\n-                        },\n-                        {\n-                            \"highlight_end\": 2,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"}\"\n-                        }\n-                    ]\n-                },\n-                \"macro_decl_name\": \"$crate::__known_path!\",\n-                \"span\": {\n-                    \"byte_end\": 8427,\n-                    \"byte_start\": 8385,\n-                    \"column_end\": 51,\n-                    \"column_start\": 9,\n-                    \"expansion\": {\n-                        \"def_site_span\": {\n-                            \"byte_end\": 8611,\n-                            \"byte_start\": 8312,\n-                            \"column_end\": 2,\n-                            \"column_start\": 1,\n-                            \"expansion\": null,\n-                            \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-                            \"is_primary\": false,\n-                            \"label\": null,\n-                            \"line_end\": 277,\n-                            \"line_start\": 270,\n-                            \"suggested_replacement\": null,\n-                            \"suggestion_applicability\": null,\n-                            \"text\": [\n-                                {\n-                                    \"highlight_end\": 22,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"macro_rules! __path {\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 43,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"    ($start:ident $(:: $seg:ident)*) => ({\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 51,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"        $crate::__known_path!($start $(:: $seg)*);\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 87,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"        $crate::path::ModPath::from_simple_segments($crate::path::PathKind::Abs, vec![\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 76,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"            $crate::path::__name![$start], $($crate::path::__name![$seg],)*\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 11,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"        ])\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 8,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"    });\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 2,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"}\"\n-                                }\n-                            ]\n-                        },\n-                        \"macro_decl_name\": \"path!\",\n-                        \"span\": {\n-                            \"byte_end\": 2966,\n-                            \"byte_start\": 2940,\n-                            \"column_end\": 42,\n-                            \"column_start\": 16,\n-                            \"expansion\": null,\n-                            \"file_name\": \"crates/ra_hir_def/src/data.rs\",\n-                            \"is_primary\": false,\n-                            \"label\": null,\n-                            \"line_end\": 80,\n-                            \"line_start\": 80,\n-                            \"suggested_replacement\": null,\n-                            \"suggestion_applicability\": null,\n-                            \"text\": [\n-                                {\n-                                    \"highlight_end\": 42,\n-                                    \"highlight_start\": 16,\n-                                    \"text\": \"    let path = path![std::future::Future];\"\n-                                }\n-                            ]\n-                        }\n-                    },\n-                    \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-                    \"is_primary\": false,\n-                    \"label\": null,\n-                    \"line_end\": 272,\n-                    \"line_start\": 272,\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"text\": [\n-                        {\n-                            \"highlight_end\": 51,\n-                            \"highlight_start\": 9,\n-                            \"text\": \"        $crate::__known_path!($start $(:: $seg)*);\"\n-                        }\n-                    ]\n-                }\n-            },\n-            \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-            \"is_primary\": true,\n-            \"label\": null,\n-            \"line_end\": 265,\n-            \"line_start\": 265,\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"text\": [\n-                {\n-                    \"highlight_end\": 77,\n-                    \"highlight_start\": 9,\n-                    \"text\": \"        compile_error!(\\\"Please register your known path in the path module\\\")\"\n-                }\n-            ]\n-        }\n-    ]\n-}\n-        \"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_multi_line_fix() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-            \"rendered\": \"warning: returning the result of a let binding from a block\\n --> src/main.rs:4:5\\n  |\\n3 |     let a = (0..10).collect();\\n  |     -------------------------- unnecessary let binding\\n4 |     a\\n  |     ^\\n  |\\n  = note: `#[warn(clippy::let_and_return)]` on by default\\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\\nhelp: return the expression directly\\n  |\\n3 |     \\n4 |     (0..10).collect()\\n  |\\n\\n\",\n-            \"children\": [\n-                {\n-                \"children\": [],\n-                \"code\": null,\n-                \"level\": \"note\",\n-                \"message\": \"`#[warn(clippy::let_and_return)]` on by default\",\n-                \"rendered\": null,\n-                \"spans\": []\n-                },\n-                {\n-                \"children\": [],\n-                \"code\": null,\n-                \"level\": \"help\",\n-                \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\",\n-                \"rendered\": null,\n-                \"spans\": []\n-                },\n-                {\n-                \"children\": [],\n-                \"code\": null,\n-                \"level\": \"help\",\n-                \"message\": \"return the expression directly\",\n-                \"rendered\": null,\n-                \"spans\": [\n-                    {\n-                    \"byte_end\": 55,\n-                    \"byte_start\": 29,\n-                    \"column_end\": 31,\n-                    \"column_start\": 5,\n-                    \"expansion\": null,\n-                    \"file_name\": \"src/main.rs\",\n-                    \"is_primary\": true,\n-                    \"label\": null,\n-                    \"line_end\": 3,\n-                    \"line_start\": 3,\n-                    \"suggested_replacement\": \"\",\n-                    \"suggestion_applicability\": \"MachineApplicable\",\n-                    \"text\": [\n-                        {\n-                        \"highlight_end\": 31,\n-                        \"highlight_start\": 5,\n-                        \"text\": \"    let a = (0..10).collect();\"\n-                        }\n-                    ]\n-                    },\n-                    {\n-                    \"byte_end\": 61,\n-                    \"byte_start\": 60,\n-                    \"column_end\": 6,\n-                    \"column_start\": 5,\n-                    \"expansion\": null,\n-                    \"file_name\": \"src/main.rs\",\n-                    \"is_primary\": true,\n-                    \"label\": null,\n-                    \"line_end\": 4,\n-                    \"line_start\": 4,\n-                    \"suggested_replacement\": \"(0..10).collect()\",\n-                    \"suggestion_applicability\": \"MachineApplicable\",\n-                    \"text\": [\n-                        {\n-                        \"highlight_end\": 6,\n-                        \"highlight_start\": 5,\n-                        \"text\": \"    a\"\n-                        }\n-                    ]\n-                    }\n-                ]\n-                }\n-            ],\n-            \"code\": {\n-                \"code\": \"clippy::let_and_return\",\n-                \"explanation\": null\n-            },\n-            \"level\": \"warning\",\n-            \"message\": \"returning the result of a let binding from a block\",\n-            \"spans\": [\n-                {\n-                \"byte_end\": 55,\n-                \"byte_start\": 29,\n-                \"column_end\": 31,\n-                \"column_start\": 5,\n-                \"expansion\": null,\n-                \"file_name\": \"src/main.rs\",\n-                \"is_primary\": false,\n-                \"label\": \"unnecessary let binding\",\n-                \"line_end\": 3,\n-                \"line_start\": 3,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                    \"highlight_end\": 31,\n-                    \"highlight_start\": 5,\n-                    \"text\": \"    let a = (0..10).collect();\"\n-                    }\n-                ]\n-                },\n-                {\n-                \"byte_end\": 61,\n-                \"byte_start\": 60,\n-                \"column_end\": 6,\n-                \"column_start\": 5,\n-                \"expansion\": null,\n-                \"file_name\": \"src/main.rs\",\n-                \"is_primary\": true,\n-                \"label\": null,\n-                \"line_end\": 4,\n-                \"line_start\": 4,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                    \"highlight_end\": 6,\n-                    \"highlight_start\": 5,\n-                    \"text\": \"    a\"\n-                    }\n-                ]\n-                }\n-            ]\n-        }\n-        \"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}"}, {"sha": "041e38a9ff4ca4d40fc64972bf3e15fa1784d02d", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 35, "deletions": 73, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,30 +1,24 @@\n //! cargo_check provides the functionality needed to run `cargo check` or\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n-mod conv;\n \n use std::{\n-    env,\n-    io::{self, BufRead, BufReader},\n+    io::{self, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n     time::Instant,\n };\n \n use cargo_metadata::Message;\n use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n-use lsp_types::{\n-    CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n-    WorkDoneProgressEnd, WorkDoneProgressReport,\n-};\n-\n-use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n-pub use crate::conv::url_from_path_with_drive_lowercasing;\n+pub use cargo_metadata::diagnostic::{\n+    Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n+};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n-    CargoCommand { command: String, all_targets: bool, extra_args: Vec<String> },\n+    CargoCommand { command: String, all_targets: bool, all_features: bool, extra_args: Vec<String> },\n     CustomCommand { command: String, args: Vec<String> },\n }\n \n@@ -62,10 +56,17 @@ pub enum CheckTask {\n     ClearDiagnostics,\n \n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic { url: Url, diagnostic: Diagnostic, fixes: Vec<CodeActionOrCommand> },\n+    AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n \n     /// Request check progress notification to client\n-    Status(WorkDoneProgress),\n+    Status(Status),\n+}\n+\n+#[derive(Debug)]\n+pub enum Status {\n+    Being,\n+    Progress(String),\n+    End,\n }\n \n pub enum CheckCommand {\n@@ -132,9 +133,7 @@ impl FlycheckThread {\n \n     fn clean_previous_results(&self, task_send: &Sender<CheckTask>) {\n         task_send.send(CheckTask::ClearDiagnostics).unwrap();\n-        task_send\n-            .send(CheckTask::Status(WorkDoneProgress::End(WorkDoneProgressEnd { message: None })))\n-            .unwrap();\n+        task_send.send(CheckTask::Status(Status::End)).unwrap();\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -156,55 +155,29 @@ impl FlycheckThread {\n     fn handle_message(&self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n         match msg {\n             CheckEvent::Begin => {\n-                task_send\n-                    .send(CheckTask::Status(WorkDoneProgress::Begin(WorkDoneProgressBegin {\n-                        title: \"Running 'cargo check'\".to_string(),\n-                        cancellable: Some(false),\n-                        message: None,\n-                        percentage: None,\n-                    })))\n-                    .unwrap();\n+                task_send.send(CheckTask::Status(Status::Being)).unwrap();\n             }\n \n             CheckEvent::End => {\n-                task_send\n-                    .send(CheckTask::Status(WorkDoneProgress::End(WorkDoneProgressEnd {\n-                        message: None,\n-                    })))\n-                    .unwrap();\n+                task_send.send(CheckTask::Status(Status::End)).unwrap();\n             }\n \n             CheckEvent::Msg(Message::CompilerArtifact(msg)) => {\n-                task_send\n-                    .send(CheckTask::Status(WorkDoneProgress::Report(WorkDoneProgressReport {\n-                        cancellable: Some(false),\n-                        message: Some(msg.target.name),\n-                        percentage: None,\n-                    })))\n-                    .unwrap();\n+                task_send.send(CheckTask::Status(Status::Progress(msg.target.name))).unwrap();\n             }\n \n             CheckEvent::Msg(Message::CompilerMessage(msg)) => {\n-                let map_result = map_rust_diagnostic_to_lsp(&msg.message, &self.workspace_root);\n-                if map_result.is_empty() {\n-                    return;\n-                }\n-\n-                for MappedRustDiagnostic { location, diagnostic, fixes } in map_result {\n-                    let fixes = fixes\n-                        .into_iter()\n-                        .map(|fix| {\n-                            CodeAction { diagnostics: Some(vec![diagnostic.clone()]), ..fix }.into()\n-                        })\n-                        .collect();\n-\n-                    task_send\n-                        .send(CheckTask::AddDiagnostic { url: location.uri, diagnostic, fixes })\n-                        .unwrap();\n-                }\n+                task_send\n+                    .send(CheckTask::AddDiagnostic {\n+                        workspace_root: self.workspace_root.clone(),\n+                        diagnostic: msg.message,\n+                    })\n+                    .unwrap();\n             }\n \n             CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n+            CheckEvent::Msg(Message::BuildFinished(_)) => {}\n+            CheckEvent::Msg(Message::TextLine(_)) => {}\n             CheckEvent::Msg(Message::Unknown) => {}\n         }\n     }\n@@ -215,14 +188,17 @@ impl FlycheckThread {\n         self.check_process = None;\n \n         let mut cmd = match &self.config {\n-            FlycheckConfig::CargoCommand { command, all_targets, extra_args } => {\n-                let mut cmd = Command::new(cargo_binary());\n+            FlycheckConfig::CargoCommand { command, all_targets, all_features, extra_args } => {\n+                let mut cmd = Command::new(ra_toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"]);\n-                cmd.arg(self.workspace_root.join(\"Cargo.toml\"));\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.workspace_root.join(\"Cargo.toml\"));\n                 if *all_targets {\n                     cmd.arg(\"--all-targets\");\n                 }\n+                if *all_features {\n+                    cmd.arg(\"--all-features\");\n+                }\n                 cmd.args(extra_args);\n                 cmd\n             }\n@@ -267,12 +243,6 @@ impl FlycheckThread {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct DiagnosticWithFixes {\n-    diagnostic: Diagnostic,\n-    fixes: Vec<CodeAction>,\n-}\n-\n enum CheckEvent {\n     Begin,\n     Msg(cargo_metadata::Message),\n@@ -296,15 +266,11 @@ fn run_cargo(\n     // erroneus output.\n     let stdout = BufReader::new(child.stdout.take().unwrap());\n     let mut read_at_least_one_message = false;\n-\n-    for line in stdout.lines() {\n-        let line = line?;\n-\n-        let message = serde_json::from_str::<cargo_metadata::Message>(&line);\n+    for message in cargo_metadata::Message::parse_stream(stdout) {\n         let message = match message {\n             Ok(message) => message,\n             Err(err) => {\n-                log::error!(\"Invalid json from cargo check, ignoring ({}): {:?} \", err, line);\n+                log::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n                 continue;\n             }\n         };\n@@ -334,7 +300,3 @@ fn run_cargo(\n \n     Ok(())\n }\n-\n-fn cargo_binary() -> String {\n-    env::var(\"CARGO\").unwrap_or_else(|_| \"cargo\".to_string())\n-}"}, {"sha": "f910ded9da6f3ca57b6fcd9dfa2d039ffb0c3528", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -42,7 +42,6 @@ pub fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n }\n \n pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n-    let block = block.block()?;\n     let has_anything_else = |thing: &SyntaxNode| -> bool {\n         let mut non_trivial_children =\n             block.syntax().children_with_tokens().filter(|it| match it.kind() {"}, {"sha": "840cfdfc8238ef70579f1c2af3ee943cdd74ae2b", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -19,11 +19,14 @@ use hir_def::{\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n     name::{name, AsName},\n-    MacroDefId,\n+    MacroDefId, MacroDefKind,\n };\n use hir_ty::{\n-    autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n-    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    autoderef,\n+    display::{HirDisplayError, HirFormatter},\n+    expr::ExprValidator,\n+    method_resolution, ApplicationTy, Canonical, InEnvironment, Substs, TraitEnvironment, Ty,\n+    TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n@@ -145,6 +148,26 @@ impl ModuleDef {\n             ModuleDef::BuiltinType(_) => None,\n         }\n     }\n+\n+    pub fn definition_visibility(&self, db: &dyn HirDatabase) -> Option<Visibility> {\n+        let module = match self {\n+            ModuleDef::Module(it) => it.parent(db)?,\n+            ModuleDef::Function(it) => return Some(it.visibility(db)),\n+            ModuleDef::Adt(it) => it.module(db),\n+            ModuleDef::EnumVariant(it) => {\n+                let parent = it.parent_enum(db);\n+                let module = it.module(db);\n+                return module.visibility_of(db, &ModuleDef::Adt(Adt::Enum(parent)));\n+            }\n+            ModuleDef::Const(it) => return Some(it.visibility(db)),\n+            ModuleDef::Static(it) => it.module(db),\n+            ModuleDef::Trait(it) => it.module(db),\n+            ModuleDef::TypeAlias(it) => return Some(it.visibility(db)),\n+            ModuleDef::BuiltinType(_) => return None,\n+        };\n+\n+        module.visibility_of(db, self)\n+    }\n }\n \n pub use hir_def::{\n@@ -675,6 +698,10 @@ impl Static {\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         db.static_data(self.id).name.clone()\n     }\n+\n+    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n+        db.static_data(self.id).mutable\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -762,13 +789,12 @@ impl MacroDef {\n \n     /// Indicate it is a proc-macro\n     pub fn is_proc_macro(&self) -> bool {\n-        match self.id.kind {\n-            hir_expand::MacroDefKind::Declarative => false,\n-            hir_expand::MacroDefKind::BuiltIn(_) => false,\n-            hir_expand::MacroDefKind::BuiltInDerive(_) => false,\n-            hir_expand::MacroDefKind::BuiltInEager(_) => false,\n-            hir_expand::MacroDefKind::CustomDerive(_) => true,\n-        }\n+        matches!(self.id.kind, MacroDefKind::CustomDerive(_))\n+    }\n+\n+    /// Indicate it is a derive macro\n+    pub fn is_derive_macro(&self) -> bool {\n+        matches!(self.id.kind, MacroDefKind::CustomDerive(_) | MacroDefKind::BuiltInDerive(_))\n     }\n }\n \n@@ -963,6 +989,17 @@ impl TypeParam {\n             ty: InEnvironment { value: ty, environment },\n         }\n     }\n+\n+    pub fn default(self, db: &dyn HirDatabase) -> Option<Type> {\n+        let params = db.generic_defaults(self.id.parent);\n+        let local_idx = hir_ty::param_idx(db, self.id)?;\n+        let resolver = self.id.parent.resolver(db.upcast());\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        params.get(local_idx).cloned().map(|ty| Type {\n+            krate: self.id.parent.module(db.upcast()).krate,\n+            ty: InEnvironment { value: ty, environment },\n+        })\n+    }\n }\n \n // FIXME: rename from `ImplDef` to `Impl`\n@@ -1212,7 +1249,7 @@ impl Type {\n \n     // This would be nicer if it just returned an iterator, but that runs into\n     // lifetime problems, because we need to borrow temp `CrateImplDefs`.\n-    pub fn iterate_impl_items<T>(\n+    pub fn iterate_assoc_items<T>(\n         self,\n         db: &dyn HirDatabase,\n         krate: Crate,\n@@ -1320,7 +1357,7 @@ impl Type {\n }\n \n impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> std::fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.ty.value.hir_fmt(f)\n     }\n }"}, {"sha": "7c1f79f279b655a83c39524f22bf14c58375b3bb", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     db::HirDatabase,\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n+    source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n     AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n     Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam,\n };\n@@ -451,6 +451,23 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n     pub fn resolve_hir_path(&self, path: &Path) -> Option<PathResolution> {\n         resolve_hir_path(self.db, &self.resolver, path)\n     }\n+\n+    /// Resolves a path where we know it is a qualifier of another path.\n+    ///\n+    /// For example, if we have:\n+    /// ```\n+    /// mod my {\n+    ///     pub mod foo {\n+    ///         struct Bar;\n+    ///     }\n+    ///\n+    ///     pub fn foo() {}\n+    /// }\n+    /// ```\n+    /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n+    pub fn resolve_hir_path_qualifier(&self, path: &Path) -> Option<PathResolution> {\n+        resolve_hir_path_qualifier(self.db, &self.resolver, path)\n+    }\n }\n \n // FIXME: Change `HasSource` trait to work with `Semantics` and remove this?"}, {"sha": "8af64fdc1b2583104ff3cc305bfdc74da502bf11", "filename": "crates/ra_hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -151,7 +151,7 @@ impl SourceToDefCtx<'_, '_> {\n         let krate = self.file_to_def(file_id)?.krate;\n         let file_ast_id = self.db.ast_id_map(src.file_id).ast_id(&src.value);\n         let ast_id = Some(AstId::new(src.file_id, file_ast_id));\n-        Some(MacroDefId { krate: Some(krate), ast_id, kind })\n+        Some(MacroDefId { krate: Some(krate), ast_id, kind, local_inner: false })\n     }\n \n     pub(super) fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {"}, {"sha": "4b509f07c6b73303c0d3a53161f33ae147b1df0e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -226,6 +226,17 @@ impl SourceAnalyzer {\n         // This must be a normal source file rather than macro file.\n         let hir_path =\n             crate::Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n+\n+        // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we\n+        // trying to resolve foo::bar.\n+        if let Some(outer_path) = path.syntax().parent().and_then(ast::Path::cast) {\n+            if let Some(qualifier) = outer_path.qualifier() {\n+                if path == &qualifier {\n+                    return resolve_hir_path_qualifier(db, &self.resolver, &hir_path);\n+                }\n+            }\n+        }\n+\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n \n@@ -404,6 +415,7 @@ pub(crate) fn resolve_hir_path(\n             TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n             TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n         });\n+\n     let body_owner = resolver.body_owner();\n     let values =\n         resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n@@ -417,6 +429,7 @@ pub(crate) fn resolve_hir_path(\n                 ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n                 ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n                 ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+                ValueNs::ImplSelf(impl_id) => PathResolution::SelfType(impl_id.into()),\n             };\n             Some(res)\n         });\n@@ -425,9 +438,48 @@ pub(crate) fn resolve_hir_path(\n         .resolve_module_path_in_items(db.upcast(), path.mod_path())\n         .take_types()\n         .map(|it| PathResolution::Def(it.into()));\n+\n     types.or(values).or(items).or_else(|| {\n         resolver\n             .resolve_path_as_macro(db.upcast(), path.mod_path())\n             .map(|def| PathResolution::Macro(def.into()))\n     })\n }\n+\n+/// Resolves a path where we know it is a qualifier of another path.\n+///\n+/// For example, if we have:\n+/// ```\n+/// mod my {\n+///     pub mod foo {\n+///         struct Bar;\n+///     }\n+///\n+///     pub fn foo() {}\n+/// }\n+/// ```\n+/// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n+pub(crate) fn resolve_hir_path_qualifier(\n+    db: &dyn HirDatabase,\n+    resolver: &Resolver,\n+    path: &crate::Path,\n+) -> Option<PathResolution> {\n+    let items = resolver\n+        .resolve_module_path_in_items(db.upcast(), path.mod_path())\n+        .take_types()\n+        .map(|it| PathResolution::Def(it.into()));\n+\n+    if items.is_some() {\n+        return items;\n+    }\n+\n+    resolver.resolve_path_in_type_ns_fully(db.upcast(), path.mod_path()).map(|ty| match ty {\n+        TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n+        TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+        TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => PathResolution::Def(Adt::from(it).into()),\n+        TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+        TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n+        TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n+        TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+    })\n+}"}, {"sha": "2bc34d449f2fd8b9404e9b59762d3cbe8124f521", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -117,7 +117,14 @@ fn lower_enum(\n     ast: &InFile<ast::EnumDef>,\n     module_id: ModuleId,\n ) {\n-    for var in ast.value.variant_list().into_iter().flat_map(|it| it.variants()) {\n+    let expander = CfgExpander::new(db, ast.file_id, module_id.krate);\n+    let variants = ast\n+        .value\n+        .variant_list()\n+        .into_iter()\n+        .flat_map(|it| it.variants())\n+        .filter(|var| expander.is_cfg_enabled(var));\n+    for var in variants {\n         trace.alloc(\n             || var.clone(),\n             || EnumVariantData {\n@@ -209,8 +216,7 @@ fn lower_struct(\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n-                let attrs = expander.parse_attrs(&fd);\n-                if !expander.is_cfg_enabled(&attrs) {\n+                if !expander.is_cfg_enabled(&fd) {\n                     continue;\n                 }\n \n@@ -227,8 +233,7 @@ fn lower_struct(\n         }\n         ast::StructKind::Record(fl) => {\n             for fd in fl.fields() {\n-                let attrs = expander.parse_attrs(&fd);\n-                if !expander.is_cfg_enabled(&attrs) {\n+                if !expander.is_cfg_enabled(&fd) {\n                     continue;\n                 }\n "}, {"sha": "576cd0c65ba984b9b00dccf62877588e18981564", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -140,6 +140,7 @@ impl Attr {\n     }\n }\n \n+#[derive(Debug, Clone, Copy)]\n pub struct AttrQuery<'a> {\n     attrs: &'a Attrs,\n     key: &'static str,"}, {"sha": "f5a7305dc0905082ad22965377033d8d3c7a97f4", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -60,7 +60,8 @@ impl CfgExpander {\n         Attrs::new(owner, &self.hygiene)\n     }\n \n-    pub(crate) fn is_cfg_enabled(&self, attrs: &Attrs) -> bool {\n+    pub(crate) fn is_cfg_enabled(&self, owner: &dyn ast::AttrsOwner) -> bool {\n+        let attrs = self.parse_attrs(owner);\n         attrs.is_cfg_enabled(&self.cfg_options)\n     }\n }\n@@ -141,12 +142,8 @@ impl Expander {\n         InFile { file_id: self.current_file_id, value }\n     }\n \n-    pub(crate) fn parse_attrs(&self, owner: &dyn ast::AttrsOwner) -> Attrs {\n-        self.cfg_expander.parse_attrs(owner)\n-    }\n-\n-    pub(crate) fn is_cfg_enabled(&self, attrs: &Attrs) -> bool {\n-        self.cfg_expander.is_cfg_enabled(attrs)\n+    pub(crate) fn is_cfg_enabled(&self, owner: &dyn ast::AttrsOwner) -> bool {\n+        self.cfg_expander.is_cfg_enabled(owner)\n     }\n \n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {"}, {"sha": "e08d62dd6869d66703312cb1b98adf478dd47b96", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -15,7 +15,7 @@ use ra_syntax::{\n     },\n     AstNode, AstPtr,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     adt::StructKind,\n@@ -60,13 +60,10 @@ pub(super) fn lower(\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n-    let ctx = LowerCtx::new(db, expander.current_file_id.clone());\n-\n     ExprCollector {\n         db,\n         def,\n         expander,\n-        ctx,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n@@ -83,7 +80,6 @@ struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n-    ctx: LowerCtx,\n     body: Body,\n     source_map: BodySourceMap,\n }\n@@ -122,6 +118,10 @@ impl ExprCollector<'_> {\n         (self.body, self.source_map)\n     }\n \n+    fn ctx(&self) -> LowerCtx {\n+        LowerCtx::new(self.db, self.expander.current_file_id)\n+    }\n+\n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_expr(expr, Ok(src.clone()));\n@@ -162,8 +162,7 @@ impl ExprCollector<'_> {\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = AstPtr::new(&expr);\n-        let attrs = self.expander.parse_attrs(&expr);\n-        if !self.expander.is_cfg_enabled(&attrs) {\n+        if !self.expander.is_cfg_enabled(&expr) {\n             return self.missing_expr();\n         }\n         match expr {\n@@ -203,6 +202,16 @@ impl ExprCollector<'_> {\n \n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n+            ast::Expr::EffectExpr(e) => match e.effect() {\n+                ast::Effect::Try(_) => {\n+                    let body = self.collect_block_opt(e.block_expr());\n+                    self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+                }\n+                // FIXME: we need to record these effects somewhere...\n+                ast::Effect::Async(_) | ast::Effect::Label(_) | ast::Effect::Unsafe(_) => {\n+                    self.collect_block_opt(e.block_expr())\n+                }\n+            },\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -217,7 +226,7 @@ impl ExprCollector<'_> {\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n-                            tested_by!(infer_resolve_while_let);\n+                            mark::hit!(infer_resolve_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();\n@@ -259,7 +268,7 @@ impl ExprCollector<'_> {\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args =\n-                    e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx, it));\n+                    e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n                 self.alloc_expr(\n                     Expr::MethodCall { receiver, method_name, args, generic_args },\n                     syntax_ptr,\n@@ -319,8 +328,7 @@ impl ExprCollector<'_> {\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n                         .filter_map(|field| {\n-                            let attrs = self.expander.parse_attrs(&field);\n-                            if !self.expander.is_cfg_enabled(&attrs) {\n+                            if !self.expander.is_cfg_enabled(&field) {\n                                 return None;\n                             }\n                             let name = field.field_name()?.as_name();\n@@ -365,7 +373,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(&self.ctx, e.type_ref());\n+                let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::Expr::RefExpr(e) => {\n@@ -388,15 +396,15 @@ impl ExprCollector<'_> {\n                     for param in pl.params() {\n                         let pat = self.collect_pat_opt(param.pat());\n                         let type_ref =\n-                            param.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n+                            param.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n                 let ret_type = e\n                     .ret_type()\n                     .and_then(|r| r.type_ref())\n-                    .map(|it| TypeRef::from_ast(&self.ctx, it));\n+                    .map(|it| TypeRef::from_ast(&self.ctx(), it));\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n@@ -456,6 +464,7 @@ impl ExprCollector<'_> {\n                         krate: Some(self.expander.module.krate),\n                         ast_id: Some(self.expander.ast_id(&e)),\n                         kind: MacroDefKind::Declarative,\n+                        local_inner: false,\n                     };\n                     self.body.item_scope.define_legacy_macro(name, mac);\n \n@@ -490,19 +499,16 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_block(&mut self, expr: ast::BlockExpr) -> ExprId {\n-        let syntax_node_ptr = AstPtr::new(&expr.clone().into());\n-        let block = match expr.block() {\n-            Some(block) => block,\n-            None => return self.alloc_expr(Expr::Missing, syntax_node_ptr),\n-        };\n+    fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        let syntax_node_ptr = AstPtr::new(&block.clone().into());\n         self.collect_block_items(&block);\n         let statements = block\n             .statements()\n             .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n+                    let type_ref =\n+                        stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }\n@@ -513,7 +519,7 @@ impl ExprCollector<'_> {\n         self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n     }\n \n-    fn collect_block_items(&mut self, block: &ast::Block) {\n+    fn collect_block_items(&mut self, block: &ast::BlockExpr) {\n         let container = ContainerId::DefWithBodyId(self.def);\n         for item in block.items() {\n             let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n@@ -568,9 +574,16 @@ impl ExprCollector<'_> {\n             self.body.item_scope.define_def(def);\n             if let Some(name) = name {\n                 let vis = crate::visibility::Visibility::Public; // FIXME determine correctly\n-                self.body\n-                    .item_scope\n-                    .push_res(name.as_name(), crate::per_ns::PerNs::from_def(def, vis));\n+                let has_constructor = match def {\n+                    ModuleDefId::AdtId(AdtId::StructId(s)) => {\n+                        self.db.struct_data(s).variant_data.kind() != StructKind::Record\n+                    }\n+                    _ => true,\n+                };\n+                self.body.item_scope.push_res(\n+                    name.as_name(),\n+                    crate::per_ns::PerNs::from_def(def, vis, has_constructor),\n+                );\n             }\n         }\n     }"}, {"sha": "09e92b74e1ab43bc59e050d7247a35cb2b0b96ce", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -174,7 +174,7 @@ mod tests {\n     use hir_expand::{name::AsName, InFile};\n     use ra_db::{fixture::WithFixture, FileId, SourceDatabase};\n     use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, covers, extract_offset};\n+    use test_utils::{assert_eq_text, extract_offset, mark};\n \n     use crate::{db::DefDatabase, test_db::TestDB, FunctionId, ModuleDefId};\n \n@@ -388,7 +388,7 @@ mod tests {\n \n     #[test]\n     fn while_let_desugaring() {\n-        covers!(infer_resolve_while_let);\n+        mark::check!(infer_resolve_while_let);\n         do_check_local_name(\n             r#\"\n fn test() {"}, {"sha": "e2130d931fdb12508870ff02a90b56256eabd502", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 94, "deletions": 100, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -9,7 +9,7 @@ use hir_expand::{\n };\n use ra_prof::profile;\n use ra_syntax::ast::{\n-    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, TypeBoundsOwner,\n+    self, AssocItem, AstNode, ModuleItemOwner, NameOwner, TypeAscriptionOwner, TypeBoundsOwner,\n     VisibilityOwner,\n };\n \n@@ -150,51 +150,31 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n-        let src = tr.lookup(db).source(db);\n+        let tr_loc = tr.lookup(db);\n+        let src = tr_loc.source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let auto = src.value.auto_token().is_some();\n-        let ast_id_map = db.ast_id_map(src.file_id);\n+        let module_id = tr_loc.container.module(db);\n \n         let container = AssocContainerId::TraitId(tr);\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = FunctionLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = ConstLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = TypeAliasLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n+        let mut items = Vec::new();\n+\n+        if let Some(item_list) = src.value.item_list() {\n+            let mut expander = Expander::new(db, tr_loc.ast_id.file_id, module_id);\n+            items.extend(collect_items(\n+                db,\n+                &mut expander,\n+                item_list.assoc_items(),\n+                src.file_id,\n+                container,\n+            ));\n+            items.extend(collect_items_in_macros(\n+                db,\n+                &mut expander,\n+                &src.with_value(item_list),\n+                container,\n+            ));\n+        }\n         Arc::new(TraitData { name, items, auto })\n     }\n \n@@ -232,24 +212,22 @@ impl ImplData {\n         let target_type = TypeRef::from_ast_opt(&lower_ctx, src.value.target_type());\n         let is_negative = src.value.excl_token().is_some();\n         let module_id = impl_loc.container.module(db);\n+        let container = AssocContainerId::ImplId(id);\n \n-        let mut items = Vec::new();\n+        let mut items: Vec<AssocItemId> = Vec::new();\n \n         if let Some(item_list) = src.value.item_list() {\n             let mut expander = Expander::new(db, impl_loc.ast_id.file_id, module_id);\n-            items.extend(collect_impl_items(\n-                db,\n-                &mut expander,\n-                item_list.impl_items(),\n-                src.file_id,\n-                id,\n-            ));\n-            items.extend(collect_impl_items_in_macros(\n-                db,\n-                &mut expander,\n-                &src.with_value(item_list),\n-                id,\n-            ));\n+            items.extend(\n+                collect_items(db, &mut expander, item_list.assoc_items(), src.file_id, container)\n+                    .into_iter()\n+                    .map(|(_, item)| item),\n+            );\n+            items.extend(\n+                collect_items_in_macros(db, &mut expander, &src.with_value(item_list), container)\n+                    .into_iter()\n+                    .map(|(_, item)| item),\n+            );\n         }\n \n         let res = ImplData { target_trait, target_type, items, is_negative };\n@@ -273,11 +251,6 @@ impl ConstData {\n         Arc::new(ConstData::new(db, vis_default, node))\n     }\n \n-    pub(crate) fn static_data_query(db: &dyn DefDatabase, konst: StaticId) -> Arc<ConstData> {\n-        let node = konst.lookup(db).source(db);\n-        Arc::new(ConstData::new(db, RawVisibility::private(), node))\n-    }\n-\n     fn new<N: NameOwner + TypeAscriptionOwner + VisibilityOwner>(\n         db: &dyn DefDatabase,\n         vis_default: RawVisibility,\n@@ -292,49 +265,76 @@ impl ConstData {\n     }\n }\n \n-fn collect_impl_items_in_macros(\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StaticData {\n+    pub name: Option<Name>,\n+    pub type_ref: TypeRef,\n+    pub visibility: RawVisibility,\n+    pub mutable: bool,\n+}\n+\n+impl StaticData {\n+    pub(crate) fn static_data_query(db: &dyn DefDatabase, konst: StaticId) -> Arc<StaticData> {\n+        let node = konst.lookup(db).source(db);\n+        let ctx = LowerCtx::new(db, node.file_id);\n+\n+        let name = node.value.name().map(|n| n.as_name());\n+        let type_ref = TypeRef::from_ast_opt(&ctx, node.value.ascribed_type());\n+        let mutable = node.value.mut_token().is_some();\n+        let visibility = RawVisibility::from_ast_with_default(\n+            db,\n+            RawVisibility::private(),\n+            node.map(|n| n.visibility()),\n+        );\n+\n+        Arc::new(StaticData { name, type_ref, visibility, mutable })\n+    }\n+}\n+\n+fn collect_items_in_macros(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n     impl_def: &InFile<ast::ItemList>,\n-    id: ImplId,\n-) -> Vec<AssocItemId> {\n+    container: AssocContainerId,\n+) -> Vec<(Name, AssocItemId)> {\n     let mut res = Vec::new();\n \n     // We set a limit to protect against infinite recursion\n     let limit = 100;\n \n     for m in impl_def.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-        res.extend(collect_impl_items_in_macro(db, expander, m, id, limit))\n+        res.extend(collect_items_in_macro(db, expander, m, container, limit))\n     }\n \n     res\n }\n \n-fn collect_impl_items_in_macro(\n+fn collect_items_in_macro(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n     m: ast::MacroCall,\n-    id: ImplId,\n+    container: AssocContainerId,\n     limit: usize,\n-) -> Vec<AssocItemId> {\n+) -> Vec<(Name, AssocItemId)> {\n     if limit == 0 {\n         return Vec::new();\n     }\n \n     if let Some((mark, items)) = expander.enter_expand(db, None, m) {\n         let items: InFile<ast::MacroItems> = expander.to_source(items);\n-        let mut res = collect_impl_items(\n+        let mut res = collect_items(\n             db,\n             expander,\n-            items.value.items().filter_map(|it| ImplItem::cast(it.syntax().clone())),\n+            items.value.items().filter_map(|it| AssocItem::cast(it.syntax().clone())),\n             items.file_id,\n-            id,\n+            container,\n         );\n+\n         // Recursive collect macros\n         // Note that ast::ModuleItem do not include ast::MacroCall\n         // We cannot use ModuleItemOwner::items here\n         for it in items.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-            res.extend(collect_impl_items_in_macro(db, expander, it, id, limit - 1))\n+            res.extend(collect_items_in_macro(db, expander, it, container, limit - 1))\n         }\n         expander.exit(db, mark);\n         res\n@@ -343,44 +343,38 @@ fn collect_impl_items_in_macro(\n     }\n }\n \n-fn collect_impl_items(\n+fn collect_items(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n-    impl_items: impl Iterator<Item = ImplItem>,\n+    assoc_items: impl Iterator<Item = AssocItem>,\n     file_id: crate::HirFileId,\n-    id: ImplId,\n-) -> Vec<AssocItemId> {\n+    container: AssocContainerId,\n+) -> Vec<(Name, AssocItemId)> {\n     let items = db.ast_id_map(file_id);\n \n-    impl_items\n+    assoc_items\n         .filter_map(|item_node| match item_node {\n-            ast::ImplItem::FnDef(it) => {\n-                let attrs = expander.parse_attrs(&it);\n-                if !expander.is_cfg_enabled(&attrs) {\n+            ast::AssocItem::FnDef(it) => {\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                if !expander.is_cfg_enabled(&it) {\n                     return None;\n                 }\n-                let def = FunctionLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+                let def = FunctionLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                    .intern(db);\n+                Some((name, def.into()))\n             }\n-            ast::ImplItem::ConstDef(it) => {\n-                let def = ConstLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+            ast::AssocItem::ConstDef(it) => {\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                let def = ConstLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                    .intern(db);\n+                Some((name, def.into()))\n             }\n-            ast::ImplItem::TypeAliasDef(it) => {\n-                let def = TypeAliasLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+            ast::AssocItem::TypeAliasDef(it) => {\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                let def =\n+                    TypeAliasLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                        .intern(db);\n+                Some((name, def.into()))\n             }\n         })\n         .collect()"}, {"sha": "945a0025e504f7b71f240d9984ab6bc5344b3fbb", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,7 +1,7 @@\n //! Defines database & queries for name resolution.\n use std::sync::Arc;\n \n-use hir_expand::{db::AstDatabase, HirFileId};\n+use hir_expand::{db::AstDatabase, name::Name, HirFileId};\n use ra_db::{salsa, CrateId, SourceDatabase, Upcast};\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n@@ -10,11 +10,15 @@ use crate::{\n     adt::{EnumData, StructData},\n     attr::Attrs,\n     body::{scope::ExprScopes, Body, BodySourceMap},\n-    data::{ConstData, FunctionData, ImplData, TraitData, TypeAliasData},\n+    data::{ConstData, FunctionData, ImplData, StaticData, TraitData, TypeAliasData},\n     docs::Documentation,\n+    find_path,\n     generics::GenericParams,\n+    item_scope::ItemInNs,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{raw::RawItems, CrateDefMap},\n+    path::ModPath,\n+    visibility::Visibility,\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -77,8 +81,8 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(ConstData::const_data_query)]\n     fn const_data(&self, konst: ConstId) -> Arc<ConstData>;\n \n-    #[salsa::invoke(ConstData::static_data_query)]\n-    fn static_data(&self, konst: StaticId) -> Arc<ConstData>;\n+    #[salsa::invoke(StaticData::static_data_query)]\n+    fn static_data(&self, konst: StaticId) -> Arc<StaticData>;\n \n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n@@ -108,6 +112,16 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     // Remove this query completely, in favor of `Attrs::docs` method\n     #[salsa::invoke(Documentation::documentation_query)]\n     fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n+\n+    #[salsa::invoke(find_path::importable_locations_of_query)]\n+    fn importable_locations_of(\n+        &self,\n+        item: ItemInNs,\n+        krate: CrateId,\n+    ) -> Arc<[(ModuleId, Name, Visibility)]>;\n+\n+    #[salsa::invoke(find_path::find_path_inner_query)]\n+    fn find_path_inner(&self, item: ItemInNs, from: ModuleId, max_len: usize) -> Option<ModPath>;\n }\n \n fn crate_def_map_wait(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {"}, {"sha": "a0cdad529b3fb8404e4216df17ab6cb353a912cd", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -101,6 +101,9 @@ pub enum Expr {\n     Try {\n         expr: ExprId,\n     },\n+    TryBlock {\n+        body: ExprId,\n+    },\n     Cast {\n         expr: ExprId,\n         type_ref: TypeRef,\n@@ -236,6 +239,7 @@ impl Expr {\n                     f(*expr);\n                 }\n             }\n+            Expr::TryBlock { body } => f(*body),\n             Expr::Loop { body } => f(*body),\n             Expr::While { condition, body } => {\n                 f(*condition);"}, {"sha": "4db7984730aa87eb281516565f57761b4083cd98", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,31 +1,40 @@\n //! An algorithm to find a path to refer to a certain item.\n \n+use std::sync::Arc;\n+\n+use hir_expand::name::{known, AsName, Name};\n+use ra_prof::profile;\n+use test_utils::mark;\n+\n use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n     visibility::Visibility,\n     CrateId, ModuleDefId, ModuleId,\n };\n-use hir_expand::name::{known, AsName, Name};\n-use test_utils::tested_by;\n+\n+// FIXME: handle local items\n+\n+/// Find a path that can be used to refer to a certain item. This can depend on\n+/// *from where* you're referring to the item, hence the `from` parameter.\n+pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+    let _p = profile(\"find_path\");\n+    db.find_path_inner(item, from, MAX_PATH_LEN)\n+}\n \n const MAX_PATH_LEN: usize = 15;\n \n impl ModPath {\n     fn starts_with_std(&self) -> bool {\n-        self.segments.first().filter(|&first_segment| first_segment == &known::std).is_some()\n+        self.segments.first() == Some(&known::std)\n     }\n \n     // When std library is present, paths starting with `std::`\n     // should be preferred over paths starting with `core::` and `alloc::`\n     fn can_start_with_std(&self) -> bool {\n-        self.segments\n-            .first()\n-            .filter(|&first_segment| {\n-                first_segment == &known::alloc || first_segment == &known::core\n-            })\n-            .is_some()\n+        let first_segment = self.segments.first();\n+        first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n     }\n \n     fn len(&self) -> usize {\n@@ -40,15 +49,7 @@ impl ModPath {\n     }\n }\n \n-// FIXME: handle local items\n-\n-/// Find a path that can be used to refer to a certain item. This can depend on\n-/// *from where* you're referring to the item, hence the `from` parameter.\n-pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n-    find_path_inner(db, item, from, MAX_PATH_LEN)\n-}\n-\n-fn find_path_inner(\n+pub(crate) fn find_path_inner_query(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n@@ -139,8 +140,7 @@ fn find_path_inner(\n     let mut best_path = None;\n     let mut best_path_len = max_len;\n     for (module_id, name) in importable_locations {\n-        let mut path = match find_path_inner(\n-            db,\n+        let mut path = match db.find_path_inner(\n             ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n             from,\n             best_path_len - 1,\n@@ -163,17 +163,19 @@ fn find_path_inner(\n \n fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n     if old_path.starts_with_std() && new_path.can_start_with_std() {\n-        tested_by!(prefer_std_paths);\n         if prefer_no_std {\n+            mark::hit!(prefer_no_std_paths);\n             new_path\n         } else {\n+            mark::hit!(prefer_std_paths);\n             old_path\n         }\n     } else if new_path.starts_with_std() && old_path.can_start_with_std() {\n-        tested_by!(prefer_std_paths);\n         if prefer_no_std {\n+            mark::hit!(prefer_no_std_paths);\n             old_path\n         } else {\n+            mark::hit!(prefer_std_paths);\n             new_path\n         }\n     } else if new_path.len() < old_path.len() {\n@@ -198,7 +200,7 @@ fn find_importable_locations(\n         .chain(crate_graph[from.krate].dependencies.iter().map(|dep| dep.crate_id))\n     {\n         result.extend(\n-            importable_locations_in_crate(db, item, krate)\n+            db.importable_locations_of(item, krate)\n                 .iter()\n                 .filter(|(_, _, vis)| vis.is_visible_from(db, from))\n                 .map(|(m, n, _)| (*m, n.clone())),\n@@ -213,11 +215,12 @@ fn find_importable_locations(\n ///\n /// Note that the crate doesn't need to be the one in which the item is defined;\n /// it might be re-exported in other crates.\n-fn importable_locations_in_crate(\n+pub(crate) fn importable_locations_of_query(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     krate: CrateId,\n-) -> Vec<(ModuleId, Name, Visibility)> {\n+) -> Arc<[(ModuleId, Name, Visibility)]> {\n+    let _p = profile(\"importable_locations_of_query\");\n     let def_map = db.crate_def_map(krate);\n     let mut result = Vec::new();\n     for (local_id, data) in def_map.modules.iter() {\n@@ -243,17 +246,20 @@ fn importable_locations_in_crate(\n             result.push((ModuleId { krate, local_id }, name.clone(), vis));\n         }\n     }\n-    result\n+\n+    Arc::from(result)\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use crate::test_db::TestDB;\n     use hir_expand::hygiene::Hygiene;\n     use ra_db::fixture::WithFixture;\n     use ra_syntax::ast::AstNode;\n-    use test_utils::covers;\n+    use test_utils::mark;\n+\n+    use crate::test_db::TestDB;\n+\n+    use super::*;\n \n     /// `code` needs to contain a cursor marker; checks that `find_path` for the\n     /// item the `path` refers to returns that same path when called from the\n@@ -508,7 +514,7 @@ mod tests {\n \n     #[test]\n     fn prefer_std_paths_over_alloc() {\n-        covers!(prefer_std_paths);\n+        mark::check!(prefer_std_paths);\n         let code = r#\"\n         //- /main.rs crate:main deps:alloc,std\n         <|>\n@@ -527,51 +533,50 @@ mod tests {\n     }\n \n     #[test]\n-    fn prefer_alloc_paths_over_std() {\n-        covers!(prefer_std_paths);\n+    fn prefer_core_paths_over_std() {\n+        mark::check!(prefer_no_std_paths);\n         let code = r#\"\n-        //- /main.rs crate:main deps:alloc,std\n+        //- /main.rs crate:main deps:core,std\n         #![no_std]\n \n         <|>\n \n-        //- /std.rs crate:std deps:alloc\n+        //- /std.rs crate:std deps:core\n \n-        pub mod sync {\n-            pub use alloc::sync::Arc;\n+        pub mod fmt {\n+            pub use core::fmt::Error;\n         }\n \n-        //- /zzz.rs crate:alloc\n+        //- /zzz.rs crate:core\n \n-        pub mod sync {\n-            pub struct Arc;\n+        pub mod fmt {\n+            pub struct Error;\n         }\n         \"#;\n-        check_found_path(code, \"alloc::sync::Arc\");\n+        check_found_path(code, \"core::fmt::Error\");\n     }\n \n     #[test]\n-    fn prefer_core_paths_over_std() {\n-        covers!(prefer_std_paths);\n+    fn prefer_alloc_paths_over_std() {\n         let code = r#\"\n-        //- /main.rs crate:main deps:core,std\n+        //- /main.rs crate:main deps:alloc,std\n         #![no_std]\n \n         <|>\n \n-        //- /std.rs crate:std deps:core\n+        //- /std.rs crate:std deps:alloc\n \n-        pub mod fmt {\n-            pub use core::fmt::Error;\n+        pub mod sync {\n+            pub use alloc::sync::Arc;\n         }\n \n-        //- /zzz.rs crate:core\n+        //- /zzz.rs crate:alloc\n \n-        pub mod fmt {\n-            pub struct Error;\n+        pub mod sync {\n+            pub struct Arc;\n         }\n         \"#;\n-        check_found_path(code, \"core::fmt::Error\");\n+        check_found_path(code, \"alloc::sync::Arc\");\n     }\n \n     #[test]"}, {"sha": "fc15948adf4d0aa5d660b0f638dd58d87a6fbd27", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -151,13 +151,20 @@ impl ItemScope {\n }\n \n impl PerNs {\n-    pub(crate) fn from_def(def: ModuleDefId, v: Visibility) -> PerNs {\n+    pub(crate) fn from_def(def: ModuleDefId, v: Visibility, has_constructor: bool) -> PerNs {\n         match def {\n             ModuleDefId::ModuleId(_) => PerNs::types(def, v),\n             ModuleDefId::FunctionId(_) => PerNs::values(def, v),\n             ModuleDefId::AdtId(adt) => match adt {\n-                AdtId::StructId(_) | AdtId::UnionId(_) => PerNs::both(def, def, v),\n+                AdtId::UnionId(_) => PerNs::types(def, v),\n                 AdtId::EnumId(_) => PerNs::types(def, v),\n+                AdtId::StructId(_) => {\n+                    if has_constructor {\n+                        PerNs::both(def, def, v)\n+                    } else {\n+                        PerNs::types(def, v)\n+                    }\n+                }\n             },\n             ModuleDefId::EnumVariantId(_) => PerNs::both(def, def, v),\n             ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def, v),"}, {"sha": "5325a27608eab95ddbda832651c3dab35909c26f", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -46,8 +46,6 @@ pub mod find_path;\n \n #[cfg(test)]\n mod test_db;\n-#[cfg(test)]\n-mod marks;\n \n use std::hash::Hash;\n "}, {"sha": "daa49d5f1040b6e792127d3299261fe685b76322", "filename": "crates/ra_hir_def/src/marks.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,17 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks!(\n-    bogus_paths\n-    name_res_works_for_broken_modules\n-    can_import_enum_variant\n-    glob_enum\n-    glob_enum_group\n-    glob_across_crates\n-    std_prelude\n-    macro_rules_from_other_crates_are_visible_with_macro_use\n-    prelude_is_macro_use\n-    macro_dollar_crate_self\n-    macro_dollar_crate_other\n-    infer_resolve_while_let\n-    prefer_std_paths\n-);"}, {"sha": "353a31ad47a153cc6b717de468deb9e4b20594f9", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -14,7 +14,7 @@ use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId, ProcMacroId};\n use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     attr::Attrs,\n@@ -204,6 +204,7 @@ impl DefCollector<'_> {\n                 ast_id: None,\n                 krate: Some(krate),\n                 kind: MacroDefKind::CustomDerive(expander),\n+                local_inner: false,\n             };\n \n             self.define_proc_macro(name.clone(), macro_id);\n@@ -301,7 +302,7 @@ impl DefCollector<'_> {\n         );\n \n         if let Some(ModuleDefId::ModuleId(m)) = res.take_types() {\n-            tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+            mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n             self.import_all_macros_exported(current_module_id, m.krate);\n         }\n     }\n@@ -411,10 +412,10 @@ impl DefCollector<'_> {\n             match def.take_types() {\n                 Some(ModuleDefId::ModuleId(m)) => {\n                     if import.is_prelude {\n-                        tested_by!(std_prelude);\n+                        mark::hit!(std_prelude);\n                         self.def_map.prelude = Some(m);\n                     } else if m.krate != self.def_map.krate {\n-                        tested_by!(glob_across_crates);\n+                        mark::hit!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.crate_def_map(m.krate);\n                         let scope = &item_map[m.local_id].scope;\n@@ -460,7 +461,7 @@ impl DefCollector<'_> {\n                     }\n                 }\n                 Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n-                    tested_by!(glob_enum);\n+                    mark::hit!(glob_enum);\n                     // glob import from enum => just import all the variants\n \n                     // XXX: urgh, so this works by accident! Here, we look at\n@@ -509,7 +510,7 @@ impl DefCollector<'_> {\n \n                     self.update(module_id, &[(name, def)], vis);\n                 }\n-                None => tested_by!(bogus_paths),\n+                None => mark::hit!(bogus_paths),\n             }\n         }\n     }\n@@ -682,7 +683,7 @@ impl ModCollector<'_, '_> {\n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != self.def_collector.def_map.krate {\n-                tested_by!(prelude_is_macro_use);\n+                mark::hit!(prelude_is_macro_use);\n                 self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n         }\n@@ -829,7 +830,7 @@ impl ModCollector<'_, '_> {\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n         let def: ModuleDefId = module.into();\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))], vis);\n+        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis, false))], vis);\n         res\n     }\n \n@@ -843,14 +844,17 @@ impl ModCollector<'_, '_> {\n         let name = def.name.clone();\n         let container = ContainerId::ModuleId(module);\n         let vis = &def.visibility;\n+        let mut has_constructor = false;\n+\n         let def: ModuleDefId = match def.kind {\n             raw::DefKind::Function(ast_id) => FunctionLoc {\n                 container: container.into(),\n                 ast_id: AstId::new(self.file_id, ast_id),\n             }\n             .intern(self.def_collector.db)\n             .into(),\n-            raw::DefKind::Struct(ast_id) => {\n+            raw::DefKind::Struct(ast_id, mode) => {\n+                has_constructor = mode != raw::StructDefKind::Record;\n                 StructLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n                     .intern(self.def_collector.db)\n                     .into()\n@@ -893,7 +897,11 @@ impl ModCollector<'_, '_> {\n             .def_map\n             .resolve_visibility(self.def_collector.db, self.module_id, vis)\n             .unwrap_or(Visibility::Public);\n-        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis))], vis)\n+        self.def_collector.update(\n+            self.module_id,\n+            &[(name, PerNs::from_def(def, vis, has_constructor))],\n+            vis,\n+        )\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {\n@@ -941,6 +949,7 @@ impl ModCollector<'_, '_> {\n                     ast_id: Some(ast_id.ast_id),\n                     krate: Some(self.def_collector.def_map.krate),\n                     kind: MacroDefKind::Declarative,\n+                    local_inner: mac.local_inner,\n                 };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n             }"}, {"sha": "19692e70cf4564f97a17f817c60c9b8280c2baa5", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -14,7 +14,7 @@ use std::iter::successors;\n \n use hir_expand::name::Name;\n use ra_db::Edition;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     db::DefDatabase,\n@@ -108,15 +108,15 @@ impl CrateDefMap {\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n-                    tested_by!(macro_dollar_crate_self);\n+                    mark::hit!(macro_dollar_crate_self);\n                     PerNs::types(\n                         ModuleId { krate: self.krate, local_id: self.root }.into(),\n                         Visibility::Public,\n                     )\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n                     let module = ModuleId { krate, local_id: def_map.root };\n-                    tested_by!(macro_dollar_crate_other);\n+                    mark::hit!(macro_dollar_crate_other);\n                     PerNs::types(module.into(), Visibility::Public)\n                 }\n             }\n@@ -221,7 +221,7 @@ impl CrateDefMap {\n                 }\n                 ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n                     // enum variant\n-                    tested_by!(can_import_enum_variant);\n+                    mark::hit!(can_import_enum_variant);\n                     let enum_data = db.enum_data(e);\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {"}, {"sha": "4e628b14d921424662c11fe2d50a4a3141a739ce", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -18,7 +18,7 @@ use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner, VisibilityOwner},\n     AstNode,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     attr::Attrs,\n@@ -155,10 +155,17 @@ pub(super) struct DefData {\n     pub(super) visibility: RawVisibility,\n }\n \n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub(super) enum StructDefKind {\n+    Record,\n+    Tuple,\n+    Unit,\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub(super) enum DefKind {\n     Function(FileAstId<ast::FnDef>),\n-    Struct(FileAstId<ast::StructDef>),\n+    Struct(FileAstId<ast::StructDef>, StructDefKind),\n     Union(FileAstId<ast::UnionDef>),\n     Enum(FileAstId<ast::EnumDef>),\n     Const(FileAstId<ast::ConstDef>),\n@@ -171,7 +178,7 @@ impl DefKind {\n     pub fn ast_id(&self) -> FileAstId<ast::ModuleItem> {\n         match self {\n             DefKind::Function(it) => it.upcast(),\n-            DefKind::Struct(it) => it.upcast(),\n+            DefKind::Struct(it, _) => it.upcast(),\n             DefKind::Union(it) => it.upcast(),\n             DefKind::Enum(it) => it.upcast(),\n             DefKind::Const(it) => it.upcast(),\n@@ -188,6 +195,7 @@ pub(super) struct MacroData {\n     pub(super) path: ModPath,\n     pub(super) name: Option<Name>,\n     pub(super) export: bool,\n+    pub(super) local_inner: bool,\n     pub(super) builtin: bool,\n }\n \n@@ -235,9 +243,14 @@ impl RawItemsCollector {\n                 return;\n             }\n             ast::ModuleItem::StructDef(it) => {\n+                let kind = match it.kind() {\n+                    ast::StructKind::Record(_) => StructDefKind::Record,\n+                    ast::StructKind::Tuple(_) => StructDefKind::Tuple,\n+                    ast::StructKind::Unit => StructDefKind::Unit,\n+                };\n                 let id = self.source_ast_id_map.ast_id(&it);\n                 let name = it.name();\n-                (DefKind::Struct(id), name)\n+                (DefKind::Struct(id, kind), name)\n             }\n             ast::ModuleItem::UnionDef(it) => {\n                 let id = self.source_ast_id_map.ast_id(&it);\n@@ -333,7 +346,7 @@ impl RawItemsCollector {\n             self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n-        tested_by!(name_res_works_for_broken_modules);\n+        mark::hit!(name_res_works_for_broken_modules);\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Idx<ModuleData>>, use_item: ast::UseItem) {\n@@ -401,14 +414,32 @@ impl RawItemsCollector {\n \n         let name = m.name().map(|it| it.as_name());\n         let ast_id = self.source_ast_id_map.ast_id(&m);\n-        // FIXME: cfg_attr\n-        let export = m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"macro_export\");\n \n         // FIXME: cfg_attr\n-        let builtin =\n-            m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"rustc_builtin_macro\");\n+        let export_attr = attrs.by_key(\"macro_export\");\n+\n+        let export = export_attr.exists();\n+        let local_inner = if export {\n+            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    ident.text.contains(\"local_inner_macros\")\n+                }\n+                _ => false,\n+            })\n+        } else {\n+            false\n+        };\n+\n+        let builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n \n-        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export, builtin });\n+        let m = self.raw_items.macros.alloc(MacroData {\n+            ast_id,\n+            path,\n+            name,\n+            export,\n+            local_inner,\n+            builtin,\n+        });\n         self.push_item(current_module, attrs, RawItemKind::Macro(m));\n     }\n "}, {"sha": "05cd0297d1ed27faecc500b3b03c898f62284991", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -8,7 +8,7 @@ use std::sync::Arc;\n \n use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, SourceDatabase};\n-use test_utils::covers;\n+use test_utils::mark;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n \n@@ -67,7 +67,7 @@ fn crate_def_map_smoke_test() {\n         \u22eeBaz: t v\n         \u22eeE: t\n         \u22eeEXT: v\n-        \u22eeU: t v\n+        \u22eeU: t\n         \u22eeext: v\n     \"###)\n }\n@@ -132,7 +132,7 @@ fn crate_def_map_fn_mod_same_name() {\n \n #[test]\n fn bogus_paths() {\n-    covers!(bogus_paths);\n+    mark::check!(bogus_paths);\n     let map = def_map(\n         \"\n         //- /lib.rs\n@@ -247,7 +247,7 @@ fn re_exports() {\n \n #[test]\n fn std_prelude() {\n-    covers!(std_prelude);\n+    mark::check!(std_prelude);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:test_crate\n@@ -271,7 +271,7 @@ fn std_prelude() {\n \n #[test]\n fn can_import_enum_variant() {\n-    covers!(can_import_enum_variant);\n+    mark::check!(can_import_enum_variant);\n     let map = def_map(\n         \"\n         //- /lib.rs"}, {"sha": "2b12c0daad5afcbb9ebe39af92c252e40056c265", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -152,7 +152,7 @@ fn glob_privacy_2() {\n \n #[test]\n fn glob_across_crates() {\n-    covers!(glob_across_crates);\n+    mark::check!(glob_across_crates);\n     let map = def_map(\n         r\"\n         //- /main.rs crate:main deps:test_crate\n@@ -171,7 +171,6 @@ fn glob_across_crates() {\n \n #[test]\n fn glob_privacy_across_crates() {\n-    covers!(glob_across_crates);\n     let map = def_map(\n         r\"\n         //- /main.rs crate:main deps:test_crate\n@@ -191,7 +190,7 @@ fn glob_privacy_across_crates() {\n \n #[test]\n fn glob_enum() {\n-    covers!(glob_enum);\n+    mark::check!(glob_enum);\n     let map = def_map(\n         \"\n         //- /lib.rs\n@@ -212,7 +211,7 @@ fn glob_enum() {\n \n #[test]\n fn glob_enum_group() {\n-    covers!(glob_enum_group);\n+    mark::check!(glob_enum_group);\n     let map = def_map(\n         r\"\n         //- /lib.rs"}, {"sha": "84480d9f6c4b2356769b5e7b529b28c38c735b00", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -19,12 +19,12 @@ fn macro_rules_are_globally_visible() {\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n-   \u22eeFoo: t v\n+   \u22eeFoo: t\n    \u22eenested: t\n    \u22ee\n    \u22eecrate::nested\n-   \u22eeBar: t v\n-   \u22eeBaz: t v\n+   \u22eeBar: t\n+   \u22eeBaz: t\n     \"###);\n }\n \n@@ -91,13 +91,13 @@ fn macro_rules_from_other_crates_are_visible() {\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n+   \u22eeBar: t\n+   \u22eeFoo: t\n    \u22eebar: t\n    \u22ee\n    \u22eecrate::bar\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n+   \u22eeBar: t\n+   \u22eeFoo: t\n    \u22eebar: t\n     \"###);\n }\n@@ -124,13 +124,50 @@ fn macro_rules_export_with_local_inner_macros_are_visible() {\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n+   \u22eeBar: t\n+   \u22eeFoo: t\n    \u22eebar: t\n    \u22ee\n    \u22eecrate::bar\n-   \u22eeBar: t v\n-   \u22eeFoo: t v\n+   \u22eeBar: t\n+   \u22eeFoo: t\n+   \u22eebar: t\n+    \"###);\n+}\n+\n+#[test]\n+fn local_inner_macros_makes_local_macros_usable() {\n+    let map = def_map(\n+        \"\n+        //- /main.rs crate:main deps:foo\n+        foo::structs!(Foo, Bar);\n+        mod bar;\n+        //- /bar.rs\n+        use crate::*;\n+        //- /lib.rs crate:foo\n+        #[macro_export(local_inner_macros)]\n+        macro_rules! structs {\n+            ($($i:ident),*) => {\n+                inner!($($i),*);\n+            }\n+        }\n+        #[macro_export]\n+        macro_rules! inner {\n+            ($($i:ident),*) => {\n+                $(struct $i { field: u32 } )*\n+            }\n+        }\n+        \",\n+    );\n+    assert_snapshot!(map, @r###\"\n+   \u22eecrate\n+   \u22eeBar: t\n+   \u22eeFoo: t\n+   \u22eebar: t\n+   \u22ee\n+   \u22eecrate::bar\n+   \u22eeBar: t\n+   \u22eeFoo: t\n    \u22eebar: t\n     \"###);\n }\n@@ -167,15 +204,15 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n-   \u22eeFoo: t v\n+   \u22eeFoo: t\n    \u22eebar: m\n    \u22eefoo: m\n     \"###);\n }\n \n #[test]\n fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n-    covers!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+    mark::check!(macro_rules_from_other_crates_are_visible_with_macro_use);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:foo\n@@ -225,7 +262,7 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n \n #[test]\n fn prelude_is_macro_use() {\n-    covers!(prelude_is_macro_use);\n+    mark::check!(prelude_is_macro_use);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:foo\n@@ -507,8 +544,7 @@ fn path_qualified_macros() {\n \n #[test]\n fn macro_dollar_crate_is_correct_in_item() {\n-    covers!(macro_dollar_crate_self);\n-    covers!(macro_dollar_crate_other);\n+    mark::check!(macro_dollar_crate_self);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:foo\n@@ -566,7 +602,7 @@ fn macro_dollar_crate_is_correct_in_item() {\n \n #[test]\n fn macro_dollar_crate_is_correct_in_indirect_deps() {\n-    covers!(macro_dollar_crate_other);\n+    mark::check!(macro_dollar_crate_other);\n     // From std\n     let map = def_map(\n         r#\""}, {"sha": "b43b294cab7c631ed736eac563e78a6f1bc6f542", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn name_res_works_for_broken_modules() {\n-    covers!(name_res_works_for_broken_modules);\n+    mark::check!(name_res_works_for_broken_modules);\n     let map = def_map(\n         r\"\n         //- /lib.rs"}, {"sha": "6a0c019fdff9862530ac35d254186e742a871254", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -116,6 +116,21 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     }\n     segments.reverse();\n     generic_args.reverse();\n+\n+    // handle local_inner_macros :\n+    // Basically, even in rustc it is quite hacky:\n+    // https://github.com/rust-lang/rust/blob/614f273e9388ddd7804d5cbc80b8865068a3744e/src/librustc_resolve/macros.rs#L456\n+    // We follow what it did anyway :)\n+    if segments.len() == 1 && kind == PathKind::Plain {\n+        if let Some(macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n+            if macro_call.is_bang() {\n+                if let Some(crate_id) = hygiene.local_inner_macros() {\n+                    kind = PathKind::DollarCrate(crate_id);\n+                }\n+            }\n+        }\n+    }\n+\n     let mod_path = ModPath { kind, segments };\n     return Some(Path { type_anchor, mod_path, generic_args });\n "}, {"sha": "7cc655487e78293b6341e9931c79cf26f2661fe7", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -6,7 +6,7 @@ use std::iter;\n use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName};\n use ra_syntax::ast::{self, NameOwner};\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::path::{ImportAlias, ModPath, PathKind};\n \n@@ -54,7 +54,7 @@ pub(crate) fn lower_use_tree(\n         // FIXME: report errors somewhere\n         // We get here if we do\n         } else if is_glob {\n-            tested_by!(glob_enum_group);\n+            mark::hit!(glob_enum_group);\n             if let Some(prefix) = prefix {\n                 cb(prefix, &tree, is_glob, None)\n             }"}, {"sha": "15fdd9019b73aba62cdd4b5b9ef11f9e95ecca26", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -86,6 +86,7 @@ pub enum ResolveValueResult {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n+    ImplSelf(ImplId),\n     LocalBinding(PatId),\n     FunctionId(FunctionId),\n     ConstId(ConstId),\n@@ -291,19 +292,26 @@ impl Resolver {\n                 }\n                 Scope::GenericParams { .. } => continue,\n \n-                Scope::ImplDefScope(impl_) if n_segments > 1 => {\n+                Scope::ImplDefScope(impl_) => {\n                     if first_name == &name![Self] {\n-                        let ty = TypeNs::SelfType(*impl_);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+                        if n_segments > 1 {\n+                            let ty = TypeNs::SelfType(*impl_);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        } else {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::ImplSelf(*impl_)));\n+                        }\n                     }\n                 }\n-                Scope::AdtScope(adt) if n_segments > 1 => {\n+                Scope::AdtScope(adt) => {\n+                    if n_segments == 1 {\n+                        // bare `Self` doesn't work in the value namespace in a struct/enum definition\n+                        continue;\n+                    }\n                     if first_name == &name![Self] {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n-                Scope::ImplDefScope(_) | Scope::AdtScope(_) => continue,\n \n                 Scope::ModuleScope(m) => {\n                     let (module_def, idx) = m.crate_def_map.resolve_path("}, {"sha": "1dc9cac6651e18f377e01e8bd888707211f1dfd2", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -38,7 +38,7 @@ macro_rules! register_builtin {\n                  _ => return None,\n             };\n \n-            Some(MacroDefId { krate: None, ast_id: None, kind: MacroDefKind::BuiltInDerive(kind) })\n+            Some(MacroDefId { krate: None, ast_id: None, kind: MacroDefKind::BuiltInDerive(kind), local_inner: false })\n         }\n     };\n }"}, {"sha": "3bce8f673fd1376a27bab67ec7c198a89248b803", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -73,11 +73,13 @@ pub fn find_builtin_macro(\n             krate: Some(krate),\n             ast_id: Some(ast_id),\n             kind: MacroDefKind::BuiltIn(kind),\n+            local_inner: false,\n         }),\n         Either::Right(kind) => Some(MacroDefId {\n             krate: Some(krate),\n             ast_id: Some(ast_id),\n             kind: MacroDefKind::BuiltInEager(kind),\n+            local_inner: false,\n         }),\n     }\n }\n@@ -358,7 +360,7 @@ fn env_expand(\n     // However, we cannot use an empty string here, because for\n     // `include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"))` will become\n     // `include!(\"foo.rs\"), which might go to infinite loop\n-    let s = get_env_inner(db, arg_id, &key).unwrap_or_else(|| \"__RA_UNIMPLEMENTATED__\".to_string());\n+    let s = get_env_inner(db, arg_id, &key).unwrap_or_else(|| \"__RA_UNIMPLEMENTED__\".to_string());\n     let expanded = quote! { #s };\n \n     Ok((expanded, FragmentKind::Expr))\n@@ -406,6 +408,7 @@ mod tests {\n                     krate: Some(CrateId(0)),\n                     ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n                     kind: MacroDefKind::BuiltIn(expander),\n+                    local_inner: false,\n                 };\n \n                 let loc = MacroCallLoc {\n@@ -425,6 +428,7 @@ mod tests {\n                     krate: Some(CrateId(0)),\n                     ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n                     kind: MacroDefKind::BuiltInEager(expander),\n+                    local_inner: false,\n                 };\n \n                 let args = macro_calls[1].token_tree().unwrap();\n@@ -504,7 +508,7 @@ mod tests {\n             \"#,\n         );\n \n-        assert_eq!(expanded, \"\\\"__RA_UNIMPLEMENTATED__\\\"\");\n+        assert_eq!(expanded, \"\\\"__RA_UNIMPLEMENTED__\\\"\");\n     }\n \n     #[test]"}, {"sha": "bf30d71519e10b7b08270619b3b11e02cce330ea", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -34,7 +34,12 @@ impl TokenExpander {\n             // FIXME switch these to ExpandResult as well\n             TokenExpander::Builtin(it) => it.expand(db, id, tt).into(),\n             TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt).into(),\n-            TokenExpander::ProcMacro(it) => it.expand(db, id, tt).into(),\n+            TokenExpander::ProcMacro(_) => {\n+                // We store the result in salsa db to prevent non-determinisc behavior in\n+                // some proc-macro implementation\n+                // See #4315 for details\n+                db.expand_proc_macro(id.into()).into()\n+            }\n         }\n     }\n \n@@ -75,6 +80,8 @@ pub trait AstDatabase: SourceDatabase {\n \n     #[salsa::interned]\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n+\n+    fn expand_proc_macro(&self, call: MacroCallId) -> Result<tt::Subtree, mbe::ExpandError>;\n }\n \n /// This expands the given macro call, but with different arguments. This is\n@@ -216,6 +223,33 @@ fn macro_expand_with_arg(\n     (Some(Arc::new(tt)), err.map(|e| format!(\"{:?}\", e)))\n }\n \n+pub(crate) fn expand_proc_macro(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let lazy_id = match id {\n+        MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(_) => unreachable!(),\n+    };\n+\n+    let loc = db.lookup_intern_macro(lazy_id);\n+    let macro_arg = match db.macro_arg(id) {\n+        Some(it) => it,\n+        None => {\n+            return Err(\n+                tt::ExpansionError::Unknown(\"No arguments for proc-macro\".to_string()).into()\n+            )\n+        }\n+    };\n+\n+    let expander = match loc.def.kind {\n+        MacroDefKind::CustomDerive(expander) => expander,\n+        _ => unreachable!(),\n+    };\n+\n+    expander.expand(db, lazy_id, &macro_arg.0)\n+}\n+\n pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n     match file_id.0 {\n         HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n@@ -330,7 +364,7 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n             FragmentKind::Expr\n         }\n         // FIXME: Expand to statements in appropriate positions; HIR lowering needs to handle that\n-        EXPR_STMT | BLOCK => FragmentKind::Expr,\n+        EXPR_STMT | BLOCK_EXPR => FragmentKind::Expr,\n         ARG_LIST => FragmentKind::Expr,\n         TRY_EXPR => FragmentKind::Expr,\n         TUPLE_EXPR => FragmentKind::Expr,\n@@ -342,7 +376,6 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n         CONDITION => FragmentKind::Expr,\n         BREAK_EXPR => FragmentKind::Expr,\n         RETURN_EXPR => FragmentKind::Expr,\n-        BLOCK_EXPR => FragmentKind::Expr,\n         MATCH_EXPR => FragmentKind::Expr,\n         MATCH_ARM => FragmentKind::Expr,\n         MATCH_GUARD => FragmentKind::Expr,"}, {"sha": "6b482a60c5400ef4f157c05b2caf10bc140f19b7", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -16,31 +16,34 @@ use crate::{\n pub struct Hygiene {\n     // This is what `$crate` expands to\n     def_crate: Option<CrateId>,\n+\n+    // Indiciate this is a local inner macro\n+    local_inner: bool,\n }\n \n impl Hygiene {\n     pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n-        let def_crate = match file_id.0 {\n-            HirFileIdRepr::FileId(_) => None,\n+        let (def_crate, local_inner) = match file_id.0 {\n+            HirFileIdRepr::FileId(_) => (None, false),\n             HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n                 MacroCallId::LazyMacro(id) => {\n                     let loc = db.lookup_intern_macro(id);\n                     match loc.def.kind {\n-                        MacroDefKind::Declarative => loc.def.krate,\n-                        MacroDefKind::BuiltIn(_) => None,\n-                        MacroDefKind::BuiltInDerive(_) => None,\n-                        MacroDefKind::BuiltInEager(_) => None,\n-                        MacroDefKind::CustomDerive(_) => None,\n+                        MacroDefKind::Declarative => (loc.def.krate, loc.def.local_inner),\n+                        MacroDefKind::BuiltIn(_) => (None, false),\n+                        MacroDefKind::BuiltInDerive(_) => (None, false),\n+                        MacroDefKind::BuiltInEager(_) => (None, false),\n+                        MacroDefKind::CustomDerive(_) => (None, false),\n                     }\n                 }\n-                MacroCallId::EagerMacro(_id) => None,\n+                MacroCallId::EagerMacro(_id) => (None, false),\n             },\n         };\n-        Hygiene { def_crate }\n+        Hygiene { def_crate, local_inner }\n     }\n \n     pub fn new_unhygienic() -> Hygiene {\n-        Hygiene { def_crate: None }\n+        Hygiene { def_crate: None, local_inner: false }\n     }\n \n     // FIXME: this should just return name\n@@ -52,4 +55,12 @@ impl Hygiene {\n         }\n         Either::Left(name_ref.as_name())\n     }\n+\n+    pub fn local_inner_macros(&self) -> Option<CrateId> {\n+        if self.local_inner {\n+            self.def_crate\n+        } else {\n+            None\n+        }\n+    }\n }"}, {"sha": "f440c073ba8abd6ebedc28a4e5374a3e8d6126e9", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -204,6 +204,8 @@ pub struct MacroDefId {\n     pub krate: Option<CrateId>,\n     pub ast_id: Option<AstId<ast::MacroCall>>,\n     pub kind: MacroDefKind,\n+\n+    pub local_inner: bool,\n }\n \n impl MacroDefId {"}, {"sha": "5fc0ec5e3c7c928d59fd9e2d20f8d1dd1f9b42ea", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -27,9 +27,9 @@ test_utils = { path = \"../test_utils\" }\n \n scoped-tls = \"1\"\n \n-chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"2c072cc830d04af5f10b390e6643327f85108282\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"2c072cc830d04af5f10b390e6643327f85108282\" }\n-chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"2c072cc830d04af5f10b390e6643327f85108282\" }\n+chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"3e9c2503ae9c5277c2acb74624dc267876dd89b3\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"3e9c2503ae9c5277c2acb74624dc267876dd89b3\" }\n+chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"3e9c2503ae9c5277c2acb74624dc267876dd89b3\" }\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "3e6e1e3331b0140bd7c0ca174326b51fcaeef142", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -573,14 +573,20 @@ pub(crate) fn is_useful(\n     matrix: &Matrix,\n     v: &PatStack,\n ) -> MatchCheckResult<Usefulness> {\n-    // Handle the special case of enums with no variants. In that case, no match\n-    // arm is useful.\n-    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(AdtId::EnumId(enum_id)), .. }) =\n-        cx.infer[cx.match_expr].strip_references()\n-    {\n-        if cx.db.enum_data(*enum_id).variants.is_empty() {\n+    // Handle two special cases:\n+    // - enum with no variants\n+    // - `!` type\n+    // In those cases, no match arm is useful.\n+    match cx.infer[cx.match_expr].strip_references() {\n+        Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(AdtId::EnumId(enum_id)), .. }) => {\n+            if cx.db.enum_data(*enum_id).variants.is_empty() {\n+                return Ok(Usefulness::NotUseful);\n+            }\n+        }\n+        Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) => {\n             return Ok(Usefulness::NotUseful);\n         }\n+        _ => (),\n     }\n \n     if v.is_empty() {\n@@ -1917,6 +1923,17 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn type_never() {\n+        let content = r\"\n+            fn test_fn(never: !) {\n+                match never {}\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_never_ref() {\n         let content = r\"\n@@ -1929,6 +1946,23 @@ mod tests {\n \n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn expr_diverges_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop {} {\n+                    Either::A => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n }\n \n #[cfg(test)]\n@@ -1980,26 +2014,6 @@ mod false_negatives {\n         check_no_diagnostic(content);\n     }\n \n-    #[test]\n-    fn expr_diverges_missing_arm() {\n-        let content = r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                }\n-            }\n-        \";\n-\n-        // This is a false negative.\n-        // Even though the match expression diverges, rustc fails\n-        // to compile here since `Either::B` is missing.\n-        check_no_diagnostic(content);\n-    }\n-\n     #[test]\n     fn expr_loop_missing_arm() {\n         let content = r\"\n@@ -2018,7 +2032,7 @@ mod false_negatives {\n         // We currently infer the type of `loop { break Foo::A }` to `!`, which\n         // causes us to skip the diagnostic since `Either::A` doesn't type check\n         // with `!`.\n-        check_no_diagnostic(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]"}, {"sha": "41ac702724e845ec68845a20b4e8357a32beb65c", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -131,3 +131,31 @@ impl AstDiagnostic for MissingOkInTailExpr {\n         ast::Expr::cast(node).unwrap()\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct BreakOutsideOfLoop {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for BreakOutsideOfLoop {\n+    fn message(&self) -> String {\n+        \"break outside of loop\".to_string()\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for BreakOutsideOfLoop {\n+    type AST = ast::Expr;\n+\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.file).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::Expr::cast(node).unwrap()\n+    }\n+}"}, {"sha": "b9c4d2e89783f18a5513ffe81828c804d5004a86", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 176, "deletions": 63, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -6,28 +6,42 @@ use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n     Obligation, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n-use hir_def::{generics::TypeParamProvenance, AdtId, AssocContainerId, Lookup};\n+use hir_def::{\n+    find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n+    Lookup, ModuleId,\n+};\n use hir_expand::name::Name;\n \n-pub struct HirFormatter<'a, 'b> {\n+pub struct HirFormatter<'a> {\n     pub db: &'a dyn HirDatabase,\n-    fmt: &'a mut fmt::Formatter<'b>,\n+    fmt: &'a mut dyn fmt::Write,\n     buf: String,\n     curr_size: usize,\n     pub(crate) max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n }\n \n pub trait HirDisplay {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result;\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError>;\n \n+    /// Returns a `Display`able type that is human-readable.\n+    /// Use this for showing types to the user (e.g. diagnostics)\n     fn display<'a>(&'a self, db: &'a dyn HirDatabase) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, None, false)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n     }\n \n+    /// Returns a `Display`able type that is human-readable and tries to be succinct.\n+    /// Use this for showing types to the user where space is constrained (e.g. doc popups)\n     fn display_truncated<'a>(\n         &'a self,\n         db: &'a dyn HirDatabase,\n@@ -36,16 +50,46 @@ pub trait HirDisplay {\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, max_size, true)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size,\n+            omit_verbose_types: true,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n+    }\n+\n+    /// Returns a String representation of `self` that can be inserted into the given module.\n+    /// Use this when generating code (e.g. assists)\n+    fn display_source_code<'a>(\n+        &'a self,\n+        db: &'a dyn HirDatabase,\n+        module_id: ModuleId,\n+    ) -> Result<String, DisplaySourceCodeError> {\n+        let mut result = String::new();\n+        match self.hir_fmt(&mut HirFormatter {\n+            db,\n+            fmt: &mut result,\n+            buf: String::with_capacity(20),\n+            curr_size: 0,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::SourceCode { module_id },\n+        }) {\n+            Ok(()) => {}\n+            Err(HirDisplayError::FmtError) => panic!(\"Writing to String can't fail!\"),\n+            Err(HirDisplayError::DisplaySourceCodeError(e)) => return Err(e),\n+        };\n+        Ok(result)\n     }\n }\n \n-impl<'a, 'b> HirFormatter<'a, 'b> {\n+impl<'a> HirFormatter<'a> {\n     pub fn write_joined<T: HirDisplay>(\n         &mut self,\n         iter: impl IntoIterator<Item = T>,\n         sep: &str,\n-    ) -> fmt::Result {\n+    ) -> Result<(), HirDisplayError> {\n         let mut first = true;\n         for e in iter {\n             if !first {\n@@ -58,14 +102,14 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n \n     /// This allows using the `write!` macro directly with a `HirFormatter`.\n-    pub fn write_fmt(&mut self, args: fmt::Arguments) -> fmt::Result {\n+    pub fn write_fmt(&mut self, args: fmt::Arguments) -> Result<(), HirDisplayError> {\n         // We write to a buffer first to track output size\n         self.buf.clear();\n         fmt::write(&mut self.buf, args)?;\n         self.curr_size += self.buf.len();\n \n         // Then we write to the internal formatter from the buffer\n-        self.fmt.write_str(&self.buf)\n+        self.fmt.write_str(&self.buf).map_err(HirDisplayError::from)\n     }\n \n     pub fn should_truncate(&self) -> bool {\n@@ -81,34 +125,82 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n }\n \n-pub struct HirDisplayWrapper<'a, T>(&'a dyn HirDatabase, &'a T, Option<usize>, bool);\n+#[derive(Clone, Copy)]\n+enum DisplayTarget {\n+    /// Display types for inlays, doc popups, autocompletion, etc...\n+    /// Showing `{unknown}` or not qualifying paths is fine here.\n+    /// There's no reason for this to fail.\n+    Diagnostics,\n+    /// Display types for inserting them in source files.\n+    /// The generated code should compile, so paths need to be qualified.\n+    SourceCode { module_id: ModuleId },\n+}\n+\n+impl DisplayTarget {\n+    fn is_source_code(&self) -> bool {\n+        matches!(self, Self::SourceCode {..})\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum DisplaySourceCodeError {\n+    PathNotFound,\n+}\n+\n+pub enum HirDisplayError {\n+    /// Errors that can occur when generating source code\n+    DisplaySourceCodeError(DisplaySourceCodeError),\n+    /// `FmtError` is required to be compatible with std::fmt::Display\n+    FmtError,\n+}\n+impl From<fmt::Error> for HirDisplayError {\n+    fn from(_: fmt::Error) -> Self {\n+        Self::FmtError\n+    }\n+}\n+\n+pub struct HirDisplayWrapper<'a, T> {\n+    db: &'a dyn HirDatabase,\n+    t: &'a T,\n+    max_size: Option<usize>,\n+    omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n+}\n \n impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n where\n     T: HirDisplay,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.1.hir_fmt(&mut HirFormatter {\n-            db: self.0,\n+        match self.t.hir_fmt(&mut HirFormatter {\n+            db: self.db,\n             fmt: f,\n             buf: String::with_capacity(20),\n             curr_size: 0,\n-            max_size: self.2,\n-            omit_verbose_types: self.3,\n-        })\n+            max_size: self.max_size,\n+            omit_verbose_types: self.omit_verbose_types,\n+            display_target: self.display_target,\n+        }) {\n+            Ok(()) => Ok(()),\n+            Err(HirDisplayError::FmtError) => Err(fmt::Error),\n+            Err(HirDisplayError::DisplaySourceCodeError(_)) => {\n+                // This should never happen\n+                panic!(\"HirDisplay failed when calling Display::fmt!\")\n+            }\n+        }\n     }\n }\n \n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -191,45 +283,66 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n-                };\n-                write!(f, \"{}\", name)?;\n+                match f.display_target {\n+                    DisplayTarget::Diagnostics => {\n+                        let name = match def_id {\n+                            AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                            AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                            AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                        };\n+                        write!(f, \"{}\", name)?;\n+                    }\n+                    DisplayTarget::SourceCode { module_id } => {\n+                        if let Some(path) = find_path::find_path(\n+                            f.db.upcast(),\n+                            ItemInNs::Types(def_id.into()),\n+                            module_id,\n+                        ) {\n+                            write!(f, \"{}\", path)?;\n+                        } else {\n+                            return Err(HirDisplayError::DisplaySourceCodeError(\n+                                DisplaySourceCodeError::PathNotFound,\n+                            ));\n+                        }\n+                    }\n+                }\n+\n                 if self.parameters.len() > 0 {\n                     let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n-                    let parameters_to_write = if f.omit_verbose_types() {\n-                        match self\n-                            .ctor\n-                            .as_generic_def()\n-                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n-                            .filter(|defaults| !defaults.is_empty())\n-                        {\n-                            None => self.parameters.0.as_ref(),\n-                            Some(default_parameters) => {\n-                                for (i, parameter) in self.parameters.iter().enumerate() {\n-                                    match (parameter, default_parameters.get(i)) {\n-                                        (&Ty::Unknown, _) | (_, None) => {\n-                                            non_default_parameters.push(parameter.clone())\n+                    let parameters_to_write =\n+                        if f.display_target.is_source_code() || f.omit_verbose_types() {\n+                            match self\n+                                .ctor\n+                                .as_generic_def()\n+                                .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                                .filter(|defaults| !defaults.is_empty())\n+                            {\n+                                None => self.parameters.0.as_ref(),\n+                                Some(default_parameters) => {\n+                                    for (i, parameter) in self.parameters.iter().enumerate() {\n+                                        match (parameter, default_parameters.get(i)) {\n+                                            (&Ty::Unknown, _) | (_, None) => {\n+                                                non_default_parameters.push(parameter.clone())\n+                                            }\n+                                            (_, Some(default_parameter))\n+                                                if parameter != default_parameter =>\n+                                            {\n+                                                non_default_parameters.push(parameter.clone())\n+                                            }\n+                                            _ => (),\n                                         }\n-                                        (_, Some(default_parameter))\n-                                            if parameter != default_parameter =>\n-                                        {\n-                                            non_default_parameters.push(parameter.clone())\n-                                        }\n-                                        _ => (),\n                                     }\n+                                    &non_default_parameters\n                                 }\n-                                &non_default_parameters\n                             }\n-                        }\n-                    } else {\n-                        self.parameters.0.as_ref()\n-                    };\n-                    write!(f, \"<\")?;\n-                    f.write_joined(parameters_to_write, \", \")?;\n-                    write!(f, \">\")?;\n+                        } else {\n+                            self.parameters.0.as_ref()\n+                        };\n+                    if !parameters_to_write.is_empty() {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(parameters_to_write, \", \")?;\n+                        write!(f, \">\")?;\n+                    }\n                 }\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n@@ -269,7 +382,7 @@ impl HirDisplay for ApplicationTy {\n }\n \n impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -287,7 +400,7 @@ impl HirDisplay for ProjectionTy {\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -332,7 +445,7 @@ impl HirDisplay for Ty {\n fn write_bounds_like_dyn_trait(\n     predicates: &[GenericPredicate],\n     f: &mut HirFormatter,\n-) -> fmt::Result {\n+) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n     // actual Rust. It will have weird results if the predicates\n@@ -394,7 +507,7 @@ fn write_bounds_like_dyn_trait(\n }\n \n impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> fmt::Result {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -416,19 +529,19 @@ impl TraitRef {\n }\n \n impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.hir_fmt_ext(f, false)\n     }\n }\n \n impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -452,15 +565,15 @@ impl HirDisplay for GenericPredicate {\n }\n \n impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        Ok(match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db))?,\n             Obligation::Projection(proj) => write!(\n                 f,\n                 \"Normalize({} => {})\",\n                 proj.projection_ty.display(f.db),\n                 proj.ty.display(f.db)\n-            ),\n-        }\n+            )?,\n+        })\n     }\n }"}, {"sha": "957d6e0b5792d5f6d84a609e76ab5c2a57cd7382", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 132, "deletions": 16, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -22,13 +22,14 @@ use rustc_hash::FxHashMap;\n \n use hir_def::{\n     body::Body,\n-    data::{ConstData, FunctionData},\n+    data::{ConstData, FunctionData, StaticData},\n     expr::{BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AssocItemId, DefWithBodyId, FieldId, FunctionId, TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, TraitId, TypeAliasId,\n+    VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n@@ -71,7 +72,7 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n     match def {\n         DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n         DefWithBodyId::FunctionId(f) => ctx.collect_fn(&db.function_data(f)),\n-        DefWithBodyId::StaticId(s) => ctx.collect_const(&db.static_data(s)),\n+        DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n     }\n \n     ctx.infer_body();\n@@ -210,6 +211,14 @@ struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    diverges: Diverges,\n+    breakables: Vec<BreakableContext>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct BreakableContext {\n+    pub may_break: bool,\n+    pub break_ty: Ty,\n }\n \n impl<'a> InferenceContext<'a> {\n@@ -224,6 +233,8 @@ impl<'a> InferenceContext<'a> {\n             owner,\n             body: db.body(owner),\n             resolver,\n+            diverges: Diverges::Maybe,\n+            breakables: Vec::new(),\n         }\n     }\n \n@@ -429,43 +440,95 @@ impl<'a> InferenceContext<'a> {\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-        return match resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path.mod_path()) {\n-            Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n+        let (resolution, unresolved) =\n+            match resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+                Some(it) => it,\n+                None => return (Ty::Unknown, None),\n+            };\n+        return match resolution {\n+            TypeNs::AdtId(AdtId::StructId(strukt)) => {\n                 let substs = Ty::substs_from_path(&ctx, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n-                (ty, Some(strukt.into()))\n+                forbid_unresolved_segments((ty, Some(strukt.into())), unresolved)\n             }\n-            Some(TypeNs::EnumVariantId(var)) => {\n+            TypeNs::EnumVariantId(var) => {\n                 let substs = Ty::substs_from_path(&ctx, path, var.into());\n                 let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n-                (ty, Some(var.into()))\n+                forbid_unresolved_segments((ty, Some(var.into())), unresolved)\n             }\n-            Some(TypeNs::SelfType(impl_id)) => {\n+            TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = Substs::type_params_for_generics(&generics);\n                 let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n-                let variant = ty_variant(&ty);\n-                (ty, variant)\n+                match unresolved {\n+                    None => {\n+                        let variant = ty_variant(&ty);\n+                        (ty, variant)\n+                    }\n+                    Some(1) => {\n+                        let segment = path.mod_path().segments.last().unwrap();\n+                        // this could be an enum variant or associated type\n+                        if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {\n+                            let enum_data = self.db.enum_data(enum_id);\n+                            if let Some(local_id) = enum_data.variant(segment) {\n+                                let variant = EnumVariantId { parent: enum_id, local_id };\n+                                return (ty, Some(variant.into()));\n+                            }\n+                        }\n+                        // FIXME potentially resolve assoc type\n+                        (Ty::Unknown, None)\n+                    }\n+                    Some(_) => {\n+                        // FIXME diagnostic\n+                        (Ty::Unknown, None)\n+                    }\n+                }\n             }\n-            Some(TypeNs::TypeAliasId(it)) => {\n+            TypeNs::TypeAliasId(it) => {\n                 let substs = Substs::build_for_def(self.db, it)\n                     .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                     .build();\n                 let ty = self.db.ty(it.into()).subst(&substs);\n                 let variant = ty_variant(&ty);\n-                (ty, variant)\n+                forbid_unresolved_segments((ty, variant), unresolved)\n+            }\n+            TypeNs::AdtSelfType(_) => {\n+                // FIXME this could happen in array size expressions, once we're checking them\n+                (Ty::Unknown, None)\n+            }\n+            TypeNs::GenericParam(_) => {\n+                // FIXME potentially resolve assoc type\n+                (Ty::Unknown, None)\n+            }\n+            TypeNs::AdtId(AdtId::EnumId(_))\n+            | TypeNs::AdtId(AdtId::UnionId(_))\n+            | TypeNs::BuiltinType(_)\n+            | TypeNs::TraitId(_) => {\n+                // FIXME diagnostic\n+                (Ty::Unknown, None)\n             }\n-            Some(_) | None => (Ty::Unknown, None),\n         };\n \n+        fn forbid_unresolved_segments(\n+            result: (Ty, Option<VariantId>),\n+            unresolved: Option<usize>,\n+        ) -> (Ty, Option<VariantId>) {\n+            if unresolved.is_none() {\n+                result\n+            } else {\n+                // FIXME diagnostic\n+                (Ty::Unknown, None)\n+            }\n+        }\n+\n         fn ty_variant(ty: &Ty) -> Option<VariantId> {\n             ty.as_adt().and_then(|(adt_id, _)| match adt_id {\n                 AdtId::StructId(s) => Some(VariantId::StructId(s)),\n                 AdtId::UnionId(u) => Some(VariantId::UnionId(u)),\n                 AdtId::EnumId(_) => {\n-                    // Error E0071, expected struct, variant or union type, found enum `Foo`\n+                    // FIXME Error E0071, expected struct, variant or union type, found enum `Foo`\n                     None\n                 }\n             })\n@@ -476,6 +539,10 @@ impl<'a> InferenceContext<'a> {\n         self.return_ty = self.make_ty(&data.type_ref);\n     }\n \n+    fn collect_static(&mut self, data: &StaticData) {\n+        self.return_ty = self.make_ty(&data.type_ref);\n+    }\n+\n     fn collect_fn(&mut self, data: &FunctionData) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n@@ -666,15 +733,57 @@ impl Expectation {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+enum Diverges {\n+    Maybe,\n+    Always,\n+}\n+\n+impl Diverges {\n+    fn is_always(self) -> bool {\n+        self == Diverges::Always\n+    }\n+}\n+\n+impl std::ops::BitAnd for Diverges {\n+    type Output = Self;\n+    fn bitand(self, other: Self) -> Self {\n+        std::cmp::min(self, other)\n+    }\n+}\n+\n+impl std::ops::BitOr for Diverges {\n+    type Output = Self;\n+    fn bitor(self, other: Self) -> Self {\n+        std::cmp::max(self, other)\n+    }\n+}\n+\n+impl std::ops::BitAndAssign for Diverges {\n+    fn bitand_assign(&mut self, other: Self) {\n+        *self = *self & other;\n+    }\n+}\n+\n+impl std::ops::BitOrAssign for Diverges {\n+    fn bitor_assign(&mut self, other: Self) {\n+        *self = *self | other;\n+    }\n+}\n+\n mod diagnostics {\n     use hir_def::{expr::ExprId, FunctionId};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n-    use crate::{db::HirDatabase, diagnostics::NoSuchField};\n+    use crate::{\n+        db::HirDatabase,\n+        diagnostics::{BreakOutsideOfLoop, NoSuchField},\n+    };\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n     pub(super) enum InferenceDiagnostic {\n         NoSuchField { expr: ExprId, field: usize },\n+        BreakOutsideOfLoop { expr: ExprId },\n     }\n \n     impl InferenceDiagnostic {\n@@ -690,6 +799,13 @@ mod diagnostics {\n                     let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file: field.file_id, field: field.value })\n                 }\n+                InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n+                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let ptr = source_map\n+                        .expr_syntax(*expr)\n+                        .expect(\"break outside of loop in synthetic syntax\");\n+                    sink.push(BreakOutsideOfLoop { file: ptr.file_id, expr: ptr.value })\n+                }\n             }\n         }\n     }"}, {"sha": "2ee9adb16425c8063a1c44831193bcced58cc46d", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -5,7 +5,7 @@\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n use hir_def::{lang_item::LangItemTarget, type_ref::Mutability};\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty, TypeCtor};\n \n@@ -20,21 +20,35 @@ impl<'a> InferenceContext<'a> {\n         self.coerce_inner(from_ty, &to_ty)\n     }\n \n-    /// Merge two types from different branches, with possible implicit coerce.\n+    /// Merge two types from different branches, with possible coercion.\n     ///\n-    /// Note that it is only possible that one type are coerced to another.\n-    /// Coercing both types to another least upper bound type is not possible in rustc,\n-    /// which will simply result in \"incompatible types\" error.\n+    /// Mostly this means trying to coerce one to the other, but\n+    ///  - if we have two function types for different functions, we need to\n+    ///    coerce both to function pointers;\n+    ///  - if we were concerned with lifetime subtyping, we'd need to look for a\n+    ///    least upper bound.\n     pub(super) fn coerce_merge_branch(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n         if self.coerce(ty1, ty2) {\n             ty2.clone()\n         } else if self.coerce(ty2, ty1) {\n             ty1.clone()\n         } else {\n-            tested_by!(coerce_merge_fail_fallback);\n-            // For incompatible types, we use the latter one as result\n-            // to be better recovery for `if` without `else`.\n-            ty2.clone()\n+            if let (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnDef(_))) = (ty1, ty2) {\n+                mark::hit!(coerce_fn_reification);\n+                // Special case: two function types. Try to coerce both to\n+                // pointers to have a chance at getting a match. See\n+                // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n+                let sig1 = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let sig2 = ty2.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let ptr_ty1 = Ty::fn_ptr(sig1);\n+                let ptr_ty2 = Ty::fn_ptr(sig2);\n+                self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n+            } else {\n+                mark::hit!(coerce_merge_fail_fallback);\n+                // For incompatible types, we use the latter one as result\n+                // to be better recovery for `if` without `else`.\n+                ty2.clone()\n+            }\n         }\n     }\n \n@@ -84,9 +98,7 @@ impl<'a> InferenceContext<'a> {\n                 match from_ty.callable_sig(self.db) {\n                     None => return false,\n                     Some(sig) => {\n-                        let num_args = sig.params_and_return.len() as u16 - 1;\n-                        from_ty =\n-                            Ty::apply(TypeCtor::FnPtr { num_args }, Substs(sig.params_and_return));\n+                        from_ty = Ty::fn_ptr(sig);\n                     }\n                 }\n             }"}, {"sha": "b28724f0e9461e03a6388b961feb77f58ae91ad4", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 95, "deletions": 21, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,7 +1,7 @@\n //! Type inference for expressions.\n \n use std::iter::{repeat, repeat_with};\n-use std::sync::Arc;\n+use std::{mem, sync::Arc};\n \n use hir_def::{\n     builtin_type::Signedness,\n@@ -21,11 +21,18 @@ use crate::{\n     Ty, TypeCtor, Uncertain,\n };\n \n-use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n+use super::{\n+    BindingMode, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,\n+    TypeMismatch,\n+};\n \n impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n+        if ty.is_never() {\n+            // Any expression that produces a value of type `!` must have diverged\n+            self.diverges = Diverges::Always;\n+        }\n         let could_unify = self.unify(&ty, &expected.ty);\n         if !could_unify {\n             self.result.type_mismatches.insert(\n@@ -64,34 +71,68 @@ impl<'a> InferenceContext<'a> {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n+                let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let mut both_arms_diverge = Diverges::Always;\n+\n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n+                both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => Ty::unit(),\n                 };\n+                both_arms_diverge &= self.diverges;\n+\n+                self.diverges = condition_diverges | both_arms_diverge;\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n+            Expr::TryBlock { body } => {\n+                let _inner = self.infer_expr(*body, expected);\n+                // FIXME should be std::result::Result<{inner}, _>\n+                Ty::Unknown\n+            }\n             Expr::Loop { body } => {\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: self.table.new_type_var(),\n+                });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                // FIXME handle break with value\n-                Ty::simple(TypeCtor::Never)\n+\n+                let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                if ctxt.may_break {\n+                    self.diverges = Diverges::Maybe;\n+                }\n+\n+                if ctxt.may_break {\n+                    ctxt.break_ty\n+                } else {\n+                    Ty::simple(TypeCtor::Never)\n+                }\n             }\n             Expr::While { condition, body } => {\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::Lambda { body, args, ret_type, arg_types } => {\n@@ -127,10 +168,12 @@ impl<'a> InferenceContext<'a> {\n                 // infer the body.\n                 self.coerce(&closure_ty, &expected.ty);\n \n-                let prev_ret_ty = std::mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n                 self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n \n+                self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n \n                 closure_ty\n@@ -160,7 +203,11 @@ impl<'a> InferenceContext<'a> {\n                     self.table.new_type_var()\n                 };\n \n+                let matchee_diverges = self.diverges;\n+                let mut all_arms_diverge = Diverges::Always;\n+\n                 for arm in arms {\n+                    self.diverges = Diverges::Maybe;\n                     let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n@@ -170,9 +217,12 @@ impl<'a> InferenceContext<'a> {\n                     }\n \n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    all_arms_diverge &= self.diverges;\n                     result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n                 }\n \n+                self.diverges = matchee_diverges | all_arms_diverge;\n+\n                 result_ty\n             }\n             Expr::Path(p) => {\n@@ -182,10 +232,29 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n-                if let Some(expr) = expr {\n-                    // FIXME handle break with value\n-                    self.infer_expr(*expr, &Expectation::none());\n+                let val_ty = if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::none())\n+                } else {\n+                    Ty::unit()\n+                };\n+\n+                let last_ty = if let Some(ctxt) = self.breakables.last() {\n+                    ctxt.break_ty.clone()\n+                } else {\n+                    Ty::Unknown\n+                };\n+\n+                let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n+\n+                if let Some(ctxt) = self.breakables.last_mut() {\n+                    ctxt.break_ty = merged_type;\n+                    ctxt.may_break = true;\n+                } else {\n+                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                        expr: tgt_expr,\n+                    });\n                 }\n+\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {\n@@ -496,8 +565,8 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 Literal::ByteString(..) => {\n                     let byte_type = Ty::simple(TypeCtor::Int(Uncertain::Known(IntTy::u8())));\n-                    let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n-                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n+                    let array_type = Ty::apply_one(TypeCtor::Array, byte_type);\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), array_type)\n                 }\n                 Literal::Char(..) => Ty::simple(TypeCtor::Char),\n                 Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int((*ty).into())),\n@@ -517,7 +586,6 @@ impl<'a> InferenceContext<'a> {\n         tail: Option<ExprId>,\n         expected: &Expectation,\n     ) -> Ty {\n-        let mut diverges = false;\n         for stmt in statements {\n             match stmt {\n                 Statement::Let { pat, type_ref, initializer } => {\n@@ -539,24 +607,30 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n-                    if let ty_app!(TypeCtor::Never) = self.infer_expr(*expr, &Expectation::none()) {\n-                        diverges = true;\n-                    }\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n \n         let ty = if let Some(expr) = tail {\n             self.infer_expr_coerce(expr, expected)\n         } else {\n-            self.coerce(&Ty::unit(), expected.coercion_target());\n-            Ty::unit()\n+            // Citing rustc: if there is no explicit tail expression,\n+            // that is typically equivalent to a tail expression\n+            // of `()` -- except if the block diverges. In that\n+            // case, there is no value supplied from the tail\n+            // expression (assuming there are no other breaks,\n+            // this implies that the type of the block will be\n+            // `!`).\n+            if self.diverges.is_always() {\n+                // we don't even make an attempt at coercion\n+                self.table.new_maybe_never_type_var()\n+            } else {\n+                self.coerce(&Ty::unit(), expected.coercion_target());\n+                Ty::unit()\n+            }\n         };\n-        if diverges {\n-            Ty::simple(TypeCtor::Never)\n-        } else {\n-            ty\n-        }\n+        ty\n     }\n \n     fn infer_method_call("}, {"sha": "4006f595d18eeab0dd0f3414f06727d982f28390", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     FieldId,\n };\n use hir_expand::name::Name;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use super::{BindingMode, Expectation, InferenceContext};\n use crate::{utils::variant_data, Substs, Ty, TypeCtor};\n@@ -111,7 +111,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n         } else if let Pat::Ref { .. } = &body[pat] {\n-            tested_by!(match_ergonomics_ref);\n+            mark::hit!(match_ergonomics_ref);\n             // When you encounter a `&pat` pattern, reset to Move.\n             // This is so that `w` is by value: `let (_, &w) = &(1, &2);`\n             default_bm = BindingMode::Move;"}, {"sha": "1c2e56fb0d822b55c7565dcd14bc56a78c8a287a", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -5,7 +5,7 @@ use std::iter;\n use hir_def::{\n     path::{Path, PathSegment},\n     resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n-    AssocContainerId, AssocItemId, Lookup,\n+    AdtId, AssocContainerId, AssocItemId, EnumVariantId, Lookup,\n };\n use hir_expand::name::Name;\n \n@@ -77,6 +77,18 @@ impl<'a> InferenceContext<'a> {\n \n                 it.into()\n             }\n+            ValueNs::ImplSelf(impl_id) => {\n+                let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n+                let substs = Substs::type_params_for_generics(&generics);\n+                let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n+                if let Some((AdtId::StructId(struct_id), _)) = ty.as_adt() {\n+                    let ty = self.db.value_ty(struct_id.into()).subst(&substs);\n+                    return Some(ty);\n+                } else {\n+                    // FIXME: diagnostic, invalid Self reference\n+                    return None;\n+                }\n+            }\n         };\n \n         let ty = self.db.value_ty(typable);\n@@ -199,6 +211,10 @@ impl<'a> InferenceContext<'a> {\n             return None;\n         }\n \n+        if let Some(result) = self.resolve_enum_variant_on_ty(&ty, name, id) {\n+            return Some(result);\n+        }\n+\n         let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n         let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n@@ -250,4 +266,21 @@ impl<'a> InferenceContext<'a> {\n             },\n         )\n     }\n+\n+    fn resolve_enum_variant_on_ty(\n+        &mut self,\n+        ty: &Ty,\n+        name: &Name,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        let (enum_id, subst) = match ty.as_adt() {\n+            Some((AdtId::EnumId(e), subst)) => (e, subst),\n+            _ => return None,\n+        };\n+        let enum_data = self.db.enum_data(enum_id);\n+        let local_id = enum_data.variant(name)?;\n+        let variant = EnumVariantId { parent: enum_id, local_id };\n+        self.write_variant_resolution(id, variant.into());\n+        Some((ValueNs::EnumVariantId(variant), Some(subst.clone())))\n+    }\n }"}, {"sha": "269495ca0bd25d29008f18a0d7f9855dd95986fe", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,7 +4,7 @@ use std::borrow::Cow;\n \n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use super::{InferenceContext, Obligation};\n use crate::{\n@@ -313,7 +313,7 @@ impl InferenceTable {\n         // more than once\n         for i in 0..3 {\n             if i > 0 {\n-                tested_by!(type_var_resolves_to_int_var);\n+                mark::hit!(type_var_resolves_to_int_var);\n             }\n             match &*ty {\n                 Ty::Infer(tv) => {\n@@ -342,7 +342,7 @@ impl InferenceTable {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_as_possible);\n+                    mark::hit!(type_var_cycles_resolve_as_possible);\n                     // recursive type\n                     return tv.fallback_value();\n                 }\n@@ -369,7 +369,7 @@ impl InferenceTable {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_completely);\n+                    mark::hit!(type_var_cycles_resolve_completely);\n                     // recursive type\n                     return tv.fallback_value();\n                 }"}, {"sha": "c87ee06ce88cb5c6b078de11ba57b1e799a4aea8", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -42,7 +42,6 @@ pub mod expr;\n mod tests;\n #[cfg(test)]\n mod test_db;\n-mod marks;\n mod _match;\n \n use std::ops::Deref;\n@@ -427,6 +426,11 @@ impl Substs {\n     }\n }\n \n+/// Return an index of a parameter in the generic type parameter list by it's id.\n+pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n+    generics(db.upcast(), id.parent).param_idx(id)\n+}\n+\n #[derive(Debug, Clone)]\n pub struct SubstsBuilder {\n     vec: Vec<Ty>,\n@@ -683,6 +687,12 @@ impl Ty {\n     pub fn unit() -> Self {\n         Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n     }\n+    pub fn fn_ptr(sig: FnSig) -> Self {\n+        Ty::apply(\n+            TypeCtor::FnPtr { num_args: sig.params().len() as u16 },\n+            Substs(sig.params_and_return),\n+        )\n+    }\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self {\n@@ -730,6 +740,10 @@ impl Ty {\n         }\n     }\n \n+    pub fn is_never(&self) -> bool {\n+        matches!(self, Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }))\n+    }\n+\n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self {\n@@ -793,15 +807,13 @@ impl Ty {\n         }\n     }\n \n-    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<TraitId> {\n+    /// If this is a `dyn Trait`, returns that trait.\n+    pub fn dyn_trait(&self) -> Option<TraitId> {\n         match self {\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                predicates.iter().find_map(|pred| match pred {\n-                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-                    _ => None,\n-                })\n-            }\n+            Ty::Dyn(predicates) => predicates.iter().find_map(|pred| match pred {\n+                GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                _ => None,\n+            }),\n             _ => None,\n         }\n     }"}, {"sha": "35ac86a461eb0a6ff5cde7483f47642e4a40b821", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -812,7 +812,7 @@ impl TraitEnvironment {\n                 // add `Self: Trait<T1, T2, ...>` to the environment in trait\n                 // function default implementations (and hypothetical code\n                 // inside consts or type aliases)\n-                test_utils::tested_by!(trait_self_implements_self);\n+                test_utils::mark::hit!(trait_self_implements_self);\n                 let substs = Substs::type_params(db, trait_id);\n                 let trait_ref = TraitRef { trait_: trait_id, substs };\n                 let pred = GenericPredicate::Implemented(trait_ref);"}, {"sha": "de5cb1d6bcb8581b76ec4f76f2d8ea560934812a", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,11 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks!(\n-    type_var_cycles_resolve_completely\n-    type_var_cycles_resolve_as_possible\n-    type_var_resolves_to_int_var\n-    impl_self_type_match_without_receiver\n-    match_ergonomics_ref\n-    coerce_merge_fail_fallback\n-    trait_self_implements_self\n-);"}, {"sha": "e19628fdf728a772dbea5231dd2a9fe068a733c9", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -408,8 +408,9 @@ fn iterate_trait_method_candidates<T>(\n     receiver_ty: Option<&Canonical<Ty>>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait = self_ty.value.inherent_trait().into_iter();\n+    // if ty is `dyn Trait`, the trait doesn't need to be in scope\n+    let inherent_trait =\n+        self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n     let env_traits = if let Ty::Placeholder(_) = self_ty.value {\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         env.trait_predicates_for_self_ty(&self_ty.value)\n@@ -468,7 +469,7 @@ fn iterate_inherent_methods<T>(\n                 // already happens in `is_valid_candidate` above; if not, we\n                 // check it here\n                 if receiver_ty.is_none() && inherent_impl_substs(db, impl_def, self_ty).is_none() {\n-                    test_utils::tested_by!(impl_self_type_match_without_receiver);\n+                    test_utils::mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n                 if let Some(result) = callback(&self_ty.value, item) {\n@@ -601,11 +602,6 @@ pub fn implements_trait(\n     krate: CrateId,\n     trait_: TraitId,\n ) -> bool {\n-    if ty.value.inherent_trait() == Some(trait_) {\n-        // FIXME this is a bit of a hack, since Chalk should say the same thing\n-        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n-        return true;\n-    }\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n     let solution = db.trait_solve(krate, goal);\n "}, {"sha": "0870874fce6cd0544a9e93794ba8e81e5dfd9365", "filename": "crates/ra_hir_ty/src/op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fop.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -30,7 +30,8 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n         BinaryOp::LogicOp(..) => Ty::simple(TypeCtor::Bool),\n-        BinaryOp::Assignment { op: None } | BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty {\n+        BinaryOp::Assignment { op: None } => lhs_ty,\n+        BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n                 TypeCtor::Int(..)\n                 | TypeCtor::Float(..)"}, {"sha": "1fe05c70c961c02409f2ae349b07db66e2eade25", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -6,6 +6,7 @@ mod patterns;\n mod traits;\n mod method_resolution;\n mod macros;\n+mod display_source_code;\n \n use std::sync::Arc;\n \n@@ -16,7 +17,7 @@ use hir_def::{\n     item_scope::ItemScope,\n     keys,\n     nameres::CrateDefMap,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n+    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n use insta::assert_snapshot;\n@@ -37,6 +38,18 @@ use crate::{\n // update the snapshots.\n \n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, _| ty.display(db).to_string())\n+}\n+\n+fn displayed_source_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, module_id| ty.display_source_code(db, module_id).unwrap())\n+}\n+\n+fn type_at_pos_displayed(\n+    db: &TestDB,\n+    pos: FilePosition,\n+    display_fn: impl FnOnce(&Ty, ModuleId) -> String,\n+) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let fn_def = expr.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n@@ -49,7 +62,7 @@ fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {\n         let infer = db.infer(func.into());\n         let ty = &infer[expr_id];\n-        return ty.display(db).to_string();\n+        return display_fn(ty, module);\n     }\n     panic!(\"Can't find expression\")\n }\n@@ -360,6 +373,33 @@ fn no_such_field_with_feature_flag_diagnostics() {\n     assert_snapshot!(diagnostics, @r###\"\"###);\n }\n \n+#[test]\n+fn no_such_field_enum_with_feature_flag_diagnostics() {\n+    let diagnostics = TestDB::with_files(\n+        r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        enum Foo {\n+            #[cfg(not(feature = \"foo\"))]\n+            Buz,\n+            #[cfg(feature = \"foo\")]\n+            Bar,\n+            Baz\n+        }\n+\n+        fn test_fn(f: Foo) {\n+            match f {\n+                Foo::Bar => {},\n+                Foo::Baz => {},\n+            }\n+        }\n+        \"#,\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"###);\n+}\n+\n #[test]\n fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n     let diagnostics = TestDB::with_files(\n@@ -491,3 +531,21 @@ fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n \n     assert_snapshot!(diagnostics, @\"\");\n }\n+\n+#[test]\n+fn break_outside_of_loop() {\n+    let diagnostics = TestDB::with_files(\n+        r\"\n+        //- /lib.rs\n+        fn foo() {\n+            break;\n+        }\n+        \",\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"break\": break outside of loop\n+    \"###\n+    );\n+}"}, {"sha": "2cc4f4bf964c3168503c0b9af68501b4349b3815", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,6 +1,6 @@\n use super::infer_with_mismatches;\n use insta::assert_snapshot;\n-use test_utils::covers;\n+use test_utils::mark;\n \n // Infer with some common definitions and impls.\n fn infer(source: &str) -> String {\n@@ -339,7 +339,7 @@ fn test(i: i32) {\n \n #[test]\n fn coerce_merge_one_by_one1() {\n-    covers!(coerce_merge_fail_fallback);\n+    mark::check!(coerce_merge_fail_fallback);\n \n     assert_snapshot!(\n         infer(r#\"\n@@ -384,7 +384,7 @@ fn foo() -> u32 {\n }\n \"#, true),\n         @r###\"\n-    17..40 '{     ...own; }': !\n+    17..40 '{     ...own; }': u32\n     23..37 'return unknown': !\n     30..37 'unknown': u32\n     \"###\n@@ -514,7 +514,7 @@ fn foo() {\n     27..103 '{     ...     }': &u32\n     37..82 'if tru...     }': ()\n     40..44 'true': bool\n-    45..82 '{     ...     }': !\n+    45..82 '{     ...     }': ()\n     59..71 'return &1u32': !\n     66..71 '&1u32': &u32\n     67..71 '1u32': u32\n@@ -545,6 +545,48 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_fn_items_in_match_arms() {\n+    mark::check!(coerce_fn_reification);\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+fn foo1(x: u32) -> isize { 1 }\n+fn foo2(x: u32) -> isize { 2 }\n+fn foo3(x: u32) -> isize { 3 }\n+fn test() {\n+    let x = match 1 {\n+        1 => foo1,\n+        2 => foo2,\n+        _ => foo3,\n+    };\n+}\n+\"#, true),\n+        @r###\"\n+    9..10 'x': u32\n+    26..31 '{ 1 }': isize\n+    28..29 '1': isize\n+    40..41 'x': u32\n+    57..62 '{ 2 }': isize\n+    59..60 '2': isize\n+    71..72 'x': u32\n+    88..93 '{ 3 }': isize\n+    90..91 '3': isize\n+    104..193 '{     ...  }; }': ()\n+    114..115 'x': fn(u32) -> isize\n+    118..190 'match ...     }': fn(u32) -> isize\n+    124..125 '1': i32\n+    136..137 '1': i32\n+    136..137 '1': i32\n+    141..145 'foo1': fn foo1(u32) -> isize\n+    155..156 '2': i32\n+    155..156 '2': i32\n+    160..164 'foo2': fn foo2(u32) -> isize\n+    174..175 '_': i32\n+    179..183 'foo3': fn foo3(u32) -> isize\n+    \"###\n+    );\n+}\n+\n #[test]\n fn coerce_closure_to_fn_ptr() {\n     assert_snapshot!("}, {"sha": "4088b1d22d9463bab869d349c9f8d5da62f20bcb", "filename": "crates/ra_hir_ty/src/tests/display_source_code.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -0,0 +1,50 @@\n+use super::displayed_source_at_pos;\n+use crate::test_db::TestDB;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn qualify_path_to_submodule() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+\n+mod foo {\n+    pub struct Foo;\n+}\n+\n+fn bar() {\n+    let foo: foo::Foo = foo::Foo;\n+    foo<|>\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"foo::Foo\", displayed_source_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn omit_default_type_parameters() {\n+    let (db, pos) = TestDB::with_position(\n+        r\"\n+        //- /main.rs\n+        struct Foo<T = u8> { t: T }\n+        fn main() {\n+            let foo = Foo { t: 5 };\n+            foo<|>;\n+        }\n+        \",\n+    );\n+    assert_eq!(\"Foo\", displayed_source_at_pos(&db, pos));\n+\n+    let (db, pos) = TestDB::with_position(\n+        r\"\n+        //- /main.rs\n+        struct Foo<K, T = u8> { k: K, t: T }\n+        fn main() {\n+            let foo = Foo { k: 400, t: 5 };\n+            foo<|>;\n+        }\n+        \",\n+    );\n+    assert_eq!(\"Foo<i32>\", displayed_source_at_pos(&db, pos));\n+}"}, {"sha": "4c6099aa230dc2c9ce49b8fc7b22b0f656f00822", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -197,7 +197,7 @@ fn spam() {\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n-    54..457 '{     ...!(); }': !\n+    54..457 '{     ...!(); }': ()\n     88..109 'spam!(...am!())': {unknown}\n     115..134 'for _ ...!() {}': ()\n     119..120 '_': {unknown}\n@@ -269,7 +269,7 @@ fn test() { S.foo()<|>; }\n }\n \n #[test]\n-fn infer_impl_items_generated_by_macros() {\n+fn infer_assoc_items_generated_by_macros() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -288,7 +288,7 @@ fn test() { S.foo()<|>; }\n }\n \n #[test]\n-fn infer_impl_items_generated_by_macros_chain() {\n+fn infer_assoc_items_generated_by_macros_chain() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -427,6 +427,32 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn infer_local_inner_macros() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+fn test() {\n+    let x = foo::foo!(1);\n+    x<|>;\n+}\n+\n+//- /lib.rs crate:foo\n+#[macro_export(local_inner_macros)]\n+macro_rules! foo {\n+    (1) => { bar!() };\n+}\n+\n+#[macro_export]\n+macro_rules! bar {\n+    () => { 42 }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"i32\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn infer_builtin_macros_line() {\n     assert_snapshot!("}, {"sha": "558a70022dce6ecb39ae37d6b77d498576c43818", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -17,19 +17,20 @@ impl<T> [T] {\n #[lang = \"slice_alloc\"]\n impl<T> [T] {}\n \n-fn test() {\n-    <[_]>::foo(b\"foo\");\n+fn test(x: &[u8]) {\n+    <[_]>::foo(x);\n }\n \"#),\n         @r###\"\n     45..49 'self': &[T]\n     56..79 '{     ...     }': T\n     66..73 'loop {}': !\n     71..73 '{}': ()\n-    133..160 '{     ...o\"); }': ()\n-    139..149 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n-    139..157 '<[_]>:...\"foo\")': u8\n-    150..156 'b\"foo\"': &[u8]\n+    131..132 'x': &[u8]\n+    141..163 '{     ...(x); }': ()\n+    147..157 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n+    147..160 '<[_]>::foo(x)': u8\n+    158..159 'x': &[u8]\n     \"###\n     );\n }\n@@ -983,7 +984,7 @@ fn test() { S2.into()<|>; }\n \n #[test]\n fn method_resolution_overloaded_method() {\n-    test_utils::covers!(impl_self_type_match_without_receiver);\n+    test_utils::mark::check!(impl_self_type_match_without_receiver);\n     let t = type_at(\n         r#\"\n //- main.rs\n@@ -1095,3 +1096,34 @@ fn test() { (S {}).method()<|>; }\n     );\n     assert_eq!(t, \"()\");\n }\n+\n+#[test]\n+fn dyn_trait_super_trait_not_in_scope() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod m {\n+    pub trait SuperTrait {\n+        fn foo(&self) -> u32 { 0 }\n+    }\n+}\n+trait Trait: m::SuperTrait {}\n+\n+struct S;\n+impl m::SuperTrait for S {}\n+impl Trait for S {}\n+\n+fn test(d: &dyn Trait) {\n+    d.foo();\n+}\n+\"#),\n+        @r###\"\n+    52..56 'self': &Self\n+    65..70 '{ 0 }': u32\n+    67..68 '0': u32\n+    177..178 'd': &dyn Trait\n+    192..208 '{     ...o(); }': ()\n+    198..199 'd': &dyn Trait\n+    198..205 'd.foo()': u32\n+    \"###\n+    );\n+}"}, {"sha": "082c472088488f0db3c29a17e777c617457abe65", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "modified", "additions": 176, "deletions": 1, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,4 +1,6 @@\n-use super::type_at;\n+use insta::assert_snapshot;\n+\n+use super::{infer_with_mismatches, type_at};\n \n #[test]\n fn infer_never1() {\n@@ -261,3 +263,176 @@ fn test(a: i32) {\n     );\n     assert_eq!(t, \"f64\");\n }\n+\n+#[test]\n+fn diverging_expression_1() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    let x: u32 = return;\n+}\n+fn test2() {\n+    let x: u32 = { return; };\n+}\n+fn test3() {\n+    let x: u32 = loop {};\n+}\n+fn test4() {\n+    let x: u32 = { loop {} };\n+}\n+fn test5() {\n+    let x: u32 = { if true { loop {}; } else { loop {}; } };\n+}\n+fn test6() {\n+    let x: u32 = { let y: u32 = { loop {}; }; };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..53 '{     ...urn; }': ()\n+    35..36 'x': u32\n+    44..50 'return': !\n+    65..98 '{     ...; }; }': ()\n+    75..76 'x': u32\n+    84..95 '{ return; }': u32\n+    86..92 'return': !\n+    110..139 '{     ... {}; }': ()\n+    120..121 'x': u32\n+    129..136 'loop {}': !\n+    134..136 '{}': ()\n+    151..184 '{     ...} }; }': ()\n+    161..162 'x': u32\n+    170..181 '{ loop {} }': u32\n+    172..179 'loop {}': !\n+    177..179 '{}': ()\n+    196..260 '{     ...} }; }': ()\n+    206..207 'x': u32\n+    215..257 '{ if t...}; } }': u32\n+    217..255 'if tru... {}; }': u32\n+    220..224 'true': bool\n+    225..237 '{ loop {}; }': u32\n+    227..234 'loop {}': !\n+    232..234 '{}': ()\n+    243..255 '{ loop {}; }': u32\n+    245..252 'loop {}': !\n+    250..252 '{}': ()\n+    272..324 '{     ...; }; }': ()\n+    282..283 'x': u32\n+    291..321 '{ let ...; }; }': u32\n+    297..298 'y': u32\n+    306..318 '{ loop {}; }': u32\n+    308..315 'loop {}': !\n+    313..315 '{}': ()\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_2() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop {}; \"foo\" };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..98 '{     ...\" }; }': ()\n+    68..69 'x': u32\n+    77..95 '{ loop...foo\" }': &str\n+    79..86 'loop {}': !\n+    84..86 '{}': ()\n+    88..93 '\"foo\"': &str\n+    77..95: expected u32, got &str\n+    88..93: expected u32, got &str\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_3_break() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop { break; } };\n+}\n+fn test2() {\n+    // should give type mismatch\n+    let x: u32 = { for a in b { break; }; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b { return; }; };\n+}\n+fn test3() {\n+    // should give type mismatch\n+    let x: u32 = { while true { break; }; };\n+    // should give type mismatch as well -- there's an implicit break, even if it's never hit\n+    let x: u32 = { while true {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { while true { return; }; };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..99 '{     ...} }; }': ()\n+    68..69 'x': u32\n+    77..96 '{ loop...k; } }': ()\n+    79..94 'loop { break; }': ()\n+    84..94 '{ break; }': ()\n+    86..91 'break': !\n+    77..96: expected u32, got ()\n+    79..94: expected u32, got ()\n+    111..357 '{     ...; }; }': ()\n+    154..155 'x': u32\n+    163..189 '{ for ...; }; }': ()\n+    165..186 'for a ...eak; }': ()\n+    169..170 'a': {unknown}\n+    174..175 'b': {unknown}\n+    176..186 '{ break; }': ()\n+    178..183 'break': !\n+    240..241 'x': u32\n+    249..267 '{ for ... {}; }': ()\n+    251..264 'for a in b {}': ()\n+    255..256 'a': {unknown}\n+    260..261 'b': {unknown}\n+    262..264 '{}': ()\n+    318..319 'x': u32\n+    327..354 '{ for ...; }; }': ()\n+    329..351 'for a ...urn; }': ()\n+    333..334 'a': {unknown}\n+    338..339 'b': {unknown}\n+    340..351 '{ return; }': ()\n+    342..348 'return': !\n+    163..189: expected u32, got ()\n+    249..267: expected u32, got ()\n+    327..354: expected u32, got ()\n+    369..668 '{     ...; }; }': ()\n+    412..413 'x': u32\n+    421..447 '{ whil...; }; }': ()\n+    423..444 'while ...eak; }': ()\n+    429..433 'true': bool\n+    434..444 '{ break; }': ()\n+    436..441 'break': !\n+    551..552 'x': u32\n+    560..578 '{ whil... {}; }': ()\n+    562..575 'while true {}': ()\n+    568..572 'true': bool\n+    573..575 '{}': ()\n+    629..630 'x': u32\n+    638..665 '{ whil...; }; }': ()\n+    640..662 'while ...urn; }': ()\n+    646..650 'true': bool\n+    651..662 '{ return; }': ()\n+    653..659 'return': !\n+    421..447: expected u32, got ()\n+    560..578: expected u32, got ()\n+    638..665: expected u32, got ()\n+    \"###);\n+}"}, {"sha": "0c5f972a2c6eaa7eeb750be86773887b95f9942b", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,5 +1,5 @@\n use insta::assert_snapshot;\n-use test_utils::covers;\n+use test_utils::mark;\n \n use super::{infer, infer_with_mismatches};\n \n@@ -197,7 +197,7 @@ fn test() {\n \n #[test]\n fn infer_pattern_match_ergonomics_ref() {\n-    covers!(match_ergonomics_ref);\n+    mark::check!(match_ergonomics_ref);\n     assert_snapshot!(\n         infer(r#\"\n fn test() {\n@@ -368,6 +368,45 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn enum_variant_through_self_in_pattern() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum E {\n+    A { x: usize },\n+    B(usize),\n+    C\n+}\n+\n+impl E {\n+    fn test() {\n+        match (loop {}) {\n+            Self::A { x } => { x; },\n+            Self::B(x) => { x; },\n+            Self::C => {},\n+        };\n+    }\n+}\n+\"#),\n+        @r###\"\n+    76..218 '{     ...     }': ()\n+    86..211 'match ...     }': ()\n+    93..100 'loop {}': !\n+    98..100 '{}': ()\n+    116..129 'Self::A { x }': E\n+    126..127 'x': usize\n+    133..139 '{ x; }': ()\n+    135..136 'x': usize\n+    153..163 'Self::B(x)': E\n+    161..162 'x': usize\n+    167..173 '{ x; }': ()\n+    169..170 'x': usize\n+    187..194 'Self::C': E\n+    198..200 '{}': ()\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_generics_in_patterns() {\n     assert_snapshot!("}, {"sha": "1f004bd6301466fc60502b45f84bd43e707f39a5", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 67, "deletions": 8, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,9 +1,10 @@\n use insta::assert_snapshot;\n-use test_utils::covers;\n+use ra_db::fixture::WithFixture;\n+use test_utils::mark;\n \n-use super::infer;\n use crate::test_db::TestDB;\n-use ra_db::fixture::WithFixture;\n+\n+use super::infer;\n \n #[test]\n fn bug_484() {\n@@ -89,8 +90,8 @@ fn quux() {\n \n #[test]\n fn recursive_vars() {\n-    covers!(type_var_cycles_resolve_completely);\n-    covers!(type_var_cycles_resolve_as_possible);\n+    mark::check!(type_var_cycles_resolve_completely);\n+    mark::check!(type_var_cycles_resolve_as_possible);\n     assert_snapshot!(\n         infer(r#\"\n fn test() {\n@@ -112,8 +113,6 @@ fn test() {\n \n #[test]\n fn recursive_vars_2() {\n-    covers!(type_var_cycles_resolve_completely);\n-    covers!(type_var_cycles_resolve_as_possible);\n     assert_snapshot!(\n         infer(r#\"\n fn test() {\n@@ -170,7 +169,7 @@ fn write() {\n \n #[test]\n fn infer_std_crash_2() {\n-    covers!(type_var_resolves_to_int_var);\n+    mark::check!(type_var_resolves_to_int_var);\n     // caused \"equating two type variables, ...\", taken from std\n     assert_snapshot!(\n         infer(r#\"\n@@ -534,6 +533,66 @@ fn foo(b: Bar) {\n     );\n }\n \n+#[test]\n+fn issue_4235_name_conflicts() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct FOO {}\n+static FOO:FOO = FOO {};\n+\n+impl FOO {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let a = &FOO;\n+    a.foo();\n+}\n+\"#), @r###\"\n+    32..38 'FOO {}': FOO\n+    64..68 'self': &FOO\n+    70..72 '{}': ()\n+    86..120 '{     ...o(); }': ()\n+    96..97 'a': &FOO\n+    100..104 '&FOO': &FOO\n+    101..104 'FOO': FOO\n+    110..111 'a': &FOO\n+    110..117 'a.foo()': ()\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn issue_4465_dollar_crate_at_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+pub struct Foo {}\n+pub fn anything<T>() -> T {\n+    loop {}\n+}\n+macro_rules! foo {\n+    () => {{\n+        let r: $crate::Foo = anything();\n+        r\n+    }};\n+}\n+fn main() {\n+    let _a = foo!();\n+}\n+\"#), @r###\"\n+    45..60 '{     loop {} }': T\n+    51..58 'loop {}': !\n+    56..58 '{}': ()\n+    !0..31 '{letr:...g();r}': Foo\n+    !4..5 'r': Foo\n+    !18..26 'anything': fn anything<Foo>() -> Foo\n+    !18..28 'anything()': Foo\n+    !29..30 'r': Foo\n+    164..188 '{     ...!(); }': ()\n+    174..176 '_a': Foo\n+\"###);\n+}\n+\n #[test]\n fn issue_4053_diesel_where_clauses() {\n     assert_snapshot!("}, {"sha": "fd2208af280e8fca4d2891fc00f9bcdb0c4e19fa", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 175, "deletions": 7, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -179,7 +179,7 @@ fn test(a: u32, b: isize, c: !, d: &str) {\n     17..18 'b': isize\n     27..28 'c': !\n     33..34 'd': &str\n-    42..121 '{     ...f32; }': !\n+    42..121 '{     ...f32; }': ()\n     48..49 'a': u32\n     55..56 'b': isize\n     62..63 'c': !\n@@ -414,15 +414,15 @@ fn test() {\n     27..31 '5f32': f32\n     37..41 '5f64': f64\n     47..54 '\"hello\"': &str\n-    60..68 'b\"bytes\"': &[u8]\n+    60..68 'b\"bytes\"': &[u8; _]\n     74..77 ''c'': char\n     83..87 'b'b'': u8\n     93..97 '3.14': f64\n     103..107 '5000': i32\n     113..118 'false': bool\n     124..128 'true': bool\n     134..202 'r#\"   ...    \"#': &str\n-    208..218 'br#\"yolo\"#': &[u8]\n+    208..218 'br#\"yolo\"#': &[u8; _]\n     \"###\n     );\n }\n@@ -575,6 +575,50 @@ impl S {\n     );\n }\n \n+#[test]\n+fn infer_self_as_path() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S1;\n+struct S2(isize);\n+enum E {\n+    V1,\n+    V2(u32),\n+}\n+\n+impl S1 {\n+    fn test() {\n+        Self;\n+    }\n+}\n+impl S2 {\n+    fn test() {\n+        Self(1);\n+    }\n+}\n+impl E {\n+    fn test() {\n+        Self::V1;\n+        Self::V2(1);\n+    }\n+}\n+\"#),\n+        @r###\"\n+    87..108 '{     ...     }': ()\n+    97..101 'Self': S1\n+    135..159 '{     ...     }': ()\n+    145..149 'Self': S2(isize) -> S2\n+    145..152 'Self(1)': S2\n+    150..151 '1': isize\n+    185..231 '{     ...     }': ()\n+    195..203 'Self::V1': E\n+    213..221 'Self::V2': V2(u32) -> E\n+    213..224 'Self::V2(1)': E\n+    222..223 '1': u32\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_binary_op() {\n     assert_snapshot!(\n@@ -935,7 +979,7 @@ fn foo() {\n     29..33 'true': bool\n     34..51 '{     ...     }': i32\n     44..45 '1': i32\n-    57..80 '{     ...     }': !\n+    57..80 '{     ...     }': i32\n     67..73 'return': !\n     90..93 '_x2': i32\n     96..149 'if tru...     }': i32\n@@ -951,7 +995,7 @@ fn foo() {\n     186..190 'true': bool\n     194..195 '3': i32\n     205..206 '_': bool\n-    210..241 '{     ...     }': !\n+    210..241 '{     ...     }': i32\n     224..230 'return': !\n     257..260 '_x4': i32\n     263..320 'match ...     }': i32\n@@ -1687,7 +1731,7 @@ fn foo() -> u32 {\n     17..59 '{     ...; }; }': ()\n     27..28 'x': || -> usize\n     31..56 '|| -> ...n 1; }': || -> usize\n-    43..56 '{ return 1; }': !\n+    43..56 '{ return 1; }': usize\n     45..53 'return 1': !\n     52..53 '1': usize\n     \"###\n@@ -1706,7 +1750,7 @@ fn foo() -> u32 {\n     17..48 '{     ...; }; }': ()\n     27..28 'x': || -> ()\n     31..45 '|| { return; }': || -> ()\n-    34..45 '{ return; }': !\n+    34..45 '{ return; }': ()\n     36..42 'return': !\n     \"###\n     );\n@@ -1755,3 +1799,127 @@ fn main() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn effects_smoke_test() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn main() {\n+    let x = unsafe { 92 };\n+    let y = async { async { () }.await };\n+    let z = try { () };\n+    let t = 'a: { 92 };\n+}\n+\"#),\n+        @r###\"\n+    11..131 '{     ...2 }; }': ()\n+    21..22 'x': i32\n+    32..38 '{ 92 }': i32\n+    34..36 '92': i32\n+    48..49 'y': {unknown}\n+    58..80 '{ asyn...wait }': {unknown}\n+    60..78 'async ....await': {unknown}\n+    66..72 '{ () }': ()\n+    68..70 '()': ()\n+    90..91 'z': {unknown}\n+    94..104 'try { () }': {unknown}\n+    98..104 '{ () }': ()\n+    100..102 '()': ()\n+    114..115 't': i32\n+    122..128 '{ 92 }': i32\n+    124..126 '92': i32\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_generic_from_later_assignment() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    let mut end = None;\n+    loop {\n+        end = Some(true);\n+    }\n+}\n+\"#),\n+        @r###\"\n+    60..130 '{     ...   } }': ()\n+    70..77 'mut end': Option<bool>\n+    80..84 'None': Option<bool>\n+    90..128 'loop {...     }': !\n+    95..128 '{     ...     }': ()\n+    105..108 'end': Option<bool>\n+    105..121 'end = ...(true)': ()\n+    111..115 'Some': Some<bool>(bool) -> Option<bool>\n+    111..121 'Some(true)': Option<bool>\n+    116..120 'true': bool\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_loop_break_with_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    let x = loop {\n+        if false {\n+            break None;\n+        }\n+\n+        break Some(true);\n+    };\n+}\n+\"#),\n+        @r###\"\n+    60..169 '{     ...  }; }': ()\n+    70..71 'x': Option<bool>\n+    74..166 'loop {...     }': Option<bool>\n+    79..166 '{     ...     }': ()\n+    89..133 'if fal...     }': ()\n+    92..97 'false': bool\n+    98..133 '{     ...     }': ()\n+    112..122 'break None': !\n+    118..122 'None': Option<bool>\n+    143..159 'break ...(true)': !\n+    149..153 'Some': Some<bool>(bool) -> Option<bool>\n+    149..159 'Some(true)': Option<bool>\n+    154..158 'true': bool\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_loop_break_without_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    let x = loop {\n+        if false {\n+            break;\n+        }\n+    };\n+}\n+\"#),\n+        @r###\"\n+    60..137 '{     ...  }; }': ()\n+    70..71 'x': ()\n+    74..134 'loop {...     }': ()\n+    79..134 '{     ...     }': ()\n+    89..128 'if fal...     }': ()\n+    92..97 'false': bool\n+    98..128 '{     ...     }': ()\n+    112..117 'break': !\n+    \"###\n+    );\n+}"}, {"sha": "34f4b9039cc3b44a53a15ce8651cbb37af773a86", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 156, "deletions": 22, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,10 +1,11 @@\n use insta::assert_snapshot;\n-\n use ra_db::fixture::WithFixture;\n+use test_utils::mark;\n \n-use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n use crate::test_db::TestDB;\n \n+use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n+\n #[test]\n fn infer_await() {\n     let (db, pos) = TestDB::with_position(\n@@ -301,7 +302,7 @@ fn test() {\n \n #[test]\n fn trait_default_method_self_bound_implements_trait() {\n-    test_utils::covers!(trait_self_implements_self);\n+    mark::check!(trait_self_implements_self);\n     assert_snapshot!(\n         infer(r#\"\n trait Trait {\n@@ -324,7 +325,6 @@ trait Trait {\n \n #[test]\n fn trait_default_method_self_bound_implements_super_trait() {\n-    test_utils::covers!(trait_self_implements_self);\n     assert_snapshot!(\n         infer(r#\"\n trait SuperTrait {\n@@ -1616,6 +1616,138 @@ fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n     );\n }\n \n+#[test]\n+fn fn_ptr_and_item() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang=\"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+trait Foo<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+struct Bar<T>(T);\n+\n+impl<A1, R, F: FnOnce(A1) -> R> Foo<(A1, R)> for Bar<F> {\n+    fn foo(&self) -> (A1, R) {}\n+}\n+\n+enum Opt<T> { None, Some(T) }\n+impl<T> Opt<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Opt<U> {}\n+}\n+\n+fn test() {\n+    let bar: Bar<fn(u8) -> u32>;\n+    bar.foo();\n+\n+    let opt: Opt<u8>;\n+    let f: fn(u8) -> u32;\n+    opt.map(f);\n+}\n+\"#),\n+        @r###\"\n+75..79 'self': Self\n+81..85 'args': Args\n+140..144 'self': &Self\n+244..248 'self': &Bar<F>\n+261..263 '{}': ()\n+347..351 'self': Opt<T>\n+353..354 'f': F\n+369..371 '{}': ()\n+385..501 '{     ...(f); }': ()\n+395..398 'bar': Bar<fn(u8) -> u32>\n+424..427 'bar': Bar<fn(u8) -> u32>\n+424..433 'bar.foo()': {unknown}\n+444..447 'opt': Opt<u8>\n+466..467 'f': fn(u8) -> u32\n+488..491 'opt': Opt<u8>\n+488..498 'opt.map(f)': Opt<FnOnce::Output<fn(u8) -> u32, (u8,)>>\n+496..497 'f': fn(u8) -> u32\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn fn_trait_deref_with_ty_default() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang=\"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) -> usize {}\n+}\n+\n+struct Lazy<T, F = fn() -> T>(F);\n+\n+impl<T, F> Lazy<T, F> {\n+    pub fn new(f: F) -> Lazy<T, F> {}\n+}\n+\n+impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n+    type Target = T;\n+}\n+\n+fn test() {\n+    let lazy1: Lazy<Foo, _> = Lazy::new(|| Foo);\n+    let r1 = lazy1.foo();\n+\n+    fn make_foo_fn() -> Foo {}\n+    let make_foo_fn_ptr: fn() -> Foo = make_foo_fn;\n+    let lazy2: Lazy<Foo, _> = Lazy::new(make_foo_fn_ptr);\n+    let r2 = lazy2.foo();\n+}\n+\"#),\n+        @r###\"\n+65..69 'self': &Self\n+166..170 'self': Self\n+172..176 'args': Args\n+240..244 'self': &Foo\n+255..257 '{}': ()\n+335..336 'f': F\n+355..357 '{}': ()\n+444..690 '{     ...o(); }': ()\n+454..459 'lazy1': Lazy<Foo, fn() -> T>\n+476..485 'Lazy::new': fn new<Foo, fn() -> T>(fn() -> T) -> Lazy<Foo, fn() -> T>\n+476..493 'Lazy::...| Foo)': Lazy<Foo, fn() -> T>\n+486..492 '|| Foo': || -> T\n+489..492 'Foo': Foo\n+503..505 'r1': {unknown}\n+508..513 'lazy1': Lazy<Foo, fn() -> T>\n+508..519 'lazy1.foo()': {unknown}\n+561..576 'make_foo_fn_ptr': fn() -> Foo\n+592..603 'make_foo_fn': fn make_foo_fn() -> Foo\n+613..618 'lazy2': Lazy<Foo, fn() -> T>\n+635..644 'Lazy::new': fn new<Foo, fn() -> T>(fn() -> T) -> Lazy<Foo, fn() -> T>\n+635..661 'Lazy::...n_ptr)': Lazy<Foo, fn() -> T>\n+645..660 'make_foo_fn_ptr': fn() -> Foo\n+671..673 'r2': {unknown}\n+676..681 'lazy2': Lazy<Foo, fn() -> T>\n+676..687 'lazy2.foo()': {unknown}\n+550..552 '{}': ()\n+\"###\n+    );\n+}\n+\n #[test]\n fn closure_1() {\n     assert_snapshot!(\n@@ -2055,7 +2187,7 @@ fn test<I: Iterator<Item: Iterator<Item = u32>>>() {\n #[test]\n fn proc_macro_server_types() {\n     assert_snapshot!(\n-        infer_with_mismatches(r#\"\n+        infer(r#\"\n macro_rules! with_api {\n     ($S:ident, $self:ident, $m:ident) => {\n         $m! {\n@@ -2069,9 +2201,9 @@ macro_rules! with_api {\n }\n macro_rules! associated_item {\n     (type TokenStream) =>\n-        (type TokenStream: 'static + Clone;);\n+        (type TokenStream: 'static;);\n     (type Group) =>\n-        (type Group: 'static + Clone;);\n+        (type Group: 'static;);\n     ($($item:tt)*) => ($($item)*;)\n }\n macro_rules! declare_server_traits {\n@@ -2083,39 +2215,41 @@ macro_rules! declare_server_traits {\n         }\n \n         $(pub trait $name: Types {\n-            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+            $(associated_item!(fn $method($($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n         })*\n \n         pub trait Server: Types $(+ $name)* {}\n         impl<S: Types $(+ $name)*> Server for S {}\n     }\n }\n+\n with_api!(Self, self_, declare_server_traits);\n-struct Group {}\n-struct TokenStream {}\n+struct G {}\n+struct T {}\n struct Rustc;\n impl Types for Rustc {\n-    type TokenStream = TokenStream;\n-    type Group = Group;\n+    type TokenStream = T;\n+    type Group = G;\n }\n+\n fn make<T>() -> T { loop {} }\n impl TokenStream for Rustc {\n     fn new() -> Self::TokenStream {\n         let group: Self::Group = make();\n         make()\n     }\n }\n-\"#, true),\n+\"#),\n         @r###\"\n-    1115..1126 '{ loop {} }': T\n-    1117..1124 'loop {}': !\n-    1122..1124 '{}': ()\n-    1190..1253 '{     ...     }': {unknown}\n-    1204..1209 'group': {unknown}\n-    1225..1229 'make': fn make<{unknown}>() -> {unknown}\n-    1225..1231 'make()': {unknown}\n-    1241..1245 'make': fn make<{unknown}>() -> {unknown}\n-    1241..1247 'make()': {unknown}\n+    1062..1073 '{ loop {} }': T\n+    1064..1071 'loop {}': !\n+    1069..1071 '{}': ()\n+    1137..1200 '{     ...     }': T\n+    1151..1156 'group': G\n+    1172..1176 'make': fn make<G>() -> G\n+    1172..1178 'make()': G\n+    1188..1192 'make': fn make<T>() -> T\n+    1188..1194 'make()': T\n     \"###\n     );\n }"}, {"sha": "5870618a00a7e68ef0728e9f1e8fdd3663f27540", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -182,7 +182,10 @@ impl chalk_ir::interner::Interner for Interner {\n         Arc::new(goal)\n     }\n \n-    fn intern_goals(&self, data: impl IntoIterator<Item = Goal<Self>>) -> Self::InternedGoals {\n+    fn intern_goals<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<Goal<Self>, E>>,\n+    ) -> Result<Self::InternedGoals, E> {\n         data.into_iter().collect()\n     }\n \n@@ -222,10 +225,10 @@ impl chalk_ir::interner::Interner for Interner {\n         clause\n     }\n \n-    fn intern_program_clauses(\n+    fn intern_program_clauses<E>(\n         &self,\n-        data: impl IntoIterator<Item = chalk_ir::ProgramClause<Self>>,\n-    ) -> Arc<[chalk_ir::ProgramClause<Self>]> {\n+        data: impl IntoIterator<Item = Result<chalk_ir::ProgramClause<Self>, E>>,\n+    ) -> Result<Arc<[chalk_ir::ProgramClause<Self>]>, E> {\n         data.into_iter().collect()\n     }\n \n@@ -236,10 +239,10 @@ impl chalk_ir::interner::Interner for Interner {\n         &clauses\n     }\n \n-    fn intern_quantified_where_clauses(\n+    fn intern_quantified_where_clauses<E>(\n         &self,\n-        data: impl IntoIterator<Item = chalk_ir::QuantifiedWhereClause<Self>>,\n-    ) -> Self::InternedQuantifiedWhereClauses {\n+        data: impl IntoIterator<Item = Result<chalk_ir::QuantifiedWhereClause<Self>, E>>,\n+    ) -> Result<Self::InternedQuantifiedWhereClauses, E> {\n         data.into_iter().collect()\n     }\n \n@@ -250,10 +253,10 @@ impl chalk_ir::interner::Interner for Interner {\n         clauses\n     }\n \n-    fn intern_parameter_kinds(\n+    fn intern_parameter_kinds<E>(\n         &self,\n-        data: impl IntoIterator<Item = chalk_ir::ParameterKind<()>>,\n-    ) -> Self::InternedParameterKinds {\n+        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<()>, E>>,\n+    ) -> Result<Self::InternedParameterKinds, E> {\n         data.into_iter().collect()\n     }\n \n@@ -264,10 +267,10 @@ impl chalk_ir::interner::Interner for Interner {\n         &parameter_kinds\n     }\n \n-    fn intern_canonical_var_kinds(\n+    fn intern_canonical_var_kinds<E>(\n         &self,\n-        data: impl IntoIterator<Item = chalk_ir::ParameterKind<UniverseIndex>>,\n-    ) -> Self::InternedCanonicalVarKinds {\n+        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<UniverseIndex>, E>>,\n+    ) -> Result<Self::InternedCanonicalVarKinds, E> {\n         data.into_iter().collect()\n     }\n \n@@ -460,6 +463,14 @@ impl ToChalk for TypeCtor {\n             TypeName::Struct(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n             TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n             TypeName::OpaqueType(_) => unreachable!(),\n+\n+            TypeName::Scalar(_) => unreachable!(),\n+            TypeName::Tuple(_) => unreachable!(),\n+            TypeName::Raw(_) => unreachable!(),\n+            TypeName::Slice => unreachable!(),\n+            TypeName::Ref(_) => unreachable!(),\n+            TypeName::Str => unreachable!(),\n+\n             TypeName::Error => {\n                 // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n                 unreachable!()\n@@ -862,12 +873,6 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // We don't do coherence checking (yet)\n         unimplemented!()\n     }\n-    fn as_struct_id(&self, id: &TypeName<Interner>) -> Option<StructId> {\n-        match id {\n-            TypeName::Struct(struct_id) => Some(*struct_id),\n-            _ => None,\n-        }\n-    }\n     fn interner(&self) -> &Interner {\n         &Interner\n     }\n@@ -892,6 +897,20 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     ) -> Arc<chalk_rust_ir::OpaqueTyDatum<Interner>> {\n         unimplemented!()\n     }\n+\n+    fn force_impl_for(\n+        &self,\n+        _well_known: chalk_rust_ir::WellKnownTrait,\n+        _ty: &chalk_ir::TyData<Interner>,\n+    ) -> Option<bool> {\n+        // this method is mostly for rustc\n+        None\n+    }\n+\n+    fn is_object_safe(&self, _trait_id: chalk_ir::TraitId<Interner>) -> bool {\n+        // FIXME: implement actual object safety\n+        true\n+    }\n }\n \n pub(crate) fn program_clauses_for_chalk_env_query("}, {"sha": "2b5d11681af79fe725f86bc89411a4ab505b3264", "filename": "crates/ra_ide/src/assists.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,47 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use ra_assists::{resolved_assists, AssistAction, AssistLabel};\n-use ra_db::{FilePosition, FileRange};\n-use ra_ide_db::RootDatabase;\n-\n-use crate::{FileId, SourceChange, SourceFileEdit};\n-\n-pub use ra_assists::AssistId;\n-\n-#[derive(Debug)]\n-pub struct Assist {\n-    pub id: AssistId,\n-    pub label: String,\n-    pub group_label: Option<String>,\n-    pub source_change: SourceChange,\n-}\n-\n-pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<Assist> {\n-    resolved_assists(db, frange)\n-        .into_iter()\n-        .map(|assist| {\n-            let file_id = frange.file_id;\n-            let assist_label = &assist.label;\n-            Assist {\n-                id: assist_label.id,\n-                label: assist_label.label.clone(),\n-                group_label: assist.group_label.map(|it| it.0),\n-                source_change: action_to_edit(assist.action, file_id, assist_label),\n-            }\n-        })\n-        .collect()\n-}\n-\n-fn action_to_edit(\n-    action: AssistAction,\n-    file_id: FileId,\n-    assist_label: &AssistLabel,\n-) -> SourceChange {\n-    let file_id = match action.file {\n-        ra_assists::AssistFile::TargetFile(it) => it,\n-        _ => file_id,\n-    };\n-    let file_edit = SourceFileEdit { file_id, edit: action.edit };\n-    SourceChange::source_file_edit(assist_label.label.clone(), file_edit)\n-        .with_cursor_opt(action.cursor_position.map(|offset| FilePosition { offset, file_id }))\n-}"}, {"sha": "aa039e6fcdb23ce06ac024df338da684440764c5", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     ast::{self, ArgListOwner},\n     match_ast, AstNode, SyntaxNode, SyntaxToken,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{CallInfo, FilePosition, FunctionSignature};\n \n@@ -84,7 +84,7 @@ fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Op\n \n                 let arg_list_range = arg_list.syntax().text_range();\n                 if !arg_list_range.contains_inclusive(token.text_range().start()) {\n-                    tested_by!(call_info_bad_offset);\n+                    mark::hit!(call_info_bad_offset);\n                     return None;\n                 }\n \n@@ -213,7 +213,7 @@ impl CallInfo {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::mock_analysis::single_file_with_position;\n \n@@ -529,7 +529,7 @@ By default this method stops actor's `Context`.\"#\n \n     #[test]\n     fn call_info_bad_offset() {\n-        covers!(call_info_bad_offset);\n+        mark::check!(call_info_bad_offset);\n         let (analysis, position) = single_file_with_position(\n             r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n                fn bar() { foo <|> (3, ); }\"#,"}, {"sha": "191300704b5531ac1ea396ac110ab777c4907373", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -59,13 +59,13 @@ pub use crate::completion::{\n /// with ordering of completions (currently this is done by the client).\n pub(crate) fn completions(\n     db: &RootDatabase,\n-    position: FilePosition,\n     config: &CompletionConfig,\n+    position: FilePosition,\n ) -> Option<Completions> {\n     let ctx = CompletionContext::new(db, position, config)?;\n \n     let mut acc = Completions::default();\n-\n+    complete_attribute::complete_attribute(&mut acc, &ctx);\n     complete_fn_param::complete_fn_param(&mut acc, &ctx);\n     complete_keyword::complete_expr_keyword(&mut acc, &ctx);\n     complete_keyword::complete_use_tree_keyword(&mut acc, &ctx);\n@@ -79,7 +79,6 @@ pub(crate) fn completions(\n     complete_postfix::complete_postfix(&mut acc, &ctx);\n     complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n     complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n-    complete_attribute::complete_attribute(&mut acc, &ctx);\n \n     Some(acc)\n }"}, {"sha": "f17266221fd637a458cd134c246544970d0ac736", "filename": "crates/ra_ide/src/completion/complete_attribute.rs", "status": "modified", "additions": 284, "deletions": 16, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,25 +3,29 @@\n //! This module uses a bit of static metadata to provide completions\n //! for built-in attributes.\n \n-use super::completion_context::CompletionContext;\n-use super::completion_item::{CompletionItem, CompletionItemKind, CompletionKind, Completions};\n-use ra_syntax::{\n-    ast::{Attr, AttrKind},\n-    AstNode,\n+use ra_syntax::{ast, AstNode, SyntaxKind};\n+use rustc_hash::FxHashSet;\n+\n+use crate::completion::{\n+    completion_context::CompletionContext,\n+    completion_item::{CompletionItem, CompletionItemKind, CompletionKind, Completions},\n };\n \n-pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_attribute {\n-        return;\n-    }\n+pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    let attribute = ctx.attribute_under_caret.as_ref()?;\n \n-    let is_inner = ctx\n-        .original_token\n-        .ancestors()\n-        .find_map(Attr::cast)\n-        .map(|attr| attr.kind() == AttrKind::Inner)\n-        .unwrap_or(false);\n+    match (attribute.path(), attribute.input()) {\n+        (Some(path), Some(ast::AttrInput::TokenTree(token_tree)))\n+            if path.to_string() == \"derive\" =>\n+        {\n+            complete_derive(acc, ctx, token_tree)\n+        }\n+        _ => complete_attribute_start(acc, ctx, attribute),\n+    }\n+    Some(())\n+}\n \n+fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n     for attr_completion in ATTRIBUTES {\n         let mut item = CompletionItem::new(\n             CompletionKind::Attribute,\n@@ -37,7 +41,7 @@ pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n             _ => {}\n         }\n \n-        if is_inner || !attr_completion.should_be_inner {\n+        if attribute.kind() == ast::AttrKind::Inner || !attr_completion.should_be_inner {\n             acc.add(item);\n         }\n     }\n@@ -126,6 +130,106 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     },\n ];\n \n+fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, derive_input: ast::TokenTree) {\n+    if let Ok(existing_derives) = parse_derive_input(derive_input) {\n+        for derive_completion in DEFAULT_DERIVE_COMPLETIONS\n+            .into_iter()\n+            .filter(|completion| !existing_derives.contains(completion.label))\n+        {\n+            let mut label = derive_completion.label.to_owned();\n+            for dependency in derive_completion\n+                .dependencies\n+                .into_iter()\n+                .filter(|&&dependency| !existing_derives.contains(dependency))\n+            {\n+                label.push_str(\", \");\n+                label.push_str(dependency);\n+            }\n+            acc.add(\n+                CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label)\n+                    .kind(CompletionItemKind::Attribute),\n+            );\n+        }\n+\n+        for custom_derive_name in get_derive_names_in_scope(ctx).difference(&existing_derives) {\n+            acc.add(\n+                CompletionItem::new(\n+                    CompletionKind::Attribute,\n+                    ctx.source_range(),\n+                    custom_derive_name,\n+                )\n+                .kind(CompletionItemKind::Attribute),\n+            );\n+        }\n+    }\n+}\n+\n+fn parse_derive_input(derive_input: ast::TokenTree) -> Result<FxHashSet<String>, ()> {\n+    match (derive_input.left_delimiter_token(), derive_input.right_delimiter_token()) {\n+        (Some(left_paren), Some(right_paren))\n+            if left_paren.kind() == SyntaxKind::L_PAREN\n+                && right_paren.kind() == SyntaxKind::R_PAREN =>\n+        {\n+            let mut input_derives = FxHashSet::default();\n+            let mut current_derive = String::new();\n+            for token in derive_input\n+                .syntax()\n+                .children_with_tokens()\n+                .filter_map(|token| token.into_token())\n+                .skip_while(|token| token != &left_paren)\n+                .skip(1)\n+                .take_while(|token| token != &right_paren)\n+            {\n+                if SyntaxKind::COMMA == token.kind() {\n+                    if !current_derive.is_empty() {\n+                        input_derives.insert(current_derive);\n+                        current_derive = String::new();\n+                    }\n+                } else {\n+                    current_derive.push_str(token.to_string().trim());\n+                }\n+            }\n+\n+            if !current_derive.is_empty() {\n+                input_derives.insert(current_derive);\n+            }\n+            Ok(input_derives)\n+        }\n+        _ => Err(()),\n+    }\n+}\n+\n+fn get_derive_names_in_scope(ctx: &CompletionContext) -> FxHashSet<String> {\n+    let mut result = FxHashSet::default();\n+    ctx.scope().process_all_names(&mut |name, scope_def| {\n+        if let hir::ScopeDef::MacroDef(mac) = scope_def {\n+            if mac.is_derive_macro() {\n+                result.insert(name.to_string());\n+            }\n+        }\n+    });\n+    result\n+}\n+\n+struct DeriveCompletion {\n+    label: &'static str,\n+    dependencies: &'static [&'static str],\n+}\n+\n+/// Standard Rust derives and the information about their dependencies\n+/// (the dependencies are needed so that the main derive don't break the compilation when added)\n+const DEFAULT_DERIVE_COMPLETIONS: &[DeriveCompletion] = &[\n+    DeriveCompletion { label: \"Clone\", dependencies: &[] },\n+    DeriveCompletion { label: \"Copy\", dependencies: &[\"Clone\"] },\n+    DeriveCompletion { label: \"Debug\", dependencies: &[] },\n+    DeriveCompletion { label: \"Default\", dependencies: &[] },\n+    DeriveCompletion { label: \"Hash\", dependencies: &[] },\n+    DeriveCompletion { label: \"PartialEq\", dependencies: &[] },\n+    DeriveCompletion { label: \"Eq\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"PartialOrd\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"Ord\", dependencies: &[\"PartialOrd\", \"Eq\", \"PartialEq\"] },\n+];\n+\n #[cfg(test)]\n mod tests {\n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n@@ -135,6 +239,170 @@ mod tests {\n         do_completion(code, CompletionKind::Attribute)\n     }\n \n+    #[test]\n+    fn empty_derive_completion() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                    r\"\n+                    #[derive(<|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Clone\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Copy, Clone\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Copy, Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Debug\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Debug\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Default\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Default\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Eq, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Eq, PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Hash\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Hash\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Ord, PartialOrd, Eq, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Ord, PartialOrd, Eq, PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialOrd, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"PartialOrd, PartialEq\",\n+                kind: Attribute,\n+            },\n+        ]\n+            \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn no_completion_for_incorrect_derive() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                r\"\n+                    #[derive{<|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @\"[]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn derive_with_input_completion() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                    r\"\n+                    #[derive(serde::Serialize, PartialEq, <|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Clone\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Copy, Clone\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Copy, Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Debug\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Debug\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Default\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Default\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Eq\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Eq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Hash\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Hash\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Ord, PartialOrd, Eq\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"Ord, PartialOrd, Eq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialOrd\",\n+                source_range: 59..59,\n+                delete: 59..59,\n+                insert: \"PartialOrd\",\n+                kind: Attribute,\n+            },\n+        ]\n+            \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_attribute_completion() {\n         assert_debug_snapshot!("}, {"sha": "f2a52a407a973d3aecbb0433afdb473de417405b", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 244, "deletions": 12, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     },\n     CompletionItem,\n };\n+use ra_assists::utils::TryEnum;\n \n pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_postfix_completions {\n@@ -37,8 +38,53 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(it) => it,\n         None => return,\n     };\n+    let try_enum = TryEnum::from_ty(&ctx.sema, &receiver_ty);\n+    if let Some(try_enum) = &try_enum {\n+        match try_enum {\n+            TryEnum::Result => {\n+                postfix_snippet(\n+                    ctx,\n+                    cap,\n+                    &dot_receiver,\n+                    \"ifl\",\n+                    \"if let Ok {}\",\n+                    &format!(\"if let Ok($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                )\n+                .add_to(acc);\n \n-    if receiver_ty.is_bool() || receiver_ty.is_unknown() {\n+                postfix_snippet(\n+                    ctx,\n+                    cap,\n+                    &dot_receiver,\n+                    \"while\",\n+                    \"while let Ok {}\",\n+                    &format!(\"while let Ok($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                )\n+                .add_to(acc);\n+            }\n+            TryEnum::Option => {\n+                postfix_snippet(\n+                    ctx,\n+                    cap,\n+                    &dot_receiver,\n+                    \"ifl\",\n+                    \"if let Some {}\",\n+                    &format!(\"if let Some($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                )\n+                .add_to(acc);\n+\n+                postfix_snippet(\n+                    ctx,\n+                    cap,\n+                    &dot_receiver,\n+                    \"while\",\n+                    \"while let Some {}\",\n+                    &format!(\"while let Some($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                )\n+                .add_to(acc);\n+            }\n+        }\n+    } else if receiver_ty.is_bool() || receiver_ty.is_unknown() {\n         postfix_snippet(\n             ctx,\n             cap,\n@@ -58,7 +104,6 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         )\n         .add_to(acc);\n     }\n-\n     // !&&&42 is a compiler error, ergo process it before considering the references\n     postfix_snippet(ctx, cap, &dot_receiver, \"not\", \"!expr\", &format!(\"!{}\", receiver_text))\n         .add_to(acc);\n@@ -80,16 +125,45 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     let dot_receiver = include_references(dot_receiver);\n     let receiver_text =\n         get_receiver_text(&dot_receiver, ctx.dot_receiver_is_ambiguous_float_literal);\n-\n-    postfix_snippet(\n-        ctx,\n-        cap,\n-        &dot_receiver,\n-        \"match\",\n-        \"match expr {}\",\n-        &format!(\"match {} {{\\n    ${{1:_}} => {{$0\\\\}},\\n}}\", receiver_text),\n-    )\n-    .add_to(acc);\n+    match try_enum {\n+        Some(try_enum) => {\n+            match try_enum {\n+                TryEnum::Result => {\n+                    postfix_snippet(\n+                    ctx,\n+                    cap,\n+                    &dot_receiver,\n+                    \"match\",\n+                    \"match expr {}\",\n+                    &format!(\"match {} {{\\n    Ok(${{1:_}}) => {{$2\\\\}},\\n    Err(${{3:_}}) => {{$0\\\\}},\\n}}\", receiver_text),\n+                )\n+                .add_to(acc);\n+                }\n+                TryEnum::Option => {\n+                    postfix_snippet(\n+                    ctx,\n+                    cap,\n+                    &dot_receiver,\n+                    \"match\",\n+                    \"match expr {}\",\n+                    &format!(\"match {} {{\\n    Some(${{1:_}}) => {{$2\\\\}},\\n    None => {{$0\\\\}},\\n}}\", receiver_text),\n+                )\n+                .add_to(acc);\n+                }\n+            }\n+        }\n+        None => {\n+            postfix_snippet(\n+                ctx,\n+                cap,\n+                &dot_receiver,\n+                \"match\",\n+                \"match expr {}\",\n+                &format!(\"match {} {{\\n    ${{1:_}} => {{$0\\\\}},\\n}}\", receiver_text),\n+            )\n+            .add_to(acc);\n+        }\n+    }\n \n     postfix_snippet(\n         ctx,\n@@ -235,6 +309,164 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn postfix_completion_works_for_option() {\n+        assert_debug_snapshot!(\n+            do_postfix_completion(\n+                r#\"\n+                enum Option<T> {\n+                    Some(T),\n+                    None,\n+                }\n+\n+                fn main() {\n+                    let bar = Option::Some(true);\n+                    bar.<|>\n+                }\n+                \"#,\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"box\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"Box::new(bar)\",\n+                detail: \"Box::new(expr)\",\n+            },\n+            CompletionItem {\n+                label: \"dbg\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"dbg!(bar)\",\n+                detail: \"dbg!(expr)\",\n+            },\n+            CompletionItem {\n+                label: \"ifl\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"if let Some($1) = bar {\\n    $0\\n}\",\n+                detail: \"if let Some {}\",\n+            },\n+            CompletionItem {\n+                label: \"match\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"match bar {\\n    Some(${1:_}) => {$2\\\\},\\n    None => {$0\\\\},\\n}\",\n+                detail: \"match expr {}\",\n+            },\n+            CompletionItem {\n+                label: \"not\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"!bar\",\n+                detail: \"!expr\",\n+            },\n+            CompletionItem {\n+                label: \"ref\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"&bar\",\n+                detail: \"&expr\",\n+            },\n+            CompletionItem {\n+                label: \"refm\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"&mut bar\",\n+                detail: \"&mut expr\",\n+            },\n+            CompletionItem {\n+                label: \"while\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"while let Some($1) = bar {\\n    $0\\n}\",\n+                detail: \"while let Some {}\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn postfix_completion_works_for_result() {\n+        assert_debug_snapshot!(\n+            do_postfix_completion(\n+                r#\"\n+                enum Result<T, E> {\n+                    Ok(T),\n+                    Err(E),\n+                }\n+\n+                fn main() {\n+                    let bar = Result::Ok(true);\n+                    bar.<|>\n+                }\n+                \"#,\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"box\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"Box::new(bar)\",\n+                detail: \"Box::new(expr)\",\n+            },\n+            CompletionItem {\n+                label: \"dbg\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"dbg!(bar)\",\n+                detail: \"dbg!(expr)\",\n+            },\n+            CompletionItem {\n+                label: \"ifl\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"if let Ok($1) = bar {\\n    $0\\n}\",\n+                detail: \"if let Ok {}\",\n+            },\n+            CompletionItem {\n+                label: \"match\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"match bar {\\n    Ok(${1:_}) => {$2\\\\},\\n    Err(${3:_}) => {$0\\\\},\\n}\",\n+                detail: \"match expr {}\",\n+            },\n+            CompletionItem {\n+                label: \"not\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"!bar\",\n+                detail: \"!expr\",\n+            },\n+            CompletionItem {\n+                label: \"ref\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"&bar\",\n+                detail: \"&expr\",\n+            },\n+            CompletionItem {\n+                label: \"refm\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"&mut bar\",\n+                detail: \"&mut expr\",\n+            },\n+            CompletionItem {\n+                label: \"while\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"while let Ok($1) = bar {\\n    $0\\n}\",\n+                detail: \"while let Ok {}\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn some_postfix_completions_ignored() {\n         assert_debug_snapshot!("}, {"sha": "02ac0166b6e12ee9c016045648151d66555f4d65", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -2,20 +2,25 @@\n \n use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n use ra_syntax::AstNode;\n-use test_utils::tested_by;\n+use rustc_hash::FxHashSet;\n+use test_utils::mark;\n \n use crate::completion::{CompletionContext, Completions};\n-use rustc_hash::FxHashSet;\n \n pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let path = match &ctx.path_prefix {\n         Some(path) => path.clone(),\n-        _ => return,\n+        None => return,\n     };\n+\n+    if ctx.attribute_under_caret.is_some() {\n+        return;\n+    }\n+\n     let scope = ctx.scope();\n     let context_module = scope.module();\n \n-    let res = match scope.resolve_hir_path(&path) {\n+    let res = match scope.resolve_hir_path_qualifier(&path) {\n         Some(res) => res,\n         None => return,\n     };\n@@ -35,7 +40,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                         if let Some(name_ref) = ctx.name_ref_syntax.as_ref() {\n                             if name_ref.syntax().text() == name.to_string().as_str() {\n                                 // for `use self::foo<|>`, don't suggest `foo` as a completion\n-                                tested_by!(dont_complete_current_use);\n+                                mark::hit!(dont_complete_current_use);\n                                 continue;\n                             }\n                         }\n@@ -79,7 +84,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 });\n \n                 // Iterate assoc types separately\n-                ty.iterate_impl_items(ctx.db, krate, |item| {\n+                ty.iterate_assoc_items(ctx.db, krate, |item| {\n                     if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n                         return None;\n                     }\n@@ -142,7 +147,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n     use insta::assert_debug_snapshot;\n@@ -153,7 +158,7 @@ mod tests {\n \n     #[test]\n     fn dont_complete_current_use() {\n-        covers!(dont_complete_current_use);\n+        mark::check!(dont_complete_current_use);\n         let completions = do_completion(r\"use self::foo<|>;\", CompletionKind::Reference);\n         assert!(completions.is_empty());\n     }\n@@ -220,6 +225,34 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_mod_with_same_name_as_function() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                use self::my::<|>;\n+\n+                mod my {\n+                    pub struct Bar;\n+                }\n+\n+                fn my() {}\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Bar\",\n+                source_range: 31..31,\n+                delete: 31..31,\n+                insert: \"Bar\",\n+                kind: Struct,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn path_visibility() {\n         assert_debug_snapshot!(\n@@ -1325,4 +1358,18 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn dont_complete_attr() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                mod foo { pub struct Foo; }\n+                #[foo::<|>]\n+                fn f() {}\n+                \"\n+            ),\n+            @r###\"[]\"###\n+        )\n+    }\n }"}, {"sha": "0568d9ccf3951000f7f9f1bb016519485b2b1231", "filename": "crates/ra_ide/src/completion/complete_snippet.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -33,6 +33,24 @@ pub(super) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionConte\n         None => return,\n     };\n \n+    snippet(\n+        ctx,\n+        cap,\n+        \"Test module\",\n+        \"\\\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn ${1:test_name}() {\n+        $0\n+    }\n+}\",\n+    )\n+    .lookup_by(\"tmod\")\n+    .add_to(acc);\n+\n     snippet(\n         ctx,\n         cap,\n@@ -117,6 +135,14 @@ mod tests {\n                 kind: Snippet,\n                 lookup: \"tfn\",\n             },\n+            CompletionItem {\n+                label: \"Test module\",\n+                source_range: 78..78,\n+                delete: 78..78,\n+                insert: \"#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn ${1:test_name}() {\\n        $0\\n    }\\n}\",\n+                kind: Snippet,\n+                lookup: \"tmod\",\n+            },\n             CompletionItem {\n                 label: \"macro_rules\",\n                 source_range: 78..78,"}, {"sha": "039df03e0547b3816d2a732e69deb788647f5a96", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -32,7 +32,7 @@\n //! ```\n \n use hir::{self, Docs, HasSource};\n-use ra_assists::utils::get_missing_impl_items;\n+use ra_assists::utils::get_missing_assoc_items;\n use ra_syntax::{\n     ast::{self, edit, ImplDef},\n     AstNode, SyntaxKind, SyntaxNode, TextRange, T,\n@@ -50,7 +50,7 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n     if let Some((trigger, impl_def)) = completion_match(ctx) {\n         match trigger.kind() {\n             SyntaxKind::NAME_REF => {\n-                get_missing_impl_items(&ctx.sema, &impl_def).iter().for_each(|item| match item {\n+                get_missing_assoc_items(&ctx.sema, &impl_def).iter().for_each(|item| match item {\n                     hir::AssocItem::Function(fn_item) => {\n                         add_function_impl(&trigger, acc, ctx, &fn_item)\n                     }\n@@ -64,34 +64,40 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n             }\n \n             SyntaxKind::FN_DEF => {\n-                for missing_fn in get_missing_impl_items(&ctx.sema, &impl_def).iter().filter_map(\n-                    |item| match item {\n-                        hir::AssocItem::Function(fn_item) => Some(fn_item),\n-                        _ => None,\n-                    },\n-                ) {\n+                for missing_fn in\n+                    get_missing_assoc_items(&ctx.sema, &impl_def).iter().filter_map(|item| {\n+                        match item {\n+                            hir::AssocItem::Function(fn_item) => Some(fn_item),\n+                            _ => None,\n+                        }\n+                    })\n+                {\n                     add_function_impl(&trigger, acc, ctx, &missing_fn);\n                 }\n             }\n \n             SyntaxKind::TYPE_ALIAS_DEF => {\n-                for missing_fn in get_missing_impl_items(&ctx.sema, &impl_def).iter().filter_map(\n-                    |item| match item {\n-                        hir::AssocItem::TypeAlias(type_item) => Some(type_item),\n-                        _ => None,\n-                    },\n-                ) {\n+                for missing_fn in\n+                    get_missing_assoc_items(&ctx.sema, &impl_def).iter().filter_map(|item| {\n+                        match item {\n+                            hir::AssocItem::TypeAlias(type_item) => Some(type_item),\n+                            _ => None,\n+                        }\n+                    })\n+                {\n                     add_type_alias_impl(&trigger, acc, ctx, &missing_fn);\n                 }\n             }\n \n             SyntaxKind::CONST_DEF => {\n-                for missing_fn in get_missing_impl_items(&ctx.sema, &impl_def).iter().filter_map(\n-                    |item| match item {\n-                        hir::AssocItem::Const(const_item) => Some(const_item),\n-                        _ => None,\n-                    },\n-                ) {\n+                for missing_fn in\n+                    get_missing_assoc_items(&ctx.sema, &impl_def).iter().filter_map(|item| {\n+                        match item {\n+                            hir::AssocItem::Const(const_item) => Some(const_item),\n+                            _ => None,\n+                        }\n+                    })\n+                {\n                     add_const_impl(&trigger, acc, ctx, &missing_fn);\n                 }\n             }"}, {"sha": "db791660a18a756727200f7aca1b57896de82f11", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,16 +1,19 @@\n //! Completion of names from the current scope, e.g. locals and imported items.\n \n use hir::ScopeDef;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::completion::{CompletionContext, Completions};\n use hir::{Adt, ModuleDef, Type};\n use ra_syntax::AstNode;\n \n pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    if (!ctx.is_trivial_path && !ctx.is_pat_binding_or_const)\n-        || ctx.record_lit_syntax.is_some()\n+    if !(ctx.is_trivial_path || ctx.is_pat_binding_or_const) {\n+        return;\n+    }\n+    if ctx.record_lit_syntax.is_some()\n         || ctx.record_pat_syntax.is_some()\n+        || ctx.attribute_under_caret.is_some()\n     {\n         return;\n     }\n@@ -27,7 +30,7 @@ pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         if ctx.use_item_syntax.is_some() {\n             if let (ScopeDef::Unknown, Some(name_ref)) = (&res, &ctx.name_ref_syntax) {\n                 if name_ref.syntax().text() == name.to_string().as_str() {\n-                    tested_by!(self_fulfilling_completion);\n+                    mark::hit!(self_fulfilling_completion);\n                     return;\n                 }\n             }\n@@ -63,7 +66,7 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n \n@@ -73,7 +76,7 @@ mod tests {\n \n     #[test]\n     fn self_fulfilling_completion() {\n-        covers!(self_fulfilling_completion);\n+        mark::check!(self_fulfilling_completion);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r#\"\n@@ -1369,4 +1372,18 @@ mod tests {\n         \"###\n         )\n     }\n+\n+    #[test]\n+    fn dont_complete_attr() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                struct Foo;\n+                #[<|>]\n+                fn f() {}\n+                \"\n+            ),\n+            @r###\"[]\"###\n+        )\n+    }\n }"}, {"sha": "da336973c1801a35cb08c02bce6a298496056d35", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n-use ra_text_edit::AtomTextEdit;\n+use ra_text_edit::Indel;\n \n use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n \n@@ -34,7 +34,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) record_pat_syntax: Option<ast::RecordPat>,\n     pub(super) record_field_syntax: Option<ast::RecordField>,\n     pub(super) impl_def: Option<ast::ImplDef>,\n-    /// FIXME: `ActiveParameter` is string-based, which is very wrong\n+    /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n@@ -58,7 +58,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_macro_call: bool,\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n-    pub(super) is_attribute: bool,\n+    pub(super) attribute_under_caret: Option<ast::Attr>,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -76,7 +76,7 @@ impl<'a> CompletionContext<'a> {\n         // actual completion.\n         let file_with_fake_ident = {\n             let parse = db.parse(position.file_id);\n-            let edit = AtomTextEdit::insert(position.offset, \"intellijRulezz\".to_string());\n+            let edit = Indel::insert(position.offset, \"intellijRulezz\".to_string());\n             parse.reparse(&edit).tree()\n         };\n         let fake_ident_token =\n@@ -116,7 +116,7 @@ impl<'a> CompletionContext<'a> {\n             is_path_type: false,\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n-            is_attribute: false,\n+            attribute_under_caret: None,\n         };\n \n         let mut original_file = original_file.syntax().clone();\n@@ -200,6 +200,7 @@ impl<'a> CompletionContext<'a> {\n                 Some(ty)\n             })\n             .flatten();\n+        self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n \n         // First, let's try to complete a reference to some declaration.\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&file_with_fake_ident, offset) {\n@@ -318,7 +319,6 @@ impl<'a> CompletionContext<'a> {\n                 .and_then(|it| it.syntax().parent().and_then(ast::CallExpr::cast))\n                 .is_some();\n             self.is_macro_call = path.syntax().parent().and_then(ast::MacroCall::cast).is_some();\n-            self.is_attribute = path.syntax().parent().and_then(ast::Attr::cast).is_some();\n \n             self.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n             self.has_type_args = segment.type_arg_list().is_some();\n@@ -344,7 +344,7 @@ impl<'a> CompletionContext<'a> {\n                                 stmt.syntax().text_range() == name_ref.syntax().text_range(),\n                             );\n                         }\n-                        if let Some(block) = ast::Block::cast(node) {\n+                        if let Some(block) = ast::BlockExpr::cast(node) {\n                             return Some(\n                                 block.expr().map(|e| e.syntax().text_range())\n                                     == Some(name_ref.syntax().text_range()),"}, {"sha": "cfb7c1e380b6b51e7b66b46bfe4d6438efae3cfc", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -2,11 +2,12 @@\n \n use std::fmt;\n \n-use super::completion_config::SnippetCap;\n use hir::Documentation;\n use ra_syntax::TextRange;\n use ra_text_edit::TextEdit;\n \n+use crate::completion::completion_config::SnippetCap;\n+\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n@@ -62,8 +63,8 @@ impl fmt::Debug for CompletionItem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut s = f.debug_struct(\"CompletionItem\");\n         s.field(\"label\", &self.label()).field(\"source_range\", &self.source_range());\n-        if self.text_edit().as_atoms().len() == 1 {\n-            let atom = &self.text_edit().as_atoms()[0];\n+        if self.text_edit().len() == 1 {\n+            let atom = &self.text_edit().iter().next().unwrap();\n             s.field(\"delete\", &atom.delete);\n             s.field(\"insert\", &atom.insert);\n         } else {"}, {"sha": "440ffa31d4e0c9db6a10a0ee1b4c4d6c6e619294", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 66, "deletions": 16, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -3,7 +3,7 @@\n use hir::{Docs, HasAttrs, HasSource, HirDisplay, ModPath, ScopeDef, StructKind, Type};\n use ra_syntax::ast::NameOwner;\n use stdx::SepBy;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     completion::{\n@@ -17,12 +17,11 @@ use crate::{\n impl Completions {\n     pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &Type) {\n         let is_deprecated = is_deprecated(field, ctx.db);\n-        let ty = ty.display(ctx.db).to_string();\n         let name = field.name(ctx.db);\n         let mut completion_item =\n             CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n                 .kind(CompletionItemKind::Field)\n-                .detail(ty.clone())\n+                .detail(ty.display(ctx.db).to_string())\n                 .set_documentation(field.docs(ctx.db))\n                 .set_deprecated(is_deprecated);\n \n@@ -107,6 +106,12 @@ impl Completions {\n             }\n         };\n \n+        if let ScopeDef::Local(local) = resolution {\n+            if let Some(score) = compute_score(ctx, &local.ty(ctx.db), &local_name) {\n+                completion_item = completion_item.set_score(score);\n+            }\n+        }\n+\n         // Add `<>` for generic types\n         if ctx.is_path_type && !ctx.has_type_args && ctx.config.add_call_parenthesis {\n             if let Some(cap) = ctx.config.snippet_cap {\n@@ -116,7 +121,7 @@ impl Completions {\n                     _ => false,\n                 };\n                 if has_non_default_type_params {\n-                    tested_by!(inserts_angle_brackets_for_generics);\n+                    mark::hit!(inserts_angle_brackets_for_generics);\n                     completion_item = completion_item\n                         .lookup_by(local_name.clone())\n                         .label(format!(\"{}<\u2026>\", local_name))\n@@ -171,7 +176,7 @@ impl Completions {\n             }\n             None if needs_bang => builder.insert_text(format!(\"{}!\", name)),\n             _ => {\n-                tested_by!(dont_insert_macro_call_parens_unncessary);\n+                mark::hit!(dont_insert_macro_call_parens_unncessary);\n                 builder.insert_text(name)\n             }\n         };\n@@ -319,19 +324,20 @@ impl Completions {\n \n pub(crate) fn compute_score(\n     ctx: &CompletionContext,\n-    // FIXME: this definitely should be a `Type`\n-    ty: &str,\n+    ty: &Type,\n     name: &str,\n ) -> Option<CompletionScore> {\n+    // FIXME: this should not fall back to string equality.\n+    let ty = &ty.display(ctx.db).to_string();\n     let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n-        tested_by!(test_struct_field_completion_in_record_lit);\n+        mark::hit!(test_struct_field_completion_in_record_lit);\n         let (struct_field, _local) = ctx.sema.resolve_record_field(record_field)?;\n         (\n             struct_field.name(ctx.db).to_string(),\n             struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n         )\n     } else if let Some(active_parameter) = &ctx.active_parameter {\n-        tested_by!(test_struct_field_completion_in_func_call);\n+        mark::hit!(test_struct_field_completion_in_func_call);\n         (active_parameter.name.clone(), active_parameter.ty.clone())\n     } else {\n         return None;\n@@ -392,7 +398,7 @@ impl Builder {\n             None => return self,\n         };\n         // If not an import, add parenthesis automatically.\n-        tested_by!(inserts_parens_for_function_calls);\n+        mark::hit!(inserts_parens_for_function_calls);\n \n         let (snippet, label) = if params.is_empty() {\n             (format!(\"{}()$0\", name), format!(\"{}()\", name))\n@@ -451,7 +457,7 @@ fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static s\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::completion::{\n         test_utils::{do_completion, do_completion_with_options},\n@@ -601,7 +607,7 @@ mod tests {\n \n     #[test]\n     fn inserts_parens_for_function_calls() {\n-        covers!(inserts_parens_for_function_calls);\n+        mark::check!(inserts_parens_for_function_calls);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r\"\n@@ -986,7 +992,7 @@ mod tests {\n \n     #[test]\n     fn inserts_angle_brackets_for_generics() {\n-        covers!(inserts_angle_brackets_for_generics);\n+        mark::check!(inserts_angle_brackets_for_generics);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r\"\n@@ -1109,7 +1115,7 @@ mod tests {\n \n     #[test]\n     fn dont_insert_macro_call_parens_unncessary() {\n-        covers!(dont_insert_macro_call_parens_unncessary);\n+        mark::check!(dont_insert_macro_call_parens_unncessary);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r\"\n@@ -1175,7 +1181,7 @@ mod tests {\n \n     #[test]\n     fn test_struct_field_completion_in_func_call() {\n-        covers!(test_struct_field_completion_in_func_call);\n+        mark::check!(test_struct_field_completion_in_func_call);\n         assert_debug_snapshot!(\n         do_reference_completion(\n                 r\"\n@@ -1265,7 +1271,7 @@ mod tests {\n \n     #[test]\n     fn test_struct_field_completion_in_record_lit() {\n-        covers!(test_struct_field_completion_in_record_lit);\n+        mark::check!(test_struct_field_completion_in_record_lit);\n         assert_debug_snapshot!(\n         do_reference_completion(\n                 r\"\n@@ -1405,4 +1411,48 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn prioritize_exact_ref_match() {\n+        assert_debug_snapshot!(\n+        do_reference_completion(\n+                r\"\n+                    struct WorldSnapshot { _f: () };\n+                    fn go(world: &WorldSnapshot) {\n+                        go(w<|>)\n+                    }\n+                    \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"WorldSnapshot\",\n+                source_range: 132..133,\n+                delete: 132..133,\n+                insert: \"WorldSnapshot\",\n+                kind: Struct,\n+            },\n+            CompletionItem {\n+                label: \"go(\u2026)\",\n+                source_range: 132..133,\n+                delete: 132..133,\n+                insert: \"go(${1:world})$0\",\n+                kind: Function,\n+                lookup: \"go\",\n+                detail: \"fn go(world: &WorldSnapshot)\",\n+                trigger_call_info: true,\n+            },\n+            CompletionItem {\n+                label: \"world\",\n+                source_range: 132..133,\n+                delete: 132..133,\n+                insert: \"world\",\n+                kind: Binding,\n+                detail: \"&WorldSnapshot\",\n+                score: TypeAndNameMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "bf22452a281c76cf798aad520d97064151bf5fb3", "filename": "crates/ra_ide/src/completion/test_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -20,7 +20,7 @@ pub(crate) fn do_completion_with_options(\n     } else {\n         single_file_with_position(code)\n     };\n-    let completions = analysis.completions(position, options).unwrap().unwrap();\n+    let completions = analysis.completions(options, position).unwrap().unwrap();\n     let completion_items: Vec<CompletionItem> = completions.into();\n     let mut kind_completions: Vec<CompletionItem> =\n         completion_items.into_iter().filter(|c| c.completion_kind == kind).collect();"}, {"sha": "c2819bbf7b807f769d6eb0482c00f18ed76c67c0", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             .unwrap_or_else(|| RelativePath::new(\"\"))\n             .join(&d.candidate);\n         let create_file = FileSystemEdit::CreateFile { source_root, path };\n-        let fix = SourceChange::file_system_edit(\"create module\", create_file);\n+        let fix = SourceChange::file_system_edit(\"Create module\", create_file);\n         res.borrow_mut().push(Diagnostic {\n             range: sema.diagnostics_range(d).range,\n             message: d.message(),\n@@ -92,7 +92,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             algo::diff(&d.ast(db).syntax(), &field_list.syntax()).into_text_edit(&mut builder);\n \n             Some(SourceChange::source_file_edit_from(\n-                \"fill struct fields\",\n+                \"Fill struct fields\",\n                 file_id,\n                 builder.finish(),\n             ))\n@@ -117,7 +117,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         let node = d.ast(db);\n         let replacement = format!(\"Ok({})\", node.syntax());\n         let edit = TextEdit::replace(node.syntax().text_range(), replacement);\n-        let fix = SourceChange::source_file_edit_from(\"wrap with ok\", file_id, edit);\n+        let fix = SourceChange::source_file_edit_from(\"Wrap with ok\", file_id, edit);\n         res.borrow_mut().push(Diagnostic {\n             range: sema.diagnostics_range(d).range,\n             message: d.message(),\n@@ -199,7 +199,7 @@ fn check_struct_shorthand_initialization(\n                     message: \"Shorthand struct initialization\".to_string(),\n                     severity: Severity::WeakWarning,\n                     fix: Some(SourceChange::source_file_edit(\n-                        \"use struct shorthand initialization\",\n+                        \"Use struct shorthand initialization\",\n                         SourceFileEdit { file_id, edit },\n                     )),\n                 });\n@@ -241,7 +241,11 @@ mod tests {\n             diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_file_edits.pop().unwrap().edit;\n-        let actual = edit.apply(&before);\n+        let actual = {\n+            let mut actual = before.to_string();\n+            edit.apply(&mut actual);\n+            actual\n+        };\n         assert_eq_text!(after, &actual);\n     }\n \n@@ -256,7 +260,11 @@ mod tests {\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_file_edits.pop().unwrap().edit;\n         let target_file_contents = analysis.file_text(file_position.file_id).unwrap();\n-        let actual = edit.apply(&target_file_contents);\n+        let actual = {\n+            let mut actual = target_file_contents.to_string();\n+            edit.apply(&mut actual);\n+            actual\n+        };\n \n         // Strip indent and empty lines from `after`, to match the behaviour of\n         // `parse_fixture` called from `analysis_and_position`.\n@@ -288,7 +296,11 @@ mod tests {\n         let diagnostic = analysis.diagnostics(file_id).unwrap().pop().unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_file_edits.pop().unwrap().edit;\n-        let actual = edit.apply(&before);\n+        let actual = {\n+            let mut actual = before.to_string();\n+            edit.apply(&mut actual);\n+            actual\n+        };\n         assert_eq_text!(after, &actual);\n     }\n \n@@ -606,7 +618,7 @@ mod tests {\n                 range: 0..8,\n                 fix: Some(\n                     SourceChange {\n-                        label: \"create module\",\n+                        label: \"Create module\",\n                         source_file_edits: [],\n                         file_system_edits: [\n                             CreateFile {\n@@ -616,7 +628,7 @@ mod tests {\n                                 path: \"foo.rs\",\n                             },\n                         ],\n-                        cursor_position: None,\n+                        is_snippet: false,\n                     },\n                 ),\n                 severity: Error,\n@@ -655,24 +667,24 @@ mod tests {\n                 range: 224..233,\n                 fix: Some(\n                     SourceChange {\n-                        label: \"fill struct fields\",\n+                        label: \"Fill struct fields\",\n                         source_file_edits: [\n                             SourceFileEdit {\n                                 file_id: FileId(\n                                     1,\n                                 ),\n                                 edit: TextEdit {\n-                                    atoms: [\n-                                        AtomTextEdit {\n-                                            delete: 3..9,\n+                                    indels: [\n+                                        Indel {\n                                             insert: \"{a:42, b: ()}\",\n+                                            delete: 3..9,\n                                         },\n                                     ],\n                                 },\n                             },\n                         ],\n                         file_system_edits: [],\n-                        cursor_position: None,\n+                        is_snippet: false,\n                     },\n                 ),\n                 severity: Error,"}, {"sha": "9572debd822c7983342845a3e7ba763fb92f611c", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,5 +1,7 @@\n //! FIXME: write short doc here\n \n+// FIXME: this modules relies on strings and AST way too much, and it should be\n+// rewritten (matklad 2020-05-07)\n use std::{\n     convert::From,\n     fmt::{self, Display},\n@@ -82,8 +84,8 @@ impl FunctionSignature {\n             let ty = field.signature_ty(db);\n             let raw_param = format!(\"{}\", ty.display(db));\n \n-            if let Some(param_type) = raw_param.split(':').nth(1) {\n-                parameter_types.push(param_type[1..].to_string());\n+            if let Some(param_type) = raw_param.split(':').nth(1).and_then(|it| it.get(1..)) {\n+                parameter_types.push(param_type.to_string());\n             } else {\n                 // useful when you have tuple struct\n                 parameter_types.push(raw_param.clone());\n@@ -127,8 +129,8 @@ impl FunctionSignature {\n         for field in variant.fields(db).into_iter() {\n             let ty = field.signature_ty(db);\n             let raw_param = format!(\"{}\", ty.display(db));\n-            if let Some(param_type) = raw_param.split(':').nth(1) {\n-                parameter_types.push(param_type[1..].to_string());\n+            if let Some(param_type) = raw_param.split(':').nth(1).and_then(|it| it.get(1..)) {\n+                parameter_types.push(param_type.to_string());\n             } else {\n                 // The unwrap_or_else is useful when you have tuple\n                 parameter_types.push(raw_param);\n@@ -195,14 +197,23 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                     let raw_param = self_param.syntax().text().to_string();\n \n                     res_types.push(\n-                        raw_param.split(':').nth(1).unwrap_or_else(|| \" Self\")[1..].to_string(),\n+                        raw_param\n+                            .split(':')\n+                            .nth(1)\n+                            .and_then(|it| it.get(1..))\n+                            .unwrap_or_else(|| \"Self\")\n+                            .to_string(),\n                     );\n                     res.push(raw_param);\n                 }\n \n                 res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n                 res_types.extend(param_list.params().map(|param| {\n-                    param.syntax().text().to_string().split(':').nth(1).unwrap()[1..].to_string()\n+                    let param_text = param.syntax().text().to_string();\n+                    match param_text.split(':').nth(1).and_then(|it| it.get(1..)) {\n+                        Some(it) => it.to_string(),\n+                        None => param_text,\n+                    }\n                 }));\n             }\n             (has_self_param, res, res_types)"}, {"sha": "5da28edd24144396e8a3f73f92706f8873529b33", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::FileSymbol;\n+use crate::{FileRange, FileSymbol};\n \n use super::short_label::ShortLabel;\n \n@@ -22,10 +22,11 @@ use super::short_label::ShortLabel;\n /// code, like a function or a struct, but this is not strictly required.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NavigationTarget {\n+    // FIXME: use FileRange?\n     file_id: FileId,\n+    full_range: TextRange,\n     name: SmolStr,\n     kind: SyntaxKind,\n-    full_range: TextRange,\n     focus_range: Option<TextRange>,\n     container_name: Option<SmolStr>,\n     description: Option<String>,\n@@ -63,6 +64,10 @@ impl NavigationTarget {\n         self.file_id\n     }\n \n+    pub fn file_range(&self) -> FileRange {\n+        FileRange { file_id: self.file_id, range: self.full_range }\n+    }\n+\n     pub fn full_range(&self) -> TextRange {\n         self.full_range\n     }\n@@ -376,16 +381,20 @@ impl ToNav for hir::Local {\n impl ToNav for hir::TypeParam {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n-        let range = match src.value {\n+        let full_range = match &src.value {\n             Either::Left(it) => it.syntax().text_range(),\n             Either::Right(it) => it.syntax().text_range(),\n         };\n+        let focus_range = match &src.value {\n+            Either::Left(_) => None,\n+            Either::Right(it) => it.name().map(|it| it.syntax().text_range()),\n+        };\n         NavigationTarget {\n             file_id: src.file_id.original_file(db),\n             name: self.name(db).to_string().into(),\n             kind: TYPE_PARAM,\n-            full_range: range,\n-            focus_range: None,\n+            full_range,\n+            focus_range,\n             container_name: None,\n             description: None,\n             docs: None,"}, {"sha": "8657377dedaace2d1e3a0021123388ee12b648eb", "filename": "crates/ra_ide/src/folding_ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -88,7 +88,7 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n         | ITEM_LIST\n         | EXTERN_ITEM_LIST\n         | USE_TREE_LIST\n-        | BLOCK\n+        | BLOCK_EXPR\n         | MATCH_ARM_LIST\n         | ENUM_VARIANT_LIST\n         | TOKEN_TREE => Some(FoldKind::Block),"}, {"sha": "90e85d4197126f12f0aba169c477a15b2e2a8978", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -93,7 +93,7 @@ pub(crate) fn reference_definition(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::{assert_eq_text, covers};\n+    use test_utils::assert_eq_text;\n \n     use crate::mock_analysis::analysis_and_position;\n \n@@ -208,7 +208,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_macros() {\n-        covers!(ra_ide_db::goto_def_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -225,7 +224,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_macros_from_other_crates() {\n-        covers!(ra_ide_db::goto_def_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -243,6 +241,38 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn goto_def_for_use_alias() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            use foo as bar<|>;\n+\n+\n+            //- /foo/lib.rs\n+            #[macro_export]\n+            macro_rules! foo { () => { () } }\",\n+            \"SOURCE_FILE FileId(2) 0..50\",\n+            \"#[macro_export]\\nmacro_rules! foo { () => { () } }\\n\",\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_def_for_use_alias_foo_macro() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            use foo::foo as bar<|>;\n+\n+            //- /foo/lib.rs\n+            #[macro_export]\n+            macro_rules! foo { () => { () } }\n+            \",\n+            \"foo MACRO_CALL FileId(2) 0..49 29..32\",\n+            \"#[macro_export]\\nmacro_rules! foo { () => { () } }|foo\",\n+        );\n+    }\n+\n     #[test]\n     fn goto_def_for_macros_in_use_tree() {\n         check_goto(\n@@ -337,7 +367,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_methods() {\n-        covers!(ra_ide_db::goto_def_for_methods);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -357,7 +386,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_fields() {\n-        covers!(ra_ide_db::goto_def_for_fields);\n         check_goto(\n             r\"\n             //- /lib.rs\n@@ -376,7 +404,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_record_fields() {\n-        covers!(ra_ide_db::goto_def_for_record_fields);\n         check_goto(\n             r\"\n             //- /lib.rs\n@@ -397,7 +424,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_record_pat_fields() {\n-        covers!(ra_ide_db::goto_def_for_record_field_pats);\n         check_goto(\n             r\"\n             //- /lib.rs\n@@ -754,14 +780,14 @@ mod tests {\n     #[test]\n     fn goto_for_type_param() {\n         check_goto(\n-            \"\n+            r#\"\n             //- /lib.rs\n-            struct Foo<T> {\n+            struct Foo<T: Clone> {\n                 t: <|>T,\n             }\n-            \",\n-            \"T TYPE_PARAM FileId(1) 11..12\",\n-            \"T\",\n+            \"#,\n+            \"T TYPE_PARAM FileId(1) 11..19 11..12\",\n+            \"T: Clone|T\",\n         );\n     }\n \n@@ -840,7 +866,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_field_init_shorthand() {\n-        covers!(ra_ide_db::goto_def_for_field_init_shorthand);\n         check_goto(\n             \"\n             //- /lib.rs"}, {"sha": "befa977c7fe7ecae4ebd89d7ac7526b08829c500", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -143,7 +143,7 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n             ModuleDef::TypeAlias(it) => from_def_source(db, it, mod_path),\n             ModuleDef::BuiltinType(it) => Some(it.to_string()),\n         },\n-        Definition::Local(it) => Some(rust_code_markup(&it.ty(db).display_truncated(db, None))),\n+        Definition::Local(it) => Some(rust_code_markup(&it.ty(db).display(db))),\n         Definition::TypeParam(_) | Definition::SelfType(_) => {\n             // FIXME: Hover for generic param\n             None\n@@ -208,7 +208,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         }\n     }?;\n \n-    res.extend(Some(rust_code_markup(&ty.display_truncated(db, None))));\n+    res.extend(Some(rust_code_markup(&ty.display(db))));\n     let range = sema.original_range(&node).range;\n     Some(RangeInfo::new(range, res))\n }\n@@ -279,6 +279,47 @@ mod tests {\n         assert_eq!(trim_markup_opt(hover.info.first()), Some(\"u32\"));\n     }\n \n+    #[test]\n+    fn hover_shows_long_type_of_an_expression() {\n+        check_hover_result(\n+            r#\"\n+            //- /main.rs\n+            struct Scan<A, B, C> {\n+                a: A,\n+                b: B,\n+                c: C,\n+            }\n+\n+            struct FakeIter<I> {\n+                inner: I,\n+            }\n+\n+            struct OtherStruct<T> {\n+                i: T,\n+            }\n+\n+            enum FakeOption<T> {\n+                Some(T),\n+                None,\n+            }\n+\n+            fn scan<A, B, C>(a: A, b: B, c: C) -> FakeIter<Scan<OtherStruct<A>, B, C>> {\n+                FakeIter { inner: Scan { a, b, c } }\n+            }\n+\n+            fn main() {\n+                let num: i32 = 55;\n+                let closure = |memo: &mut u32, value: &u32, _another: &mut u32| -> FakeOption<u32> {\n+                    FakeOption::Some(*memo + value)\n+                };\n+                let number = 5u32;\n+                let mut iter<|> = scan(OtherStruct { i: num }, closure, number);\n+            }\n+            \"#,\n+            &[\"FakeIter<Scan<OtherStruct<OtherStruct<i32>>, |&mut u32, &u32, &mut u32| -> FakeOption<u32>, u32>>\"],\n+        );\n+    }\n+\n     #[test]\n     fn hover_shows_fn_signature() {\n         // Single file with result\n@@ -405,7 +446,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn hover_omits_default_generic_types() {\n+    fn hover_default_generic_types() {\n         check_hover_result(\n             r#\"\n //- /main.rs\n@@ -417,7 +458,7 @@ struct Test<K, T = u8> {\n fn main() {\n     let zz<|> = Test { t: 23, k: 33 };\n }\"#,\n-            &[\"Test<i32>\"],\n+            &[\"Test<i32, u8>\"],\n         );\n     }\n \n@@ -880,4 +921,21 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"unsafe trait foo\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_mod_with_same_name_as_function() {\n+        check_hover_result(\n+            \"\n+            //- /lib.rs\n+            use self::m<|>y::Bar;\n+\n+            mod my {\n+                pub struct Bar;\n+            }\n+\n+            fn my() {}\n+            \",\n+            &[\"mod my\"],\n+        );\n+    }\n }"}, {"sha": "b391f903a80a115d2c94ba8194856b399a356acc", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -9,6 +9,7 @@ use ra_syntax::{\n };\n \n use crate::{FileId, FunctionSignature};\n+use stdx::to_lower_snake_case;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct InlayHintsConfig {\n@@ -144,7 +145,7 @@ fn get_param_name_hints(\n         .iter()\n         .skip(n_params_to_skip)\n         .zip(args)\n-        .filter(|(param, arg)| should_show_param_hint(&fn_signature, param, &arg))\n+        .filter(|(param, arg)| should_show_param_name_hint(sema, &fn_signature, param, &arg))\n         .map(|(param_name, arg)| InlayHint {\n             range: arg.syntax().text_range(),\n             kind: InlayKind::ParameterHint,\n@@ -181,7 +182,7 @@ fn get_bind_pat_hints(\n \n fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::BindPat, pat_ty: &Type) -> bool {\n     if let Some(Adt::Enum(enum_data)) = pat_ty.as_adt() {\n-        let pat_text = bind_pat.syntax().to_string();\n+        let pat_text = bind_pat.to_string();\n         enum_data\n             .variants(db)\n             .into_iter()\n@@ -198,7 +199,7 @@ fn should_not_display_type_hint(db: &RootDatabase, bind_pat: &ast::BindPat, pat_\n     }\n \n     if let Some(Adt::Struct(s)) = pat_ty.as_adt() {\n-        if s.fields(db).is_empty() && s.name(db).to_string() == bind_pat.syntax().to_string() {\n+        if s.fields(db).is_empty() && s.name(db).to_string() == bind_pat.to_string() {\n             return true;\n         }\n     }\n@@ -230,15 +231,16 @@ fn should_not_display_type_hint(db: &RootDatabase, bind_pat: &ast::BindPat, pat_\n     false\n }\n \n-fn should_show_param_hint(\n+fn should_show_param_name_hint(\n+    sema: &Semantics<RootDatabase>,\n     fn_signature: &FunctionSignature,\n     param_name: &str,\n     argument: &ast::Expr,\n ) -> bool {\n+    let param_name = param_name.trim_start_matches('_');\n     if param_name.is_empty()\n-        || is_argument_similar_to_param(argument, param_name)\n-        || Some(param_name.trim_start_matches('_'))\n-            == fn_signature.name.as_ref().map(|s| s.trim_start_matches('_'))\n+        || Some(param_name) == fn_signature.name.as_ref().map(|s| s.trim_start_matches('_'))\n+        || is_argument_similar_to_param_name(sema, argument, param_name)\n     {\n         return false;\n     }\n@@ -254,20 +256,42 @@ fn should_show_param_hint(\n     parameters_len != 1 || !is_obvious_param(param_name)\n }\n \n-fn is_argument_similar_to_param(argument: &ast::Expr, param_name: &str) -> bool {\n-    let argument_string = remove_ref(argument.clone()).syntax().to_string();\n-    let param_name = param_name.trim_start_matches('_');\n-    let argument_string = argument_string.trim_start_matches('_');\n-    argument_string.starts_with(&param_name) || argument_string.ends_with(&param_name)\n+fn is_argument_similar_to_param_name(\n+    sema: &Semantics<RootDatabase>,\n+    argument: &ast::Expr,\n+    param_name: &str,\n+) -> bool {\n+    if is_enum_name_similar_to_param_name(sema, argument, param_name) {\n+        return true;\n+    }\n+    match get_string_representation(argument) {\n+        None => false,\n+        Some(repr) => {\n+            let argument_string = repr.trim_start_matches('_');\n+            argument_string.starts_with(param_name) || argument_string.ends_with(param_name)\n+        }\n+    }\n+}\n+\n+fn is_enum_name_similar_to_param_name(\n+    sema: &Semantics<RootDatabase>,\n+    argument: &ast::Expr,\n+    param_name: &str,\n+) -> bool {\n+    match sema.type_of_expr(argument).and_then(|t| t.as_adt()) {\n+        Some(Adt::Enum(e)) => to_lower_snake_case(&e.name(sema.db).to_string()) == param_name,\n+        _ => false,\n+    }\n }\n \n-fn remove_ref(expr: ast::Expr) -> ast::Expr {\n-    if let ast::Expr::RefExpr(ref_expr) = &expr {\n-        if let Some(inner) = ref_expr.expr() {\n-            return inner;\n+fn get_string_representation(expr: &ast::Expr) -> Option<String> {\n+    match expr {\n+        ast::Expr::MethodCallExpr(method_call_expr) => {\n+            Some(method_call_expr.name_ref()?.to_string())\n         }\n+        ast::Expr::RefExpr(ref_expr) => get_string_representation(&ref_expr.expr()?),\n+        _ => Some(expr.to_string()),\n     }\n-    expr\n }\n \n fn is_obvious_param(param_name: &str) -> bool {\n@@ -1073,6 +1097,12 @@ struct TestVarContainer {\n     test_var: i32,\n }\n \n+impl TestVarContainer {\n+    fn test_var(&self) -> i32 {\n+        self.test_var\n+    }\n+}\n+\n struct Test {}\n \n impl Test {\n@@ -1098,10 +1128,15 @@ struct Param {}\n fn different_order(param: &Param) {}\n fn different_order_mut(param: &mut Param) {}\n fn has_underscore(_param: bool) {}\n+fn enum_matches_param_name(completion_kind: CompletionKind) {}\n \n fn twiddle(twiddle: bool) {}\n fn doo(_doo: bool) {}\n \n+enum CompletionKind {\n+    Keyword,\n+}\n+\n fn main() {\n     let container: TestVarContainer = TestVarContainer { test_var: 42 };\n     let test: Test = Test {};\n@@ -1114,18 +1149,21 @@ fn main() {\n     let test_var: i32 = 55;\n     test_processed.no_hints_expected(22, test_var);\n     test_processed.no_hints_expected(33, container.test_var);\n+    test_processed.no_hints_expected(44, container.test_var());\n     test_processed.frob(false);\n \n     twiddle(true);\n     doo(true);\n \n-    let param_begin: Param = Param {};\n+    let mut param_begin: Param = Param {};\n     different_order(&param_begin);\n     different_order(&mut param_begin);\n \n     let param: bool = true;\n     has_underscore(param);\n \n+    enum_matches_param_name(CompletionKind::Keyword);\n+\n     let a: f64 = 7.0;\n     let b: f64 = 4.0;\n     let _: f64 = a.div_euclid(b);"}, {"sha": "af1ade8a1e12d09caf06608c53348a22b5676fef", "filename": "crates/ra_ide/src/join_lines.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -129,8 +129,7 @@ fn has_comma_after(node: &SyntaxNode) -> bool {\n }\n \n fn join_single_expr_block(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n-    let block = ast::Block::cast(token.parent())?;\n-    let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n+    let block_expr = ast::BlockExpr::cast(token.parent())?;\n     if !block_expr.is_standalone() {\n         return None;\n     }\n@@ -167,16 +166,28 @@ fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use crate::test_utils::{assert_eq_text, check_action, extract_range};\n+    use ra_syntax::SourceFile;\n+    use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n     use super::*;\n \n     fn check_join_lines(before: &str, after: &str) {\n-        check_action(before, after, |file, offset| {\n-            let range = TextRange::empty(offset);\n-            let res = join_lines(file, range);\n-            Some(res)\n-        })\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let file = SourceFile::parse(&before).ok().unwrap();\n+\n+        let range = TextRange::empty(before_cursor_pos);\n+        let result = join_lines(&file, range);\n+\n+        let actual = {\n+            let mut actual = before.to_string();\n+            result.apply(&mut actual);\n+            actual\n+        };\n+        let actual_cursor_pos = result\n+            .apply_to_offset(before_cursor_pos)\n+            .expect(\"cursor position is affected by the edit\");\n+        let actual = add_cursor(&actual, actual_cursor_pos);\n+        assert_eq_text!(after, &actual);\n     }\n \n     #[test]\n@@ -570,7 +581,11 @@ fn foo() {\n         let (sel, before) = extract_range(before);\n         let parse = SourceFile::parse(&before);\n         let result = join_lines(&parse.tree(), sel);\n-        let actual = result.apply(&before);\n+        let actual = {\n+            let mut actual = before.to_string();\n+            result.apply(&mut actual);\n+            actual\n+        };\n         assert_eq_text!(after, &actual);\n     }\n "}, {"sha": "97ff67ee891da5ebb689472432f106837757430a", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -16,7 +16,6 @@ macro_rules! eprintln {\n }\n \n pub mod mock_analysis;\n-mod source_change;\n \n mod prime_caches;\n mod status;\n@@ -32,7 +31,6 @@ mod syntax_highlighting;\n mod parent_module;\n mod references;\n mod impls;\n-mod assists;\n mod diagnostics;\n mod syntax_tree;\n mod folding_ranges;\n@@ -44,11 +42,6 @@ mod inlay_hints;\n mod expand_macro;\n mod ssr;\n \n-#[cfg(test)]\n-mod marks;\n-#[cfg(test)]\n-mod test_utils;\n-\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n@@ -65,7 +58,6 @@ use ra_syntax::{SourceFile, TextRange, TextSize};\n use crate::display::ToNav;\n \n pub use crate::{\n-    assists::{Assist, AssistId},\n     call_hierarchy::CallItem,\n     completion::{\n         CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n@@ -78,25 +70,26 @@ pub use crate::{\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n     references::{Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},\n-    source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     ssr::SsrError,\n     syntax_highlighting::{\n         Highlight, HighlightModifier, HighlightModifiers, HighlightTag, HighlightedRange,\n     },\n };\n \n pub use hir::Documentation;\n+pub use ra_assists::{AssistConfig, AssistId};\n pub use ra_db::{\n     Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRootId,\n };\n pub use ra_ide_db::{\n     change::{AnalysisChange, LibraryData},\n     line_index::{LineCol, LineIndex},\n-    line_index_utils::translate_offset_with_edit,\n     search::SearchScope,\n+    source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     symbol_index::Query,\n     RootDatabase,\n };\n+pub use ra_text_edit::{Indel, TextEdit};\n \n pub type Cancelable<T> = Result<T, Canceled>;\n \n@@ -135,10 +128,12 @@ pub struct AnalysisHost {\n     db: RootDatabase,\n }\n \n-impl Default for AnalysisHost {\n-    fn default() -> AnalysisHost {\n-        AnalysisHost::new(None)\n-    }\n+#[derive(Debug)]\n+pub struct Assist {\n+    pub id: AssistId,\n+    pub label: String,\n+    pub group_label: Option<String>,\n+    pub source_change: SourceChange,\n }\n \n impl AnalysisHost {\n@@ -176,18 +171,20 @@ impl AnalysisHost {\n     pub fn request_cancellation(&mut self) {\n         self.db.request_cancellation();\n     }\n-    pub fn raw_database(\n-        &self,\n-    ) -> &(impl hir::db::HirDatabase + salsa::Database + ra_db::SourceDatabaseExt) {\n+    pub fn raw_database(&self) -> &RootDatabase {\n         &self.db\n     }\n-    pub fn raw_database_mut(\n-        &mut self,\n-    ) -> &mut (impl hir::db::HirDatabase + salsa::Database + ra_db::SourceDatabaseExt) {\n+    pub fn raw_database_mut(&mut self) -> &mut RootDatabase {\n         &mut self.db\n     }\n }\n \n+impl Default for AnalysisHost {\n+    fn default() -> AnalysisHost {\n+        AnalysisHost::new(None)\n+    }\n+}\n+\n /// Analysis is a snapshot of a world state at a moment in time. It is the main\n /// entry point for asking semantic information about the world. When the world\n /// state is advanced using `AnalysisHost::apply_change` method, all existing\n@@ -289,14 +286,10 @@ impl Analysis {\n \n     /// Returns an edit to remove all newlines in the range, cleaning up minor\n     /// stuff like trailing commas.\n-    pub fn join_lines(&self, frange: FileRange) -> Cancelable<SourceChange> {\n+    pub fn join_lines(&self, frange: FileRange) -> Cancelable<TextEdit> {\n         self.with_db(|db| {\n             let parse = db.parse(frange.file_id);\n-            let file_edit = SourceFileEdit {\n-                file_id: frange.file_id,\n-                edit: join_lines::join_lines(&parse.tree(), frange.range),\n-            };\n-            SourceChange::source_file_edit(\"join lines\", file_edit)\n+            join_lines::join_lines(&parse.tree(), frange.range)\n         })\n     }\n \n@@ -456,16 +449,26 @@ impl Analysis {\n     /// Computes completions at the given position.\n     pub fn completions(\n         &self,\n-        position: FilePosition,\n         config: &CompletionConfig,\n+        position: FilePosition,\n     ) -> Cancelable<Option<Vec<CompletionItem>>> {\n-        self.with_db(|db| completion::completions(db, position, config).map(Into::into))\n+        self.with_db(|db| completion::completions(db, config, position).map(Into::into))\n     }\n \n     /// Computes assists (aka code actions aka intentions) for the given\n     /// position.\n-    pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<Assist>> {\n-        self.with_db(|db| assists::assists(db, frange))\n+    pub fn assists(&self, config: &AssistConfig, frange: FileRange) -> Cancelable<Vec<Assist>> {\n+        self.with_db(|db| {\n+            ra_assists::Assist::resolved(db, config, frange)\n+                .into_iter()\n+                .map(|assist| Assist {\n+                    id: assist.assist.id,\n+                    label: assist.assist.label,\n+                    group_label: assist.assist.group.map(|it| it.0),\n+                    source_change: assist.source_change,\n+                })\n+                .collect()\n+        })\n     }\n \n     /// Computes the set of diagnostics for the given file.\n@@ -490,7 +493,7 @@ impl Analysis {\n     ) -> Cancelable<Result<SourceChange, SsrError>> {\n         self.with_db(|db| {\n             let edits = ssr::parse_search_replace(query, parse_only, db)?;\n-            Ok(SourceChange::source_file_edits(\"ssr\", edits))\n+            Ok(SourceChange::source_file_edits(\"Structural Search Replace\", edits))\n         })\n     }\n "}, {"sha": "bea30fe2af55d53d33d907b392f064127b7dac78", "filename": "crates/ra_ide/src/marks.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=db926218b2082077750291f8426ddd28b284cd08", "patch": "@@ -1,14 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks!(\n-    inserts_angle_brackets_for_generics\n-    inserts_parens_for_function_calls\n-    call_info_bad_offset\n-    dont_complete_current_use\n-    test_resolve_parent_module_on_module_decl\n-    search_filters_by_range\n-    dont_insert_macro_call_parens_unncessary\n-    self_fulfilling_completion\n-    test_struct_field_completion_in_func_call\n-    test_struct_field_completion_in_record_lit\n-);"}, {"sha": "a083fb1eb35890f0cd460357b3b13c6b7b3bdda7", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstNode},\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::NavigationTarget;\n \n@@ -25,7 +25,7 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n             .item_list()\n             .map_or(false, |it| it.syntax().text_range().contains_inclusive(position.offset))\n         {\n-            tested_by!(test_resolve_parent_module_on_module_decl);\n+            mark::hit!(test_resolve_parent_module_on_module_decl);\n             module = m.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n         }\n     }\n@@ -57,7 +57,7 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n mod tests {\n     use ra_cfg::CfgOptions;\n     use ra_db::Env;\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::{\n         mock_analysis::{analysis_and_position, MockAnalysis},\n@@ -81,7 +81,7 @@ mod tests {\n \n     #[test]\n     fn test_resolve_parent_module_on_module_decl() {\n-        covers!(test_resolve_parent_module_on_module_decl);\n+        mark::check!(test_resolve_parent_module_on_module_decl);\n         let (analysis, pos) = analysis_and_position(\n             \"\n             //- /lib.rs"}, {"sha": "96444bf6a52d2f8a72767d4deb322dc924d084ac", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -190,8 +190,6 @@ fn get_struct_def_name_for_struct_literal_search(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n-\n     use crate::{\n         mock_analysis::{analysis_and_position, single_file_with_position, MockAnalysis},\n         Declaration, Reference, ReferenceSearchResult, SearchScope,\n@@ -301,7 +299,6 @@ mod tests {\n \n     #[test]\n     fn search_filters_by_range() {\n-        covers!(ra_ide_db::search_filters_by_range);\n         let code = r#\"\n             fn foo() {\n                 let spam<|> = 92;\n@@ -593,6 +590,31 @@ mod tests {\n         check_result(refs, \"i BIND_PAT FileId(1) 36..37 Other\", &[\"FileId(1) 51..52 Other Write\"]);\n     }\n \n+    #[test]\n+    fn test_find_struct_function_refs_outside_module() {\n+        let code = r#\"\n+        mod foo {\n+            pub struct Foo;\n+\n+            impl Foo {\n+                pub fn new<|>() -> Foo {\n+                    Foo\n+                }\n+            }\n+        }\n+\n+        fn main() {\n+            let _f = foo::Foo::new();\n+        }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"new FN_DEF FileId(1) 87..150 94..97 Other\",\n+            &[\"FileId(1) 227..230 StructLiteral\"],\n+        );\n+    }\n+\n     fn get_all_refs(text: &str) -> ReferenceSearchResult {\n         let (analysis, position) = single_file_with_position(text);\n         analysis.find_all_refs(position, None).unwrap().unwrap()"}, {"sha": "fd2163dad66300e637b2b5a8afd3022d7ddff784", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 299, "deletions": 33, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -4,35 +4,40 @@ use hir::{ModuleSource, Semantics};\n use ra_db::{RelativePath, RelativePathBuf, SourceDatabaseExt};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    algo::find_node_at_offset, ast, lex_single_valid_syntax_kind, AstNode, SyntaxKind, SyntaxNode,\n+    algo::find_node_at_offset, ast, ast::TypeAscriptionOwner, lex_single_valid_syntax_kind,\n+    AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n use ra_text_edit::TextEdit;\n+use std::convert::TryInto;\n+use test_utils::mark;\n \n use crate::{\n-    FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind, SourceChange,\n-    SourceFileEdit, TextRange,\n+    references::find_all_refs, FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind,\n+    SourceChange, SourceFileEdit, TextRange, TextSize,\n };\n \n-use super::find_all_refs;\n-\n pub(crate) fn rename(\n     db: &RootDatabase,\n     position: FilePosition,\n     new_name: &str,\n ) -> Option<RangeInfo<SourceChange>> {\n     match lex_single_valid_syntax_kind(new_name)? {\n         SyntaxKind::IDENT | SyntaxKind::UNDERSCORE => (),\n+        SyntaxKind::SELF_KW => return rename_to_self(db, position),\n         _ => return None,\n     }\n \n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n-    if let Some((ast_name, ast_module)) =\n-        find_name_and_module_at_offset(source_file.syntax(), position)\n-    {\n+    let syntax = source_file.syntax();\n+    if let Some((ast_name, ast_module)) = find_name_and_module_at_offset(syntax, position) {\n         let range = ast_name.syntax().text_range();\n         rename_mod(&sema, &ast_name, &ast_module, position, new_name)\n             .map(|info| RangeInfo::new(range, info))\n+    } else if let Some(self_token) =\n+        syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+    {\n+        rename_self_to_param(db, position, self_token, new_name)\n     } else {\n         rename_reference(sema.db, position, new_name)\n     }\n@@ -52,11 +57,13 @@ fn source_edit_from_reference(reference: Reference, new_name: &str) -> SourceFil\n     let file_id = reference.file_range.file_id;\n     let range = match reference.kind {\n         ReferenceKind::FieldShorthandForField => {\n+            mark::hit!(test_rename_struct_field_for_shorthand);\n             replacement_text.push_str(new_name);\n             replacement_text.push_str(\": \");\n             TextRange::new(reference.file_range.range.start(), reference.file_range.range.start())\n         }\n         ReferenceKind::FieldShorthandForLocal => {\n+            mark::hit!(test_rename_local_for_field_shorthand);\n             replacement_text.push_str(\": \");\n             replacement_text.push_str(new_name);\n             TextRange::new(reference.file_range.range.end(), reference.file_range.range.end())\n@@ -121,7 +128,113 @@ fn rename_mod(\n         source_file_edits.extend(ref_edits);\n     }\n \n-    Some(SourceChange::from_edits(\"rename\", source_file_edits, file_system_edits))\n+    Some(SourceChange::from_edits(\"Rename\", source_file_edits, file_system_edits))\n+}\n+\n+fn rename_to_self(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<SourceChange>> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+    let syn = source_file.syntax();\n+\n+    let fn_def = find_node_at_offset::<ast::FnDef>(syn, position.offset)?;\n+    let params = fn_def.param_list()?;\n+    if params.self_param().is_some() {\n+        return None; // method already has self param\n+    }\n+    let first_param = params.params().next()?;\n+    let mutable = match first_param.ascribed_type() {\n+        Some(ast::TypeRef::ReferenceType(rt)) => rt.mut_token().is_some(),\n+        _ => return None, // not renaming other types\n+    };\n+\n+    let RangeInfo { range, info: refs } = find_all_refs(db, position, None)?;\n+\n+    let param_range = first_param.syntax().text_range();\n+    let (param_ref, usages): (Vec<Reference>, Vec<Reference>) = refs\n+        .into_iter()\n+        .partition(|reference| param_range.intersect(reference.file_range.range).is_some());\n+\n+    if param_ref.is_empty() {\n+        return None;\n+    }\n+\n+    let mut edits = usages\n+        .into_iter()\n+        .map(|reference| source_edit_from_reference(reference, \"self\"))\n+        .collect::<Vec<_>>();\n+\n+    edits.push(SourceFileEdit {\n+        file_id: position.file_id,\n+        edit: TextEdit::replace(\n+            param_range,\n+            String::from(if mutable { \"&mut self\" } else { \"&self\" }),\n+        ),\n+    });\n+\n+    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"Rename\", edits)))\n+}\n+\n+fn text_edit_from_self_param(\n+    syn: &SyntaxNode,\n+    self_param: &ast::SelfParam,\n+    new_name: &str,\n+) -> Option<TextEdit> {\n+    fn target_type_name(impl_def: &ast::ImplDef) -> Option<String> {\n+        if let Some(ast::TypeRef::PathType(p)) = impl_def.target_type() {\n+            return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n+        }\n+        None\n+    }\n+\n+    let impl_def =\n+        find_node_at_offset::<ast::ImplDef>(syn, self_param.syntax().text_range().start())?;\n+    let type_name = target_type_name(&impl_def)?;\n+\n+    let mut replacement_text = String::from(new_name);\n+    replacement_text.push_str(\": \");\n+    replacement_text.push_str(self_param.mut_token().map_or(\"&\", |_| \"&mut \"));\n+    replacement_text.push_str(type_name.as_str());\n+\n+    Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n+}\n+\n+fn rename_self_to_param(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    self_token: SyntaxToken,\n+    new_name: &str,\n+) -> Option<RangeInfo<SourceChange>> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+    let syn = source_file.syntax();\n+\n+    let text = db.file_text(position.file_id);\n+    let fn_def = find_node_at_offset::<ast::FnDef>(syn, position.offset)?;\n+    let search_range = fn_def.syntax().text_range();\n+\n+    let mut edits: Vec<SourceFileEdit> = vec![];\n+\n+    for (idx, _) in text.match_indices(\"self\") {\n+        let offset: TextSize = idx.try_into().unwrap();\n+        if !search_range.contains_inclusive(offset) {\n+            continue;\n+        }\n+        if let Some(ref usage) =\n+            syn.token_at_offset(offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+        {\n+            let edit = if let Some(ref self_param) = ast::SelfParam::cast(usage.parent()) {\n+                text_edit_from_self_param(syn, self_param, new_name)?\n+            } else {\n+                TextEdit::replace(usage.text_range(), String::from(new_name))\n+            };\n+            edits.push(SourceFileEdit { file_id: position.file_id, edit });\n+        }\n+    }\n+\n+    let range = ast::SelfParam::cast(self_token.parent())\n+        .map_or(self_token.text_range(), |p| p.syntax().text_range());\n+\n+    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"Rename\", edits)))\n }\n \n fn rename_reference(\n@@ -140,14 +253,14 @@ fn rename_reference(\n         return None;\n     }\n \n-    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"rename\", edit)))\n+    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"Rename\", edit)))\n }\n \n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n     use ra_text_edit::TextEditBuilder;\n-    use test_utils::assert_eq_text;\n+    use test_utils::{assert_eq_text, mark};\n \n     use crate::{\n         mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n@@ -379,6 +492,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_struct_field_for_shorthand() {\n+        mark::check!(test_rename_struct_field_for_shorthand);\n         test_rename(\n             r#\"\n     struct Foo {\n@@ -408,6 +522,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_local_for_field_shorthand() {\n+        mark::check!(test_rename_local_for_field_shorthand);\n         test_rename(\n             r#\"\n     struct Foo {\n@@ -527,17 +642,17 @@ mod tests {\n             RangeInfo {\n                 range: 4..7,\n                 info: SourceChange {\n-                    label: \"rename\",\n+                    label: \"Rename\",\n                     source_file_edits: [\n                         SourceFileEdit {\n                             file_id: FileId(\n                                 2,\n                             ),\n                             edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: 4..7,\n+                                indels: [\n+                                    Indel {\n                                         insert: \"foo2\",\n+                                        delete: 4..7,\n                                     },\n                                 ],\n                             },\n@@ -554,7 +669,7 @@ mod tests {\n                             dst_path: \"bar/foo2.rs\",\n                         },\n                     ],\n-                    cursor_position: None,\n+                    is_snippet: false,\n                 },\n             },\n         )\n@@ -579,17 +694,17 @@ mod tests {\n             RangeInfo {\n                 range: 4..7,\n                 info: SourceChange {\n-                    label: \"rename\",\n+                    label: \"Rename\",\n                     source_file_edits: [\n                         SourceFileEdit {\n                             file_id: FileId(\n                                 1,\n                             ),\n                             edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: 4..7,\n+                                indels: [\n+                                    Indel {\n                                         insert: \"foo2\",\n+                                        delete: 4..7,\n                                     },\n                                 ],\n                             },\n@@ -606,7 +721,7 @@ mod tests {\n                             dst_path: \"foo2/mod.rs\",\n                         },\n                     ],\n-                    cursor_position: None,\n+                    is_snippet: false,\n                 },\n             },\n         )\n@@ -662,17 +777,17 @@ mod tests {\n             RangeInfo {\n                 range: 8..11,\n                 info: SourceChange {\n-                    label: \"rename\",\n+                    label: \"Rename\",\n                     source_file_edits: [\n                         SourceFileEdit {\n                             file_id: FileId(\n                                 2,\n                             ),\n                             edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: 8..11,\n+                                indels: [\n+                                    Indel {\n                                         insert: \"foo2\",\n+                                        delete: 8..11,\n                                     },\n                                 ],\n                             },\n@@ -682,10 +797,10 @@ mod tests {\n                                 1,\n                             ),\n                             edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: 27..30,\n+                                indels: [\n+                                    Indel {\n                                         insert: \"foo2\",\n+                                        delete: 27..30,\n                                     },\n                                 ],\n                             },\n@@ -702,13 +817,164 @@ mod tests {\n                             dst_path: \"bar/foo2.rs\",\n                         },\n                     ],\n-                    cursor_position: None,\n+                    is_snippet: false,\n                 },\n             },\n         )\n         \"###);\n     }\n \n+    #[test]\n+    fn test_enum_variant_from_module_1() {\n+        test_rename(\n+            r#\"\n+    mod foo {\n+        pub enum Foo {\n+            Bar<|>,\n+        }\n+    }\n+\n+    fn func(f: foo::Foo) {\n+        match f {\n+            foo::Foo::Bar => {}\n+        }\n+    }\n+    \"#,\n+            \"Baz\",\n+            r#\"\n+    mod foo {\n+        pub enum Foo {\n+            Baz,\n+        }\n+    }\n+\n+    fn func(f: foo::Foo) {\n+        match f {\n+            foo::Foo::Baz => {}\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_enum_variant_from_module_2() {\n+        test_rename(\n+            r#\"\n+    mod foo {\n+        pub struct Foo {\n+            pub bar<|>: uint,\n+        }\n+    }\n+\n+    fn foo(f: foo::Foo) {\n+        let _ = f.bar;\n+    }\n+    \"#,\n+            \"baz\",\n+            r#\"\n+    mod foo {\n+        pub struct Foo {\n+            pub baz: uint,\n+        }\n+    }\n+\n+    fn foo(f: foo::Foo) {\n+        let _ = f.baz;\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_parameter_to_self() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(foo<|>: &mut Foo) -> i32 {\n+            foo.i\n+        }\n+    }\n+    \"#,\n+            \"self\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(&mut self) -> i32 {\n+            self.i\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_self_to_parameter() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(&mut <|>self) -> i32 {\n+            self.i\n+        }\n+    }\n+    \"#,\n+            \"foo\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(foo: &mut Foo) -> i32 {\n+            foo.i\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_self_in_path_to_parameter() {\n+        test_rename(\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(&self) -> i32 {\n+            let self_var = 1;\n+            self<|>.i\n+        }\n+    }\n+    \"#,\n+            \"foo\",\n+            r#\"\n+    struct Foo {\n+        i: i32,\n+    }\n+\n+    impl Foo {\n+        fn f(foo: &Foo) -> i32 {\n+            let self_var = 1;\n+            foo.i\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n     fn test_rename(text: &str, new_name: &str, expected: &str) {\n         let (analysis, position) = single_file_with_position(text);\n         let source_change = analysis.rename(position, new_name).unwrap();\n@@ -717,13 +983,13 @@ mod tests {\n         if let Some(change) = source_change {\n             for edit in change.info.source_file_edits {\n                 file_id = Some(edit.file_id);\n-                for atom in edit.edit.as_atoms() {\n-                    text_edit_builder.replace(atom.delete, atom.insert.clone());\n+                for indel in edit.edit.into_iter() {\n+                    text_edit_builder.replace(indel.delete, indel.insert);\n                 }\n             }\n         }\n-        let result =\n-            text_edit_builder.finish().apply(&*analysis.file_text(file_id.unwrap()).unwrap());\n+        let mut result = analysis.file_text(file_id.unwrap()).unwrap().to_string();\n+        text_edit_builder.finish().apply(&mut result);\n         assert_eq_text!(expected, &*result);\n     }\n }"}, {"sha": "131b8f307c139b77e3cc4be1c3eac8860326745d", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 108, "deletions": 5, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::Semantics;\n+use hir::{AsAssocItem, Semantics};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n@@ -9,6 +9,7 @@ use ra_syntax::{\n };\n \n use crate::FileId;\n+use ast::DocCommentsOwner;\n use std::fmt::Display;\n \n #[derive(Debug)]\n@@ -37,6 +38,7 @@ pub enum RunnableKind {\n     Test { test_id: TestId, attr: TestAttr },\n     TestMod { path: String },\n     Bench { test_id: TestId },\n+    DocTest { test_id: TestId },\n     Bin,\n }\n \n@@ -63,14 +65,36 @@ fn runnable_fn(sema: &Semantics<RootDatabase>, fn_def: ast::FnDef) -> Option<Run\n         RunnableKind::Bin\n     } else {\n         let test_id = if let Some(module) = sema.to_def(&fn_def).map(|def| def.module(sema.db)) {\n-            let path = module\n+            let def = sema.to_def(&fn_def)?;\n+            let impl_trait_name =\n+                def.as_assoc_item(sema.db).and_then(|assoc_item| {\n+                    match assoc_item.container(sema.db) {\n+                        hir::AssocItemContainer::Trait(trait_item) => {\n+                            Some(trait_item.name(sema.db).to_string())\n+                        }\n+                        hir::AssocItemContainer::ImplDef(impl_def) => impl_def\n+                            .target_ty(sema.db)\n+                            .as_adt()\n+                            .map(|adt| adt.name(sema.db).to_string()),\n+                    }\n+                });\n+\n+            let path_iter = module\n                 .path_to_root(sema.db)\n                 .into_iter()\n                 .rev()\n                 .filter_map(|it| it.name(sema.db))\n-                .map(|name| name.to_string())\n-                .chain(std::iter::once(name_string))\n-                .join(\"::\");\n+                .map(|name| name.to_string());\n+\n+            let path = if let Some(impl_trait_name) = impl_trait_name {\n+                path_iter\n+                    .chain(std::iter::once(impl_trait_name))\n+                    .chain(std::iter::once(name_string))\n+                    .join(\"::\")\n+            } else {\n+                path_iter.chain(std::iter::once(name_string)).join(\"::\")\n+            };\n+\n             TestId::Path(path)\n         } else {\n             TestId::Name(name_string)\n@@ -81,6 +105,8 @@ fn runnable_fn(sema: &Semantics<RootDatabase>, fn_def: ast::FnDef) -> Option<Run\n             RunnableKind::Test { test_id, attr }\n         } else if fn_def.has_atom_attr(\"bench\") {\n             RunnableKind::Bench { test_id }\n+        } else if has_doc_test(&fn_def) {\n+            RunnableKind::DocTest { test_id }\n         } else {\n             return None;\n         }\n@@ -117,6 +143,10 @@ fn has_test_related_attribute(fn_def: &ast::FnDef) -> bool {\n         .any(|attribute_text| attribute_text.contains(\"test\"))\n }\n \n+fn has_doc_test(fn_def: &ast::FnDef) -> bool {\n+    fn_def.doc_comment_text().map_or(false, |comment| comment.contains(\"```\"))\n+}\n+\n fn runnable_mod(sema: &Semantics<RootDatabase>, module: ast::Module) -> Option<Runnable> {\n     let has_test_function = module\n         .item_list()?\n@@ -194,6 +224,79 @@ mod tests {\n                 );\n     }\n \n+    #[test]\n+    fn test_runnables_doc_test() {\n+        let (analysis, pos) = analysis_and_position(\n+            r#\"\n+        //- /lib.rs\n+        <|> //empty\n+        fn main() {}\n+\n+        /// ```\n+        /// let x = 5;\n+        /// ```\n+        fn foo() {}\n+        \"#,\n+        );\n+        let runnables = analysis.runnables(pos.file_id).unwrap();\n+        assert_debug_snapshot!(&runnables,\n+        @r###\"\n+        [\n+            Runnable {\n+                range: 1..21,\n+                kind: Bin,\n+            },\n+            Runnable {\n+                range: 22..64,\n+                kind: DocTest {\n+                    test_id: Path(\n+                        \"foo\",\n+                    ),\n+                },\n+            },\n+        ]\n+        \"###\n+                );\n+    }\n+\n+    #[test]\n+    fn test_runnables_doc_test_in_impl() {\n+        let (analysis, pos) = analysis_and_position(\n+            r#\"\n+        //- /lib.rs\n+        <|> //empty\n+        fn main() {}\n+\n+        struct Data;\n+        impl Data {\n+            /// ```\n+            /// let x = 5;\n+            /// ```\n+            fn foo() {}\n+        }\n+        \"#,\n+        );\n+        let runnables = analysis.runnables(pos.file_id).unwrap();\n+        assert_debug_snapshot!(&runnables,\n+        @r###\"\n+        [\n+            Runnable {\n+                range: 1..21,\n+                kind: Bin,\n+            },\n+            Runnable {\n+                range: 51..105,\n+                kind: DocTest {\n+                    test_id: Path(\n+                        \"Data::foo\",\n+                    ),\n+                },\n+            },\n+        ]\n+        \"###\n+                );\n+    }\n+\n     #[test]\n     fn test_runnables_module() {\n         let (analysis, pos) = analysis_and_position("}, {"sha": "752b487e82fa76530f534f5cdb66f8763b169f76", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -27,13 +27,13 @@\n .keyword.unsafe     { color: #BC8383; font-weight: bold; }\n .control            { font-style: italic; }\n </style>\n-<pre><code><span class=\"macro\">macro_rules!</span> println {\n+<pre><code><span class=\"macro\">macro_rules!</span> <span class=\"macro declaration\">println</span> {\n     ($($arg:tt)*) =&gt; ({\n         $<span class=\"keyword\">crate</span>::io::_print($<span class=\"keyword\">crate</span>::format_args_nl!($($arg)*));\n     })\n }\n #[rustc_builtin_macro]\n-<span class=\"macro\">macro_rules!</span> format_args_nl {\n+<span class=\"macro\">macro_rules!</span> <span class=\"macro declaration\">format_args_nl</span> {\n     ($fmt:expr) =&gt; {{ <span class=\"comment\">/* compiler built-in */</span> }};\n     ($fmt:expr, $($args:tt)*) =&gt; {{ <span class=\"comment\">/* compiler built-in */</span> }};\n }"}, {"sha": "635fe5cf9ddf54fc7d11ace1fca787cdfd56b341", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -33,11 +33,23 @@\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">y</span>: <span class=\"builtin_type\">i32</span>,\n }\n \n+<span class=\"keyword\">trait</span> <span class=\"trait declaration\">Bar</span> {\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>(&<span class=\"keyword\">self</span>) -&gt; <span class=\"builtin_type\">i32</span>;\n+}\n+\n+<span class=\"keyword\">impl</span> <span class=\"trait\">Bar</span> <span class=\"keyword\">for</span> <span class=\"struct\">Foo</span> {\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>(&<span class=\"keyword\">self</span>) -&gt; <span class=\"builtin_type\">i32</span> {\n+        <span class=\"keyword\">self</span>.<span class=\"field\">x</span>\n+    }\n+}\n+\n+<span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable\">STATIC_MUT</span>: <span class=\"builtin_type\">i32</span> = <span class=\"numeric_literal\">0</span>;\n+\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span>&lt;<span class=\"lifetime declaration\">'a</span>, <span class=\"type_param declaration\">T</span>&gt;() -&gt; <span class=\"type_param\">T</span> {\n     <span class=\"function\">foo</span>::&lt;<span class=\"lifetime\">'a</span>, <span class=\"builtin_type\">i32</span>&gt;()\n }\n \n-<span class=\"macro\">macro_rules!</span> def_fn {\n+<span class=\"macro\">macro_rules!</span> <span class=\"macro declaration\">def_fn</span> {\n     ($($tt:tt)*) =&gt; {$($tt)*}\n }\n \n@@ -56,7 +68,14 @@\n         <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> = <span class=\"numeric_literal\">92</span>;\n         <span class=\"variable mutable\">vec</span>.<span class=\"unresolved_reference\">push</span>(<span class=\"struct\">Foo</span> { <span class=\"field\">x</span>, <span class=\"field\">y</span>: <span class=\"numeric_literal\">1</span> });\n     }\n-    <span class=\"keyword unsafe\">unsafe</span> { <span class=\"variable mutable\">vec</span>.<span class=\"unresolved_reference\">set_len</span>(<span class=\"numeric_literal\">0</span>); }\n+    <span class=\"keyword unsafe\">unsafe</span> {\n+        <span class=\"variable mutable\">vec</span>.<span class=\"unresolved_reference\">set_len</span>(<span class=\"numeric_literal\">0</span>);\n+        <span class=\"static mutable\">STATIC_MUT</span> = <span class=\"numeric_literal\">1</span>;\n+    }\n+\n+    <span class=\"keyword control\">for</span> <span class=\"variable declaration\">e</span> <span class=\"keyword control\">in</span> <span class=\"variable mutable\">vec</span> {\n+        <span class=\"comment\">// Do nothing</span>\n+    }\n \n     <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">x</span> = <span class=\"numeric_literal\">42</span>;\n     <span class=\"keyword\">let</span> <span class=\"variable declaration mutable\">y</span> = &<span class=\"keyword\">mut</span> <span class=\"variable mutable\">x</span>;"}, {"sha": "1873d1d0d0abd4231ad080451d767ac7264025e1", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -1,18 +1,18 @@\n //!  structural search replace\n \n-use crate::source_change::SourceFileEdit;\n+use std::{collections::HashMap, iter::once, str::FromStr};\n+\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n-use ra_ide_db::symbol_index::SymbolsDatabase;\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::ast::make::try_expr_from_text;\n+use ra_ide_db::{symbol_index::SymbolsDatabase, RootDatabase};\n use ra_syntax::ast::{\n-    ArgList, AstToken, CallExpr, Comment, Expr, MethodCallExpr, RecordField, RecordLit,\n+    make::try_expr_from_text, ArgList, AstToken, CallExpr, Comment, Expr, MethodCallExpr,\n+    RecordField, RecordLit,\n };\n use ra_syntax::{AstNode, SyntaxElement, SyntaxKind, SyntaxNode};\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use rustc_hash::FxHashMap;\n-use std::collections::HashMap;\n-use std::{iter::once, str::FromStr};\n+\n+use crate::SourceFileEdit;\n \n #[derive(Debug, PartialEq)]\n pub struct SsrError(String);\n@@ -401,16 +401,22 @@ fn render_replace(\n     ignored_comments: &Vec<Comment>,\n     template: &SsrTemplate,\n ) -> String {\n-    let mut builder = TextEditBuilder::default();\n-    for element in template.template.descendants() {\n-        if let Some(var) = template.placeholders.get(&element) {\n-            builder.replace(element.text_range(), binding[var].to_string())\n+    let edit = {\n+        let mut builder = TextEditBuilder::default();\n+        for element in template.template.descendants() {\n+            if let Some(var) = template.placeholders.get(&element) {\n+                builder.replace(element.text_range(), binding[var].to_string())\n+            }\n         }\n-    }\n-    for comment in ignored_comments {\n-        builder.insert(template.template.text_range().end(), comment.syntax().to_string())\n-    }\n-    builder.finish().apply(&template.template.text().to_string())\n+        for comment in ignored_comments {\n+            builder.insert(template.template.text_range().end(), comment.syntax().to_string())\n+        }\n+        builder.finish()\n+    };\n+\n+    let mut text = template.template.text().to_string();\n+    edit.apply(&mut text);\n+    text\n }\n \n #[cfg(test)]\n@@ -505,15 +511,19 @@ mod tests {\n         );\n \n         let edit = replace(&matches, &query.template);\n-        assert_eq!(edit.apply(input), \"fn main() { bar(1+2); }\");\n+        let mut after = input.to_string();\n+        edit.apply(&mut after);\n+        assert_eq!(after, \"fn main() { bar(1+2); }\");\n     }\n \n     fn assert_ssr_transform(query: &str, input: &str, result: &str) {\n         let query: SsrQuery = query.parse().unwrap();\n         let code = SourceFile::parse(input).tree();\n         let matches = find(&query.pattern, code.syntax());\n         let edit = replace(&matches, &query.template);\n-        assert_eq!(edit.apply(input), result);\n+        let mut after = input.to_string();\n+        edit.apply(&mut after);\n+        assert_eq!(after, result);\n     }\n \n     #[test]"}, {"sha": "be57eeb0abeab6eade3d82657cf876328e4bb563", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "patch": "@@ -167,6 +167,19 @@ pub(crate) fn highlight(\n                         binding_hash: None,\n                     });\n                 }\n+                if let Some(name) = mc.is_macro_rules() {\n+                    if let Some((highlight, binding_hash)) = highlight_element(\n+                        &sema,\n+                        &mut bindings_shadow_count,\n+                        name.syntax().clone().into(),\n+                    ) {\n+                        stack.add(HighlightedRange {\n+                            range: name.syntax().text_range(),\n+                            highlight,\n+                            binding_hash,\n+                        });\n+                    }\n+                }\n                 continue;\n             }\n             WalkEvent::Leave(Some(mc)) => {\n@@ -390,12 +403,13 @@ fn highlight_element(\n                 T![break]\n                 | T![continue]\n                 | T![else]\n-                | T![for]\n                 | T![if]\n                 | T![loop]\n                 | T![match]\n                 | T![return]\n-                | T![while] => h | HighlightModifier::ControlFlow,\n+                | T![while]\n+                | T![in] => h | HighlightModifier::ControlFlow,\n+                T![for] if !is_child_of_impl(element) => h | HighlightModifier::ControlFlow,\n                 T![unsafe] => h | HighlightModifier::Unsafe,\n                 _ => h,\n             }\n@@ -419,6 +433,13 @@ fn highlight_element(\n     }\n }\n \n+fn is_child_of_impl(element: SyntaxElement) -> bool {\n+    match element.parent() {\n+        Some(e) => e.kind() == IMPL_DEF,\n+        _ => false,\n+    }\n+}\n+\n fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n     match def {\n         Definition::Macro(_) => HighlightTag::Macro,\n@@ -431,10 +452,16 @@ fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n             hir::ModuleDef::Adt(hir::Adt::Union(_)) => HighlightTag::Union,\n             hir::ModuleDef::EnumVariant(_) => HighlightTag::EnumVariant,\n             hir::ModuleDef::Const(_) => HighlightTag::Constant,\n-            hir::ModuleDef::Static(_) => HighlightTag::Static,\n             hir::ModuleDef::Trait(_) => HighlightTag::Trait,\n             hir::ModuleDef::TypeAlias(_) => HighlightTag::TypeAlias,\n             hir::ModuleDef::BuiltinType(_) => HighlightTag::BuiltinType,\n+            hir::ModuleDef::Static(s) => {\n+                let mut h = Highlight::new(HighlightTag::Static);\n+                if s.is_mut(db) {\n+                    h |= HighlightModifier::Mutable;\n+                }\n+                return h;\n+            }\n         },\n         Definition::SelfType(_) => HighlightTag::SelfType,\n         Definition::TypeParam(_) => HighlightTag::TypeParam,"}, {"sha": "eb43a23da6821ad34a5dc734b79f8eff510df82b", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "86c70ff830b8ff4cfa862731db1d0fdc0438d884", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "f14533e14bb7295d74f2dfba982e78ef349b5dd3", "filename": "crates/ra_ide/src/test_utils.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs?ref=db926218b2082077750291f8426ddd28b284cd08"}, {"sha": "cd48cad93b969ec286a8e4fb32fef384ea92914d", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "85be14ad33a2a152d352cace64bcf6b39702af3c", "filename": "crates/ra_ide/src/typing/on_enter.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "8b06cbfc54b7ca8681708f783e216ff77cad68b4", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "1b74e6558613d2064b8c208284a46ed2e4a67640", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "c7c744fce1ef8db144f1d07ab1bd6cb03b99539d", "filename": "crates/ra_ide_db/src/line_index.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "039a12c0d84823005e16b6246e176ce4aae6a9ab", "filename": "crates/ra_ide_db/src/line_index_utils.rs", "status": "removed", "additions": 0, "deletions": 302, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs?ref=db926218b2082077750291f8426ddd28b284cd08"}, {"sha": "03b4be21c974b7698115164b7356f834704e4e6d", "filename": "crates/ra_ide_db/src/marks.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs?ref=db926218b2082077750291f8426ddd28b284cd08"}, {"sha": "589f4477192609a13f94807bf3ecf384ad77754a", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "3484f55886b8d858cc99a7d52671db0c7fc5090f", "filename": "crates/ra_ide_db/src/source_change.rs", "status": "renamed", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e", "previous_filename": "crates/ra_ide/src/source_change.rs"}, {"sha": "9c450eabaed018f7e42f607fbdcf046da54a6cb7", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "7c9bb4d00e1a2f5f4d036eaa53393c8a5b77a7a9", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "fc4133a6753446ea09e959d57e0492498135cc21", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "c43003fd63df3f215d8b706b3601f4a151d4032c", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "be0cd5661bd6be0db8f19a22e4ae2fabb85525e9", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "34f0397686fb04720acdf53ddddf9a0d1a95a2cd", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "706a2f796b217a313f4c545668bc183cefb4191e", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "67a924de53977c0111d997f78f19342564bf53ee", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "2d61f9d8083a241ca19018a92b2a7879e70eae98", "filename": "crates/ra_parser/src/grammar/type_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "eeb8ad66bd16b3df4339141b111cbf12c094f47a", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "4f59b0a2356fe7a6ee33b7143e703176e1e93be2", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e7404492a8e9399aa6a36a2cbc4555dab82d3e29", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "bb30032785167f63f379eb3f01dd8dbb322cd83e", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "bc010cfe99d68e9aa96577509e2046aee28eff7c", "filename": "crates/ra_proc_macro_srv/src/tests/fixtures/test_serialize_proc_macro.txt", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "82cefbb29a77882e917c2702f9560610a53e0a9e", "filename": "crates/ra_proc_macro_srv/src/tests/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "84348b5defced354f079b5601a2c48ac4d898438", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e4a60f4c02fd17b5fb4efc0bbbf5c86afa335a09", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "a306ce95f36e89f4539d2861506c68401b370f0d", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "a2e9f65effc08478cd33c9137fbcb452979285ec", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "a8a196e64c963f68435babe2ec8d703f9b292032", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "664894d1f839cfba0e1259bc625016fae30ad9d4", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "1876afe958e0bc817569201e7f67bc031b5ae1b8", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "29eb3fcb9ccca443055ef4c2bde26bf8f5735aac", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "7771d6759553973228f61ff658d99d8ca3f9b1ab", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "98c38d0095a98245c7b460a05714552528d52fd9", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "cf6067e57c42497c626e7eacbf31dda4a15381a9", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1430, "deletions": 191, "changes": 1621, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "da0eb09267ffe9eef47c0acaf689023618dabe1f", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "39f9b12ab20b916e1760129ce5940f5e6665537b", "filename": "crates/ra_syntax/src/fuzz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "61e686da5e6dc6108a14aa3b3d5054d85dc3af54", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "edbc190f855367d2c2c6fd8592bdac0e943e652e", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e566af7e87acc2271a192c8d50b0ee0413817cad", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "d68cf0a82bf434b86e1a91539b912b5601c7578f", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "2c08f7e6ed4be68434ec1b0fa42a1e73affa60b8", "filename": "crates/ra_syntax/src/validation/block.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "375ed45e073f57c847e4719f20937e03f54c9dae", "filename": "crates/ra_syntax/test_data/parser/err/0005_attribute_recover.rast", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0005_attribute_recover.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0005_attribute_recover.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0005_attribute_recover.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b72c92c33cf3ba95a77e4e43fbe8521aa4342c1b", "filename": "crates/ra_syntax/test_data/parser/err/0007_stray_curly_in_file.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0007_stray_curly_in_file.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0007_stray_curly_in_file.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0007_stray_curly_in_file.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "33953d8d770072b8da2e20f2c22a1d3c8e4499cf", "filename": "crates/ra_syntax/test_data/parser/err/0008_item_block_recovery.rast", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0008_item_block_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0008_item_block_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0008_item_block_recovery.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "3bf57eacc729117c2c7a71219dce0dbedca5a7a0", "filename": "crates/ra_syntax/test_data/parser/err/0010_unsafe_lambda_block.rast", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9323b78905a6830af34a1dd07e302885957db8c8", "filename": "crates/ra_syntax/test_data/parser/err/0014_where_no_bounds.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0014_where_no_bounds.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0014_where_no_bounds.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0014_where_no_bounds.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "93434f34f4a38af1043fd0339e6080a6beb0acd5", "filename": "crates/ra_syntax/test_data/parser/err/0016_missing_semi.rast", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0016_missing_semi.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0016_missing_semi.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0016_missing_semi.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "628315c7850bfebc1c98c286db2a027f3c2305dc", "filename": "crates/ra_syntax/test_data/parser/err/0017_incomplete_binexpr.rast", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0017_incomplete_binexpr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0017_incomplete_binexpr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0017_incomplete_binexpr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "31cc4e5514275cf8aa5456b83c19d49c6101cfd8", "filename": "crates/ra_syntax/test_data/parser/err/0018_incomplete_fn.rast", "status": "modified", "additions": 82, "deletions": 83, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0018_incomplete_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0018_incomplete_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0018_incomplete_fn.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "4ff27f5c85dda34295deae5b7594b57611cf7fe3", "filename": "crates/ra_syntax/test_data/parser/err/0019_let_recover.rast", "status": "modified", "additions": 81, "deletions": 85, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0019_let_recover.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0019_let_recover.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0019_let_recover.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "5f3a31473f0cceb8fed291d835ebe21e814836d8", "filename": "crates/ra_syntax/test_data/parser/err/0020_fn_recover.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0020_fn_recover.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0020_fn_recover.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0020_fn_recover.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "1746bd3c1011ac6a81978db53239d4af4040c2ca", "filename": "crates/ra_syntax/test_data/parser/err/0021_incomplete_param.rast", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0021_incomplete_param.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0021_incomplete_param.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0021_incomplete_param.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "28146f44e36b4a2f596b522a47d2fe78fe6b895d", "filename": "crates/ra_syntax/test_data/parser/err/0022_bad_exprs.rast", "status": "modified", "additions": 113, "deletions": 116, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9ea9d715ea8e235940d1a6dbfae08b2e9a00a2cb", "filename": "crates/ra_syntax/test_data/parser/err/0023_mismatched_paren.rast", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0023_mismatched_paren.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0023_mismatched_paren.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0023_mismatched_paren.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "7c957fdde2365357289a550c0d5154fccf8f8d9f", "filename": "crates/ra_syntax/test_data/parser/err/0024_many_type_parens.rast", "status": "modified", "additions": 214, "deletions": 216, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "88b086daff4bfa228f69472e69c3f9c2601509e1", "filename": "crates/ra_syntax/test_data/parser/err/0025_nope.rast", "status": "modified", "additions": 179, "deletions": 181, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "568a4cc028eb75ea1710da79637042a1ddf69c71", "filename": "crates/ra_syntax/test_data/parser/err/0027_incomplere_where_for.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0027_incomplere_where_for.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0027_incomplere_where_for.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0027_incomplere_where_for.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "0da8f59f043fdab008d7e13a16f15f0926e4e5e2", "filename": "crates/ra_syntax/test_data/parser/err/0029_field_completion.rast", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0029_field_completion.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0029_field_completion.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0029_field_completion.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "515819e42e042ff5ac747fb7b4e84a22f640483b", "filename": "crates/ra_syntax/test_data/parser/err/0031_block_inner_attrs.rast", "status": "modified", "additions": 105, "deletions": 109, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0031_block_inner_attrs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0031_block_inner_attrs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0031_block_inner_attrs.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "c6859eca8b027b1781468098d831ebb76656db15", "filename": "crates/ra_syntax/test_data/parser/err/0032_match_arms_inner_attrs.rast", "status": "modified", "additions": 180, "deletions": 181, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0032_match_arms_inner_attrs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0032_match_arms_inner_attrs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0032_match_arms_inner_attrs.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "53e445459bec673b95597abed812cd8bc036a195", "filename": "crates/ra_syntax/test_data/parser/err/0033_match_arms_outer_attrs.rast", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0033_match_arms_outer_attrs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0033_match_arms_outer_attrs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0033_match_arms_outer_attrs.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "1b2ac5011fad4e5a27365d89cff237e35a2d15dc", "filename": "crates/ra_syntax/test_data/parser/err/0034_bad_box_pattern.rast", "status": "modified", "additions": 77, "deletions": 78, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0034_bad_box_pattern.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0034_bad_box_pattern.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0034_bad_box_pattern.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9588cf3b3ac013af42d4142b8c4c3902599fb95d", "filename": "crates/ra_syntax/test_data/parser/err/0035_use_recover.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0035_use_recover.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0035_use_recover.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0035_use_recover.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e3cda7c432aaffcc200ae6b9d1b227bb555d4f1c", "filename": "crates/ra_syntax/test_data/parser/err/0037_visibility_in_traits.rast", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "21db9ee85e4b5a7e71bea9b5c7e99d5502af1a60", "filename": "crates/ra_syntax/test_data/parser/err/0038_endless_inclusive_range.rast", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "ec950381b4372fa489badb3c81f022befd24eb0f", "filename": "crates/ra_syntax/test_data/parser/err/0039_lambda_recovery.rast", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e4645638426a3a8c9ec4bcb764a33a7465a93fb6", "filename": "crates/ra_syntax/test_data/parser/err/0163_weird_blocks.rast", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0163_weird_blocks.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0163_weird_blocks.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0163_weird_blocks.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "8fa324c1a14f7d3040014041387ca6f296863503", "filename": "crates/ra_syntax/test_data/parser/err/0163_weird_blocks.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0163_weird_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0163_weird_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0163_weird_blocks.rs?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "75668c818df4f834e1f81db57915df5b46270824", "filename": "crates/ra_syntax/test_data/parser/inline/err/0002_misplaced_label_err.rast", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "c789e8d825644a69d42636a4c01f3c6078ecab3f", "filename": "crates/ra_syntax/test_data/parser/inline/err/0006_unsafe_block_in_mod.rast", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0006_unsafe_block_in_mod.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0006_unsafe_block_in_mod.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0006_unsafe_block_in_mod.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "cd24313d4dc61b14a00e8eacf8b3baf4254e3eab", "filename": "crates/ra_syntax/test_data/parser/inline/err/0007_async_without_semicolon.rast", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0007_async_without_semicolon.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0007_async_without_semicolon.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0007_async_without_semicolon.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "c5fa7a404612e6ec41fcd618f8829f5a156ba48d", "filename": "crates/ra_syntax/test_data/parser/inline/err/0008_pub_expr.rast", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0008_pub_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0008_pub_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0008_pub_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "0656fdf739241d4bf21a2d93745946237dc31200", "filename": "crates/ra_syntax/test_data/parser/inline/err/0009_attr_on_expr_not_allowed.rast", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0009_attr_on_expr_not_allowed.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0009_attr_on_expr_not_allowed.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0009_attr_on_expr_not_allowed.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e1abc56331440d095edc4a956706e845a6e07d68", "filename": "crates/ra_syntax/test_data/parser/inline/err/0010_bad_tuple_index_expr.rast", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_bad_tuple_index_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_bad_tuple_index_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_bad_tuple_index_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9be441110ff4ba950fb118b724c0a4baa099e6c6", "filename": "crates/ra_syntax/test_data/parser/inline/err/0010_wrong_order_fns.rast", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_wrong_order_fns.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_wrong_order_fns.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_wrong_order_fns.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b8cd0587da7c1ea3fdf5c5dd2c331073be2db502", "filename": "crates/ra_syntax/test_data/parser/inline/err/0014_default_fn_type.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_default_fn_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_default_fn_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_default_fn_type.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "a9de44b57c0399a73759eda5cafe789f8611ed1a", "filename": "crates/ra_syntax/test_data/parser/inline/err/0014_record_literal_before_ellipsis_recovery.rast", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "a38b4f5736d55cfd108b00abdb896aafbe123c97", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0001_trait_item_list.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9dc473e43c7fd4f67f63f4a05b7a9ba760e08fa0", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0003_where_pred_for.rast", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "6c8c1e24b08f6b2abc00fd80ca52b74034827ee7", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0005_function_type_params.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0005_function_type_params.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0005_function_type_params.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0005_function_type_params.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9f4a9e69bce61c3a7b4c39644f4ca1f19e5940e4", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0006_self_param.rast", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0006_self_param.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0006_self_param.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0006_self_param.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "10eb31d68626cda5f495962d88ea70974120053f", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0008_path_part.rast", "status": "modified", "additions": 84, "deletions": 85, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0008_path_part.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0008_path_part.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0008_path_part.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "425e5196cb748c8a5b9a41349b243dd5fdba9322", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0009_loop_expr.rast", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0009_loop_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0009_loop_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0009_loop_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "d823c08fc18958a14bba6f43c8d44752b8161991", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0011_field_expr.rast", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "422912e3cb2a7a33185b3d8dbbc990f43d51bfcf", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0015_continue_expr.rast", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0015_continue_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0015_continue_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0015_continue_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "15da6fdd6e9513c58daef63d4dfc739c32ed5152", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0018_arb_self_types.rast", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0018_arb_self_types.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0018_arb_self_types.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0018_arb_self_types.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "10d6b2fdef0e00696f16ba2e90aeb9cdbcef3a79", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0019_unary_expr.rast", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0019_unary_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0019_unary_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0019_unary_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "c204aeb63ee926e8b5d25f785f6b3dbe7fbca291", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0021_impl_item_list.rast", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0021_impl_item_list.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0021_impl_item_list.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0021_impl_item_list.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "7eb27d5e14b980af86736b9ba55484dea10a7df1", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0024_slice_pat.rast", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b4598768eefc5547a459006720caa30833af67af", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0026_tuple_pat_fields.rast", "status": "modified", "additions": 92, "deletions": 93, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b824c10a8c7c214b553c925b8751d41020984500", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0027_ref_pat.rast", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0027_ref_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0027_ref_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0027_ref_pat.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "fabb09937fc09e333c944b95cb1f94eb4025c9cc", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0029_cast_expr.rast", "status": "modified", "additions": 77, "deletions": 78, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0029_cast_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0029_cast_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0029_cast_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "3aed267322fc47c9f05af1e1abfc8e84093c49fc", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0030_cond.rast", "status": "modified", "additions": 179, "deletions": 186, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0030_cond.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0030_cond.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0030_cond.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "899b63aac38ec05a8f8c3494f34783d1128091f3", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0031_while_expr.rast", "status": "modified", "additions": 72, "deletions": 77, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0031_while_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0031_while_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0031_while_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e064aafaf25ae264cffdab21c445d96362383a21", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0034_break_expr.rast", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0034_break_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0034_break_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0034_break_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "cf582559319769b3ba12599063cecf29e7902f96", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0036_unsafe_extern_fn.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0036_unsafe_extern_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0036_unsafe_extern_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0036_unsafe_extern_fn.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "fbd90bc0f7af8259e523eb230ac9c1224519b580", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0037_qual_paths.rast", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0037_qual_paths.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0037_qual_paths.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0037_qual_paths.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "a767f145db28de7bdb7e95572cf7b3ab3415c0a2", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0038_full_range_expr.rast", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0038_full_range_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0038_full_range_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0038_full_range_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e92ea2bf2379bbeb91917cf3603ec2383fdb0c0b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0039_type_arg.rast", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0039_type_arg.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0039_type_arg.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0039_type_arg.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "aa582516a38181c9520bdd013720ce20b703506b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0040_crate_keyword_vis.rast", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0040_crate_keyword_vis.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0040_crate_keyword_vis.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0040_crate_keyword_vis.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "0c1c6e8771cbccef24fe35cb39fd61b3e7f68f06", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0042_call_expr.rast", "status": "modified", "additions": 135, "deletions": 136, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0042_call_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0042_call_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0042_call_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "c23b3b67cf625e8c73aac55871cbe813dce683c0", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0044_block_items.rast", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0044_block_items.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0044_block_items.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0044_block_items.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9ca2165baf754bbe762e6b8c7503098150899ceb", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0045_param_list_opt_patterns.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0045_param_list_opt_patterns.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0045_param_list_opt_patterns.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0045_param_list_opt_patterns.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b209f67f8ceaafd8a89eb748a668d46ec83c0986", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0048_path_type_with_bounds.rast", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0048_path_type_with_bounds.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0048_path_type_with_bounds.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0048_path_type_with_bounds.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "70232a3b272f87cd70ccacbc00a0a8e9867ca2b8", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0053_path_expr.rast", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0053_path_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0053_path_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0053_path_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "03c52525eb7d1d01ca222691fa46d4d5e07d6127", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0055_literal_pattern.rast", "status": "modified", "additions": 64, "deletions": 65, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0055_literal_pattern.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0055_literal_pattern.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0055_literal_pattern.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "24f89b83ff08a6a7a87809f8d03dfdd47f63226c", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0056_where_clause.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0056_where_clause.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0056_where_clause.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0056_where_clause.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "bb43d1eaf3893a264fff959fae04aa280f4ca0e2", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0057_const_fn.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0057_const_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0057_const_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0057_const_fn.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "8bd94a86846bbb27b8c213fc2c51e295d1da5904", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0058_range_pat.rast", "status": "modified", "additions": 70, "deletions": 71, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9210f155cba8ea43ddb8aefcf83d92f786399336", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0059_match_arms_commas.rast", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0059_match_arms_commas.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0059_match_arms_commas.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0059_match_arms_commas.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "850465d824d99d06319c441c351449fda9f73ff3", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0061_record_lit.rast", "status": "modified", "additions": 112, "deletions": 113, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "02656df31fd41da20c265307b0e11652e2148bc0", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0062_mod_contents.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0062_mod_contents.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0062_mod_contents.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0062_mod_contents.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "445d8d309f7819547410245c453e8e5387b7c9f0", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0064_if_expr.rast", "status": "modified", "additions": 109, "deletions": 120, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0064_if_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0064_if_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0064_if_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "177bb5514a1ccb24fd57f3f1e30e697f3b9d7c61", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0066_match_arm.rast", "status": "modified", "additions": 139, "deletions": 140, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0066_match_arm.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0066_match_arm.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0066_match_arm.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "f8ff7079b55b1e79d91e25eb30f1e7858d18e55f", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0070_stmt_bin_expr_ambiguity.rast", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0070_stmt_bin_expr_ambiguity.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0070_stmt_bin_expr_ambiguity.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0070_stmt_bin_expr_ambiguity.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "07b3d14351384b5016c709f88bf8f2bdddaccccf", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0071_match_expr.rast", "status": "modified", "additions": 81, "deletions": 84, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0071_match_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0071_match_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0071_match_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "665f716a8693f1fd356ebb75dff250241052ff9b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0072_return_expr.rast", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0072_return_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0072_return_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0072_return_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "3fd3a4391d320657550a05a2eaeb8bad03a9d099", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0074_stmt_postfix_expr_ambiguity.rast", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0074_stmt_postfix_expr_ambiguity.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0074_stmt_postfix_expr_ambiguity.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0074_stmt_postfix_expr_ambiguity.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "97c6e6a9dd7884069279807edf60edd6d60cb35c", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0075_block.rast", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0075_block.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0075_block.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0075_block.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e2c1a507de5dd1e5af6fe94f8f39f767872667ce", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0076_function_where_clause.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0076_function_where_clause.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0076_function_where_clause.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0076_function_where_clause.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "4f3a8ed24e6469fc1d34fc88ed6ea21eb22e1cc7", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0077_try_expr.rast", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0077_try_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0077_try_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0077_try_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "462d1a8bb070ced49e62245872d8c7b45d6e26c8", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0080_postfix_range.rast", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0080_postfix_range.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0080_postfix_range.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0080_postfix_range.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "dfb8d57ad84486df6aa9d757ccebf47ed497fc30", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0081_for_type.rast", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "7fe96e17db0c126877fbce393f59b96eeb0e02af", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0082_ref_expr.rast", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9fcb7899e244d4839242fd1ce1af9d439e81da98", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0085_expr_literals.rast", "status": "modified", "additions": 123, "deletions": 124, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0085_expr_literals.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0085_expr_literals.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0085_expr_literals.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "a42abc189deb817fbf11addd1acf2482cf28208f", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0086_function_ret_type.rast", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0086_function_ret_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0086_function_ret_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0086_function_ret_type.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "7e71d73738e195fa1becb6d5a56faae93bed3402", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0088_break_ambiguity.rast", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0088_break_ambiguity.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0088_break_ambiguity.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0088_break_ambiguity.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "48aaf1004d250c7f88f81f38e637e5f25975b2b3", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0089_extern_fn.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0089_extern_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0089_extern_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0089_extern_fn.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "aed81f9b0f03896152c2ccbe1e0aa65a699a50c2", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0093_index_expr.rast", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0093_index_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0093_index_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0093_index_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "67d9595d3d45a42d137630c9ff4f7fd6996e290b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0095_placeholder_pat.rast", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0095_placeholder_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0095_placeholder_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0095_placeholder_pat.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "031e7465218aad486bdb61793966864f683d74da", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0096_no_semi_after_block.rast", "status": "modified", "additions": 111, "deletions": 118, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0096_no_semi_after_block.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0096_no_semi_after_block.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0096_no_semi_after_block.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "816e493107d79c3b2c098c207b0bc87ef74db675", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0098_const_unsafe_fn.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0098_const_unsafe_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0098_const_unsafe_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0098_const_unsafe_fn.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "d48ef865cb84ffba4c797fc7d42a242563032e55", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0099_param_list.rast", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0099_param_list.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0099_param_list.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0099_param_list.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e4455cd3e4b3cef6845aa6ffe8e75d2fcd4fab57", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0100_for_expr.rast", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0100_for_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0100_for_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0100_for_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "8a874306009731de59c1c4d83f037312bcaedd24", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0101_unsafe_fn.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0101_unsafe_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0101_unsafe_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0101_unsafe_fn.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9f966ff8a0d3cdbdffd83bdd53921e7828b35d6a", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0102_record_field_pat_list.rast", "status": "modified", "additions": 120, "deletions": 121, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0102_record_field_pat_list.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0102_record_field_pat_list.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0102_record_field_pat_list.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9b3bef04e57a0bff013ca089f7e64727c381feae", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0103_array_expr.rast", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0103_array_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0103_array_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0103_array_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "8b2323cf27038b12521695e3a26015f8ed8f7586", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0105_block_expr.rast", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0105_block_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0105_block_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0105_block_expr.rast?ref=db926218b2082077750291f8426ddd28b284cd08"}, {"sha": "2fed74c5e05f49678aca03152ee5488f5a153cc6", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0105_block_expr.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0105_block_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db926218b2082077750291f8426ddd28b284cd08/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0105_block_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0105_block_expr.rs?ref=db926218b2082077750291f8426ddd28b284cd08"}, {"sha": "e6471715267c3bde7cd4e60d5ba0797484bfab35", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0106_lambda_expr.rast", "status": "modified", "additions": 123, "deletions": 128, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0106_lambda_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0106_lambda_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0106_lambda_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "98963dc62ea97376b8d13c1886ecf28760d06355", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0107_method_call_expr.rast", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "ea603e2c9388384119fbc9186160b1198f5d8271", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0108_tuple_expr.rast", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0108_tuple_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0108_tuple_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0108_tuple_expr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "30ff96a7c9cbf1c80de989b4532f5c41ff03714f", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0109_label.rast", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0109_label.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0109_label.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0109_label.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b58f40ac1505dcaedbd60d88a59d608c70130410", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0111_tuple_pat.rast", "status": "modified", "additions": 77, "deletions": 78, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b67714c176957fe6795d3210bc733c604c4f745f", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0112_bind_pat.rast", "status": "modified", "additions": 115, "deletions": 116, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0112_bind_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0112_bind_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0112_bind_pat.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "5de480da90a45bf63a943620001c80eb8b09a470", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0113_nocontentexpr.rast", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0113_nocontentexpr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0113_nocontentexpr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0113_nocontentexpr.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "e152c6b6cdeae4fc1638732ac767ae234875731b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0118_match_guard.rast", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0118_match_guard.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0118_match_guard.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0118_match_guard.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "b283ab8041097f422bc1442ce2777bf6f4c01245", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0120_match_arms_inner_attribute.rast", "status": "modified", "additions": 68, "deletions": 69, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0120_match_arms_inner_attribute.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0120_match_arms_inner_attribute.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0120_match_arms_inner_attribute.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "9d547091421ef01775a1b4c9fb09dd0243d6891b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0121_match_arms_outer_attributes.rast", "status": "modified", "additions": 133, "deletions": 134, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0121_match_arms_outer_attributes.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0121_match_arms_outer_attributes.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0121_match_arms_outer_attributes.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "ada2fc54eb5838d8cb658cedfdb459a06f3cf178", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0122_generic_lifetime_type_attribute.rast", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0122_generic_lifetime_type_attribute.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0122_generic_lifetime_type_attribute.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0122_generic_lifetime_type_attribute.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "6178dfe5980c2a7632f1d40d53b50620fdc9325b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0124_async_fn.rast", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0124_async_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0124_async_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0124_async_fn.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}, {"sha": "ced59b7c1f80465bee30ea82a45683fdffdf8f11", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0125_crate_keyword_path.rast", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0125_crate_keyword_path.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7fece3bdd2450c0807f7dd742239cae95f0cc65e/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0125_crate_keyword_path.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0125_crate_keyword_path.rast?ref=7fece3bdd2450c0807f7dd742239cae95f0cc65e"}]}