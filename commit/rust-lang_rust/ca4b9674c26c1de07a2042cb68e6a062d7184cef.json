{"sha": "ca4b9674c26c1de07a2042cb68e6a062d7184cef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNGI5Njc0YzI2YzFkZTA3YTIwNDJjYjY4ZTZhMDYyZDcxODRjZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-01T21:53:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-01T21:53:53Z"}, "message": "Auto merge of #21318 - stepancheg:box-fns, r=alexcrichton\n\nFunctions are needed for safety and convenience.\r\n\r\nIt is a common pattern to use `mem::transmute` to convert between\r\n`Box` and raw pointer, like this:\r\n\r\n```\r\nlet b = Box::new(3);\r\nlet p = mem::transmute(b);\r\n// pass `p` to some C library\r\n```\r\n\r\nAfter this commit, conversion can be written as:\r\n\r\n```\r\nlet p = b.into_raw();\r\n```\r\n\r\n`into_raw` and `from_raw` functions are still unsafe, but they are\r\nmuch safer than `mem::transmute`, because *raw functions do not\r\nconvert between incompatible pointers. For example, this likely\r\nincorrect code can be successfully compiled:\r\n\r\n```\r\nlet p: *mut u64 = ...\r\nlet b: Box<u32> = mem::transmute(p);\r\n```\r\n\r\nUsing `from_raw` results in compile-time error:\r\n\r\n```\r\nlet p: *mut u64 = ...\r\nlet b: Box<u32> = Box::from_raw(p); // compile-time error\r\n```\r\n\r\n`into_raw` and `from_raw` functions are similar to C++ `std::unique_ptr`\r\n`release` function [1] and constructor from pointer [2].\r\n\r\n[1] http://en.cppreference.com/w/cpp/memory/unique_ptr/release\r\n[2] http://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr", "tree": {"sha": "759ff3ca5e735f22b9cc47a4bec21e87aa204262", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/759ff3ca5e735f22b9cc47a4bec21e87aa204262"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca4b9674c26c1de07a2042cb68e6a062d7184cef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4b9674c26c1de07a2042cb68e6a062d7184cef", "html_url": "https://github.com/rust-lang/rust/commit/ca4b9674c26c1de07a2042cb68e6a062d7184cef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca4b9674c26c1de07a2042cb68e6a062d7184cef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "html_url": "https://github.com/rust-lang/rust/commit/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7"}, {"sha": "5a722f8632eabfa5a776171ebdd6c1f6385098c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a722f8632eabfa5a776171ebdd6c1f6385098c7", "html_url": "https://github.com/rust-lang/rust/commit/5a722f8632eabfa5a776171ebdd6c1f6385098c7"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "504b58d8ad1058886fee5672cc9925e5bbd36c9c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ca4b9674c26c1de07a2042cb68e6a062d7184cef/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4b9674c26c1de07a2042cb68e6a062d7184cef/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=ca4b9674c26c1de07a2042cb68e6a062d7184cef", "patch": "@@ -102,6 +102,52 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T : ?Sized> Box<T> {\n+    /// Constructs a box from the raw pointer.\n+    ///\n+    /// After this function call, pointer is owned by resulting box.\n+    /// In particular, it means that `Box` destructor calls destructor\n+    /// of `T` and releases memory. Since the way `Box` allocates and\n+    /// releases memory is unspecified, so the only valid pointer to\n+    /// pass to this function is the one taken from another `Box` with\n+    /// `box::into_raw` function.\n+    ///\n+    /// Function is unsafe, because improper use of this function may\n+    /// lead to memory problems like double-free, for example if the\n+    /// function is called twice on the same raw pointer.\n+    #[unstable(feature = \"alloc\",\n+               reason = \"may be renamed or moved out of Box scope\")]\n+    pub unsafe fn from_raw(raw: *mut T) -> Self {\n+        mem::transmute(raw)\n+    }\n+}\n+\n+/// Consumes the `Box`, returning the wrapped raw pointer.\n+///\n+/// After call to this function, caller is responsible for the memory\n+/// previously managed by `Box`, in particular caller should properly\n+/// destroy `T` and release memory. The proper way to do it is to\n+/// convert pointer back to `Box` with `Box::from_raw` function, because\n+/// `Box` does not specify, how memory is allocated.\n+///\n+/// Function is unsafe, because result of this function is no longer\n+/// automatically managed that may lead to memory or other resource\n+/// leak.\n+///\n+/// # Example\n+/// ```\n+/// use std::boxed;\n+///\n+/// let seventeen = Box::new(17u32);\n+/// let raw = unsafe { boxed::into_raw(seventeen) };\n+/// let boxed_again = unsafe { Box::from_raw(raw) };\n+/// ```\n+#[unstable(feature = \"alloc\",\n+           reason = \"may be renamed\")]\n+pub unsafe fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T {\n+    mem::transmute(b)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f7ddfcb09d7fb92be762db1c8b7fec57ca582a8d", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ca4b9674c26c1de07a2042cb68e6a062d7184cef/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4b9674c26c1de07a2042cb68e6a062d7184cef/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=ca4b9674c26c1de07a2042cb68e6a062d7184cef", "patch": "@@ -15,6 +15,7 @@ use core::ops::Deref;\n use core::result::Result::{Ok, Err};\n use core::clone::Clone;\n \n+use std::boxed;\n use std::boxed::Box;\n use std::boxed::BoxAny;\n \n@@ -73,3 +74,44 @@ fn deref() {\n     fn homura<T: Deref<Target=i32>>(_: T) { }\n     homura(Box::new(765i32));\n }\n+\n+#[test]\n+fn raw_sized() {\n+    unsafe {\n+        let x = Box::new(17i32);\n+        let p = boxed::into_raw(x);\n+        assert_eq!(17, *p);\n+        *p = 19;\n+        let y = Box::from_raw(p);\n+        assert_eq!(19, *y);\n+    }\n+}\n+\n+#[test]\n+fn raw_trait() {\n+    trait Foo {\n+        fn get(&self) -> u32;\n+        fn set(&mut self, value: u32);\n+    }\n+\n+    struct Bar(u32);\n+\n+    impl Foo for Bar {\n+        fn get(&self) -> u32 {\n+            self.0\n+        }\n+\n+        fn set(&mut self, value: u32) {\n+            self.0 = value;\n+        }\n+    }\n+\n+    unsafe {\n+        let x: Box<Foo> = Box::new(Bar(17));\n+        let p = boxed::into_raw(x);\n+        assert_eq!(17, (*p).get());\n+        (*p).set(19);\n+        let y: Box<Foo> = Box::from_raw(p);\n+        assert_eq!(19, y.get());\n+    }\n+}"}]}