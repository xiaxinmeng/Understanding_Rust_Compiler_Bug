{"sha": "5e6812b5977bfd8c7f1643b29392e554ce46e58d", "node_id": "C_kwDOAAsO6NoAKDVlNjgxMmI1OTc3YmZkOGM3ZjE2NDNiMjkzOTJlNTU0Y2U0NmU1OGQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-09T05:58:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-09T05:58:04Z"}, "message": "Rollup merge of #98915 - nnethercote:clarify-deriving-code, r=Mark-Simulacrum\n\nClarify deriving code\n\nA number of clarifications to the deriving code.\n\nr? ``@Mark-Simulacrum``", "tree": {"sha": "b364127125868086bf5a2f2efd7bbf5bb543b48d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b364127125868086bf5a2f2efd7bbf5bb543b48d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e6812b5977bfd8c7f1643b29392e554ce46e58d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiyRjsCRBK7hj4Ov3rIwAAsj0IAIbS0wYTzyB2iq5Y5eV6vRqI\n7UjtIGCWZHSV86D/7LOyqh8kV5mQLrpD6vwZ76r2oJwHxIGowSR6dptSoO3vXKG4\nCNK34nM5UyWuXBFUE/uNLfsutDLATTgI8REqIzw4Z/J4Arc1EVbpvFz+0xAWSG3w\nk7aOOsSLSD+VlR6XhW9Y6RdSSvKW2BKHKpjJ9rMjz4UJNtcyVB8eZvLjOw7HOytn\n+JkGWuggm0+2RERE8HfkyhLfDQkoaxq1NpUTB8B09ghYRNhfMP/VYTsKvi2sABN2\nJigNRbPGzg5YrVWPWF8bbZTqLYMsuIRmv4J944wjLpL8B+qm0Qydo/xBgWFpuo0=\n=klVg\n-----END PGP SIGNATURE-----\n", "payload": "tree b364127125868086bf5a2f2efd7bbf5bb543b48d\nparent fd4f11dd768e7de5015b57eef6b18c1f4d31e1e6\nparent 0578697a63f3b531f6ffeb18a186eff372bf67f1\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657346284 +0530\ncommitter GitHub <noreply@github.com> 1657346284 +0530\n\nRollup merge of #98915 - nnethercote:clarify-deriving-code, r=Mark-Simulacrum\n\nClarify deriving code\n\nA number of clarifications to the deriving code.\n\nr? ``@Mark-Simulacrum``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6812b5977bfd8c7f1643b29392e554ce46e58d", "html_url": "https://github.com/rust-lang/rust/commit/5e6812b5977bfd8c7f1643b29392e554ce46e58d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e6812b5977bfd8c7f1643b29392e554ce46e58d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd4f11dd768e7de5015b57eef6b18c1f4d31e1e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd4f11dd768e7de5015b57eef6b18c1f4d31e1e6", "html_url": "https://github.com/rust-lang/rust/commit/fd4f11dd768e7de5015b57eef6b18c1f4d31e1e6"}, {"sha": "0578697a63f3b531f6ffeb18a186eff372bf67f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0578697a63f3b531f6ffeb18a186eff372bf67f1", "html_url": "https://github.com/rust-lang/rust/commit/0578697a63f3b531f6ffeb18a186eff372bf67f1"}], "stats": {"total": 1021, "additions": 454, "deletions": 567}, "files": [{"sha": "9cd72ed0c67b272289b1d3ba3bccc6c0aa98e66f", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -80,7 +80,7 @@ pub fn expand_deriving_clone(\n             name: sym::clone,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: Vec::new(),\n+            nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n             unify_fieldless_variants: false,\n@@ -160,8 +160,8 @@ fn cs_clone(\n     let ctor_path;\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n-    let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo<'_>| {\n-        let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n+    let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo| {\n+        let args = vec![cx.expr_addr_of(field.span, field.self_expr.clone())];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n "}, {"sha": "4e798bf6acb108ea90b37332ae105f77d6c5357a", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_eq(\n             name: sym::assert_receiver_is_total_eq,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![],\n+            nonself_args: vec![],\n             ret_ty: Unit,\n             attributes: attrs,\n             unify_fieldless_variants: true,"}, {"sha": "859e995356e804e8f1ff6c13dccf44ebdf1f228c", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, MetaItem};\n+use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -28,7 +27,7 @@ pub fn expand_deriving_ord(\n             name: sym::cmp,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![(self_ref(), sym::other)],\n+            nonself_args: vec![(self_ref(), sym::other)],\n             ret_ty: Path(path_std!(cmp::Ordering)),\n             attributes: attrs,\n             unify_fieldless_variants: true,\n@@ -40,84 +39,54 @@ pub fn expand_deriving_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn ordering_collapsed(\n-    cx: &mut ExtCtxt<'_>,\n-    span: Span,\n-    self_arg_tags: &[Ident],\n-) -> P<ast::Expr> {\n-    let lft = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[0]));\n-    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n-    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n-}\n-\n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n-    let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n-\n+    let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n \n     // Builds:\n     //\n-    // match ::std::cmp::Ord::cmp(&self_field1, &other_field1) {\n-    // ::std::cmp::Ordering::Equal =>\n-    // match ::std::cmp::Ord::cmp(&self_field2, &other_field2) {\n-    // ::std::cmp::Ordering::Equal => {\n-    // ...\n+    // match ::core::cmp::Ord::cmp(&self.x, &other.x) {\n+    //     ::std::cmp::Ordering::Equal =>\n+    //         ::core::cmp::Ord::cmp(&self.y, &other.y),\n+    //     cmp => cmp,\n     // }\n-    // cmp => cmp\n-    // },\n-    // cmp => cmp\n-    // }\n-    //\n     let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_f, other_fs| {\n-            // match new {\n-            //     ::std::cmp::Ordering::Equal => old,\n-            //     cmp => cmp\n-            // }\n-            let new = {\n-                let [other_f] = other_fs else {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                };\n-                let args =\n-                    vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-                cx.expr_call_global(span, cmp_path.clone(), args)\n-            };\n-\n-            let eq_arm = cx.arm(span, cx.pat_path(span, equals_path.clone()), old);\n-            let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-\n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        |cx, args| match args {\n-            Some((span, self_f, other_fs)) => {\n-                let new = {\n-                    let [other_f] = other_fs else {\n-                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                        };\n-                    let args =\n-                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-                    cx.expr_call_global(span, cmp_path.clone(), args)\n-                };\n-\n-                new\n-            }\n-            None => cx.expr_path(equals_path.clone()),\n-        },\n-        Box::new(|cx, span, tag_tuple| {\n-            if tag_tuple.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n-            } else {\n-                ordering_collapsed(cx, span, tag_tuple)\n-            }\n-        }),\n         cx,\n         span,\n         substr,\n+        |cx, fold| match fold {\n+            CsFold::Single(field) => {\n+                let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                    };\n+                let args = vec![\n+                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n+                    cx.expr_addr_of(field.span, other_expr.clone()),\n+                ];\n+                cx.expr_call_global(field.span, cmp_path.clone(), args)\n+            }\n+            CsFold::Combine(span, expr1, expr2) => {\n+                let eq_arm = cx.arm(span, cx.pat_path(span, equal_path.clone()), expr1);\n+                let neq_arm =\n+                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+            }\n+            CsFold::Fieldless => cx.expr_path(equal_path.clone()),\n+            CsFold::EnumNonMatching(span, tag_tuple) => {\n+                if tag_tuple.len() != 2 {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n+                } else {\n+                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n+                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n+                    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n+                }\n+            }\n+        },\n     );\n     BlockOrExpr::new_expr(expr)\n }"}, {"sha": "724c639984cca33f8eff63d2f78e67edadc3c4b3", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_local, path_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{BinOpKind, Expr, MetaItem};\n+use rustc_ast::{BinOpKind, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -23,33 +22,22 @@ pub fn expand_deriving_partial_eq(\n         combiner: BinOpKind,\n         base: bool,\n     ) -> BlockOrExpr {\n-        let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n-            let [other_f] = other_fs else {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n-            };\n-\n-            cx.expr_binary(span, op, self_f, other_f.clone())\n-        };\n-\n         let expr = cs_fold(\n             true, // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let eq = op(cx, span, self_f, other_fs);\n-                cx.expr_binary(span, combiner, subexpr, eq)\n-            },\n-            |cx, args| {\n-                match args {\n-                    Some((span, self_f, other_fs)) => {\n-                        // Special-case the base case to generate cleaner code.\n-                        op(cx, span, self_f, other_fs)\n-                    }\n-                    None => cx.expr_bool(span, base),\n-                }\n-            },\n-            Box::new(|cx, span, _| cx.expr_bool(span, !base)),\n             cx,\n             span,\n             substr,\n+            |cx, fold| match fold {\n+                CsFold::Single(field) => {\n+                    let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n+                    };\n+                    cx.expr_binary(field.span, op, field.self_expr.clone(), other_expr.clone())\n+                }\n+                CsFold::Combine(span, expr1, expr2) => cx.expr_binary(span, combiner, expr1, expr2),\n+                CsFold::Fieldless => cx.expr_bool(span, base),\n+                CsFold::EnumNonMatching(span, _tag_tuple) => cx.expr_bool(span, !base),\n+            },\n         );\n         BlockOrExpr::new_expr(expr)\n     }\n@@ -69,7 +57,7 @@ pub fn expand_deriving_partial_eq(\n                 name: $name,\n                 generics: Bounds::empty(),\n                 explicit_self: true,\n-                args: vec![(self_ref(), sym::other)],\n+                nonself_args: vec![(self_ref(), sym::other)],\n                 ret_ty: Path(path_local!(bool)),\n                 attributes: attrs,\n                 unify_fieldless_variants: true,"}, {"sha": "3f9843922dad74ebf22253acd39281198ea0fa87", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 38, "deletions": 64, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, MetaItem};\n+use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -26,7 +25,7 @@ pub fn expand_deriving_partial_ord(\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n         explicit_self: true,\n-        args: vec![(self_ref(), sym::other)],\n+        nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n         unify_fieldless_variants: true,\n@@ -50,79 +49,54 @@ pub fn expand_deriving_partial_ord(\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n-    let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n-    let ordering_expr = cx.expr_path(ordering.clone());\n-\n+    let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n \n     // Builds:\n     //\n-    // match ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1) {\n-    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) =>\n-    // match ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2) {\n-    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n-    // ...\n-    // }\n-    // cmp => cmp\n-    // },\n-    // cmp => cmp\n+    // match ::core::cmp::PartialOrd::partial_cmp(&self.x, &other.x) {\n+    //     ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+    //         ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y),\n+    //     cmp => cmp,\n     // }\n-    //\n     let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_f, other_fs| {\n-            // match new {\n-            //     Some(::std::cmp::Ordering::Equal) => old,\n-            //     cmp => cmp\n-            // }\n-\n-            let new = {\n-                let [other_f] = other_fs else {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\");\n-                };\n-\n-                let args =\n-                    vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-\n-                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-            };\n-\n-            let eq_arm = cx.arm(span, cx.pat_some(span, cx.pat_path(span, ordering.clone())), old);\n-            let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-\n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        |cx: &mut ExtCtxt<'_>, args: Option<(Span, P<Expr>, &[P<Expr>])>| match args {\n-            Some((span, self_f, other_fs)) => {\n-                let new = {\n-                    let [other_f] = other_fs else {\n-                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                        };\n-                    let args =\n-                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-                };\n-\n-                new\n-            }\n-            None => cx.expr_some(span, ordering_expr.clone()),\n-        },\n-        Box::new(|cx, span, tag_tuple| {\n-            if tag_tuple.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n-                let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n-                let fn_partial_cmp_path =\n-                    cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n-                cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n-            }\n-        }),\n         cx,\n         span,\n         substr,\n+        |cx, fold| match fold {\n+            CsFold::Single(field) => {\n+                let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                    };\n+                let args = vec![\n+                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n+                    cx.expr_addr_of(field.span, other_expr.clone()),\n+                ];\n+                cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n+            }\n+            CsFold::Combine(span, expr1, expr2) => {\n+                let eq_arm =\n+                    cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n+                let neq_arm =\n+                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+            }\n+            CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n+            CsFold::EnumNonMatching(span, tag_tuple) => {\n+                if tag_tuple.len() != 2 {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                } else {\n+                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n+                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                    let fn_partial_cmp_path =\n+                        cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n+                    cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n+                }\n+            }\n+        },\n     );\n     BlockOrExpr::new_expr(expr)\n }"}, {"sha": "b99198054def8a1fde8099e8b8330a32421d8f36", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_debug(\n             name: sym::fmt,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![(fmtr, sym::f)],\n+            nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n             attributes: Vec::new(),\n             unify_fieldless_variants: false,\n@@ -53,7 +53,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let fmt = substr.nonself_args[0].clone();\n+    let fmt = substr.nonselflike_args[0].clone();\n \n     // Struct and tuples are similar enough that we use the same code for both,\n     // with some extra pieces for structs due to the field names.\n@@ -96,7 +96,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 args.push(name);\n             }\n             // Use double indirection to make sure this works for unsized types\n-            let field = cx.expr_addr_of(field.span, field.self_.clone());\n+            let field = cx.expr_addr_of(field.span, field.self_expr.clone());\n             let field = cx.expr_addr_of(field.span, field);\n             args.push(field);\n         }\n@@ -116,7 +116,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             }\n \n             // Use double indirection to make sure this works for unsized types\n-            let value_ref = cx.expr_addr_of(field.span, field.self_.clone());\n+            let value_ref = cx.expr_addr_of(field.span, field.self_expr.clone());\n             value_exprs.push(cx.expr_addr_of(field.span, value_ref));\n         }\n "}, {"sha": "d688143a2a5c622e56102406b81ca1bee70b1fbe", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -36,7 +36,10 @@ pub fn expand_deriving_rustc_decodable(\n                 )],\n             },\n             explicit_self: false,\n-            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::d)],\n+            nonself_args: vec![(\n+                Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut),\n+                sym::d,\n+            )],\n             ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n                 vec![\n@@ -63,7 +66,7 @@ fn decodable_substructure(\n     substr: &Substructure<'_>,\n     krate: Symbol,\n ) -> BlockOrExpr {\n-    let decoder = substr.nonself_args[0].clone();\n+    let decoder = substr.nonselflike_args[0].clone();\n     let recurse = vec![\n         Ident::new(krate, trait_span),\n         Ident::new(sym::Decodable, trait_span),"}, {"sha": "5177690917f21759da87a64be8c7cbcbc889602b", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_default(\n             name: kw::Default,\n             generics: Bounds::empty(),\n             explicit_self: false,\n-            args: Vec::new(),\n+            nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n             unify_fieldless_variants: false,"}, {"sha": "49dbe51f7626c720e102f5bd324f63d81e23e843", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -120,7 +120,10 @@ pub fn expand_deriving_rustc_encodable(\n                 )],\n             },\n             explicit_self: true,\n-            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::s)],\n+            nonself_args: vec![(\n+                Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut),\n+                sym::s,\n+            )],\n             ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n                 vec![\n@@ -147,7 +150,7 @@ fn encodable_substructure(\n     substr: &Substructure<'_>,\n     krate: Symbol,\n ) -> BlockOrExpr {\n-    let encoder = substr.nonself_args[0].clone();\n+    let encoder = substr.nonselflike_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = Ident::new(sym::_e, trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n@@ -165,12 +168,12 @@ fn encodable_substructure(\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n-            for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n+            for (i, &FieldInfo { name, ref self_expr, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n                     Some(id) => id.name,\n                     None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n-                let self_ref = cx.expr_addr_of(span, self_.clone());\n+                let self_ref = cx.expr_addr_of(span, self_expr.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_call_global(\n@@ -234,8 +237,8 @@ fn encodable_substructure(\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n-                for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n-                    let self_ref = cx.expr_addr_of(span, self_.clone());\n+                for (i, &FieldInfo { ref self_expr, span, .. }) in fields.iter().enumerate() {\n+                    let self_ref = cx.expr_addr_of(span, self_expr.clone());\n                     let enc =\n                         cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                     let lambda = cx.lambda1(span, enc, blkarg);"}, {"sha": "74e18bffc2ec982d13c15a30930dacccd889e260", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 339, "deletions": 391, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -227,8 +227,8 @@ pub struct MethodDef<'a> {\n     /// Is there is a `&self` argument? If not, it is a static function.\n     pub explicit_self: bool,\n \n-    /// Arguments other than the self argument\n-    pub args: Vec<(Ty, Symbol)>,\n+    /// Arguments other than the self argument.\n+    pub nonself_args: Vec<(Ty, Symbol)>,\n \n     /// Returns type\n     pub ret_ty: Ty,\n@@ -245,25 +245,24 @@ pub struct MethodDef<'a> {\n pub struct Substructure<'a> {\n     /// ident of self\n     pub type_ident: Ident,\n-    /// verbatim access to any non-self arguments\n-    pub nonself_args: &'a [P<Expr>],\n+    /// Verbatim access to any non-selflike arguments, i.e. arguments that\n+    /// don't have type `&Self`.\n+    pub nonselflike_args: &'a [P<Expr>],\n     pub fields: &'a SubstructureFields<'a>,\n }\n \n /// Summary of the relevant parts of a struct/enum field.\n-pub struct FieldInfo<'a> {\n+pub struct FieldInfo {\n     pub span: Span,\n     /// None for tuple structs/normal enum variants, Some for normal\n     /// structs/struct enum variants.\n     pub name: Option<Ident>,\n     /// The expression corresponding to this field of `self`\n     /// (specifically, a reference to it).\n-    pub self_: P<Expr>,\n+    pub self_expr: P<Expr>,\n     /// The expressions corresponding to references to this field in\n-    /// the other `Self` arguments.\n-    pub other: Vec<P<Expr>>,\n-    /// The attributes on the field\n-    pub attrs: &'a [ast::Attribute],\n+    /// the other selflike arguments.\n+    pub other_selflike_exprs: Vec<P<Expr>>,\n }\n \n /// Fields for a static method\n@@ -276,11 +275,11 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n-    Struct(&'a ast::VariantData, Vec<FieldInfo<'a>>),\n+    Struct(&'a ast::VariantData, Vec<FieldInfo>),\n     /// Matching variants of the enum: variant index, variant count, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n-    EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo<'a>>),\n+    EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo>),\n \n     /// Non-matching variants of the enum, but with all state hidden from the\n     /// consequent code. The field is a list of `Ident`s bound to the variant\n@@ -298,11 +297,6 @@ pub enum SubstructureFields<'a> {\n pub type CombineSubstructureFunc<'a> =\n     Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> BlockOrExpr + 'a>;\n \n-/// Deal with non-matching enum variants. The slice is the identifiers holding\n-/// the variant index value for each of the `Self` arguments.\n-pub type EnumNonMatchCollapsedFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &[Ident]) -> P<Expr> + 'a>;\n-\n pub fn combine_substructure(\n     f: CombineSubstructureFunc<'_>,\n ) -> RefCell<CombineSubstructureFunc<'_>> {\n@@ -782,31 +776,39 @@ impl<'a> TraitDef<'a> {\n             .methods\n             .iter()\n             .map(|method_def| {\n-                let (explicit_self, self_args, nonself_args, tys) =\n-                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+                let (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys) =\n+                    method_def.extract_arg_details(cx, self, type_ident, generics);\n \n                 let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_struct_method_body(\n                         cx,\n                         self,\n                         struct_def,\n                         type_ident,\n-                        &nonself_args,\n+                        &nonselflike_args,\n                     )\n                 } else {\n                     method_def.expand_struct_method_body(\n                         cx,\n                         self,\n                         struct_def,\n                         type_ident,\n-                        &self_args,\n-                        &nonself_args,\n+                        &selflike_args,\n+                        &nonselflike_args,\n                         use_temporaries,\n                         is_packed,\n                     )\n                 };\n \n-                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+                method_def.create_method(\n+                    cx,\n+                    self,\n+                    type_ident,\n+                    generics,\n+                    explicit_self,\n+                    nonself_arg_tys,\n+                    body,\n+                )\n             })\n             .collect();\n \n@@ -831,29 +833,37 @@ impl<'a> TraitDef<'a> {\n             .methods\n             .iter()\n             .map(|method_def| {\n-                let (explicit_self, self_args, nonself_args, tys) =\n-                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+                let (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys) =\n+                    method_def.extract_arg_details(cx, self, type_ident, generics);\n \n                 let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_enum_method_body(\n                         cx,\n                         self,\n                         enum_def,\n                         type_ident,\n-                        &nonself_args,\n+                        &nonselflike_args,\n                     )\n                 } else {\n                     method_def.expand_enum_method_body(\n                         cx,\n                         self,\n                         enum_def,\n                         type_ident,\n-                        self_args,\n-                        &nonself_args,\n+                        selflike_args,\n+                        &nonselflike_args,\n                     )\n                 };\n \n-                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+                method_def.create_method(\n+                    cx,\n+                    self,\n+                    type_ident,\n+                    generics,\n+                    explicit_self,\n+                    nonself_arg_tys,\n+                    body,\n+                )\n             })\n             .collect();\n \n@@ -867,11 +877,11 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n-        let substructure = Substructure { type_ident, nonself_args, fields };\n+        let substructure = Substructure { type_ident, nonselflike_args, fields };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n         f(cx, span, &substructure)\n@@ -891,49 +901,51 @@ impl<'a> MethodDef<'a> {\n         !self.explicit_self\n     }\n \n-    fn split_self_nonself_args(\n+    // The return value includes:\n+    // - explicit_self: The `&self` arg, if present.\n+    // - selflike_args: Expressions for `&self` (if present) and also any other\n+    //   args with the same type (e.g. the `other` arg in `PartialEq::eq`).\n+    // - nonselflike_args: Expressions for all the remaining args.\n+    // - nonself_arg_tys: Additional information about all the args other than\n+    //   `&self`.\n+    fn extract_arg_details(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n         generics: &Generics,\n     ) -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n-        let mut self_args = Vec::new();\n-        let mut nonself_args = Vec::new();\n-        let mut arg_tys = Vec::new();\n+        let mut selflike_args = Vec::new();\n+        let mut nonselflike_args = Vec::new();\n+        let mut nonself_arg_tys = Vec::new();\n         let span = trait_.span;\n \n-        let ast_explicit_self = if self.explicit_self {\n+        let explicit_self = if self.explicit_self {\n             let (self_expr, explicit_self) = ty::get_explicit_self(cx, span);\n-            self_args.push(self_expr);\n+            selflike_args.push(self_expr);\n             Some(explicit_self)\n         } else {\n             None\n         };\n \n-        for (ty, name) in self.args.iter() {\n+        for (ty, name) in self.nonself_args.iter() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n             let ident = Ident::new(*name, span);\n-            arg_tys.push((ident, ast_ty));\n+            nonself_arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(span, ident);\n \n-            match *ty {\n-                // for static methods, just treat any Self\n-                // arguments as a normal arg\n-                Self_ if !self.is_static() => {\n-                    self_args.push(arg_expr);\n-                }\n-                Ref(ref ty, _) if matches!(**ty, Self_) && !self.is_static() => {\n-                    self_args.push(cx.expr_deref(span, arg_expr))\n-                }\n-                _ => {\n-                    nonself_args.push(arg_expr);\n+            match ty {\n+                // Selflike (`&Self`) arguments only occur in non-static methods.\n+                Ref(box Self_, _) if !self.is_static() => {\n+                    selflike_args.push(cx.expr_deref(span, arg_expr))\n                 }\n+                Self_ => cx.span_bug(span, \"`Self` in non-return position\"),\n+                _ => nonselflike_args.push(arg_expr),\n             }\n         }\n \n-        (ast_explicit_self, self_args, nonself_args, arg_tys)\n+        (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys)\n     }\n \n     fn create_method(\n@@ -943,20 +955,21 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         explicit_self: Option<ast::ExplicitSelf>,\n-        arg_types: Vec<(Ident, P<ast::Ty>)>,\n+        nonself_arg_tys: Vec<(Ident, P<ast::Ty>)>,\n         body: BlockOrExpr,\n     ) -> P<ast::AssocItem> {\n         let span = trait_.span;\n         // Create the generics that aren't for `Self`.\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = {\n-            let self_args = explicit_self.map(|explicit_self| {\n+            let self_arg = explicit_self.map(|explicit_self| {\n                 let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(span);\n                 ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n             });\n-            let nonself_args = arg_types.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n-            self_args.into_iter().chain(nonself_args).collect()\n+            let nonself_args =\n+                nonself_arg_tys.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n+            self_arg.into_iter().chain(nonself_args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n@@ -1024,76 +1037,50 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'b>,\n         struct_def: &'b VariantData,\n         type_ident: Ident,\n-        self_args: &[P<Expr>],\n-        nonself_args: &[P<Expr>],\n+        selflike_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n         use_temporaries: bool,\n         is_packed: bool,\n     ) -> BlockOrExpr {\n-        let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n         let span = trait_.span;\n-        let mut patterns = Vec::new();\n-\n-        for (i, self_arg) in self_args.iter().enumerate() {\n-            let ident_exprs = if !is_packed {\n-                trait_.create_struct_field_accesses(cx, self_arg, struct_def)\n-            } else {\n-                // Get the pattern for the let-destructuring.\n-                //\n-                // We could use `type_ident` instead of `Self`, but in the case of a type parameter\n-                // shadowing the struct name, that causes a second, unnecessary E0578 error. #97343\n-                let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-                let (pat, ident_exprs) = trait_.create_struct_pattern(\n-                    cx,\n-                    struct_path,\n-                    struct_def,\n-                    &format!(\"__self_{}\", i),\n-                    ast::Mutability::Not,\n-                    use_temporaries,\n-                );\n-                patterns.push(pat);\n-                ident_exprs\n-            };\n-            raw_fields.push(ident_exprs);\n-        }\n-\n-        // transpose raw_fields\n-        let fields = if !raw_fields.is_empty() {\n-            let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n-            let first_field = raw_fields.next().unwrap();\n-            let mut other_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n-            first_field\n-                .map(|(span, opt_id, field, attrs)| FieldInfo {\n-                    span: span.with_ctxt(trait_.span.ctxt()),\n-                    name: opt_id,\n-                    self_: field,\n-                    other: other_fields\n-                        .iter_mut()\n-                        .map(|l| {\n-                            let (.., ex, _) = l.next().unwrap();\n-                            ex\n-                        })\n-                        .collect(),\n-                    attrs,\n-                })\n-                .collect()\n-        } else {\n-            cx.span_bug(span, \"no `self` parameter for method in generic `derive`\")\n+        assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n+\n+        let mk_body = |cx, selflike_fields| {\n+            self.call_substructure_method(\n+                cx,\n+                trait_,\n+                type_ident,\n+                nonselflike_args,\n+                &Struct(struct_def, selflike_fields),\n+            )\n         };\n \n-        let mut body = self.call_substructure_method(\n-            cx,\n-            trait_,\n-            type_ident,\n-            nonself_args,\n-            &Struct(struct_def, fields),\n-        );\n-\n         if !is_packed {\n-            body\n+            let selflike_fields =\n+                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def);\n+            mk_body(cx, selflike_fields)\n         } else {\n+            let prefixes: Vec<_> =\n+                (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n+            let selflike_fields =\n+                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, use_temporaries);\n+            let mut body = mk_body(cx, selflike_fields);\n+\n+            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n+            let patterns = trait_.create_struct_patterns(\n+                cx,\n+                struct_path,\n+                struct_def,\n+                &prefixes,\n+                ast::Mutability::Not,\n+                use_temporaries,\n+            );\n+\n             // Do the let-destructuring.\n-            let mut stmts: Vec<_> = iter::zip(self_args, patterns)\n-                .map(|(arg_expr, pat)| cx.stmt_let_pat(span, pat, arg_expr.clone()))\n+            let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n+                .map(|(selflike_arg_expr, pat)| {\n+                    cx.stmt_let_pat(span, pat, selflike_arg_expr.clone())\n+                })\n                 .collect();\n             stmts.extend(std::mem::take(&mut body.0));\n             BlockOrExpr(stmts, body.1)\n@@ -1106,15 +1093,15 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         struct_def: &VariantData,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(\n             cx,\n             trait_,\n             type_ident,\n-            nonself_args,\n+            nonselflike_args,\n             &StaticStruct(struct_def, summary),\n         )\n     }\n@@ -1148,7 +1135,7 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    /// Creates a match for a tuple of all `self_args`, where either all\n+    /// Creates a match for a tuple of all `selflike_args`, where either all\n     /// variants match, or it falls into a catch-all for when one variant\n     /// does not match.\n     ///\n@@ -1161,33 +1148,33 @@ impl<'a> MethodDef<'a> {\n     /// a simple equality check (for PartialEq).\n     ///\n     /// The catch-all handler is provided access the variant index values\n-    /// for each of the self-args, carried in precomputed variables.\n+    /// for each of the selflike_args, carried in precomputed variables.\n     fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n         type_ident: Ident,\n-        mut self_args: Vec<P<Expr>>,\n-        nonself_args: &[P<Expr>],\n+        mut selflike_args: Vec<P<Expr>>,\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n         let variants = &enum_def.variants;\n \n-        let self_arg_names = iter::once(\"__self\".to_string())\n+        let prefixes = iter::once(\"__self\".to_string())\n             .chain(\n-                self_args\n+                selflike_args\n                     .iter()\n                     .enumerate()\n                     .skip(1)\n-                    .map(|(arg_count, _self_arg)| format!(\"__arg_{}\", arg_count)),\n+                    .map(|(arg_count, _selflike_arg)| format!(\"__arg_{}\", arg_count)),\n             )\n             .collect::<Vec<String>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each self_arg to an int\n+        // a series of let statements mapping each selflike_arg to an int\n         // value corresponding to its discriminant.\n-        let vi_idents = self_arg_names\n+        let vi_idents = prefixes\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", name);\n@@ -1206,37 +1193,38 @@ impl<'a> MethodDef<'a> {\n         // (Variant1, Variant1, ...) => Body1\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n-        // where each tuple has length = self_args.len()\n+        // where each tuple has length = selflike_args.len()\n+\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n             .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n-                let mk_self_pat = |cx: &mut ExtCtxt<'_>, self_arg_name: &str| {\n-                    let (p, idents) = trait_.create_enum_variant_pattern(\n-                        cx,\n-                        type_ident,\n-                        variant,\n-                        self_arg_name,\n-                        ast::Mutability::Not,\n-                    );\n-                    (cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)), idents)\n-                };\n-\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n-                let mut subpats = Vec::with_capacity(self_arg_names.len());\n-                let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n-                let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0]);\n-                    subpats.push(p);\n-                    idents\n-                };\n-                for self_arg_name in &self_arg_names[1..] {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_name);\n-                    subpats.push(p);\n-                    self_pats_idents.push(idents);\n-                }\n+\n+                let use_temporaries = false; // enums can't be repr(packed)\n+                let fields = trait_.create_struct_pattern_fields(\n+                    cx,\n+                    &variant.data,\n+                    &prefixes,\n+                    use_temporaries,\n+                );\n+\n+                let sp = variant.span.with_ctxt(trait_.span.ctxt());\n+                let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n+                let mut subpats: Vec<_> = trait_\n+                    .create_struct_patterns(\n+                        cx,\n+                        variant_path,\n+                        &variant.data,\n+                        &prefixes,\n+                        ast::Mutability::Not,\n+                        use_temporaries,\n+                    )\n+                    .into_iter()\n+                    .map(|p| cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)))\n+                    .collect();\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n                 let single_pat = if subpats.len() == 1 {\n@@ -1248,57 +1236,20 @@ impl<'a> MethodDef<'a> {\n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case\n                 // we are in.\n-\n-                // All of the Self args have the same variant in these\n-                // cases.  So we transpose the info in self_pats_idents\n-                // to gather the getter expressions together, in the\n-                // form that EnumMatching expects.\n-\n-                // The transposition is driven by walking across the\n-                // arg fields of the variant for the first self pat.\n-                let field_tuples = first_self_pat_idents\n-                    .into_iter()\n-                    .enumerate()\n-                    // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, (span, opt_ident, self_getter_expr, attrs))| {\n-                        // ... but FieldInfo also wants getter expr\n-                        // for matching other arguments of Self type;\n-                        // so walk across the *other* self_pats_idents\n-                        // and pull out getter for same field in each\n-                        // of them (using `field_index` tracked above).\n-                        // That is the heart of the transposition.\n-                        let others = self_pats_idents\n-                            .iter()\n-                            .map(|fields| {\n-                                let (_, _opt_ident, ref other_getter_expr, _) = fields[field_index];\n-\n-                                // All Self args have same variant, so\n-                                // opt_idents are the same.  (Assert\n-                                // here to make it self-evident that\n-                                // it is okay to ignore `_opt_ident`.)\n-                                assert!(opt_ident == _opt_ident);\n-\n-                                other_getter_expr.clone()\n-                            })\n-                            .collect::<Vec<P<Expr>>>();\n-\n-                        FieldInfo {\n-                            span,\n-                            name: opt_ident,\n-                            self_: self_getter_expr,\n-                            other: others,\n-                            attrs,\n-                        }\n-                    })\n-                    .collect::<Vec<FieldInfo<'_>>>();\n-\n+                //\n                 // Now, for some given VariantK, we have built up\n                 // expressions for referencing every field of every\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n-                let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n+                let substructure = EnumMatching(index, variants.len(), variant, fields);\n                 let arm_expr = self\n-                    .call_substructure_method(cx, trait_, type_ident, nonself_args, &substructure)\n+                    .call_substructure_method(\n+                        cx,\n+                        trait_,\n+                        type_ident,\n+                        nonselflike_args,\n+                        &substructure,\n+                    )\n                     .into_expr(cx, span);\n \n                 cx.arm(span, single_pat, arm_expr)\n@@ -1316,13 +1267,13 @@ impl<'a> MethodDef<'a> {\n                         cx,\n                         trait_,\n                         type_ident,\n-                        nonself_args,\n+                        nonselflike_args,\n                         &substructure,\n                     )\n                     .into_expr(cx, span),\n                 )\n             }\n-            _ if variants.len() > 1 && self_args.len() > 1 => {\n+            _ if variants.len() > 1 && selflike_args.len() > 1 => {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n@@ -1349,8 +1300,8 @@ impl<'a> MethodDef<'a> {\n         //   catch-all `_` match, it would trigger the\n         //   unreachable-pattern error.\n         //\n-        if variants.len() > 1 && self_args.len() > 1 {\n-            // Build a series of let statements mapping each self_arg\n+        if variants.len() > 1 && selflike_args.len() > 1 {\n+            // Build a series of let statements mapping each selflike_arg\n             // to its discriminant value.\n             //\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n@@ -1365,10 +1316,14 @@ impl<'a> MethodDef<'a> {\n             // We also build an expression which checks whether all discriminants are equal:\n             // `__self_vi == __arg_1_vi && __self_vi == __arg_2_vi && ...`\n             let mut discriminant_test = cx.expr_bool(span, true);\n-            for (i, (&ident, self_arg)) in iter::zip(&vi_idents, &self_args).enumerate() {\n-                let self_addr = cx.expr_addr_of(span, self_arg.clone());\n-                let variant_value =\n-                    deriving::call_intrinsic(cx, span, sym::discriminant_value, vec![self_addr]);\n+            for (i, (&ident, selflike_arg)) in iter::zip(&vi_idents, &selflike_args).enumerate() {\n+                let selflike_addr = cx.expr_addr_of(span, selflike_arg.clone());\n+                let variant_value = deriving::call_intrinsic(\n+                    cx,\n+                    span,\n+                    sym::discriminant_value,\n+                    vec![selflike_addr],\n+                );\n                 let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n@@ -1389,18 +1344,18 @@ impl<'a> MethodDef<'a> {\n                     cx,\n                     trait_,\n                     type_ident,\n-                    nonself_args,\n+                    nonselflike_args,\n                     &catch_all_substructure,\n                 )\n                 .into_expr(cx, span);\n \n-            // Final wrinkle: the self_args are expressions that deref\n+            // Final wrinkle: the selflike_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n+            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n+            let match_arg = cx.expr(span, ast::ExprKind::Tup(selflike_args));\n \n             // Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1418,67 +1373,21 @@ impl<'a> MethodDef<'a> {\n             let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));\n             BlockOrExpr(index_let_stmts, Some(arm_expr))\n         } else if variants.is_empty() {\n-            // As an additional wrinkle, For a zero-variant enum A,\n-            // currently the compiler\n-            // will accept `fn (a: &Self) { match   *a   { } }`\n-            // but rejects `fn (a: &Self) { match (&*a,) { } }`\n-            // as well as  `fn (a: &Self) { match ( *a,) { } }`\n-            //\n-            // This means that the strategy of building up a tuple of\n-            // all Self arguments fails when Self is a zero variant\n-            // enum: rustc rejects the expanded program, even though\n-            // the actual code tends to be impossible to execute (at\n-            // least safely), according to the type system.\n-            //\n-            // The most expedient fix for this is to just let the\n-            // code fall through to the catch-all.  But even this is\n-            // error-prone, since the catch-all as defined above would\n-            // generate code like this:\n-            //\n-            //     _ => { let __self0 = match *self { };\n-            //            let __self1 = match *__arg_0 { };\n-            //            <catch-all-expr> }\n-            //\n-            // Which is yields bindings for variables which type\n-            // inference cannot resolve to unique types.\n-            //\n-            // One option to the above might be to add explicit type\n-            // annotations.  But the *only* reason to go down that path\n-            // would be to try to make the expanded output consistent\n-            // with the case when the number of enum variants >= 1.\n-            //\n-            // That just isn't worth it.  In fact, trying to generate\n-            // sensible code for *any* deriving on a zero-variant enum\n-            // does not make sense.  But at the same time, for now, we\n-            // do not want to cause a compile failure just because the\n-            // user happened to attach a deriving to their\n-            // zero-variant enum.\n-            //\n-            // Instead, just generate a failing expression for the\n-            // zero variant case, skipping matches and also skipping\n-            // delegating back to the end user code entirely.\n-            //\n-            // (See also #4499 and #12609; note that some of the\n-            // discussions there influence what choice we make here;\n-            // e.g., if we feature-gate `match x { ... }` when x refers\n-            // to an uninhabited type (e.g., a zero-variant enum or a\n-            // type holding such an enum), but do not feature-gate\n-            // zero-variant enums themselves, then attempting to\n-            // derive Debug on such a type could here generate code\n-            // that needs the feature gate enabled.)\n-\n+            // There is no sensible code to be generated for *any* deriving on\n+            // a zero-variant enum. So we just generate a failing expression\n+            // for the zero variant case.\n             BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)))\n         } else {\n-            // Final wrinkle: the self_args are expressions that deref\n+            // Final wrinkle: the selflike_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = if self_args.len() == 1 {\n-                self_args.pop().unwrap()\n+            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n+            let match_arg = if selflike_args.len() == 1 {\n+                selflike_args.pop().unwrap()\n             } else {\n-                cx.expr(span, ast::ExprKind::Tup(self_args))\n+                cx.expr(span, ast::ExprKind::Tup(selflike_args))\n             };\n             BlockOrExpr(vec![], Some(cx.expr_match(span, match_arg, match_arms)))\n         }\n@@ -1490,7 +1399,7 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         enum_def: &EnumDef,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let summary = enum_def\n             .variants\n@@ -1505,7 +1414,7 @@ impl<'a> MethodDef<'a> {\n             cx,\n             trait_,\n             type_ident,\n-            nonself_args,\n+            nonselflike_args,\n             &StaticEnum(enum_def, summary),\n         )\n     }\n@@ -1538,170 +1447,209 @@ impl<'a> TraitDef<'a> {\n         }\n     }\n \n-    fn create_subpatterns(\n+    fn create_struct_patterns(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        field_paths: Vec<Ident>,\n+        struct_path: ast::Path,\n+        struct_def: &'a VariantData,\n+        prefixes: &[String],\n         mutbl: ast::Mutability,\n         use_temporaries: bool,\n     ) -> Vec<P<ast::Pat>> {\n-        field_paths\n+        prefixes\n             .iter()\n-            .map(|path| {\n-                let binding_mode = if use_temporaries {\n-                    ast::BindingMode::ByValue(ast::Mutability::Not)\n-                } else {\n-                    ast::BindingMode::ByRef(mutbl)\n-                };\n-                cx.pat(path.span, PatKind::Ident(binding_mode, *path, None))\n+            .map(|prefix| {\n+                let pieces_iter =\n+                    struct_def.fields().iter().enumerate().map(|(i, struct_field)| {\n+                        let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+                        let binding_mode = if use_temporaries {\n+                            ast::BindingMode::ByValue(ast::Mutability::Not)\n+                        } else {\n+                            ast::BindingMode::ByRef(mutbl)\n+                        };\n+                        let ident = self.mk_pattern_ident(prefix, i);\n+                        let path = ident.with_span_pos(sp);\n+                        (\n+                            sp,\n+                            struct_field.ident,\n+                            cx.pat(path.span, PatKind::Ident(binding_mode, path, None)),\n+                        )\n+                    });\n+\n+                let struct_path = struct_path.clone();\n+                match *struct_def {\n+                    VariantData::Struct(..) => {\n+                        let field_pats = pieces_iter\n+                            .map(|(sp, ident, pat)| {\n+                                if ident.is_none() {\n+                                    cx.span_bug(\n+                                        sp,\n+                                        \"a braced struct with unnamed fields in `derive`\",\n+                                    );\n+                                }\n+                                ast::PatField {\n+                                    ident: ident.unwrap(),\n+                                    is_shorthand: false,\n+                                    attrs: ast::AttrVec::new(),\n+                                    id: ast::DUMMY_NODE_ID,\n+                                    span: pat.span.with_ctxt(self.span.ctxt()),\n+                                    pat,\n+                                    is_placeholder: false,\n+                                }\n+                            })\n+                            .collect();\n+                        cx.pat_struct(self.span, struct_path, field_pats)\n+                    }\n+                    VariantData::Tuple(..) => {\n+                        let subpats = pieces_iter.map(|(_, _, subpat)| subpat).collect();\n+                        cx.pat_tuple_struct(self.span, struct_path, subpats)\n+                    }\n+                    VariantData::Unit(..) => cx.pat_path(self.span, struct_path),\n+                }\n             })\n             .collect()\n     }\n \n-    fn create_struct_pattern(\n-        &self,\n-        cx: &mut ExtCtxt<'_>,\n-        struct_path: ast::Path,\n-        struct_def: &'a VariantData,\n-        prefix: &str,\n-        mutbl: ast::Mutability,\n-        use_temporaries: bool,\n-    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n-        let mut paths = Vec::new();\n-        let mut ident_exprs = Vec::new();\n-        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n-            paths.push(ident.with_span_pos(sp));\n-            let val = cx.expr_path(cx.path_ident(sp, ident));\n-            let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };\n-            ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n-        }\n-\n-        let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n-        let pattern = match *struct_def {\n-            VariantData::Struct(..) => {\n-                let field_pats = iter::zip(subpats, &ident_exprs)\n-                    .map(|(pat, &(sp, ident, ..))| {\n-                        if ident.is_none() {\n-                            cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n-                        }\n-                        ast::PatField {\n-                            ident: ident.unwrap(),\n-                            is_shorthand: false,\n-                            attrs: ast::AttrVec::new(),\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: pat.span.with_ctxt(self.span.ctxt()),\n-                            pat,\n-                            is_placeholder: false,\n-                        }\n-                    })\n-                    .collect();\n-                cx.pat_struct(self.span, struct_path, field_pats)\n-            }\n-            VariantData::Tuple(..) => cx.pat_tuple_struct(self.span, struct_path, subpats),\n-            VariantData::Unit(..) => cx.pat_path(self.span, struct_path),\n-        };\n+    fn create_fields<F>(&self, struct_def: &'a VariantData, mk_exprs: F) -> Vec<FieldInfo>\n+    where\n+        F: Fn(usize, &ast::FieldDef, Span) -> Vec<P<ast::Expr>>,\n+    {\n+        struct_def\n+            .fields()\n+            .iter()\n+            .enumerate()\n+            .map(|(i, struct_field)| {\n+                // For this field, get an expr for each selflike_arg. E.g. for\n+                // `PartialEq::eq`, one for each of `&self` and `other`.\n+                let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+                let mut exprs: Vec<_> = mk_exprs(i, struct_field, sp);\n+                let self_expr = exprs.remove(0);\n+                let other_selflike_exprs = exprs;\n+                FieldInfo {\n+                    span: sp.with_ctxt(self.span.ctxt()),\n+                    name: struct_field.ident,\n+                    self_expr,\n+                    other_selflike_exprs,\n+                }\n+            })\n+            .collect()\n+    }\n \n-        (pattern, ident_exprs)\n+    fn mk_pattern_ident(&self, prefix: &str, i: usize) -> Ident {\n+        Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span)\n     }\n \n-    fn create_struct_field_accesses(\n+    fn create_struct_pattern_fields(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        mut self_arg: &P<Expr>,\n         struct_def: &'a VariantData,\n-    ) -> Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])> {\n-        let mut ident_exprs = Vec::new();\n-        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-\n-            // We don't the need the deref, if there is one.\n-            if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &self_arg.kind {\n-                self_arg = inner;\n-            }\n-\n-            // Note: we must use `struct_field.span` rather than `span` in the\n-            // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n-            // \"field `0` of struct `Point` is private\" errors on tuple\n-            // structs.\n-            let val = cx.expr(\n-                sp,\n-                ast::ExprKind::Field(\n-                    self_arg.clone(),\n-                    struct_field.ident.unwrap_or_else(|| {\n-                        Ident::from_str_and_span(&i.to_string(), struct_field.span)\n-                    }),\n-                ),\n-            );\n-            ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n-        }\n-        ident_exprs\n+        prefixes: &[String],\n+        use_temporaries: bool,\n+    ) -> Vec<FieldInfo> {\n+        self.create_fields(struct_def, |i, _struct_field, sp| {\n+            prefixes\n+                .iter()\n+                .map(|prefix| {\n+                    let ident = self.mk_pattern_ident(prefix, i);\n+                    let expr = cx.expr_path(cx.path_ident(sp, ident));\n+                    if use_temporaries { expr } else { cx.expr_deref(sp, expr) }\n+                })\n+                .collect()\n+        })\n     }\n \n-    fn create_enum_variant_pattern(\n+    fn create_struct_field_access_fields(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        enum_ident: Ident,\n-        variant: &'a ast::Variant,\n-        prefix: &str,\n-        mutbl: ast::Mutability,\n-    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n-        let sp = variant.span.with_ctxt(self.span.ctxt());\n-        let variant_path = cx.path(sp, vec![enum_ident, variant.ident]);\n-        let use_temporaries = false; // enums can't be repr(packed)\n-        self.create_struct_pattern(cx, variant_path, &variant.data, prefix, mutbl, use_temporaries)\n+        selflike_args: &[P<Expr>],\n+        struct_def: &'a VariantData,\n+    ) -> Vec<FieldInfo> {\n+        self.create_fields(struct_def, |i, struct_field, sp| {\n+            selflike_args\n+                .iter()\n+                .map(|mut selflike_arg| {\n+                    // We don't the need the deref, if there is one.\n+                    if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &selflike_arg.kind {\n+                        selflike_arg = inner;\n+                    }\n+                    // Note: we must use `struct_field.span` rather than `span` in the\n+                    // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n+                    // \"field `0` of struct `Point` is private\" errors on tuple\n+                    // structs.\n+                    cx.expr(\n+                        sp,\n+                        ast::ExprKind::Field(\n+                            selflike_arg.clone(),\n+                            struct_field.ident.unwrap_or_else(|| {\n+                                Ident::from_str_and_span(&i.to_string(), struct_field.span)\n+                            }),\n+                        ),\n+                    )\n+                })\n+                .collect()\n+        })\n     }\n }\n \n-/// Function to fold over fields, with three cases, to generate more efficient and concise code.\n-/// When the `substructure` has grouped fields, there are two cases:\n-/// Zero fields: call the base case function with `None` (like the usual base case of `cs_fold`).\n-/// One or more fields: call the base case function on the first value (which depends on\n-/// `use_fold`), and use that as the base case. Then perform `cs_fold` on the remainder of the\n-/// fields.\n-/// When the `substructure` is an `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n-/// is returned. Statics may not be folded over.\n-pub fn cs_fold<F, B>(\n+/// The function passed to `cs_fold` is called repeatedly with a value of this\n+/// type. It describes one part of the code generation. The result is always an\n+/// expression.\n+pub enum CsFold<'a> {\n+    /// The basic case: a field expression for one or more selflike args. E.g.\n+    /// for `PartialEq::eq` this is something like `self.x == other.x`.\n+    Single(&'a FieldInfo),\n+\n+    /// The combination of two field expressions. E.g. for `PartialEq::eq` this\n+    /// is something like `<field1 equality> && <field2 equality>`.\n+    Combine(Span, P<Expr>, P<Expr>),\n+\n+    // The fallback case for a struct or enum variant with no fields.\n+    Fieldless,\n+\n+    /// The fallback case for non-matching enum variants. The slice is the\n+    /// identifiers holding the variant index value for each of the `Self`\n+    /// arguments.\n+    EnumNonMatching(Span, &'a [Ident]),\n+}\n+\n+/// Folds over fields, combining the expressions for each field in a sequence.\n+/// Statics may not be folded over.\n+pub fn cs_fold<F>(\n     use_foldl: bool,\n-    mut f: F,\n-    mut b: B,\n-    mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substructure: &Substructure<'_>,\n+    mut f: F,\n ) -> P<Expr>\n where\n-    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n-    B: FnMut(&mut ExtCtxt<'_>, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>,\n+    F: FnMut(&mut ExtCtxt<'_>, CsFold<'_>) -> P<Expr>,\n {\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n-            let (base, rest) = match (all_fields.is_empty(), use_foldl) {\n-                (false, true) => {\n-                    let (first, rest) = all_fields.split_first().unwrap();\n-                    let args = (first.span, first.self_.clone(), &first.other[..]);\n-                    (b(cx, Some(args)), rest)\n-                }\n-                (false, false) => {\n-                    let (last, rest) = all_fields.split_last().unwrap();\n-                    let args = (last.span, last.self_.clone(), &last.other[..]);\n-                    (b(cx, Some(args)), rest)\n-                }\n-                (true, _) => (b(cx, None), &all_fields[..]),\n+            if all_fields.is_empty() {\n+                return f(cx, CsFold::Fieldless);\n+            }\n+\n+            let (base_field, rest) = if use_foldl {\n+                all_fields.split_first().unwrap()\n+            } else {\n+                all_fields.split_last().unwrap()\n+            };\n+\n+            let base_expr = f(cx, CsFold::Single(base_field));\n+\n+            let op = |old, field: &FieldInfo| {\n+                let new = f(cx, CsFold::Single(field));\n+                f(cx, CsFold::Combine(field.span, old, new))\n             };\n \n             if use_foldl {\n-                rest.iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n+                rest.iter().fold(base_expr, op)\n             } else {\n-                rest.iter().rev().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n+                rest.iter().rfold(base_expr, op)\n             }\n         }\n-        EnumNonMatchingCollapsed(tuple) => enum_nonmatch_f(cx, trait_span, tuple),\n+        EnumNonMatchingCollapsed(tuple) => f(cx, CsFold::EnumNonMatching(trait_span, tuple)),\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }"}, {"sha": "2213cd6d37d2d9c80177b3f1c8692be2876e805c", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6812b5977bfd8c7f1643b29392e554ce46e58d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=5e6812b5977bfd8c7f1643b29392e554ce46e58d", "patch": "@@ -30,7 +30,7 @@ pub fn expand_deriving_hash(\n             name: sym::hash,\n             generics: Bounds { bounds: vec![(typaram, vec![path_std!(hash::Hasher)])] },\n             explicit_self: true,\n-            args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n+            nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n             attributes: vec![],\n             unify_fieldless_variants: true,\n@@ -49,7 +49,7 @@ fn hash_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n ) -> BlockOrExpr {\n-    let [state_expr] = substr.nonself_args else {\n+    let [state_expr] = substr.nonselflike_args else {\n         cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\");\n     };\n     let call_hash = |span, thing_expr| {\n@@ -82,7 +82,9 @@ fn hash_substructure(\n     };\n \n     stmts.extend(\n-        fields.iter().map(|FieldInfo { ref self_, span, .. }| call_hash(*span, self_.clone())),\n+        fields\n+            .iter()\n+            .map(|FieldInfo { ref self_expr, span, .. }| call_hash(*span, self_expr.clone())),\n     );\n     BlockOrExpr::new_stmts(stmts)\n }"}]}