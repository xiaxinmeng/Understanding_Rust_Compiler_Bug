{"sha": "f77cabecbba8d842cd944b064065ad4e6a6b760d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3N2NhYmVjYmJhOGQ4NDJjZDk0NGIwNjQwNjVhZDRlNmE2Yjc2MGQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-11T23:47:46Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-12T20:35:56Z"}, "message": "Deprecation fallout in libcollections", "tree": {"sha": "a04a154f46f5876a741a377fd5aca2c2eb9b3a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a04a154f46f5876a741a377fd5aca2c2eb9b3a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f77cabecbba8d842cd944b064065ad4e6a6b760d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f77cabecbba8d842cd944b064065ad4e6a6b760d", "html_url": "https://github.com/rust-lang/rust/commit/f77cabecbba8d842cd944b064065ad4e6a6b760d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f77cabecbba8d842cd944b064065ad4e6a6b760d/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b5204f55efd9e25425055264d44f28501c0439b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5204f55efd9e25425055264d44f28501c0439b", "html_url": "https://github.com/rust-lang/rust/commit/0b5204f55efd9e25425055264d44f28501c0439b"}], "stats": {"total": 83, "additions": 43, "deletions": 40}, "files": [{"sha": "7745a0d887ee8ad7281087ea5b14b8dc6fe5e437", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -264,7 +264,7 @@ impl Bitv {\n         assert!(i < self.nbits);\n         let w = i / uint::BITS;\n         let b = i % uint::BITS;\n-        let x = self.storage.get(w) & (1 << b);\n+        let x = self.storage[w] & (1 << b);\n         x != 0\n     }\n \n@@ -289,8 +289,8 @@ impl Bitv {\n         let w = i / uint::BITS;\n         let b = i % uint::BITS;\n         let flag = 1 << b;\n-        *self.storage.get_mut(w) = if x { *self.storage.get(w) | flag }\n-                          else { *self.storage.get(w) & !flag };\n+        *self.storage.get_mut(w) = if x { self.storage[w] | flag }\n+                          else { self.storage[w] & !flag };\n     }\n \n     /// Set all bits to 1.\n@@ -827,7 +827,7 @@ impl Clone for Bitv {\n     fn clone_from(&mut self, source: &Bitv) {\n         self.nbits = source.nbits;\n         self.storage.reserve(source.storage.len());\n-        for (i, w) in self.storage.mut_iter().enumerate() { *w = *source.storage.get(i); }\n+        for (i, w) in self.storage.mut_iter().enumerate() { *w = source.storage[i]; }\n     }\n }\n \n@@ -1146,7 +1146,7 @@ impl BitvSet {\n         self_bitv.reserve(other_bitv.capacity());\n         // Apply values\n         for (i, w) in other_bitv.mask_words(0) {\n-            let old = *self_bitv.storage.get(i);\n+            let old = self_bitv.storage[i];\n             let new = f(old, w);\n             *self_bitv.storage.get_mut(i) = new;\n         }\n@@ -1573,10 +1573,10 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n                 // one Bitv might be longer than the other\n                 let word_idx = self.next_idx / uint::BITS;\n                 let w1 = if word_idx < s_bitv.storage.len() {\n-                             *s_bitv.storage.get(word_idx)\n+                             s_bitv.storage[word_idx]\n                          } else { 0 };\n                 let w2 = if word_idx < o_bitv.storage.len() {\n-                             *o_bitv.storage.get(word_idx)\n+                             o_bitv.storage[word_idx]\n                          } else { 0 };\n                 self.current_word = (self.merge)(w1, w2);\n             }"}, {"sha": "4c5f8ef09879e06ee898940db4de26278c771ec4", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -299,14 +299,14 @@ impl<K: Ord, V> Leaf<K, V> {\n             midpoint = 0;\n         }\n         loop {\n-            let order = self.elts.get(midpoint).key.cmp(&k);\n+            let order = self.elts[midpoint].key.cmp(&k);\n             match order {\n                 Equal => {\n                     return None;\n                 }\n                 Greater => {\n                     if midpoint > 0 {\n-                        if self.elts.get(midpoint - 1).key.cmp(&k) == Less {\n+                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -322,7 +322,7 @@ impl<K: Ord, V> Leaf<K, V> {\n                 }\n                 Less => {\n                     if midpoint + 1 < self.elts.len() {\n-                        if self.elts.get(midpoint + 1).key.cmp(&k) == Greater {\n+                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -422,7 +422,7 @@ impl<K: Ord, V: Eq> Ord for Leaf<K, V> {\n         if self.elts.len() < other.elts.len() {\n             return Less;\n         }\n-        self.elts.get(0).cmp(other.elts.get(0))\n+        self.elts[0].cmp(&other.elts[0])\n     }\n }\n \n@@ -457,14 +457,14 @@ impl<K: Ord, V> Branch<K, V> {\n             midpoint = 0u;\n         }\n         loop {\n-            let order = self.elts.get(midpoint).key.cmp(&k);\n+            let order = self.elts[midpoint].key.cmp(&k);\n             match order {\n                 Equal => {\n                     return None;\n                 }\n                 Greater => {\n                     if midpoint > 0 {\n-                        if self.elts.get(midpoint - 1).key.cmp(&k) == Less {\n+                        if self.elts[midpoint - 1].key.cmp(&k) == Less {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -480,7 +480,7 @@ impl<K: Ord, V> Branch<K, V> {\n                 }\n                 Less => {\n                     if midpoint + 1 < self.elts.len() {\n-                        if self.elts.get(midpoint + 1).key.cmp(&k) == Greater {\n+                        if self.elts[midpoint + 1].key.cmp(&k) == Greater {\n                             return Some(midpoint);\n                         }\n                         else {\n@@ -529,15 +529,15 @@ impl<K: Clone + Ord, V: Clone> Branch<K, V> {\n             Some(i) => {\n                 if i == self.elts.len() {\n                     let new_outcome = self.clone().rightmost_child.insert(k.clone(),\n-                                                                       v.clone(),\n-                                                                       ub.clone());\n+                                                                          v.clone(),\n+                                                                          ub.clone());\n                     new_branch = new_outcome.clone().val0();\n                     outcome = new_outcome.val1();\n                 }\n                 else {\n-                    let new_outcome = self.elts.get(i).left.clone().insert(k.clone(),\n-                                                                                 v.clone(),\n-                                                                                 ub.clone());\n+                    let new_outcome = self.elts[i].left.clone().insert(k.clone(),\n+                                                                       v.clone(),\n+                                                                       ub.clone());\n                     new_branch = new_outcome.clone().val0();\n                     outcome = new_outcome.val1();\n                 }\n@@ -581,7 +581,7 @@ impl<K: Clone + Ord, V: Clone> Branch<K, V> {\n                 //If we have a new branch node, attempt to insert it into the tree\n                 //as with the key-value pair, then check to see if the node is overfull.\n                 BranchNode(branch) => {\n-                    let new_elt = branch.elts.get(0).clone();\n+                    let new_elt = branch.elts[0].clone();\n                     let new_elt_index = self.bsearch_branch(new_elt.clone().key);\n                     match new_elt_index {\n                         None => {\n@@ -652,7 +652,7 @@ impl<K: Ord, V: Eq> Ord for Branch<K, V> {\n         if self.elts.len() < other.elts.len() {\n             return Less;\n         }\n-        self.elts.get(0).cmp(other.elts.get(0))\n+        self.elts[0].cmp(&other.elts[0])\n     }\n }\n "}, {"sha": "8344ad7c79d7b902edb95e2d40ee376aaa1ecd67", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -654,7 +654,7 @@ impl<A> Iterator<A> for MoveItems<A> {\n \n impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n+    fn next_back(&mut self) -> Option<A> { self.list.pop() }\n }\n \n impl<A> FromIterator<A> for DList<A> {\n@@ -667,7 +667,7 @@ impl<A> FromIterator<A> for DList<A> {\n \n impl<A> Extendable<A> for DList<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n-        for elt in iterator { self.push_back(elt); }\n+        for elt in iterator { self.push(elt); }\n     }\n }\n "}, {"sha": "a88a833c9edcab2b3a1a398cd323ec28ec020a96", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -261,7 +261,7 @@ impl<T: Ord> PriorityQueue<T> {\n     ///\n     /// ```\n     pub fn top<'a>(&'a self) -> Option<&'a T> {\n-        if self.is_empty() { None } else { Some(self.data.get(0)) }\n+        if self.is_empty() { None } else { Some(&self.data[0]) }\n     }\n \n     #[deprecated=\"renamed to `top`\"]\n@@ -473,7 +473,7 @@ impl<T: Ord> PriorityQueue<T> {\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n-                if new > *self.data.get(parent) {\n+                if new > self.data[parent] {\n                     let x = replace(self.data.get_mut(parent), zeroed());\n                     ptr::write(self.data.get_mut(pos), x);\n                     pos = parent;\n@@ -493,7 +493,7 @@ impl<T: Ord> PriorityQueue<T> {\n             let mut child = 2 * pos + 1;\n             while child < end {\n                 let right = child + 1;\n-                if right < end && !(*self.data.get(child) > *self.data.get(right)) {\n+                if right < end && !(self.data[child] > self.data[right]) {\n                     child = right;\n                 }\n                 let x = replace(self.data.get_mut(child), zeroed());"}, {"sha": "ce08f169366dad8fb0937ad13ae460a12210cf3e", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -53,7 +53,7 @@ impl<T> Mutable for RingBuf<T> {\n impl<T> Deque<T> for RingBuf<T> {\n     /// Return a reference to the first element in the RingBuf\n     fn front<'a>(&'a self) -> Option<&'a T> {\n-        if self.nelts > 0 { Some(self.get(0)) } else { None }\n+        if self.nelts > 0 { Some(&self[0]) } else { None }\n     }\n \n     /// Return a mutable reference to the first element in the RingBuf\n@@ -63,7 +63,7 @@ impl<T> Deque<T> for RingBuf<T> {\n \n     /// Return a reference to the last element in the RingBuf\n     fn back<'a>(&'a self) -> Option<&'a T> {\n-        if self.nelts > 0 { Some(self.get(self.nelts - 1)) } else { None }\n+        if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n     }\n \n     /// Return a mutable reference to the last element in the RingBuf\n@@ -152,7 +152,7 @@ impl<T> RingBuf<T> {\n     #[deprecated = \"prefer using indexing, e.g., ringbuf[0]\"]\n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         let idx = self.raw_index(i);\n-        match *self.elts.get(idx) {\n+        match self.elts[idx] {\n             None => fail!(),\n             Some(ref v) => v\n         }\n@@ -481,6 +481,7 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n \n impl<A> Index<uint, A> for RingBuf<A> {\n     #[inline]\n+    #[allow(deprecated)]\n     fn index<'a>(&'a self, i: &uint) -> &'a A {\n         self.get(*i)\n     }\n@@ -506,7 +507,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n impl<A> Extendable<A> for RingBuf<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n-            self.push_back(elt);\n+            self.push(elt);\n         }\n     }\n }"}, {"sha": "4c7c7e3ea74bb1fa8bbd7171ac840798b1f6c1e5", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -190,7 +190,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n         let max = self.sdir.iter().map(|&x| x).enumerate()\n                            .filter(|&(i, sd)|\n                                 new_pos(i, sd.dir) < self.sdir.len() &&\n-                                self.sdir.get(new_pos(i, sd.dir)).size < sd.size)\n+                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n                            .max_by(|&(_, sd)| sd.size);\n         match max {\n             Some((i, sd)) => {"}, {"sha": "4529c8782a19493c6f30e032ef81294ff7b733b1", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -86,7 +86,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     /// Return a reference to the value corresponding to the key.\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n-            match *self.v.get(*key) {\n+            match self.v[*key] {\n               Some(ref value) => Some(value),\n               None => None\n             }\n@@ -421,6 +421,7 @@ impl<V> Extendable<(uint, V)> for SmallIntMap<V> {\n \n impl<V> Index<uint, V> for SmallIntMap<V> {\n     #[inline]\n+    #[allow(deprecated)]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n         self.get(i)\n     }"}, {"sha": "d911ca6bb14f9824d080449f2729131e6053e8eb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -251,11 +251,11 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n         match self.buffer.as_slice().head() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n-                self.buffer.shift();\n+                self.buffer.remove(0);\n                 return Some(c);\n             }\n             Some(&(c, _)) if self.sorted => {\n-                self.buffer.shift();\n+                self.buffer.remove(0);\n                 return Some(c);\n             }\n             _ => self.sorted = false\n@@ -287,7 +287,7 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n             self.sorted = true;\n         }\n \n-        match self.buffer.shift() {\n+        match self.buffer.remove(0) {\n             Some((c, 0)) => {\n                 self.sorted = false;\n                 Some(c)\n@@ -805,21 +805,21 @@ pub trait StrAllocating: Str {\n \n             for (j, tc) in t.chars().enumerate() {\n \n-                let next = *dcol.get(j + 1);\n+                let next = dcol[j + 1];\n \n                 if sc == tc {\n                     *dcol.get_mut(j + 1) = current;\n                 } else {\n                     *dcol.get_mut(j + 1) = cmp::min(current, next);\n-                    *dcol.get_mut(j + 1) = cmp::min(*dcol.get(j + 1),\n-                                                    *dcol.get(j)) + 1;\n+                    *dcol.get_mut(j + 1) = cmp::min(dcol[j + 1],\n+                                                    dcol[j]) + 1;\n                 }\n \n                 current = next;\n             }\n         }\n \n-        return *dcol.get(tlen);\n+        return dcol[tlen];\n     }\n \n     /// An Iterator over the string in Unicode Normalization Form D"}, {"sha": "952f28da2af891980a6bafc96d723979fdb39b1f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -669,7 +669,7 @@ impl String {\n     /// }\n     /// ```\n     pub unsafe fn shift_byte(&mut self) -> Option<u8> {\n-        self.vec.shift()\n+        self.vec.remove(0)\n     }\n \n     /// Removes the first character from the string buffer and returns it."}, {"sha": "6bda0eed66dd937c66e3b3ff2d221eed6b2d804f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77cabecbba8d842cd944b064065ad4e6a6b760d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f77cabecbba8d842cd944b064065ad4e6a6b760d", "patch": "@@ -453,6 +453,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n impl<T> Index<uint,T> for Vec<T> {\n     #[inline]\n+    #[allow(deprecated)] // allow use of get\n     fn index<'a>(&'a self, index: &uint) -> &'a T {\n         self.get(*index)\n     }"}]}