{"sha": "c7e072427469ef50880a722b7b6cd00b052939f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZTA3MjQyNzQ2OWVmNTA4ODBhNzIyYjdiNmNkMDBiMDUyOTM5ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-13T19:37:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-13T19:37:40Z"}, "message": "auto merge of #17733 : jgallagher/rust/while-let, r=alexcrichton\n\nThis is *heavily* based on `if let` (#17634) by @jakub- and @kballard\r\n\r\nThis should close #17687", "tree": {"sha": "c87cb2f922c34bf1b6d9b6152ae466a31b817eff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c87cb2f922c34bf1b6d9b6152ae466a31b817eff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7e072427469ef50880a722b7b6cd00b052939f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e072427469ef50880a722b7b6cd00b052939f5", "html_url": "https://github.com/rust-lang/rust/commit/c7e072427469ef50880a722b7b6cd00b052939f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7e072427469ef50880a722b7b6cd00b052939f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daa71e40a98f32084539e7cfe893a3e94f83fe69", "url": "https://api.github.com/repos/rust-lang/rust/commits/daa71e40a98f32084539e7cfe893a3e94f83fe69", "html_url": "https://github.com/rust-lang/rust/commit/daa71e40a98f32084539e7cfe893a3e94f83fe69"}, {"sha": "16ccdba8512fc7ce397095cf5d62858ef2234c47", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ccdba8512fc7ce397095cf5d62858ef2234c47", "html_url": "https://github.com/rust-lang/rust/commit/16ccdba8512fc7ce397095cf5d62858ef2234c47"}], "stats": {"total": 281, "additions": 266, "deletions": 15}, "files": [{"sha": "131637948c8d2bac568848d106505b83eefff481", "filename": "src/doc/reference.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -2488,6 +2488,8 @@ The currently implemented features of the reference compiler are:\n \n * `if_let` - Allows use of the `if let` syntax.\n \n+* `while_let` - Allows use of the `while let` syntax.\n+\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n@@ -3494,6 +3496,18 @@ of a condition expression it expects a refutable let statement. If the value of\n expression on the right hand side of the let statement matches the pattern, the corresponding\n block will execute, otherwise flow proceeds to the first `else` block that follows.\n \n+### While let loops\n+\n+```{.ebnf .gram}\n+while_let_expr : \"while\" \"let\" pat '=' expr '{' block '}' ;\n+```\n+\n+A `while let` loop is semantically identical to a `while` loop but in place of a\n+condition expression it expects a refutable let statement. If the value of the\n+expression on the right hand side of the let statement matches the pattern, the\n+loop body block executes and control returns to the pattern matching statement.\n+Otherwise, the while expression completes.\n+\n ### Return expressions\n \n ```{.ebnf .gram}"}, {"sha": "c392d92a83fc7353d26ffafb113ee6bf1fc1e4fe", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -145,5 +145,6 @@ register_diagnostics!(\n     E0161,\n     E0162,\n     E0163,\n-    E0164\n+    E0164,\n+    E0165\n )"}, {"sha": "988b128e31d5c103ba611301466b10143503628c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -1082,7 +1082,8 @@ impl LintPass for UnnecessaryParens {\n             ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n             ast::ExprMatch(ref head, _, source) => match source {\n                 ast::MatchNormal => (head, \"`match` head expression\", true),\n-                ast::MatchIfLetDesugar => (head, \"`if let` head expression\", true)\n+                ast::MatchIfLetDesugar => (head, \"`if let` head expression\", true),\n+                ast::MatchWhileLetDesugar => (head, \"`while let` head expression\", true),\n             },\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),"}, {"sha": "b573c4e59487a83d35f0ad6af46cbb679a5ad329", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -259,6 +259,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n+            ast::ExprWhileLet(..) => {\n+                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+            }\n+\n             ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n                 //\n                 //          [pred]"}, {"sha": "84367090b26df73fda8b1c242fa4959897a8dff7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -261,20 +261,32 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n \n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => {\n-                    if source == MatchIfLetDesugar {\n-                        if printed_if_let_err {\n-                            // we already printed an irrefutable if-let pattern error.\n-                            // We don't want two, that's just confusing.\n-                        } else {\n+                    match source {\n+                        MatchIfLetDesugar => {\n+                            if printed_if_let_err {\n+                                // we already printed an irrefutable if-let pattern error.\n+                                // We don't want two, that's just confusing.\n+                            } else {\n+                                // find the first arm pattern so we can use its span\n+                                let &(ref first_arm_pats, _) = &arms[0];\n+                                let first_pat = first_arm_pats.get(0);\n+                                let span = first_pat.span;\n+                                span_err!(cx.tcx.sess, span, E0162, \"irrefutable if-let pattern\");\n+                                printed_if_let_err = true;\n+                            }\n+                        },\n+\n+                        MatchWhileLetDesugar => {\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = first_arm_pats.get(0);\n                             let span = first_pat.span;\n-                            span_err!(cx.tcx.sess, span, E0162, \"irrefutable if-let pattern\");\n-                            printed_if_let_err = true;\n-                        }\n-                    } else {\n-                        span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\");\n+                            span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n+                        },\n+\n+                        MatchNormal => {\n+                            span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n+                        },\n                     }\n                 }\n                 Useful => (),"}, {"sha": "6f179e0624fe21df3d5a56d597b43cf7c1ec2912", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -429,6 +429,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 self.walk_block(&**blk);\n             }\n \n+            ast::ExprWhileLet(..) => {\n+                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+            }\n+\n             ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n                 // The pattern lives as long as the block.\n                 debug!(\"walk_expr for loop case: blk id={}\", blk.id);"}, {"sha": "90973dfaa0028363ae8687868f67242155022df1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -484,6 +484,9 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ExprIfLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n+      ExprWhileLet(..) => {\n+          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+      }\n       ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from for loop with bm {:?}\",\n@@ -1022,6 +1025,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n \n+          ExprWhileLet(..) => {\n+              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+          }\n+\n           ExprForLoop(ref pat, ref head, ref blk, _) => {\n             let ln = self.propagate_through_loop(expr, ForLoop(&**pat), &**blk, succ);\n             self.propagate_through_expr(&**head, ln)\n@@ -1480,6 +1487,9 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprIfLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n+      ExprWhileLet(..) => {\n+        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+      }\n     }\n }\n "}, {"sha": "4a1c4aaa89514d826ebbb24e88fd4457ddfde177", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -530,6 +530,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprIfLet(..) => {\n             self.tcx().sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n           }\n+          ast::ExprWhileLet(..) => {\n+            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+          }\n         }\n     }\n "}, {"sha": "d81f78f23ffaf4671f5e21821577245de36315de", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -3496,6 +3496,11 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n+            ast::ExprWhileLet(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                              Found unexpanded while-let.\");\n+            }\n+\n             ast::ExprForLoop(ref pattern, ref head, ref body, _) => {\n                 walk_expr(cx, &**head, scope_stack, scope_map);\n "}, {"sha": "1185c64497889b7fc0375106ef1ef74e79e397db", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -3605,6 +3605,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprIfLet(..) => {\n             tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n         }\n+        ast::ExprWhileLet(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+        }\n \n         ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr"}, {"sha": "b78398fdb6d704c9f0382ee021188930b0e6ee23", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -4058,6 +4058,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n+      ast::ExprWhileLet(..) => {\n+        tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+      }\n       ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n         check_expr(fcx, &**head);\n         let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);"}, {"sha": "459e7eb093e7c2d96877d539f4f70ed36d6b5b44", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -93,6 +93,9 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                 explain_span(cx, \"method call\", expr.span)\n               },\n               ast::ExprMatch(_, _, ast::MatchIfLetDesugar) => explain_span(cx, \"if let\", expr.span),\n+              ast::ExprMatch(_, _, ast::MatchWhileLetDesugar) => {\n+                  explain_span(cx, \"while let\", expr.span)\n+              },\n               ast::ExprMatch(..) => explain_span(cx, \"match\", expr.span),\n               _ => explain_span(cx, \"expression\", expr.span)\n             }"}, {"sha": "3c28cac6c6f7c1e9186ae56796016f018e979c2a", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -294,6 +294,7 @@ mod svh_visitor {\n \n             // just syntactic artifacts, expanded away by time of SVH.\n             ExprIfLet(..)            => unreachable!(),\n+            ExprWhileLet(..)         => unreachable!(),\n             ExprMac(..)              => unreachable!(),\n         }\n     }"}, {"sha": "bf4734529a291944b56d8969d9d1986f00653a2e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -524,6 +524,8 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n@@ -579,7 +581,8 @@ pub struct QPath {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum MatchSource {\n     MatchNormal,\n-    MatchIfLetDesugar\n+    MatchIfLetDesugar,\n+    MatchWhileLetDesugar,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]"}, {"sha": "98ac6fe6a6c8089aa625f831c040529e98b2adbd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -147,6 +147,8 @@ pub trait AstBuilder {\n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_none(&self, sp: Span) -> P<ast::Expr>;\n \n+    fn expr_break(&self, sp: Span) -> P<ast::Expr>;\n+\n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n \n     fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr>;\n@@ -688,6 +690,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(none)\n     }\n \n+\n+    fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n+        self.expr(sp, ast::ExprBreak(None))\n+    }\n+\n+\n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprTup(exprs))\n     }"}, {"sha": "575dcf32dd6cbb048b1f591bd106e8fd6f417e38", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -67,6 +67,42 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n         }\n \n+        // Desugar ExprWhileLet\n+        // From: `[opt_ident]: while let <pat> = <expr> <body>`\n+        ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n+            // to:\n+            //\n+            //   [opt_ident]: loop {\n+            //     match <expr> {\n+            //       <pat> => <body>,\n+            //       _ => break\n+            //     }\n+            //   }\n+\n+            // `<pat> => <body>`\n+            let pat_arm = {\n+                let body_expr = fld.cx.expr_block(body);\n+                fld.cx.arm(pat.span, vec![pat], body_expr)\n+            };\n+\n+            // `_ => break`\n+            let break_arm = {\n+                let pat_under = fld.cx.pat_wild(span);\n+                let break_expr = fld.cx.expr_break(span);\n+                fld.cx.arm(span, vec![pat_under], break_expr)\n+            };\n+\n+            // `match <expr> { ... }`\n+            let arms = vec![pat_arm, break_arm];\n+            let match_expr = fld.cx.expr(span,\n+                                         ast::ExprMatch(expr, arms, ast::MatchWhileLetDesugar));\n+\n+            // `[opt_ident]: loop { ... }`\n+            let loop_block = fld.cx.block_expr(match_expr);\n+            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n+            fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n+        }\n+\n         // Desugar ExprIfLet\n         // From: `if let <pat> = <expr> <body> [<elseopt>]`\n         ast::ExprIfLet(pat, expr, body, mut elseopt) => {"}, {"sha": "c1877c827a41f4772e10a51e1eb7480b45ada643", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -73,6 +73,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"slicing_syntax\", Active),\n \n     (\"if_let\", Active),\n+    (\"while_let\", Active),\n \n     // if you change this list without updating src/doc/reference.md, cmr will be sad\n \n@@ -345,6 +346,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                                   e.span,\n                                   \"slicing syntax is experimental\");\n             }\n+            ast::ExprWhileLet(..) => {\n+                self.gate_feature(\"while_let\", e.span,\n+                                  \"`while let` syntax is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "8faecd407a86b59024862e4f9c78856a7a8899ce", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -1216,6 +1216,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                           folder.fold_block(body),\n                           opt_ident.map(|i| folder.fold_ident(i)))\n             }\n+            ExprWhileLet(pat, expr, body, opt_ident) => {\n+                ExprWhileLet(folder.fold_pat(pat),\n+                             folder.fold_expr(expr),\n+                             folder.fold_block(body),\n+                             opt_ident.map(|i| folder.fold_ident(i)))\n+            }\n             ExprForLoop(pat, iter, body, opt_ident) => {\n                 ExprForLoop(folder.fold_pat(pat),\n                             folder.fold_expr(iter),"}, {"sha": "d46d078c776be0b2ea59b01cc3e7565d1fe109a5", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -28,6 +28,7 @@ pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n         | ast::ExprMatch(..)\n         | ast::ExprBlock(_)\n         | ast::ExprWhile(..)\n+        | ast::ExprWhileLet(..)\n         | ast::ExprLoop(..)\n         | ast::ExprForLoop(..) => false,\n         _ => true"}, {"sha": "d5253cff6cb2655b473cb5ac8035ddae06916d5f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -26,7 +26,7 @@ use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIfLet, ExprIndex, Ex\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n-use ast::{ExprVec, ExprWhile, ExprForLoop, Field, FnDecl};\n+use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n use ast::{Once, Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n@@ -2935,14 +2935,30 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident))\n     }\n \n+    /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n+        if self.is_keyword(keywords::Let) {\n+            return self.parse_while_let_expr(opt_ident);\n+        }\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident));\n     }\n \n+    /// Parse a 'while let' expression ('while' token already eaten)\n+    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n+        let lo = self.last_span.lo;\n+        self.expect_keyword(keywords::Let);\n+        let pat = self.parse_pat();\n+        self.expect(&token::EQ);\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n+        let body = self.parse_block();\n+        let hi = body.span.hi;\n+        return self.mk_expr(lo, hi, ExprWhileLet(pat, expr, body, opt_ident));\n+    }\n+\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();"}, {"sha": "d32828192e9966a007b26fb68e7450001ec5b994", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -1515,6 +1515,19 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block(&**blk));\n             }\n+            ast::ExprWhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n+                for ident in opt_ident.iter() {\n+                    try!(self.print_ident(*ident));\n+                    try!(self.word_space(\":\"));\n+                }\n+                try!(self.head(\"while let\"));\n+                try!(self.print_pat(&**pat));\n+                try!(space(&mut self.s));\n+                try!(self.word_space(\"=\"));\n+                try!(self.print_expr(&**expr));\n+                try!(space(&mut self.s));\n+                try!(self.print_block(&**blk));\n+            }\n             ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n                     try!(self.print_ident(*ident));"}, {"sha": "00377a324a7685b5ca5e461c59bed49060374948", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -733,6 +733,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(&**if_block);\n             walk_expr_opt(visitor, optional_else);\n         }\n+        ExprWhileLet(ref pattern, ref subexpression, ref block, _) => {\n+            visitor.visit_pat(&**pattern);\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_block(&**block);\n+        }\n         ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n             visitor.visit_pat(&**pattern);\n             visitor.visit_expr(&**subexpression);"}, {"sha": "6c766dec9a3e9df51cff06c6c4c30dc2421ef154", "filename": "src/test/compile-fail/lint-unnecessary-parens.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![deny(unnecessary_parens)]\n-#![feature(if_let)]\n+#![feature(if_let,while_let)]\n \n #[deriving(Eq, PartialEq)]\n struct X { y: bool }\n@@ -34,6 +34,7 @@ fn main() {\n         _ => {}\n     }\n     if let 1i = (1i) {} //~ ERROR unnecessary parentheses around `if let` head expression\n+    while let 1i = (2i) {} //~ ERROR unnecessary parentheses around `while let` head expression\n     let v = X { y: false };\n     // struct lits needs parens, so these shouldn't warn.\n     if (v == X { y: true }) {}"}, {"sha": "0dd442ec3f66aad9ea73f739f8edde9d13889d3f", "filename": "src/test/compile-fail/while-let.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules,while_let)]\n+\n+fn macros() {\n+    macro_rules! foo{\n+        ($p:pat, $e:expr, $b:block) => {{\n+            while let $p = $e $b\n+        }}\n+    }\n+    macro_rules! bar{\n+        ($p:pat, $e:expr, $b:block) => {{\n+            foo!($p, $e, $b)\n+        }}\n+    }\n+\n+    foo!(a, 1i, { //~ ERROR irrefutable while-let\n+        println!(\"irrefutable pattern\");\n+    });\n+    bar!(a, 1i, { //~ ERROR irrefutable while-let\n+        println!(\"irrefutable pattern\");\n+    });\n+}\n+\n+pub fn main() {\n+    while let a = 1i { //~ ERROR irrefutable while-let\n+        println!(\"irrefutable pattern\");\n+    }\n+}"}, {"sha": "41f54d47ad42c2771655c7c40a08e2901807c9e8", "filename": "src/test/run-pass/while-let.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e072427469ef50880a722b7b6cd00b052939f5/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-let.rs?ref=c7e072427469ef50880a722b7b6cd00b052939f5", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(while_let)]\n+\n+use std::collections::PriorityQueue;\n+\n+fn make_pq() -> PriorityQueue<int> {\n+    PriorityQueue::from_vec(vec![1i,2,3])\n+}\n+\n+pub fn main() {\n+    let mut pq = make_pq();\n+    let mut sum = 0i;\n+    while let Some(x) = pq.pop() {\n+        sum += x;\n+    }\n+    assert_eq!(sum, 6i);\n+\n+    pq = make_pq();\n+    sum = 0;\n+    'a: while let Some(x) = pq.pop() {\n+        sum += x;\n+        if x == 2 {\n+            break 'a;\n+        }\n+    }\n+    assert_eq!(sum, 5i);\n+\n+    pq = make_pq();\n+    sum = 0;\n+    'a: while let Some(x) = pq.pop() {\n+        if x == 3 {\n+            continue 'a;\n+        }\n+        sum += x;\n+    }\n+    assert_eq!(sum, 3i);\n+\n+    let mut pq1 = make_pq();\n+    sum = 0;\n+    while let Some(x) = pq1.pop() {\n+        let mut pq2 = make_pq();\n+        while let Some(y) = pq2.pop() {\n+            sum += x * y;\n+        }\n+    }\n+    assert_eq!(sum, 6i + 12 + 18);\n+}"}]}