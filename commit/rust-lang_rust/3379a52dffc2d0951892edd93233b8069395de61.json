{"sha": "3379a52dffc2d0951892edd93233b8069395de61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNzlhNTJkZmZjMmQwOTUxODkyZWRkOTMyMzNiODA2OTM5NWRlNjE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-13T17:44:29Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:48:34Z"}, "message": "Make type resolver a proper folder, make it resolve consts as well", "tree": {"sha": "439f91277ca6746bc5f73b9fc2272aa1ac583110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/439f91277ca6746bc5f73b9fc2272aa1ac583110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3379a52dffc2d0951892edd93233b8069395de61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3379a52dffc2d0951892edd93233b8069395de61", "html_url": "https://github.com/rust-lang/rust/commit/3379a52dffc2d0951892edd93233b8069395de61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3379a52dffc2d0951892edd93233b8069395de61/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "278f5b043d3cde9ed5b6dfef708ed29179fd534c", "url": "https://api.github.com/repos/rust-lang/rust/commits/278f5b043d3cde9ed5b6dfef708ed29179fd534c", "html_url": "https://github.com/rust-lang/rust/commit/278f5b043d3cde9ed5b6dfef708ed29179fd534c"}], "stats": {"total": 165, "additions": 117, "deletions": 48}, "files": [{"sha": "896d084f46885a58745bd73482bfd7c16b28eff9", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 117, "deletions": 48, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/3379a52dffc2d0951892edd93233b8069395de61/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3379a52dffc2d0951892edd93233b8069395de61/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=3379a52dffc2d0951892edd93233b8069395de61", "patch": "@@ -118,16 +118,13 @@ pub(crate) fn unify(\n             chalk_ir::GenericArgData::Const(c) => c.inference_var(&Interner),\n         } == Some(iv))\n     };\n-    let fallback = |iv, kind, default| match kind {\n-        chalk_ir::VariableKind::Ty(_ty_kind) => find_var(iv).map_or(default, |i| {\n-            BoundVar::new(DebruijnIndex::INNERMOST, i).to_ty(&Interner).cast(&Interner)\n-        }),\n-        chalk_ir::VariableKind::Lifetime => find_var(iv).map_or(default, |i| {\n-            BoundVar::new(DebruijnIndex::INNERMOST, i).to_lifetime(&Interner).cast(&Interner)\n-        }),\n-        chalk_ir::VariableKind::Const(ty) => find_var(iv).map_or(default, |i| {\n-            BoundVar::new(DebruijnIndex::INNERMOST, i).to_const(&Interner, ty).cast(&Interner)\n-        }),\n+    let fallback = |iv, kind, default, binder| match kind {\n+        chalk_ir::VariableKind::Ty(_ty_kind) => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_ty(&Interner).cast(&Interner)),\n+        chalk_ir::VariableKind::Lifetime => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_lifetime(&Interner).cast(&Interner)),\n+        chalk_ir::VariableKind::Const(ty) => find_var(iv)\n+            .map_or(default, |i| BoundVar::new(binder, i).to_const(&Interner, ty).cast(&Interner)),\n     };\n     Some(Substitution::from_iter(\n         &Interner,\n@@ -212,7 +209,7 @@ impl<'a> InferenceTable<'a> {\n     pub(crate) fn resolve_with_fallback<T>(\n         &mut self,\n         t: T,\n-        fallback: impl Fn(InferenceVar, VariableKind, GenericArg) -> GenericArg,\n+        fallback: impl Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n     ) -> T::Result\n     where\n         T: HasInterner<Interner = Interner> + Fold<Interner>,\n@@ -224,50 +221,25 @@ impl<'a> InferenceTable<'a> {\n         &mut self,\n         var_stack: &mut Vec<InferenceVar>,\n         t: T,\n-        fallback: &impl Fn(InferenceVar, VariableKind, GenericArg) -> GenericArg,\n+        fallback: &impl Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n     ) -> T::Result\n     where\n         T: HasInterner<Interner = Interner> + Fold<Interner>,\n     {\n-        fold_tys(\n-            t,\n-            |ty, _| match ty.kind(&Interner) {\n-                &TyKind::InferenceVar(tv, kind) => {\n-                    if var_stack.contains(&tv) {\n-                        cov_mark::hit!(type_var_cycles_resolve_as_possible);\n-                        // recursive type\n-                        let default =\n-                            self.type_variable_table.fallback_value(tv, kind).cast(&Interner);\n-                        return fallback(tv, VariableKind::Ty(kind), default)\n-                            .assert_ty_ref(&Interner)\n-                            .clone();\n-                    }\n-                    if let Some(known_ty) = self.var_unification_table.probe_var(tv) {\n-                        // known_ty may contain other variables that are known by now\n-                        var_stack.push(tv);\n-                        let result = self.resolve_with_fallback_inner(\n-                            var_stack,\n-                            known_ty.assert_ty_ref(&Interner).clone(),\n-                            fallback,\n-                        );\n-                        var_stack.pop();\n-                        result\n-                    } else {\n-                        let default =\n-                            self.type_variable_table.fallback_value(tv, kind).cast(&Interner);\n-                        fallback(tv, VariableKind::Ty(kind), default)\n-                            .assert_ty_ref(&Interner)\n-                            .clone()\n-                    }\n-                }\n-                _ => ty,\n+        t.fold_with(\n+            &mut resolve::Resolver {\n+                type_variable_table: &self.type_variable_table,\n+                var_unification_table: &mut self.var_unification_table,\n+                var_stack,\n+                fallback,\n             },\n             DebruijnIndex::INNERMOST,\n         )\n+        .expect(\"fold failed unexpectedly\")\n     }\n \n     pub(crate) fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n-        self.resolve_with_fallback(ty, |_, _, d| d)\n+        self.resolve_with_fallback(ty, |_, _, d, _| d)\n     }\n \n     // FIXME get rid of this, instead resolve shallowly where necessary\n@@ -316,9 +288,7 @@ impl<'a> InferenceTable<'a> {\n     }\n \n     /// Resolves the type as far as currently possible, replacing type variables\n-    /// by their known types. All types returned by the infer_* functions should\n-    /// be resolved as far as possible, i.e. contain no type variables with\n-    /// known type.\n+    /// by their known types.\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<InferenceVar>, ty: Ty) -> Ty {\n         fold_tys(\n             ty,\n@@ -356,3 +326,102 @@ impl<'a> fmt::Debug for InferenceTable<'a> {\n             .finish()\n     }\n }\n+\n+mod resolve {\n+    use super::{ChalkInferenceTable, TypeVariableTable};\n+    use crate::{\n+        ConcreteConst, Const, ConstData, ConstValue, DebruijnIndex, GenericArg, InferenceVar,\n+        Interner, Ty, TyVariableKind, VariableKind,\n+    };\n+    use chalk_ir::{\n+        cast::Cast,\n+        fold::{Fold, Folder},\n+        Fallible,\n+    };\n+    use hir_def::type_ref::ConstScalar;\n+\n+    pub(super) struct Resolver<'a, F> {\n+        pub type_variable_table: &'a TypeVariableTable,\n+        pub var_unification_table: &'a mut ChalkInferenceTable,\n+        pub var_stack: &'a mut Vec<InferenceVar>,\n+        pub fallback: F,\n+    }\n+    impl<'a, 'i, F> Folder<'i, Interner> for Resolver<'a, F>\n+    where\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg + 'i,\n+    {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner> {\n+            self\n+        }\n+\n+        fn interner(&self) -> &'i Interner {\n+            &Interner\n+        }\n+\n+        fn fold_inference_ty(\n+            &mut self,\n+            var: InferenceVar,\n+            kind: TyVariableKind,\n+            outer_binder: DebruijnIndex,\n+        ) -> Fallible<Ty> {\n+            let var = self.var_unification_table.inference_var_root(var);\n+            if self.var_stack.contains(&var) {\n+                cov_mark::hit!(type_var_cycles_resolve_as_possible);\n+                // recursive type\n+                let default = self.type_variable_table.fallback_value(var, kind).cast(&Interner);\n+                return Ok((self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n+                    .assert_ty_ref(&Interner)\n+                    .clone());\n+            }\n+            let result = if let Some(known_ty) = self.var_unification_table.probe_var(var) {\n+                // known_ty may contain other variables that are known by now\n+                self.var_stack.push(var);\n+                let result =\n+                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                self.var_stack.pop();\n+                result.assert_ty_ref(&Interner).clone()\n+            } else {\n+                let default = self.type_variable_table.fallback_value(var, kind).cast(&Interner);\n+                (self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n+                    .assert_ty_ref(&Interner)\n+                    .clone()\n+            };\n+            Ok(result)\n+        }\n+\n+        fn fold_inference_const(\n+            &mut self,\n+            ty: Ty,\n+            var: InferenceVar,\n+            outer_binder: DebruijnIndex,\n+        ) -> Fallible<Const> {\n+            let var = self.var_unification_table.inference_var_root(var);\n+            let default = ConstData {\n+                ty: ty.clone(),\n+                value: ConstValue::Concrete(ConcreteConst { interned: ConstScalar::Unknown }),\n+            }\n+            .intern(&Interner)\n+            .cast(&Interner);\n+            if self.var_stack.contains(&var) {\n+                cov_mark::hit!(type_var_cycles_resolve_as_possible);\n+                // recursive\n+                return Ok((self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n+                    .assert_const_ref(&Interner)\n+                    .clone());\n+            }\n+            let result = if let Some(known_ty) = self.var_unification_table.probe_var(var) {\n+                // known_ty may contain other variables that are known by now\n+                self.var_stack.push(var);\n+                let result =\n+                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                self.var_stack.pop();\n+                result.assert_const_ref(&Interner).clone()\n+            } else {\n+                (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n+                    .assert_const_ref(&Interner)\n+                    .clone()\n+            };\n+            Ok(result)\n+        }\n+    }\n+}"}]}