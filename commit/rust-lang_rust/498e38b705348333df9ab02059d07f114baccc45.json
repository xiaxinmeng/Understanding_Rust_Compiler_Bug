{"sha": "498e38b705348333df9ab02059d07f114baccc45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OGUzOGI3MDUzNDgzMzNkZjlhYjAyMDU5ZDA3ZjExNGJhY2NjNDU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-28T07:24:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T18:44:06Z"}, "message": "Convert uses of #fmt to #ifmt. Issue #855", "tree": {"sha": "23a43b5b13b21ed2510d6dc52799e3e6d672b467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23a43b5b13b21ed2510d6dc52799e3e6d672b467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/498e38b705348333df9ab02059d07f114baccc45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/498e38b705348333df9ab02059d07f114baccc45", "html_url": "https://github.com/rust-lang/rust/commit/498e38b705348333df9ab02059d07f114baccc45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/498e38b705348333df9ab02059d07f114baccc45/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "959938e89144435c3a2fb1752527cfb17dd071a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/959938e89144435c3a2fb1752527cfb17dd071a4", "html_url": "https://github.com/rust-lang/rust/commit/959938e89144435c3a2fb1752527cfb17dd071a4"}], "stats": {"total": 725, "additions": 345, "deletions": 380}, "files": [{"sha": "9f0fbe1d328b1767aeb5f04eb1e1f74388b4a3e3", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -341,9 +341,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n     fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n                               metas: &provided_metas) -> istr {\n         fn len_and_str(s: &istr) -> istr {\n-            ret istr::from_estr(#fmt[\"%u_%s\",\n-                                     istr::byte_len(s),\n-                                     istr::to_estr(s)]);\n+            ret #ifmt[\"%u_%s\", istr::byte_len(s), s];\n         }\n \n         fn len_and_str_lit(l: &ast::lit) -> istr {\n@@ -374,9 +372,9 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n \n     fn warn_missing(sess: &session::session, name: &istr, default: &istr) {\n         if !sess.get_opts().library { ret; }\n-        sess.warn(istr::from_estr(\n-            #fmt[\"missing crate link meta '%s', using '%s' as default\",\n-                       istr::to_estr(name), istr::to_estr(default)]));\n+        sess.warn(\n+            #ifmt[\"missing crate link meta '%s', using '%s' as default\",\n+                       name, default]);\n     }\n \n     fn crate_meta_name(sess: &session::session, _crate: &ast::crate,\n@@ -461,9 +459,7 @@ fn mangle(ss: &[istr]) -> istr {\n     let n = ~\"_ZN\"; // Begin name-sequence.\n \n     for s: istr in ss {\n-        n += istr::from_estr(#fmt[\"%u%s\",\n-                                  istr::byte_len(s),\n-                                  istr::to_estr(s)]);\n+        n += #ifmt[\"%u%s\", istr::byte_len(s), s];\n     }\n     n += ~\"E\"; // End name-sequence.\n "}, {"sha": "f3e80344f5346c26be78024f90cea15d3d25d3c7", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -122,8 +122,8 @@ fn time<@T>(do_it: bool, what: &istr, thunk: fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n-    log_err #fmt[\"time: %s took %s s\", istr::to_estr(what),\n-                 istr::to_estr(common::float_to_str(end - start, 3u))];\n+    log_err #ifmt[\"time: %s took %s s\", what,\n+                 common::float_to_str(end - start, 3u)];\n     ret rv;\n }\n \n@@ -255,21 +255,21 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n }\n \n fn version(argv0: &istr) {\n-    let vers = \"unknown version\";\n+    let vers = ~\"unknown version\";\n     // FIXME: Restore after istr conversion\n     //let env_vers = #env[\"CFG_VERSION\"];\n-    let env_vers = \"FIXME\";\n-    if str::byte_len(env_vers) != 0u { vers = env_vers; }\n+    let env_vers = ~\"FIXME\";\n+    if istr::byte_len(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(\n-        istr::from_estr(#fmt[\"%s %s\\n\",\n-                             istr::to_estr(argv0),\n-                             vers]));\n+        #ifmt[\"%s %s\\n\",\n+                             argv0,\n+                             vers]);\n }\n \n fn usage(argv0: &istr) {\n-    io::stdout().write_str(istr::from_estr(\n-        #fmt[\"usage: %s [options] <input>\\n\", istr::to_estr(argv0)] +\n-                               \"\n+    io::stdout().write_str(\n+        #ifmt[\"usage: %s [options] <input>\\n\", argv0] +\n+                               ~\"\n options:\n \n     -h --help          display this message\n@@ -302,7 +302,7 @@ options:\n     --test             build test harness\n     --gc               garbage collect shared data (experimental/temporary)\n \n-\"));\n+\");\n }\n \n fn get_os(triple: &istr) -> session::os {\n@@ -473,7 +473,7 @@ fn main(args: [str]) {\n         alt getopts::getopts(args, opts()) {\n           getopts::success(m) { m }\n           getopts::failure(f) {\n-            log_err #fmt[\"error: %s\", istr::to_estr(getopts::fail_str(f))];\n+            log_err #ifmt[\"error: %s\", getopts::fail_str(f)];\n             fail\n           }\n         };\n@@ -637,11 +637,11 @@ fn main(args: [str]) {\n \n     let err_code = run::run_program(prog, gcc_args);\n     if 0 != err_code {\n-        sess.err(istr::from_estr(\n-            #fmt[\"linking with gcc failed with code %d\", err_code]));\n-        sess.note(istr::from_estr(\n-            #fmt[\"gcc arguments: %s\",\n-                       istr::to_estr(istr::connect(gcc_args, ~\" \"))]));\n+        sess.err(\n+            #ifmt[\"linking with gcc failed with code %d\", err_code]);\n+        sess.note(\n+            #ifmt[\"gcc arguments: %s\",\n+                       istr::connect(gcc_args, ~\" \")]);\n         sess.abort_if_errors();\n     }\n     // Clean up on Darwin"}, {"sha": "9f952041df146fbd1098a72ea4359c6c2f95e5d0", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -95,13 +95,13 @@ obj session(targ_cfg: @config,\n     }\n     fn span_bug(sp: span, msg: &istr) -> ! {\n         self.span_fatal(sp,\n-                        istr::from_estr(#fmt[\"internal compiler error %s\",\n-                                             istr::to_estr(msg)]));\n+                        #ifmt[\"internal compiler error %s\",\n+                                             msg]);\n     }\n     fn bug(msg: &istr) -> ! {\n-        self.fatal(istr::from_estr(\n-            #fmt[\"internal compiler error %s\",\n-                 istr::to_estr(msg)]));\n+        self.fatal(\n+            #ifmt[\"internal compiler error %s\",\n+                 msg]);\n     }\n     fn span_unimpl(sp: span, msg: &istr) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);"}, {"sha": "876a6cbc8b6802a940430313981e17f426cdc6f7", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -124,13 +124,11 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n }\n \n fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n-    log #fmt[\"looking for %s\",\n-             istr::to_estr(\n-                 syntax::print::pprust::meta_item_to_str(*needle))];\n+    log #ifmt[\"looking for %s\",\n+                 syntax::print::pprust::meta_item_to_str(*needle)];\n     for item: @ast::meta_item in haystack {\n-        log #fmt[\"looking in %s\",\n-                 istr::to_estr(\n-                     syntax::print::pprust::meta_item_to_str(*item))];\n+        log #ifmt[\"looking in %s\",\n+                     syntax::print::pprust::meta_item_to_str(*item)];\n         if eq(item, needle) { log \"found it!\"; ret true; }\n     }\n     log \"found it not :(\";\n@@ -185,9 +183,9 @@ fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n     for meta: @ast::meta_item in metas {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n-            sess.span_fatal(meta.span, istr::from_estr(\n-                            #fmt[\"duplicate meta item `%s`\",\n-                                 istr::to_estr(name)]));\n+            sess.span_fatal(meta.span,\n+                            #ifmt[\"duplicate meta item `%s`\",\n+                                 name]);\n         }\n         map.insert(name, ());\n     }"}, {"sha": "f299f819fef4fdc60a10669f6d60fe35b19de1fb", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -92,14 +92,14 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n     cx.path += [i.ident];\n-    log #fmt[\"current path: %s\",\n-             istr::to_estr(ast_util::path_name_i(cx.path))];\n+    log #ifmt[\"current path: %s\",\n+             ast_util::path_name_i(cx.path)];\n \n     if is_test_fn(i) {\n         log \"this is a test function\";\n         let test = {path: cx.path, ignore: is_ignored(i)};\n         cx.testfns += [test];\n-        log #fmt[\"have %u test functions\", vec::len(cx.testfns)];\n+        log #ifmt[\"have %u test functions\", vec::len(cx.testfns)];\n     }\n \n     let res = fold::noop_fold_item(i, fld);\n@@ -168,8 +168,8 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n          node: item_,\n          span: dummy_sp()};\n \n-    log #fmt[\"Synthetic test module:\\n%s\\n\",\n-             istr::to_estr(pprust::item_to_str(@item))];\n+    log #ifmt[\"Synthetic test module:\\n%s\\n\",\n+             pprust::item_to_str(@item)];\n \n     ret @item;\n }\n@@ -234,7 +234,7 @@ fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n }\n \n fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n-    log #fmt[\"building test vector from %u tests\", vec::len(cx.testfns)];\n+    log #ifmt[\"building test vector from %u tests\", vec::len(cx.testfns)];\n     let descs = [];\n     for test: test in cx.testfns {\n         let test_ = test; // Satisfy alias analysis\n@@ -249,8 +249,8 @@ fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let path = test.path;\n \n-    log #fmt[\"encoding %s\",\n-             istr::to_estr(ast_util::path_name_i(path))];\n+    log #ifmt[\"encoding %s\",\n+             ast_util::path_name_i(path)];\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast_util::path_name_i(path), ast::sk_rc));"}, {"sha": "2b185c1abbbced15e5077a8b4c52c40fffe42f2d", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1040,7 +1040,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       }\n       13 { ret ~\"Vector\"; }\n       14 { ret ~\"Metadata\"; }\n-      _ { log_err #fmt[\"unknown TypeKind %d\", kind as int]; fail; }\n+      _ { log_err #ifmt[\"unknown TypeKind %d\", kind as int]; fail; }\n     }\n }\n "}, {"sha": "5100037ea7ddd31fbce3f4e49efbfcbdf39ad604", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -100,13 +100,13 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n \n-    log #fmt[\"matching %u metadata requirements against %u items\",\n+    log #ifmt[\"matching %u metadata requirements against %u items\",\n              vec::len(metas), vec::len(linkage_metas)];\n \n     for needed: @ast::meta_item in metas {\n         if !attr::contains(linkage_metas, needed) {\n-            log #fmt[\"missing %s\",\n-                     istr::to_estr(pprust::meta_item_to_str(*needed))];\n+            log #ifmt[\"missing %s\",\n+                     pprust::meta_item_to_str(*needed)];\n             ret false;\n         }\n     }\n@@ -170,27 +170,27 @@ fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n     // manually filtering fs::list_dir here.\n \n     for library_search_path: istr in library_search_paths {\n-        log #fmt[\"searching %s\", istr::to_estr(library_search_path)];\n+        log #ifmt[\"searching %s\", library_search_path];\n         for path: istr in fs::list_dir(library_search_path) {\n-            log #fmt[\"searching %s\", istr::to_estr(path)];\n+            log #ifmt[\"searching %s\", path];\n             let f: istr = fs::basename(path);\n             if !(istr::starts_with(f, prefix) && istr::ends_with(f, suffix))\n                {\n-                log #fmt[\"skipping %s, doesn't look like %s*%s\",\n-                         istr::to_estr(path),\n-                         istr::to_estr(prefix),\n-                         istr::to_estr(suffix)];\n+                log #ifmt[\"skipping %s, doesn't look like %s*%s\",\n+                         path,\n+                         prefix,\n+                         suffix];\n                 cont;\n             }\n             alt get_metadata_section(path) {\n               option::some(cvec) {\n                 if !metadata_matches(cvec, metas) {\n-                    log #fmt[\"skipping %s, metadata doesn't match\",\n-                             istr::to_estr(path)];\n+                    log #ifmt[\"skipping %s, metadata doesn't match\",\n+                             path];\n                     cont;\n                 }\n-                log #fmt[\"found %s with matching metadata\",\n-                         istr::to_estr(path)];\n+                log #ifmt[\"found %s with matching metadata\",\n+                         path];\n                 ret some({ident: path, data: cvec});\n               }\n               _ { }\n@@ -230,9 +230,9 @@ fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n     alt find_library_crate(sess, ident, metas, library_search_paths) {\n       some(t) { ret t; }\n       none. {\n-        sess.span_fatal(span, istr::from_estr(\n-                        #fmt[\"can't find crate for '%s'\",\n-                                   istr::to_estr(ident)]));\n+        sess.span_fatal(span,\n+                        #ifmt[\"can't find crate for '%s'\",\n+                                   ident]);\n       }\n     }\n }\n@@ -275,7 +275,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n     for dep: decoder::crate_dep in decoder::get_crate_deps(cdata) {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;\n-        log #fmt[\"resolving dep %s\", istr::to_estr(cname)];\n+        log #ifmt[\"resolving dep %s\", cname];\n         if e.crate_cache.contains_key(cname) {\n             log \"already have it\";\n             // We've already seen this crate"}, {"sha": "a3637b178a0496e1e7e227c8846f97db524fe6dc", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -349,9 +349,8 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item in get_meta_items(meta_items) {\n         out.write_str(\n-            istr::from_estr(\n-                #fmt[\"%s\\n\",\n-                     istr::to_estr(pprust::meta_item_to_str(*mi))]));\n+                #ifmt[\"%s\\n\",\n+                     pprust::meta_item_to_str(*mi)]);\n     }\n }\n \n@@ -360,9 +359,8 @@ fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n \n     for attr: ast::attribute in get_attributes(md) {\n         out.write_str(\n-            istr::from_estr(\n-                #fmt[\"%s\\n\",\n-                     istr::to_estr(pprust::attribute_to_str(attr))]));\n+                #ifmt[\"%s\\n\",\n+                     pprust::attribute_to_str(attr)]);\n     }\n \n     out.write_str(~\"\\n\\n\");\n@@ -392,8 +390,8 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n \n     for dep: crate_dep in get_crate_deps(data) {\n         out.write_str(\n-            istr::from_estr(#fmt[\"%d %s\\n\", dep.cnum,\n-                                 istr::to_estr(dep.ident)]));\n+            #ifmt[\"%d %s\\n\", dep.cnum,\n+                                 dep.ident]);\n     }\n \n     out.write_str(~\"\\n\");\n@@ -414,10 +412,9 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n             out.write_str(\n-                istr::from_estr(\n-                    #fmt[\"%s (%s)\\n\",\n-                         istr::to_estr(data.path),\n-                         istr::to_estr(describe_def(items, did))]));\n+                    #ifmt[\"%s (%s)\\n\",\n+                         data.path,\n+                         describe_def(items, did)]);\n         }\n     }\n     out.write_str(~\"\\n\");"}, {"sha": "b403ef7de8bb1cca518c913292d112c0c8bef9ff", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -178,7 +178,7 @@ fn encode_inlineness(ebml_w: &ebml::writer, c: u8) {\n }\n \n fn def_to_str(did: &def_id) -> istr {\n-    ret istr::from_estr(#fmt[\"%d:%d\", did.crate, did.node]);\n+    ret #ifmt[\"%d:%d\", did.crate, did.node];\n }\n \n fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {"}, {"sha": "a9af80018c0be4163103fbb6df83305adcd42188", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -257,10 +257,10 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n         alt f.node {\n           ast::expr_path(_) {\n             if def_is_local(cx.tcx.def_map.get(f.id), true) {\n-                cx.tcx.sess.span_err(f.span, istr::from_estr(\n-                                     #fmt[\"function may alias with \\\n+                cx.tcx.sess.span_err(f.span,\n+                                     #ifmt[\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n-                                          unsafe_t_offsets[0]]));\n+                                          unsafe_t_offsets[0]]);\n             }\n           }\n           _ { }\n@@ -275,10 +275,10 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n             let mut_alias = arg_t.mode == ty::mo_alias(true);\n             if i != offset &&\n                    ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias) {\n-                cx.tcx.sess.span_err(args[i].span, istr::from_estr(\n-                                     #fmt[\"argument %u may alias with \\\n+                cx.tcx.sess.span_err(args[i].span,\n+                                     #ifmt[\"argument %u may alias with \\\n                      argument %u, which is not immutably rooted\",\n-                                          i, offset]));\n+                                          i, offset]);\n             }\n             i += 1u;\n         }"}, {"sha": "9a9807cf4890202d2389f5507306b96b068dde1b", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -96,11 +96,11 @@ fn lower_kind(a: kind, b: kind) -> kind {\n     if kind_lteq(a, b) { a } else { b }\n }\n \n-fn kind_to_str(k: kind) -> str {\n+fn kind_to_str(k: kind) -> istr {\n     alt k {\n-      ast::kind_pinned. { \"pinned\" }\n-      ast::kind_unique. { \"unique\" }\n-      ast::kind_shared. { \"shared\" }\n+      ast::kind_pinned. { ~\"pinned\" }\n+      ast::kind_unique. { ~\"unique\" }\n+      ast::kind_shared. { ~\"shared\" }\n     }\n }\n \n@@ -114,17 +114,17 @@ fn type_and_kind(tcx: &ty::ctxt, e: &@ast::expr) ->\n fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n                   descr: &istr) {\n     let tk = type_and_kind(tcx, e);\n-    log #fmt[\"for %s: want %s type, got %s type %s\", istr::to_estr(descr),\n+    log #ifmt[\"for %s: want %s type, got %s type %s\", descr,\n              kind_to_str(k_need), kind_to_str(tk.kind),\n-             istr::to_estr(util::ppaux::ty_to_str(tcx, tk.ty))];\n+             util::ppaux::ty_to_str(tcx, tk.ty)];\n \n     if !kind_lteq(k_need, tk.kind) {\n         let s =\n-            #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n-                 istr::to_estr(descr), kind_to_str(k_need),\n+            #ifmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n+                 descr, kind_to_str(k_need),\n                  kind_to_str(tk.kind),\n-                 istr::to_estr(util::ppaux::ty_to_str(tcx, tk.ty))];\n-        tcx.sess.span_err(e.span, istr::from_estr(s));\n+                 util::ppaux::ty_to_str(tcx, tk.ty)];\n+        tcx.sess.span_err(e.span, s);\n     }\n }\n \n@@ -169,11 +169,11 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n                 let k = ty::type_kind(tcx, t);\n                 if !kind_lteq(k_need, k) {\n                     let s =\n-                        #fmt[\"mismatched kinds for typaram %d: \\\n+                        #ifmt[\"mismatched kinds for typaram %d: \\\n                                   needed %s type, got %s type %s\",\n                              i, kind_to_str(k_need), kind_to_str(k),\n-                             istr::to_estr(util::ppaux::ty_to_str(tcx, t))];\n-                    tcx.sess.span_err(e.span, istr::from_estr(s));\n+                             util::ppaux::ty_to_str(tcx, t)];\n+                    tcx.sess.span_err(e.span, s);\n                 }\n                 i += 1;\n             }"}, {"sha": "2f3d8222e3aa437d15a7b06302f145b9682cf6ea", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -575,8 +575,7 @@ fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &istr) -> ! {\n }\n \n fn mk_unresolved_msg(id: &ident, kind: &istr) -> istr {\n-    ret istr::from_estr(\n-        #fmt[\"unresolved %s: %s\", istr::to_estr(kind), istr::to_estr(id)]);\n+    ret #ifmt[\"unresolved %s: %s\", kind, id];\n }\n \n // Lookup helpers\n@@ -1011,8 +1010,7 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n             for match: glob_imp_def in matches {\n                 let sp = match.item.span;\n                 e.sess.span_note(\n-                    sp, istr::from_estr(#fmt[\"'%s' is imported here\",\n-                                             istr::to_estr(id)]));\n+                    sp, #ifmt[\"'%s' is imported here\", id]);\n             }\n             e.sess.span_fatal(sp,\n                               ~\"'\" + id"}, {"sha": "e6f0c726310552befc611ae41ae9f8e63ca3d63f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1893,8 +1893,8 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n             alt { ti.take_glue } {\n               some(_) { }\n               none. {\n-                log #fmt[\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n@@ -1903,16 +1903,16 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_take_glue),\n                                   ti.ty_params, ~\"take\");\n-                log #fmt[\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"--- lazily_emit_tydesc_glue TAKE %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n         } else if field == abi::tydesc_field_drop_glue {\n             alt { ti.drop_glue } {\n               some(_) { }\n               none. {\n-                log #fmt[\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"+++ lazily_emit_tydesc_glue DROP %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n@@ -1921,16 +1921,16 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_drop_glue),\n                                   ti.ty_params, ~\"drop\");\n-                log #fmt[\"--- lazily_emit_tydesc_glue DROP %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"--- lazily_emit_tydesc_glue DROP %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n          } else if field == abi::tydesc_field_free_glue {\n             alt { ti.free_glue } {\n               some(_) { }\n               none. {\n-                log #fmt[\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"+++ lazily_emit_tydesc_glue FREE %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n@@ -1939,19 +1939,19 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_free_glue),\n                                   ti.ty_params, ~\"free\");\n-                log #fmt[\"--- lazily_emit_tydesc_glue FREE %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"--- lazily_emit_tydesc_glue FREE %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n         } else if field == abi::tydesc_field_cmp_glue {\n             alt { ti.cmp_glue } {\n               some(_) { }\n               none. {\n-                log #fmt[\"+++ lazily_emit_tydesc_glue CMP %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"+++ lazily_emit_tydesc_glue CMP %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n                 ti.cmp_glue = some(bcx_ccx(cx).upcalls.cmp_type);\n-                log #fmt[\"--- lazily_emit_tydesc_glue CMP %s\",\n-                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n+                log #ifmt[\"--- lazily_emit_tydesc_glue CMP %s\",\n+                         ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n         } else if field == abi::tydesc_field_copy_glue {\n@@ -6323,16 +6323,16 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n     write_metadata(cx.ccx, crate);\n     if ccx.sess.get_opts().stats {\n         log_err \"--- trans stats ---\";\n-        log_err #fmt[\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs];\n-        log_err #fmt[\"n_derived_tydescs: %u\", ccx.stats.n_derived_tydescs];\n-        log_err #fmt[\"n_glues_created: %u\", ccx.stats.n_glues_created];\n-        log_err #fmt[\"n_null_glues: %u\", ccx.stats.n_null_glues];\n-        log_err #fmt[\"n_real_glues: %u\", ccx.stats.n_real_glues];\n+        log_err #ifmt[\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs];\n+        log_err #ifmt[\"n_derived_tydescs: %u\", ccx.stats.n_derived_tydescs];\n+        log_err #ifmt[\"n_glues_created: %u\", ccx.stats.n_glues_created];\n+        log_err #ifmt[\"n_null_glues: %u\", ccx.stats.n_null_glues];\n+        log_err #ifmt[\"n_real_glues: %u\", ccx.stats.n_real_glues];\n \n \n         for timing: {ident: istr, time: int} in *ccx.stats.fn_times {\n-            log_err #fmt[\"time: %s took %d ms\",\n-                         istr::to_estr(timing.ident), timing.time];\n+            log_err #ifmt[\"time: %s took %d ms\",\n+                         timing.ident, timing.time];\n         }\n     }\n     ret llmod;"}, {"sha": "bc2beb35f5d5ee1d3bd7cac4d9ffaee8869318ca", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -170,10 +170,10 @@ fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n     let changed = find_pre_post_state_expr(fcx, pres, a);\n     // FIXME: This could be a typestate constraint\n     if vec::len(bs) != vec::len(ops) {\n-        fcx.ccx.tcx.sess.span_bug(a.span, istr::from_estr(\n-                                  #fmt[\"mismatched arg lengths: \\\n+        fcx.ccx.tcx.sess.span_bug(a.span,\n+                                  #ifmt[\"mismatched arg lengths: \\\n                                         %u exprs vs. %u ops\",\n-                                       vec::len(bs), vec::len(ops)]));\n+                                       vec::len(bs), vec::len(ops)]);\n     }\n     ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id, ops,\n                                   bs, cf) || changed;"}, {"sha": "2dc1e36f224c36473e62d3fe4ed649f90f9d4e83", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -2440,20 +2440,20 @@ mod unify {\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n         let i = 0u;\n         while i < vec::len::<ufind::node>(vb.sets.nodes) {\n-            let sets = \"\";\n+            let sets = ~\"\";\n             let j = 0u;\n             while j < vec::len::<option::t<uint>>(vb.sets.nodes) {\n-                if ufind::find(vb.sets, j) == i { sets += #fmt[\" %u\", j]; }\n+                if ufind::find(vb.sets, j) == i { sets += #ifmt[\" %u\", j]; }\n                 j += 1u;\n             }\n             let typespec;\n             alt smallintmap::find::<t>(vb.types, i) {\n-              none. { typespec = \"\"; }\n+              none. { typespec = ~\"\"; }\n               some(typ) {\n-                typespec = \" =\" + istr::to_estr(ty_to_str(tcx, typ));\n+                typespec = ~\" =\" + ty_to_str(tcx, typ);\n               }\n             }\n-            log_err #fmt[\"set %u:%s%s\", i, typespec, sets];\n+            log_err #ifmt[\"set %u:%s%s\", i, typespec, sets];\n             i += 1u;\n         }\n     }"}, {"sha": "bd49a7ef5fc86f523c14a102e0038138e5819e25", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1368,16 +1368,16 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                 let arg_len = vec::len::<ty::t>(arg_types);\n                 if arg_len != subpats_len {\n                     // TODO: note definition of tag variant\n-                    // TODO (issue #448): Wrap a #fmt string over multiple\n+                    // TODO (issue #448): Wrap a #ifmt string over multiple\n                     // lines...\n                     let s =\n-                        #fmt[\"this pattern has %u field%s, but the \\\n+                        #ifmt[\"this pattern has %u field%s, but the \\\n                                        corresponding variant has %u field%s\",\n                              subpats_len,\n-                             if subpats_len == 1u { \"\" } else { \"s\" },\n-                             arg_len, if arg_len == 1u { \"\" } else { \"s\" }];\n+                             if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n+                             arg_len, if arg_len == 1u { ~\"\" } else { ~\"s\" }];\n                     fcx.ccx.tcx.sess.span_fatal(\n-                        pat.span, istr::from_estr(s));\n+                        pat.span, s);\n                 }\n \n                 // TODO: vec::iter2\n@@ -1390,24 +1390,24 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             } else if subpats_len > 0u {\n                 // TODO: note definition of tag variant\n                 fcx.ccx.tcx.sess.span_fatal(\n-                    pat.span, istr::from_estr(\n-                    #fmt[\"this pattern has %u field%s, \\\n+                    pat.span,\n+                    #ifmt[\"this pattern has %u field%s, \\\n                           but the corresponding \\\n                           variant has no fields\",\n                          subpats_len,\n                          if subpats_len == 1u {\n-                             \"\"\n-                         } else { \"s\" }]));\n+                             ~\"\"\n+                         } else { ~\"s\" }]);\n             }\n             write::ty_fixup(fcx, pat.id, path_tpot);\n           }\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span, istr::from_estr(\n-                #fmt[\"mismatched types: expected %s, found tag\",\n-                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]));\n+                pat.span,\n+                #ifmt[\"mismatched types: expected %s, found tag\",\n+                     ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n         write::ty_fixup(fcx, pat.id, path_tpot);\n@@ -1418,20 +1418,20 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span, istr::from_estr(\n-                #fmt[\"mismatched types: expected %s, found record\",\n-                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]));\n+                pat.span,\n+                #ifmt[\"mismatched types: expected %s, found record\",\n+                     ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span, istr::from_estr(\n-                #fmt[\"mismatched types: expected a record \\\n+                pat.span,\n+                #ifmt[\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                     ex_f_count, f_count]));\n+                     ex_f_count, f_count]);\n         }\n         fn matches(name: &istr, f: &ty::field) -> bool {\n             ret istr::eq(name, f.ident);\n@@ -1440,10 +1440,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             alt vec::find(bind matches(f.ident, _), ex_fields) {\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none. {\n-                fcx.ccx.tcx.sess.span_fatal(pat.span, istr::from_estr(\n-                                            #fmt[\"mismatched types: did not \\\n+                fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                                            #ifmt[\"mismatched types: did not \\\n                                              expect a record with a field %s\",\n-                                                 istr::to_estr(f.ident)]));\n+                                                 f.ident]);\n               }\n             }\n         }\n@@ -1455,19 +1455,19 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span, istr::from_estr(\n-                #fmt[\"mismatched types: expected %s, found tuple\",\n-                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]));\n+                pat.span,\n+                #ifmt[\"mismatched types: expected %s, found tuple\",\n+                     ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n             fcx.ccx.tcx.sess.span_fatal(\n-                pat.span, istr::from_estr(\n-                #fmt[\"mismatched types: expected a tuple \\\n+                pat.span,\n+                #ifmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                     vec::len(ex_elts), e_count]));\n+                     vec::len(ex_elts), e_count]);\n         }\n         let i = 0u;\n         for elt in elts { check_pat(fcx, map, elt, ex_elts[i]); i += 1u; }\n@@ -1595,16 +1595,17 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         let expected_arg_count = vec::len(arg_tys);\n         let supplied_arg_count = vec::len(args);\n         if expected_arg_count != supplied_arg_count {\n-            fcx.ccx.tcx.sess.span_err(sp, istr::from_estr(\n-                                      #fmt[\"this function takes %u \\\n+            fcx.ccx.tcx.sess.span_err(\n+                sp,\n+                #ifmt[\"this function takes %u \\\n                       parameter%s but %u parameter%s supplied\",\n-                                           expected_arg_count,\n-                                           if expected_arg_count == 1u {\n-                                               \"\"\n-                                           } else { \"s\" }, supplied_arg_count,\n-                                           if supplied_arg_count == 1u {\n-                                               \" was\"\n-                                           } else { \"s were\" }]));\n+                      expected_arg_count,\n+                      if expected_arg_count == 1u {\n+                          ~\"\"\n+                      } else { ~\"s\" }, supplied_arg_count,\n+                      if supplied_arg_count == 1u {\n+                          ~\" was\"\n+                      } else { ~\"s were\" }]);\n             // HACK: extend the arguments list with dummy arguments to\n             // check against\n             let dummy = {mode: ty::mo_val, ty: ty::mk_nil(fcx.ccx.tcx)};\n@@ -1819,10 +1820,10 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n                 tcx.sess.span_err(\n-                    expr.span, istr::from_estr(\n-                    #fmt[\"mismatched types: expected bool \\\n+                    expr.span,\n+                    #ifmt[\"mismatched types: expected bool \\\n                           or integer but found %s\",\n-                         istr::to_estr(ty_to_str(tcx, oper_t))]));\n+                         ty_to_str(tcx, oper_t)]);\n             }\n           }\n           ast::neg. {\n@@ -2266,9 +2267,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           _ {\n             let t_err = resolve_type_vars_if_possible(fcx, base_t);\n             let msg =\n-                #fmt[\"attempted field access on type %s\",\n-                     istr::to_estr(ty_to_str(tcx, t_err))];\n-            tcx.sess.span_fatal(expr.span, istr::from_estr(msg));\n+                #ifmt[\"attempted field access on type %s\",\n+                     ty_to_str(tcx, t_err)];\n+            tcx.sess.span_fatal(expr.span, msg);\n           }\n         }\n       }"}, {"sha": "508aa1da7001a47fde399bc5af417e78724bdf42", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -80,13 +80,13 @@ fn span_to_str(sp: &span, cm: &codemap) -> istr {\n     while true {\n         let lo = lookup_char_pos(cm, cur.lo);\n         let hi = lookup_char_pos(cm, cur.hi);\n-        res += istr::from_estr(\n-            #fmt[\"%s:%u:%u: %u:%u\",\n+        res +=\n+            #ifmt[\"%s:%u:%u: %u:%u\",\n                  if some(lo.filename) == prev_file {\n-                     \"-\"\n+                     ~\"-\"\n                  } else {\n-                     istr::to_estr(lo.filename)\n-                 }, lo.line, lo.col, hi.line, hi.col]);\n+                     lo.filename\n+                 }, lo.line, lo.col, hi.line, hi.col];\n         alt cur.expanded_from {\n           os_none. { break; }\n           os_some(new_sp) {\n@@ -115,10 +115,9 @@ fn emit_diagnostic(sp: &option::t<span>, msg: &istr, kind: &istr, color: u8,\n     if term::color_supported() {\n         term::fg(io::stdout().get_buf_writer(), color);\n     }\n-    io::stdout().write_str(istr::from_estr(#fmt[\"%s:\", istr::to_estr(kind)]));\n+    io::stdout().write_str(#ifmt[~\"%s:\", kind]);\n     if term::color_supported() { term::reset(io::stdout().get_buf_writer()); }\n-    io::stdout().write_str(istr::from_estr(#fmt[\" %s\\n\",\n-                                                istr::to_estr(msg)]));\n+    io::stdout().write_str(#ifmt[~\" %s\\n\", msg]);\n \n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n@@ -148,17 +147,15 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n         // Print the offending lines\n         for line: uint in display_lines {\n             io::stdout().write_str(\n-                istr::from_estr(#fmt[\"%s:%u \",\n-                                     istr::to_estr(fm.name), line + 1u]));\n+                #ifmt[~\"%s:%u \", fm.name, line + 1u]);\n             let s = get_line(fm, line as int, file);\n             if !istr::ends_with(s, ~\"\\n\") { s += ~\"\\n\"; }\n             io::stdout().write_str(s);\n         }\n         if elided {\n             let last_line = display_lines[vec::len(display_lines) - 1u];\n-            let s = #fmt[\"%s:%u \",\n-                         istr::to_estr(fm.name), last_line + 1u];\n-            let indent = str::char_len(s);\n+            let s = #ifmt[~\"%s:%u \", fm.name, last_line + 1u];\n+            let indent = istr::char_len(s);\n             let out = ~\"\";\n             while indent > 0u { out += ~\" \"; indent -= 1u; }\n             out += ~\"...\\n\";"}, {"sha": "ce787c2bc6ed217db2b481f56026b569013fe8c8", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -26,9 +26,9 @@ fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n                 let extname = pth.node.idents[0];\n                 alt exts.find(extname) {\n                   none. {\n-                    cx.span_fatal(pth.span, istr::from_estr(\n-                                  #fmt[\"macro undefined: '%s'\",\n-                                       istr::to_estr(extname)]))\n+                    cx.span_fatal(pth.span,\n+                                  #ifmt[\"macro undefined: '%s'\",\n+                                       extname])\n                   }\n                   some(normal(ext)) {\n                     let expanded = ext(cx, pth.span, args, body);"}, {"sha": "59bc277c7417549975b195dde6843e32664839ef", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,7 +1,7 @@\n \n \n /*\n- * The compiler code necessary to support the #fmt extension.  Eventually this\n+ * The compiler code necessary to support the #ifmt extension. Eventually this\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n@@ -22,15 +22,16 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, ~\"#fmt requires arguments of the form `[...]`.\")\n+            cx.span_fatal(\n+                sp, ~\"#ifmt requires arguments of the form `[...]`.\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) == 0u {\n-        cx.span_fatal(sp, ~\"#fmt requires a format string\");\n+        cx.span_fatal(sp, ~\"#ifmt requires a format string\");\n     }\n     let fmt =\n         expr_to_str(cx, args[0],\n-                    ~\"first argument to #fmt must be a \"\n+                    ~\"first argument to #ifmt must be a \"\n                     + ~\"string literal.\");\n     let fmtspan = args[0].span;\n     log \"Format string:\";\n@@ -151,7 +152,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 let count_is_args = [count_lit];\n                 ret make_call(cx, sp, count_is_path, count_is_args);\n               }\n-              _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n+              _ { cx.span_unimpl(sp, ~\"unimplemented #ifmt conversion\"); }\n             }\n         }\n         fn make_ty(cx: &ext_ctxt, sp: span, t: &ty) -> @ast::expr {\n@@ -205,7 +206,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               _ { ret false; }\n             }\n         }\n-        let unsupported = ~\"conversion not supported in #fmt string\";\n+        let unsupported = ~\"conversion not supported in #ifmt string\";\n         alt cnv.param {\n           option::none. { }\n           _ { cx.span_unimpl(sp, unsupported); }\n@@ -217,14 +218,14 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"+ flag only valid in \" +\n-                                      ~\"signed #fmt conversion\");\n+                                      ~\"signed #ifmt conversion\");\n                 }\n               }\n               flag_space_for_sign. {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"space flag only valid in \" +\n-                                      ~\"signed #fmt conversions\");\n+                                      ~\"signed #ifmt conversions\");\n                 }\n               }\n               flag_left_zero_pad. { }\n@@ -330,7 +331,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n-                              ~\"not enough arguments to #fmt \" +\n+                              ~\"not enough arguments to #ifmt \" +\n                                   ~\"for the given format string\");\n             }\n             log \"Building conversion:\";\n@@ -345,9 +346,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n \n     if expected_nargs < nargs {\n         cx.span_fatal(\n-            sp, istr::from_estr(\n-            #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n-                 nargs, expected_nargs]));\n+            sp,\n+            #ifmt[\"too many arguments to #fmt. found %u, expected %u\",\n+                 nargs, expected_nargs]);\n     }\n     ret tmp_expr;\n }"}, {"sha": "f96b24676cbb10962e7e70ef6c2f4cdeb705afc5", "filename": "src/comp/syntax/ext/ifmt.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fifmt.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,7 +1,7 @@\n \n \n /*\n- * The compiler code necessary to support the #fmt extension.  Eventually this\n+ * The compiler code necessary to support the #ifmt extension. Eventually this\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n@@ -22,15 +22,16 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, ~\"#fmt requires arguments of the form `[...]`.\")\n+            cx.span_fatal(\n+                sp, ~\"#ifmt requires arguments of the form `[...]`.\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) == 0u {\n-        cx.span_fatal(sp, ~\"#fmt requires a format string\");\n+        cx.span_fatal(sp, ~\"#ifmt requires a format string\");\n     }\n     let fmt =\n         expr_to_str(cx, args[0],\n-                    ~\"first argument to #fmt must be a \"\n+                    ~\"first argument to #ifmt must be a \"\n                     + ~\"string literal.\");\n     let fmtspan = args[0].span;\n     log \"Format string:\";\n@@ -151,7 +152,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 let count_is_args = [count_lit];\n                 ret make_call(cx, sp, count_is_path, count_is_args);\n               }\n-              _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n+              _ { cx.span_unimpl(sp, ~\"unimplemented #ifmt conversion\"); }\n             }\n         }\n         fn make_ty(cx: &ext_ctxt, sp: span, t: &ty) -> @ast::expr {\n@@ -205,7 +206,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               _ { ret false; }\n             }\n         }\n-        let unsupported = ~\"conversion not supported in #fmt string\";\n+        let unsupported = ~\"conversion not supported in #ifmt string\";\n         alt cnv.param {\n           option::none. { }\n           _ { cx.span_unimpl(sp, unsupported); }\n@@ -217,14 +218,14 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"+ flag only valid in \" +\n-                                      ~\"signed #fmt conversion\");\n+                                      ~\"signed #ifmt conversion\");\n                 }\n               }\n               flag_space_for_sign. {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"space flag only valid in \" +\n-                                      ~\"signed #fmt conversions\");\n+                                      ~\"signed #ifmt conversions\");\n                 }\n               }\n               flag_left_zero_pad. { }\n@@ -330,7 +331,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n-                              ~\"not enough arguments to #fmt \" +\n+                              ~\"not enough arguments to #ifmt \" +\n                                   ~\"for the given format string\");\n             }\n             log \"Building conversion:\";\n@@ -345,9 +346,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n \n     if expected_nargs < nargs {\n         cx.span_fatal(\n-            sp, istr::from_estr(\n-            #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n-                 nargs, expected_nargs]));\n+            sp,\n+            #ifmt[\"too many arguments to #fmt. found %u, expected %u\",\n+                 nargs, expected_nargs]);\n     }\n     ret tmp_expr;\n }"}, {"sha": "2ab61e122444e2815bce6ac15f9024c681bed836", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -309,13 +309,13 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg =\n-                                #fmt[\"'%s' occurs %u times, but \",\n-                                     istr::to_estr(fv), len] +\n-                                    #fmt[\"'%s' occurs %u times\",\n-                                         istr::to_estr(old_name),\n+                                #ifmt[\"'%s' occurs %u times, but \",\n+                                     fv, len] +\n+                                    #ifmt[\"'%s' occurs %u times\",\n+                                         old_name,\n                                          old_len];\n                             cx.span_fatal(\n-                                repeat_me.span, istr::from_estr(msg));\n+                                repeat_me.span, msg);\n                         }\n                       }\n                     }"}, {"sha": "fa147faa1ccc3c3c52d9d3a9461bd67d75a10d4d", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -326,8 +326,7 @@ fn scan_numeric_escape(rdr: &reader, n_hex_digits: uint) -> char {\n         rdr.bump();\n         if !is_hex_digit(n) {\n             rdr.err(\n-                istr::from_estr(\n-                    #fmt[\"illegal numeric character escape: %d\", n as int]));\n+                    #ifmt[\"illegal numeric character escape: %d\", n as int]);\n             fail;\n         }\n         accum_int *= 16;\n@@ -471,8 +470,8 @@ fn next_token_inner(rdr: &reader) -> token::token {\n               'U' { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 {\n                 rdr.err(\n-                    istr::from_estr(#fmt[\"unknown character escape: %d\",\n-                                         c2 as int]));\n+                    #ifmt[\"unknown character escape: %d\",\n+                                         c2 as int]);\n                 fail;\n               }\n             }\n@@ -512,8 +511,8 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                   }\n                   c2 {\n                     rdr.err(\n-                        istr::from_estr(#fmt[\"unknown string escape: %d\",\n-                                             c2 as int]));\n+                        #ifmt[\"unknown string escape: %d\",\n+                                             c2 as int]);\n                     fail;\n                   }\n                 }\n@@ -553,7 +552,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n       '%' { ret binop(rdr, token::PERCENT); }\n       c {\n         rdr.err(\n-            istr::from_estr(#fmt[\"unkown start of token: %d\", c as int]));\n+            #ifmt[\"unkown start of token: %d\", c as int]);\n         fail;\n       }\n     }\n@@ -654,7 +653,7 @@ fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     let curr_line = ~\"/*\";\n     let level: int = 1;\n     while level > 0 {\n-        log #fmt[\"=== block comment level %d\", level];\n+        log #ifmt[\"=== block comment level %d\", level];\n         if rdr.is_eof() { rdr.err(~\"unterminated block comment\"); fail; }\n         if rdr.curr() == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);"}, {"sha": "59460a07e0697274b73ec85999bf1051075855a4", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -67,8 +67,7 @@ tag token { STRING(istr, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n fn tok_str(t: token) -> istr {\n     alt t {\n       STRING(s, len) {\n-        ret istr::from_estr(\n-            #fmt[\"STR(%s,%d)\", istr::to_estr(s), len]);\n+        ret #ifmt[~\"STR(%s,%d)\", s, len];\n       }\n       BREAK(_) { ret ~\"BREAK\"; }\n       BEGIN(_) { ret ~\"BEGIN\"; }\n@@ -87,8 +86,7 @@ fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n     while i != right && L != 0u {\n         L -= 1u;\n         if i != left { s += ~\", \"; }\n-        s += istr::from_estr(\n-            #fmt[\"%d=%s\", szs[i], istr::to_estr(tok_str(toks[i]))]);\n+        s += #ifmt[~\"%d=%s\", szs[i], tok_str(toks[i])];\n         i += 1u;\n         i %= n;\n     }\n@@ -107,7 +105,7 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // fall behind.\n \n     let n: uint = 3u * linewidth;\n-    log #fmt[\"mk_printer %u\", linewidth];\n+    log #ifmt[~\"mk_printer %u\", linewidth];\n     let token: [mutable token] = vec::init_elt_mut(EOF, n);\n     let size: [mutable int] = vec::init_elt_mut(0, n);\n     let scan_stack: [mutable uint] = vec::init_elt_mut(0u, n);\n@@ -247,7 +245,7 @@ obj printer(out: io::writer,\n     fn replace_last_token(t: token) { token[right] = t; }\n \n     fn pretty_print(t: token) {\n-        log #fmt[\"pp [%u,%u]\", left, right];\n+        log #ifmt[~\"pp [%u,%u]\", left, right];\n         alt t {\n           EOF. {\n             if !scan_stack_empty {\n@@ -263,17 +261,17 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #fmt[\"pp BEGIN/buffer [%u,%u]\", left, right];\n+            log #ifmt[~\"pp BEGIN/buffer [%u,%u]\", left, right];\n             token[right] = t;\n             size[right] = -right_total;\n             self.scan_push(right);\n           }\n           END. {\n             if scan_stack_empty {\n-                log #fmt[\"pp END/print [%u,%u]\", left, right];\n+                log #ifmt[~\"pp END/print [%u,%u]\", left, right];\n                 self.print(t, 0);\n             } else {\n-                log #fmt[\"pp END/buffer [%u,%u]\", left, right];\n+                log #ifmt[~\"pp END/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n                 token[right] = t;\n                 size[right] = -1;\n@@ -287,7 +285,7 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #fmt[\"pp BREAK/buffer [%u,%u]\", left, right];\n+            log #ifmt[~\"pp BREAK/buffer [%u,%u]\", left, right];\n             self.check_stack(0);\n             self.scan_push(right);\n             token[right] = t;\n@@ -296,10 +294,10 @@ obj printer(out: io::writer,\n           }\n           STRING(s, len) {\n             if scan_stack_empty {\n-                log #fmt[\"pp STRING/print [%u,%u]\", left, right];\n+                log #ifmt[~\"pp STRING/print [%u,%u]\", left, right];\n                 self.print(t, len);\n             } else {\n-                log #fmt[\"pp STRING/buffer [%u,%u]\", left, right];\n+                log #ifmt[~\"pp STRING/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n                 token[right] = t;\n                 size[right] = len;\n@@ -310,14 +308,14 @@ obj printer(out: io::writer,\n         }\n     }\n     fn check_stream() {\n-        log #fmt[\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n+        log #ifmt[~\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n                  left, right, left_total, right_total];\n         if right_total - left_total > space {\n-            log #fmt[\"scan window is %d, longer than space on line (%d)\",\n+            log #ifmt[~\"scan window is %d, longer than space on line (%d)\",\n                      right_total - left_total, space];\n             if !scan_stack_empty {\n                 if left == scan_stack[bottom] {\n-                    log #fmt[\"setting %u to infinity and popping\", left];\n+                    log #ifmt[\"setting %u to infinity and popping\", left];\n                     size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n@@ -326,7 +324,7 @@ obj printer(out: io::writer,\n         }\n     }\n     fn scan_push(x: uint) {\n-        log #fmt[\"scan_push %u\", x];\n+        log #ifmt[\"scan_push %u\", x];\n         if scan_stack_empty {\n             scan_stack_empty = false;\n         } else { top += 1u; top %= buf_len; assert (top != bottom); }\n@@ -355,7 +353,7 @@ obj printer(out: io::writer,\n         assert (right != left);\n     }\n     fn advance_left(x: token, L: int) {\n-        log #fmt[\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L];\n+        log #ifmt[\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L];\n         if L >= 0 {\n             self.print(x, L);\n             alt x {\n@@ -394,13 +392,13 @@ obj printer(out: io::writer,\n         }\n     }\n     fn print_newline(amount: int) {\n-        log #fmt[\"NEWLINE %d\", amount];\n+        log #ifmt[\"NEWLINE %d\", amount];\n         out.write_str(~\"\\n\");\n         pending_indentation = 0;\n         self.indent(amount);\n     }\n     fn indent(amount: int) {\n-        log #fmt[\"INDENT %d\", amount];\n+        log #ifmt[\"INDENT %d\", amount];\n         pending_indentation += amount;\n     }\n     fn top() -> print_stack_elt {\n@@ -417,15 +415,15 @@ obj printer(out: io::writer,\n         out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n-        log #fmt[\"print %s %d (remaining line space=%d)\",\n-                 istr::to_estr(tok_str(x)), L,\n+        log #ifmt[\"print %s %d (remaining line space=%d)\",\n+                 tok_str(x), L,\n                  space];\n         log buf_str(token, size, left, right, 6u);\n         alt x {\n           BEGIN(b) {\n             if L > space {\n                 let col = margin - space + b.offset;\n-                log #fmt[\"print BEGIN -> push broken block at col %d\", col];\n+                log #ifmt[\"print BEGIN -> push broken block at col %d\", col];\n                 print_stack += [{offset: col, pbreak: broken(b.breaks)}];\n             } else {\n                 log \"print BEGIN -> push fitting block\";"}, {"sha": "c1db95b2aaf74ac1c530003390ba442849a10b85", "filename": "src/comp/syntax/untyped_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -362,7 +362,7 @@ fn dummy() {\n          alt *elts.(idx) {\n            leaf_destructure(x) { x }\n            _ {\n-             ctx.ff(sp, #fmt[\"expected %s in position %u\",\n+             ctx.ff(sp, #ifmt[\"expected %s in position %u\",\n                              #ident_to_str[leaf_destructure], idx])\n            }\n          }],"}, {"sha": "44d80bd3d7dc94575852232ee928b3136268e573", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -195,7 +195,7 @@ fn check_whole_compiler(code: &str) {\n             ~\"/Users/jruderman/code/rust/build/stage1/rustc\",\n             [~\"-c\", istr::from_estr(filename)]);\n \n-    //log_err #fmt(\"Status: %d\", p.status);\n+    //log_err #ifmt(\"Status: %d\", p.status);\n     //log_err \"Output: \" + p.out;\n     if p.err != \"\" {\n         if contains(p.err, \"argument of incompatible type\") {\n@@ -265,7 +265,7 @@ fn content_is_dangerous_to_modify(code: &str) -> bool {\n     let dangerous_patterns =\n         [\"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n          \"#macro\", // not safe to steal things inside of it, because they have a special syntax\n-         \"#\", // strange representation of the arguments to #fmt, for example\n+         \"#\", // strange representation of the arguments to #ifmt, for example\n          \" be \", // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n          \"@\"]; // hangs when compiling: https://github.com/graydon/rust/issues/768\n \n@@ -327,9 +327,9 @@ fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n     }\n \n     if old == new {\n-        log_err #fmt[\"Converged after %u iterations\", i];\n+        log_err #ifmt[\"Converged after %u iterations\", i];\n     } else {\n-        log_err #fmt[\"Did not converge after %u iterations!\", i];\n+        log_err #ifmt[\"Did not converge after %u iterations!\", i];\n         write_file(\"round-trip-a.rs\", old);\n         write_file(\"round-trip-b.rs\", new);\n         std::run::run_program(~\"diff\",\n@@ -340,12 +340,12 @@ fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n }\n \n fn check_convergence(files: &[str]) {\n-    log_err #fmt[\"pp convergence tests: %u files\", vec::len(files)];\n+    log_err #ifmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = istr::to_estr(io::read_whole_file_str(istr::from_estr(file)));\n             if !content_is_confusing(s) {\n-                log_err #fmt[\"pp converge: %s\", file];\n+                log_err #ifmt[\"pp converge: %s\", istr::from_estr(file)];\n                 // Change from 7u to 2u when https://github.com/graydon/rust/issues/759 is fixed\n                 check_roundtrip_convergence(s, 7u);\n             }\n@@ -377,7 +377,7 @@ fn check_variants(files: &[str]) {\n \n fn main(args: [str]) {\n     if vec::len(args) != 2u {\n-        log_err #fmt[\"usage: %s <testdir>\", args[0]];\n+        log_err #ifmt[\"usage: %s <testdir>\", istr::from_estr(args[0])];\n         ret;\n     }\n     let files = [];"}, {"sha": "f85b8ccabbe0bafe10e78e3c50dec00277b33e9a", "filename": "src/lib/net.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -7,8 +7,7 @@ tag ip_addr { ipv4(u8, u8, u8, u8); }\n fn format_addr(ip: ip_addr) -> istr {\n     alt ip {\n       ipv4(a, b, c, d) {\n-        istr::from_estr(\n-            #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint])\n+        #ifmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n       }\n       _ { fail \"Unsupported address type\"; }\n     }"}, {"sha": "f9765e64b887fead6dffd074a0f9750dfaaa9ac5", "filename": "src/lib/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -81,7 +81,7 @@ fn join(task_port: (task_id, comm::port<task_notification>)) -> task_result {\n       exit(_id, res) {\n         if _id == id {\n             ret res\n-        } else { fail #fmt[\"join received id %d, expected %d\", _id, id] }\n+        } else { fail #ifmt[\"join received id %d, expected %d\", _id, id] }\n       }\n     }\n }"}, {"sha": "ee0ef3cab4c0e23c81327b8a2fd11ec07a604d7f", "filename": "src/lib/test.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -120,11 +120,11 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n             st.out.write_line(\n-                istr::from_estr(#fmt[\"\\nrunning %u tests\", st.total]));\n+                #ifmt[\"\\nrunning %u tests\", st.total]);\n           }\n           te_wait(test) {\n             st.out.write_str(\n-                istr::from_estr(#fmt[\"test %s ... \", test.name]));\n+                #ifmt[\"test %s ... \", istr::from_estr(test.name)]);\n           }\n           te_result(test, result) {\n             alt result {\n@@ -167,19 +167,18 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n         st.out.write_line(~\"\\nfailures:\");\n         for test: test_desc in st.failures {\n             let testname = test.name; // Satisfy alias analysis\n-            st.out.write_line(istr::from_estr(#fmt[\"    %s\", testname]));\n+            st.out.write_line(#ifmt[\"    %s\", istr::from_estr(testname)]);\n         }\n     }\n \n-    st.out.write_str(istr::from_estr(#fmt[\"\\nresult: \"]));\n+    st.out.write_str(#ifmt[\"\\nresult: \"]);\n     if success {\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n     st.out.write_str(\n-        istr::from_estr(\n-            #fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n-                          st.failed, st.ignored]));\n+            #ifmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n+                          st.failed, st.ignored]);\n \n     ret success;\n \n@@ -226,7 +225,7 @@ fn run_tests(opts: &test_opts, tests: &[test_desc], to_task: &test_to_task,\n     // provide a great user experience because you might sit waiting for the\n     // result of a particular test for an unusually long amount of time.\n     let concurrency = get_concurrency();\n-    log #fmt[\"using %u test tasks\", concurrency];\n+    log #ifmt[\"using %u test tasks\", concurrency];\n     let total = vec::len(filtered_tests);\n     let run_idx = 0u;\n     let wait_idx = 0u;"}, {"sha": "d0896241c9ef5dc5016684d0b4f421088b79c932", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -28,7 +28,7 @@ fn main() {\n     } else { max_depth = n; }\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(0, stretch_depth);\n-    log #fmt[\"stretch tree of depth %d\\t check: %d\", stretch_depth,\n+    log #ifmt[\"stretch tree of depth %d\\t check: %d\", stretch_depth,\n              item_check(stretch_tree)];\n     let long_lived_tree = bottom_up_tree(0, max_depth);\n     let depth = min_depth;\n@@ -43,10 +43,10 @@ fn main() {\n             chk += item_check(temp_tree);\n             i += 1;\n         }\n-        log #fmt[\"%d\\t trees of depth %d\\t check: %d\", iterations * 2, depth,\n+        log #ifmt[\"%d\\t trees of depth %d\\t check: %d\", iterations * 2, depth,\n                  chk];\n         depth += 2;\n     }\n-    log #fmt[\"long lived trees of depth %d\\t check: %d\", max_depth,\n+    log #ifmt[\"long lived trees of depth %d\\t check: %d\", max_depth,\n              item_check(long_lived_tree)];\n }"}, {"sha": "bc0433edcdc639e12f850f1cc6c699dcf64b550b", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -58,5 +58,5 @@ fn fannkuch(n: int) -> int {\n \n fn main(args: [str]) {\n     let n = 7;\n-    log #fmt[\"Pfannkuchen(%d) = %d\", n, fannkuch(n)];\n+    log #ifmt[\"Pfannkuchen(%d) = %d\", n, fannkuch(n)];\n }"}, {"sha": "08764bbf5cfdc20f4ace0a43250d9e9abcaa4d5d", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -69,7 +69,7 @@ fn stress_task(id: int) {\n         let n = 15;\n         assert (fib(n) == fib(n));\n         i += 1;\n-        log_err #fmt[\"%d: Completed %d iterations\", id, i];\n+        log_err #ifmt[\"%d: Completed %d iterations\", id, i];\n     }\n }\n \n@@ -108,9 +108,8 @@ fn main(argv: [str]) {\n                     let elapsed = stop - start;\n \n                     out.write_line(\n-                        istr::from_estr(\n-                            #fmt[\"%d\\t%d\\t%s\", n, fibn,\n-                                 istr::to_estr(u64::str(elapsed))]));\n+                            #ifmt[\"%d\\t%d\\t%s\", n, fibn,\n+                                 u64::str(elapsed)]);\n                 }\n             }\n         }"}, {"sha": "9e67911fc8790f510cfce0d12940d0ce05b1c1c7", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -128,7 +128,7 @@ mod map_reduce {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n-                    // log_err #fmt(\"received %d\", v);\n+                    // log_err #ifmt(\"received %d\", v);\n                     ret some(v);\n                   }\n                   done. {\n@@ -203,7 +203,7 @@ fn main(argv: [str]) {\n         let out = io::stdout();\n \n         out.write_line(\n-            istr::from_estr(#fmt[\"Usage: %s <filename> ...\", argv[0]]));\n+            #ifmt[\"Usage: %s <filename> ...\", istr::from_estr(argv[0])]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program."}, {"sha": "bb976d23e1611471cada960d3d3b371bf11956d7", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -124,7 +124,7 @@ mod map_reduce {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n-                    // log_err #fmt(\"received %d\", v);\n+                    // log_err #ifmt(\"received %d\", v);\n                     ret some(v);\n                   }\n                   done. {\n@@ -198,8 +198,8 @@ fn main(argv: [str]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n-        out.write_line(istr::from_estr(\n-            #fmt[\"Usage: %s <filename> ...\", argv[0]]));\n+        out.write_line(\n+            #ifmt[\"Usage: %s <filename> ...\", istr::from_estr(argv[0])]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program."}, {"sha": "7d9d7770b8940c20cb9b670f12790a492d043ace", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,7 +1,7 @@\n-// error-pattern:expecting [, found fmt\n+// error-pattern:expecting [, found ifmt\n \n // Don't know how to deal with a syntax extension appearing after an\n // item attribute. Probably could use a better error message.\n #[foo = \"bar\"]\n-#fmt(\"baz\")\n+#ifmt(\"baz\")\n fn main() { }\n\\ No newline at end of file"}, {"sha": "55adc1caec504f634ea76cb881bc72f1a7f1f433", "filename": "src/test/compile-fail/extfmt-missing-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:missing type\n \n-fn main() { #fmt[\"%+\"]; }\n+fn main() { #ifmt[\"%+\"]; }"}, {"sha": "c69a4410fe0243f51675827446441b776e1d498b", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:format string\n \n-fn main() { #fmt[]; }\n+fn main() { #ifmt[]; }"}, {"sha": "451e020fcafd9cd4725ffaf4f971d22a0cb54480", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,8 +1,8 @@\n // error-pattern: literal\n \n fn main() {\n-    // #fmt's first argument must be a literal.  Hopefully this\n+    // #ifmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #fmt[\"a\" + \"b\"];\n+    let x = #ifmt[\"a\" + \"b\"];\n }"}, {"sha": "19af91bfcc7567188e414ab8e055304dca6c23ef", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,8 +1,8 @@\n // error-pattern: literal\n \n fn main() {\n-    // #fmt's first argument must be a literal.  Hopefully this\n+    // #ifmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #fmt[20];\n+    let x = #ifmt[20];\n }"}, {"sha": "beb9d3d8e96814951d204e795a574c90acf97b7b", "filename": "src/test/compile-fail/extfmt-not-enough-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #fmt[\"%s%s%s\", \"test\", \"test\"]; }\n+fn main() { let s = #ifmt[\"%s%s%s\", \"test\", \"test\"]; }"}, {"sha": "393fd4ca618fb9b3f7e3e1d5c84ecb1d311cca9b", "filename": "src/test/compile-fail/extfmt-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #fmt[\"%s\", \"test\", \"test\"]; }\n+fn main() { let s = #ifmt[\"%s\", \"test\", \"test\"]; }"}, {"sha": "7d2ce0902de68b18b6f197a577c20f8defd55db5", "filename": "src/test/compile-fail/extfmt-unknown-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unknown type\n \n-fn main() { #fmt[\"%w\"]; }\n+fn main() { #ifmt[\"%w\"]; }"}, {"sha": "6f847b93bab4481e6f528800e1ddb1792b815308", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,6 +1,6 @@\n-// error-pattern:only valid in signed #fmt conversion\n+// error-pattern:only valid in signed #ifmt conversion\n \n fn main() {\n     // Can't use a sign on unsigned conversions\n-    #fmt[\"%+u\", 10u];\n+    #ifmt[\"%+u\", 10u];\n }"}, {"sha": "ecd026b33d896bf98569b58210788f3681fd0b03", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,6 +1,6 @@\n-// error-pattern:only valid in signed #fmt conversion\n+// error-pattern:only valid in signed #ifmt conversion\n \n fn main() {\n     // Can't use a space on unsigned conversions\n-    #fmt[\"% u\", 10u];\n+    #ifmt[\"% u\", 10u];\n }"}, {"sha": "19cd69c7f695989f978b8e0c0ae0876a043b0169", "filename": "src/test/compile-fail/extfmt-unterminated-conv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unterminated conversion\n \n-fn main() { #fmt[\"%\"]; }\n+fn main() { #ifmt[\"%\"]; }"}, {"sha": "bce5cdf232d69d92a0845d1cc1584c90f2f2e8a4", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -72,34 +72,21 @@ fn parse_config(args: &[istr]) -> config {\n \n fn log_config(config: &config) {\n     let c = config;\n-    logv(c, istr::from_estr(\n-        #fmt[\"configuration:\"]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"compile_lib_path: %s\",\n-             istr::to_estr(config.compile_lib_path)]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"run_lib_path: %s\", istr::to_estr(config.run_lib_path)]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"rustc_path: %s\", istr::to_estr(config.rustc_path)]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"src_base: %s\", istr::to_estr(config.src_base)]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"build_base: %s\", istr::to_estr(config.build_base)]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"stage_id: %s\", istr::to_estr(config.stage_id)]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"mode: %s\", istr::to_estr(mode_str(config.mode))]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"run_ignored: %b\", config.run_ignored]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"filter: %s\", istr::to_estr(opt_str(config.filter))]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"runtool: %s\", istr::to_estr(opt_str(config.runtool))]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"rustcflags: %s\", istr::to_estr(opt_str(config.rustcflags))]));\n-    logv(c, istr::from_estr(\n-        #fmt[\"verbose: %b\", config.verbose]));\n-    logv(c, istr::from_estr(#fmt[\"\\n\"]));\n+    logv(c, #ifmt[\"configuration:\"]);\n+    logv(c, #ifmt[\"compile_lib_path: %s\",\n+                 config.compile_lib_path]);\n+    logv(c, #ifmt[\"run_lib_path: %s\", config.run_lib_path]);\n+    logv(c, #ifmt[\"rustc_path: %s\", config.rustc_path]);\n+    logv(c, #ifmt[\"src_base: %s\", config.src_base]);\n+    logv(c, #ifmt[\"build_base: %s\", config.build_base]);\n+    logv(c, #ifmt[\"stage_id: %s\", config.stage_id]);\n+    logv(c, #ifmt[\"mode: %s\", mode_str(config.mode)]);\n+    logv(c, #ifmt[\"run_ignored: %b\", config.run_ignored]);\n+    logv(c, #ifmt[\"filter: %s\", opt_str(config.filter)]);\n+    logv(c, #ifmt[\"runtool: %s\", opt_str(config.runtool)]);\n+    logv(c, #ifmt[\"rustcflags: %s\", opt_str(config.rustcflags)]);\n+    logv(c, #ifmt[\"verbose: %b\", config.verbose]);\n+    logv(c, #ifmt[\"\\n\"]);\n }\n \n fn opt_str(maybestr: option::t<istr>) -> istr {\n@@ -154,11 +141,12 @@ type tests_and_conv_fn =\n     {tests: [test::test_desc], to_task: fn(&fn()) -> test::joinable};\n \n fn make_tests(cx: &cx) -> tests_and_conv_fn {\n-    log #fmt[\"making tests from %s\", istr::to_estr(cx.config.src_base)];\n+    log #ifmt[\"making tests from %s\", cx.config.src_base];\n     let configport = port::<[u8]>();\n     let tests = [];\n     for file: istr in fs::list_dir(cx.config.src_base) {\n-        log #fmt[\"inspecting file %s\", istr::to_estr(file)];\n+        let file = file;\n+        log #ifmt[\"inspecting file %s\", file];\n         if is_test(cx.config, file) {\n             tests += [make_test(cx, file, configport)];\n         }\n@@ -196,9 +184,9 @@ fn make_test(cx: &cx, testfile: &istr, configport: &port<[u8]>) ->\n }\n \n fn make_test_name(config: &config, testfile: &istr) -> str {\n-    #fmt[\"[%s] %s\",\n-         istr::to_estr(mode_str(config.mode)),\n-         istr::to_estr(testfile)]\n+    istr::to_estr(\n+        #ifmt[\"[%s] %s\", mode_str(config.mode),\n+              testfile])\n }\n \n /*"}, {"sha": "0c8eff0aac902918ba504046b894da3240a22391", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -115,9 +115,8 @@ fn parse_name_value_directive(line: &istr,\n         let value =\n             istr::slice(line, colon + istr::byte_len(keycolon),\n                        istr::byte_len(line));\n-        log #fmt(\"%s: %s\",\n-                 istr::to_estr(directive),\n-                 istr::to_estr(value));\n+        log #ifmt(\"%s: %s\", directive,\n+                  value);\n         option::some(value)\n     } else { option::none }\n }"}, {"sha": "4339ab18690a0ddb8567e73b7f29c4f60312a0c1", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -25,7 +25,7 @@ fn run(cx: &cx, _testfile: -[u8]) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");\n     }\n-    log #fmt[\"running %s\", istr::to_estr(testfile)];\n+    log #ifmt[\"running %s\", testfile];\n     let props = load_props(testfile);\n     alt cx.config.mode {\n       mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n@@ -91,15 +91,13 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n \n     let round = 0;\n     while round < rounds {\n-        logv(cx.config,\n-             istr::from_estr(#fmt[\"pretty-printing round %d\", round]));\n+        logv(cx.config, #ifmt[\"pretty-printing round %d\", round]);\n         let procres = print_source(cx, testfile, srcs[round]);\n \n         if procres.status != 0 {\n             fatal_procres(\n-                istr::from_estr(#fmt[\"pretty-printing failed in round %d\",\n-                                     round]),\n-                procres);\n+                    #ifmt[\"pretty-printing failed in round %d\", round],\n+                    procres);\n         }\n \n         srcs += [procres.stdout];\n@@ -150,7 +148,7 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n         if expected != actual {\n             error(~\"pretty-printed source does match expected source\");\n             let msg =\n-                #fmt[\"\\n\\\n+                #ifmt[\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n %s\\n\\\n@@ -160,8 +158,9 @@ actual:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-                     istr::to_estr(expected), istr::to_estr(actual)];\n-            io::stdout().write_str(istr::from_estr(msg));\n+                     expected,\n+                      actual];\n+            io::stdout().write_str(msg);\n             fail;\n         }\n     }\n@@ -192,7 +191,8 @@ fn check_error_patterns(props: &test_props, testfile: &istr,\n     let next_err_pat = props.error_patterns[next_err_idx];\n     for line: istr in istr::split(procres.stdout, '\\n' as u8) {\n         if istr::find(line, next_err_pat) > 0 {\n-            log #fmt[\"found error pattern %s\", istr::to_estr(next_err_pat)];\n+            log #ifmt[\"found error pattern %s\",\n+                      next_err_pat];\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n                 log \"found all error patterns\";\n@@ -206,14 +206,13 @@ fn check_error_patterns(props: &test_props, testfile: &istr,\n         vec::slice(props.error_patterns, next_err_idx,\n                    vec::len(props.error_patterns));\n     if vec::len(missing_patterns) == 1u {\n-        fatal_procres(istr::from_estr(\n-            #fmt[\"error pattern '%s' not found!\",\n-                 istr::to_estr(missing_patterns[0])]), procres);\n+        fatal_procres(\n+            #ifmt[\"error pattern '%s' not found!\",\n+                  missing_patterns[0]], procres);\n     } else {\n         for pattern: istr in missing_patterns {\n-            error(istr::from_estr(\n-                #fmt[\"error pattern '%s' not found!\",\n-                     istr::to_estr(pattern)]));\n+            error(#ifmt[\"error pattern '%s' not found!\",\n+                        pattern]);\n         }\n         fatal_procres(~\"multiple error patterns not found\", procres);\n     }\n@@ -301,9 +300,8 @@ fn program_output(cx: &cx, testfile: &istr, lib_path: &istr, prog: &istr,\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(cx.config,\n-                 istr::from_estr(#fmt[\"executing %s\",\n-                                      istr::to_estr(cmdline)]));\n+            logv(cx.config, #ifmt[\"executing %s\",\n+                                  cmdline]);\n             cmdline\n         };\n     let res = procsrv::run(cx.procsrv, lib_path, prog, args, input);\n@@ -315,18 +313,18 @@ fn program_output(cx: &cx, testfile: &istr, lib_path: &istr, prog: &istr,\n }\n \n fn make_cmdline(libpath: &istr, prog: &istr, args: &[istr]) -> istr {\n-    istr::from_estr(#fmt[\"%s %s %s\",\n-                         istr::to_estr(lib_path_cmd_prefix(libpath)),\n-                         istr::to_estr(prog),\n-                         istr::to_estr(istr::connect(args, ~\" \"))])\n+    #ifmt[\"%s %s %s\",\n+          lib_path_cmd_prefix(libpath),\n+          prog,\n+          istr::connect(args, ~\" \")]\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n fn lib_path_cmd_prefix(path: &istr) -> istr {\n-    istr::from_estr(#fmt[\"%s=\\\"%s\\\"\",\n-                         istr::to_estr(util::lib_path_env_var()),\n-                         istr::to_estr(util::make_new_path(path))])\n+        #ifmt[\"%s=\\\"%s\\\"\",\n+              util::lib_path_env_var(),\n+              util::make_new_path(path)]\n }\n \n fn dump_output(config: &config, testfile: &istr, out: &istr, err: &istr) {\n@@ -365,34 +363,32 @@ fn output_base_name(config: &config, testfile: &istr) -> istr {\n             parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n             istr::connect(parts, ~\".\")\n         };\n-    istr::from_estr(#fmt[\"%s%s.%s\", istr::to_estr(base),\n-                         istr::to_estr(filename),\n-                         istr::to_estr(config.stage_id)])\n+    #ifmt[\"%s%s.%s\", base, filename,\n+                        config.stage_id]\n }\n \n fn maybe_dump_to_stdout(config: &config, out: &istr, err: &istr) {\n     if config.verbose {\n-        let sep1 = #fmt[\"------%s------------------------------\", \"stdout\"];\n-        let sep2 = #fmt[\"------%s------------------------------\", \"stderr\"];\n+        let sep1 = #ifmt[\"------%s------------------------------\", ~\"stdout\"];\n+        let sep2 = #ifmt[\"------%s------------------------------\", ~\"stderr\"];\n         let sep3 = ~\"------------------------------------------\";\n-        io::stdout().write_line(istr::from_estr(sep1));\n+        io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n-        io::stdout().write_line(istr::from_estr(sep2));\n+        io::stdout().write_line(sep2);\n         io::stdout().write_line(err);\n         io::stdout().write_line(sep3);\n     }\n }\n \n fn error(err: &istr) {\n-    io::stdout().write_line(istr::from_estr(#fmt[\"\\nerror: %s\",\n-                                                 istr::to_estr(err)]));\n+    io::stdout().write_line(#ifmt[\"\\nerror: %s\", err]);\n }\n \n fn fatal(err: &istr) -> ! { error(err); fail; }\n \n fn fatal_procres(err: &istr, procres: procres) -> ! {\n     let msg =\n-        istr::from_estr(#fmt[\"\\n\\\n+        #ifmt[\"\\n\\\n error: %s\\n\\\n command: %s\\n\\\n stdout:\\n\\\n@@ -404,10 +400,10 @@ stderr:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-                             istr::to_estr(err),\n-                             istr::to_estr(procres.cmdline),\n-                             istr::to_estr(procres.stdout),\n-                             istr::to_estr(procres.stderr)]);\n+                             err,\n+                             procres.cmdline,\n+                             procres.stdout,\n+                             procres.stderr];\n     io::stdout().write_str(msg);\n     fail;\n }"}, {"sha": "6c845b8ff5fa6899bab35027c56a6baca3212a82", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -11,8 +11,7 @@ fn make_new_path(path: &istr) -> istr {\n     // maintain the current value while adding our own\n     alt getenv(lib_path_env_var()) {\n       option::some(curr) {\n-        istr::from_estr(#fmt[\"%s:%s\",\n-                             istr::to_estr(path), istr::to_estr(curr)]) }\n+        #ifmt[\"%s:%s\", path, curr] }\n       option::none. { path }\n     }\n }"}, {"sha": "e61a3ffeb36027a6993f36bc98d5b3c77a2b2575", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -3,4 +3,4 @@\n use std;\n import std::str;\n \n-fn main() { let str_var: str = \"meh\"; fail #fmt[\"%s\", str_var]; }\n+fn main() { let str_var: istr = ~\"meh\"; fail #ifmt[\"%s\", str_var]; }"}, {"sha": "2663745a5af985a88b43db111e81479df78dce91", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -167,7 +167,7 @@ mod test_distinguish_syntax_ext {\n     use std;\n \n     fn f() {\n-        #fmt[\"test%s\", \"s\"];\n+        #ifmt[\"test%s\", ~\"s\"];\n         #[attr = \"val\"]\n         fn g() { }\n     }"}, {"sha": "8aaf9c6142896d124b11039441acccbe56dc2fb2", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498e38b705348333df9ab02059d07f114baccc45/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=498e38b705348333df9ab02059d07f114baccc45", "patch": "@@ -54,7 +54,7 @@ fn test_simple() {\n  // Silly, but what else can we do?\n     check vec::same_length(expected, immut_names);\n     let pairs = vec::zip(expected, immut_names);\n-    for (a, b) in pairs { log #fmt[\"%d %d\", a, b]; assert (a == b); }\n+    for (a, b) in pairs { log #ifmt[\"%d %d\", a, b]; assert (a == b); }\n }\n \n // Local Variables:"}]}