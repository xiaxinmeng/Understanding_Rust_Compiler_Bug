{"sha": "50d99ec32ce197fb3c355d7cd88ace82e538790e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZDk5ZWMzMmNlMTk3ZmIzYzM1NWQ3Y2Q4OGFjZTgyZTUzODc5MGU=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2011-10-27T19:57:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-27T20:37:53Z"}, "message": "Add documentation to std::uint", "tree": {"sha": "31892766a20a1f2550a79739acf8e1c22a96d429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31892766a20a1f2550a79739acf8e1c22a96d429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50d99ec32ce197fb3c355d7cd88ace82e538790e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50d99ec32ce197fb3c355d7cd88ace82e538790e", "html_url": "https://github.com/rust-lang/rust/commit/50d99ec32ce197fb3c355d7cd88ace82e538790e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50d99ec32ce197fb3c355d7cd88ace82e538790e/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9f9227a1c3d944ea9f5d88c721fbb32473b5454", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f9227a1c3d944ea9f5d88c721fbb32473b5454", "html_url": "https://github.com/rust-lang/rust/commit/a9f9227a1c3d944ea9f5d88c721fbb32473b5454"}], "stats": {"total": 83, "additions": 73, "deletions": 10}, "files": [{"sha": "e5eb6a1b182e804579f8837bb6ead50454de47dc", "filename": "src/lib/uint.rs", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/50d99ec32ce197fb3c355d7cd88ace82e538790e/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d99ec32ce197fb3c355d7cd88ace82e538790e/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=50d99ec32ce197fb3c355d7cd88ace82e538790e", "patch": "@@ -1,49 +1,78 @@\n-/**\n- * Return the minimal value for an uint.\n- *\n- * This is always 0\n- */\n+/*\n+Module: uint\n+*/\n+\n+/*\n+Function: min_value\n+\n+Return the minimal value for an uint.\n+\n+This is always 0\n+*/\n pure fn min_value() -> uint { ret 0u; }\n \n-/**\n- * Return the maximal value for an uint.\n- *\n- * This is 2^wordsize - 1\n- */\n+/*\n+Function: max_value\n+\n+Return the maximal value for an uint.\n+\n+This is 2^wordsize - 1\n+*/\n pure fn max_value() -> uint {\n      ret 0u - 1u;\n }\n \n+/* Function: add */\n pure fn add(x: uint, y: uint) -> uint { ret x + y; }\n \n+/* Function: sub */\n pure fn sub(x: uint, y: uint) -> uint { ret x - y; }\n \n+/* Function: mul */\n pure fn mul(x: uint, y: uint) -> uint { ret x * y; }\n \n+/* Function: div */\n pure fn div(x: uint, y: uint) -> uint { ret x / y; }\n \n+/* Function: rem */\n pure fn rem(x: uint, y: uint) -> uint { ret x % y; }\n \n+/* Predicate: lt */\n pure fn lt(x: uint, y: uint) -> bool { ret x < y; }\n \n+/* Predicate: le */\n pure fn le(x: uint, y: uint) -> bool { ret x <= y; }\n \n+/* Predicate: eq */\n pure fn eq(x: uint, y: uint) -> bool { ret x == y; }\n \n+/* Predicate: ne */\n pure fn ne(x: uint, y: uint) -> bool { ret x != y; }\n \n+/* Predicate: ge */\n pure fn ge(x: uint, y: uint) -> bool { ret x >= y; }\n \n+/* Predicate: gt */\n pure fn gt(x: uint, y: uint) -> bool { ret x > y; }\n \n fn max(x: uint, y: uint) -> uint { if x > y { ret x; } ret y; }\n \n fn min(x: uint, y: uint) -> uint { if x > y { ret y; } ret x; }\n \n+/*\n+Function: range\n+\n+Iterate over the range [`lo`..`hi`)\n+*/\n fn range(lo: uint, hi: uint, it: block(uint)) {\n     while lo < hi { it(lo); lo += 1u; }\n }\n \n+/*\n+Function: next_power_of_two\n+\n+Returns the smallest power of 2 greater than or equal to `n`\n+*/\n fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;\n     let tmp: uint = n - 1u;\n@@ -52,6 +81,20 @@ fn next_power_of_two(n: uint) -> uint {\n     ret tmp + 1u;\n }\n \n+/*\n+Function: parse_buf\n+\n+Parse a buffer of bytes\n+\n+Parameters:\n+\n+buf - A byte buffer\n+radix - The base of the number\n+\n+Failure:\n+\n+buf must not be empty\n+*/\n fn parse_buf(buf: [u8], radix: uint) -> uint {\n     if vec::len::<u8>(buf) == 0u {\n         log_err \"parse_buf(): buf is empty\";\n@@ -69,8 +112,22 @@ fn parse_buf(buf: [u8], radix: uint) -> uint {\n     fail;\n }\n \n+/*\n+Function: from_str\n+\n+Parse a string to an int\n+\n+Failure:\n+\n+s must not be empty\n+*/\n fn from_str(s: str) -> uint { parse_buf(str::bytes(s), 10u) }\n \n+/*\n+Function: to_str\n+\n+Convert to a string in a given base\n+*/\n fn to_str(num: uint, radix: uint) -> str {\n     let n = num;\n     assert (0u < radix && radix <= 16u);\n@@ -106,6 +163,12 @@ fn to_str(num: uint, radix: uint) -> str {\n     while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n     ret s1;\n }\n+\n+/*\n+Function: str\n+\n+Convert to a string\n+*/\n fn str(i: uint) -> str { ret to_str(i, 10u); }\n \n // Local Variables:"}]}