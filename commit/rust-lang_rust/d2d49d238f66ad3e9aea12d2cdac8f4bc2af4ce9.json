{"sha": "d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZDQ5ZDIzOGY2NmFkM2U5YWVhMTJkMmNkYWM4ZjRiYzJhZjRjZTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-14T20:56:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-14T20:56:22Z"}, "message": "Rollup merge of #63507 - estebank:type-inference-error, r=Centril\n\nWhen needing type annotations in local bindings, account for impl Trait and closures\n\nFix https://github.com/rust-lang/rust/issues/46680, fix https://github.com/rust-lang/rust/issues/63504, fix https://github.com/rust-lang/rust/issues/63506, fix #40014, cc https://github.com/rust-lang/rust/issues/63502.", "tree": {"sha": "971766d824661216b8465284eb565e49621220da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/971766d824661216b8465284eb565e49621220da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdVHV3CRBK7hj4Ov3rIwAAdHIIAIni6xeJq3XbXxQJuJqtrd5k\nY1XRksCssZdYyGLYbp86XfTmrhpWqkGdEGOGKgrngGJFcxyE+mhriwV+NJt9MZSG\nCWnQO/u5cudYo/nSFA0yBRg9NTQLsp0lf4M8w5Yg5L0fjjH1/Q5MR0hHHj1UnO3o\n6+sdMxur9/jCYOY9bBDVj/Ad1UZwzJrh1PSjTwq9MJtZKh6PMsU2B1rcCE1NdXRh\nW9tLPwbpPs6UF70y7zDL7bsxT+ruFxAiiRSOTfeyHTvPJriKc1uk05DxVCvWgP8q\nRaBxDo23mYv4q1i4ixsnWgiMp3NA3Du6omHCwZ+VLzl/T2vZVEebTm4j8UXjziY=\n=682W\n-----END PGP SIGNATURE-----\n", "payload": "tree 971766d824661216b8465284eb565e49621220da\nparent aaeff01446fed6fb3bd15d638022a85174350772\nparent 6c3a98e029048ff316d6c8ae2f69b3db08cae90e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565816182 +0200\ncommitter GitHub <noreply@github.com> 1565816182 +0200\n\nRollup merge of #63507 - estebank:type-inference-error, r=Centril\n\nWhen needing type annotations in local bindings, account for impl Trait and closures\n\nFix https://github.com/rust-lang/rust/issues/46680, fix https://github.com/rust-lang/rust/issues/63504, fix https://github.com/rust-lang/rust/issues/63506, fix #40014, cc https://github.com/rust-lang/rust/issues/63502.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "html_url": "https://github.com/rust-lang/rust/commit/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaeff01446fed6fb3bd15d638022a85174350772", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaeff01446fed6fb3bd15d638022a85174350772", "html_url": "https://github.com/rust-lang/rust/commit/aaeff01446fed6fb3bd15d638022a85174350772"}, {"sha": "6c3a98e029048ff316d6c8ae2f69b3db08cae90e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3a98e029048ff316d6c8ae2f69b3db08cae90e", "html_url": "https://github.com/rust-lang/rust/commit/6c3a98e029048ff316d6c8ae2f69b3db08cae90e"}], "stats": {"total": 479, "additions": 405, "deletions": 74}, "files": [{"sha": "571ee393782f93a83a0065653839988b69ef2475", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -649,12 +649,34 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn is_const_scope(&self, hir_id: HirId) -> bool {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(Item { node: ItemKind::Const(_, _), .. }) => true,\n-            Node::Item(Item { node: ItemKind::Fn(_, header, _, _), .. }) => header.is_const(),\n+    /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n+    /// Used exclusively for diagnostics, to avoid suggestion function calls.\n+    pub fn is_const_context(&self, hir_id: HirId) -> bool {\n+        let parent_id = self.get_parent_item(hir_id);\n+        match self.get(parent_id) {\n+            Node::Item(&Item {\n+                node: ItemKind::Const(..),\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                node: TraitItemKind::Const(..),\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                node: ImplItemKind::Const(..),\n+                ..\n+            })\n+            | Node::AnonConst(_)\n+            | Node::Item(&Item {\n+                node: ItemKind::Static(..),\n+                ..\n+            }) => true,\n+            Node::Item(&Item {\n+                node: ItemKind::Fn(_, header, ..),\n+                ..\n+            }) => header.constness == Constness::Const,\n             _ => false,\n-        }, |_| false).map(|id| id != CRATE_HIR_ID).unwrap_or(false)\n+        }\n     }\n \n     /// If there is some error when walking the parents (e.g., a node does not"}, {"sha": "e8d44ee1310e73b92e2adfa003c178393a42736e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -1541,7 +1541,7 @@ pub enum ExprKind {\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`.\n+    /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<GeneratorMovability>`."}, {"sha": "3267505708b8100dfcee4e45cf7fc2423828e423", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 161, "deletions": 51, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -1,13 +1,13 @@\n use crate::hir::def::Namespace;\n-use crate::hir::{self, Local, Pat, Body, HirId};\n+use crate::hir::{self, Body, FunctionRetTy, Expr, ExprKind, HirId, Local, Pat};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n \n struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -16,9 +16,26 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_local_pattern: Option<&'tcx Pat>,\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n+    found_closure: Option<&'tcx ExprKind>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        target_ty: Ty<'tcx>,\n+        hir_map: &'a hir::map::Map<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            target_ty,\n+            hir_map,\n+            found_local_pattern: None,\n+            found_arg_pattern: None,\n+            found_ty: None,\n+            found_closure: None,\n+        }\n+    }\n+\n     fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_type_opt(hir_id)\n@@ -72,6 +89,60 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_body(self, body);\n     }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n+            &expr.node,\n+            self.node_matches_type(expr.hir_id),\n+        ) {\n+            self.found_closure = Some(&expr.node);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// Suggest giving an appropriate return type to a closure expression.\n+fn closure_return_type_suggestion(\n+    span: Span,\n+    err: &mut DiagnosticBuilder<'_>,\n+    output: &FunctionRetTy,\n+    body: &Body,\n+    name: &str,\n+    ret: &str,\n+) {\n+    let (arrow, post) = match output {\n+        FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+        _ => (\"\", \"\"),\n+    };\n+    let suggestion = match body.value.node {\n+        ExprKind::Block(..) => {\n+            vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n+        }\n+        _ => {\n+            vec![\n+                (output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n+                (body.value.span.shrink_to_hi(), \" }\".to_string()),\n+            ]\n+        }\n+    };\n+    err.multipart_suggestion(\n+        \"give this closure an explicit return type without `_` placeholders\",\n+        suggestion,\n+        Applicability::HasPlaceholders,\n+    );\n+    err.span_label(span, InferCtxt::missing_type_msg(&name));\n+}\n+\n+/// Given a closure signature, return a `String` containing a list of all its argument types.\n+fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n+    fn_sig.inputs()\n+        .skip_binder()\n+        .iter()\n+        .next()\n+        .map(|args| args.tuple_fields()\n+            .map(|arg| arg.to_string())\n+            .collect::<Vec<_>>().join(\", \"))\n+        .unwrap_or_default()\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -106,16 +177,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n-        let mut err_span = span;\n-\n-        let mut local_visitor = FindLocalByTypeVisitor {\n-            infcx: &self,\n-            target_ty: ty,\n-            hir_map: &self.tcx.hir(),\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-            found_ty: None,\n-        };\n+        let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -136,6 +198,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n+        let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n+            pattern.span\n+        } else {\n+            span\n+        };\n+\n+        let is_named_and_not_impl_trait = |ty: Ty<'_>| {\n+            &ty.to_string() != \"_\" &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n+        };\n+\n+        let ty_msg = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let args = closure_args(&fn_sig);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+                format!(\" for the closure `fn({}) -> {}`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) => {\n+                let ty = ty_to_string(ty);\n+                format!(\" for `{}`\", ty)\n+            }\n+            _ => String::new(),\n+        };\n \n         // When `name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n@@ -150,27 +237,58 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n         //   |         the type parameter `E` is specified\n         // ```\n-        let (ty_msg, suffix) = match &local_visitor.found_ty {\n-            Some(ty) if &ty.to_string() != \"_\" && name == \"_\" => {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            err_span,\n+            E0282,\n+            \"type annotations needed{}\",\n+            ty_msg,\n+        );\n+\n+        let suffix = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+\n+                if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n+                    if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n+                        closure_return_type_suggestion(\n+                            span,\n+                            &mut err,\n+                            &decl.output,\n+                            &body,\n+                            &name,\n+                            &ret,\n+                        );\n+                        // We don't want to give the other suggestions when the problem is the\n+                        // closure return type.\n+                        return err;\n+                    }\n+                }\n+\n+                // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n+                let args = closure_args(&fn_sig);\n+                // This suggestion is incomplete, as the user will get further type inference\n+                // errors due to the `_` placeholders and the introduction of `Box`, but it does\n+                // nudge them in the right direction.\n+                format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\"the explicit type `{}`, with the type parameters specified\", ty))\n+                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if &ty.to_string() != \"_\" && ty.to_string() != name => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\n-                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n+                format!(\n+                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n                     ty,\n                     name,\n-                 ))\n+                )\n             }\n-            _ => (String::new(), \"a type\".to_owned()),\n+            _ => \"a type\".to_string(),\n         };\n-        let mut labels = vec![(span, InferCtxt::missing_type_msg(&name))];\n \n         if let Some(pattern) = local_visitor.found_arg_pattern {\n-            err_span = pattern.span;\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:\n@@ -187,39 +305,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             //          ^ consider giving this closure parameter the type `[_; 0]`\n             //            with the type parameter `_` specified\n             // ```\n-            labels.clear();\n-            labels.push((\n+            err.span_label(\n                 pattern.span,\n                 format!(\"consider giving this closure parameter {}\", suffix),\n-            ));\n+            );\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            if let Some(simple_ident) = pattern.simple_ident() {\n+            let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n-                    None => labels.push((\n-                        pattern.span,\n-                        format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    )),\n-                    Some(DesugaringKind::ForLoop) => labels.push((\n-                        pattern.span,\n-                        \"the element type for this iterator is not specified\".to_owned(),\n-                    )),\n-                    _ => {}\n+                    None => {\n+                        format!(\"consider giving `{}` {}\", simple_ident, suffix)\n+                    }\n+                    Some(DesugaringKind::ForLoop) => {\n+                        \"the element type for this iterator is not specified\".to_string()\n+                    }\n+                    _ => format!(\"this needs {}\", suffix),\n                 }\n             } else {\n-                labels.push((pattern.span, format!(\"consider giving this pattern {}\", suffix)));\n-            }\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            err_span,\n-            E0282,\n-            \"type annotations needed{}\",\n-            ty_msg,\n-        );\n-\n-        for (target_span, label_message) in labels {\n-            err.span_label(target_span, label_message);\n+                format!(\"consider giving this pattern {}\", suffix)\n+            };\n+            err.span_label(pattern.span, msg);\n+        }\n+        if !err.span.span_labels().iter().any(|span_label| {\n+                span_label.label.is_some() && span_label.span == span\n+            }) && local_visitor.found_arg_pattern.is_none()\n+        { // Avoid multiple labels pointing at `span`.\n+            err.span_label(span, InferCtxt::missing_type_msg(&name));\n         }\n \n         err"}, {"sha": "02593d4d609fda723a05ec931f3d193615a4e4e3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -2068,6 +2068,9 @@ impl<'tcx> TyS<'tcx> {\n             Error => {  // ignore errors (#54954)\n                 ty::Binder::dummy(FnSig::fake())\n             }\n+            Closure(..) => bug!(\n+                \"to get the signature of a closure, use `closure_sig()` not `fn_sig()`\",\n+            ),\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }"}, {"sha": "ed25601208ad1caacf505f29764cf8d84b3396c0", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -127,6 +127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n+        self.suggest_boxing_when_appropriate(&mut err, expr, expected, expr_ty);\n         self.suggest_missing_await(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n@@ -548,7 +549,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_scope(expr.hir_id) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n             // Shouldn't suggest `.into()` on `const`s.\n             // FIXME(estebank): modify once we decide to suggest `as` casts\n             return false;"}, {"sha": "74d3a12765bf65bc217a8b132011442f0b533bb0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -3902,6 +3902,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err, &fn_decl, expected, found, can_suggest);\n         }\n         self.suggest_ref_or_into(err, expression, expected, found);\n+        self.suggest_boxing_when_appropriate(err, expression, expected, found);\n         pointing_at_return_type\n     }\n \n@@ -4062,6 +4063,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n+    /// in the heap by calling `Box::new()`.\n+    fn suggest_boxing_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return;\n+        }\n+        if !expected.is_box() || found.is_box() {\n+            return;\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(boxed_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            err.span_suggestion(\n+                expr.span,\n+                \"store this in the heap by calling `Box::new`\",\n+                format!(\"Box::new({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\"for more on the distinction between the stack and the \\\n+                        heap, read https://doc.rust-lang.org/book/ch15-01-box.html, \\\n+                        https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n+                        https://doc.rust-lang.org/std/boxed/index.html\");\n+        }\n+    }\n+\n+\n     /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n     ///\n     /// ```"}, {"sha": "0f610a5e42f65060ad380ad2161ce35d80825e49", "filename": "src/test/ui/error-codes/E0282.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/E0282.rs:2:9\n    |\n LL |     let x = \"hello\".chars().rev().collect();\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "0672014a9292928ada4105fb3ca9c24b4a04e5d9", "filename": "src/test/ui/for/for-loop-unconstrained-element-type.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/for-loop-unconstrained-element-type.rs:8:14\n    |\n LL |     for i in Vec::new() { }\n-   |              ^^^^^^^^^^\n-   |              |\n-   |              cannot infer type\n-   |              the element type for this iterator is not specified\n+   |              ^^^^^^^^^^ the element type for this iterator is not specified\n \n error: aborting due to previous error\n "}, {"sha": "30ed5050433a621438c6d499230d503964b85a11", "filename": "src/test/ui/inference/cannot-infer-async-enabled-impl-trait-bindings.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,18 @@\n+// edition:2018\n+#![feature(async_await)]\n+#![feature(impl_trait_in_bindings)]\n+//~^ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+\n+use std::io::Error;\n+\n+fn make_unit() -> Result<(), Error> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    let fut = async {\n+        make_unit()?; //~ ERROR type annotations needed\n+\n+        Ok(())\n+    };\n+}"}, {"sha": "67a834a2e957aef40c0023348723d5810272c8be", "filename": "src/test/ui/inference/cannot-infer-async-enabled-impl-trait-bindings.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/cannot-infer-async-enabled-impl-trait-bindings.rs:3:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0282]: type annotations needed for `impl std::future::Future`\n+  --> $DIR/cannot-infer-async-enabled-impl-trait-bindings.rs:14:9\n+   |\n+LL |     let fut = async {\n+   |         --- consider giving `fut` the explicit type `impl std::future::Future`, with the type parameters specified\n+LL |         make_unit()?;\n+   |         ^^^^^^^^^^^^ cannot infer type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "edc64276e7ce42fa8d2199f7c52fb50d6865019a", "filename": "src/test/ui/inference/cannot-infer-async.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+#![feature(async_await)]\n+\n+use std::io::Error;\n+\n+fn make_unit() -> Result<(), Error> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    let fut = async {\n+        make_unit()?; //~ ERROR type annotations needed\n+\n+        Ok(())\n+    };\n+}"}, {"sha": "36608a11bb73073ca768f697092770d6f7da8d99", "filename": "src/test/ui/inference/cannot-infer-async.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/cannot-infer-async.rs:12:9\n+   |\n+LL |     let fut = async {\n+   |         --- consider giving `fut` a type\n+LL |         make_unit()?;\n+   |         ^^^^^^^^^^^^ cannot infer type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "8f48483c254218a66f9fcd4afe6cce7e919faf8e", "filename": "src/test/ui/inference/cannot-infer-closure.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = |a: (), b: ()| {\n+        Err(a)?; //~ ERROR type annotations needed for the closure\n+        Ok(b)\n+    };\n+}"}, {"sha": "5f30b5d993c1ee84cbeee95fc3d55e3d845c913e", "filename": "src/test/ui/inference/cannot-infer-closure.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn((), ()) -> std::result::Result<(), _>`\n+  --> $DIR/cannot-infer-closure.rs:3:9\n+   |\n+LL |         Err(a)?;\n+   |         ^^^^^^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let x = |a: (), b: ()| -> std::result::Result<(), _> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "9b890be3c789b44d86c580d05725db5f0a2d6718", "filename": "src/test/ui/issues/issue-18159.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-18159.rs:2:9\n    |\n LL |     let x;\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "77df9921b754ac197d295029eac40558cc31e42b", "filename": "src/test/ui/match/match-unresolved-one-arm.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/match-unresolved-one-arm.rs:4:9\n    |\n LL |     let x = match () {\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "3de02cd0bd4814ab2b535a94e8dec18e6b916ac4", "filename": "src/test/ui/suggestions/suggest-box.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.fixed?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn main() {\n+    let _x: Box<dyn Fn() -> Result<(), ()>> = Box::new(|| { //~ ERROR mismatched types\n+        Err(())?;\n+        Ok(())\n+    });\n+}"}, {"sha": "e680a61db3b177cc912c35927b3075019fe58dd2", "filename": "src/test/ui/suggestions/suggest-box.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn main() {\n+    let _x: Box<dyn Fn() -> Result<(), ()>> = || { //~ ERROR mismatched types\n+        Err(())?;\n+        Ok(())\n+    };\n+}"}, {"sha": "50c106d63a02b54a72053102ce0c7a3a1123ddd0", "filename": "src/test/ui/suggestions/suggest-box.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,24 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-box.rs:4:47\n+   |\n+LL |       let _x: Box<dyn Fn() -> Result<(), ()>> = || {\n+   |  _______________________________________________^\n+LL | |         Err(())?;\n+LL | |         Ok(())\n+LL | |     };\n+   | |_____^ expected struct `std::boxed::Box`, found closure\n+   |\n+   = note: expected type `std::boxed::Box<dyn std::ops::Fn() -> std::result::Result<(), ()>>`\n+              found type `[closure@$DIR/suggest-box.rs:4:47: 7:6]`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+help: store this in the heap by calling `Box::new`\n+   |\n+LL |     let _x: Box<dyn Fn() -> Result<(), ()>> = Box::new(|| {\n+LL |         Err(())?;\n+LL |         Ok(())\n+LL |     });\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "910f273b9722d01474cc7f8ec6e3b8c3cae7242c", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || -> _ { [] }; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "de2d29f1270c6c26af800ac12299338c6c19afd0", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-1.rs:2:24\n+   |\n+LL |     let _v = || -> _ { [] };\n+   |                        ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                    ^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "6955b37ad97e423526043712f4de6b3488b9006a", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || { [] }; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "9dbd822fbb5defc4fd6553e8d8993d7462cf56b2", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-2.rs:2:19\n+   |\n+LL |     let _v = || { [] };\n+   |                   ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                 ^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "ec6c094027e1e48fdc32f8b2b733b730b187c27f", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || []; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "ad0d4e41f7874b66e43f6d0d6ffe3419bc2609c6", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr?ref=d2d49d238f66ad3e9aea12d2cdac8f4bc2af4ce9", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-3.rs:2:17\n+   |\n+LL |     let _v = || [];\n+   |                 ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                 ^^^^^^^^^^^    ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}