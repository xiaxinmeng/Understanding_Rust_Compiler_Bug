{"sha": "f88d6e8437fdf4284ca7a1548e2e5ecfe89585be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OGQ2ZTg0MzdmZGY0Mjg0Y2E3YTE1NDhlMmU1ZWNmZTg5NTg1YmU=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-23T16:11:52Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-23T23:24:58Z"}, "message": "Loop instead of recursion", "tree": {"sha": "170b1561558312d14e96aa993c6c4d0174b280dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/170b1561558312d14e96aa993c6c4d0174b280dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be", "html_url": "https://github.com/rust-lang/rust/commit/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9cd294cf2775441e713c7ee2918b728733b99f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd294cf2775441e713c7ee2918b728733b99f5", "html_url": "https://github.com/rust-lang/rust/commit/a9cd294cf2775441e713c7ee2918b728733b99f5"}], "stats": {"total": 150, "additions": 79, "deletions": 71}, "files": [{"sha": "a1cbcde1f4291ca9acc5195668054a90853448af", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 79, "deletions": 71, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=f88d6e8437fdf4284ca7a1548e2e5ecfe89585be", "patch": "@@ -10,82 +10,90 @@ use rustc_span::symbol::Ident;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+    crate fn lower_pat(&mut self, mut pattern: &Pat) -> &'hir hir::Pat<'hir> {\n         ensure_sufficient_stack(|| {\n-            let node = match p.kind {\n-                PatKind::Wild => hir::PatKind::Wild,\n-                PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                    let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                    let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                    node\n-                }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref path, ref pats) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                    hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-                }\n-                PatKind::Or(ref pats) => hir::PatKind::Or(\n-                    self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n-                ),\n-                PatKind::Path(ref qself, ref path) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        qself,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    hir::PatKind::Path(qpath)\n-                }\n-                PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n+            // loop here to avoid recursion\n+            let node = loop {\n+                match pattern.kind {\n+                    PatKind::Wild => break hir::PatKind::Wild,\n+                    PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                        break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n+                    }\n+                    PatKind::Lit(ref e) => break hir::PatKind::Lit(self.lower_expr(e)),\n+                    PatKind::TupleStruct(ref path, ref pats) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                        break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n+                    }\n+                    PatKind::Or(ref pats) => {\n+                        break hir::PatKind::Or(\n+                            self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n+                        );\n+                    }\n+                    PatKind::Path(ref qself, ref path) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            qself,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        break hir::PatKind::Path(qpath);\n+                    }\n+                    PatKind::Struct(ref path, ref fields, etc) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n \n-                    let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                        hir_id: self.next_id(),\n-                        ident: f.ident,\n-                        pat: self.lower_pat(&f.pat),\n-                        is_shorthand: f.is_shorthand,\n-                        span: f.span,\n-                    }));\n-                    hir::PatKind::Struct(qpath, fs, etc)\n-                }\n-                PatKind::Tuple(ref pats) => {\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                    hir::PatKind::Tuple(pats, ddpos)\n-                }\n-                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-                PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-                PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n-                    hir::PatKind::Range(\n-                        e1.as_deref().map(|e| self.lower_expr(e)),\n-                        e2.as_deref().map(|e| self.lower_expr(e)),\n-                        self.lower_range_end(end, e2.is_some()),\n-                    )\n-                }\n-                PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-                PatKind::Rest => {\n-                    // If we reach here the `..` pattern is not semantically allowed.\n-                    self.ban_illegal_rest_pat(p.span)\n+                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                            hir_id: self.next_id(),\n+                            ident: f.ident,\n+                            pat: self.lower_pat(&f.pat),\n+                            is_shorthand: f.is_shorthand,\n+                            span: f.span,\n+                        }));\n+                        break hir::PatKind::Struct(qpath, fs, etc);\n+                    }\n+                    PatKind::Tuple(ref pats) => {\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                        break hir::PatKind::Tuple(pats, ddpos);\n+                    }\n+                    PatKind::Box(ref inner) => {\n+                        break hir::PatKind::Box(self.lower_pat(inner));\n+                    }\n+                    PatKind::Ref(ref inner, mutbl) => {\n+                        break hir::PatKind::Ref(self.lower_pat(inner), mutbl);\n+                    }\n+                    PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                        break hir::PatKind::Range(\n+                            e1.as_deref().map(|e| self.lower_expr(e)),\n+                            e2.as_deref().map(|e| self.lower_expr(e)),\n+                            self.lower_range_end(end, e2.is_some()),\n+                        );\n+                    }\n+                    PatKind::Slice(ref pats) => break self.lower_pat_slice(pats),\n+                    PatKind::Rest => {\n+                        // If we reach here the `..` pattern is not semantically allowed.\n+                        break self.ban_illegal_rest_pat(pattern.span);\n+                    }\n+                    // return inner to be processed in next loop\n+                    PatKind::Paren(ref inner) => pattern = inner,\n+                    PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", pattern.span),\n                 }\n-                // FIXME: consider not using recursion to lower this.\n-                PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-                PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", p.span),\n             };\n \n-            self.pat_with_node_id_of(p, node)\n+            self.pat_with_node_id_of(pattern, node)\n         })\n     }\n "}]}