{"sha": "67565ae4ae0bfe686ecbbb7808c601a87bde5efe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NTY1YWU0YWUwYmZlNjg2ZWNiYmI3ODA4YzYwMWE4N2JkZTVlZmU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-19T02:53:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-19T02:53:11Z"}, "message": "Rollup merge of #64566 - ecstatic-morse:generic-dataflow, r=oli-obk\n\nA more generic interface for dataflow analysis\n\n#64470 requires a transfer function that is slightly more complex than the typical `gen`/`kill` one. Namely, it must copy state bits between locals when assignments occur (see #62547 for an attempt to make this fit into the existing framework). This PR contains a dataflow interface that allows for arbitrary transfer functions. The trade-off is efficiency: we can no longer coalesce transfer functions for blocks and must visit each statement individually while iterating to fixpoint.\n\nAnother issue is that poorly behaved transfer functions can result in an analysis that fails to converge. `gen`/`kill` sets do not have this problem. I believe that, in order to guarantee convergence, flipping a bit from `false` to `true` in the entry set cannot cause an output bit to go from `true` to `false` (negate all preceding booleans when `true` is the bottom value). Perhaps someone with a more formal background can confirm and we can add a section to the docs?\n\nThis approach is not maximally generic: it still requires that the lattice used for analysis is the powerset of values of `Analysis::Idx` for the `mir::Body` of interest. This can be done at a later date. Also, this is the bare minimum to get #64470 working. I've not adapted the existing debug framework to work with the new analysis, so there are no `rustc_peek` tests either. I'm planning to do this after #64470 is merged.\n\nFinally, my ultimate plan is to make the existing, `gen`/`kill`-based `BitDenotation` a special case of `generic::Analysis`. Currently they share a ton of code. I should be able to do this without changing any implementers of `BitDenotation`. Something like:\n\n```rust\nstruct GenKillAnalysis<A: BitDenotation> {\n    trans_for_block: IndexVec<BasicBlock, GenKillSet<A::Idx>>,\n    analysis: A,\n}\n\nimpl<A> generic::Analysis for GenKillAnalysis<A> {\n    // specializations of `apply_{partial,whole}_block_effect`...\n}\n```\n\nr? @pnkfelix", "tree": {"sha": "95fdb9c908e0978cf21f1e26f84e8478e151b78c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95fdb9c908e0978cf21f1e26f84e8478e151b78c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67565ae4ae0bfe686ecbbb7808c601a87bde5efe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdgu2XCRBK7hj4Ov3rIwAAdHIIAE8C8ogVV8dgz1z0HCXGivgX\nihld9YQC4Kk1QDbcBJ9GaU6uSqPpsxgqBO/4oUbF2vpQMaU+D3XveHd29QcRCi1y\ntUlJyZ7kZc2W5UwDQXdYT+pyS6krhDRUioHJjXPYxi6e7CGvkrHvWNvIngbmujS4\nSGMOxC4LdY5aOsyUmcjxTPfQHy14rR9HYXniyuvBTCDfL1Vl+fSP2y8Mh9vXeDYn\nw5ixfRYciDTyNK1dPbeanhpjDX7+ZEj67Eyhc7xeK+YNnh4DdAbBIPxPk9FT1IJ0\nXz7iamKJbE+cfK/1Aoemh7+tpWAD1UKL8W6fyg5EO24/+x++W9wPyf08jtKGLSA=\n=aJbU\n-----END PGP SIGNATURE-----\n", "payload": "tree 95fdb9c908e0978cf21f1e26f84e8478e151b78c\nparent 08351004125c4d49aa757f2c3ec2340f7469ea91\nparent b4e94d9a3a04798201676be8f18ee483eb292104\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568861591 +0200\ncommitter GitHub <noreply@github.com> 1568861591 +0200\n\nRollup merge of #64566 - ecstatic-morse:generic-dataflow, r=oli-obk\n\nA more generic interface for dataflow analysis\n\n#64470 requires a transfer function that is slightly more complex than the typical `gen`/`kill` one. Namely, it must copy state bits between locals when assignments occur (see #62547 for an attempt to make this fit into the existing framework). This PR contains a dataflow interface that allows for arbitrary transfer functions. The trade-off is efficiency: we can no longer coalesce transfer functions for blocks and must visit each statement individually while iterating to fixpoint.\n\nAnother issue is that poorly behaved transfer functions can result in an analysis that fails to converge. `gen`/`kill` sets do not have this problem. I believe that, in order to guarantee convergence, flipping a bit from `false` to `true` in the entry set cannot cause an output bit to go from `true` to `false` (negate all preceding booleans when `true` is the bottom value). Perhaps someone with a more formal background can confirm and we can add a section to the docs?\n\nThis approach is not maximally generic: it still requires that the lattice used for analysis is the powerset of values of `Analysis::Idx` for the `mir::Body` of interest. This can be done at a later date. Also, this is the bare minimum to get #64470 working. I've not adapted the existing debug framework to work with the new analysis, so there are no `rustc_peek` tests either. I'm planning to do this after #64470 is merged.\n\nFinally, my ultimate plan is to make the existing, `gen`/`kill`-based `BitDenotation` a special case of `generic::Analysis`. Currently they share a ton of code. I should be able to do this without changing any implementers of `BitDenotation`. Something like:\n\n```rust\nstruct GenKillAnalysis<A: BitDenotation> {\n    trans_for_block: IndexVec<BasicBlock, GenKillSet<A::Idx>>,\n    analysis: A,\n}\n\nimpl<A> generic::Analysis for GenKillAnalysis<A> {\n    // specializations of `apply_{partial,whole}_block_effect`...\n}\n```\n\nr? @pnkfelix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67565ae4ae0bfe686ecbbb7808c601a87bde5efe", "html_url": "https://github.com/rust-lang/rust/commit/67565ae4ae0bfe686ecbbb7808c601a87bde5efe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67565ae4ae0bfe686ecbbb7808c601a87bde5efe/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08351004125c4d49aa757f2c3ec2340f7469ea91", "url": "https://api.github.com/repos/rust-lang/rust/commits/08351004125c4d49aa757f2c3ec2340f7469ea91", "html_url": "https://github.com/rust-lang/rust/commit/08351004125c4d49aa757f2c3ec2340f7469ea91"}, {"sha": "b4e94d9a3a04798201676be8f18ee483eb292104", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e94d9a3a04798201676be8f18ee483eb292104", "html_url": "https://github.com/rust-lang/rust/commit/b4e94d9a3a04798201676be8f18ee483eb292104"}], "stats": {"total": 514, "additions": 514, "deletions": 0}, "files": [{"sha": "886044c0692829e2c283e2e3cb10586c16ef1ef0", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/67565ae4ae0bfe686ecbbb7808c601a87bde5efe/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67565ae4ae0bfe686ecbbb7808c601a87bde5efe/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=67565ae4ae0bfe686ecbbb7808c601a87bde5efe", "patch": "@@ -0,0 +1,512 @@\n+//! Dataflow analysis with arbitrary transfer functions.\n+//!\n+//! This module is a work in progress. You should instead use `BitDenotation` in\n+//! `librustc_mir/dataflow/mod.rs` and encode your transfer function as a [gen/kill set][gk]. In\n+//! doing so, your analysis will run faster and you will be able to generate graphviz diagrams for\n+//! debugging with no extra effort. The interface in this module is intended only for dataflow\n+//! problems that cannot be expressed using gen/kill sets.\n+//!\n+//! FIXME(ecstaticmorse): In the long term, the plan is to preserve the existing `BitDenotation`\n+//! interface, but make `Engine` and `ResultsCursor` the canonical way to perform and inspect a\n+//! dataflow analysis. This requires porting the graphviz debugging logic to this module, deciding\n+//! on a way to handle the `before` methods in `BitDenotation` and creating an adapter so that\n+//! gen-kill problems can still be evaluated efficiently. See the discussion in [#64566][] for more\n+//! information.\n+//!\n+//! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n+//! [#64566]: https://github.com/rust-lang/rust/pull/64566\n+\n+use std::cmp::Ordering;\n+use std::ops;\n+\n+use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::work_queue::WorkQueue;\n+\n+use crate::dataflow::BottomValue;\n+\n+/// A specific kind of dataflow analysis.\n+///\n+/// To run a dataflow analysis, one must set the initial state of the `START_BLOCK` via\n+/// `initialize_start_block` and define a transfer function for each statement or terminator via\n+/// the various `effect` methods. The entry set for all other basic blocks is initialized to\n+/// `Self::BOTTOM_VALUE`. The dataflow `Engine` then iteratively updates the various entry sets for\n+/// each block with the cumulative effects of the transfer functions of all preceding blocks.\n+///\n+/// You should use an `Engine` to actually run an analysis, and a `ResultsCursor` to inspect the\n+/// results of that analysis like so:\n+///\n+/// ```ignore(cross-crate-imports)\n+/// fn do_my_analysis(body: &mir::Body<'tcx>, dead_unwinds: &BitSet<BasicBlock>) {\n+///     // `MyAnalysis` implements `Analysis`.\n+///     let analysis = MyAnalysis::new();\n+///\n+///     let results = Engine::new(body, dead_unwinds, analysis).iterate_to_fixpoint();\n+///     let mut cursor = ResultsCursor::new(body, results);\n+///\n+///     for (_, statement_index) in body.block_data[START_BLOCK].statements.iter_enumerated() {\n+///         cursor.seek_after(Location { block: START_BLOCK, statement_index });\n+///         let state = cursor.get();\n+///         println!(\"{:?}\", state);\n+///     }\n+/// }\n+/// ```\n+pub trait Analysis<'tcx>: BottomValue {\n+    /// The index type used to access the dataflow state.\n+    type Idx: Idx;\n+\n+    /// A name, used for debugging, that describes this dataflow analysis.\n+    ///\n+    /// The name should be suitable as part of a filename, so avoid whitespace, slashes or periods\n+    /// and try to keep it short.\n+    const NAME: &'static str;\n+\n+    /// The size of each bitvector allocated for each block.\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n+\n+    /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n+    /// analysis.\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n+\n+    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    ///\n+    /// Note that the effect of a successful return from a `Call` terminator should **not** be\n+    /// acounted for in this function. That should go in `apply_call_return_effect`. For example,\n+    /// in the `InitializedPlaces` analyses, the return place is not marked as initialized here.\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with the effect of a successful return from a `Call`\n+    /// terminator.\n+    ///\n+    /// This is separated from `apply_terminator_effect` to properly track state across\n+    /// unwind edges for `Call`s.\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    );\n+\n+    /// Applies the cumulative effect of an entire basic block to the dataflow state (except for\n+    /// `call_return_effect`, which is handled in the `Engine`).\n+    ///\n+    /// The default implementation calls `statement_effect` for every statement in the block before\n+    /// finally calling `terminator_effect`. However, some dataflow analyses are able to coalesce\n+    /// transfer functions for an entire block and apply them at once. Such analyses should\n+    /// override `block_effect`.\n+    fn apply_whole_block_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) {\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            self.apply_statement_effect(state, stmt, location);\n+        }\n+\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        self.apply_terminator_effect(state, block_data.terminator(), location);\n+    }\n+\n+    /// Applies the cumulative effect of a sequence of statements (and possibly a terminator)\n+    /// within a single basic block.\n+    ///\n+    /// When called with `0..block_data.statements.len() + 1` as the statement range, this function\n+    /// is equivalent to `apply_whole_block_effect`.\n+    fn apply_partial_block_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        mut range: ops::Range<usize>,\n+    ) {\n+        if range.is_empty() {\n+            return;\n+        }\n+\n+        // The final location might be a terminator, so iterate through all statements until the\n+        // final one, then check to see whether the final one is a statement or terminator.\n+        //\n+        // This can't cause the range to wrap-around since we check that the range contains at\n+        // least one element above.\n+        range.end -= 1;\n+        let final_location = Location { block, statement_index: range.end };\n+\n+        for statement_index in range {\n+            let location = Location { block, statement_index };\n+            let stmt = &block_data.statements[statement_index];\n+            self.apply_statement_effect(state, stmt, location);\n+        }\n+\n+        if final_location.statement_index == block_data.statements.len() {\n+            let terminator = block_data.terminator();\n+            self.apply_terminator_effect(state, terminator, final_location);\n+        } else {\n+            let stmt = &block_data.statements[final_location.statement_index];\n+            self.apply_statement_effect(state, stmt, final_location);\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum CursorPosition {\n+    AtBlockStart(BasicBlock),\n+    After(Location),\n+}\n+\n+impl CursorPosition {\n+    fn block(&self) -> BasicBlock {\n+        match *self {\n+            Self::AtBlockStart(block) => block,\n+            Self::After(Location { block, .. }) => block,\n+        }\n+    }\n+}\n+\n+/// Inspect the results of dataflow analysis.\n+///\n+/// This cursor has linear performance when visiting statements in a block in order. Visiting\n+/// statements within a block in reverse order is `O(n^2)`, where `n` is the number of statements\n+/// in that block.\n+pub struct ResultsCursor<'mir, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'mir mir::Body<'tcx>,\n+    results: Results<'tcx, A>,\n+    state: BitSet<A::Idx>,\n+\n+    pos: CursorPosition,\n+\n+    /// Whether the effects of `apply_call_return_effect` are currently stored in `state`.\n+    ///\n+    /// This flag ensures that multiple calls to `seek_after_assume_call_returns` with the same\n+    /// target only result in one invocation of `apply_call_return_effect`.\n+    is_call_return_effect_applied: bool,\n+}\n+\n+impl<'mir, 'tcx, A> ResultsCursor<'mir, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n+    pub fn new(body: &'mir mir::Body<'tcx>, results: Results<'tcx, A>) -> Self {\n+        ResultsCursor {\n+            body,\n+            pos: CursorPosition::AtBlockStart(mir::START_BLOCK),\n+            is_call_return_effect_applied: false,\n+            state: results.entry_sets[mir::START_BLOCK].clone(),\n+            results,\n+        }\n+    }\n+\n+    /// Resets the cursor to the start of the given `block`.\n+    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n+        self.state.overwrite(&self.results.entry_sets[block]);\n+        self.pos = CursorPosition::AtBlockStart(block);\n+        self.is_call_return_effect_applied = false;\n+    }\n+\n+    /// Updates the cursor to hold the dataflow state immediately before `target`.\n+    pub fn seek_before(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        if target.statement_index == 0 {\n+            self.seek_to_block_start(target.block);\n+        } else {\n+            self._seek_after(Location {\n+                block: target.block,\n+                statement_index: target.statement_index - 1,\n+            });\n+        }\n+    }\n+\n+    /// Updates the cursor to hold the dataflow state at `target`.\n+    ///\n+    /// If `target` is a `Call` terminator, `apply_call_return_effect` will not be called. See\n+    /// `seek_after_assume_call_returns` if you wish to observe the dataflow state upon a\n+    /// successful return.\n+    pub fn seek_after(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        // This check ensures the correctness of a call to `seek_after_assume_call_returns`\n+        // followed by one to `seek_after` with the same target.\n+        if self.is_call_return_effect_applied {\n+            self.seek_to_block_start(target.block);\n+        }\n+\n+        self._seek_after(target);\n+    }\n+\n+    /// Equivalent to `seek_after`, but also calls `apply_call_return_effect` if `target` is a\n+    /// `Call` terminator whose callee is convergent.\n+    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        self._seek_after(target);\n+\n+        if target != self.body.terminator_loc(target.block) {\n+            return;\n+        }\n+\n+        let term = self.body.basic_blocks()[target.block].terminator();\n+        if let mir::TerminatorKind::Call {\n+            destination: Some((return_place, _)),\n+            func,\n+            args,\n+            ..\n+        } = &term.kind {\n+            if !self.is_call_return_effect_applied {\n+                self.is_call_return_effect_applied = true;\n+                self.results.analysis.apply_call_return_effect(\n+                    &mut self.state,\n+                    target.block,\n+                    func,\n+                    args,\n+                    return_place,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn _seek_after(&mut self, target: Location) {\n+        let Location { block: target_block, statement_index: target_index } = target;\n+\n+        if self.pos.block() != target_block {\n+            self.seek_to_block_start(target_block);\n+        }\n+\n+        // If we're in the same block but after the target statement, we need to reset to the start\n+        // of the block.\n+        if let CursorPosition::After(Location { statement_index: curr_index, .. }) = self.pos {\n+            match curr_index.cmp(&target_index) {\n+                Ordering::Equal => return,\n+                Ordering::Less => {},\n+                Ordering::Greater => self.seek_to_block_start(target_block),\n+            }\n+        }\n+\n+        // The cursor is now in the same block as the target location pointing at an earlier\n+        // statement.\n+        debug_assert_eq!(self.pos.block(), target_block);\n+        if let CursorPosition::After(Location { statement_index, .. }) = self.pos {\n+            debug_assert!(statement_index < target_index);\n+        }\n+\n+        let first_unapplied_statement = match self.pos {\n+            CursorPosition::AtBlockStart(_) => 0,\n+            CursorPosition::After(Location { statement_index, .. }) => statement_index + 1,\n+        };\n+\n+        let block_data = &self.body.basic_blocks()[target_block];\n+        self.results.analysis.apply_partial_block_effect(\n+            &mut self.state,\n+            target_block,\n+            block_data,\n+            first_unapplied_statement..target_index + 1,\n+        );\n+\n+        self.pos = CursorPosition::After(target);\n+        self.is_call_return_effect_applied = false;\n+    }\n+\n+    /// Gets the dataflow state at the current location.\n+    pub fn get(&self) -> &BitSet<A::Idx> {\n+        &self.state\n+    }\n+}\n+\n+/// A completed dataflow analysis.\n+pub struct Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    analysis: A,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+/// All information required to iterate a dataflow analysis to fixpoint.\n+pub struct Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    analysis: A,\n+    bits_per_block: usize,\n+    body: &'a mir::Body<'tcx>,\n+    dead_unwinds: &'a BitSet<BasicBlock>,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+impl<A> Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(\n+        body: &'a mir::Body<'tcx>,\n+        dead_unwinds: &'a BitSet<BasicBlock>,\n+        analysis: A,\n+    ) -> Self {\n+        let bits_per_block = analysis.bits_per_block(body);\n+\n+        let bottom_value_set = if A::BOTTOM_VALUE == true {\n+            BitSet::new_filled(bits_per_block)\n+        } else {\n+            BitSet::new_empty(bits_per_block)\n+        };\n+\n+        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n+        analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n+\n+        Engine {\n+            analysis,\n+            bits_per_block,\n+            body,\n+            dead_unwinds,\n+            entry_sets,\n+        }\n+    }\n+\n+    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n+        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n+\n+        let mut dirty_queue: WorkQueue<BasicBlock> =\n+            WorkQueue::with_none(self.body.basic_blocks().len());\n+\n+        for (bb, _) in traversal::reverse_postorder(self.body) {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n+        // be processed after the ones added above.\n+        for bb in self.body.basic_blocks().indices() {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        while let Some(bb) = dirty_queue.pop() {\n+            let bb_data = &self.body[bb];\n+            let on_entry = &self.entry_sets[bb];\n+\n+            temp_state.overwrite(on_entry);\n+            self.analysis.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n+\n+            self.propagate_bits_into_graph_successors_of(\n+                &mut temp_state,\n+                (bb, bb_data),\n+                &mut dirty_queue,\n+            );\n+        }\n+\n+        Results {\n+            analysis: self.analysis,\n+            entry_sets: self.entry_sets,\n+        }\n+    }\n+\n+    fn propagate_bits_into_graph_successors_of(\n+        &mut self,\n+        in_out: &mut BitSet<A::Idx>,\n+        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n+        dirty_list: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        match bb_data.terminator().kind {\n+            mir::TerminatorKind::Return\n+            | mir::TerminatorKind::Resume\n+            | mir::TerminatorKind::Abort\n+            | mir::TerminatorKind::GeneratorDrop\n+            | mir::TerminatorKind::Unreachable => {}\n+\n+            mir::TerminatorKind::Goto { target }\n+            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n+            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n+            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n+            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n+            {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n+            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n+            | mir::TerminatorKind::DropAndReplace {\n+                target,\n+                value: _,\n+                location: _,\n+                unwind: Some(unwind),\n+            } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                if !self.dead_unwinds.contains(bb) {\n+                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::Call { cleanup, ref destination, ref func, ref args, .. } => {\n+                if let Some(unwind) = cleanup {\n+                    if !self.dead_unwinds.contains(bb) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+\n+                if let Some((ref dest_place, dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, after all other\n+                    // propagation, as documented in comment above.\n+                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n+                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                if let Some(unwind) = unwind {\n+                    if !self.dead_unwinds.contains(bb) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(\n+        &mut self,\n+        in_out: &BitSet<A::Idx>,\n+        bb: BasicBlock,\n+        dirty_queue: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        let entry_set = &mut self.entry_sets[bb];\n+        let set_changed = self.analysis.join(entry_set, &in_out);\n+        if set_changed {\n+            dirty_queue.insert(bb);\n+        }\n+    }\n+}"}, {"sha": "5ab4e25b683cb2f077fd7a7b5f65bc145d52fb26", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67565ae4ae0bfe686ecbbb7808c601a87bde5efe/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67565ae4ae0bfe686ecbbb7808c601a87bde5efe/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=67565ae4ae0bfe686ecbbb7808c601a87bde5efe", "patch": "@@ -30,6 +30,7 @@ use self::move_paths::MoveData;\n \n mod at_location;\n pub mod drop_flag_effects;\n+pub mod generic;\n mod graphviz;\n mod impls;\n pub mod move_paths;"}, {"sha": "9a03719ab61f5013bfdc053a701046d557d07f2d", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67565ae4ae0bfe686ecbbb7808c601a87bde5efe/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67565ae4ae0bfe686ecbbb7808c601a87bde5efe/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=67565ae4ae0bfe686ecbbb7808c601a87bde5efe", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(try_blocks)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]\n+#![feature(range_is_empty)]\n \n #![recursion_limit=\"256\"]\n "}]}