{"sha": "b43bede93826f459e210957c8fd12fc1dd77d678", "node_id": "C_kwDOAAsO6NoAKGI0M2JlZGU5MzgyNmY0NTllMjEwOTU3YzhmZDEyZmMxZGQ3N2Q2Nzg", "commit": {"author": {"name": "Christian Legnitto", "email": "christian@legnitto.com", "date": "2022-06-30T17:10:31Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-02T21:27:11Z"}, "message": "Add shim for `realpath` on unix", "tree": {"sha": "4733e49ca5afaac748f49c10d9153d08e9d227ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4733e49ca5afaac748f49c10d9153d08e9d227ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b43bede93826f459e210957c8fd12fc1dd77d678", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b43bede93826f459e210957c8fd12fc1dd77d678", "html_url": "https://github.com/rust-lang/rust/commit/b43bede93826f459e210957c8fd12fc1dd77d678", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b43bede93826f459e210957c8fd12fc1dd77d678/comments", "author": {"login": "LegNeato", "id": 368904, "node_id": "MDQ6VXNlcjM2ODkwNA==", "avatar_url": "https://avatars.githubusercontent.com/u/368904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LegNeato", "html_url": "https://github.com/LegNeato", "followers_url": "https://api.github.com/users/LegNeato/followers", "following_url": "https://api.github.com/users/LegNeato/following{/other_user}", "gists_url": "https://api.github.com/users/LegNeato/gists{/gist_id}", "starred_url": "https://api.github.com/users/LegNeato/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LegNeato/subscriptions", "organizations_url": "https://api.github.com/users/LegNeato/orgs", "repos_url": "https://api.github.com/users/LegNeato/repos", "events_url": "https://api.github.com/users/LegNeato/events{/privacy}", "received_events_url": "https://api.github.com/users/LegNeato/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7865255b86b4e880de529aa3db57596499283a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/7865255b86b4e880de529aa3db57596499283a18", "html_url": "https://github.com/rust-lang/rust/commit/7865255b86b4e880de529aa3db57596499283a18"}], "stats": {"total": 226, "additions": 224, "deletions": 2}, "files": [{"sha": "766a3cba734b495578b8a91dfa271c9aa638d63b", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=b43bede93826f459e210957c8fd12fc1dd77d678", "patch": "@@ -37,6 +37,7 @@ const UNIX_IO_ERROR_TABLE: &[(std::io::ErrorKind, &str)] = {\n         (NotFound, \"ENOENT\"),\n         (Interrupted, \"EINTR\"),\n         (InvalidInput, \"EINVAL\"),\n+        (InvalidFilename, \"ENAMETOOLONG\"),\n         (TimedOut, \"ETIMEDOUT\"),\n         (AlreadyExists, \"EEXIST\"),\n         (WouldBlock, \"EWOULDBLOCK\"),"}, {"sha": "5eb2d0a6cac2e57581e153ac70d6fff5f0ff02d7", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=b43bede93826f459e210957c8fd12fc1dd77d678", "patch": "@@ -161,6 +161,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // fadvise is only informational, we can ignore it.\n                 this.write_null(dest)?;\n             }\n+            \"realpath\" => {\n+                let [path, resolved_path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.realpath(path, resolved_path)?;\n+                this.write_pointer(result, dest)?;\n+            }\n \n             // Time related shims\n             \"gettimeofday\" => {"}, {"sha": "76c170987912cdb23e1527a73ca3acfe2e07ffa2", "filename": "src/shims/unix/fs.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffs.rs?ref=b43bede93826f459e210957c8fd12fc1dd77d678", "patch": "@@ -1,5 +1,6 @@\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n+use std::convert::TryInto;\n use std::fs::{\n     read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir,\n };\n@@ -1662,6 +1663,67 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.set_last_error(enotty)?;\n         Ok(0)\n     }\n+\n+    fn realpath(\n+        &mut self,\n+        path_op: &OpTy<'tcx, Provenance>,\n+        processed_path_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"realpath\");\n+\n+        let pathname = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n+        let processed_ptr = this.read_pointer(processed_path_op)?;\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`realpath`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EACCES\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(Pointer::null());\n+        }\n+\n+        let result = std::fs::canonicalize(pathname);\n+        match result {\n+            Ok(resolved) => {\n+                let path_max = this\n+                    .eval_libc_i32(\"PATH_MAX\")?\n+                    .try_into()\n+                    .expect(\"PATH_MAX does not fit in u64\");\n+                let dest = if this.ptr_is_null(processed_ptr)? {\n+                    // POSIX says behavior when passing a null pointer is implementation-defined,\n+                    // but GNU/linux, freebsd, netbsd, bionic/android, and macos all treat a null pointer\n+                    // similarly to:\n+                    //\n+                    // \"If resolved_path is specified as NULL, then realpath() uses\n+                    // malloc(3) to allocate a buffer of up to PATH_MAX bytes to hold\n+                    // the resolved pathname, and returns a pointer to this buffer.  The\n+                    // caller should deallocate this buffer using free(3).\"\n+                    // <https://man7.org/linux/man-pages/man3/realpath.3.html>\n+                    this.alloc_os_str_as_c_str(resolved.as_os_str(), MiriMemoryKind::C.into())?\n+                } else {\n+                    let (wrote_path, _) =\n+                        this.write_path_to_c_str(&resolved, processed_ptr, path_max)?;\n+\n+                    if !wrote_path {\n+                        // Note that we do not explicitly handle `FILENAME_MAX`\n+                        // (different from `PATH_MAX` above) as it is Linux-specific and\n+                        // seems like a bit of a mess anyway: <https://eklitzke.org/path-max-is-tricky>.\n+                        let enametoolong = this.eval_libc(\"ENAMETOOLONG\")?;\n+                        this.set_last_error(enametoolong)?;\n+                        return Ok(Pointer::null());\n+                    }\n+                    processed_ptr\n+                };\n+\n+                Ok(dest)\n+            }\n+            Err(e) => {\n+                this.set_last_error_from_io_error(e.kind())?;\n+                Ok(Pointer::null())\n+            }\n+        }\n+    }\n }\n \n /// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch when"}, {"sha": "fb545d8b5847e8406e429a2de5ed75cf8f3ce560", "filename": "src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43bede93826f459e210957c8fd12fc1dd77d678/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=b43bede93826f459e210957c8fd12fc1dd77d678", "patch": "@@ -73,6 +73,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n+            \"realpath$DARWIN_EXTSN\" => {\n+                let [path, resolved_path] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.realpath(path, resolved_path)?;\n+                this.write_pointer(result, dest)?;\n+            }\n \n             // Environment related shims\n             \"_NSGetEnviron\" => {"}, {"sha": "a8025007bf5f502038132a9c73d1718b67fc4ccb", "filename": "tests/pass/fs.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b43bede93826f459e210957c8fd12fc1dd77d678/tests%2Fpass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43bede93826f459e210957c8fd12fc1dd77d678/tests%2Fpass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ffs.rs?ref=b43bede93826f459e210957c8fd12fc1dd77d678", "patch": "@@ -24,6 +24,7 @@ fn main() {\n     test_errors();\n     test_rename();\n     test_directory();\n+    test_canonicalize();\n     test_dup_stdout_stderr();\n \n     // These all require unix, if the test is changed to no longer `ignore-windows`, move these to a unix test\n@@ -365,6 +366,24 @@ fn test_rename() {\n     remove_file(&path2).unwrap();\n }\n \n+fn test_canonicalize() {\n+    use std::fs::canonicalize;\n+    let dir_path = prepare_dir(\"miri_test_fs_dir\");\n+    create_dir(&dir_path).unwrap();\n+    let path = dir_path.join(\"test_file\");\n+    drop(File::create(&path).unwrap());\n+\n+    let p = canonicalize(format!(\"{}/./test_file\", dir_path.to_string_lossy())).unwrap();\n+    assert_eq!(p.to_string_lossy().find('.'), None);\n+\n+    remove_dir_all(&dir_path).unwrap();\n+\n+    // Make sure we get an error for long paths.\n+    use std::convert::TryInto;\n+    let too_long = \"x/\".repeat(libc::PATH_MAX.try_into().unwrap());\n+    assert!(canonicalize(too_long).is_err());\n+}\n+\n fn test_directory() {\n     let dir_path = prepare_dir(\"miri_test_fs_dir\");\n     // Creating a directory should succeed."}, {"sha": "2735e5b25bc3b4aac8f3ce3f24c2980e3f54c38d", "filename": "tests/pass/libc.rs", "status": "modified", "additions": 131, "deletions": 2, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/b43bede93826f459e210957c8fd12fc1dd77d678/tests%2Fpass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43bede93826f459e210957c8fd12fc1dd77d678/tests%2Fpass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.rs?ref=b43bede93826f459e210957c8fd12fc1dd77d678", "patch": "@@ -1,16 +1,141 @@\n //@ignore-target-windows: No libc on Windows\n //@compile-flags: -Zmiri-disable-isolation\n+#![feature(io_error_more)]\n #![feature(rustc_private)]\n \n use std::fs::{remove_file, File};\n use std::os::unix::io::AsRawFd;\n+use std::path::PathBuf;\n \n-fn tmp() -> std::path::PathBuf {\n+fn tmp() -> PathBuf {\n     std::env::var(\"MIRI_TEMP\")\n-        .map(std::path::PathBuf::from)\n+        .map(|tmp| {\n+            // MIRI_TEMP is set outside of our emulated\n+            // program, so it may have path separators that don't\n+            // correspond to our target platform. We normalize them here\n+            // before constructing a `PathBuf`\n+            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n+        })\n         .unwrap_or_else(|_| std::env::temp_dir())\n }\n \n+/// Test allocating variant of `realpath`.\n+fn test_posix_realpath_alloc() {\n+    use std::ffi::OsString;\n+    use std::ffi::{CStr, CString};\n+    use std::fs::{remove_file, File};\n+    use std::os::unix::ffi::OsStrExt;\n+    use std::os::unix::ffi::OsStringExt;\n+\n+    let buf;\n+    let path = tmp().join(\"miri_test_libc_posix_realpath_alloc\");\n+    let c_path = CString::new(path.as_os_str().as_bytes()).expect(\"CString::new failed\");\n+\n+    // Cleanup before test.\n+    remove_file(&path).ok();\n+    // Create file.\n+    drop(File::create(&path).unwrap());\n+    unsafe {\n+        let r = libc::realpath(c_path.as_ptr(), std::ptr::null_mut());\n+        assert!(!r.is_null());\n+        buf = CStr::from_ptr(r).to_bytes().to_vec();\n+        libc::free(r as *mut _);\n+    }\n+    let canonical = PathBuf::from(OsString::from_vec(buf));\n+    assert_eq!(path.file_name(), canonical.file_name());\n+\n+    // Cleanup after test.\n+    remove_file(&path).unwrap();\n+}\n+\n+/// Test non-allocating variant of `realpath`.\n+fn test_posix_realpath_noalloc() {\n+    use std::ffi::{CStr, CString};\n+    use std::fs::{remove_file, File};\n+    use std::os::unix::ffi::OsStrExt;\n+\n+    let path = tmp().join(\"miri_test_libc_posix_realpath_noalloc\");\n+    let c_path = CString::new(path.as_os_str().as_bytes()).expect(\"CString::new failed\");\n+\n+    let mut v = vec![0; libc::PATH_MAX as usize];\n+\n+    // Cleanup before test.\n+    remove_file(&path).ok();\n+    // Create file.\n+    drop(File::create(&path).unwrap());\n+    unsafe {\n+        let r = libc::realpath(c_path.as_ptr(), v.as_mut_ptr());\n+        assert!(!r.is_null());\n+    }\n+    let c = unsafe { CStr::from_ptr(v.as_ptr()) };\n+    let canonical = PathBuf::from(c.to_str().expect(\"CStr to str\"));\n+\n+    assert_eq!(path.file_name(), canonical.file_name());\n+\n+    // Cleanup after test.\n+    remove_file(&path).unwrap();\n+}\n+\n+/// Test failure cases for `realpath`.\n+fn test_posix_realpath_errors() {\n+    use std::convert::TryInto;\n+    use std::ffi::CString;\n+    use std::fs::{create_dir_all, remove_dir_all};\n+    use std::io::ErrorKind;\n+    use std::os::unix::ffi::OsStrExt;\n+    use std::os::unix::fs::symlink;\n+\n+    // Test non-existent path returns an error.\n+    let c_path = CString::new(\"./nothing_to_see_here\").expect(\"CString::new failed\");\n+    let r = unsafe { libc::realpath(c_path.as_ptr(), std::ptr::null_mut()) };\n+    assert!(r.is_null());\n+    let e = std::io::Error::last_os_error();\n+    assert_eq!(e.raw_os_error(), Some(libc::ENOENT));\n+    assert_eq!(e.kind(), ErrorKind::NotFound);\n+\n+    // Test that a long path returns an error.\n+    //\n+    // Linux first checks if the path exists and macos does not.\n+    // Using an existing path ensures all platforms return `ENAMETOOLONG` given a long path.\n+    //\n+    // Rather than creating a bunch of directories, we create two directories containing symlinks.\n+    // Sadly we can't avoid creating directories and instead use a path like \"./././././\" or \"./../../\" as linux\n+    // appears to collapse \".\" and \"..\" before checking path length.\n+    let path = tmp().join(\"posix_realpath_errors\");\n+    // Cleanup before test.\n+    remove_dir_all(&path).ok();\n+\n+    // The directories we will put symlinks in.\n+    let x = path.join(\"x/\");\n+    let y = path.join(\"y/\");\n+\n+    // The symlinks in each directory pointing to each other.\n+    let yx_sym = y.join(\"x\");\n+    let xy_sym = x.join(\"y\");\n+\n+    // Create directories.\n+    create_dir_all(&x).expect(\"dir x\");\n+    create_dir_all(&y).expect(\"dir y\");\n+\n+    // Create symlinks between directories.\n+    symlink(&x, &yx_sym).expect(\"symlink x\");\n+    symlink(&y, &xy_sym).expect(\"symlink y \");\n+\n+    // This path exists due to the symlinks created above.\n+    let too_long = path.join(\"x/y/\".repeat(libc::PATH_MAX.try_into().unwrap()));\n+\n+    let c_path = CString::new(too_long.into_os_string().as_bytes()).expect(\"CString::new failed\");\n+    let r = unsafe { libc::realpath(c_path.as_ptr(), std::ptr::null_mut()) };\n+    let e = std::io::Error::last_os_error();\n+\n+    assert!(r.is_null());\n+    assert_eq!(e.raw_os_error(), Some(libc::ENAMETOOLONG));\n+    assert_eq!(e.kind(), ErrorKind::InvalidFilename);\n+\n+    // Cleanup after test.\n+    remove_dir_all(&path).ok();\n+}\n+\n #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n fn test_posix_fadvise() {\n     use std::convert::TryInto;\n@@ -336,6 +461,10 @@ fn main() {\n \n     test_posix_gettimeofday();\n \n+    test_posix_realpath_alloc();\n+    test_posix_realpath_noalloc();\n+    test_posix_realpath_errors();\n+\n     #[cfg(any(target_os = \"linux\"))]\n     test_sync_file_range();\n "}]}