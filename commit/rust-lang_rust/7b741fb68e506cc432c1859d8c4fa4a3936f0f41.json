{"sha": "7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNzQxZmI2OGU1MDZjYzQzMmMxODU5ZDhjNGZhNGEzOTM2ZjBmNDE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-11T11:36:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-11T11:36:06Z"}, "message": "Rollup merge of #67889 - Zoxc:parallel-cgus, r=michaelwoerister\n\nCompile some CGUs in parallel at the start of codegen\n\nThis brings the compilation time for `syntex_syntax` from 11.542s to 10.453s with 6 threads in non-incremental debug mode. Just compiling `n` CGUs in parallel at the beginning of codegen seems sufficient to get rid of the staircase effect, at least for `syntex_syntax`.\n\nBased on https://github.com/rust-lang/rust/pull/67777.\n\nr? @michaelwoerister\ncc @alexcrichton @Mark-Simulacrum", "tree": {"sha": "d48367a1970306aed53c22639a13baa40e5582c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48367a1970306aed53c22639a13baa40e5582c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeGbMmCRBK7hj4Ov3rIwAAdHIIABax6yLkBYBR5BHo1H0sxJNB\nF87E92XCXbwz6nSuHCVyT9Ha/xbpwp+IHBnMmozuedsFaP9BvjbZVN9pWGx0/7q/\nNt5KIS8cERG658hxgmjOdLh5c0XTDu8MsgdBjSbT37xe2kJbhWtJjwBqsQrObGRx\nLvmOVb+S5iFhJG4+tE3riLtJ0G6P0mNUQwWXmvu7OpaLB9c+i5hADuUSJ+mutkwk\nyVr2WNSsmOYV1bpSuCeG94Qa/cVjiR5BJpKgJqAmReKcguRxmt+rK+IaQ5rq5QGO\nEIBbpjTf3ldpKizL1n/fn5a4OJVFr2cFfJBr4rfxEUMM2L3ryyTtombxv+4tM4E=\n=CFQ+\n-----END PGP SIGNATURE-----\n", "payload": "tree d48367a1970306aed53c22639a13baa40e5582c4\nparent cd47af1881f2844dd1b81f9e37f64dd52d969eac\nparent 69bacd002b432292f5b0fdf76b4fad1432473f36\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1578742566 +0100\ncommitter GitHub <noreply@github.com> 1578742566 +0100\n\nRollup merge of #67889 - Zoxc:parallel-cgus, r=michaelwoerister\n\nCompile some CGUs in parallel at the start of codegen\n\nThis brings the compilation time for `syntex_syntax` from 11.542s to 10.453s with 6 threads in non-incremental debug mode. Just compiling `n` CGUs in parallel at the beginning of codegen seems sufficient to get rid of the staircase effect, at least for `syntex_syntax`.\n\nBased on https://github.com/rust-lang/rust/pull/67777.\n\nr? @michaelwoerister\ncc @alexcrichton @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "html_url": "https://github.com/rust-lang/rust/commit/7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd47af1881f2844dd1b81f9e37f64dd52d969eac", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd47af1881f2844dd1b81f9e37f64dd52d969eac", "html_url": "https://github.com/rust-lang/rust/commit/cd47af1881f2844dd1b81f9e37f64dd52d969eac"}, {"sha": "69bacd002b432292f5b0fdf76b4fad1432473f36", "url": "https://api.github.com/repos/rust-lang/rust/commits/69bacd002b432292f5b0fdf76b4fad1432473f36", "html_url": "https://github.com/rust-lang/rust/commit/69bacd002b432292f5b0fdf76b4fad1432473f36"}], "stats": {"total": 111, "additions": 89, "deletions": 22}, "files": [{"sha": "d3b524c1a1e70023fe3bd43eddd16a4244630d9c", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "patch": "@@ -13,7 +13,7 @@\n //!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n-use super::{LlvmCodegenBackend, ModuleLlvm};\n+use super::ModuleLlvm;\n \n use crate::builder::Builder;\n use crate::common;\n@@ -29,7 +29,6 @@ use rustc::middle::exported_symbols;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::session::config::DebugInfo;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::back::write::submit_codegened_module_to_llvm;\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_codegen_ssa::traits::*;\n@@ -100,8 +99,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n pub fn compile_codegen_unit(\n     tcx: TyCtxt<'tcx>,\n     cgu_name: Symbol,\n-    tx_to_llvm_workers: &std::sync::mpsc::Sender<Box<dyn std::any::Any + Send>>,\n-) {\n+) -> (ModuleCodegen<ModuleLlvm>, u64) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n \n@@ -115,8 +113,6 @@ pub fn compile_codegen_unit(\n     // the time we needed for codegenning it.\n     let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n \n-    submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tx_to_llvm_workers, module, cost);\n-\n     fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet...\n@@ -164,6 +160,8 @@ pub fn compile_codegen_unit(\n             kind: ModuleKind::Regular,\n         }\n     }\n+\n+    (module, cost)\n }\n \n pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {"}, {"sha": "a6168128c4d44611eb45a5be8f9234e687dfcfc8", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "patch": "@@ -19,6 +19,7 @@\n #![feature(link_args)]\n #![feature(static_nobundle)]\n #![feature(trusted_len)]\n+#![recursion_limit = \"256\"]\n \n use back::write::{create_informational_target_machine, create_target_machine};\n use rustc_span::symbol::Symbol;\n@@ -108,9 +109,8 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         tcx: TyCtxt<'_>,\n         cgu_name: Symbol,\n-        tx: &std::sync::mpsc::Sender<Box<dyn Any + Send>>,\n-    ) {\n-        base::compile_codegen_unit(tcx, cgu_name, tx);\n+    ) -> (ModuleCodegen<ModuleLlvm>, u64) {\n+        base::compile_codegen_unit(tcx, cgu_name)\n     }\n     fn target_machine_factory(\n         &self,"}, {"sha": "efd560071202cd7aa1ebbc5cf6d3a32553933091", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "patch": "@@ -14,8 +14,8 @@\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n use crate::back::write::{\n-    start_async_codegen, submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm,\n-    OngoingCodegen,\n+    start_async_codegen, submit_codegened_module_to_llvm, submit_post_lto_module_to_llvm,\n+    submit_pre_lto_module_to_llvm, OngoingCodegen,\n };\n use crate::common::{IntPredicate, RealPredicate, TypeKind};\n use crate::meth;\n@@ -40,6 +40,7 @@ use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc_codegen_utils::{check_for_rustc_errors_attr, symbol_names_test};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::print_time_passes_entry;\n+use rustc_data_structures::sync::{par_iter, Lock, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::Idx;\n@@ -606,20 +607,83 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         codegen_units\n     };\n \n-    let mut total_codegen_time = Duration::new(0, 0);\n+    let total_codegen_time = Lock::new(Duration::new(0, 0));\n \n-    for cgu in codegen_units.into_iter() {\n+    // The non-parallel compiler can only translate codegen units to LLVM IR\n+    // on a single thread, leading to a staircase effect where the N LLVM\n+    // threads have to wait on the single codegen threads to generate work\n+    // for them. The parallel compiler does not have this restriction, so\n+    // we can pre-load the LLVM queue in parallel before handing off\n+    // coordination to the OnGoingCodegen scheduler.\n+    //\n+    // This likely is a temporary measure. Once we don't have to support the\n+    // non-parallel compiler anymore, we can compile CGUs end-to-end in\n+    // parallel and get rid of the complicated scheduling logic.\n+    let pre_compile_cgus = |cgu_reuse: &[CguReuse]| {\n+        if cfg!(parallel_compiler) {\n+            tcx.sess.time(\"compile_first_CGU_batch\", || {\n+                // Try to find one CGU to compile per thread.\n+                let cgus: Vec<_> = cgu_reuse\n+                    .iter()\n+                    .enumerate()\n+                    .filter(|&(_, reuse)| reuse == &CguReuse::No)\n+                    .take(tcx.sess.threads())\n+                    .collect();\n+\n+                // Compile the found CGUs in parallel.\n+                par_iter(cgus)\n+                    .map(|(i, _)| {\n+                        let start_time = Instant::now();\n+                        let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n+                        let mut time = total_codegen_time.lock();\n+                        *time += start_time.elapsed();\n+                        (i, module)\n+                    })\n+                    .collect()\n+            })\n+        } else {\n+            FxHashMap::default()\n+        }\n+    };\n+\n+    let mut cgu_reuse = Vec::new();\n+    let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n+\n+    for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n-        let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n+        // Do some setup work in the first iteration\n+        if pre_compiled_cgus.is_none() {\n+            // Calculate the CGU reuse\n+            cgu_reuse = tcx.sess.time(\"find_cgu_reuse\", || {\n+                codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect()\n+            });\n+            // Pre compile some CGUs\n+            pre_compiled_cgus = Some(pre_compile_cgus(&cgu_reuse));\n+        }\n+\n+        let cgu_reuse = cgu_reuse[i];\n         tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                let start_time = Instant::now();\n-                backend.compile_codegen_unit(tcx, cgu.name(), &ongoing_codegen.coordinator_send);\n-                total_codegen_time += start_time.elapsed();\n+                let (module, cost) =\n+                    if let Some(cgu) = pre_compiled_cgus.as_mut().unwrap().remove(&i) {\n+                        cgu\n+                    } else {\n+                        let start_time = Instant::now();\n+                        let module = backend.compile_codegen_unit(tcx, cgu.name());\n+                        let mut time = total_codegen_time.lock();\n+                        *time += start_time.elapsed();\n+                        module\n+                    };\n+                submit_codegened_module_to_llvm(\n+                    &backend,\n+                    &ongoing_codegen.coordinator_send,\n+                    module,\n+                    cost,\n+                );\n                 false\n             }\n             CguReuse::PreLto => {\n@@ -652,7 +716,11 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    print_time_passes_entry(tcx.sess.time_passes(), \"codegen_to_LLVM_IR\", total_codegen_time);\n+    print_time_passes_entry(\n+        tcx.sess.time_passes(),\n+        \"codegen_to_LLVM_IR\",\n+        total_codegen_time.into_inner(),\n+    );\n \n     ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n "}, {"sha": "bc3a75250bf703f0b20606c8113c2f3831ea1979", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b741fb68e506cc432c1859d8c4fa4a3936f0f41/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=7b741fb68e506cc432c1859d8c4fa4a3936f0f41", "patch": "@@ -1,5 +1,6 @@\n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n+use crate::ModuleCodegen;\n \n use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::{config, Session};\n@@ -10,7 +11,6 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_span::symbol::Symbol;\n use syntax::expand::allocator::AllocatorKind;\n \n-use std::sync::mpsc;\n use std::sync::Arc;\n \n pub trait BackendTypes {\n@@ -34,7 +34,7 @@ impl<'tcx, T> Backend<'tcx> for T where\n {\n }\n \n-pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send {\n+pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send + Sync {\n     fn new_metadata(&self, sess: TyCtxt<'_>, mod_name: &str) -> Self::Module;\n     fn write_compressed_metadata<'tcx>(\n         &self,\n@@ -48,12 +48,13 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         mods: &mut Self::Module,\n         kind: AllocatorKind,\n     );\n+    /// This generates the codegen unit and returns it along with\n+    /// a `u64` giving an estimate of the unit's processing cost.\n     fn compile_codegen_unit(\n         &self,\n         tcx: TyCtxt<'_>,\n         cgu_name: Symbol,\n-        tx_to_llvm_workers: &mpsc::Sender<Box<dyn std::any::Any + Send>>,\n-    );\n+    ) -> (ModuleCodegen<Self::Module>, u64);\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}]}