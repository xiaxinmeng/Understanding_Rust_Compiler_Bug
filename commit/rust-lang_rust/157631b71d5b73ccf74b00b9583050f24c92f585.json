{"sha": "157631b71d5b73ccf74b00b9583050f24c92f585", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NzYzMWI3MWQ1YjczY2NmNzRiMDBiOTU4MzA1MGYyNGM5MmY1ODU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-06T18:41:24Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-20T00:52:06Z"}, "message": "Remove `MaybeRequiresStorage`", "tree": {"sha": "27f4bc892f1861c046c9c9c463c735a985fd1eec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27f4bc892f1861c046c9c9c463c735a985fd1eec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/157631b71d5b73ccf74b00b9583050f24c92f585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/157631b71d5b73ccf74b00b9583050f24c92f585", "html_url": "https://github.com/rust-lang/rust/commit/157631b71d5b73ccf74b00b9583050f24c92f585", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/157631b71d5b73ccf74b00b9583050f24c92f585/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3508592c26055ddd0c79d1ad595f1dc7b0640162", "url": "https://api.github.com/repos/rust-lang/rust/commits/3508592c26055ddd0c79d1ad595f1dc7b0640162", "html_url": "https://github.com/rust-lang/rust/commit/3508592c26055ddd0c79d1ad595f1dc7b0640162"}], "stats": {"total": 236, "additions": 2, "deletions": 234}, "files": [{"sha": "ed01d6b01ea4316afb9d7a1d3fc154fcb3cbac21", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/157631b71d5b73ccf74b00b9583050f24c92f585/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157631b71d5b73ccf74b00b9583050f24c92f585/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=157631b71d5b73ccf74b00b9583050f24c92f585", "patch": "@@ -30,7 +30,7 @@ pub use self::borrowed_locals::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n pub use self::borrows::Borrows;\n pub use self::init_locals::MaybeInitializedLocals;\n pub use self::liveness::MaybeLiveLocals;\n-pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};\n+pub use self::storage_liveness::MaybeStorageLive;\n \n /// `MaybeInitializedPlaces` tracks all places that might be\n /// initialized upon reaching a particular point in the control flow"}, {"sha": "2a2be069b1ed8d433a94eb3a4af10d918655a792", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 233, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/157631b71d5b73ccf74b00b9583050f24c92f585/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157631b71d5b73ccf74b00b9583050f24c92f585/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=157631b71d5b73ccf74b00b9583050f24c92f585", "patch": "@@ -1,11 +1,9 @@\n pub use super::*;\n \n use crate::dataflow::BottomValue;\n-use crate::dataflow::{self, GenKill, Results, ResultsRefCursor};\n+use crate::dataflow::{self, GenKill};\n use crate::util::storage::AlwaysLiveLocals;\n-use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n-use std::cell::RefCell;\n \n #[derive(Clone)]\n pub struct MaybeStorageLive {\n@@ -78,233 +76,3 @@ impl BottomValue for MaybeStorageLive {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n-\n-type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorrowedLocals>;\n-\n-/// Dataflow analysis that determines whether each local requires storage at a\n-/// given location; i.e. whether its storage can go away without being observed.\n-pub struct MaybeRequiresStorage<'mir, 'tcx> {\n-    body: &'mir Body<'tcx>,\n-    borrowed_locals: RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n-}\n-\n-impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n-    pub fn new(\n-        body: &'mir Body<'tcx>,\n-        borrowed_locals: &'mir Results<'tcx, MaybeBorrowedLocals>,\n-    ) -> Self {\n-        MaybeRequiresStorage {\n-            body,\n-            borrowed_locals: RefCell::new(ResultsRefCursor::new(&body, borrowed_locals)),\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> dataflow::AnalysisDomain<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n-    type Idx = Local;\n-\n-    const NAME: &'static str = \"requires_storage\";\n-\n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n-    }\n-\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n-        // The resume argument is live on function entry (we don't care about\n-        // the `self` argument)\n-        for arg in body.args_iter().skip(1) {\n-            on_entry.insert(arg);\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n-    fn before_statement_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        stmt: &mir::Statement<'tcx>,\n-        loc: Location,\n-    ) {\n-        // If a place is borrowed in a statement, it needs storage for that statement.\n-        self.borrowed_locals.borrow().analysis().statement_effect(trans, stmt, loc);\n-\n-        match &stmt.kind {\n-            StatementKind::StorageDead(l) => trans.kill(*l),\n-\n-            // If a place is assigned to in a statement, it needs storage for that statement.\n-            StatementKind::Assign(box (place, _))\n-            | StatementKind::SetDiscriminant { box place, .. } => {\n-                trans.gen(place.local);\n-            }\n-            StatementKind::LlvmInlineAsm(asm) => {\n-                for place in &*asm.outputs {\n-                    trans.gen(place.local);\n-                }\n-            }\n-\n-            // Nothing to do for these. Match exhaustively so this fails to compile when new\n-            // variants are added.\n-            StatementKind::AscribeUserType(..)\n-            | StatementKind::FakeRead(..)\n-            | StatementKind::Nop\n-            | StatementKind::Retag(..)\n-            | StatementKind::StorageLive(..) => {}\n-        }\n-    }\n-\n-    fn statement_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _: &mir::Statement<'tcx>,\n-        loc: Location,\n-    ) {\n-        // If we move from a place then only stops needing storage *after*\n-        // that statement.\n-        self.check_for_move(trans, loc);\n-    }\n-\n-    fn before_terminator_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        terminator: &mir::Terminator<'tcx>,\n-        loc: Location,\n-    ) {\n-        // If a place is borrowed in a terminator, it needs storage for that terminator.\n-        self.borrowed_locals.borrow().analysis().terminator_effect(trans, terminator, loc);\n-\n-        match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n-                trans.gen(place.local);\n-            }\n-\n-            // Note that we do *not* gen the `resume_arg` of `Yield` terminators. The reason for\n-            // that is that a `yield` will return from the function, and `resume_arg` is written\n-            // only when the generator is later resumed. Unlike `Call`, this doesn't require the\n-            // place to have storage *before* the yield, only after.\n-            TerminatorKind::Yield { .. } => {}\n-\n-            TerminatorKind::InlineAsm { operands, .. } => {\n-                for op in operands {\n-                    match op {\n-                        InlineAsmOperand::Out { place, .. }\n-                        | InlineAsmOperand::InOut { out_place: place, .. } => {\n-                            if let Some(place) = place {\n-                                trans.gen(place.local);\n-                            }\n-                        }\n-                        InlineAsmOperand::In { .. }\n-                        | InlineAsmOperand::Const { .. }\n-                        | InlineAsmOperand::SymFn { .. }\n-                        | InlineAsmOperand::SymStatic { .. } => {}\n-                    }\n-                }\n-            }\n-\n-            // Nothing to do for these. Match exhaustively so this fails to compile when new\n-            // variants are added.\n-            TerminatorKind::Call { destination: None, .. }\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Assert { .. }\n-            | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n-            | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Goto { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Return\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Unreachable => {}\n-        }\n-    }\n-\n-    fn terminator_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        terminator: &mir::Terminator<'tcx>,\n-        loc: Location,\n-    ) {\n-        match &terminator.kind {\n-            // For call terminators the destination requires storage for the call\n-            // and after the call returns successfully, but not after a panic.\n-            // Since `propagate_call_unwind` doesn't exist, we have to kill the\n-            // destination here, and then gen it again in `call_return_effect`.\n-            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n-                trans.kill(place.local);\n-            }\n-\n-            // Nothing to do for these. Match exhaustively so this fails to compile when new\n-            // variants are added.\n-            TerminatorKind::Call { destination: None, .. }\n-            | TerminatorKind::Yield { .. }\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Assert { .. }\n-            | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n-            | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Goto { .. }\n-            | TerminatorKind::InlineAsm { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Return\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Unreachable => {}\n-        }\n-\n-        self.check_for_move(trans, loc);\n-    }\n-\n-    fn call_return_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _block: BasicBlock,\n-        _func: &mir::Operand<'tcx>,\n-        _args: &[mir::Operand<'tcx>],\n-        return_place: mir::Place<'tcx>,\n-    ) {\n-        trans.gen(return_place.local);\n-    }\n-\n-    fn yield_resume_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _resume_block: BasicBlock,\n-        resume_place: mir::Place<'tcx>,\n-    ) {\n-        trans.gen(resume_place.local);\n-    }\n-}\n-\n-impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n-    /// Kill locals that are fully moved and have not been borrowed.\n-    fn check_for_move(&self, trans: &mut impl GenKill<Local>, loc: Location) {\n-        let mut visitor = MoveVisitor { trans, borrowed_locals: &self.borrowed_locals };\n-        visitor.visit_location(&self.body, loc);\n-    }\n-}\n-\n-impl<'mir, 'tcx> BottomValue for MaybeRequiresStorage<'mir, 'tcx> {\n-    /// bottom = dead\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n-struct MoveVisitor<'a, 'mir, 'tcx, T> {\n-    borrowed_locals: &'a RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n-    trans: &'a mut T,\n-}\n-\n-impl<'a, 'mir, 'tcx, T> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx, T>\n-where\n-    T: GenKill<Local>,\n-{\n-    fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n-        if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n-            let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n-            borrowed_locals.seek_before_primary_effect(loc);\n-            if !borrowed_locals.contains(*local) {\n-                self.trans.kill(*local);\n-            }\n-        }\n-    }\n-}"}]}