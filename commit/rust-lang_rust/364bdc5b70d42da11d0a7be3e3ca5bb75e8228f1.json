{"sha": "364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NGJkYzViNzBkNDJkYTExZDBhN2JlM2UzY2E1YmI3NWU4MjI4ZjE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-04T05:41:33Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-04T05:41:33Z"}, "message": "Merge pull request #427 from wartman4404/master\n\nPrefer `.cloned()` over `.map(|x| x.clone())`", "tree": {"sha": "9dd43c77d348637a2fa35d9c4d128bc1d2c2a0d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dd43c77d348637a2fa35d9c4d128bc1d2c2a0d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "html_url": "https://github.com/rust-lang/rust/commit/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b1409684a4860a73608609fd50dfd256c87a785", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1409684a4860a73608609fd50dfd256c87a785", "html_url": "https://github.com/rust-lang/rust/commit/4b1409684a4860a73608609fd50dfd256c87a785"}, {"sha": "764eedd0508a53b5184741bd05b8d20ea1034c42", "url": "https://api.github.com/repos/rust-lang/rust/commits/764eedd0508a53b5184741bd05b8d20ea1034c42", "html_url": "https://github.com/rust-lang/rust/commit/764eedd0508a53b5184741bd05b8d20ea1034c42"}], "stats": {"total": 209, "additions": 203, "deletions": 6}, "files": [{"sha": "4c23d6994d298fc9ed2cc7829f2e41b20b027422", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 71 lints included in this crate:\n+There are 72 lints included in this crate:\n \n name                                                                                                   | default | meaning\n -------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -34,6 +34,7 @@ name\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                       | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                       | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                               | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n+[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                 | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                               | warn    | a match on boolean expression; recommends `if..else` block instead\n [match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                       | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                     | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant"}, {"sha": "855ea51ee8eacc395a48caf87025302fa5db16b1", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use rustc::middle::ty;\n \n-use utils::{snippet, span_lint};\n+use utils::{snippet, span_lint, is_adjusted};\n \n \n #[allow(missing_copy_implementations)]\n@@ -32,10 +32,6 @@ impl LateLintPass for EtaPass {\n     }\n }\n \n-fn is_adjusted(cx: &LateContext, e: &Expr) -> bool {\n-    cx.tcx.tables.borrow().adjustments.get(&e.id).is_some()\n-}\n-\n fn check_closure(cx: &LateContext, expr: &Expr) {\n     if let ExprClosure(_, ref decl, ref blk) = expr.node {\n         if !blk.stmts.is_empty() {"}, {"sha": "37e1ace61ded590091d440c70023a058c08f28a4", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "patch": "@@ -45,6 +45,7 @@ pub mod returns;\n pub mod lifetimes;\n pub mod loops;\n pub mod ranges;\n+pub mod map_clone;\n pub mod matches;\n pub mod precedence;\n pub mod mutex_atomic;\n@@ -100,6 +101,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box needless_features::NeedlessFeaturesPass);\n     reg.register_late_lint_pass(box needless_update::NeedlessUpdatePass);\n     reg.register_late_lint_pass(box no_effect::NoEffectPass);\n+    reg.register_late_lint_pass(box map_clone::MapClonePass);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n@@ -141,6 +143,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::UNUSED_COLLECT,\n         loops::WHILE_LET_LOOP,\n         loops::WHILE_LET_ON_ITERATOR,\n+        map_clone::MAP_CLONE,\n         matches::MATCH_BOOL,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,"}, {"sha": "e93a8221145847a5f3957cd0e41e478101d9a573", "filename": "src/map_clone.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "patch": "@@ -0,0 +1,101 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use syntax::ast::Ident;\n+use utils::OPTION_PATH;\n+use utils::{is_adjusted, match_trait_method, match_type, snippet, span_help_and_lint};\n+use utils::{walk_ptrs_ty, walk_ptrs_ty_depth};\n+\n+declare_lint!(pub MAP_CLONE, Warn,\n+              \"using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends \\\n+              `.cloned()` instead)\");\n+\n+#[derive(Copy, Clone)]\n+pub struct MapClonePass;\n+\n+impl LateLintPass for MapClonePass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if_let_chain! {\n+            [\n+                // call to .map()\n+                let ExprMethodCall(name, _, ref args) = expr.node,\n+                name.node.as_str() == \"map\" && args.len() == 2,\n+                let ExprClosure(_, ref decl, ref blk) = args[1].node,\n+                // just one expression in the closure\n+                blk.stmts.is_empty(),\n+                let Some(ref closure_expr) = blk.expr,\n+                // nothing special in the argument, besides reference bindings\n+                // (e.g. .map(|&x| x) )\n+                let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n+                // the method is being called on a known type (option or iterator)\n+                let Some(type_name) = get_type_name(cx, expr, &args[0])\n+            ], {\n+                // look for derefs, for .map(|x| *x)\n+                if only_derefs(cx, &*closure_expr, arg_ident) &&\n+                    // .cloned() only removes one level of indirection, don't lint on more\n+                    walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                {\n+                    span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                        \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                        using `.cloned()`\", type_name),\n+                        &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                }\n+                // explicit clone() calls ( .map(|x| x.clone()) )\n+                else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n+                    if clone_call.node.as_str() == \"clone\" &&\n+                        clone_args.len() == 1 &&\n+                        match_trait_method(cx, closure_expr, &[\"core\", \"clone\", \"Clone\"]) &&\n+                        expr_eq_ident(&clone_args[0], arg_ident)\n+                    {\n+                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                            using `.cloned()`\", type_name),\n+                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n+    match expr.node {\n+        ExprPath(None, ref path) => {\n+            let arg_segment = [PathSegment { identifier: id, parameters: PathParameters::none() }];\n+            !path.global && path.segments == arg_segment\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n+    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+        Some(\"iterator\")\n+    } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &OPTION_PATH) {\n+        Some(\"Option\")\n+    } else {\n+        None\n+    }\n+}\n+\n+fn get_arg_name(pat: &Pat) -> Option<Ident> {\n+    match pat.node {\n+        PatIdent(_, ident, None) => Some(ident.node),\n+        PatRegion(ref subpat, _) => get_arg_name(subpat),\n+        _ => None,\n+    }\n+}\n+\n+fn only_derefs(cx: &LateContext, expr: &Expr, id: Ident) -> bool {\n+    match expr.node {\n+        ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => {\n+            only_derefs(cx, subexpr, id)\n+        },\n+        _ => expr_eq_ident(expr, id),\n+    }\n+}\n+\n+impl LintPass for MapClonePass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MAP_CLONE)\n+    }\n+}"}, {"sha": "757d7bc379d76eb988bfccf764e0e3f6252d253d", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "patch": "@@ -347,6 +347,10 @@ pub fn is_integer_literal(expr: &Expr, value: u64) -> bool\n     false\n }\n \n+pub fn is_adjusted(cx: &LateContext, e: &Expr) -> bool {\n+    cx.tcx.tables.borrow().adjustments.get(&e.id).is_some()\n+}\n+\n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n ///     if_let_chain! {"}, {"sha": "f6241114a83c545356e04adf8bb5b065e39fffa9", "filename": "tests/compile-fail/map_clone.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/tests%2Fcompile-fail%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1/tests%2Fcompile-fail%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmap_clone.rs?ref=364bdc5b70d42da11d0a7be3e3ca5bb75e8228f1", "patch": "@@ -0,0 +1,92 @@\n+#![feature(plugin)]\n+\n+#![plugin(clippy)]\n+#![deny(map_clone)]\n+\n+#![allow(unused)]\n+\n+use std::ops::Deref;\n+\n+fn map_clone_iter() {\n+    let x = [1,2,3];\n+    x.iter().map(|y| y.clone()); //~ ERROR you seem to be using .map()\n+                                 //~^ HELP try\n+    x.iter().map(|&y| y); //~ ERROR you seem to be using .map()\n+                          //~^ HELP try\n+    x.iter().map(|y| *y); //~ ERROR you seem to be using .map()\n+                          //~^ HELP try\n+}\n+\n+fn map_clone_option() {\n+    let x = Some(4);\n+    x.as_ref().map(|y| y.clone()); //~ ERROR you seem to be using .map()\n+                                   //~^ HELP try\n+    x.as_ref().map(|&y| y); //~ ERROR you seem to be using .map()\n+                            //~^ HELP try\n+    x.as_ref().map(|y| *y); //~ ERROR you seem to be using .map()\n+                            //~^ HELP try\n+}\n+\n+fn not_linted_option() {\n+    let x = Some(5);\n+\n+    // Not linted: other statements\n+    x.as_ref().map(|y| {\n+        println!(\"y: {}\", y);\n+        y.clone()\n+    });\n+\n+    // Not linted: argument bindings\n+    let x = Some((6, 7));\n+    x.map(|(y, _)| y.clone());\n+\n+    // Not linted: cloning something else\n+    x.map(|y| y.0.clone());\n+\n+    // Not linted: no dereferences\n+    x.map(|y| y);\n+\n+    // Not linted: multiple dereferences\n+    let _: Option<(i32, i32)> = x.as_ref().as_ref().map(|&&x| x);\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Wrapper<T>(T);\n+impl<T> Wrapper<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Wrapper<U> {\n+        Wrapper(f(self.0))\n+    }\n+}\n+\n+fn map_clone_other() {\n+    let eight = 8;\n+    let x = Wrapper(&eight);\n+\n+    // Not linted: not a linted type\n+    x.map(|y| y.clone());\n+    x.map(|&y| y);\n+    x.map(|y| *y);\n+}\n+\n+#[derive(Copy, Clone)]\n+struct UnusualDeref;\n+static NINE: i32 = 9;\n+\n+impl Deref for UnusualDeref {\n+    type Target = i32;\n+    fn deref(&self) -> &i32 { &NINE }\n+}\n+\n+fn map_clone_deref() {\n+    let x = Some(UnusualDeref);\n+    let _: Option<UnusualDeref> = x.as_ref().map(|y| *y); //~ ERROR you seem to be using .map()\n+                                                          //~^ HELP try\n+\n+    // Not linted: using deref conversion\n+    let _: Option<i32> = x.map(|y| *y);\n+\n+    // Not linted: using regular deref but also deref conversion\n+    let _: Option<i32> = x.as_ref().map(|y| **y);\n+}\n+\n+fn main() { }"}]}