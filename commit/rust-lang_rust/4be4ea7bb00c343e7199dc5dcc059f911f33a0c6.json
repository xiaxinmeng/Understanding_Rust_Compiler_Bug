{"sha": "4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZTRlYTdiYjAwYzM0M2U3MTk5ZGM1ZGNjMDU5ZjkxMWYzM2EwYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-20T03:25:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-20T03:25:58Z"}, "message": "auto merge of #16606 : pczarn/rust/inline-asm, r=alexcrichton\n\nIt's unfortunate that the read+write operands need special treatment in the AST. A separate vec for all expressions is an alternative, but it doesn't play nicely with trans.\r\n\r\nFixes #14936", "tree": {"sha": "461dad2e00d4102e5ea18dab90854ac8ea9a5b1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461dad2e00d4102e5ea18dab90854ac8ea9a5b1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "html_url": "https://github.com/rust-lang/rust/commit/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a0272da67d8fab7e1dd8950e92fb33480ba669a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a0272da67d8fab7e1dd8950e92fb33480ba669a", "html_url": "https://github.com/rust-lang/rust/commit/4a0272da67d8fab7e1dd8950e92fb33480ba669a"}, {"sha": "4155643428f10530cbdfe579c83f5070d58a18dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4155643428f10530cbdfe579c83f5070d58a18dd", "html_url": "https://github.com/rust-lang/rust/commit/4155643428f10530cbdfe579c83f5070d58a18dd"}], "stats": {"total": 142, "additions": 105, "deletions": 37}, "files": [{"sha": "fd3074e130e70fd66483d2187ba665ed157f8c2c", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -473,14 +473,15 @@ impl<'a> CFGBuilder<'a> {\n             ast::ExprInlineAsm(ref inline_asm) => {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n-                fn extract_expr<A>(&(_, expr): &(A, Gc<ast::Expr>)) -> Gc<ast::Expr> { expr }\n                 let post_inputs = self.exprs(inputs.map(|a| {\n                     debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n-                    extract_expr(a)\n+                    let &(_, expr) = a;\n+                    expr\n                 }), pred);\n                 let post_outputs = self.exprs(outputs.map(|a| {\n                     debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n-                    extract_expr(a)\n+                    let &(_, expr, _) = a;\n+                    expr\n                 }), post_inputs);\n                 self.add_node(expr.id, [post_outputs])\n             }"}, {"sha": "aefd57ab085ad8e981033592864551cd2bacb9e9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -380,8 +380,9 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                     self.consume_expr(&**input);\n                 }\n \n-                for &(_, ref output) in ia.outputs.iter() {\n-                    self.mutate_expr(expr, &**output, JustWrite);\n+                for &(_, ref output, is_rw) in ia.outputs.iter() {\n+                    self.mutate_expr(expr, &**output,\n+                                           if is_rw { WriteAndRead } else { JustWrite });\n                 }\n             }\n "}, {"sha": "2062fa97777d5f58b66cb212d58933b1f3563fdb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -1192,9 +1192,10 @@ impl<'a> Liveness<'a> {\n           }\n \n           ExprInlineAsm(ref ia) => {\n-            let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n-                // see comment on lvalues in\n-                // propagate_through_lvalue_components()\n+\n+            let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, ref expr, _)| {\n+                // see comment on lvalues\n+                // in propagate_through_lvalue_components()\n                 let succ = self.write_lvalue(&**expr, succ, ACC_WRITE);\n                 self.propagate_through_lvalue_components(&**expr, succ)\n             });\n@@ -1437,7 +1438,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         }\n \n         // Output operands must be lvalues\n-        for &(_, ref out) in ia.outputs.iter() {\n+        for &(_, ref out, _) in ia.outputs.iter() {\n           this.check_lvalue(&**out);\n           this.visit_expr(&**out, ());\n         }"}, {"sha": "be5f586bb97fe478a666eff1cff63701da5ef262", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -36,13 +36,27 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     let temp_scope = fcx.push_custom_cleanup_scope();\n \n+    let mut ext_inputs = Vec::new();\n+    let mut ext_constraints = Vec::new();\n+\n     // Prepare the output operands\n-    let outputs = ia.outputs.iter().map(|&(ref c, ref out)| {\n+    let outputs = ia.outputs.iter().enumerate().map(|(i, &(ref c, ref out, is_rw))| {\n         constraints.push((*c).clone());\n \n         let out_datum = unpack_datum!(bcx, expr::trans(bcx, &**out));\n         output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n-        out_datum.val\n+        let val = out_datum.val;\n+        if is_rw {\n+            ext_inputs.push(unpack_result!(bcx, {\n+                callee::trans_arg_datum(bcx,\n+                                       expr_ty(bcx, &**out),\n+                                       out_datum,\n+                                       cleanup::CustomScope(temp_scope),\n+                                       callee::DontAutorefArg)\n+            }));\n+            ext_constraints.push(i.to_string());\n+        }\n+        val\n \n     }).collect::<Vec<_>>();\n \n@@ -58,14 +72,15 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n                                    cleanup::CustomScope(temp_scope),\n                                    callee::DontAutorefArg)\n         })\n-    }).collect::<Vec<_>>();\n+    }).collect::<Vec<_>>().append(ext_inputs.as_slice());\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n     let mut constraints =\n         String::from_str(constraints.iter()\n                                     .map(|s| s.get().to_string())\n+                                    .chain(ext_constraints.move_iter())\n                                     .collect::<Vec<String>>()\n                                     .connect(\",\")\n                                     .as_slice());"}, {"sha": "88bdb00a7c983888c6d3659ae2f79cfab94cb108", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -3729,7 +3729,7 @@ fn populate_scope_map(cx: &CrateContext,\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n-                for &(_, ref exp) in outputs.iter() {\n+                for &(_, ref exp, _) in outputs.iter() {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }"}, {"sha": "1cec680ff2cb853adaffb97cac7fa4b94720001f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -3332,7 +3332,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           for &(_, ref input) in ia.inputs.iter() {\n               check_expr(fcx, &**input);\n           }\n-          for &(_, ref out) in ia.outputs.iter() {\n+          for &(_, ref out, _) in ia.outputs.iter() {\n               check_expr(fcx, &**out);\n           }\n           fcx.write_nil(id);"}, {"sha": "42d9430d7320e6c88098c8f59e0a421ceb5f6087", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -958,9 +958,9 @@ pub enum AsmDialect {\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n-    pub clobbers: InternedString,\n+    pub outputs: Vec<(InternedString, Gc<Expr>, bool)>,\n     pub inputs: Vec<(InternedString, Gc<Expr>)>,\n-    pub outputs: Vec<(InternedString, Gc<Expr>)>,\n+    pub clobbers: InternedString,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect"}, {"sha": "43fa0964f80f94d854fb912a9e9b7df56b42f55b", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -59,8 +59,6 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let mut state = Asm;\n \n-    let mut read_write_operands = Vec::new();\n-\n     'statement: loop {\n         match state {\n             Asm => {\n@@ -100,8 +98,6 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     let output = match constraint.get().slice_shift_char() {\n                         (Some('='), _) => None,\n                         (Some('+'), operand) => {\n-                            // Save a reference to the output\n-                            read_write_operands.push((outputs.len(), out));\n                             Some(token::intern_and_get_ident(format!(\n                                         \"={}\",\n                                         operand).as_slice()))\n@@ -112,7 +108,8 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         }\n                     };\n \n-                    outputs.push((output.unwrap_or(constraint), out));\n+                    let is_rw = output.is_some();\n+                    outputs.push((output.unwrap_or(constraint), out, is_rw));\n                 }\n             }\n             Inputs => {\n@@ -202,21 +199,14 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    // Append an input operand, with the form of (\"0\", expr)\n-    // that links to an output operand.\n-    for &(i, out) in read_write_operands.iter() {\n-        inputs.push((token::intern_and_get_ident(i.to_string().as_slice()),\n-                                                 out));\n-    }\n-\n     MacExpr::new(box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(asm.get()),\n             asm_str_style: asm_str_style.unwrap(),\n-            clobbers: token::intern_and_get_ident(cons.as_slice()),\n-            inputs: inputs,\n             outputs: outputs,\n+            inputs: inputs,\n+            clobbers: token::intern_and_get_ident(cons.as_slice()),\n             volatile: volatile,\n             alignstack: alignstack,\n             dialect: dialect"}, {"sha": "fb96b4b83d7f3368b8df93d7778695b8686e09a0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -1189,8 +1189,8 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n                 inputs: a.inputs.iter().map(|&(ref c, input)| {\n                     ((*c).clone(), folder.fold_expr(input))\n                 }).collect(),\n-                outputs: a.outputs.iter().map(|&(ref c, out)| {\n-                    ((*c).clone(), folder.fold_expr(out))\n+                outputs: a.outputs.iter().map(|&(ref c, out, is_rw)| {\n+                    ((*c).clone(), folder.fold_expr(out), is_rw)\n                 }).collect(),\n                 .. (*a).clone()\n             })"}, {"sha": "6fe44078447e59009c96d974283735600130418b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -1671,8 +1671,14 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\":\"));\n \n                 try!(self.commasep(Inconsistent, a.outputs.as_slice(),\n-                                   |s, &(ref co, ref o)| {\n-                    try!(s.print_string(co.get(), ast::CookedStr));\n+                                   |s, &(ref co, ref o, is_rw)| {\n+                    match co.get().slice_shift_char() {\n+                        (Some('='), operand) if is_rw => {\n+                            try!(s.print_string(format!(\"+{}\", operand).as_slice(),\n+                                                ast::CookedStr))\n+                        }\n+                        _ => try!(s.print_string(co.get(), ast::CookedStr))\n+                    }\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n                     try!(s.pclose());"}, {"sha": "9e371143311c27d0975f350689a8350fec8131ed", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -854,11 +854,11 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n         ExprParen(ref subexpression) => {\n             visitor.visit_expr(&**subexpression, env.clone())\n         }\n-        ExprInlineAsm(ref assembler) => {\n-            for &(_, ref input) in assembler.inputs.iter() {\n+        ExprInlineAsm(ref ia) => {\n+            for &(_, ref input) in ia.inputs.iter() {\n                 visitor.visit_expr(&**input, env.clone())\n             }\n-            for &(_, ref output) in assembler.outputs.iter() {\n+            for &(_, ref output, _) in ia.outputs.iter() {\n                 visitor.visit_expr(&**output, env.clone())\n             }\n         }"}, {"sha": "123ad36ee4f2d7c84a1e2d31dca870871bb2fb95", "filename": "src/test/run-pass/issue-14936.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be4ea7bb00c343e7199dc5dcc059f911f33a0c6/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14936.rs?ref=4be4ea7bb00c343e7199dc5dcc059f911f33a0c6", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(asm, macro_rules)]\n+\n+type History = Vec<&'static str>;\n+\n+fn wrap<A>(x:A, which: &'static str, history: &mut History) -> A {\n+    history.push(which);\n+    x\n+}\n+\n+macro_rules! demo {\n+    ( $output_constraint:tt ) => {\n+        {\n+            let mut x: int = 0;\n+            let y: int = 1;\n+\n+            let mut history: History = vec!();\n+            unsafe {\n+                asm!(\"mov ($1), $0\"\n+                     : $output_constraint (*wrap(&mut x, \"out\", &mut history))\n+                     : \"r\"(&wrap(y, \"in\", &mut history)));\n+            }\n+            assert_eq!((x,y), (1,1));\n+            assert_eq!(history.as_slice(), &[\"out\", \"in\"]);\n+        }\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"x86_64\")]\n+fn main() {\n+    fn out_write_only_expr_then_in_expr() {\n+        demo!(\"=r\")\n+    }\n+\n+    fn out_read_write_expr_then_in_expr() {\n+        demo!(\"+r\")\n+    }\n+\n+    out_write_only_expr_then_in_expr();\n+    out_read_write_expr_then_in_expr();\n+}\n+\n+#[cfg(not(target_arch = \"x86\"), not(target_arch = \"x86_64\"))]\n+pub fn main() {}"}]}