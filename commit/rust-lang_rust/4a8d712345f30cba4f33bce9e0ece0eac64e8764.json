{"sha": "4a8d712345f30cba4f33bce9e0ece0eac64e8764", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhOGQ3MTIzNDVmMzBjYmE0ZjMzYmNlOWUwZWNlMGVhYzY0ZTg3NjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-24T14:20:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-24T14:20:02Z"}, "message": "Use type-safe wrapper for TypeFlags", "tree": {"sha": "6e7b5d0d117b3c85a42a97dbd124bcf70fabe55e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7b5d0d117b3c85a42a97dbd124bcf70fabe55e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a8d712345f30cba4f33bce9e0ece0eac64e8764", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8d712345f30cba4f33bce9e0ece0eac64e8764", "html_url": "https://github.com/rust-lang/rust/commit/4a8d712345f30cba4f33bce9e0ece0eac64e8764", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a8d712345f30cba4f33bce9e0ece0eac64e8764/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de06faf889f0939c7d9b24aeb724b46403b8dba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/de06faf889f0939c7d9b24aeb724b46403b8dba4", "html_url": "https://github.com/rust-lang/rust/commit/de06faf889f0939c7d9b24aeb724b46403b8dba4"}], "stats": {"total": 105, "additions": 59, "deletions": 46}, "files": [{"sha": "c014bc0c164f206dce9b7c1180382c215b0d846f", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a8d712345f30cba4f33bce9e0ece0eac64e8764/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8d712345f30cba4f33bce9e0ece0eac64e8764/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=4a8d712345f30cba4f33bce9e0ece0eac64e8764", "patch": "@@ -287,7 +287,7 @@ want to be able to cache results even when all the types in the trait\n reference are not fully known. In that case, it may happen that the\n trait selection process is also influencing type variables, so we have\n to be able to not only cache the *result* of the selection process,\n-but *reply* its effects on the type variables.\n+but *replay* its effects on the type variables.\n \n ## An example\n "}, {"sha": "4a081c0db37333bb4ab87c7f72aed48705fa7408", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4a8d712345f30cba4f33bce9e0ece0eac64e8764/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8d712345f30cba4f33bce9e0ece0eac64e8764/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4a8d712345f30cba4f33bce9e0ece0eac64e8764", "patch": "@@ -589,22 +589,33 @@ pub struct ctxt<'tcx> {\n // through the type during type construction, so that we can quickly\n // check whether the type has various kinds of types in it without\n // recursing over the type itself.\n-const HAS_PARAMS: uint = 1;\n-const HAS_SELF: uint = 2;\n-const HAS_TY_INFER: uint = 4;\n-const HAS_RE_INFER: uint = 8;\n-const HAS_REGIONS: uint = 16;\n-const HAS_TY_ERR: uint = 32;\n-const HAS_TY_BOT: uint = 64;\n-const NEEDS_SUBST: uint = HAS_PARAMS | HAS_SELF | HAS_REGIONS;\n+bitflags! {\n+    flags TypeFlags: u32 {\n+        const NO_TYPE_FLAGS = 0b0,\n+        const HAS_PARAMS    = 0b1,\n+        const HAS_SELF      = 0b10,\n+        const HAS_TY_INFER  = 0b100,\n+        const HAS_RE_INFER  = 0b1000,\n+        const HAS_REGIONS   = 0b10000,\n+        const HAS_TY_ERR    = 0b100000,\n+        const HAS_TY_BOT    = 0b1000000,\n+        const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n+    }\n+}\n \n pub type t_box = &'static t_box_;\n \n #[deriving(Show)]\n pub struct t_box_ {\n     pub sty: sty,\n     pub id: uint,\n-    pub flags: uint,\n+    pub flags: TypeFlags,\n+}\n+\n+impl fmt::Show for TypeFlags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.bits)\n+    }\n }\n \n // To reduce refcounting cost, we're representing types as unsafe pointers\n@@ -631,8 +642,8 @@ pub fn get(t: t) -> t_box {\n     }\n }\n \n-fn tbox_has_flag(tb: t_box, flag: uint) -> bool {\n-    (tb.flags & flag) != 0u\n+fn tbox_has_flag(tb: t_box, flag: TypeFlags) -> bool {\n+    tb.flags.intersects(flag)\n }\n pub fn type_has_params(t: t) -> bool {\n     tbox_has_flag(get(t), HAS_PARAMS)\n@@ -887,7 +898,7 @@ mod primitives {\n             pub static $name: t_box_ = t_box_ {\n                 sty: $sty,\n                 id: $id,\n-                flags: 0,\n+                flags: super::NO_TYPE_FLAGS,\n             };\n         )\n     )\n@@ -1578,32 +1589,32 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         _ => ()\n     }\n \n-    let mut flags = 0u;\n-    fn rflags(r: Region) -> uint {\n+    let mut flags = NO_TYPE_FLAGS;\n+    fn rflags(r: Region) -> TypeFlags {\n         HAS_REGIONS | {\n             match r {\n               ty::ReInfer(_) => HAS_RE_INFER,\n-              _ => 0u\n+              _ => NO_TYPE_FLAGS,\n             }\n         }\n     }\n-    fn sflags(substs: &Substs) -> uint {\n-        let mut f = 0u;\n+    fn sflags(substs: &Substs) -> TypeFlags {\n+        let mut f = NO_TYPE_FLAGS;\n         let mut i = substs.types.iter();\n         for tt in i {\n-            f |= get(*tt).flags;\n+            f = f | get(*tt).flags;\n         }\n         match substs.regions {\n             subst::ErasedRegions => {}\n             subst::NonerasedRegions(ref regions) => {\n                 for r in regions.iter() {\n-                    f |= rflags(*r)\n+                    f = f | rflags(*r)\n                 }\n             }\n         }\n         return f;\n     }\n-    fn flags_for_bounds(bounds: &ExistentialBounds) -> uint {\n+    fn flags_for_bounds(bounds: &ExistentialBounds) -> TypeFlags {\n         rflags(bounds.region_bound)\n     }\n     match &st {\n@@ -1616,53 +1627,53 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       // But doing so caused sporadic memory corruption, and\n       // neither I (tjc) nor nmatsakis could figure out why,\n       // so we're doing it this way.\n-      &ty_bot => flags |= HAS_TY_BOT,\n-      &ty_err => flags |= HAS_TY_ERR,\n+      &ty_bot => flags = flags | HAS_TY_BOT,\n+      &ty_err => flags = flags | HAS_TY_ERR,\n       &ty_param(ref p) => {\n           if p.space == subst::SelfSpace {\n-              flags |= HAS_SELF;\n+              flags = flags | HAS_SELF;\n           } else {\n-              flags |= HAS_PARAMS;\n+              flags = flags | HAS_PARAMS;\n           }\n       }\n-      &ty_unboxed_closure(_, ref region) => flags |= rflags(*region),\n-      &ty_infer(_) => flags |= HAS_TY_INFER,\n+      &ty_unboxed_closure(_, ref region) => flags = flags | rflags(*region),\n+      &ty_infer(_) => flags = flags | HAS_TY_INFER,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n-          flags |= sflags(substs);\n+          flags = flags | sflags(substs);\n       }\n       &ty_trait(box TyTrait { ref substs, ref bounds, .. }) => {\n-          flags |= sflags(substs);\n-          flags |= flags_for_bounds(bounds);\n+          flags = flags | sflags(substs);\n+          flags = flags | flags_for_bounds(bounds);\n       }\n       &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n-        flags |= get(tt).flags\n+        flags = flags | get(tt).flags\n       }\n       &ty_ptr(ref m) => {\n-        flags |= get(m.ty).flags;\n+        flags = flags | get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n-        flags |= rflags(r);\n-        flags |= get(m.ty).flags;\n+        flags = flags | rflags(r);\n+        flags = flags | get(m.ty).flags;\n       }\n-      &ty_tup(ref ts) => for tt in ts.iter() { flags |= get(*tt).flags; },\n+      &ty_tup(ref ts) => for tt in ts.iter() { flags = flags | get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n-        for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n-        flags |= get(f.sig.output).flags;\n+        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n+        flags = flags | get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n-        flags &= !HAS_TY_BOT;\n+        flags = flags - HAS_TY_BOT;\n       }\n       &ty_closure(ref f) => {\n         match f.store {\n             RegionTraitStore(r, _) => {\n-                flags |= rflags(r);\n+                flags = flags | rflags(r);\n             }\n             _ => {}\n         }\n-        for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n-        flags |= get(f.sig.output).flags;\n+        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n+        flags = flags | get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n-        flags &= !HAS_TY_BOT;\n-        flags |= flags_for_bounds(&f.bounds);\n+        flags = flags - HAS_TY_BOT;\n+        flags = flags | flags_for_bounds(&f.bounds);\n       }\n     }\n \n@@ -1977,14 +1988,16 @@ impl ItemSubsts {\n \n // Type utilities\n \n-pub fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n+pub fn type_is_nil(ty: t) -> bool {\n+    get(ty).sty == ty_nil\n+}\n \n pub fn type_is_bot(ty: t) -> bool {\n-    (get(ty).flags & HAS_TY_BOT) != 0\n+    get(ty).flags.intersects(HAS_TY_BOT)\n }\n \n pub fn type_is_error(ty: t) -> bool {\n-    (get(ty).flags & HAS_TY_ERR) != 0\n+    get(ty).flags.intersects(HAS_TY_ERR)\n }\n \n pub fn type_needs_subst(ty: t) -> bool {"}]}