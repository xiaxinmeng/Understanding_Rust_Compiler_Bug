{"sha": "f3d1a53fa6ba7695df179c4b02491628e2b951aa", "node_id": "C_kwDOAAsO6NoAKGYzZDFhNTNmYTZiYTc2OTVkZjE3OWM0YjAyNDkxNjI4ZTJiOTUxYWE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-24T09:42:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-24T09:42:09Z"}, "message": "Merge #11772\n\n11772: Support constants in const eval r=HKalbasi a=HKalbasi\n\nThis PR enables evaluating things like this:\r\n```rust\r\nconst X: usize = 2;\r\nconst Y: usize = 3 + X; // = 5\r\n```\r\nMy target was nalgebra's `U5`, `U22`, ... which are defined as `type U5 = Const<{ SomeType5::SOME_ASSOC_CONST }>` but I didn't find out how to find the `ConstId` of the implementation of the trait, not the trait itself (possibly related to #4558 ? We can find associated type alias, so maybe this is doable already) So it doesn't help for nalgebra currently, but it is useful anyway.\r\n\n\nCo-authored-by: hkalbasi <hamidrezakalbasi@protonmail.com>", "tree": {"sha": "38ac0d6259d2c5b4546a276788527056a1d7f1fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38ac0d6259d2c5b4546a276788527056a1d7f1fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3d1a53fa6ba7695df179c4b02491628e2b951aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiPDzxCRBK7hj4Ov3rIwAAHXYIAIYXL5JZYwvbpbfNAojXSS3Z\nAzYUQSjxwHGtYwiUB/Y0bftt8zL639om8czCxMEskRmPDhMszrujIqS/Ce/NM1zW\nGCHgVJH4SbWrYLbwInT1aL/usbsvHoK78k/1DDmIjS3ukYRreQ6if/Y9HSUGO9C6\nC2un1oPBu2Sr0OELoS3O7SVI0OkCFEM3bmWoRUAM7UFy+6Tv4OE13GpWlkc/Sb79\nMfiSjURLKG3VKkAa5tMLZAu1b64XrUA3tNoYDk2Ne1/M5xHja+2kpyMQ1FjKMCNw\nOAnitysPUPJJfDQSV5GfGtBA9s0M9Iujlv9efWvHKDD5OuAgsY4d8TSgBvt+aHY=\n=cggu\n-----END PGP SIGNATURE-----\n", "payload": "tree 38ac0d6259d2c5b4546a276788527056a1d7f1fd\nparent b8e1d09b90fa2d7a0b4668c83ecf6f8dff8e62d8\nparent bf4a1e48427bf53f624e04a4f6a15f8ea16d1c99\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648114929 +0000\ncommitter GitHub <noreply@github.com> 1648114929 +0000\n\nMerge #11772\n\n11772: Support constants in const eval r=HKalbasi a=HKalbasi\n\nThis PR enables evaluating things like this:\r\n```rust\r\nconst X: usize = 2;\r\nconst Y: usize = 3 + X; // = 5\r\n```\r\nMy target was nalgebra's `U5`, `U22`, ... which are defined as `type U5 = Const<{ SomeType5::SOME_ASSOC_CONST }>` but I didn't find out how to find the `ConstId` of the implementation of the trait, not the trait itself (possibly related to #4558 ? We can find associated type alias, so maybe this is doable already) So it doesn't help for nalgebra currently, but it is useful anyway.\r\n\n\nCo-authored-by: hkalbasi <hamidrezakalbasi@protonmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d1a53fa6ba7695df179c4b02491628e2b951aa", "html_url": "https://github.com/rust-lang/rust/commit/f3d1a53fa6ba7695df179c4b02491628e2b951aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3d1a53fa6ba7695df179c4b02491628e2b951aa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8e1d09b90fa2d7a0b4668c83ecf6f8dff8e62d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e1d09b90fa2d7a0b4668c83ecf6f8dff8e62d8", "html_url": "https://github.com/rust-lang/rust/commit/b8e1d09b90fa2d7a0b4668c83ecf6f8dff8e62d8"}, {"sha": "bf4a1e48427bf53f624e04a4f6a15f8ea16d1c99", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4a1e48427bf53f624e04a4f6a15f8ea16d1c99", "html_url": "https://github.com/rust-lang/rust/commit/bf4a1e48427bf53f624e04a4f6a15f8ea16d1c99"}], "stats": {"total": 439, "additions": 298, "deletions": 141}, "files": [{"sha": "18de04b16da939a4355c17aea880a7c14d3c9fe7", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f3d1a53fa6ba7695df179c4b02491628e2b951aa", "patch": "@@ -32,7 +32,7 @@ pub mod symbols;\n \n mod display;\n \n-use std::{collections::HashMap, iter, ops::ControlFlow, sync::Arc};\n+use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n@@ -55,9 +55,7 @@ use hir_def::{\n use hir_expand::{name::name, MacroCallKind};\n use hir_ty::{\n     autoderef,\n-    consteval::{\n-        eval_const, unknown_const_as_generic, ComputedExpr, ConstEvalCtx, ConstEvalError, ConstExt,\n-    },\n+    consteval::{unknown_const_as_generic, ComputedExpr, ConstEvalError, ConstExt},\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n@@ -1602,20 +1600,7 @@ impl Const {\n     }\n \n     pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n-        let body = db.body(self.id.into());\n-        let root = &body.exprs[body.body_expr];\n-        let infer = db.infer_query(self.id.into());\n-        let infer = infer.as_ref();\n-        let result = eval_const(\n-            root,\n-            &mut ConstEvalCtx {\n-                exprs: &body.exprs,\n-                pats: &body.pats,\n-                local_data: HashMap::default(),\n-                infer: &mut |x| infer[x].clone(),\n-            },\n-        );\n-        result\n+        db.const_eval(self.id)\n     }\n }\n "}, {"sha": "009ea008fcbcb777d99262eff48f39b560690878", "filename": "crates/hir_ty/src/consteval.rs", "status": "modified", "additions": 118, "deletions": 44, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs?ref=f3d1a53fa6ba7695df179c4b02491628e2b951aa", "patch": "@@ -8,22 +8,19 @@ use std::{\n \n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData, IntTy, Scalar};\n use hir_def::{\n-    expr::{ArithOp, BinaryOp, Expr, Literal, Pat},\n+    expr::{ArithOp, BinaryOp, Expr, ExprId, Literal, Pat, PatId},\n     path::ModPath,\n-    resolver::{Resolver, ValueNs},\n+    resolver::{resolver_for_expr, ResolveValueResult, Resolver, ValueNs},\n     type_ref::ConstScalar,\n+    ConstId, DefWithBodyId,\n };\n-use hir_expand::name::Name;\n use la_arena::{Arena, Idx};\n use stdx::never;\n \n use crate::{\n-    db::HirDatabase,\n-    infer::{Expectation, InferenceContext},\n-    lower::ParamLoweringMode,\n-    to_placeholder_idx,\n-    utils::Generics,\n-    Const, ConstData, ConstValue, GenericArg, Interner, Ty, TyKind,\n+    db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode, to_placeholder_idx,\n+    utils::Generics, Const, ConstData, ConstValue, GenericArg, InferenceResult, Interner, Ty,\n+    TyKind,\n };\n \n /// Extension trait for [`Const`]\n@@ -55,21 +52,30 @@ impl ConstExt for Const {\n }\n \n pub struct ConstEvalCtx<'a> {\n+    pub db: &'a dyn HirDatabase,\n+    pub owner: DefWithBodyId,\n     pub exprs: &'a Arena<Expr>,\n     pub pats: &'a Arena<Pat>,\n-    pub local_data: HashMap<Name, ComputedExpr>,\n-    pub infer: &'a mut dyn FnMut(Idx<Expr>) -> Ty,\n+    pub local_data: HashMap<PatId, ComputedExpr>,\n+    infer: &'a InferenceResult,\n }\n \n-#[derive(Debug, Clone)]\n+impl ConstEvalCtx<'_> {\n+    fn expr_ty(&mut self, expr: ExprId) -> Ty {\n+        self.infer[expr].clone()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ConstEvalError {\n     NotSupported(&'static str),\n-    TypeError,\n+    SemanticError(&'static str),\n+    Loop,\n     IncompleteExpr,\n     Panic(String),\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ComputedExpr {\n     Literal(Literal),\n     Tuple(Box<[ComputedExpr]>),\n@@ -80,14 +86,14 @@ impl Display for ComputedExpr {\n         match self {\n             ComputedExpr::Literal(l) => match l {\n                 Literal::Int(x, _) => {\n-                    if *x >= 16 {\n+                    if *x >= 10 {\n                         write!(f, \"{} ({:#X})\", x, x)\n                     } else {\n                         x.fmt(f)\n                     }\n                 }\n                 Literal::Uint(x, _) => {\n-                    if *x >= 16 {\n+                    if *x >= 10 {\n                         write!(f, \"{} ({:#X})\", x, x)\n                     } else {\n                         x.fmt(f)\n@@ -143,12 +149,17 @@ fn is_valid(scalar: &Scalar, value: i128) -> bool {\n     }\n }\n \n-pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExpr, ConstEvalError> {\n+pub fn eval_const(\n+    expr_id: ExprId,\n+    ctx: &mut ConstEvalCtx<'_>,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    let expr = &ctx.exprs[expr_id];\n     match expr {\n+        Expr::Missing => Err(ConstEvalError::IncompleteExpr),\n         Expr::Literal(l) => Ok(ComputedExpr::Literal(l.clone())),\n         &Expr::UnaryOp { expr, op } => {\n-            let ty = &(ctx.infer)(expr);\n-            let ev = eval_const(&ctx.exprs[expr], ctx)?;\n+            let ty = &ctx.expr_ty(expr);\n+            let ev = eval_const(expr, ctx)?;\n             match op {\n                 hir_def::expr::UnaryOp::Deref => Err(ConstEvalError::NotSupported(\"deref\")),\n                 hir_def::expr::UnaryOp::Not => {\n@@ -203,9 +214,9 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n             }\n         }\n         &Expr::BinaryOp { lhs, rhs, op } => {\n-            let ty = &(ctx.infer)(lhs);\n-            let lhs = eval_const(&ctx.exprs[lhs], ctx)?;\n-            let rhs = eval_const(&ctx.exprs[rhs], ctx)?;\n+            let ty = &ctx.expr_ty(lhs);\n+            let lhs = eval_const(lhs, ctx)?;\n+            let rhs = eval_const(rhs, ctx)?;\n             let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n             let v1 = match lhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n@@ -249,31 +260,31 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n                     }\n                     Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n                 }\n-                BinaryOp::LogicOp(_) => Err(ConstEvalError::TypeError),\n+                BinaryOp::LogicOp(_) => Err(ConstEvalError::SemanticError(\"logic op on numbers\")),\n                 _ => Err(ConstEvalError::NotSupported(\"bin op on this operators\")),\n             }\n         }\n         Expr::Block { statements, tail, .. } => {\n-            let mut prev_values = HashMap::<Name, Option<ComputedExpr>>::default();\n+            let mut prev_values = HashMap::<PatId, Option<ComputedExpr>>::default();\n             for statement in &**statements {\n                 match *statement {\n-                    hir_def::expr::Statement::Let { pat, initializer, .. } => {\n-                        let pat = &ctx.pats[pat];\n-                        let name = match pat {\n-                            Pat::Bind { name, subpat, .. } if subpat.is_none() => name.clone(),\n+                    hir_def::expr::Statement::Let { pat: pat_id, initializer, .. } => {\n+                        let pat = &ctx.pats[pat_id];\n+                        match pat {\n+                            Pat::Bind { subpat, .. } if subpat.is_none() => (),\n                             _ => {\n                                 return Err(ConstEvalError::NotSupported(\"complex patterns in let\"))\n                             }\n                         };\n                         let value = match initializer {\n-                            Some(x) => eval_const(&ctx.exprs[x], ctx)?,\n+                            Some(x) => eval_const(x, ctx)?,\n                             None => continue,\n                         };\n-                        if !prev_values.contains_key(&name) {\n-                            let prev = ctx.local_data.insert(name.clone(), value);\n-                            prev_values.insert(name, prev);\n+                        if !prev_values.contains_key(&pat_id) {\n+                            let prev = ctx.local_data.insert(pat_id, value);\n+                            prev_values.insert(pat_id, prev);\n                         } else {\n-                            ctx.local_data.insert(name, value);\n+                            ctx.local_data.insert(pat_id, value);\n                         }\n                     }\n                     hir_def::expr::Statement::Expr { .. } => {\n@@ -282,7 +293,7 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n                 }\n             }\n             let r = match tail {\n-                &Some(x) => eval_const(&ctx.exprs[x], ctx),\n+                &Some(x) => eval_const(x, ctx),\n                 None => Ok(ComputedExpr::Tuple(Box::new([]))),\n             };\n             // clean up local data, so caller will receive the exact map that passed to us\n@@ -295,19 +306,48 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n             r\n         }\n         Expr::Path(p) => {\n-            let name = p.mod_path().as_ident().ok_or(ConstEvalError::NotSupported(\"big paths\"))?;\n-            let r = ctx\n-                .local_data\n-                .get(name)\n-                .ok_or(ConstEvalError::NotSupported(\"Non local name resolution\"))?;\n-            Ok(r.clone())\n+            let resolver = resolver_for_expr(ctx.db.upcast(), ctx.owner, expr_id);\n+            let pr = resolver\n+                .resolve_path_in_value_ns(ctx.db.upcast(), p.mod_path())\n+                .ok_or(ConstEvalError::SemanticError(\"unresolved path\"))?;\n+            let pr = match pr {\n+                ResolveValueResult::ValueNs(v) => v,\n+                ResolveValueResult::Partial(..) => {\n+                    return match ctx\n+                        .infer\n+                        .assoc_resolutions_for_expr(expr_id)\n+                        .ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n+                    {\n+                        hir_def::AssocItemId::FunctionId(_) => {\n+                            Err(ConstEvalError::NotSupported(\"assoc function\"))\n+                        }\n+                        hir_def::AssocItemId::ConstId(c) => ctx.db.const_eval(c),\n+                        hir_def::AssocItemId::TypeAliasId(_) => {\n+                            Err(ConstEvalError::NotSupported(\"assoc type alias\"))\n+                        }\n+                    }\n+                }\n+            };\n+            match pr {\n+                ValueNs::LocalBinding(pat_id) => {\n+                    let r = ctx\n+                        .local_data\n+                        .get(&pat_id)\n+                        .ok_or(ConstEvalError::NotSupported(\"Unexpected missing local\"))?;\n+                    Ok(r.clone())\n+                }\n+                ValueNs::ConstId(id) => ctx.db.const_eval(id),\n+                ValueNs::GenericParam(_) => {\n+                    Err(ConstEvalError::NotSupported(\"const generic without substitution\"))\n+                }\n+                _ => Err(ConstEvalError::NotSupported(\"path that are not const or local\")),\n+            }\n         }\n         _ => Err(ConstEvalError::NotSupported(\"This kind of expression\")),\n     }\n }\n \n pub fn eval_usize(expr: Idx<Expr>, mut ctx: ConstEvalCtx<'_>) -> Option<u64> {\n-    let expr = &ctx.exprs[expr];\n     if let Ok(ce) = eval_const(expr, &mut ctx) {\n         match ce {\n             ComputedExpr::Literal(Literal::Int(x, _)) => return x.try_into().ok(),\n@@ -380,10 +420,39 @@ pub fn usize_const(value: Option<u64>) -> Const {\n     .intern(Interner)\n }\n \n-pub(crate) fn eval_to_const(\n+pub(crate) fn const_eval_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &ConstId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    Err(ConstEvalError::Loop)\n+}\n+\n+pub(crate) fn const_eval_query(\n+    db: &dyn HirDatabase,\n+    const_id: ConstId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    let def = const_id.into();\n+    let body = db.body(def);\n+    let infer = &db.infer(def);\n+    let result = eval_const(\n+        body.body_expr,\n+        &mut ConstEvalCtx {\n+            db,\n+            owner: const_id.into(),\n+            exprs: &body.exprs,\n+            pats: &body.pats,\n+            local_data: HashMap::default(),\n+            infer,\n+        },\n+    );\n+    result\n+}\n+\n+pub(crate) fn eval_to_const<'a>(\n     expr: Idx<Expr>,\n     mode: ParamLoweringMode,\n-    ctx: &mut InferenceContext,\n+    ctx: &mut InferenceContext<'a>,\n     args: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Const {\n@@ -396,10 +465,15 @@ pub(crate) fn eval_to_const(\n     }\n     let body = ctx.body.clone();\n     let ctx = ConstEvalCtx {\n+        db: ctx.db,\n+        owner: ctx.owner,\n         exprs: &body.exprs,\n         pats: &body.pats,\n         local_data: HashMap::default(),\n-        infer: &mut |x| ctx.infer_expr(x, &Expectation::None),\n+        infer: &ctx.result,\n     };\n     usize_const(eval_usize(expr, ctx))\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "4a052851afd147b802f5fb12947ece83c967726a", "filename": "crates/hir_ty/src/consteval/tests.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=f3d1a53fa6ba7695df179c4b02491628e2b951aa", "patch": "@@ -0,0 +1,148 @@\n+use base_db::fixture::WithFixture;\n+use hir_def::{db::DefDatabase, expr::Literal};\n+\n+use crate::{consteval::ComputedExpr, db::HirDatabase, test_db::TestDB};\n+\n+use super::ConstEvalError;\n+\n+fn check_fail(ra_fixture: &str, error: ConstEvalError) {\n+    assert_eq!(eval_goal(ra_fixture), Err(error));\n+}\n+\n+fn check_number(ra_fixture: &str, answer: i128) {\n+    let r = eval_goal(ra_fixture).unwrap();\n+    match r {\n+        ComputedExpr::Literal(Literal::Int(r, _)) => assert_eq!(r, answer),\n+        ComputedExpr::Literal(Literal::Uint(r, _)) => assert_eq!(r, answer as u128),\n+        x => panic!(\"Expected number but found {:?}\", x),\n+    }\n+}\n+\n+fn eval_goal(ra_fixture: &str) -> Result<ComputedExpr, ConstEvalError> {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let module_id = db.module_for_file(file_id);\n+    let def_map = module_id.def_map(&db);\n+    let scope = &def_map[module_id.local_id].scope;\n+    let const_id = scope\n+        .declarations()\n+        .into_iter()\n+        .find_map(|x| match x {\n+            hir_def::ModuleDefId::ConstId(x) => {\n+                if db.const_data(x).name.as_ref()?.to_string() == \"GOAL\" {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        })\n+        .unwrap();\n+    db.const_eval(const_id)\n+}\n+\n+#[test]\n+fn add() {\n+    check_number(r#\"const GOAL: usize = 2 + 2;\"#, 4);\n+}\n+\n+#[test]\n+fn bit_op() {\n+    check_number(r#\"const GOAL: u8 = !0 & !(!0 >> 1)\"#, 128);\n+    check_number(r#\"const GOAL: i8 = !0 & !(!0 >> 1)\"#, 0);\n+    // FIXME: rustc evaluate this to -128\n+    check_fail(\n+        r#\"const GOAL: i8 = 1 << 7\"#,\n+        ConstEvalError::Panic(\"attempt to run invalid arithmetic operation\".to_string()),\n+    );\n+    check_fail(\n+        r#\"const GOAL: i8 = 1 << 8\"#,\n+        ConstEvalError::Panic(\"attempt to run invalid arithmetic operation\".to_string()),\n+    );\n+}\n+\n+#[test]\n+fn locals() {\n+    check_number(\n+        r#\"\n+    const GOAL: usize = {\n+        let a = 3 + 2;\n+        let b = a * a;\n+        b\n+    };\n+    \"#,\n+        25,\n+    );\n+}\n+\n+#[test]\n+fn consts() {\n+    check_number(\n+        r#\"\n+    const F1: i32 = 1;\n+    const F3: i32 = 3 * F2;\n+    const F2: i32 = 2 * F1;\n+    const GOAL: i32 = F3;\n+    \"#,\n+        6,\n+    );\n+}\n+\n+#[test]\n+fn const_loop() {\n+    check_fail(\n+        r#\"\n+    const F1: i32 = 1 * F3;\n+    const F3: i32 = 3 * F2;\n+    const F2: i32 = 2 * F1;\n+    const GOAL: i32 = F3;\n+    \"#,\n+        ConstEvalError::Loop,\n+    );\n+}\n+\n+#[test]\n+fn const_impl_assoc() {\n+    check_number(\n+        r#\"\n+    struct U5;\n+    impl U5 {\n+        const VAL: usize = 5;\n+    }\n+    const GOAL: usize = U5::VAL;\n+    \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn const_generic_subst() {\n+    // FIXME: this should evaluate to 5\n+    check_fail(\n+        r#\"\n+    struct Adder<const N: usize, const M: usize>;\n+    impl<const N: usize, const M: usize> Adder<N, M> {\n+        const VAL: usize = N + M;\n+    }\n+    const GOAL: usize = Adder::<2, 3>::VAL;\n+    \"#,\n+        ConstEvalError::NotSupported(\"const generic without substitution\"),\n+    );\n+}\n+\n+#[test]\n+fn const_trait_assoc() {\n+    // FIXME: this should evaluate to 0\n+    check_fail(\n+        r#\"\n+    struct U0;\n+    trait ToConst {\n+        const VAL: usize;\n+    }\n+    impl ToConst for U0 {\n+        const VAL: usize = 0;\n+    }\n+    const GOAL: usize = U0::VAL;\n+    \"#,\n+        ConstEvalError::IncompleteExpr,\n+    );\n+}"}, {"sha": "467dcfa33ea757f1e2695a75fbf7c381f3fd81c9", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=f3d1a53fa6ba7695df179c4b02491628e2b951aa", "patch": "@@ -5,13 +5,14 @@ use std::sync::Arc;\n \n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, expr::ExprId, BlockId, ConstParamId, DefWithBodyId, FunctionId, GenericDefId,\n-    ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n+    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, FunctionId,\n+    GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n \n use crate::{\n     chalk_db,\n+    consteval::{ComputedExpr, ConstEvalError},\n     method_resolution::{InherentImpls, TraitImpls},\n     Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n     QuantifiedWhereClause, ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n@@ -41,6 +42,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::const_param_ty_query)]\n     fn const_param_ty(&self, def: ConstParamId) -> Ty;\n \n+    #[salsa::invoke(crate::consteval::const_eval_query)]\n+    #[salsa::cycle(crate::consteval::const_eval_recover)]\n+    fn const_eval(&self, def: ConstId) -> Result<ComputedExpr, ConstEvalError>;\n+\n     #[salsa::invoke(crate::lower::impl_trait_query)]\n     fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;\n "}, {"sha": "9a6795a1c883695a2ea7246949a829c3166ebced", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=f3d1a53fa6ba7695df179c4b02491628e2b951aa", "patch": "@@ -358,12 +358,12 @@ impl Index<PatId> for InferenceResult {\n #[derive(Clone, Debug)]\n pub(crate) struct InferenceContext<'a> {\n     pub(crate) db: &'a dyn HirDatabase,\n-    owner: DefWithBodyId,\n+    pub(crate) owner: DefWithBodyId,\n     pub(crate) body: Arc<Body>,\n     pub(crate) resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n-    result: InferenceResult,\n+    pub(crate) result: InferenceResult,\n     /// The return type of the function being inferred, the closure or async block if we're\n     /// currently within one.\n     ///"}, {"sha": "675f9038f0961f616f63d33293fb7dd00d7efb9b", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=f3d1a53fa6ba7695df179c4b02491628e2b951aa", "patch": "@@ -1749,6 +1749,18 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn const_eval_array_repeat_expr() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    const X: usize = 6 - 1;\n+    let t = [(); X + 2];\n+      //^ [(); 7]\n+}\"#,\n+    );\n+}\n+\n #[test]\n fn shadowing_primitive_with_inner_items() {\n     check_types("}, {"sha": "67dc9884ed33793c6caf84a0b3185335196a7cb8", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 8, "deletions": 75, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d1a53fa6ba7695df179c4b02491628e2b951aa/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=f3d1a53fa6ba7695df179c4b02491628e2b951aa", "patch": "@@ -3401,10 +3401,11 @@ impl<const LEN: usize> Foo<LEN$0> {}\n \n #[test]\n fn hover_const_eval() {\n+    // show hex for <10\n     check(\n         r#\"\n /// This is a doc\n-const FOO$0: usize = !0 & !(!0 >> 1);\n+const FOO$0: usize = 1 << 3;\n \"#,\n         expect![[r#\"\n             *FOO*\n@@ -3414,22 +3415,19 @@ const FOO$0: usize = !0 & !(!0 >> 1);\n             ```\n \n             ```rust\n-            const FOO: usize = 9223372036854775808 (0x8000000000000000)\n+            const FOO: usize = 8\n             ```\n \n             ---\n \n             This is a doc\n         \"#]],\n     );\n+    // show hex for >10\n     check(\n         r#\"\n /// This is a doc\n-const FOO$0: usize = {\n-    let a = 3 + 2;\n-    let b = a * a;\n-    b\n-};\n+const FOO$0: usize = (1 << 3) + (1 << 2);\n \"#,\n         expect![[r#\"\n             *FOO*\n@@ -3439,60 +3437,15 @@ const FOO$0: usize = {\n             ```\n \n             ```rust\n-            const FOO: usize = 25 (0x19)\n-            ```\n-\n-            ---\n-\n-            This is a doc\n-        \"#]],\n-    );\n-    check(\n-        r#\"\n-/// This is a doc\n-const FOO$0: usize = 1 << 10;\n-\"#,\n-        expect![[r#\"\n-            *FOO*\n-\n-            ```rust\n-            test\n-            ```\n-\n-            ```rust\n-            const FOO: usize = 1024 (0x400)\n-            ```\n-\n-            ---\n-\n-            This is a doc\n-        \"#]],\n-    );\n-    check(\n-        r#\"\n-/// This is a doc\n-const FOO$0: usize = {\n-    let b = 4;\n-    let a = { let b = 2; let a = b; a } + { let a = 1; a + b };\n-    a\n-};\n-\"#,\n-        expect![[r#\"\n-            *FOO*\n-\n-            ```rust\n-            test\n-            ```\n-\n-            ```rust\n-            const FOO: usize = 7\n+            const FOO: usize = 12 (0xC)\n             ```\n \n             ---\n \n             This is a doc\n         \"#]],\n     );\n+    // show original body when const eval fails\n     check(\n         r#\"\n /// This is a doc\n@@ -3514,6 +3467,7 @@ const FOO$0: usize = 2 - 3;\n             This is a doc\n         \"#]],\n     );\n+    // don't show hex for negatives\n     check(\n         r#\"\n /// This is a doc\n@@ -3538,27 +3492,6 @@ const FOO$0: i32 = 2 - 3;\n     check(\n         r#\"\n /// This is a doc\n-const FOO$0: usize = 1 << 100;\n-\"#,\n-        expect![[r#\"\n-            *FOO*\n-\n-            ```rust\n-            test\n-            ```\n-\n-            ```rust\n-            const FOO: usize = 1 << 100\n-            ```\n-\n-            ---\n-\n-            This is a doc\n-        \"#]],\n-    );\n-    check(\n-        r#\"\n-/// This is a doc\n const FOO$0: &str = \"bar\";\n \"#,\n         expect![[r#\""}]}