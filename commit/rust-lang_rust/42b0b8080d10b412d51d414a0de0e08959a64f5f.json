{"sha": "42b0b8080d10b412d51d414a0de0e08959a64f5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYjBiODA4MGQxMGI0MTJkNTFkNDE0YTBkZTBlMDg5NTlhNjRmNWY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-11-14T13:29:40Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-11-21T18:22:30Z"}, "message": "Replace ByVal attribute with on_stack field for Indirect\n\nThis makes it clearer that only PassMode::Indirect allows ByVal", "tree": {"sha": "619ece353280d2e0eb5931b3ca23c674f92309f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/619ece353280d2e0eb5931b3ca23c674f92309f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42b0b8080d10b412d51d414a0de0e08959a64f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42b0b8080d10b412d51d414a0de0e08959a64f5f", "html_url": "https://github.com/rust-lang/rust/commit/42b0b8080d10b412d51d414a0de0e08959a64f5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42b0b8080d10b412d51d414a0de0e08959a64f5f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "967a228208a88791c66a4ee3ee72cc75fa2b7fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/967a228208a88791c66a4ee3ee72cc75fa2b7fbc", "html_url": "https://github.com/rust-lang/rust/commit/967a228208a88791c66a4ee3ee72cc75fa2b7fbc"}], "stats": {"total": 159, "additions": 102, "deletions": 57}, "files": [{"sha": "e988fdb9d5c5372c9e7a51a14eb549a0cb8568b1", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=42b0b8080d10b412d51d414a0de0e08959a64f5f", "patch": "@@ -41,12 +41,12 @@ impl ArgAttributeExt for ArgAttribute {\n }\n \n pub trait ArgAttributesExt {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value, ty: Option<&Type>);\n-    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value, ty: Option<&Type>);\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value);\n+    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value);\n }\n \n impl ArgAttributesExt for ArgAttributes {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value, ty: Option<&Type>) {\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -61,9 +61,6 @@ impl ArgAttributesExt for ArgAttributes {\n             if let Some(align) = self.pointee_align {\n                 llvm::LLVMRustAddAlignmentAttr(llfn, idx.as_uint(), align.bytes() as u32);\n             }\n-            if regular.contains(ArgAttribute::ByVal) {\n-                llvm::LLVMRustAddByValAttr(llfn, idx.as_uint(), ty.unwrap());\n-            }\n             regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n             match self.arg_ext {\n                 ArgExtension::None => {}\n@@ -77,7 +74,7 @@ impl ArgAttributesExt for ArgAttributes {\n         }\n     }\n \n-    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value, ty: Option<&Type>) {\n+    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -100,9 +97,6 @@ impl ArgAttributesExt for ArgAttributes {\n                     align.bytes() as u32,\n                 );\n             }\n-            if regular.contains(ArgAttribute::ByVal) {\n-                llvm::LLVMRustAddByValCallSiteAttr(callsite, idx.as_uint(), ty.unwrap());\n-            }\n             regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n             match self.arg_ext {\n                 ArgExtension::None => {}\n@@ -285,10 +279,12 @@ impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n-            PassMode::Indirect(_, Some(_)) => {\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             }\n-            PassMode::Direct(_) | PassMode::Indirect(_, None) | PassMode::Cast(_) => {\n+            PassMode::Direct(_)\n+            | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ }\n+            | PassMode::Cast(_) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             }\n@@ -333,14 +329,14 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n         ).sum();\n         let mut llargument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect(..) = self.ret.mode { 1 } else { 0 } + args_capacity,\n+            if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 } + args_capacity,\n         );\n \n         let llreturn_ty = match self.ret.mode {\n             PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_llvm_type(cx),\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n-            PassMode::Indirect(..) => {\n+            PassMode::Indirect { .. } => {\n                 llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                 cx.type_void()\n             }\n@@ -360,15 +356,17 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n-                PassMode::Indirect(_, Some(_)) => {\n+                PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n                     let ptr_ty = cx.tcx.mk_mut_ptr(arg.layout.ty);\n                     let ptr_layout = cx.layout_of(ptr_ty);\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 0, true));\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_, None) => cx.type_ptr_to(arg.memory_ty(cx)),\n+                PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+                    cx.type_ptr_to(arg.memory_ty(cx))\n+                }\n             };\n             llargument_tys.push(llarg_ty);\n         }\n@@ -420,35 +418,53 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n \n         let mut i = 0;\n-        let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n-            attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn, ty);\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_attrs_to_llfn(llvm::AttributePlace::Argument(i), llfn);\n             i += 1;\n+            i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_llfn(llvm::AttributePlace::ReturnValue, llfn, None);\n+                attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, llfn);\n+            }\n+            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+                assert!(!on_stack);\n+                apply(attrs);\n             }\n-            PassMode::Indirect(ref attrs, _) => apply(attrs, Some(self.ret.layout.llvm_type(cx))),\n             _ => {}\n         }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n-                apply(&ArgAttributes::new(), None);\n+                apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Direct(ref attrs) | PassMode::Indirect(ref attrs, None) => {\n-                    apply(attrs, Some(arg.layout.llvm_type(cx)))\n+                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                    let i = apply(attrs);\n+                    unsafe {\n+                        llvm::LLVMRustAddByValAttr(\n+                            llfn,\n+                            llvm::AttributePlace::Argument(i).as_uint(),\n+                            arg.layout.llvm_type(cx),\n+                        );\n+                    }\n+                }\n+                PassMode::Direct(ref attrs)\n+                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                    apply(attrs);\n                 }\n-                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n-                    apply(attrs, None);\n-                    apply(extra_attrs, None);\n+                PassMode::Indirect { ref attrs, extra_attrs: Some(ref extra_attrs), on_stack } => {\n+                    assert!(!on_stack);\n+                    apply(attrs);\n+                    apply(extra_attrs);\n                 }\n                 PassMode::Pair(ref a, ref b) => {\n-                    apply(a, None);\n-                    apply(b, None);\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => {\n+                    apply(&ArgAttributes::new());\n                 }\n-                PassMode::Cast(_) => apply(&ArgAttributes::new(), None),\n             }\n         }\n     }\n@@ -457,15 +473,19 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         // FIXME(wesleywiser, eddyb): We should apply `nounwind` and `noreturn` as appropriate to this callsite.\n \n         let mut i = 0;\n-        let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n-            attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite, ty);\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_attrs_to_callsite(llvm::AttributePlace::Argument(i), callsite);\n             i += 1;\n+            i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_callsite(llvm::AttributePlace::ReturnValue, callsite, None);\n+                attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, callsite);\n+            }\n+            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+                assert!(!on_stack);\n+                apply(attrs);\n             }\n-            PassMode::Indirect(ref attrs, _) => apply(attrs, Some(self.ret.layout.llvm_type(bx))),\n             _ => {}\n         }\n         if let abi::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n@@ -483,22 +503,39 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n-                apply(&ArgAttributes::new(), None);\n+                apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Direct(ref attrs) | PassMode::Indirect(ref attrs, None) => {\n-                    apply(attrs, Some(arg.layout.llvm_type(bx)))\n+                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                    let i = apply(attrs);\n+                    unsafe {\n+                        llvm::LLVMRustAddByValCallSiteAttr(\n+                            callsite,\n+                            llvm::AttributePlace::Argument(i).as_uint(),\n+                            arg.layout.llvm_type(bx),\n+                        );\n+                    }\n                 }\n-                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n-                    apply(attrs, None);\n-                    apply(extra_attrs, None);\n+                PassMode::Direct(ref attrs)\n+                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                    apply(attrs);\n+                }\n+                PassMode::Indirect {\n+                    ref attrs,\n+                    extra_attrs: Some(ref extra_attrs),\n+                    on_stack: _,\n+                } => {\n+                    apply(attrs);\n+                    apply(extra_attrs);\n                 }\n                 PassMode::Pair(ref a, ref b) => {\n-                    apply(a, None);\n-                    apply(b, None);\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => {\n+                    apply(&ArgAttributes::new());\n                 }\n-                PassMode::Cast(_) => apply(&ArgAttributes::new(), None),\n             }\n         }\n "}, {"sha": "fd20709f5d80f67ef96ac901725ee362c67bc594", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=42b0b8080d10b412d51d414a0de0e08959a64f5f", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n         let llval = match self.fn_abi.ret.mode {\n-            PassMode::Ignore | PassMode::Indirect(..) => {\n+            PassMode::Ignore | PassMode::Indirect { .. } => {\n                 bx.ret_void();\n                 return;\n             }\n@@ -1101,7 +1101,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => match arg.mode {\n-                PassMode::Indirect(..) | PassMode::Cast(_) => {\n+                PassMode::Indirect { .. } | PassMode::Cast(_) => {\n                     let scratch = PlaceRef::alloca(bx, arg.layout);\n                     op.val.store(bx, scratch);\n                     (scratch.llval, scratch.align, true)"}, {"sha": "24d2ee6ec34a7dbc87c79f5bfea0db7bb7ef1dc1", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=42b0b8080d10b412d51d414a0de0e08959a64f5f", "patch": "@@ -2801,7 +2801,8 @@ where\n             for arg in &mut self.args {\n                 fixup(arg, false);\n             }\n-            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n+            if let PassMode::Indirect { ref mut attrs, extra_attrs: _, on_stack: _ } = self.ret.mode\n+            {\n                 attrs.set(ArgAttribute::StructRet);\n             }\n             return;"}, {"sha": "0931e8a37714d7f1ab018f871bdd6d58954c7dfb", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=42b0b8080d10b412d51d414a0de0e08959a64f5f", "patch": "@@ -36,9 +36,12 @@ pub enum PassMode {\n     /// a single uniform or a pair of registers.\n     Cast(CastTarget),\n     /// Pass the argument indirectly via a hidden pointer.\n-    /// The second value, if any, is for the extra data (vtable or length)\n+    /// The `extra_attrs` value, if any, is for the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n-    Indirect(ArgAttributes, Option<ArgAttributes>),\n+    /// `on_stack` defines that the the value should be passed at a fixed\n+    /// stack offset in accordance to the ABI rather than passed using a\n+    /// pointer. This corresponds to the `byval` LLVM argument attribute.\n+    Indirect { attrs: ArgAttributes, extra_attrs: Option<ArgAttributes>, on_stack: bool },\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -52,7 +55,6 @@ mod attr_impl {\n     bitflags::bitflags! {\n         #[derive(Default)]\n         pub struct ArgAttribute: u16 {\n-            const ByVal     = 1 << 0;\n             const NoAlias   = 1 << 1;\n             const NoCapture = 1 << 2;\n             const NonNull   = 1 << 3;\n@@ -460,14 +462,14 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n \n         let extra_attrs = self.layout.is_unsized().then_some(ArgAttributes::new());\n \n-        self.mode = PassMode::Indirect(attrs, extra_attrs);\n+        self.mode = PassMode::Indirect { attrs, extra_attrs, on_stack: false };\n     }\n \n     pub fn make_indirect_byval(&mut self) {\n         self.make_indirect();\n         match self.mode {\n-            PassMode::Indirect(ref mut attrs, _) => {\n-                attrs.set(ArgAttribute::ByVal);\n+            PassMode::Indirect { attrs: _, extra_attrs: _, ref mut on_stack } => {\n+                *on_stack = true;\n             }\n             _ => unreachable!(),\n         }\n@@ -500,15 +502,15 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn is_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(..))\n+        matches!(self.mode, PassMode::Indirect {..})\n     }\n \n     pub fn is_sized_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(_, None))\n+        matches!(self.mode, PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ })\n     }\n \n     pub fn is_unsized_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(_, Some(_)))\n+        matches!(self.mode, PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ })\n     }\n \n     pub fn is_ignore(&self) -> bool {\n@@ -617,7 +619,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)),\n         }\n \n-        if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n+        if let PassMode::Indirect { ref mut attrs, extra_attrs: _, on_stack: _ } = self.ret.mode {\n             attrs.set(ArgAttribute::StructRet);\n         }\n "}, {"sha": "713b4100a33351472f8a1abfc739588956617021", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b8080d10b412d51d414a0de0e08959a64f5f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=42b0b8080d10b412d51d414a0de0e08959a64f5f", "patch": "@@ -92,9 +92,14 @@ where\n \n         for arg in &mut fn_abi.args {\n             let attrs = match arg.mode {\n-                PassMode::Ignore | PassMode::Indirect(_, None) => continue,\n+                PassMode::Ignore\n+                | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+                    continue;\n+                }\n                 PassMode::Direct(ref mut attrs) => attrs,\n-                PassMode::Pair(..) | PassMode::Indirect(_, Some(_)) | PassMode::Cast(_) => {\n+                PassMode::Pair(..)\n+                | PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ }\n+                | PassMode::Cast(_) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }\n             };"}]}