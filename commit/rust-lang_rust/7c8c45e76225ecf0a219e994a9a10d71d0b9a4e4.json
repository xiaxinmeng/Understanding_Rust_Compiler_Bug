{"sha": "7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjOGM0NWU3NjIyNWVjZjBhMjE5ZTk5NGE5YTEwZDcxZDBiOWE0ZTQ=", "commit": {"author": {"name": "Son", "email": "leson.phung@gmail.com", "date": "2017-02-06T10:38:47Z"}, "committer": {"name": "Son", "email": "leson.phung@gmail.com", "date": "2017-02-06T10:38:47Z"}, "message": "Extract collections benchmarks to libcollections/benches\nAnd libcore/benches", "tree": {"sha": "6cd10bee45b84d1927d9f3b0532e6b7db0a039a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cd10bee45b84d1927d9f3b0532e6b7db0a039a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "html_url": "https://github.com/rust-lang/rust/commit/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/comments", "author": {"login": "phungleson", "id": 93457, "node_id": "MDQ6VXNlcjkzNDU3", "avatar_url": "https://avatars.githubusercontent.com/u/93457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phungleson", "html_url": "https://github.com/phungleson", "followers_url": "https://api.github.com/users/phungleson/followers", "following_url": "https://api.github.com/users/phungleson/following{/other_user}", "gists_url": "https://api.github.com/users/phungleson/gists{/gist_id}", "starred_url": "https://api.github.com/users/phungleson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phungleson/subscriptions", "organizations_url": "https://api.github.com/users/phungleson/orgs", "repos_url": "https://api.github.com/users/phungleson/repos", "events_url": "https://api.github.com/users/phungleson/events{/privacy}", "received_events_url": "https://api.github.com/users/phungleson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phungleson", "id": 93457, "node_id": "MDQ6VXNlcjkzNDU3", "avatar_url": "https://avatars.githubusercontent.com/u/93457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phungleson", "html_url": "https://github.com/phungleson", "followers_url": "https://api.github.com/users/phungleson/followers", "following_url": "https://api.github.com/users/phungleson/following{/other_user}", "gists_url": "https://api.github.com/users/phungleson/gists{/gist_id}", "starred_url": "https://api.github.com/users/phungleson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phungleson/subscriptions", "organizations_url": "https://api.github.com/users/phungleson/orgs", "repos_url": "https://api.github.com/users/phungleson/repos", "events_url": "https://api.github.com/users/phungleson/events{/privacy}", "received_events_url": "https://api.github.com/users/phungleson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4711ac314c3380f992e218879b7c94b26ba4102b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4711ac314c3380f992e218879b7c94b26ba4102b", "html_url": "https://github.com/rust-lang/rust/commit/4711ac314c3380f992e218879b7c94b26ba4102b"}], "stats": {"total": 2814, "additions": 1442, "deletions": 1372}, "files": [{"sha": "02b2171a224d0ae2b0111a5445f83b54fc88c9c3", "filename": "src/libcollections/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -16,7 +16,6 @@ std_unicode = { path = \"../libstd_unicode\" }\n name = \"collectionstest\"\n path = \"../libcollectionstest/lib.rs\"\n \n-# FIXME: need to extract benchmarks to separate crate\n-#[[bench]]\n-#name = \"collectionstest\"\n-#path = \"../libcollectionstest/lib.rs\"\n+[[bench]]\n+name = \"collectionsbenches\"\n+path = \"../libcollections/benches/lib.rs\""}, {"sha": "744afb991b00e99ebf4eff3cc8c7836796d6139c", "filename": "src/libcollections/benches/btree/map.rs", "status": "renamed", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fbtree%2Fmap.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n+use std::iter::Iterator;\n+use std::vec::Vec;\n+use std::collections::BTreeMap;\n+use std::__rand::{Rng, thread_rng};\n+use test::{Bencher, black_box};\n+\n macro_rules! map_insert_rand_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use std::__rand::{thread_rng, Rng};\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let n: usize = $n;\n             let mut map = $map::new();\n             // setup\n@@ -39,9 +43,7 @@ macro_rules! map_insert_rand_bench {\n macro_rules! map_insert_seq_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n             let n: usize = $n;\n             // setup\n@@ -64,12 +66,7 @@ macro_rules! map_insert_seq_bench {\n macro_rules! map_find_rand_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use std::iter::Iterator;\n-            use std::__rand::{thread_rng, Rng};\n-            use std::vec::Vec;\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n             let n: usize = $n;\n \n@@ -97,9 +94,7 @@ macro_rules! map_find_rand_bench {\n macro_rules! map_find_seq_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n-        pub fn $name(b: &mut ::test::Bencher) {\n-            use test::black_box;\n-\n+        pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n             let n: usize = $n;\n \n@@ -118,3 +113,45 @@ macro_rules! map_find_seq_bench {\n         }\n     )\n }\n+\n+map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n+map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n+\n+map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n+map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n+\n+map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n+map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n+\n+map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n+map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n+\n+fn bench_iter(b: &mut Bencher, size: i32) {\n+    let mut map = BTreeMap::<i32, i32>::new();\n+    let mut rng = thread_rng();\n+\n+    for _ in 0..size {\n+        map.insert(rng.gen(), rng.gen());\n+    }\n+\n+    b.iter(|| {\n+        for entry in &map {\n+            black_box(entry);\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn iter_20(b: &mut Bencher) {\n+    bench_iter(b, 20);\n+}\n+\n+#[bench]\n+pub fn iter_1000(b: &mut Bencher) {\n+    bench_iter(b, 1000);\n+}\n+\n+#[bench]\n+pub fn iter_100000(b: &mut Bencher) {\n+    bench_iter(b, 100000);\n+}", "previous_filename": "src/libcollectionstest/bench.rs"}, {"sha": "f436b0ac0c0375063da64723236781c25f628b41", "filename": "src/libcollections/benches/btree/mod.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fbtree%2Fmod.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod map;"}, {"sha": "1a21db5e344e3556e232eda8a5e89a588440e2fd", "filename": "src/libcollections/benches/lib.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Flib.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+\n+#![feature(rand)]\n+#![feature(test)]\n+\n+extern crate test;\n+\n+mod btree;\n+mod linked_list;\n+mod string;\n+mod str;\n+mod slice;\n+mod vec;\n+mod vec_deque;"}, {"sha": "bbac44553f18a267bfd7b016a3677d5e3e77ede5", "filename": "src/libcollections/benches/linked_list.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Flinked_list.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::LinkedList;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_collect_into(b: &mut Bencher) {\n+    let v = &[0; 64];\n+    b.iter(|| {\n+        let _: LinkedList<_> = v.iter().cloned().collect();\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_front(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_front(0);\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_back(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_back(0);\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_back_pop_back(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_back(0);\n+        m.pop_back();\n+    })\n+}\n+\n+#[bench]\n+fn bench_push_front_pop_front(b: &mut Bencher) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    b.iter(|| {\n+        m.push_front(0);\n+        m.pop_front();\n+    })\n+}\n+\n+#[bench]\n+fn bench_iter(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_mut(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let mut m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter_mut().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_rev(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter().rev().count() == 128);\n+    })\n+}\n+#[bench]\n+fn bench_iter_mut_rev(b: &mut Bencher) {\n+    let v = &[0; 128];\n+    let mut m: LinkedList<_> = v.iter().cloned().collect();\n+    b.iter(|| {\n+        assert!(m.iter_mut().rev().count() == 128);\n+    })\n+}"}, {"sha": "eb4b76509f913693d45627b0e21aa5d1ea094ad2", "filename": "src/libcollections/benches/slice.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fslice.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,280 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{mem, ptr};\n+use std::__rand::{Rng, thread_rng};\n+\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn iterator(b: &mut Bencher) {\n+    // peculiar numbers to stop LLVM from optimising the summation\n+    // out.\n+    let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for x in &v {\n+            sum += *x;\n+        }\n+        // sum == 11806, to stop dead code elimination.\n+        if sum == 0 {\n+            panic!()\n+        }\n+    })\n+}\n+\n+#[bench]\n+fn mut_iterator(b: &mut Bencher) {\n+    let mut v = vec![0; 100];\n+\n+    b.iter(|| {\n+        let mut i = 0;\n+        for x in &mut v {\n+            *x = i;\n+            i += 1;\n+        }\n+    })\n+}\n+\n+#[bench]\n+fn concat(b: &mut Bencher) {\n+    let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n+    b.iter(|| {\n+        xss.concat();\n+    });\n+}\n+\n+#[bench]\n+fn join(b: &mut Bencher) {\n+    let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n+    b.iter(|| xss.join(&0));\n+}\n+\n+#[bench]\n+fn push(b: &mut Bencher) {\n+    let mut vec = Vec::<i32>::new();\n+    b.iter(|| {\n+        vec.push(0);\n+        black_box(&vec);\n+    });\n+}\n+\n+#[bench]\n+fn starts_with_same_vector(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    b.iter(|| vec.starts_with(&vec))\n+}\n+\n+#[bench]\n+fn starts_with_single_element(b: &mut Bencher) {\n+    let vec: Vec<_> = vec![0];\n+    b.iter(|| vec.starts_with(&vec))\n+}\n+\n+#[bench]\n+fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    let mut match_vec: Vec<_> = (0..99).collect();\n+    match_vec.push(0);\n+    b.iter(|| vec.starts_with(&match_vec))\n+}\n+\n+#[bench]\n+fn ends_with_same_vector(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    b.iter(|| vec.ends_with(&vec))\n+}\n+\n+#[bench]\n+fn ends_with_single_element(b: &mut Bencher) {\n+    let vec: Vec<_> = vec![0];\n+    b.iter(|| vec.ends_with(&vec))\n+}\n+\n+#[bench]\n+fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    let mut match_vec: Vec<_> = (0..100).collect();\n+    match_vec[0] = 200;\n+    b.iter(|| vec.starts_with(&match_vec))\n+}\n+\n+#[bench]\n+fn contains_last_element(b: &mut Bencher) {\n+    let vec: Vec<_> = (0..100).collect();\n+    b.iter(|| vec.contains(&99))\n+}\n+\n+#[bench]\n+fn zero_1kb_from_elem(b: &mut Bencher) {\n+    b.iter(|| vec![0u8; 1024]);\n+}\n+\n+#[bench]\n+fn zero_1kb_set_memory(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut v = Vec::<u8>::with_capacity(1024);\n+        unsafe {\n+            let vp = v.as_mut_ptr();\n+            ptr::write_bytes(vp, 0, 1024);\n+            v.set_len(1024);\n+        }\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn zero_1kb_loop_set(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut v = Vec::<u8>::with_capacity(1024);\n+        unsafe {\n+            v.set_len(1024);\n+        }\n+        for i in 0..1024 {\n+            v[i] = 0;\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn zero_1kb_mut_iter(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut v = Vec::<u8>::with_capacity(1024);\n+        unsafe {\n+            v.set_len(1024);\n+        }\n+        for x in &mut v {\n+            *x = 0;\n+        }\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn random_inserts(b: &mut Bencher) {\n+    let mut rng = thread_rng();\n+    b.iter(|| {\n+        let mut v = vec![(0, 0); 30];\n+        for _ in 0..100 {\n+            let l = v.len();\n+            v.insert(rng.gen::<usize>() % (l + 1), (1, 1));\n+        }\n+    })\n+}\n+#[bench]\n+fn random_removes(b: &mut Bencher) {\n+    let mut rng = thread_rng();\n+    b.iter(|| {\n+        let mut v = vec![(0, 0); 130];\n+        for _ in 0..100 {\n+            let l = v.len();\n+            v.remove(rng.gen::<usize>() % l);\n+        }\n+    })\n+}\n+\n+fn gen_ascending(len: usize) -> Vec<u64> {\n+    (0..len as u64).collect()\n+}\n+\n+fn gen_descending(len: usize) -> Vec<u64> {\n+    (0..len as u64).rev().collect()\n+}\n+\n+fn gen_random(len: usize) -> Vec<u64> {\n+    let mut rng = thread_rng();\n+    rng.gen_iter::<u64>().take(len).collect()\n+}\n+\n+fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n+    let mut rng = thread_rng();\n+    let mut v = gen_ascending(len);\n+    for _ in (0usize..).take_while(|x| x * x <= len) {\n+        let x = rng.gen::<usize>() % len;\n+        let y = rng.gen::<usize>() % len;\n+        v.swap(x, y);\n+    }\n+    v\n+}\n+\n+fn gen_mostly_descending(len: usize) -> Vec<u64> {\n+    let mut rng = thread_rng();\n+    let mut v = gen_descending(len);\n+    for _ in (0usize..).take_while(|x| x * x <= len) {\n+        let x = rng.gen::<usize>() % len;\n+        let y = rng.gen::<usize>() % len;\n+        v.swap(x, y);\n+    }\n+    v\n+}\n+\n+fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n+    let mut rng = thread_rng();\n+    rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n+}\n+\n+fn gen_big_ascending(len: usize) -> Vec<[u64; 16]> {\n+    (0..len as u64).map(|x| [x; 16]).take(len).collect()\n+}\n+\n+fn gen_big_descending(len: usize) -> Vec<[u64; 16]> {\n+    (0..len as u64).rev().map(|x| [x; 16]).take(len).collect()\n+}\n+\n+macro_rules! sort_bench {\n+    ($name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            b.iter(|| $gen($len).sort());\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n+        }\n+    }\n+}\n+\n+sort_bench!(sort_small_random, gen_random, 10);\n+sort_bench!(sort_small_ascending, gen_ascending, 10);\n+sort_bench!(sort_small_descending, gen_descending, 10);\n+\n+sort_bench!(sort_small_big_random, gen_big_random, 10);\n+sort_bench!(sort_small_big_ascending, gen_big_ascending, 10);\n+sort_bench!(sort_small_big_descending, gen_big_descending, 10);\n+\n+sort_bench!(sort_medium_random, gen_random, 100);\n+sort_bench!(sort_medium_ascending, gen_ascending, 100);\n+sort_bench!(sort_medium_descending, gen_descending, 100);\n+\n+sort_bench!(sort_large_random, gen_random, 10000);\n+sort_bench!(sort_large_ascending, gen_ascending, 10000);\n+sort_bench!(sort_large_descending, gen_descending, 10000);\n+sort_bench!(sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n+sort_bench!(sort_large_mostly_descending, gen_mostly_descending, 10000);\n+\n+sort_bench!(sort_large_big_random, gen_big_random, 10000);\n+sort_bench!(sort_large_big_ascending, gen_big_ascending, 10000);\n+sort_bench!(sort_large_big_descending, gen_big_descending, 10000);\n+\n+#[bench]\n+fn sort_large_random_expensive(b: &mut Bencher) {\n+    let len = 10000;\n+    b.iter(|| {\n+        let mut v = gen_random(len);\n+        let mut count = 0;\n+        v.sort_by(|a: &u64, b: &u64| {\n+            count += 1;\n+            if count % 1_000_000_000 == 0 {\n+                panic!(\"should not happen\");\n+            }\n+            (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n+        });\n+        black_box(count);\n+    });\n+    b.bytes = len as u64 * mem::size_of::<u64>() as u64;\n+}\n\\ No newline at end of file"}, {"sha": "7f727078101c463ef62d85ca1c48e828d02bfa8c", "filename": "src/libcollections/benches/str.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fstr.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,298 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn char_iterator(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| s.chars().count());\n+}\n+\n+#[bench]\n+fn char_iterator_for(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| {\n+        for ch in s.chars() { black_box(ch); }\n+    });\n+}\n+\n+#[bench]\n+fn char_iterator_ascii(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\n+    Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| s.chars().count());\n+}\n+\n+#[bench]\n+fn char_iterator_rev(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| s.chars().rev().count());\n+}\n+\n+#[bench]\n+fn char_iterator_rev_for(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+\n+    b.iter(|| {\n+        for ch in s.chars().rev() { black_box(ch); }\n+    });\n+}\n+\n+#[bench]\n+fn char_indicesator(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    let len = s.chars().count();\n+\n+    b.iter(|| assert_eq!(s.char_indices().count(), len));\n+}\n+\n+#[bench]\n+fn char_indicesator_rev(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    let len = s.chars().count();\n+\n+    b.iter(|| assert_eq!(s.char_indices().rev().count(), len));\n+}\n+\n+#[bench]\n+fn split_unicode_ascii(b: &mut Bencher) {\n+    let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+\n+    b.iter(|| assert_eq!(s.split('V').count(), 3));\n+}\n+\n+#[bench]\n+fn split_ascii(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+\n+    b.iter(|| assert_eq!(s.split(' ').count(), len));\n+}\n+\n+#[bench]\n+fn split_extern_fn(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+    fn pred(c: char) -> bool { c == ' ' }\n+\n+    b.iter(|| assert_eq!(s.split(pred).count(), len));\n+}\n+\n+#[bench]\n+fn split_closure(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+\n+    b.iter(|| assert_eq!(s.split(|c: char| c == ' ').count(), len));\n+}\n+\n+#[bench]\n+fn split_slice(b: &mut Bencher) {\n+    let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n+    let len = s.split(' ').count();\n+\n+    let c: &[char] = &[' '];\n+    b.iter(|| assert_eq!(s.split(c).count(), len));\n+}\n+\n+#[bench]\n+fn bench_join(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    let sep = \"\u2192\";\n+    let v = vec![s, s, s, s, s, s, s, s, s, s];\n+    b.iter(|| {\n+        assert_eq!(v.join(sep).len(), s.len() * 10 + sep.len() * 9);\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_short_short(b: &mut Bencher) {\n+    let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+    let needle = \"sit\";\n+\n+    b.iter(|| {\n+        assert!(haystack.contains(needle));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_short_long(b: &mut Bencher) {\n+    let haystack = \"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum.\";\n+    let needle = \"english\";\n+\n+    b.iter(|| {\n+        assert!(!haystack.contains(needle));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_bad_naive(b: &mut Bencher) {\n+    let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+    let needle = \"aaaaaaaab\";\n+\n+    b.iter(|| {\n+        assert!(!haystack.contains(needle));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_equal(b: &mut Bencher) {\n+    let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+    let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+\n+    b.iter(|| {\n+        assert!(haystack.contains(needle));\n+    })\n+}\n+\n+macro_rules! make_test_inner {\n+    ($s:ident, $code:expr, $name:ident, $str:expr) => {\n+        #[bench]\n+        fn $name(bencher: &mut Bencher) {\n+            let mut $s = $str;\n+            black_box(&mut $s);\n+            bencher.iter(|| $code);\n+        }\n+    }\n+}\n+\n+macro_rules! make_test {\n+    ($name:ident, $s:ident, $code:expr) => {\n+        mod $name {\n+            use test::Bencher;\n+            use test::black_box;\n+\n+            // Short strings: 65 bytes each\n+            make_test_inner!($s, $code, short_ascii,\n+                \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n+            make_test_inner!($s, $code, short_mixed,\n+                \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n+            make_test_inner!($s, $code, short_pile_of_poo,\n+                \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n+            make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum!\");\n+        }\n+    }\n+}\n+\n+make_test!(chars_count, s, s.chars().count());\n+\n+make_test!(contains_bang_str, s, s.contains(\"!\"));\n+make_test!(contains_bang_char, s, s.contains('!'));\n+\n+make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n+\n+make_test!(split_a_str, s, s.split(\"a\").count());\n+\n+make_test!(trim_ascii_char, s, {\n+    use std::ascii::AsciiExt;\n+    s.trim_matches(|c: char| c.is_ascii())\n+});\n+make_test!(trim_left_ascii_char, s, {\n+    use std::ascii::AsciiExt;\n+    s.trim_left_matches(|c: char| c.is_ascii())\n+});\n+make_test!(trim_right_ascii_char, s, {\n+    use std::ascii::AsciiExt;\n+    s.trim_right_matches(|c: char| c.is_ascii())\n+});\n+\n+make_test!(find_underscore_char, s, s.find('_'));\n+make_test!(rfind_underscore_char, s, s.rfind('_'));\n+make_test!(find_underscore_str, s, s.find(\"_\"));\n+\n+make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n+make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n+make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n+\n+make_test!(split_space_char, s, s.split(' ').count());\n+make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n+\n+make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n+make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n+\n+make_test!(split_space_str, s, s.split(\" \").count());\n+make_test!(split_ad_str, s, s.split(\"ad\").count());"}, {"sha": "36be21d978e1fdac8574e031a233a2915d062762", "filename": "src/libcollections/benches/string.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fstring.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::repeat;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_with_capacity(b: &mut Bencher) {\n+    b.iter(|| String::with_capacity(100));\n+}\n+\n+#[bench]\n+fn bench_push_str(b: &mut Bencher) {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+    b.iter(|| {\n+        let mut r = String::new();\n+        r.push_str(s);\n+    });\n+}\n+\n+const REPETITIONS: u64 = 10_000;\n+\n+#[bench]\n+fn bench_push_str_one_byte(b: &mut Bencher) {\n+    b.bytes = REPETITIONS;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push_str(\"a\")\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_char_one_byte(b: &mut Bencher) {\n+    b.bytes = REPETITIONS;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push('a')\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_char_two_bytes(b: &mut Bencher) {\n+    b.bytes = REPETITIONS * 2;\n+    b.iter(|| {\n+        let mut r = String::new();\n+        for _ in 0..REPETITIONS {\n+            r.push('\u00e2')\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n+    let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+              Lorem ipsum dolor sit amet, consectetur. \";\n+\n+    assert_eq!(100, s.len());\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n+    let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n+    assert_eq!(100, s.len());\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_invalid(b: &mut Bencher) {\n+    let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(s);\n+    });\n+}\n+\n+#[bench]\n+fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n+    let s = repeat(0xf5).take(100).collect::<Vec<_>>();\n+    b.iter(|| {\n+        let _ = String::from_utf8_lossy(&s);\n+    });\n+}\n+\n+#[bench]\n+fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    // ensure our operation produces an exact-size string before we benchmark it\n+    let mut r = String::with_capacity(s.len());\n+    r.push_str(s);\n+    assert_eq!(r.len(), r.capacity());\n+    b.iter(|| {\n+        let mut r = String::with_capacity(s.len());\n+        r.push_str(s);\n+        r.shrink_to_fit();\n+        r\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_str(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    b.iter(|| String::from(s))\n+}\n+\n+#[bench]\n+fn bench_from(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    b.iter(|| String::from(s))\n+}\n+\n+#[bench]\n+fn bench_to_string(b: &mut Bencher) {\n+    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+             Lorem ipsum dolor sit amet, consectetur. \";\n+    b.iter(|| s.to_string())\n+}"}, {"sha": "414901170683effec41392bb7c3002e44a156d5a", "filename": "src/libcollections/benches/vec.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fvec.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,492 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::Bencher;\n+use std::iter::{FromIterator, repeat};\n+\n+#[bench]\n+fn bench_new(b: &mut Bencher) {\n+    b.iter(|| {\n+        let v: Vec<u32> = Vec::new();\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(v.capacity(), 0);\n+    })\n+}\n+\n+fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let v: Vec<u32> = Vec::with_capacity(src_len);\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(v.capacity(), src_len);\n+    })\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0000(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 0)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0010(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 10)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_0100(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 100)\n+}\n+\n+#[bench]\n+fn bench_with_capacity_1000(b: &mut Bencher) {\n+    do_bench_with_capacity(b, 1000)\n+}\n+\n+fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = (0..src_len).collect::<Vec<_>>();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    })\n+}\n+\n+#[bench]\n+fn bench_from_fn_0000(b: &mut Bencher) {\n+    do_bench_from_fn(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_fn_0010(b: &mut Bencher) {\n+    do_bench_from_fn(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_fn_0100(b: &mut Bencher) {\n+    do_bench_from_fn(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_fn_1000(b: &mut Bencher) {\n+    do_bench_from_fn(b, 1000)\n+}\n+\n+fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst: Vec<usize> = repeat(5).take(src_len).collect();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().all(|x| *x == 5));\n+    })\n+}\n+\n+#[bench]\n+fn bench_from_elem_0000(b: &mut Bencher) {\n+    do_bench_from_elem(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_elem_0010(b: &mut Bencher) {\n+    do_bench_from_elem(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_elem_0100(b: &mut Bencher) {\n+    do_bench_from_elem(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_elem_1000(b: &mut Bencher) {\n+    do_bench_from_elem(b, 1000)\n+}\n+\n+fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = src.clone()[..].to_vec();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_slice_0000(b: &mut Bencher) {\n+    do_bench_from_slice(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_slice_0010(b: &mut Bencher) {\n+    do_bench_from_slice(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_slice_0100(b: &mut Bencher) {\n+    do_bench_from_slice(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_slice_1000(b: &mut Bencher) {\n+    do_bench_from_slice(b, 1000)\n+}\n+\n+fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst: Vec<_> = FromIterator::from_iter(src.clone());\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_from_iter_0000(b: &mut Bencher) {\n+    do_bench_from_iter(b, 0)\n+}\n+\n+#[bench]\n+fn bench_from_iter_0010(b: &mut Bencher) {\n+    do_bench_from_iter(b, 10)\n+}\n+\n+#[bench]\n+fn bench_from_iter_0100(b: &mut Bencher) {\n+    do_bench_from_iter(b, 100)\n+}\n+\n+#[bench]\n+fn bench_from_iter_1000(b: &mut Bencher) {\n+    do_bench_from_iter(b, 1000)\n+}\n+\n+fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend(src.clone());\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0000(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0010(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_0100(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_extend_0000_1000(b: &mut Bencher) {\n+    do_bench_extend(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_extend_0010_0010(b: &mut Bencher) {\n+    do_bench_extend(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_extend_0100_0100(b: &mut Bencher) {\n+    do_bench_extend(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_extend_1000_1000(b: &mut Bencher) {\n+    do_bench_extend(b, 1000, 1000)\n+}\n+\n+fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend_from_slice(&src);\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0000(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0010(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_0100(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_0000_1000(b: &mut Bencher) {\n+    do_bench_push_all(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_push_all_0010_0010(b: &mut Bencher) {\n+    do_bench_push_all(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_0100_0100(b: &mut Bencher) {\n+    do_bench_push_all(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_1000_1000(b: &mut Bencher) {\n+    do_bench_push_all(b, 1000, 1000)\n+}\n+\n+fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+        dst.extend(src.clone());\n+        assert_eq!(dst.len(), dst_len + src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0010(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_0100(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0000_1000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0010_0010(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_0100_0100(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_push_all_move_1000_1000(b: &mut Bencher) {\n+    do_bench_push_all_move(b, 1000, 1000)\n+}\n+\n+fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n+    let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n+\n+    b.bytes = src_len as u64;\n+\n+    b.iter(|| {\n+        let dst = src.clone();\n+        assert_eq!(dst.len(), src_len);\n+        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+    });\n+}\n+\n+#[bench]\n+fn bench_clone_0000(b: &mut Bencher) {\n+    do_bench_clone(b, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_0010(b: &mut Bencher) {\n+    do_bench_clone(b, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_0100(b: &mut Bencher) {\n+    do_bench_clone(b, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_1000(b: &mut Bencher) {\n+    do_bench_clone(b, 1000)\n+}\n+\n+fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n+    let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n+    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+\n+    b.bytes = (times * src_len) as u64;\n+\n+    b.iter(|| {\n+        let mut dst = dst.clone();\n+\n+        for _ in 0..times {\n+            dst.clone_from(&src);\n+\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_1000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 1000, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0010_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 10, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_0100_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 100, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_01_1000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 1, 1000, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 0, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_1000_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 1000, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 100)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_1000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 1000)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0010_0000(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 10, 0)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 100, 10)\n+}\n+\n+#[bench]\n+fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n+    do_bench_clone_from(b, 10, 1000, 100)\n+}"}, {"sha": "380645e7cd03a9236f31f2ff4cdd88b61fa54aac", "filename": "src/libcollections/benches/vec_deque.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollections%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fvec_deque.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::VecDeque;\n+use test::{Bencher, black_box};\n+\n+#[bench]\n+fn bench_new(b: &mut Bencher) {\n+    b.iter(|| {\n+        let ring: VecDeque<i32> = VecDeque::new();\n+        black_box(ring);\n+    })\n+}\n+\n+#[bench]\n+fn bench_grow_1025(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut deq = VecDeque::new();\n+        for i in 0..1025 {\n+            deq.push_front(i);\n+        }\n+        black_box(deq);\n+    })\n+}\n+\n+#[bench]\n+fn bench_iter_1000(b: &mut Bencher) {\n+    let ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for &i in &ring {\n+            sum += i;\n+        }\n+        black_box(sum);\n+    })\n+}\n+\n+#[bench]\n+fn bench_mut_iter_1000(b: &mut Bencher) {\n+    let mut ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        for i in &mut ring {\n+            sum += *i;\n+        }\n+        black_box(sum);\n+    })\n+}"}, {"sha": "11be13426e49cebb93ade022297b828e801485a5", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -606,52 +606,3 @@ fn test_split_off_large_random_sorted() {\n     assert!(map.into_iter().eq(data.clone().into_iter().filter(|x| x.0 < key)));\n     assert!(right.into_iter().eq(data.into_iter().filter(|x| x.0 >= key)));\n }\n-\n-mod bench {\n-    use std::collections::BTreeMap;\n-    use std::__rand::{Rng, thread_rng};\n-\n-    use test::{Bencher, black_box};\n-\n-    map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n-    map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n-\n-    map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n-    map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n-\n-    map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n-    map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n-\n-    map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n-    map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n-\n-    fn bench_iter(b: &mut Bencher, size: i32) {\n-        let mut map = BTreeMap::<i32, i32>::new();\n-        let mut rng = thread_rng();\n-\n-        for _ in 0..size {\n-            map.insert(rng.gen(), rng.gen());\n-        }\n-\n-        b.iter(|| {\n-            for entry in &map {\n-                black_box(entry);\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn iter_20(b: &mut Bencher) {\n-        bench_iter(b, 20);\n-    }\n-\n-    #[bench]\n-    pub fn iter_1000(b: &mut Bencher) {\n-        bench_iter(b, 1000);\n-    }\n-\n-    #[bench]\n-    pub fn iter_100000(b: &mut Bencher) {\n-        bench_iter(b, 100000);\n-    }\n-}"}, {"sha": "57e3c2df059e122775f7d98f0c082980a7a4c7bb", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -35,10 +35,6 @@ extern crate std_unicode;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n \n-#[cfg(test)]\n-#[macro_use]\n-mod bench;\n-\n mod binary_heap;\n mod btree;\n mod cow_str;"}, {"sha": "a59724a017b1241de3e9995727a719782b76ea7f", "filename": "src/libcollectionstest/linked_list.rs", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flinked_list.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -10,8 +10,6 @@\n \n use std::collections::LinkedList;\n \n-use test;\n-\n #[test]\n fn test_basic() {\n     let mut m = LinkedList::<Box<_>>::new();\n@@ -356,81 +354,6 @@ fn test_extend() {\n     assert!(a.iter().eq(&[1, 2, 3, 4, 5, 6, 7]));\n }\n \n-#[bench]\n-fn bench_collect_into(b: &mut test::Bencher) {\n-    let v = &[0; 64];\n-    b.iter(|| {\n-        let _: LinkedList<_> = v.iter().cloned().collect();\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_front(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_front(0);\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_back(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_back(0);\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_back(0);\n-        m.pop_back();\n-    })\n-}\n-\n-#[bench]\n-fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    b.iter(|| {\n-        m.push_front(0);\n-        m.pop_front();\n-    })\n-}\n-\n-#[bench]\n-fn bench_iter(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter().count() == 128);\n-    })\n-}\n-#[bench]\n-fn bench_iter_mut(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let mut m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter_mut().count() == 128);\n-    })\n-}\n-#[bench]\n-fn bench_iter_rev(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter().rev().count() == 128);\n-    })\n-}\n-#[bench]\n-fn bench_iter_mut_rev(b: &mut test::Bencher) {\n-    let v = &[0; 128];\n-    let mut m: LinkedList<_> = v.iter().cloned().collect();\n-    b.iter(|| {\n-        assert!(m.iter_mut().rev().count() == 128);\n-    })\n-}\n-\n #[test]\n fn test_contains() {\n     let mut l = LinkedList::new();"}, {"sha": "a7f7baf38518c186751d04f02574ba9bdac7e7ba", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -1170,276 +1170,3 @@ fn test_copy_from_slice_dst_shorter() {\n     let mut dst = [0; 3];\n     dst.copy_from_slice(&src);\n }\n-\n-mod bench {\n-    use std::{mem, ptr};\n-    use std::__rand::{Rng, thread_rng};\n-\n-    use test::{Bencher, black_box};\n-\n-    #[bench]\n-    fn iterator(b: &mut Bencher) {\n-        // peculiar numbers to stop LLVM from optimising the summation\n-        // out.\n-        let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n-\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for x in &v {\n-                sum += *x;\n-            }\n-            // sum == 11806, to stop dead code elimination.\n-            if sum == 0 {\n-                panic!()\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn mut_iterator(b: &mut Bencher) {\n-        let mut v = vec![0; 100];\n-\n-        b.iter(|| {\n-            let mut i = 0;\n-            for x in &mut v {\n-                *x = i;\n-                i += 1;\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn concat(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n-        b.iter(|| {\n-            xss.concat();\n-        });\n-    }\n-\n-    #[bench]\n-    fn join(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n-        b.iter(|| xss.join(&0));\n-    }\n-\n-    #[bench]\n-    fn push(b: &mut Bencher) {\n-        let mut vec = Vec::<i32>::new();\n-        b.iter(|| {\n-            vec.push(0);\n-            black_box(&vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| vec.starts_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn starts_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<_> = vec![0];\n-        b.iter(|| vec.starts_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        let mut match_vec: Vec<_> = (0..99).collect();\n-        match_vec.push(0);\n-        b.iter(|| vec.starts_with(&match_vec))\n-    }\n-\n-    #[bench]\n-    fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| vec.ends_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn ends_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<_> = vec![0];\n-        b.iter(|| vec.ends_with(&vec))\n-    }\n-\n-    #[bench]\n-    fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        let mut match_vec: Vec<_> = (0..100).collect();\n-        match_vec[0] = 200;\n-        b.iter(|| vec.starts_with(&match_vec))\n-    }\n-\n-    #[bench]\n-    fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| vec.contains(&99))\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_from_elem(b: &mut Bencher) {\n-        b.iter(|| vec![0u8; 1024]);\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_set_memory(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                let vp = v.as_mut_ptr();\n-                ptr::write_bytes(vp, 0, 1024);\n-                v.set_len(1024);\n-            }\n-            v\n-        });\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_loop_set(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                v.set_len(1024);\n-            }\n-            for i in 0..1024 {\n-                v[i] = 0;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn zero_1kb_mut_iter(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut v = Vec::<u8>::with_capacity(1024);\n-            unsafe {\n-                v.set_len(1024);\n-            }\n-            for x in &mut v {\n-                *x = 0;\n-            }\n-            v\n-        });\n-    }\n-\n-    #[bench]\n-    fn random_inserts(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = vec![(0, 0); 30];\n-            for _ in 0..100 {\n-                let l = v.len();\n-                v.insert(rng.gen::<usize>() % (l + 1), (1, 1));\n-            }\n-        })\n-    }\n-    #[bench]\n-    fn random_removes(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = vec![(0, 0); 130];\n-            for _ in 0..100 {\n-                let l = v.len();\n-                v.remove(rng.gen::<usize>() % l);\n-            }\n-        })\n-    }\n-\n-    fn gen_ascending(len: usize) -> Vec<u64> {\n-        (0..len as u64).collect()\n-    }\n-\n-    fn gen_descending(len: usize) -> Vec<u64> {\n-        (0..len as u64).rev().collect()\n-    }\n-\n-    fn gen_random(len: usize) -> Vec<u64> {\n-        let mut rng = thread_rng();\n-        rng.gen_iter::<u64>().take(len).collect()\n-    }\n-\n-    fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n-        let mut rng = thread_rng();\n-        let mut v = gen_ascending(len);\n-        for _ in (0usize..).take_while(|x| x * x <= len) {\n-            let x = rng.gen::<usize>() % len;\n-            let y = rng.gen::<usize>() % len;\n-            v.swap(x, y);\n-        }\n-        v\n-    }\n-\n-    fn gen_mostly_descending(len: usize) -> Vec<u64> {\n-        let mut rng = thread_rng();\n-        let mut v = gen_descending(len);\n-        for _ in (0usize..).take_while(|x| x * x <= len) {\n-            let x = rng.gen::<usize>() % len;\n-            let y = rng.gen::<usize>() % len;\n-            v.swap(x, y);\n-        }\n-        v\n-    }\n-\n-    fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n-        let mut rng = thread_rng();\n-        rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n-    }\n-\n-    fn gen_big_ascending(len: usize) -> Vec<[u64; 16]> {\n-        (0..len as u64).map(|x| [x; 16]).take(len).collect()\n-    }\n-\n-    fn gen_big_descending(len: usize) -> Vec<[u64; 16]> {\n-        (0..len as u64).rev().map(|x| [x; 16]).take(len).collect()\n-    }\n-\n-    macro_rules! sort_bench {\n-        ($name:ident, $gen:expr, $len:expr) => {\n-            #[bench]\n-            fn $name(b: &mut Bencher) {\n-                b.iter(|| $gen($len).sort());\n-                b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n-            }\n-        }\n-    }\n-\n-    sort_bench!(sort_small_random, gen_random, 10);\n-    sort_bench!(sort_small_ascending, gen_ascending, 10);\n-    sort_bench!(sort_small_descending, gen_descending, 10);\n-\n-    sort_bench!(sort_small_big_random, gen_big_random, 10);\n-    sort_bench!(sort_small_big_ascending, gen_big_ascending, 10);\n-    sort_bench!(sort_small_big_descending, gen_big_descending, 10);\n-\n-    sort_bench!(sort_medium_random, gen_random, 100);\n-    sort_bench!(sort_medium_ascending, gen_ascending, 100);\n-    sort_bench!(sort_medium_descending, gen_descending, 100);\n-\n-    sort_bench!(sort_large_random, gen_random, 10000);\n-    sort_bench!(sort_large_ascending, gen_ascending, 10000);\n-    sort_bench!(sort_large_descending, gen_descending, 10000);\n-    sort_bench!(sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n-    sort_bench!(sort_large_mostly_descending, gen_mostly_descending, 10000);\n-\n-    sort_bench!(sort_large_big_random, gen_big_random, 10000);\n-    sort_bench!(sort_large_big_ascending, gen_big_ascending, 10000);\n-    sort_bench!(sort_large_big_descending, gen_big_descending, 10000);\n-\n-    #[bench]\n-    fn sort_large_random_expensive(b: &mut Bencher) {\n-        let len = 10000;\n-        b.iter(|| {\n-            let mut v = gen_random(len);\n-            let mut count = 0;\n-            v.sort_by(|a: &u64, b: &u64| {\n-                count += 1;\n-                if count % 1_000_000_000 == 0 {\n-                    panic!(\"should not happen\");\n-                }\n-                (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n-            });\n-            black_box(count);\n-        });\n-        b.bytes = len as u64 * mem::size_of::<u64>() as u64;\n-    }\n-}"}, {"sha": "6221888f5e55e7777ed4fdbe43ea6f0493592c30", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -1564,294 +1564,3 @@ fn different_str_pattern_forwarding_lifetimes() {\n \n     foo::<&str>(\"x\");\n }\n-\n-mod bench {\n-    use test::{Bencher, black_box};\n-\n-    #[bench]\n-    fn char_iterator(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_for(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| {\n-            for ch in s.chars() { black_box(ch); }\n-        });\n-    }\n-\n-    #[bench]\n-    fn char_iterator_ascii(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_rev(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| s.chars().rev().count());\n-    }\n-\n-    #[bench]\n-    fn char_iterator_rev_for(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-\n-        b.iter(|| {\n-            for ch in s.chars().rev() { black_box(ch); }\n-        });\n-    }\n-\n-    #[bench]\n-    fn char_indicesator(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.chars().count();\n-\n-        b.iter(|| assert_eq!(s.char_indices().count(), len));\n-    }\n-\n-    #[bench]\n-    fn char_indicesator_rev(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.chars().count();\n-\n-        b.iter(|| assert_eq!(s.char_indices().rev().count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_unicode_ascii(b: &mut Bencher) {\n-        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-\n-        b.iter(|| assert_eq!(s.split('V').count(), 3));\n-    }\n-\n-    #[bench]\n-    fn split_ascii(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(' ').count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_extern_fn(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-        fn pred(c: char) -> bool { c == ' ' }\n-\n-        b.iter(|| assert_eq!(s.split(pred).count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_closure(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(|c: char| c == ' ').count(), len));\n-    }\n-\n-    #[bench]\n-    fn split_slice(b: &mut Bencher) {\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        let c: &[char] = &[' '];\n-        b.iter(|| assert_eq!(s.split(c).count(), len));\n-    }\n-\n-    #[bench]\n-    fn bench_join(b: &mut Bencher) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let sep = \"\u2192\";\n-        let v = vec![s, s, s, s, s, s, s, s, s, s];\n-        b.iter(|| {\n-            assert_eq!(v.join(sep).len(), s.len() * 10 + sep.len() * 9);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_short_short(b: &mut Bencher) {\n-        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-        let needle = \"sit\";\n-\n-        b.iter(|| {\n-            assert!(haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_short_long(b: &mut Bencher) {\n-        let haystack = \"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\n-\n-In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n-sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n-diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n-lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n-eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n-interdum. Curabitur ut nisi justo.\n-\n-Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n-mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n-lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n-est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n-felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n-ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n-feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n-Aliquam sit amet placerat lorem.\n-\n-Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n-mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n-Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n-lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n-suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n-cursus accumsan.\n-\n-Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n-feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n-vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n-leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum.\";\n-        let needle = \"english\";\n-\n-        b.iter(|| {\n-            assert!(!haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_bad_naive(b: &mut Bencher) {\n-        let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n-        let needle = \"aaaaaaaab\";\n-\n-        b.iter(|| {\n-            assert!(!haystack.contains(needle));\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_contains_equal(b: &mut Bencher) {\n-        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-        let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n-\n-        b.iter(|| {\n-            assert!(haystack.contains(needle));\n-        })\n-    }\n-\n-    macro_rules! make_test_inner {\n-        ($s:ident, $code:expr, $name:ident, $str:expr) => {\n-            #[bench]\n-            fn $name(bencher: &mut Bencher) {\n-                let mut $s = $str;\n-                black_box(&mut $s);\n-                bencher.iter(|| $code);\n-            }\n-        }\n-    }\n-\n-    macro_rules! make_test {\n-        ($name:ident, $s:ident, $code:expr) => {\n-            mod $name {\n-                use test::Bencher;\n-                use test::black_box;\n-\n-                // Short strings: 65 bytes each\n-                make_test_inner!($s, $code, short_ascii,\n-                    \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n-                make_test_inner!($s, $code, short_mixed,\n-                    \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n-                make_test_inner!($s, $code, short_pile_of_poo,\n-                    \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n-                make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\n-\n-In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n-sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n-diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n-lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n-eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n-interdum. Curabitur ut nisi justo.\n-\n-Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n-mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n-lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n-est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n-felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n-ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n-feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n-Aliquam sit amet placerat lorem.\n-\n-Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n-mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n-Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n-lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n-suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n-cursus accumsan.\n-\n-Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n-feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n-vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n-leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum!\");\n-            }\n-        }\n-    }\n-\n-    make_test!(chars_count, s, s.chars().count());\n-\n-    make_test!(contains_bang_str, s, s.contains(\"!\"));\n-    make_test!(contains_bang_char, s, s.contains('!'));\n-\n-    make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n-\n-    make_test!(split_a_str, s, s.split(\"a\").count());\n-\n-    make_test!(trim_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_left_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_left_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_right_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_right_matches(|c: char| c.is_ascii())\n-    });\n-\n-    make_test!(find_underscore_char, s, s.find('_'));\n-    make_test!(rfind_underscore_char, s, s.rfind('_'));\n-    make_test!(find_underscore_str, s, s.find(\"_\"));\n-\n-    make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n-    make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n-    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n-\n-    make_test!(split_space_char, s, s.split(' ').count());\n-    make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n-\n-    make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n-    make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n-\n-    make_test!(split_space_str, s, s.split(\" \").count());\n-    make_test!(split_ad_str, s, s.split(\"ad\").count());\n-}"}, {"sha": "f77dd510303c74b3564b2acbdda66080aef50a9e", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -9,9 +9,6 @@\n // except according to those terms.\n \n use std::borrow::Cow;\n-use std::iter::repeat;\n-\n-use test::Bencher;\n \n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B>;\n@@ -436,125 +433,3 @@ fn test_into_boxed_str() {\n     let ys = xs.into_boxed_str();\n     assert_eq!(&*ys, \"hello my name is bob\");\n }\n-\n-#[bench]\n-fn bench_with_capacity(b: &mut Bencher) {\n-    b.iter(|| String::with_capacity(100));\n-}\n-\n-#[bench]\n-fn bench_push_str(b: &mut Bencher) {\n-    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-    b.iter(|| {\n-        let mut r = String::new();\n-        r.push_str(s);\n-    });\n-}\n-\n-const REPETITIONS: u64 = 10_000;\n-\n-#[bench]\n-fn bench_push_str_one_byte(b: &mut Bencher) {\n-    b.bytes = REPETITIONS;\n-    b.iter(|| {\n-        let mut r = String::new();\n-        for _ in 0..REPETITIONS {\n-            r.push_str(\"a\")\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_char_one_byte(b: &mut Bencher) {\n-    b.bytes = REPETITIONS;\n-    b.iter(|| {\n-        let mut r = String::new();\n-        for _ in 0..REPETITIONS {\n-            r.push('a')\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_char_two_bytes(b: &mut Bencher) {\n-    b.bytes = REPETITIONS * 2;\n-    b.iter(|| {\n-        let mut r = String::new();\n-        for _ in 0..REPETITIONS {\n-            r.push('\u00e2')\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n-    let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-              Lorem ipsum dolor sit amet, consectetur. \";\n-\n-    assert_eq!(100, s.len());\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(s);\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-    let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n-    assert_eq!(100, s.len());\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(s);\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_invalid(b: &mut Bencher) {\n-    let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(s);\n-    });\n-}\n-\n-#[bench]\n-fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-    let s = repeat(0xf5).take(100).collect::<Vec<_>>();\n-    b.iter(|| {\n-        let _ = String::from_utf8_lossy(&s);\n-    });\n-}\n-\n-#[bench]\n-fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    // ensure our operation produces an exact-size string before we benchmark it\n-    let mut r = String::with_capacity(s.len());\n-    r.push_str(s);\n-    assert_eq!(r.len(), r.capacity());\n-    b.iter(|| {\n-        let mut r = String::with_capacity(s.len());\n-        r.push_str(s);\n-        r.shrink_to_fit();\n-        r\n-    });\n-}\n-\n-#[bench]\n-fn bench_from_str(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| String::from(s))\n-}\n-\n-#[bench]\n-fn bench_from(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| String::from(s))\n-}\n-\n-#[bench]\n-fn bench_to_string(b: &mut Bencher) {\n-    let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n-             Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| s.to_string())\n-}"}, {"sha": "edeedf1d40baf3d37b38d6c36928945c7828558a", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 0, "deletions": 483, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -10,13 +10,10 @@\n \n use std::ascii::AsciiExt;\n use std::borrow::Cow;\n-use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n use std::panic;\n use std::vec::{Drain, IntoIter};\n \n-use test::Bencher;\n-\n struct DropCounter<'a> {\n     count: &'a mut u32,\n }\n@@ -633,483 +630,3 @@ fn test_placement_panic() {\n     let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { vec.place_back() <- mkpanic(); }));\n     assert_eq!(vec.len(), 3);\n }\n-\n-#[bench]\n-fn bench_new(b: &mut Bencher) {\n-    b.iter(|| {\n-        let v: Vec<u32> = Vec::new();\n-        assert_eq!(v.len(), 0);\n-        assert_eq!(v.capacity(), 0);\n-    })\n-}\n-\n-fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let v: Vec<u32> = Vec::with_capacity(src_len);\n-        assert_eq!(v.len(), 0);\n-        assert_eq!(v.capacity(), src_len);\n-    })\n-}\n-\n-#[bench]\n-fn bench_with_capacity_0000(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 0)\n-}\n-\n-#[bench]\n-fn bench_with_capacity_0010(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 10)\n-}\n-\n-#[bench]\n-fn bench_with_capacity_0100(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 100)\n-}\n-\n-#[bench]\n-fn bench_with_capacity_1000(b: &mut Bencher) {\n-    do_bench_with_capacity(b, 1000)\n-}\n-\n-fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst = (0..src_len).collect::<Vec<_>>();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    })\n-}\n-\n-#[bench]\n-fn bench_from_fn_0000(b: &mut Bencher) {\n-    do_bench_from_fn(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_fn_0010(b: &mut Bencher) {\n-    do_bench_from_fn(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_fn_0100(b: &mut Bencher) {\n-    do_bench_from_fn(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_fn_1000(b: &mut Bencher) {\n-    do_bench_from_fn(b, 1000)\n-}\n-\n-fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst: Vec<usize> = repeat(5).take(src_len).collect();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().all(|x| *x == 5));\n-    })\n-}\n-\n-#[bench]\n-fn bench_from_elem_0000(b: &mut Bencher) {\n-    do_bench_from_elem(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_elem_0010(b: &mut Bencher) {\n-    do_bench_from_elem(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_elem_0100(b: &mut Bencher) {\n-    do_bench_from_elem(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_elem_1000(b: &mut Bencher) {\n-    do_bench_from_elem(b, 1000)\n-}\n-\n-fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n-    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst = src.clone()[..].to_vec();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_from_slice_0000(b: &mut Bencher) {\n-    do_bench_from_slice(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_slice_0010(b: &mut Bencher) {\n-    do_bench_from_slice(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_slice_0100(b: &mut Bencher) {\n-    do_bench_from_slice(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_slice_1000(b: &mut Bencher) {\n-    do_bench_from_slice(b, 1000)\n-}\n-\n-fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n-    let src: Vec<_> = FromIterator::from_iter(0..src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst: Vec<_> = FromIterator::from_iter(src.clone());\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_from_iter_0000(b: &mut Bencher) {\n-    do_bench_from_iter(b, 0)\n-}\n-\n-#[bench]\n-fn bench_from_iter_0010(b: &mut Bencher) {\n-    do_bench_from_iter(b, 10)\n-}\n-\n-#[bench]\n-fn bench_from_iter_0100(b: &mut Bencher) {\n-    do_bench_from_iter(b, 100)\n-}\n-\n-#[bench]\n-fn bench_from_iter_1000(b: &mut Bencher) {\n-    do_bench_from_iter(b, 1000)\n-}\n-\n-fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-        dst.extend(src.clone());\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_extend_0000_0000(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_extend_0000_0010(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_extend_0000_0100(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_extend_0000_1000(b: &mut Bencher) {\n-    do_bench_extend(b, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_extend_0010_0010(b: &mut Bencher) {\n-    do_bench_extend(b, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_extend_0100_0100(b: &mut Bencher) {\n-    do_bench_extend(b, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_extend_1000_1000(b: &mut Bencher) {\n-    do_bench_extend(b, 1000, 1000)\n-}\n-\n-fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-        dst.extend_from_slice(&src);\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_0000(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_0010(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_0100(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_0000_1000(b: &mut Bencher) {\n-    do_bench_push_all(b, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_push_all_0010_0010(b: &mut Bencher) {\n-    do_bench_push_all(b, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_0100_0100(b: &mut Bencher) {\n-    do_bench_push_all(b, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_1000_1000(b: &mut Bencher) {\n-    do_bench_push_all(b, 1000, 1000)\n-}\n-\n-fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-        dst.extend(src.clone());\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_0000(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_0010(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_0100(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0000_1000(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0010_0010(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_0100_0100(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_push_all_move_1000_1000(b: &mut Bencher) {\n-    do_bench_push_all_move(b, 1000, 1000)\n-}\n-\n-fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n-    let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n-\n-    b.bytes = src_len as u64;\n-\n-    b.iter(|| {\n-        let dst = src.clone();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-    });\n-}\n-\n-#[bench]\n-fn bench_clone_0000(b: &mut Bencher) {\n-    do_bench_clone(b, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_0010(b: &mut Bencher) {\n-    do_bench_clone(b, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_0100(b: &mut Bencher) {\n-    do_bench_clone(b, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_1000(b: &mut Bencher) {\n-    do_bench_clone(b, 1000)\n-}\n-\n-fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n-    let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n-    let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n-\n-    b.bytes = (times * src_len) as u64;\n-\n-    b.iter(|| {\n-        let mut dst = dst.clone();\n-\n-        for _ in 0..times {\n-            dst.clone_from(&src);\n-\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n-        }\n-    });\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0010_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0100_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_1000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 1000, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0010_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 10, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0100_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 100, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0010_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 10, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_0100_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 100, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_01_1000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 1, 1000, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 0, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0010_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 10, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0100_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 100, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_1000_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 1000, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0010_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 10, 100)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0100_1000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 100, 1000)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0010_0000(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 10, 0)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 100, 10)\n-}\n-\n-#[bench]\n-fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n-    do_bench_clone_from(b, 10, 1000, 100)\n-}"}, {"sha": "1541061a1984214bf70a4260b2ab35136b98d894", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -12,8 +12,6 @@ use std::collections::VecDeque;\n use std::fmt::Debug;\n use std::collections::vec_deque::Drain;\n \n-use test;\n-\n use self::Taggy::*;\n use self::Taggypar::*;\n \n@@ -124,51 +122,6 @@ fn test_index_out_of_bounds() {\n     deq[3];\n }\n \n-#[bench]\n-fn bench_new(b: &mut test::Bencher) {\n-    b.iter(|| {\n-        let ring: VecDeque<i32> = VecDeque::new();\n-        test::black_box(ring);\n-    })\n-}\n-\n-#[bench]\n-fn bench_grow_1025(b: &mut test::Bencher) {\n-    b.iter(|| {\n-        let mut deq = VecDeque::new();\n-        for i in 0..1025 {\n-            deq.push_front(i);\n-        }\n-        test::black_box(deq);\n-    })\n-}\n-\n-#[bench]\n-fn bench_iter_1000(b: &mut test::Bencher) {\n-    let ring: VecDeque<_> = (0..1000).collect();\n-\n-    b.iter(|| {\n-        let mut sum = 0;\n-        for &i in &ring {\n-            sum += i;\n-        }\n-        test::black_box(sum);\n-    })\n-}\n-\n-#[bench]\n-fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-    let mut ring: VecDeque<_> = (0..1000).collect();\n-\n-    b.iter(|| {\n-        let mut sum = 0;\n-        for i in &mut ring {\n-            sum += *i;\n-        }\n-        test::black_box(sum);\n-    })\n-}\n-\n #[derive(Clone, PartialEq, Debug)]\n enum Taggy {\n     One(i32),"}, {"sha": "e847c7fa3a0ec9580c82431ebe0d86bd8a88e9c2", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "patch": "@@ -14,5 +14,5 @@ name = \"coretest\"\n path = \"../libcoretest/lib.rs\"\n \n [[bench]]\n-name = \"corebench\"\n-path = \"../libcore/bench/lib.rs\"\n+name = \"corebenches\"\n+path = \"../libcore/benches/lib.rs\""}, {"sha": "67e02cf9509b6cd8ba71db2be4dd19cea9946ce0", "filename": "src/libcore/benches/any.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fany.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/any.rs"}, {"sha": "55d9e3e0913801bf2a4106eee84d44015dfe6cb4", "filename": "src/libcore/benches/hash/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fhash%2Fmod.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/hash/mod.rs"}, {"sha": "3379c85bbec7d5985df61fa213c3da90127faeb3", "filename": "src/libcore/benches/hash/sip.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fhash%2Fsip.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/hash/sip.rs"}, {"sha": "93d38a5bc83bbf1e392585821c90b82d5a72d3fb", "filename": "src/libcore/benches/iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/iter.rs"}, {"sha": "d2db329da799981b3a6d3a372211f21893603b6a", "filename": "src/libcore/benches/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/lib.rs"}, {"sha": "8e541d92a7f170c366b97c57c1912d9bd19f783d", "filename": "src/libcore/benches/mem.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fmem.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/mem.rs"}, {"sha": "562866e11777cf0e4db920ff0e9b0d4e60ea5c05", "filename": "src/libcore/benches/num/dec2flt/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/num/dec2flt/mod.rs"}, {"sha": "1de2bf4921f589996130885f363b550cbf179695", "filename": "src/libcore/benches/num/flt2dec/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/num/flt2dec/mod.rs"}, {"sha": "6824cf40ed2aec678ae771792ce01f9fb2a573da", "filename": "src/libcore/benches/num/flt2dec/strategy/dragon.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/num/flt2dec/strategy/dragon.rs"}, {"sha": "82e1a858fca9fc655a15967c43a88d7c6fd17711", "filename": "src/libcore/benches/num/flt2dec/strategy/grisu.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/num/flt2dec/strategy/grisu.rs"}, {"sha": "55f0bdb57ec820711fc8b8ddec0bc7981eaa6837", "filename": "src/libcore/benches/num/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fmod.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/num/mod.rs"}, {"sha": "7f36a4b0771aa611d9cb2f07544787da0e28be9c", "filename": "src/libcore/benches/ops.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4/src%2Flibcore%2Fbenches%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fops.rs?ref=7c8c45e76225ecf0a219e994a9a10d71d0b9a4e4", "previous_filename": "src/libcore/bench/ops.rs"}]}