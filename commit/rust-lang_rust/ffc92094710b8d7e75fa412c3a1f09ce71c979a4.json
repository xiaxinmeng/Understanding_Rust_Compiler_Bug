{"sha": "ffc92094710b8d7e75fa412c3a1f09ce71c979a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYzkyMDk0NzEwYjhkN2U3NWZhNDEyYzNhMWYwOWNlNzFjOTc5YTQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-09-25T09:00:36Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-09-25T09:00:36Z"}, "message": "Fold KindAnalysisVisitor into the Context.  Removed unused current_item state.", "tree": {"sha": "9e30265622d25786d338404111d7edbf94a1ea78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e30265622d25786d338404111d7edbf94a1ea78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffc92094710b8d7e75fa412c3a1f09ce71c979a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc92094710b8d7e75fa412c3a1f09ce71c979a4", "html_url": "https://github.com/rust-lang/rust/commit/ffc92094710b8d7e75fa412c3a1f09ce71c979a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffc92094710b8d7e75fa412c3a1f09ce71c979a4/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "339027ec157757e903bc23ad0eed11e8a75867fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/339027ec157757e903bc23ad0eed11e8a75867fa", "html_url": "https://github.com/rust-lang/rust/commit/339027ec157757e903bc23ad0eed11e8a75867fa"}], "stats": {"total": 83, "additions": 38, "deletions": 45}, "files": [{"sha": "270babb9cf3e238a54f19d68948f00fbd196d6d2", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ffc92094710b8d7e75fa412c3a1f09ce71c979a4/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc92094710b8d7e75fa412c3a1f09ce71c979a4/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=ffc92094710b8d7e75fa412c3a1f09ce71c979a4", "patch": "@@ -54,43 +54,38 @@ use syntax::visit::Visitor;\n pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    current_item: NodeId\n }\n \n-struct KindAnalysisVisitor;\n+impl Visitor<()> for Context {\n \n-impl Visitor<Context> for KindAnalysisVisitor {\n-\n-    fn visit_expr(&mut self, ex:@Expr, e:Context) {\n-        check_expr(self, ex, e);\n+    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+        check_expr(self, ex);\n     }\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:Context) {\n-        check_fn(self, fk, fd, b, s, n, e);\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, _:()) {\n+        check_fn(self, fk, fd, b, s, n);\n     }\n \n-    fn visit_ty(&mut self, t:&Ty, e:Context) {\n-        check_ty(self, t, e);\n+    fn visit_ty(&mut self, t:&Ty, _:()) {\n+        check_ty(self, t);\n     }\n-    fn visit_item(&mut self, i:@item, e:Context) {\n-        check_item(self, i, e);\n+    fn visit_item(&mut self, i:@item, _:()) {\n+        check_item(self, i);\n     }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    crate: &Crate) {\n-    let ctx = Context {\n+    let mut ctx = Context {\n         tcx: tcx,\n         method_map: method_map,\n-        current_item: -1\n     };\n-    let mut visit = KindAnalysisVisitor;\n-    visit::walk_crate(&mut visit, crate, ctx);\n+    visit::walk_crate(&mut ctx, crate, ());\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_struct_safe_for_destructor(cx: Context,\n+fn check_struct_safe_for_destructor(cx: &mut Context,\n                                     span: Span,\n                                     struct_did: DefId) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n@@ -120,7 +115,7 @@ fn check_struct_safe_for_destructor(cx: Context,\n     }\n }\n \n-fn check_impl_of_trait(cx: Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n+fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n     let ast_trait_def = cx.tcx.def_map.find(&trait_ref.ref_id)\n                             .expect(\"trait ref not in def map!\");\n     let trait_def_id = ast_util::def_id_of_def(*ast_trait_def);\n@@ -156,7 +151,7 @@ fn check_impl_of_trait(cx: Context, it: @item, trait_ref: &trait_ref, self_type:\n     }\n }\n \n-fn check_item(visitor: &mut KindAnalysisVisitor, item: @item, cx: Context) {\n+fn check_item(cx: &mut Context, item: @item) {\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n@@ -166,16 +161,15 @@ fn check_item(visitor: &mut KindAnalysisVisitor, item: @item, cx: Context) {\n         }\n     }\n \n-    let cx = Context { current_item: item.id, ..cx };\n-    visit::walk_item(visitor, item, cx);\n+    visit::walk_item(cx, item, ());\n }\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the NodeId for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: NodeId,\n-                            b: &fn(checker: &fn(Context, @freevar_entry))) {\n-    fn check_for_uniq(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n+fn with_appropriate_checker(cx: &Context, id: NodeId,\n+                            b: &fn(checker: &fn(&Context, @freevar_entry))) {\n+    fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n@@ -187,7 +181,7 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n         check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_box(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_box(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -198,7 +192,7 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n         check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_block(cx: Context, fv: &freevar_entry,\n+    fn check_for_block(cx: &Context, fv: &freevar_entry,\n                        bounds: ty::BuiltinBounds, region: ty::Region) {\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -209,7 +203,7 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n                              bounds, Some(var_t));\n     }\n \n-    fn check_for_bare(cx: Context, fv: @freevar_entry) {\n+    fn check_for_bare(cx: &Context, fv: @freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n             \"can't capture dynamic environment in a fn item; \\\n@@ -252,13 +246,12 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n fn check_fn(\n-    v: &mut KindAnalysisVisitor,\n+    cx: &mut Context,\n     fk: &visit::fn_kind,\n     decl: &fn_decl,\n     body: &Block,\n     sp: Span,\n-    fn_id: NodeId,\n-    cx: Context) {\n+    fn_id: NodeId) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -268,10 +261,10 @@ fn check_fn(\n         }\n     }\n \n-    visit::walk_fn(v, fk, decl, body, sp, fn_id, cx);\n+    visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());\n }\n \n-pub fn check_expr(v: &mut KindAnalysisVisitor, e: @Expr, cx: Context) {\n+pub fn check_expr(cx: &mut Context, e: @Expr) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n@@ -336,10 +329,10 @@ pub fn check_expr(v: &mut KindAnalysisVisitor, e: @Expr, cx: Context) {\n         }\n         _ => {}\n     }\n-    visit::walk_expr(v, e, cx);\n+    visit::walk_expr(cx, e, ());\n }\n \n-fn check_ty(v: &mut KindAnalysisVisitor, aty: &Ty, cx: Context) {\n+fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n@@ -354,11 +347,11 @@ fn check_ty(v: &mut KindAnalysisVisitor, aty: &Ty, cx: Context) {\n       }\n       _ => {}\n     }\n-    visit::walk_ty(v, aty, cx);\n+    visit::walk_ty(cx, aty, ());\n }\n \n // Calls \"any_missing\" if any bounds were missing.\n-pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n+pub fn check_builtin_bounds(cx: &Context, ty: ty::t, bounds: ty::BuiltinBounds,\n                             any_missing: &fn(ty::BuiltinBounds))\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n@@ -373,7 +366,7 @@ pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n     }\n }\n \n-pub fn check_typaram_bounds(cx: Context,\n+pub fn check_typaram_bounds(cx: &Context,\n                     _type_parameter_id: NodeId,\n                     sp: Span,\n                     ty: ty::t,\n@@ -389,7 +382,7 @@ pub fn check_typaram_bounds(cx: Context,\n     }\n }\n \n-pub fn check_freevar_bounds(cx: Context, sp: Span, ty: ty::t,\n+pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n@@ -412,7 +405,7 @@ pub fn check_freevar_bounds(cx: Context, sp: Span, ty: ty::t,\n     }\n }\n \n-pub fn check_trait_cast_bounds(cx: Context, sp: Span, ty: ty::t,\n+pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n         cx.tcx.sess.span_err(sp,\n@@ -423,7 +416,7 @@ pub fn check_trait_cast_bounds(cx: Context, sp: Span, ty: ty::t,\n     }\n }\n \n-fn is_nullary_variant(cx: Context, ex: @Expr) -> bool {\n+fn is_nullary_variant(cx: &Context, ex: @Expr) -> bool {\n     match ex.node {\n       ExprPath(_) => {\n         match cx.tcx.def_map.get_copy(&ex.id) {\n@@ -437,7 +430,7 @@ fn is_nullary_variant(cx: Context, ex: @Expr) -> bool {\n     }\n }\n \n-fn check_imm_free_var(cx: Context, def: Def, sp: Span) {\n+fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n     match def {\n         DefLocal(_, is_mutbl) => {\n             if is_mutbl {\n@@ -457,7 +450,7 @@ fn check_imm_free_var(cx: Context, def: Def, sp: Span) {\n     }\n }\n \n-fn check_copy(cx: Context, ty: ty::t, sp: Span, reason: &str) {\n+fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n     debug!(\"type_contents(%s)=%s\",\n            ty_to_str(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_str());\n@@ -469,7 +462,7 @@ fn check_copy(cx: Context, ty: ty::t, sp: Span, reason: &str) {\n     }\n }\n \n-pub fn check_send(cx: Context, ty: ty::t, sp: Span) -> bool {\n+pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_sendable(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n             sp, fmt!(\"value has non-sendable type `%s`\",\n@@ -525,7 +518,7 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n ///\n /// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n-    cx: Context,\n+    cx: &Context,\n     source: &Expr,\n     target: &Expr)\n {\n@@ -601,7 +594,7 @@ pub fn check_cast_for_escaping_regions(\n         }\n     }\n \n-    fn is_subregion_of(cx: Context, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+    fn is_subregion_of(cx: &Context, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n         cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n }"}]}