{"sha": "60cf413a20392ae38ffbf945e3d77f892655a74f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwY2Y0MTNhMjAzOTJhZTM4ZmZiZjk0NWUzZDc3Zjg5MjY1NWE3NGY=", "commit": {"author": {"name": "Simon Heath", "email": "icefox@dreamquest.io", "date": "2019-02-27T04:47:55Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-02-27T15:03:11Z"}, "message": "Incorporated review changes.", "tree": {"sha": "7f7616f986030ac3e9f9a20e43c91959c6ba5c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f7616f986030ac3e9f9a20e43c91959c6ba5c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60cf413a20392ae38ffbf945e3d77f892655a74f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60cf413a20392ae38ffbf945e3d77f892655a74f", "html_url": "https://github.com/rust-lang/rust/commit/60cf413a20392ae38ffbf945e3d77f892655a74f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60cf413a20392ae38ffbf945e3d77f892655a74f/comments", "author": {"login": "icefoxen", "id": 1335133, "node_id": "MDQ6VXNlcjEzMzUxMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1335133?v=4", "gravatar_id": "", "url": "https://api.github.com/users/icefoxen", "html_url": "https://github.com/icefoxen", "followers_url": "https://api.github.com/users/icefoxen/followers", "following_url": "https://api.github.com/users/icefoxen/following{/other_user}", "gists_url": "https://api.github.com/users/icefoxen/gists{/gist_id}", "starred_url": "https://api.github.com/users/icefoxen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/icefoxen/subscriptions", "organizations_url": "https://api.github.com/users/icefoxen/orgs", "repos_url": "https://api.github.com/users/icefoxen/repos", "events_url": "https://api.github.com/users/icefoxen/events{/privacy}", "received_events_url": "https://api.github.com/users/icefoxen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72afe51d81dd0824a009e378e9142ca7236806aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/72afe51d81dd0824a009e378e9142ca7236806aa", "html_url": "https://github.com/rust-lang/rust/commit/72afe51d81dd0824a009e378e9142ca7236806aa"}], "stats": {"total": 52, "additions": 35, "deletions": 17}, "files": [{"sha": "0fc182348c6c2f9d3ba5075c1f46808e6c6f1ea9", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60cf413a20392ae38ffbf945e3d77f892655a74f/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cf413a20392ae38ffbf945e3d77f892655a74f/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=60cf413a20392ae38ffbf945e3d77f892655a74f", "patch": "@@ -406,7 +406,9 @@ pub trait TryInto<T>: Sized {\n /// - `TryFrom<T> for U` implies [`TryInto<U>`]` for T`\n /// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n /// is implemented and cannot fail -- the associated `Error` type for\n-/// calling `T::try_from()` on a value of type `T` is `!`.\n+/// calling `T::try_from()` on a value of type `T` is `Infallible`.\n+/// When the `!` type is stablized `Infallible` and `!` will be\n+/// equivalent.\n ///\n /// # Examples\n ///"}, {"sha": "4a2f958b93fe77c47ae6a07e64060a49e6e82056", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/60cf413a20392ae38ffbf945e3d77f892655a74f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cf413a20392ae38ffbf945e3d77f892655a74f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=60cf413a20392ae38ffbf945e3d77f892655a74f", "patch": "@@ -4544,9 +4544,14 @@ macro_rules! try_from_unbounded {\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n-            /// Try to create the target type from the source type.\n-            /// This particular variant will never fail, but is included\n-            /// for completeness's sake.\n+            /// Try to create the target number type from a source\n+            /// number type.  If the source type has a larger range\n+            /// than the target, or their ranges are disjoint (such\n+            /// as converting a signed to unsigned number or vice \n+            /// versa), this will return `None` if the source value\n+            /// doesn't fit into the range of the destination value.\n+            /// If the conversion can never fail, this is still\n+            /// implemented for completeness's sake.\n             #[inline]\n             fn try_from(value: $source) -> Result<Self, Self::Error> {\n                 Ok(value as $target)\n@@ -4562,10 +4567,14 @@ macro_rules! try_from_lower_bounded {\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n-            /// Try to create a target number type from a\n-            /// source type that has `source::MIN > dest::MIN`.\n-            /// Will return an error if `source` is less than\n-            /// `dest::MIN`.\n+            /// Try to create the target number type from a source\n+            /// number type.  If the source type has a larger range\n+            /// than the target, or their ranges are disjoint (such\n+            /// as converting a signed to unsigned number or vice \n+            /// versa), this will return `None` if the source value\n+            /// doesn't fit into the range of the destination value.\n+            /// If the conversion can never fail, this is still\n+            /// implemented for completeness's sake.\n             #[inline]\n             fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                 if u >= 0 {\n@@ -4585,10 +4594,14 @@ macro_rules! try_from_upper_bounded {\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n-            /// Try to create a target number type from a\n-            /// source type that has `source::MAX > dest::MAX`.\n-            /// Will return an error if `source` is greater than\n-            /// `dest::MAX`.\n+            /// Try to create the target number type from a source\n+            /// number type.  If the source type has a larger range\n+            /// than the target, or their ranges are disjoint (such\n+            /// as converting a signed to unsigned number or vice \n+            /// versa), this will return `None` if the source value\n+            /// doesn't fit into the range of the destination value.\n+            /// If the conversion can never fail, this is still\n+            /// implemented for completeness's sake.\n             #[inline]\n             fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                 if u > (<$target>::max_value() as $source) {\n@@ -4608,11 +4621,14 @@ macro_rules! try_from_both_bounded {\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n-            /// Try to \"narrow\" a number from the source type\n-            /// to the target type.  Will return an error if\n-            /// the source value is either larger than the\n-            /// `MAX` value for the target type or smaller\n-            /// than the `MIN` value for it.\n+            /// Try to create the target number type from a source\n+            /// number type.  If the source type has a larger range\n+            /// than the target, or their ranges are disjoint (such\n+            /// as converting a signed to unsigned number or vice \n+            /// versa), this will return `None` if the source value\n+            /// doesn't fit into the range of the destination value.\n+            /// If the conversion can never fail, this is still\n+            /// implemented for completeness's sake.\n             #[inline]\n             fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n                 let min = <$target>::min_value() as $source;"}]}