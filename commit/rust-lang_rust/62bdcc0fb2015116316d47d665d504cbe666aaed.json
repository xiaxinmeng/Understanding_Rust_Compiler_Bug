{"sha": "62bdcc0fb2015116316d47d665d504cbe666aaed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYmRjYzBmYjIwMTUxMTYzMTZkNDdkNjY1ZDUwNGNiZTY2NmFhZWQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-29T12:19:08Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-29T12:19:08Z"}, "message": "Merge #1605\n\n1605: Resolve modules inside inline module r=matklad a=andreevlex\n\n#1510 \n\nCo-authored-by: Alexander Andreev <andreevlex.as@gmail.com>", "tree": {"sha": "350eac424760fdfa68d29d39fed22df98c547ece", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350eac424760fdfa68d29d39fed22df98c547ece"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62bdcc0fb2015116316d47d665d504cbe666aaed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62bdcc0fb2015116316d47d665d504cbe666aaed", "html_url": "https://github.com/rust-lang/rust/commit/62bdcc0fb2015116316d47d665d504cbe666aaed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62bdcc0fb2015116316d47d665d504cbe666aaed/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ad63fbe61a2e024bab8baadc22863a0795d20a95", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad63fbe61a2e024bab8baadc22863a0795d20a95", "html_url": "https://github.com/rust-lang/rust/commit/ad63fbe61a2e024bab8baadc22863a0795d20a95"}, {"sha": "3629268f71b69524bdc0ac01c1d9972dfd29b767", "url": "https://api.github.com/repos/rust-lang/rust/commits/3629268f71b69524bdc0ac01c1d9972dfd29b767", "html_url": "https://github.com/rust-lang/rust/commit/3629268f71b69524bdc0ac01c1d9972dfd29b767"}], "stats": {"total": 201, "additions": 152, "deletions": 49}, "files": [{"sha": "06b7322153203bbf8c97e6c2c7e799d662e65a08", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 114, "deletions": 34, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/62bdcc0fb2015116316d47d665d504cbe666aaed/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62bdcc0fb2015116316d47d665d504cbe666aaed/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=62bdcc0fb2015116316d47d665d504cbe666aaed", "patch": "@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n+use std::sync::Arc;\n \n-use arrayvec::ArrayVec;\n-use ra_db::FileId;\n+use ra_db::{FileId, SourceRoot};\n use ra_syntax::{ast, SmolStr};\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashMap;\n@@ -105,6 +105,7 @@ where\n             module_id,\n             file_id: file_id.into(),\n             raw_items: &raw_items,\n+            parent_module: None,\n         }\n         .collect(raw_items.items());\n \n@@ -455,8 +456,14 @@ where\n         if !self.macro_stack_monitor.is_poison(macro_def_id) {\n             let file_id: HirFileId = macro_call_id.as_file(MacroFileKind::Items);\n             let raw_items = self.db.raw_items(file_id);\n-            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items());\n+            ModCollector {\n+                def_collector: &mut *self,\n+                file_id,\n+                module_id,\n+                raw_items: &raw_items,\n+                parent_module: None,\n+            }\n+            .collect(raw_items.items());\n         } else {\n             log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n             self.def_map.poison_macros.insert(macro_def_id);\n@@ -476,6 +483,7 @@ struct ModCollector<'a, D> {\n     module_id: CrateModuleId,\n     file_id: HirFileId,\n     raw_items: &'a raw::RawItems,\n+    parent_module: Option<&'a Name>,\n }\n \n impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n@@ -508,6 +516,7 @@ where\n                     module_id,\n                     file_id: self.file_id,\n                     raw_items: self.raw_items,\n+                    parent_module: Some(name),\n                 }\n                 .collect(&*items);\n             }\n@@ -521,6 +530,7 @@ where\n                     name,\n                     is_root,\n                     attr_path.as_ref(),\n+                    self.parent_module,\n                 ) {\n                     Ok(file_id) => {\n                         let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n@@ -530,6 +540,7 @@ where\n                             module_id,\n                             file_id: file_id.into(),\n                             raw_items: &raw_items,\n+                            parent_module: None,\n                         }\n                         .collect(raw_items.items())\n                     }\n@@ -636,46 +647,47 @@ fn resolve_submodule(\n     name: &Name,\n     is_root: bool,\n     attr_path: Option<&SmolStr>,\n+    parent_module: Option<&Name>,\n ) -> Result<FileId, RelativePathBuf> {\n-    // FIXME: handle submodules of inline modules properly\n     let file_id = file_id.original_file(db);\n     let source_root_id = db.file_source_root(file_id);\n     let path = db.file_relative_path(file_id);\n     let root = RelativePathBuf::default();\n     let dir_path = path.parent().unwrap_or(&root);\n     let mod_name = path.file_stem().unwrap_or(\"unknown\");\n-    let is_dir_owner = is_root || mod_name == \"mod\";\n-\n-    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n-    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n-    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-    let mut candidates = ArrayVec::<[_; 3]>::new();\n-    let file_attr_mod = attr_path.map(|file_path| {\n-        let file_path = normalize_attribute_path(file_path);\n-        let file_attr_mod = dir_path.join(file_path.as_ref()).normalize();\n-        candidates.push(file_attr_mod.clone());\n-\n-        file_attr_mod\n-    });\n-    if is_dir_owner {\n-        candidates.push(file_mod.clone());\n-        candidates.push(dir_mod);\n-    } else {\n-        candidates.push(file_dir_mod.clone());\n-    };\n-    let sr = db.source_root(source_root_id);\n-    let mut points_to = candidates.into_iter().filter_map(|path| sr.files.get(&path)).copied();\n-    // FIXME: handle ambiguity\n-    match points_to.next() {\n-        Some(file_id) => Ok(file_id),\n-        None => {\n-            if let Some(file_attr_mod) = file_attr_mod {\n-                Err(file_attr_mod)\n+\n+    let resolve_mode = match (attr_path.filter(|p| !p.is_empty()), parent_module) {\n+        (Some(file_path), Some(parent_name)) => {\n+            let file_path = normalize_attribute_path(file_path);\n+            let path = dir_path.join(format!(\"{}/{}\", parent_name, file_path)).normalize();\n+            ResolutionMode::InsideInlineModule(InsideInlineModuleMode::WithAttributePath(path))\n+        }\n+        (Some(file_path), None) => {\n+            let file_path = normalize_attribute_path(file_path);\n+            let path = dir_path.join(file_path.as_ref()).normalize();\n+            ResolutionMode::OutOfLine(OutOfLineMode::WithAttributePath(path))\n+        }\n+        (None, Some(parent_name)) => {\n+            let path = dir_path.join(format!(\"{}/{}.rs\", parent_name, name));\n+            ResolutionMode::InsideInlineModule(InsideInlineModuleMode::File(path))\n+        }\n+        _ => {\n+            let is_dir_owner = is_root || mod_name == \"mod\";\n+            if is_dir_owner {\n+                let file_mod = dir_path.join(format!(\"{}.rs\", name));\n+                let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n+                ResolutionMode::OutOfLine(OutOfLineMode::RootOrModRs {\n+                    file: file_mod,\n+                    directory: dir_mod,\n+                })\n             } else {\n-                Err(if is_dir_owner { file_mod } else { file_dir_mod })\n+                let path = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n+                ResolutionMode::OutOfLine(OutOfLineMode::FileInDirectory(path))\n             }\n         }\n-    }\n+    };\n+\n+    resolve_mode.resolve(db.source_root(source_root_id))\n }\n \n fn normalize_attribute_path(file_path: &SmolStr) -> Cow<str> {\n@@ -693,6 +705,74 @@ fn normalize_attribute_path(file_path: &SmolStr) -> Cow<str> {\n     }\n }\n \n+enum OutOfLineMode {\n+    RootOrModRs { file: RelativePathBuf, directory: RelativePathBuf },\n+    FileInDirectory(RelativePathBuf),\n+    WithAttributePath(RelativePathBuf),\n+}\n+\n+impl OutOfLineMode {\n+    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n+        match self {\n+            OutOfLineMode::RootOrModRs { file, directory } => match source_root.files.get(file) {\n+                None => resolve_simple_path(source_root, directory).map_err(|_| file.clone()),\n+                file_id => resolve_find_result(file_id, file),\n+            },\n+            OutOfLineMode::FileInDirectory(path) => resolve_simple_path(source_root, path),\n+            OutOfLineMode::WithAttributePath(path) => resolve_simple_path(source_root, path),\n+        }\n+    }\n+}\n+\n+enum InsideInlineModuleMode {\n+    File(RelativePathBuf),\n+    WithAttributePath(RelativePathBuf),\n+}\n+\n+impl InsideInlineModuleMode {\n+    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n+        match self {\n+            InsideInlineModuleMode::File(path) => resolve_simple_path(source_root, path),\n+            InsideInlineModuleMode::WithAttributePath(path) => {\n+                resolve_simple_path(source_root, path)\n+            }\n+        }\n+    }\n+}\n+\n+enum ResolutionMode {\n+    OutOfLine(OutOfLineMode),\n+    InsideInlineModule(InsideInlineModuleMode),\n+}\n+\n+impl ResolutionMode {\n+    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n+        use self::ResolutionMode::*;\n+\n+        match self {\n+            OutOfLine(mode) => mode.resolve(source_root),\n+            InsideInlineModule(mode) => mode.resolve(source_root),\n+        }\n+    }\n+}\n+\n+fn resolve_simple_path(\n+    source_root: Arc<SourceRoot>,\n+    path: &RelativePathBuf,\n+) -> Result<FileId, RelativePathBuf> {\n+    resolve_find_result(source_root.files.get(path), path)\n+}\n+\n+fn resolve_find_result(\n+    file_id: Option<&FileId>,\n+    path: &RelativePathBuf,\n+) -> Result<FileId, RelativePathBuf> {\n+    match file_id {\n+        Some(file_id) => Ok(file_id.clone()),\n+        None => Err(path.clone()),\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ra_db::SourceDatabase;"}, {"sha": "38272814992c0bf3e6173dc301d362d0d5f0d583", "filename": "crates/ra_hir/src/nameres/tests/mods.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/62bdcc0fb2015116316d47d665d504cbe666aaed/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62bdcc0fb2015116316d47d665d504cbe666aaed/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs?ref=62bdcc0fb2015116316d47d665d504cbe666aaed", "patch": "@@ -336,10 +336,10 @@ fn module_resolution_explicit_path_mod_rs_with_win_separator() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n-fn module_resolution_decl_inside_inline_module() {\n+fn module_resolution_decl_inside_inline_module_with_path_attribute() {\n     let map = def_map_with_crate_graph(\n         r###\"\n         //- /main.rs\n@@ -368,10 +368,39 @@ fn module_resolution_decl_inside_inline_module() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+#[test]\n+fn module_resolution_decl_inside_inline_module() {\n+    let map = def_map_with_crate_graph(\n+        r###\"\n+        //- /main.rs\n+        mod foo {\n+            mod bar;\n+        }\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \"###,\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::foo\n+        \u22eebar: t\n+        \u22ee\n+        \u22eecrate::foo::bar\n+        \u22eeBaz: t v\n+    \"###);\n+}\n+\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n-fn module_resolution_decl_inside_inline_module_2() {\n+fn module_resolution_decl_inside_inline_module_2_with_path_attribute() {\n     let map = def_map_with_crate_graph(\n         r###\"\n         //- /main.rs\n@@ -400,7 +429,7 @@ fn module_resolution_decl_inside_inline_module_2() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_3() {\n@@ -433,7 +462,7 @@ fn module_resolution_decl_inside_inline_module_3() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_empty_path() {\n@@ -491,7 +520,7 @@ fn module_resolution_decl_empty_path() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_relative_path() {\n@@ -523,9 +552,7 @@ fn module_resolution_decl_inside_inline_module_relative_path() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n #[test]\n-#[ignore]\n fn module_resolution_decl_inside_inline_module_in_crate_root() {\n     let map = def_map_with_crate_graph(\n         r###\"\n@@ -557,9 +584,7 @@ fn module_resolution_decl_inside_inline_module_in_crate_root() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n #[test]\n-#[ignore]\n fn module_resolution_decl_inside_inline_module_in_mod_rs() {\n     let map = def_map_with_crate_graph(\n         r###\"\n@@ -597,9 +622,7 @@ fn module_resolution_decl_inside_inline_module_in_mod_rs() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n #[test]\n-#[ignore]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n     let map = def_map_with_crate_graph(\n         r###\"\n@@ -613,7 +636,7 @@ fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n         }\n         use self::bar::baz::Baz;\n \n-        //- /foo/bar/qwe.rs\n+        //- /bar/qwe.rs\n         pub struct Baz;\n         \"###,\n         crate_graph! {\n@@ -637,7 +660,7 @@ fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root_2() {"}]}