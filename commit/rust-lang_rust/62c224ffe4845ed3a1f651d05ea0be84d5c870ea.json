{"sha": "62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYzIyNGZmZTQ4NDVlZDNhMWY2NTFkMDVlYTBiZTg0ZDVjODcwZWE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-30T23:10:30Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-30T23:10:30Z"}, "message": "Drop slots on block exits even when blocks have no statements. Part way to fixing bind leakage in rustc.", "tree": {"sha": "4b5fdc0220f369b0cae5784c1d076fe502a78df0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b5fdc0220f369b0cae5784c1d076fe502a78df0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "html_url": "https://github.com/rust-lang/rust/commit/62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e3e6903b20df01a6abe36d741c39d6e9696ebb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e3e6903b20df01a6abe36d741c39d6e9696ebb", "html_url": "https://github.com/rust-lang/rust/commit/f6e3e6903b20df01a6abe36d741c39d6e9696ebb"}], "stats": {"total": 246, "additions": 156, "deletions": 90}, "files": [{"sha": "c82331db8f2c7124a7de6cac7b138afe41bfcd37", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "patch": "@@ -462,6 +462,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       deep.rs \\\n                       deref.rs \\\n                       destructor-ordering.rs \\\n+                      drop-on-empty-block-exit.rs \\\n                       export-non-interference.rs \\\n                       exterior.rs \\\n                       fn-lval.rs \\"}, {"sha": "78b3ac51a97f26b7283ea3ecffc11bde339953f6", "filename": "src/boot/fe/ast.ml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "patch": "@@ -1545,6 +1545,7 @@ and fmt_pat (ff:Format.formatter) (pat:pat) : unit =\n         fmt_lval ff ctor;\n         fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_pat ff pats\n     | PAT_slot (_, ident) ->\n+        fmt ff \"?\";\n         fmt_ident ff ident\n     | PAT_wild ->\n         fmt ff \"_\""}, {"sha": "b5548e2cd8724d00696f7fc628bbc402a2a97f74", "filename": "src/boot/me/loop.ml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Floop.ml", "raw_url": "https://github.com/rust-lang/rust/raw/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Floop.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Floop.ml?ref=62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "patch": "@@ -114,6 +114,8 @@ let loop_depth_visitor\n   let visit_block_pre b =\n     if Hashtbl.mem cx.ctxt_block_is_loop_body b.id\n     then push_loop ();\n+    let fcx = Stack.top fcxs in\n+      htab_put cx.ctxt_block_loop_depths b.id fcx.current_depth;\n     inner.Walk.visit_block_pre b\n   in\n "}, {"sha": "7f5e4cda684b5060a1e65c95f7f3d8e5297095e9", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "patch": "@@ -131,6 +131,7 @@ type ctxt =\n       (* Typestate-y stuff. *)\n       ctxt_stmt_is_init: (node_id,unit) Hashtbl.t;\n       ctxt_post_stmt_slot_drops: (node_id,node_id list) Hashtbl.t;\n+      ctxt_post_block_slot_drops: (node_id,node_id list) Hashtbl.t;\n \n       (* Layout-y stuff. *)\n       ctxt_slot_aliased: (node_id,unit) Hashtbl.t;\n@@ -141,6 +142,7 @@ type ctxt =\n       ctxt_call_sizes: (node_id,size) Hashtbl.t;\n       ctxt_block_is_loop_body: (node_id,unit) Hashtbl.t;\n       ctxt_stmt_loop_depths: (node_id,int) Hashtbl.t;\n+      ctxt_block_loop_depths: (node_id,int) Hashtbl.t;\n       ctxt_slot_loop_depths: (node_id,int) Hashtbl.t;\n \n       (* Translation-y stuff. *)\n@@ -216,6 +218,7 @@ let new_ctxt sess abi crate =\n \n     ctxt_stmt_is_init = Hashtbl.create 0;\n     ctxt_post_stmt_slot_drops = Hashtbl.create 0;\n+    ctxt_post_block_slot_drops = Hashtbl.create 0;\n \n     ctxt_slot_aliased = Hashtbl.create 0;\n     ctxt_slot_is_obj_state = Hashtbl.create 0;\n@@ -227,6 +230,7 @@ let new_ctxt sess abi crate =\n     ctxt_block_is_loop_body = Hashtbl.create 0;\n     ctxt_slot_loop_depths = Hashtbl.create 0;\n     ctxt_stmt_loop_depths = Hashtbl.create 0;\n+    ctxt_block_loop_depths = Hashtbl.create 0;\n \n     ctxt_fn_fixups = Hashtbl.create 0;\n     ctxt_block_fixups = Hashtbl.create 0;\n@@ -399,6 +403,10 @@ let get_stmt_depth (cx:ctxt) (id:node_id) : int =\n   Hashtbl.find cx.ctxt_stmt_loop_depths id\n ;;\n \n+let get_block_depth (cx:ctxt) (id:node_id) : int =\n+  Hashtbl.find cx.ctxt_block_loop_depths id\n+;;\n+\n let get_slot_depth (cx:ctxt) (id:node_id) : int =\n   Hashtbl.find cx.ctxt_slot_loop_depths id\n ;;"}, {"sha": "d8be85bfcc7de0c29ada78c57e3acf357a0e5dda", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 73, "deletions": 37, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "patch": "@@ -826,10 +826,51 @@ let trans_visitor\n       out diff current_fp\n   in\n \n+  let curr_stmt_depth _ =\n+    if (Stack.is_empty curr_stmt)\n+    then None\n+    else\n+      Some\n+        (get_stmt_depth cx (Stack.top curr_stmt))\n+  in\n+\n   let cell_of_block_slot\n+      ?access_depth:(access_depth=curr_stmt_depth())\n       (slot_id:node_id)\n       : Il.cell =\n+\n     let referent_type = slot_id_referent_type slot_id in\n+\n+    let local_access off =\n+      Il.Mem (fp_off_sz off, referent_type)\n+    in\n+\n+    let outer_access off slot_depth depth =\n+      let _ = assert (slot_depth < depth) in\n+        let _ =\n+          iflog\n+            begin\n+              fun _ ->\n+                let k =\n+                  Hashtbl.find cx.ctxt_slot_keys slot_id\n+                in\n+                  annotate (Printf.sprintf\n+                              \"access outer frame slot #%d = %s\"\n+                              (int_of_node slot_id)\n+                              (Fmt.fmt_to_str Ast.fmt_slot_key k))\n+            end\n+        in\n+        let diff = depth - slot_depth in\n+        let _ = annotate \"get outer frame pointer\" in\n+        let fp = get_nth_outer_frame_ptr diff in\n+        let _ = annotate \"calculate size\" in\n+        let p =\n+          based_sz (get_ty_params_of_current_frame())\n+            (fst (force_to_reg (Il.Cell fp))) off\n+        in\n+          Il.Mem (p, referent_type)\n+    in\n+\n       match htab_search cx.ctxt_slot_vregs slot_id with\n           Some vr ->\n             begin\n@@ -865,43 +906,15 @@ let trans_visitor\n                           Il.Mem (slot_mem, referent_type)\n                       end\n                     else\n-                      if (Stack.is_empty curr_stmt)\n-                      then\n-                        Il.Mem (fp_off_sz off, referent_type)\n-                      else\n-                        let slot_depth = get_slot_depth cx slot_id in\n-                        let stmt_depth =\n-                          get_stmt_depth cx (Stack.top curr_stmt)\n-                        in\n-                          if slot_depth <> stmt_depth\n-                          then\n-                            let _ = assert (slot_depth < stmt_depth) in\n-                            let _ =\n-                              iflog\n-                                begin\n-                                  fun _ ->\n-                                    let k =\n-                                      Hashtbl.find cx.ctxt_slot_keys slot_id\n-                                    in\n-                                      annotate\n-                                        (Printf.sprintf\n-                                           \"access outer frame slot #%d = %s\"\n-                                           (int_of_node slot_id)\n-                                           (Fmt.fmt_to_str\n-                                              Ast.fmt_slot_key k))\n-                                end\n-                            in\n-                            let diff = stmt_depth - slot_depth in\n-                            let _ = annotate \"get outer frame pointer\" in\n-                            let fp = get_nth_outer_frame_ptr diff in\n-                            let _ = annotate \"calculate size\" in\n-                            let p =\n-                              based_sz (get_ty_params_of_current_frame())\n-                                (fst (force_to_reg (Il.Cell fp))) off\n-                            in\n-                              Il.Mem (p, referent_type)\n-                          else\n-                            Il.Mem (fp_off_sz off, referent_type)\n+                      match access_depth with\n+                          None -> local_access off\n+                        | Some depth ->\n+                            let slot_depth = get_slot_depth cx slot_id in\n+                              if slot_depth <> depth\n+                              then\n+                                outer_access off slot_depth depth\n+                              else\n+                                local_access off\n             end\n   in\n \n@@ -2434,12 +2447,35 @@ let trans_visitor\n         | Ast.EXPR_atom a ->\n             trans_atom a\n \n+  and drop_slots_after_block bid : unit =\n+    match htab_search cx.ctxt_post_block_slot_drops bid with\n+        None -> ()\n+      | Some slots ->\n+          List.iter\n+            begin\n+              fun slot_id ->\n+                let slot = get_slot cx slot_id in\n+                let k = Hashtbl.find cx.ctxt_slot_keys slot_id in\n+                let depth = Hashtbl.find cx.ctxt_block_loop_depths bid in\n+                  iflog (fun _ ->\n+                           annotate\n+                             (Printf.sprintf\n+                                \"post-block, drop_slot %d = %s \"\n+                                (int_of_node slot_id)\n+                                (Fmt.fmt_to_str Ast.fmt_slot_key k)));\n+                  drop_slot_in_current_frame\n+                    (cell_of_block_slot\n+                       ~access_depth:(Some depth) slot_id) slot\n+            end\n+            slots\n+\n   and trans_block (block:Ast.block) : unit =\n     flush_emitter_size_cache();\n     trace_str cx.ctxt_sess.Session.sess_trace_block\n       \"entering block\";\n     emit (Il.Enter (Hashtbl.find cx.ctxt_block_fixups block.id));\n     Array.iter trans_stmt block.node;\n+    drop_slots_after_block block.id;\n     trace_str cx.ctxt_sess.Session.sess_trace_block\n       \"exiting block\";\n     emit Il.Leave;"}, {"sha": "81781d3422277ae40baf578814aadfe87db127a6", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 60, "deletions": 53, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "patch": "@@ -449,9 +449,12 @@ type slots_stack = node_id Stack.t;;\n type block_slots_stack = slots_stack Stack.t;;\n type frame_block_slots_stack = block_slots_stack Stack.t;;\n type loop_block_slots_stack = block_slots_stack option Stack.t;;\n-(* like ret drops slots from all blocks in the frame\n- * break from a simple loo drops slots from all block in a loop *)\n-let (loop_blocks:loop_block_slots_stack) = \n+\n+(* Like ret drops slots from all blocks in the frame\n+ * break from a simple loop drops slots from all block in a loop\n+ *)\n+\n+let (loop_blocks:loop_block_slots_stack) =\n   let s = Stack.create() in Stack.push None s; s\n \n let condition_assigning_visitor\n@@ -583,7 +586,7 @@ let condition_assigning_visitor\n           let precond = slot_inits (lval_slots cx lval) in\n             raise_precondition sid precond;\n   in\n-    \n+\n   let visit_stmt_pre s =\n     begin\n       match s.node with\n@@ -1317,11 +1320,12 @@ let lifecycle_visitor\n \n \n   let visit_block_pre b =\n-   \n+\n     let s = Stack.create() in\n       begin\n-        match Stack.top loop_blocks with \n-            Some loop -> Stack.push s loop | None -> ()\n+        match Stack.top loop_blocks with\n+            Some loop -> Stack.push s loop\n+          | None -> ()\n       end;\n       Stack.push s (Stack.top frame_blocks);\n       begin\n@@ -1337,7 +1341,7 @@ let lifecycle_visitor\n       inner.Walk.visit_block_pre b\n   in\n \n-  let note_drops stmt slots =\n+  let note_stmt_drops stmt slots =\n     iflog cx\n       begin\n         fun _ ->\n@@ -1352,6 +1356,21 @@ let lifecycle_visitor\n     htab_put cx.ctxt_post_stmt_slot_drops stmt.id slots\n   in\n \n+  let note_block_drops bid slots =\n+    iflog cx\n+      begin\n+        fun _ ->\n+          log cx \"implicit drop of %d slots after block %d: \"\n+            (List.length slots)\n+            (int_of_node bid);\n+          List.iter (fun s -> log cx \"drop: %a\"\n+                       Ast.sprintf_slot_key\n+                       (Hashtbl.find cx.ctxt_slot_keys s))\n+            slots\n+      end;\n+    htab_put cx.ctxt_post_block_slot_drops bid slots\n+  in\n+\n   let filter_live_block_slots slots =\n     List.filter (fun i -> Hashtbl.mem live_block_slots i) slots\n   in\n@@ -1360,37 +1379,24 @@ let lifecycle_visitor\n     inner.Walk.visit_block_post b;\n     begin\n       match Stack.top loop_blocks with\n-          Some loop -> \n-            ignore(Stack.pop loop);\n-            if Stack.is_empty loop then\n-              ignore(Stack.pop loop_blocks);\n+          Some loop ->\n+            ignore (Stack.pop loop);\n+            if Stack.is_empty loop\n+            then ignore (Stack.pop loop_blocks);\n         | None -> ()\n     end;\n     let block_slots = Stack.pop (Stack.top frame_blocks) in\n-    let stmts = b.node in\n-    let len = Array.length stmts in\n-      if len > 0\n-      then\n-        begin\n-          let s = stmts.(len-1) in\n-            match s.node with\n-                Ast.STMT_ret _\n-              | Ast.STMT_be _ \n-              | Ast.STMT_break ->\n-                  () (* Taken care of in visit_stmt_post below. *)\n-              | _ ->\n-                (* The blk_slots stack we have has accumulated slots in\n-                 * declaration order as we walked the block; the top of the\n-                 * stack is the last-declared slot. We want to generate\n-                 * slot-drop obligations here for the slots in top-down order\n-                 * (starting with the last-declared) but only hitting those\n-                 * slots that actually got initialized (went live) at some\n-                 * point in the block.\n-                 *)\n-                let slots = stk_elts_from_top block_slots in\n-                let live = filter_live_block_slots slots in\n-                  note_drops s live\n-        end;\n+      (* The blk_slots stack we have has accumulated slots in\n+       * declaration order as we walked the block; the top of the\n+       * stack is the last-declared slot. We want to generate\n+       * slot-drop obligations here for the slots in top-down order\n+       * (starting with the last-declared) but only hitting those\n+       * slots that actually got initialized (went live) at some\n+       * point in the block.\n+       *)\n+    let slots = stk_elts_from_top block_slots in\n+    let live = filter_live_block_slots slots in\n+      note_block_drops b.id live\n   in\n \n   let visit_stmt_pre s =\n@@ -1499,33 +1505,34 @@ let lifecycle_visitor\n \n   let visit_stmt_post s =\n     inner.Walk.visit_stmt_post s;\n-    let handle_ret_like_stmt block_stack =\n+\n+    let handle_outward_jump_stmt block_stack =\n       let blocks = stk_elts_from_top block_stack in\n           let slots = List.concat (List.map stk_elts_from_top blocks) in\n           let live = filter_live_block_slots slots in\n-            note_drops s live\n+            note_stmt_drops s live\n     in\n-    match s.node with\n-        Ast.STMT_ret _\n-      | Ast.STMT_be _ ->\n-          handle_ret_like_stmt (Stack.top frame_blocks)\n-      | Ast.STMT_break ->\n-          begin\n-            match (Stack.top loop_blocks) with\n-                Some loop -> handle_ret_like_stmt loop\n-              | None -> \n-                  iflog cx (fun _ ->\n-                              log cx \"break statement outside of a loop\");\n-                  err (Some s.id) \"break statement outside of a loop\"\n-          end\n-      | _ -> ()\n+\n+      match s.node with\n+          Ast.STMT_ret _\n+        | Ast.STMT_be _ ->\n+            handle_outward_jump_stmt (Stack.top frame_blocks)\n+\n+        | Ast.STMT_break ->\n+            begin\n+              match (Stack.top loop_blocks) with\n+                  Some loop -> handle_outward_jump_stmt loop\n+                | None ->\n+                    err (Some s.id) \"break statement outside of a loop\"\n+            end\n+        | _ -> ()\n   in\n \n   let enter_frame _ =\n     Stack.push (Stack.create()) frame_blocks;\n     Stack.push None loop_blocks\n   in\n-    \n+\n   let leave_frame _ =\n     ignore (Stack.pop frame_blocks);\n     match Stack.pop loop_blocks with"}, {"sha": "988f4358c56d17c13edb97269a68f69278c1e732", "filename": "src/test/run-pass/drop-on-empty-block-exit.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c224ffe4845ed3a1f651d05ea0be84d5c870ea/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs?ref=62c224ffe4845ed3a1f651d05ea0be84d5c870ea", "patch": "@@ -0,0 +1,11 @@\n+tag t {\n+  foo(@int);\n+}\n+\n+fn main() {\n+  auto tt = foo(@10);\n+  alt (tt) {\n+    case (foo(?z)) {\n+    }\n+  }\n+}\n\\ No newline at end of file"}]}