{"sha": "dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZWVmMGVkYjJkMjVhM2ZmMzIxZDhlMDk1MzJmMDUzYjVlZjJjMDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:07:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:28:07Z"}, "message": "rollup merge of #19972: alexcrichton/snapshots\n\nConflicts:\n\tsrc/libcollections/string.rs\n\tsrc/libcollections/vec.rs\n\tsrc/snapshots.txt", "tree": {"sha": "9ac43217e9134d908926c2aa7bfda279582f1ee6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ac43217e9134d908926c2aa7bfda279582f1ee6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "html_url": "https://github.com/rust-lang/rust/commit/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b084cda4e9e0540b67d5db728b58acf8afba9f6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b084cda4e9e0540b67d5db728b58acf8afba9f6e", "html_url": "https://github.com/rust-lang/rust/commit/b084cda4e9e0540b67d5db728b58acf8afba9f6e"}, {"sha": "84086c464f537591f0e4629676b3fc75517492ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/84086c464f537591f0e4629676b3fc75517492ab", "html_url": "https://github.com/rust-lang/rust/commit/84086c464f537591f0e4629676b3fc75517492ab"}], "stats": {"total": 833, "additions": 0, "deletions": 833}, "files": [{"sha": "e4328a3cb202bfc6e6e5432c02825d255c7ce45d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -448,30 +448,6 @@ impl<T: Ord> Default for BTreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> Sub<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3,4,5].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a - b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,2]);\n-    /// ```\n-    fn sub(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -493,30 +469,6 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitXor<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2,3,4].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a ^ b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,4]);\n-    /// ```\n-    fn bitxor(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.symmetric_difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -538,30 +490,6 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitAnd<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2,3,4].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a & b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![2,3]);\n-    /// ```\n-    fn bitand(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.intersection(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -583,30 +511,6 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitOr<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3,4,5].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a | b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,2,3,4,5]);\n-    /// ```\n-    fn bitor(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.union(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///"}, {"sha": "bb762f4fb4e408819287522e43141d47442b16d3", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -183,60 +183,24 @@ impl<E:CLike> EnumSet<E> {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & !e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & !e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitxor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits ^ e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits ^ e.bits}"}, {"sha": "db59424cedd64c9b77104fed882fa29d85cd7017", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -862,28 +862,7 @@ impl<'a, S: Str> Equiv<S> for String {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n #[experimental = \"waiting on Add stabilization\"]\n-impl<S: Str> Add<S, String> for String {\n-    /// Concatenates `self` and `other` as a new mutable `String`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let string1 = \"foo\".to_string();\n-    /// let string2 = \"bar\".to_string();\n-    /// let string3 = string1 + string2;\n-    /// assert_eq!(string3, \"foobar\".to_string());\n-    /// ```\n-    fn add(&self, other: &S) -> String {\n-        let mut s = String::from_str(self.as_slice());\n-        s.push_str(other.as_slice());\n-        return s;\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a> Add<&'a str, String> for String {\n     fn add(mut self, other: &str) -> String {\n         self.push_str(other);"}, {"sha": "ec2a7c7a06ca776154dad482820719ab71be0baf", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -1361,20 +1361,6 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Clone, Sized? V: AsSlice<T>> Add<V, Vec<T>> for Vec<T> {\n-    #[inline]\n-    fn add(&self, rhs: &V) -> Vec<T> {\n-        let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n-        res.push_all(self.as_slice());\n-        res.push_all(rhs.as_slice());\n-        res\n-    }\n-}\n-\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove impl after a snapshot\n impl<'a, T: Clone> Add<&'a [T], Vec<T>> for Vec<T> {\n     #[inline]\n     fn add(mut self, rhs: &[T]) -> Vec<T> {"}, {"sha": "e752fd11ee5b27fe41194cf02cdec9cb241c8204", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 437, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -92,46 +92,6 @@ pub trait Drop {\n /// struct Foo;\n ///\n /// impl Add<Foo, Foo> for Foo {\n-///     fn add(&self, _rhs: &Foo) -> Foo {\n-///       println!(\"Adding!\");\n-///       *self\n-///   }\n-/// }\n-///\n-/// fn main() {\n-///   Foo + Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"add\"]\n-pub trait Add<Sized? RHS,Result> for Sized? {\n-    /// The method for the `+` operator\n-    fn add(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! add_impl {\n-    ($($t:ty)*) => ($(\n-        impl Add<$t, $t> for $t {\n-            #[inline]\n-            fn add(&self, other: &$t) -> $t { (*self) + (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Add` trait is used to specify the functionality of `+`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n-/// calling `add`, and therefore, `main` prints `Adding!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Add<Foo, Foo> for Foo {\n ///     fn add(self, _rhs: Foo) -> Foo {\n ///       println!(\"Adding!\");\n ///       self\n@@ -142,14 +102,12 @@ macro_rules! add_impl {\n ///   Foo + Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"add\"]\n pub trait Add<RHS, Result> {\n     /// The method for the `+` operator\n     fn add(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n         impl Add<$t, $t> for $t {\n@@ -173,46 +131,6 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Sub<Foo, Foo> for Foo {\n-///     fn sub(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Subtracting!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo - Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"sub\"]\n-pub trait Sub<Sized? RHS, Result> for Sized? {\n-    /// The method for the `-` operator\n-    fn sub(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! sub_impl {\n-    ($($t:ty)*) => ($(\n-        impl Sub<$t, $t> for $t {\n-            #[inline]\n-            fn sub(&self, other: &$t) -> $t { (*self) - (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Sub` trait is used to specify the functionality of `-`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n-/// calling `sub`, and therefore, `main` prints `Subtracting!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Sub<Foo, Foo> for Foo {\n ///     fn sub(self, _rhs: Foo) -> Foo {\n ///         println!(\"Subtracting!\");\n ///         self\n@@ -223,14 +141,12 @@ macro_rules! sub_impl {\n ///     Foo - Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"sub\"]\n pub trait Sub<RHS, Result> {\n     /// The method for the `-` operator\n     fn sub(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n         impl Sub<$t, $t> for $t {\n@@ -254,46 +170,6 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Mul<Foo, Foo> for Foo {\n-///     fn mul(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Multiplying!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo * Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"mul\"]\n-pub trait Mul<Sized? RHS, Result>  for Sized? {\n-    /// The method for the `*` operator\n-    fn mul(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! mul_impl {\n-    ($($t:ty)*) => ($(\n-        impl Mul<$t, $t> for $t {\n-            #[inline]\n-            fn mul(&self, other: &$t) -> $t { (*self) * (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Mul` trait is used to specify the functionality of `*`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n-/// calling `mul`, and therefore, `main` prints `Multiplying!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Mul<Foo, Foo> for Foo {\n ///     fn mul(self, _rhs: Foo) -> Foo {\n ///         println!(\"Multiplying!\");\n ///         self\n@@ -304,14 +180,12 @@ macro_rules! mul_impl {\n ///     Foo * Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"mul\"]\n pub trait Mul<RHS, Result> {\n     /// The method for the `*` operator\n     fn mul(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n         impl Mul<$t, $t> for $t {\n@@ -335,46 +209,6 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Div<Foo, Foo> for Foo {\n-///     fn div(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Dividing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo / Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"div\"]\n-pub trait Div<Sized? RHS, Result> for Sized? {\n-    /// The method for the `/` operator\n-    fn div(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! div_impl {\n-    ($($t:ty)*) => ($(\n-        impl Div<$t, $t> for $t {\n-            #[inline]\n-            fn div(&self, other: &$t) -> $t { (*self) / (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Div` trait is used to specify the functionality of `/`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n-/// calling `div`, and therefore, `main` prints `Dividing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Div<Foo, Foo> for Foo {\n ///     fn div(self, _rhs: Foo) -> Foo {\n ///         println!(\"Dividing!\");\n ///         self\n@@ -385,14 +219,12 @@ macro_rules! div_impl {\n ///     Foo / Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"div\"]\n pub trait Div<RHS, Result> {\n     /// The method for the `/` operator\n     fn div(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n         impl Div<$t, $t> for $t {\n@@ -416,60 +248,6 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Rem<Foo, Foo> for Foo {\n-///     fn rem(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Remainder-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo % Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"rem\"]\n-pub trait Rem<Sized? RHS, Result>  for Sized? {\n-    /// The method for the `%` operator\n-    fn rem(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rem_impl {\n-    ($($t:ty)*) => ($(\n-        impl Rem<$t, $t> for $t {\n-            #[inline]\n-            fn rem(&self, other: &$t) -> $t { (*self) % (*other) }\n-        }\n-    )*)\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rem_float_impl {\n-    ($t:ty, $fmod:ident) => {\n-        impl Rem<$t, $t> for $t {\n-            #[inline]\n-            fn rem(&self, other: &$t) -> $t {\n-                extern { fn $fmod(a: $t, b: $t) -> $t; }\n-                unsafe { $fmod(*self, *other) }\n-            }\n-        }\n-    }\n-}\n-\n-/// The `Rem` trait is used to specify the functionality of `%`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n-/// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Rem<Foo, Foo> for Foo {\n ///     fn rem(self, _rhs: Foo) -> Foo {\n ///         println!(\"Remainder-ing!\");\n ///         self\n@@ -480,14 +258,12 @@ macro_rules! rem_float_impl {\n ///     Foo % Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"rem\"]\n pub trait Rem<RHS, Result> {\n     /// The method for the `%` operator\n     fn rem(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n         impl Rem<$t, $t> for $t {\n@@ -497,7 +273,6 @@ macro_rules! rem_impl {\n     )*)\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n         impl Rem<$t, $t> for $t {\n@@ -721,46 +496,6 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl BitAnd<Foo, Foo> for Foo {\n-///     fn bitand(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise And-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo & Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitand\"]\n-pub trait BitAnd<Sized? RHS, Result> for Sized? {\n-    /// The method for the `&` operator\n-    fn bitand(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitand_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitAnd<$t, $t> for $t {\n-            #[inline]\n-            fn bitand(&self, rhs: &$t) -> $t { (*self) & (*rhs) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitAnd` trait is used to specify the functionality of `&`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n-/// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitAnd<Foo, Foo> for Foo {\n ///     fn bitand(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise And-ing!\");\n ///         self\n@@ -771,14 +506,12 @@ macro_rules! bitand_impl {\n ///     Foo & Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitand\"]\n pub trait BitAnd<RHS, Result> {\n     /// The method for the `&` operator\n     fn bitand(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n         impl BitAnd<$t, $t> for $t {\n@@ -802,46 +535,6 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl BitOr<Foo, Foo> for Foo {\n-///     fn bitor(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise Or-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo | Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitor\"]\n-pub trait BitOr<Sized? RHS, Result> for Sized? {\n-    /// The method for the `|` operator\n-    fn bitor(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitor_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitOr<$t,$t> for $t {\n-            #[inline]\n-            fn bitor(&self, rhs: &$t) -> $t { (*self) | (*rhs) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitOr` trait is used to specify the functionality of `|`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n-/// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitOr<Foo, Foo> for Foo {\n ///     fn bitor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Or-ing!\");\n ///         self\n@@ -852,14 +545,12 @@ macro_rules! bitor_impl {\n ///     Foo | Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitor\"]\n pub trait BitOr<RHS, Result> {\n     /// The method for the `|` operator\n     fn bitor(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n         impl BitOr<$t,$t> for $t {\n@@ -883,46 +574,6 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl BitXor<Foo, Foo> for Foo {\n-///     fn bitxor(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise Xor-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo ^ Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitxor\"]\n-pub trait BitXor<Sized? RHS, Result> for Sized? {\n-    /// The method for the `^` operator\n-    fn bitxor(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitxor_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitXor<$t, $t> for $t {\n-            #[inline]\n-            fn bitxor(&self, other: &$t) -> $t { (*self) ^ (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitXor` trait is used to specify the functionality of `^`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n-/// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitXor<Foo, Foo> for Foo {\n ///     fn bitxor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Xor-ing!\");\n ///         self\n@@ -933,14 +584,12 @@ macro_rules! bitxor_impl {\n ///     Foo ^ Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitxor\"]\n pub trait BitXor<RHS, Result> {\n     /// The method for the `^` operator\n     fn bitxor(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n         impl BitXor<$t, $t> for $t {\n@@ -964,48 +613,6 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl Shl<Foo, Foo> for Foo {\n-///     fn shl(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Shifting left!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo << Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"shl\"]\n-pub trait Shl<Sized? RHS, Result> for Sized? {\n-    /// The method for the `<<` operator\n-    fn shl(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! shl_impl {\n-    ($($t:ty)*) => ($(\n-        impl Shl<uint, $t> for $t {\n-            #[inline]\n-            fn shl(&self, other: &uint) -> $t {\n-                (*self) << (*other)\n-            }\n-        }\n-    )*)\n-}\n-\n-/// The `Shl` trait is used to specify the functionality of `<<`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n-/// calling `shl`, and therefore, `main` prints `Shifting left!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Shl<Foo, Foo> for Foo {\n ///     fn shl(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting left!\");\n ///         self\n@@ -1016,14 +623,12 @@ macro_rules! shl_impl {\n ///     Foo << Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"shl\"]\n pub trait Shl<RHS, Result> {\n     /// The method for the `<<` operator\n     fn shl(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n         impl Shl<uint, $t> for $t {\n@@ -1049,46 +654,6 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl Shr<Foo, Foo> for Foo {\n-///     fn shr(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Shifting right!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo >> Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"shr\"]\n-pub trait Shr<Sized? RHS, Result> for Sized? {\n-    /// The method for the `>>` operator\n-    fn shr(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! shr_impl {\n-    ($($t:ty)*) => ($(\n-        impl Shr<uint, $t> for $t {\n-            #[inline]\n-            fn shr(&self, other: &uint) -> $t { (*self) >> (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Shr` trait is used to specify the functionality of `>>`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n-/// calling `shr`, and therefore, `main` prints `Shifting right!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Shr<Foo, Foo> for Foo {\n ///     fn shr(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting right!\");\n ///         self\n@@ -1099,14 +664,12 @@ macro_rules! shr_impl {\n ///     Foo >> Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"shr\"]\n pub trait Shr<RHS, Result> {\n     /// The method for the `>>` operator\n     fn shr(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! shr_impl {\n     ($($t:ty)*) => ($(\n         impl Shr<uint, $t> for $t {"}, {"sha": "50a6fb9d0ca3f88f4a45a7da831d8aa580a6ca78", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -2852,45 +2852,18 @@ impl TypeContents {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n-    fn bitor(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits | other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n     fn bitor(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::BitAnd<TypeContents,TypeContents> for TypeContents {\n-    fn bitand(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::BitAnd<TypeContents, TypeContents> for TypeContents {\n     fn bitand(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & other.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n-    fn sub(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & !other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::Sub<TypeContents, TypeContents> for TypeContents {\n     fn sub(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}"}, {"sha": "5dd76047779a0eb45c86d5ba45a4f2bf03aad69c", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -205,17 +205,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the union of the two sets of flags.\n-            #[inline]\n-            fn bitor(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits | other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the union of the two sets of flags.\n             #[inline]\n@@ -224,17 +213,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the left flags, but with all the right flags toggled.\n-            #[inline]\n-            fn bitxor(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits ^ other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n@@ -243,17 +221,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the intersection between the two sets of flags.\n-            #[inline]\n-            fn bitand(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n@@ -262,17 +229,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the set difference of the two sets of flags.\n-            #[inline]\n-            fn sub(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & !other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the set difference of the two sets of flags.\n             #[inline]"}, {"sha": "f7351c9580f2fbecfb35891fe46e1772eba3ea5a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -287,21 +287,6 @@ impl Neg<Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<Duration,Duration> for Duration {\n-    fn add(&self, rhs: &Duration) -> Duration {\n-        let mut secs = self.secs + rhs.secs;\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<Duration, Duration> for Duration {\n     fn add(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs + rhs.secs;\n@@ -314,21 +299,6 @@ impl Add<Duration, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<Duration,Duration> for Duration {\n-    fn sub(&self, rhs: &Duration) -> Duration {\n-        let mut secs = self.secs - rhs.secs;\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<Duration, Duration> for Duration {\n     fn sub(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n@@ -341,19 +311,6 @@ impl Sub<Duration, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Mul<i32,Duration> for Duration {\n-    fn mul(&self, rhs: &i32) -> Duration {\n-        // Multiply nanoseconds as i64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as i64 * *rhs as i64;\n-        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n-        let secs = self.secs * *rhs as i64 + extra_secs;\n-        Duration { secs: secs, nanos: nanos as i32 }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Mul<i32, Duration> for Duration {\n     fn mul(self, rhs: i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n@@ -364,27 +321,6 @@ impl Mul<i32, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Div<i32,Duration> for Duration {\n-    fn div(&self, rhs: &i32) -> Duration {\n-        let mut secs = self.secs / *rhs as i64;\n-        let carry = self.secs - secs * *rhs as i64;\n-        let extra_nanos = carry * NANOS_PER_SEC as i64 / *rhs as i64;\n-        let mut nanos = self.nanos / *rhs + extra_nanos as i32;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Div<i32, Duration> for Duration {\n     fn div(self, rhs: i32) -> Duration {\n         let mut secs = self.secs / rhs as i64;"}, {"sha": "c726e17a8fa653e678a6010cc2b2900f0570ee88", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -48,30 +48,12 @@ impl Pos for BytePos {\n     fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<BytePos, BytePos> for BytePos {\n-    fn add(&self, rhs: &BytePos) -> BytePos {\n-        BytePos((self.to_uint() + rhs.to_uint()) as u32)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<BytePos, BytePos> for BytePos {\n     fn add(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() + rhs.to_uint()) as u32)\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<BytePos, BytePos> for BytePos {\n-    fn sub(&self, rhs: &BytePos) -> BytePos {\n-        BytePos((self.to_uint() - rhs.to_uint()) as u32)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<BytePos, BytePos> for BytePos {\n     fn sub(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() - rhs.to_uint()) as u32)\n@@ -83,30 +65,12 @@ impl Pos for CharPos {\n     fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<CharPos,CharPos> for CharPos {\n-    fn add(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(self.to_uint() + rhs.to_uint())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<CharPos, CharPos> for CharPos {\n     fn add(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() + rhs.to_uint())\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<CharPos,CharPos> for CharPos {\n-    fn sub(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(self.to_uint() - rhs.to_uint())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<CharPos, CharPos> for CharPos {\n     fn sub(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() - rhs.to_uint())"}, {"sha": "378dbba07fa69536e43976a896cba1a51983506f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -106,30 +106,6 @@ enum LockstepIterSize {\n     LisContradiction(String),\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n-    fn add(&self, other: &LockstepIterSize) -> LockstepIterSize {\n-        match *self {\n-            LisUnconstrained => other.clone(),\n-            LisContradiction(_) => self.clone(),\n-            LisConstraint(l_len, l_id) => match *other {\n-                LisUnconstrained => self.clone(),\n-                LisContradiction(_) => other.clone(),\n-                LisConstraint(r_len, _) if l_len == r_len => self.clone(),\n-                LisConstraint(r_len, r_id) => {\n-                    let l_n = token::get_ident(l_id);\n-                    let r_n = token::get_ident(r_id);\n-                    LisContradiction(format!(\"inconsistent lockstep iteration: \\\n-                                              '{}' has {} items, but '{}' has {}\",\n-                                              l_n, l_len, r_n, r_len).to_string())\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n     fn add(self, other: LockstepIterSize) -> LockstepIterSize {\n         match self {"}, {"sha": "dfa9b9242740ef278c438566584ff2337b1635cf", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbeef0edb2d25a3ff321d8e09532f053b5ef2c07/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=dbeef0edb2d25a3ff321d8e09532f053b5ef2c07", "patch": "@@ -97,29 +97,6 @@ impl Timespec {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<Duration, Timespec> for Timespec {\n-    fn add(&self, other: &Duration) -> Timespec {\n-        let d_sec = other.num_seconds();\n-        // It is safe to unwrap the nanoseconds, because there cannot be\n-        // more than one second left, which fits in i64 and in i32.\n-        let d_nsec = (*other - Duration::seconds(d_sec))\n-                     .num_nanoseconds().unwrap() as i32;\n-        let mut sec = self.sec + d_sec;\n-        let mut nsec = self.nsec + d_nsec;\n-        if nsec >= NSEC_PER_SEC {\n-            nsec -= NSEC_PER_SEC;\n-            sec += 1;\n-        } else if nsec < 0 {\n-            nsec += NSEC_PER_SEC;\n-            sec -= 1;\n-        }\n-        Timespec::new(sec, nsec)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<Duration, Timespec> for Timespec {\n     fn add(self, other: Duration) -> Timespec {\n         let d_sec = other.num_seconds();\n@@ -140,17 +117,6 @@ impl Add<Duration, Timespec> for Timespec {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<Timespec, Duration> for Timespec {\n-    fn sub(&self, other: &Timespec) -> Duration {\n-        let sec = self.sec - other.sec;\n-        let nsec = self.nsec - other.nsec;\n-        Duration::seconds(sec) + Duration::nanoseconds(nsec as i64)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<Timespec, Duration> for Timespec {\n     fn sub(self, other: Timespec) -> Duration {\n         let sec = self.sec - other.sec;"}]}