{"sha": "8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYjQ4Y2MxZTYwN2E3MTg5YzgwYzFkMGYzZjU1NjczMTJiZjFhOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-01T07:56:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-01T07:56:33Z"}, "message": "auto merge of #9599 : alexcrichton/rust/less-fmt, r=huonw\n\nThis also prevents future fmt! usage from leaking into the compiler, but it's still turned on by default for everyone else.", "tree": {"sha": "d963256840e228ef6b0949e8e7203850e763aba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d963256840e228ef6b0949e8e7203850e763aba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "html_url": "https://github.com/rust-lang/rust/commit/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6df7ab839fef099af163463ae99b9541d3d12c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6df7ab839fef099af163463ae99b9541d3d12c5", "html_url": "https://github.com/rust-lang/rust/commit/f6df7ab839fef099af163463ae99b9541d3d12c5"}, {"sha": "dec37051dd01b3faf921163a5d8370223ff77682", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec37051dd01b3faf921163a5d8370223ff77682", "html_url": "https://github.com/rust-lang/rust/commit/dec37051dd01b3faf921163a5d8370223ff77682"}], "stats": {"total": 9574, "additions": 4793, "deletions": 4781}, "files": [{"sha": "06adc311f78602ab1e21b3b74bc8a761535f4151", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -88,7 +88,7 @@ ifneq ($(wildcard $(NON_BUILD_TARGET_TRIPLES)),)\n CFG_INFO := $(info cfg: non-build target triples $(NON_BUILD_TARGET_TRIPLES))\n endif\n \n-CFG_RUSTC_FLAGS := $(RUSTFLAGS)\n+CFG_RUSTC_FLAGS := $(RUSTFLAGS) --cfg nofmt\n CFG_GCCISH_CFLAGS :=\n CFG_GCCISH_LINK_FLAGS :=\n "}, {"sha": "0ae03198f3639cebddf54f446dee59ff34934635", "filename": "doc/rust.md", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -683,15 +683,15 @@ mod math {\n     type complex = (f64, f64);\n     fn sin(f: f64) -> f64 {\n         ...\n-# fail!();\n+# fail2!();\n     }\n     fn cos(f: f64) -> f64 {\n         ...\n-# fail!();\n+# fail2!();\n     }\n     fn tan(f: f64) -> f64 {\n         ...\n-# fail!();\n+# fail2!();\n     }\n }\n ~~~~~~~~\n@@ -817,12 +817,14 @@ An example of `use` declarations:\n use std::num::sin;\n use std::option::{Some, None};\n \n+# fn foo<T>(_: T){}\n+\n fn main() {\n-    // Equivalent to 'info!(std::num::sin(1.0));'\n-    info!(sin(1.0));\n+    // Equivalent to 'std::num::sin(1.0);'\n+    sin(1.0);\n \n-    // Equivalent to 'info!(~[std::option::Some(1.0), std::option::None]);'\n-    info!(~[Some(1.0), None]);\n+    // Equivalent to 'foo(~[std::option::Some(1.0), std::option::None]);'\n+    foo(~[Some(1.0), None]);\n }\n ~~~~\n \n@@ -1040,8 +1042,8 @@ output slot type would normally be. For example:\n \n ~~~~\n fn my_err(s: &str) -> ! {\n-    info!(s);\n-    fail!();\n+    info2!(\"{}\", s);\n+    fail2!();\n }\n ~~~~\n \n@@ -1059,7 +1061,7 @@ were declared without the `!` annotation, the following code would not\n typecheck:\n \n ~~~~\n-# fn my_err(s: &str) -> ! { fail!() }\n+# fn my_err(s: &str) -> ! { fail2!() }\n \n fn f(i: int) -> int {\n    if i == 42 {\n@@ -2382,7 +2384,7 @@ fn ten_times(f: &fn(int)) {\n     }\n }\n \n-ten_times(|j| println(fmt!(\"hello, %d\", j)));\n+ten_times(|j| println!(\"hello, {}\", j));\n \n ~~~~\n \n@@ -2594,9 +2596,9 @@ enum List<X> { Nil, Cons(X, @List<X>) }\n let x: List<int> = Cons(10, @Cons(11, @Nil));\n \n match x {\n-    Cons(_, @Nil) => fail!(\"singleton list\"),\n+    Cons(_, @Nil) => fail2!(\"singleton list\"),\n     Cons(*)       => return,\n-    Nil           => fail!(\"empty list\")\n+    Nil           => fail2!(\"empty list\")\n }\n ~~~~\n \n@@ -2633,7 +2635,7 @@ match x {\n         return;\n     }\n     _ => {\n-        fail!();\n+        fail2!();\n     }\n }\n ~~~~\n@@ -2687,7 +2689,7 @@ guard may refer to the variables bound within the pattern they follow.\n let message = match maybe_digit {\n   Some(x) if x < 10 => process_digit(x),\n   Some(x) => process_other(x),\n-  None => fail!()\n+  None => fail2!()\n };\n ~~~~\n \n@@ -3472,20 +3474,20 @@ that demonstrates all four of them:\n \n ```rust\n fn main() {\n-    error!(\"This is an error log\")\n-    warn!(\"This is a warn log\")\n-    info!(\"this is an info log\")\n-    debug!(\"This is a debug log\")\n+    error2!(\"This is an error log\")\n+    warn2!(\"This is a warn log\")\n+    info2!(\"this is an info log\")\n+    debug2!(\"This is a debug log\")\n }\n ```\n \n These four log levels correspond to levels 1-4, as controlled by `RUST_LOG`:\n \n ```bash\n $ RUST_LOG=rust=3 ./rust\n-rust: ~\"\\\"This is an error log\\\"\"\n-rust: ~\"\\\"This is a warn log\\\"\"\n-rust: ~\"\\\"this is an info log\\\"\"\n+This is an error log\n+This is a warn log\n+this is an info log\n ```\n \n # Appendix: Rationales and design tradeoffs"}, {"sha": "726b8bb2b8001a4ef995f057869b5dee7563145b", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -66,7 +66,7 @@ use std::int;\n fn main() {\n     let pairs = read_int_pairs();\n     for &(a,b) in pairs.iter() {\n-        println(fmt!(\"%4.4d, %4.4d\", a, b));\n+        println!(\"{:4.4d}, {:4.4d}\", a, b);\n     }\n }\n \n@@ -281,7 +281,7 @@ fn main() {\n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n-            println(fmt!(\"%4.4d, %4.4d\", a, b));\n+            println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n     };\n@@ -387,7 +387,7 @@ condition! {\n fn main() {\n     let pairs = read_int_pairs();\n     for &(a,b) in pairs.iter() {\n-        println(fmt!(\"%4.4d, %4.4d\", a, b));\n+        println!(\"{:4.4d}, {:4.4d}\", a, b);\n     }\n }\n \n@@ -462,7 +462,7 @@ fn main() {\n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n-                println(fmt!(\"%4.4d, %4.4d\", a, b));\n+                println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n     }\n@@ -540,7 +540,7 @@ fn main() {\n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n-            println(fmt!(\"%4.4d, %4.4d\", a, b));\n+            println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n     }\n@@ -636,7 +636,7 @@ fn main() {\n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n-            println(fmt!(\"%4.4d, %4.4d\", a, b));\n+            println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n     }\n@@ -766,7 +766,7 @@ fn main() {\n             // The protected logic.\n             let pairs = read_int_pairs();\n             for &(a,b) in pairs.iter() {\n-                println(fmt!(\"%4.4d, %4.4d\", a, b));\n+                println!(\"{:4.4d}, {:4.4d}\", a, b);\n             }\n \n         }"}, {"sha": "a70b29f9100581fb219dfa56a286aced7827f2b0", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -226,7 +226,7 @@ match x {\n                 // complicated stuff goes here\n                 return result + val;\n             },\n-            _ => fail!(\"Didn't get good_2\")\n+            _ => fail2!(\"Didn't get good_2\")\n         }\n     }\n     _ => return 0 // default value\n@@ -268,7 +268,7 @@ macro_rules! biased_match (\n biased_match!((x)       ~ (good_1(g1, val)) else { return 0 };\n               binds g1, val )\n biased_match!((g1.body) ~ (good_2(result) )\n-                  else { fail!(\"Didn't get good_2\") };\n+                  else { fail2!(\"Didn't get good_2\") };\n               binds result )\n // complicated stuff goes here\n return result + val;\n@@ -369,7 +369,7 @@ macro_rules! biased_match (\n # fn f(x: t1) -> uint {\n biased_match!(\n     (x)       ~ (good_1(g1, val)) else { return 0 };\n-    (g1.body) ~ (good_2(result) ) else { fail!(\"Didn't get good_2\") };\n+    (g1.body) ~ (good_2(result) ) else { fail2!(\"Didn't get good_2\") };\n     binds val, result )\n // complicated stuff goes here\n return result + val;"}, {"sha": "09d3469871f65dcdba7b266556cd43ff6e1c77cc", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -99,15 +99,14 @@ execution. Like any closure, the function passed to `spawn` may capture\n an environment that it carries across tasks.\n \n ~~~\n-# use std::io::println;\n # use std::task::spawn;\n # fn generate_task_number() -> int { 0 }\n // Generate some state locally\n let child_task_number = generate_task_number();\n \n do spawn {\n    // Capture it in the remote task\n-   println(fmt!(\"I am child number %d\", child_task_number));\n+   println!(\"I am child number {}\", child_task_number);\n }\n ~~~\n \n@@ -282,7 +281,7 @@ fn fib(n: uint) -> uint {\n \n let mut delayed_fib = extra::future::Future::spawn (|| fib(50) );\n make_a_sandwich();\n-println(fmt!(\"fib(50) = %?\", delayed_fib.get()))\n+println!(\"fib(50) = {:?}\", delayed_fib.get())\n ~~~\n \n The call to `future::spawn` returns immediately a `future` object regardless of how long it\n@@ -310,7 +309,7 @@ fn main() {\n     for ft in futures.mut_iter()  {\n         final_res += ft.get();\n     }\n-    println(fmt!(\"\u03c0^2/6 is not far from : %?\", final_res));\n+    println!(\"\u03c0^2/6 is not far from : {}\", final_res);\n }\n ~~~\n \n@@ -338,7 +337,7 @@ fn pnorm(nums: &~[float], p: uint) -> float {\n \n fn main() {\n     let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n-    println(fmt!(\"Inf-norm = %?\",  *numbers.iter().max().unwrap()));\n+    println!(\"Inf-norm = {}\",  *numbers.iter().max().unwrap());\n \n     let numbers_arc = Arc::new(numbers);\n \n@@ -349,7 +348,7 @@ fn main() {\n         do spawn {\n             let local_arc : Arc<~[float]> = port.recv();\n             let task_numbers = local_arc.get();\n-            println(fmt!(\"%u-norm = %?\", num, pnorm(task_numbers, num)));\n+            println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n         }\n     }\n }"}, {"sha": "f9109fcb8ea392d741785ae3a9c6791463999986", "filename": "doc/tutorial.md", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -225,7 +225,7 @@ let hi = \"hi\";\n let mut count = 0;\n \n while count < 10 {\n-    println(fmt!(\"count: %?\", count));\n+    println!(\"count: {}\", count);\n     count += 1;\n }\n ~~~~\n@@ -388,23 +388,26 @@ assert!(y == 4u);\n but are instead provided by the libraries. To make it clear to the reader when\n a name refers to a syntax extension, the names of all syntax extensions end\n with `!`. The standard library defines a few syntax extensions, the most\n-useful of which is `fmt!`, a `sprintf`-style text formatter that you will\n-often see in examples.\n+useful of which is [`format!`][fmt], a `sprintf`-like text formatter that you\n+will often see in examples, and its related family of macros: `print!`,\n+`println!`, and `write!`.\n \n-`fmt!` supports most of the directives that [printf][pf] supports, but unlike\n-printf, will give you a compile-time error when the types of the directives\n-don't match the types of the arguments.\n+`format!` draws syntax from python, but contains many of the same principles\n+that [printf][pf] has. Unlike printf, `format!` will give you a compile-time\n+error when the types of the directives don't match the types of the arguments.\n \n ~~~~\n # let mystery_object = ();\n \n-println(fmt!(\"%s is %d\", \"the answer\", 43));\n+// {} will print the \"default format\" of a type\n+println!(\"{} is {}\", \"the answer\", 43);\n \n-// %? will conveniently print any type\n-println(fmt!(\"what is this thing: %?\", mystery_object));\n+// {:?} will conveniently print any type\n+println!(\"what is this thing: {:?}\", mystery_object);\n ~~~~\n \n [pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n+[fmt]: http://static.rust-lang.org/doc/master/std/fmt/index.html\n \n You can define your own syntax extensions with the macro system. For details, see the [macro tutorial][macros].\n \n@@ -737,7 +740,7 @@ fn area(sh: Shape) -> float {\n     match sh {\n         Circle { radius: radius, _ } => float::consts::pi * square(radius),\n         Rectangle { top_left: top_left, bottom_right: bottom_right } => {\n-            (bottom_right.x - top_left.x) * (top_left.y - bottom_right.y) \n+            (bottom_right.x - top_left.x) * (top_left.y - bottom_right.y)\n         }\n     }\n }\n@@ -753,7 +756,7 @@ unit, `()`, as the empty tuple if you like).\n ~~~~\n let mytup: (int, int, float) = (10, 20, 30.0);\n match mytup {\n-  (a, b, c) => info!(a + b + (c as int))\n+  (a, b, c) => info2!(\"{}\", a + b + (c as int))\n }\n ~~~~\n \n@@ -769,7 +772,7 @@ For example:\n struct MyTup(int, int, float);\n let mytup: MyTup = MyTup(10, 20, 30.0);\n match mytup {\n-  MyTup(a, b, c) => info!(a + b + (c as int))\n+  MyTup(a, b, c) => info2!(\"{}\", a + b + (c as int))\n }\n ~~~~\n \n@@ -1238,7 +1241,7 @@ something silly like\n ~~~\n # struct Point { x: float, y: float }\n let point = &@~Point { x: 10f, y: 20f };\n-println(fmt!(\"%f\", point.x));\n+println!(\"{:f}\", point.x);\n ~~~\n \n The indexing operator (`[]`) also auto-dereferences.\n@@ -1443,7 +1446,7 @@ the enclosing scope.\n fn call_closure_with_ten(b: &fn(int)) { b(10); }\n \n let captured_var = 20;\n-let closure = |arg| println(fmt!(\"captured_var=%d, arg=%d\", captured_var, arg));\n+let closure = |arg| println!(\"captured_var={}, arg={}\", captured_var, arg);\n \n call_closure_with_ten(closure);\n ~~~~\n@@ -1566,7 +1569,7 @@ arguments.\n use std::task::spawn;\n \n do spawn() || {\n-    debug!(\"I'm a task, whatever\");\n+    debug2!(\"I'm a task, whatever\");\n }\n ~~~~\n \n@@ -1578,7 +1581,7 @@ may be omitted from `do` expressions.\n use std::task::spawn;\n \n do spawn {\n-   debug!(\"Kablam!\");\n+   debug2!(\"Kablam!\");\n }\n ~~~~\n \n@@ -1916,7 +1919,7 @@ and `~str`.\n ~~~~\n # trait Printable { fn print(&self); }\n impl Printable for int {\n-    fn print(&self) { println(fmt!(\"%d\", *self)) }\n+    fn print(&self) { println!(\"{}\", *self) }\n }\n \n impl Printable for ~str {"}, {"sha": "e253c9bd0595330250995fa623dacc4ba9b25ea0", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -82,23 +82,23 @@ pub fn parse_config(args: ~[~str]) -> config {\n     let argv0 = args[0].clone();\n     let args_ = args.tail();\n     if args[1] == ~\"-h\" || args[1] == ~\"--help\" {\n-        let message = fmt!(\"Usage: %s [OPTIONS] [TESTNAME...]\", argv0);\n+        let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println(getopts::groups::usage(message, groups));\n         println(\"\");\n-        fail!()\n+        fail2!()\n     }\n \n     let matches =\n         &match getopts::groups::getopts(args_, groups) {\n           Ok(m) => m,\n-          Err(f) => fail!(f.to_err_msg())\n+          Err(f) => fail2!(\"{}\", f.to_err_msg())\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        let message = fmt!(\"Usage: %s [OPTIONS]  [TESTNAME...]\", argv0);\n+        let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n         println(getopts::groups::usage(message, groups));\n         println(\"\");\n-        fail!()\n+        fail2!()\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n@@ -152,29 +152,29 @@ pub fn parse_config(args: ~[~str]) -> config {\n \n pub fn log_config(config: &config) {\n     let c = config;\n-    logv(c, fmt!(\"configuration:\"));\n-    logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n-    logv(c, fmt!(\"run_lib_path: %s\", config.run_lib_path));\n-    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path.to_str()));\n-    logv(c, fmt!(\"src_base: %s\", config.src_base.to_str()));\n-    logv(c, fmt!(\"build_base: %s\", config.build_base.to_str()));\n-    logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n-    logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n-    logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n-    logv(c, fmt!(\"filter: %s\", opt_str(&config.filter)));\n-    logv(c, fmt!(\"runtool: %s\", opt_str(&config.runtool)));\n-    logv(c, fmt!(\"rustcflags: %s\", opt_str(&config.rustcflags)));\n-    logv(c, fmt!(\"jit: %b\", config.jit));\n-    logv(c, fmt!(\"target: %s\", config.target));\n-    logv(c, fmt!(\"adb_path: %s\", config.adb_path));\n-    logv(c, fmt!(\"adb_test_dir: %s\", config.adb_test_dir));\n-    logv(c, fmt!(\"adb_device_status: %b\", config.adb_device_status));\n+    logv(c, format!(\"configuration:\"));\n+    logv(c, format!(\"compile_lib_path: {}\", config.compile_lib_path));\n+    logv(c, format!(\"run_lib_path: {}\", config.run_lib_path));\n+    logv(c, format!(\"rustc_path: {}\", config.rustc_path.to_str()));\n+    logv(c, format!(\"src_base: {}\", config.src_base.to_str()));\n+    logv(c, format!(\"build_base: {}\", config.build_base.to_str()));\n+    logv(c, format!(\"stage_id: {}\", config.stage_id));\n+    logv(c, format!(\"mode: {}\", mode_str(config.mode)));\n+    logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n+    logv(c, format!(\"filter: {}\", opt_str(&config.filter)));\n+    logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n+    logv(c, format!(\"rustcflags: {}\", opt_str(&config.rustcflags)));\n+    logv(c, format!(\"jit: {}\", config.jit));\n+    logv(c, format!(\"target: {}\", config.target));\n+    logv(c, format!(\"adb_path: {}\", config.adb_path));\n+    logv(c, format!(\"adb_test_dir: {}\", config.adb_test_dir));\n+    logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n     match config.test_shard {\n         None => logv(c, ~\"test_shard: (all)\"),\n-        Some((a,b)) => logv(c, fmt!(\"test_shard: %u.%u\", a, b))\n+        Some((a,b)) => logv(c, format!(\"test_shard: {}.{}\", a, b))\n     }\n-    logv(c, fmt!(\"verbose: %b\", config.verbose));\n-    logv(c, fmt!(\"\\n\"));\n+    logv(c, format!(\"verbose: {}\", config.verbose));\n+    logv(c, format!(\"\\n\"));\n }\n \n pub fn opt_str<'a>(maybestr: &'a Option<~str>) -> &'a str {\n@@ -203,7 +203,7 @@ pub fn str_mode(s: ~str) -> mode {\n       ~\"pretty\" => mode_pretty,\n       ~\"debug-info\" => mode_debug_info,\n       ~\"codegen\" => mode_codegen,\n-      _ => fail!(\"invalid mode\")\n+      _ => fail2!(\"invalid mode\")\n     }\n }\n \n@@ -226,7 +226,7 @@ pub fn run_tests(config: &config) {\n     // For context, see #8904\n     rt::test::prepare_for_lots_of_tests();\n     let res = test::run_tests_console(&opts, tests);\n-    if !res { fail!(\"Some tests failed\"); }\n+    if !res { fail2!(\"Some tests failed\"); }\n }\n \n pub fn test_opts(config: &config) -> test::TestOpts {\n@@ -244,13 +244,13 @@ pub fn test_opts(config: &config) -> test::TestOpts {\n }\n \n pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n-    debug!(\"making tests from %s\",\n+    debug2!(\"making tests from {}\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n     let dirs = os::list_dir_path(&config.src_base);\n     for file in dirs.iter() {\n         let file = file.clone();\n-        debug!(\"inspecting file %s\", file.to_str());\n+        debug2!(\"inspecting file {}\", file.to_str());\n         if is_test(config, &file) {\n             let t = do make_test(config, &file) {\n                 match config.mode {\n@@ -306,12 +306,12 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n         let filename = path.filename();\n         let p = path.pop();\n         let dir = p.filename();\n-        fmt!(\"%s/%s\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n+        format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n-    test::DynTestName(fmt!(\"[%s] %s\",\n-                           mode_str(config.mode),\n-                           shorten(testfile)))\n+    test::DynTestName(format!(\"[{}] {}\",\n+                              mode_str(config.mode),\n+                              shorten(testfile)))\n }\n \n pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {"}, {"sha": "02195e684e3855d872c3d397cbf4a929e0e8dffa", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -56,7 +56,7 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n     while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n     let msg = line.slice(idx, len).to_owned();\n \n-    debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n+    debug2!(\"line={} kind={} msg={}\", line_num - adjust_line, kind, msg);\n \n     return ~[ExpectedError{line: line_num - adjust_line, kind: kind,\n                            msg: msg}];"}, {"sha": "36780abc7eefd600a7753f49fdb693fcfef3530d", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -150,7 +150,7 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n               let end = strs.pop();\n               (strs.pop(), end)\n           }\n-          n => fail!(\"Expected 1 or 2 strings, not %u\", n)\n+          n => fail2!(\"Expected 1 or 2 strings, not {}\", n)\n         }\n     }\n }\n@@ -179,7 +179,7 @@ fn parse_name_value_directive(line: &str,\n         Some(colon) => {\n             let value = line.slice(colon + keycolon.len(),\n                                    line.len()).to_owned();\n-            debug!(\"%s: %s\", directive,  value);\n+            debug2!(\"{}: {}\", directive,  value);\n             Some(value)\n         }\n         None => None"}, {"sha": "2d55fa775d7d70fb82aae41760727165d4a4b20f", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -63,9 +63,9 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n         io::stdout().write_str(\"\\n\\n\");\n     }\n     let testfile = Path(testfile);\n-    debug!(\"running %s\", testfile.to_str());\n+    debug2!(\"running {}\", testfile.to_str());\n     let props = load_props(&testfile);\n-    debug!(\"loaded props\");\n+    debug2!(\"loaded props\");\n     match config.mode {\n       mode_compile_fail => run_cfail_test(&config, &props, &testfile),\n       mode_run_fail => run_rfail_test(&config, &props, &testfile),\n@@ -136,8 +136,8 @@ fn check_correct_failure_status(ProcRes: &ProcRes) {\n     static RUST_ERR: int = 101;\n     if ProcRes.status != RUST_ERR {\n         fatal_ProcRes(\n-            fmt!(\"failure produced the wrong error code: %d\",\n-                 ProcRes.status),\n+            format!(\"failure produced the wrong error code: {}\",\n+                    ProcRes.status),\n             ProcRes);\n     }\n }\n@@ -174,11 +174,11 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     let mut round = 0;\n     while round < rounds {\n-        logv(config, fmt!(\"pretty-printing round %d\", round));\n+        logv(config, format!(\"pretty-printing round {}\", round));\n         let ProcRes = print_source(config, testfile, srcs[round].clone());\n \n         if ProcRes.status != 0 {\n-            fatal_ProcRes(fmt!(\"pretty-printing failed in round %d\", round),\n+            fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n                           &ProcRes);\n         }\n \n@@ -228,19 +228,19 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         if expected != actual {\n             error(~\"pretty-printed source does not match expected source\");\n             let msg =\n-                fmt!(\"\\n\\\n+                format!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n-%s\\n\\\n+{}\\n\\\n ------------------------------------------\\n\\\n actual:\\n\\\n ------------------------------------------\\n\\\n-%s\\n\\\n+{}\\n\\\n ------------------------------------------\\n\\\n \\n\",\n                      expected, actual);\n             io::stdout().write_str(msg);\n-            fail!();\n+            fail2!();\n         }\n     }\n \n@@ -285,7 +285,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     let script_str = [~\"set charset UTF-8\",\n                       cmds,\n                       ~\"quit\\n\"].connect(\"\\n\");\n-    debug!(\"script_str = %s\", script_str);\n+    debug2!(\"script_str = {}\", script_str);\n     dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n     // run debugger script with gdb\n@@ -318,8 +318,8 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             }\n         }\n         if i != num_check_lines {\n-            fatal_ProcRes(fmt!(\"line not found in debugger output: %s\",\n-                               check_lines[i]), &ProcRes);\n+            fatal_ProcRes(format!(\"line not found in debugger output: {}\",\n+                                  check_lines[i]), &ProcRes);\n         }\n     }\n }\n@@ -340,10 +340,10 @@ fn check_error_patterns(props: &TestProps,\n     let mut done = false;\n     for line in ProcRes.stderr.line_iter() {\n         if line.contains(*next_err_pat) {\n-            debug!(\"found error pattern %s\", *next_err_pat);\n+            debug2!(\"found error pattern {}\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n-                debug!(\"found all error patterns\");\n+                debug2!(\"found all error patterns\");\n                 done = true;\n                 break;\n             }\n@@ -355,11 +355,11 @@ fn check_error_patterns(props: &TestProps,\n     let missing_patterns =\n         props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n-        fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n-                           missing_patterns[0]), ProcRes);\n+        fatal_ProcRes(format!(\"error pattern '{}' not found!\",\n+                              missing_patterns[0]), ProcRes);\n     } else {\n         for pattern in missing_patterns.iter() {\n-            error(fmt!(\"error pattern '%s' not found!\", *pattern));\n+            error(format!(\"error pattern '{}' not found!\", *pattern));\n         }\n         fatal_ProcRes(~\"multiple error patterns not found\", ProcRes);\n     }\n@@ -378,7 +378,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        fmt!(\"%s:%u:\", testfile.to_str(), ee.line)\n+        format!(\"{}:{}:\", testfile.to_str(), ee.line)\n     }).collect::<~[~str]>();\n \n     fn to_lower( s : &str ) -> ~str {\n@@ -415,7 +415,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n-                debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n+                debug2!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n                        prefixes[i], ee.kind, ee.msg, line);\n                 if (prefix_matches(line, prefixes[i]) &&\n                     line.contains(ee.kind) &&\n@@ -433,7 +433,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n \n         if !was_expected && is_compiler_error_or_warning(line) {\n-            fatal_ProcRes(fmt!(\"unexpected compiler error or warning: '%s'\",\n+            fatal_ProcRes(format!(\"unexpected compiler error or warning: '{}'\",\n                                line),\n                           ProcRes);\n         }\n@@ -442,7 +442,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = &expected_errors[i];\n-            fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\",\n+            fatal_ProcRes(format!(\"expected {} on line {} not found: {}\",\n                                ee.kind, ee.line, ee.msg), ProcRes);\n         }\n     }\n@@ -591,7 +591,7 @@ fn compose_and_run_compiler(\n                                      config.compile_lib_path, None);\n         if auxres.status != 0 {\n             fatal_ProcRes(\n-                fmt!(\"auxiliary build of %s failed to compile: \",\n+                format!(\"auxiliary build of {} failed to compile: \",\n                      abs_ab.to_str()),\n                 &auxres);\n         }\n@@ -615,7 +615,7 @@ fn compose_and_run_compiler(\n fn ensure_dir(path: &Path) {\n     if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n-        fail!(\"can't make dir %s\", path.to_str());\n+        fail2!(\"can't make dir {}\", path.to_str());\n     }\n }\n \n@@ -678,7 +678,7 @@ fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(config, fmt!(\"executing %s\", cmdline));\n+            logv(config, format!(\"executing {}\", cmdline));\n             cmdline\n         };\n     let procsrv::Result{ out, err, status } =\n@@ -695,19 +695,19 @@ fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    fmt!(\"%s %s\", prog, args.connect(\" \"))\n+    format!(\"{} {}\", prog, args.connect(\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    fmt!(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n+    format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog,\n          args.connect(\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n fn lib_path_cmd_prefix(path: &str) -> ~str {\n-    fmt!(\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+    format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n }\n \n fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n@@ -744,8 +744,8 @@ fn output_base_name(config: &config, testfile: &Path) -> Path {\n \n fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     if config.verbose {\n-        let sep1 = fmt!(\"------%s------------------------------\", \"stdout\");\n-        let sep2 = fmt!(\"------%s------------------------------\", \"stderr\");\n+        let sep1 = format!(\"------{}------------------------------\", \"stdout\");\n+        let sep2 = format!(\"------{}------------------------------\", \"stderr\");\n         let sep3 = ~\"------------------------------------------\";\n         io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n@@ -755,27 +755,27 @@ fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     }\n }\n \n-fn error(err: ~str) { io::stdout().write_line(fmt!(\"\\nerror: %s\", err)); }\n+fn error(err: ~str) { io::stdout().write_line(format!(\"\\nerror: {}\", err)); }\n \n-fn fatal(err: ~str) -> ! { error(err); fail!(); }\n+fn fatal(err: ~str) -> ! { error(err); fail2!(); }\n \n fn fatal_ProcRes(err: ~str, ProcRes: &ProcRes) -> ! {\n     let msg =\n-        fmt!(\"\\n\\\n-error: %s\\n\\\n-command: %s\\n\\\n+        format!(\"\\n\\\n+error: {}\\n\\\n+command: {}\\n\\\n stdout:\\n\\\n ------------------------------------------\\n\\\n-%s\\n\\\n+{}\\n\\\n ------------------------------------------\\n\\\n stderr:\\n\\\n ------------------------------------------\\n\\\n-%s\\n\\\n+{}\\n\\\n ------------------------------------------\\n\\\n \\n\",\n              err, ProcRes.cmdline, ProcRes.stdout, ProcRes.stderr);\n     io::stdout().write_str(msg);\n-    fail!();\n+    fail2!();\n }\n \n fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n@@ -794,23 +794,23 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n         ~[(~\"\",~\"\")], Some(~\"\"));\n \n     if config.verbose {\n-        io::stdout().write_str(fmt!(\"push (%s) %s %s %s\",\n+        io::stdout().write_str(format!(\"push ({}) {} {} {}\",\n             config.target, args.prog,\n             copy_result.out, copy_result.err));\n     }\n \n-    logv(config, fmt!(\"executing (%s) %s\", config.target, cmdline));\n+    logv(config, format!(\"executing ({}) {}\", config.target, cmdline));\n \n     let mut runargs = ~[];\n \n     // run test via adb_run_wrapper\n     runargs.push(~\"shell\");\n     for (key, val) in env.move_iter() {\n-        runargs.push(fmt!(\"%s=%s\", key, val));\n+        runargs.push(format!(\"{}={}\", key, val));\n     }\n-    runargs.push(fmt!(\"%s/adb_run_wrapper.sh\", config.adb_test_dir));\n-    runargs.push(fmt!(\"%s\", config.adb_test_dir));\n-    runargs.push(fmt!(\"%s\", prog_short));\n+    runargs.push(format!(\"{}/adb_run_wrapper.sh\", config.adb_test_dir));\n+    runargs.push(format!(\"{}\", config.adb_test_dir));\n+    runargs.push(format!(\"{}\", prog_short));\n \n     for tv in args.args.iter() {\n         runargs.push(tv.to_owned());\n@@ -822,7 +822,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs = ~[];\n     runargs.push(~\"shell\");\n     runargs.push(~\"cat\");\n-    runargs.push(fmt!(\"%s/%s.exitcode\", config.adb_test_dir, prog_short));\n+    runargs.push(format!(\"{}/{}.exitcode\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n         procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")],\n@@ -841,7 +841,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs = ~[];\n     runargs.push(~\"shell\");\n     runargs.push(~\"cat\");\n-    runargs.push(fmt!(\"%s/%s.stdout\", config.adb_test_dir, prog_short));\n+    runargs.push(format!(\"{}/{}.stdout\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n         procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n@@ -850,7 +850,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs = ~[];\n     runargs.push(~\"shell\");\n     runargs.push(~\"cat\");\n-    runargs.push(fmt!(\"%s/%s.stderr\", config.adb_test_dir, prog_short));\n+    runargs.push(format!(\"{}/{}.stderr\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n         procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n@@ -887,7 +887,7 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {\n-                io::stdout().write_str(fmt!(\"push (%s) %s %s %s\",\n+                io::stdout().write_str(format!(\"push ({}) {} {} {}\",\n                     config.target, file.to_str(),\n                     copy_result.out, copy_result.err));\n             }"}, {"sha": "59b8ba1c7ff30ef238e31927dd7ee0a3c306b3f7", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -29,7 +29,7 @@ pub fn get_os(triple: &str) -> &'static str {\n             return os\n         }\n     }\n-    fail!(\"Cannot determine OS from triple\");\n+    fail2!(\"Cannot determine OS from triple\");\n }\n \n pub fn make_new_path(path: &str) -> ~str {\n@@ -38,7 +38,7 @@ pub fn make_new_path(path: &str) -> ~str {\n     // maintain the current value while adding our own\n     match getenv(lib_path_env_var()) {\n       Some(curr) => {\n-        fmt!(\"%s%s%s\", path, path_div(), curr)\n+        format!(\"{}{}{}\", path, path_div(), curr)\n       }\n       None => path.to_str()\n     }\n@@ -63,6 +63,6 @@ pub fn path_div() -> ~str { ~\":\" }\n pub fn path_div() -> ~str { ~\";\" }\n \n pub fn logv(config: &config, s: ~str) {\n-    debug!(\"%s\", s);\n+    debug2!(\"{}\", s);\n     if config.verbose { io::println(s); }\n }"}, {"sha": "1cb30eaa040b2755ae3142941b3279aa1504d07e", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -255,7 +255,7 @@ impl<T:Send> MutexArc<T> {\n         let inner = x.unwrap();\n         let MutexArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail!(~\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n+            fail2!(\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n         }\n         data\n     }\n@@ -300,9 +300,9 @@ impl<T:Freeze + Send> MutexArc<T> {\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n         if is_mutex {\n-            fail!(\"Poisoned MutexArc - another task failed inside!\");\n+            fail2!(\"Poisoned MutexArc - another task failed inside!\");\n         } else {\n-            fail!(\"Poisoned rw_arc - another task failed inside!\");\n+            fail2!(\"Poisoned rw_arc - another task failed inside!\");\n         }\n     }\n }\n@@ -505,7 +505,7 @@ impl<T:Freeze + Send> RWArc<T> {\n         let inner = x.unwrap();\n         let RWArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail!(~\"Can't unwrap poisoned RWArc - another task failed inside!\")\n+            fail2!(\"Can't unwrap poisoned RWArc - another task failed inside!\")\n         }\n         data\n     }\n@@ -619,7 +619,7 @@ mod tests {\n         assert_eq!(arc_v.get()[2], 3);\n         assert_eq!(arc_v.get()[4], 5);\n \n-        info!(arc_v);\n+        info2!(\"{:?}\", arc_v);\n     }\n \n     #[test]"}, {"sha": "520faad1afa0797775a7128c92fb0b07b2fdbb93", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -127,7 +127,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n         let start = round_up_to(after_tydesc, align);\n \n-        //debug!(\"freeing object: idx = %u, size = %u, align = %u, done = %b\",\n+        //debug2!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n             ((*tydesc).drop_glue)(ptr::offset(buf, start as int) as *i8);\n@@ -176,7 +176,7 @@ impl Arena {\n             }\n             this.pod_head.fill = end;\n \n-            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //debug2!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n             ptr::offset(vec::raw::to_ptr(this.pod_head.data), start as int)\n@@ -232,7 +232,7 @@ impl Arena {\n             let head = transmute_mut_region(&mut self.head);\n             head.fill = round_up_to(end, sys::pref_align_of::<*TyDesc>());\n \n-            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //debug2!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n             let buf = vec::raw::to_ptr(self.head.data);\n@@ -305,6 +305,6 @@ fn test_arena_destructors_fail() {\n     // Now, fail while allocating\n     do arena.alloc::<@int> {\n         // Now fail.\n-        fail!();\n+        fail2!();\n     };\n }"}, {"sha": "ed366047c848ba1b06da90a4f828ce3c213d9666", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -141,7 +141,7 @@ impl<'self> ToBase64 for &'self [u8] {\n                     v.push('=' as u8);\n                 }\n             }\n-            _ => fail!(\"Algebra is broken, please alert the math police\")\n+            _ => fail2!(\"Algebra is broken, please alert the math police\")\n         }\n \n         unsafe {\n@@ -202,7 +202,7 @@ impl<'self> FromBase64 for &'self str {\n                 '/'|'_' => buf |= 0x3F,\n                 '\\r'|'\\n' => loop,\n                 '=' => break,\n-                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                _ => return Err(format!(\"Invalid character '{}' at position {}\",\n                                      self.char_at(idx), idx))\n             }\n \n@@ -218,7 +218,7 @@ impl<'self> FromBase64 for &'self str {\n \n         for (idx, byte) in it {\n             if (byte as char) != '=' {\n-                return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                return Err(format!(\"Invalid character '{}' at position {}\",\n                                 self.char_at(idx), idx));\n             }\n         }"}, {"sha": "49a38a00b1003143c61dfed8fab52fd97dbf7d09", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -232,7 +232,7 @@ pub struct Bitv {\n }\n \n fn die() -> ! {\n-    fail!(\"Tried to do operation on bit vectors with different sizes\");\n+    fail2!(\"Tried to do operation on bit vectors with different sizes\");\n }\n \n impl Bitv {\n@@ -1357,7 +1357,7 @@ mod tests {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n         do b.ones |i| {\n-            fail!(\"found 1 at %?\", i)\n+            fail2!(\"found 1 at {:?}\", i)\n         };\n     }\n \n@@ -1366,7 +1366,7 @@ mod tests {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n         do b.ones |i| {\n-            fail!(\"found 1 at %?\", i)\n+            fail2!(\"found 1 at {:?}\", i)\n         };\n     }\n "}, {"sha": "476755919a4c460cb0dfb8ee5d64284536142373", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -179,7 +179,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n-            fail!()\n+            fail2!()\n         }\n         port.recv()\n     }\n@@ -189,7 +189,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             port.duplex_stream.recv();\n-            fail!()\n+            fail2!()\n         }\n         chan.try_send(());\n     }\n@@ -200,7 +200,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             port.duplex_stream.recv();\n-            fail!()\n+            fail2!()\n         }\n         chan.send(());\n     }"}, {"sha": "8c97f7db2bd8a65459362f580b1c3c7d8cf1ae65", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -109,23 +109,23 @@ impl ToBits for u64 {\n     }\n }\n \n-/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// Adds the specified number of bytes to the bit count. fail2!() if this would cause numeric\n /// overflow.\n pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n     if new_high_bits > Zero::zero() {\n-        fail!(\"Numeric overflow occured.\")\n+        fail2!(\"Numeric overflow occured.\")\n     }\n \n     match bits.checked_add(&new_low_bits) {\n         Some(x) => return x,\n-        None => fail!(\"Numeric overflow occured.\")\n+        None => fail2!(\"Numeric overflow occured.\")\n     }\n }\n \n /// Adds the specified number of bytes to the bit count, which is a tuple where the first element is\n-/// the high order value. fail!() if this would cause numeric overflow.\n+/// the high order value. fail2!() if this would cause numeric overflow.\n pub fn add_bytes_to_bits_tuple\n         <T: Int + Unsigned + CheckedAdd + ToBits>\n         (bits: (T, T), bytes: T) -> (T, T) {\n@@ -144,15 +144,15 @@ pub fn add_bytes_to_bits_tuple\n             } else {\n                 match hi.checked_add(&new_high_bits) {\n                     Some(y) => return (y, x),\n-                    None => fail!(\"Numeric overflow occured.\")\n+                    None => fail2!(\"Numeric overflow occured.\")\n                 }\n             }\n         },\n         None => {\n             let one: T = One::one();\n             let z = match new_high_bits.checked_add(&one) {\n                 Some(w) => w,\n-                None => fail!(\"Numeric overflow occured.\")\n+                None => fail2!(\"Numeric overflow occured.\")\n             };\n             match hi.checked_add(&z) {\n                 // This re-executes the addition that was already performed earlier when overflow\n@@ -163,7 +163,7 @@ pub fn add_bytes_to_bits_tuple\n                 // be Unsigned - overflow is not defined for Signed types. This function could be\n                 // implemented for signed types as well if that were needed.\n                 Some(y) => return (y, low + new_low_bits),\n-                None => fail!(\"Numeric overflow occured.\")\n+                None => fail2!(\"Numeric overflow occured.\")\n             }\n         }\n     }"}, {"sha": "bf91c5c5d7e6fe6526cf1947330390a0df7eb956", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -632,11 +632,11 @@ pub fn check_links<T>(list: &DList<T>) {\n     loop {\n         match (last_ptr, node_ptr.prev.resolve_immut()) {\n             (None   , None      ) => {}\n-            (None   , _         ) => fail!(\"prev link for list_head\"),\n+            (None   , _         ) => fail2!(\"prev link for list_head\"),\n             (Some(p), Some(pptr)) => {\n                 assert_eq!(p as *Node<T>, pptr as *Node<T>);\n             }\n-            _ => fail!(\"prev link is none, not good\"),\n+            _ => fail2!(\"prev link is none, not good\"),\n         }\n         match node_ptr.next {\n             Some(ref next) => {"}, {"sha": "8cba1a417d049651fa11c58a164cd75fcd62eb41", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -138,7 +138,7 @@ pub mod reader {\n                         (data[start + 3u] as uint),\n                     next: start + 4u};\n         }\n-        fail!(\"vint too big\");\n+        fail2!(\"vint too big\");\n     }\n \n     #[cfg(target_arch = \"x86\")]\n@@ -216,8 +216,8 @@ pub mod reader {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n-                error!(\"failed to find block with tag %u\", tg);\n-                fail!();\n+                error2!(\"failed to find block with tag {}\", tg);\n+                fail2!();\n             }\n         }\n     }\n@@ -305,31 +305,32 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        fail!(\"Expected label %s but found %s\", lbl, str);\n+                        fail2!(\"Expected label {} but found {}\", lbl, str);\n                     }\n                 }\n             }\n         }\n \n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc {\n-            debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n+            debug2!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n-                fail!(\"no more documents in current node!\");\n+                fail2!(\"no more documents in current node!\");\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 doc_at(self.parent.data, self.pos);\n-            debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+            debug2!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n                    self.parent.start,\n                    self.parent.end,\n                    self.pos,\n                    r_tag,\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                fail!(\"expected EBML doc with tag %? but found tag %?\", exp_tag, r_tag);\n+                fail2!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n+                       exp_tag, r_tag);\n             }\n             if r_doc.end > self.parent.end {\n-                fail!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                fail2!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n                       r_doc.end, self.parent.end);\n             }\n             self.pos = r_doc.end;\n@@ -351,7 +352,7 @@ pub mod reader {\n \n         fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n-            debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n+            debug2!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n             r as uint\n         }\n     }\n@@ -383,7 +384,7 @@ pub mod reader {\n         fn read_uint(&mut self) -> uint {\n             let v = doc_as_u64(self.next_doc(EsUint));\n             if v > (::std::uint::max_value as u64) {\n-                fail!(\"uint %? too large for this architecture\", v);\n+                fail2!(\"uint {} too large for this architecture\", v);\n             }\n             v as uint\n         }\n@@ -403,8 +404,8 @@ pub mod reader {\n         fn read_int(&mut self) -> int {\n             let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n             if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-                debug!(\"FIXME #6122: Removing this makes this function miscompile\");\n-                fail!(\"int %? out of range for this architecture\", v);\n+                debug2!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n+                fail2!(\"int {} out of range for this architecture\", v);\n             }\n             v as int\n         }\n@@ -437,7 +438,7 @@ pub mod reader {\n                         name: &str,\n                         f: &fn(&mut Decoder) -> T)\n                         -> T {\n-            debug!(\"read_enum(%s)\", name);\n+            debug2!(\"read_enum({})\", name);\n             self._check_label(name);\n \n             let doc = self.next_doc(EsEnum);\n@@ -457,9 +458,9 @@ pub mod reader {\n                                 _: &[&str],\n                                 f: &fn(&mut Decoder, uint) -> T)\n                                 -> T {\n-            debug!(\"read_enum_variant()\");\n+            debug2!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx=%u\", idx);\n+            debug2!(\"  idx={}\", idx);\n \n             let doc = self.next_doc(EsEnumBody);\n \n@@ -477,17 +478,17 @@ pub mod reader {\n         fn read_enum_variant_arg<T>(&mut self,\n                                     idx: uint,\n                                     f: &fn(&mut Decoder) -> T) -> T {\n-            debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+            debug2!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n         fn read_enum_struct_variant<T>(&mut self,\n                                        _: &[&str],\n                                        f: &fn(&mut Decoder, uint) -> T)\n                                        -> T {\n-            debug!(\"read_enum_struct_variant()\");\n+            debug2!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx=%u\", idx);\n+            debug2!(\"  idx={}\", idx);\n \n             let doc = self.next_doc(EsEnumBody);\n \n@@ -507,7 +508,7 @@ pub mod reader {\n                                              idx: uint,\n                                              f: &fn(&mut Decoder) -> T)\n                                              -> T {\n-            debug!(\"read_enum_struct_variant_arg(name=%?, idx=%u)\", name, idx);\n+            debug2!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n@@ -516,7 +517,7 @@ pub mod reader {\n                           _: uint,\n                           f: &fn(&mut Decoder) -> T)\n                           -> T {\n-            debug!(\"read_struct(name=%s)\", name);\n+            debug2!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n@@ -525,71 +526,71 @@ pub mod reader {\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-            debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+            debug2!(\"read_struct_field(name={}, idx={})\", name, idx);\n             self._check_label(name);\n             f(self)\n         }\n \n         fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug!(\"read_tuple()\");\n+            debug2!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n         fn read_tuple_arg<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                              -> T {\n-            debug!(\"read_tuple_arg(idx=%u)\", idx);\n+            debug2!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n                                 f: &fn(&mut Decoder, uint) -> T)\n                                 -> T {\n-            debug!(\"read_tuple_struct(name=%?)\", name);\n+            debug2!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,\n                                     idx: uint,\n                                     f: &fn(&mut Decoder) -> T)\n                                     -> T {\n-            debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+            debug2!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n         fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n-            debug!(\"read_option()\");\n+            debug2!(\"read_option()\");\n             do self.read_enum(\"Option\") |this| {\n                 do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n-                        _ => fail!(),\n+                        _ => fail2!(),\n                     }\n                 }\n             }\n         }\n \n         fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug!(\"read_seq()\");\n+            debug2!(\"read_seq()\");\n             do self.push_doc(EsVec) |d| {\n                 let len = d._next_uint(EsVecLen);\n-                debug!(\"  len=%u\", len);\n+                debug2!(\"  len={}\", len);\n                 f(d, len)\n             }\n         }\n \n         fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n-            debug!(\"read_seq_elt(idx=%u)\", idx);\n+            debug2!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n         fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug!(\"read_map()\");\n+            debug2!(\"read_map()\");\n             do self.push_doc(EsMap) |d| {\n                 let len = d._next_uint(EsMapLen);\n-                debug!(\"  len=%u\", len);\n+                debug2!(\"  len={}\", len);\n                 f(d, len)\n             }\n         }\n@@ -598,15 +599,15 @@ pub mod reader {\n                                idx: uint,\n                                f: &fn(&mut Decoder) -> T)\n                                -> T {\n-            debug!(\"read_map_elt_key(idx=%u)\", idx);\n+            debug2!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n         fn read_map_elt_val<T>(&mut self,\n                                idx: uint,\n                                f: &fn(&mut Decoder) -> T)\n                                -> T {\n-            debug!(\"read_map_elt_val(idx=%u)\", idx);\n+            debug2!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n         }\n     }\n@@ -642,7 +643,7 @@ pub mod writer {\n                             n as u8]),\n             4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n-            _ => fail!(\"vint to write too big: %?\", n)\n+            _ => fail2!(\"vint to write too big: {}\", n)\n         };\n     }\n \n@@ -651,7 +652,7 @@ pub mod writer {\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-        fail!(\"vint to write too big: %?\", n);\n+        fail2!(\"vint to write too big: {}\", n);\n     }\n \n     pub fn Encoder(w: @io::Writer) -> Encoder {\n@@ -665,7 +666,7 @@ pub mod writer {\n     // FIXME (#2741): Provide a function to write the standard ebml header.\n     impl Encoder {\n         pub fn start_tag(&mut self, tag_id: uint) {\n-            debug!(\"Start tag %u\", tag_id);\n+            debug2!(\"Start tag {}\", tag_id);\n \n             // Write the enum ID:\n             write_vuint(self.writer, tag_id);\n@@ -684,7 +685,7 @@ pub mod writer {\n             write_sized_vuint(self.writer, size, 4u);\n             self.writer.seek(cur_pos as int, io::SeekSet);\n \n-            debug!(\"End tag (size = %u)\", size);\n+            debug2!(\"End tag (size = {})\", size);\n         }\n \n         pub fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n@@ -748,12 +749,12 @@ pub mod writer {\n         }\n \n         pub fn wr_bytes(&mut self, b: &[u8]) {\n-            debug!(\"Write %u bytes\", b.len());\n+            debug2!(\"Write {} bytes\", b.len());\n             self.writer.write(b);\n         }\n \n         pub fn wr_str(&mut self, s: &str) {\n-            debug!(\"Write str: %?\", s);\n+            debug2!(\"Write str: {}\", s);\n             self.writer.write(s.as_bytes());\n         }\n     }\n@@ -977,15 +978,15 @@ mod tests {\n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n-            debug!(\"v == %?\", v);\n+            debug2!(\"v == {:?}\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n                 let mut ebml_w = writer::Encoder(wr);\n                 v.encode(&mut ebml_w)\n             };\n             let ebml_doc = reader::Doc(@bytes);\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n-            debug!(\"v1 == %?\", v1);\n+            debug2!(\"v1 == {:?}\", v1);\n             assert_eq!(v, v1);\n         }\n "}, {"sha": "37bcb447f082eaec62858d8dfc24cf88a9167796", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -43,7 +43,7 @@ to handle any `FileInput` structs. E.g. a simple `cat` program\n or a program that numbers lines after concatenating two files\n \n     for input_vec_state(make_path_option_vec([~\"a.txt\", ~\"b.txt\"])) |line, state| {\n-        io::println(fmt!(\"%u: %s\", state.line_num,\n+        io::println(format!(\"{}: %s\", state.line_num,\n                                    line));\n     }\n \n@@ -88,7 +88,7 @@ total line count).\n         input.next_file(); // skip!\n \n         for input.each_line_state |line, state| {\n-           io::println(fmt!(\"%u: %s\", state.line_num_file,\n+           io::println(format!(\"{}: %s\", state.line_num_file,\n                                       line))\n         }\n     }\n@@ -449,11 +449,11 @@ mod test {\n     fn test_fileinput_read_byte() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n+            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-byte-{}.tmp\", i)), true);\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n         for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames.clone());\n@@ -479,11 +479,11 @@ mod test {\n     fn test_fileinput_read() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n+            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-{}.tmp\", i)), true);\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n         for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames);\n@@ -500,13 +500,13 @@ mod test {\n         let mut all_lines = ~[];\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n+            |i| format!(\"tmp/lib-fileinput-test-input-vec-{}.tmp\", i)), true);\n \n         for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n-                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n+                vec::from_fn(3, |j| format!(\"{} {}\", i, j));\n             make_file(filename.get_ref(), contents);\n-            debug!(\"contents=%?\", contents);\n+            debug2!(\"contents={:?}\", contents);\n             all_lines.push_all(contents);\n         }\n \n@@ -522,11 +522,11 @@ mod test {\n     fn test_input_vec_state() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n+            |i| format!(\"tmp/lib-fileinput-test-input-vec-state-{}.tmp\", i)),true);\n \n         for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n-                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n+                vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n         }\n \n@@ -544,7 +544,7 @@ mod test {\n     fn test_empty_files() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-empty-files-%u.tmp\", i)),true);\n+            |i| format!(\"tmp/lib-fileinput-test-empty-files-{}.tmp\", i)),true);\n \n         make_file(filenames[0].get_ref(), [~\"1\", ~\"2\"]);\n         make_file(filenames[1].get_ref(), []);\n@@ -555,7 +555,7 @@ mod test {\n             let expected_path = match line {\n                 \"1\" | \"2\" => filenames[0].clone(),\n                 \"3\" | \"4\" => filenames[2].clone(),\n-                _ => fail!(\"unexpected line\")\n+                _ => fail2!(\"unexpected line\")\n             };\n             assert_eq!(state.current_path.clone(), expected_path);\n             count += 1;\n@@ -593,11 +593,11 @@ mod test {\n     fn test_next_file() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n+            |i| format!(\"tmp/lib-fileinput-test-next-file-{}.tmp\", i)),true);\n \n         for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n-                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n+                vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n         }\n \n@@ -609,7 +609,7 @@ mod test {\n \n         // read all lines from 1 (but don't read any from 2),\n         for i in range(1u, 4) {\n-            assert_eq!(input.read_line(), fmt!(\"1 %u\", i));\n+            assert_eq!(input.read_line(), format!(\"1 {}\", i));\n         }\n         // 1 is finished, but 2 hasn't been started yet, so this will\n         // just \"skip\" to the beginning of 2 (Python's fileinput does"}, {"sha": "616c7522a488bfc357a60f47cdf7f714c3fca057", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -121,11 +121,11 @@ mod tests {\n             do 2000.times {\n                 input.push_all(r.choose(words));\n             }\n-            debug!(\"de/inflate of %u bytes of random word-sequences\",\n+            debug2!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n             let cmp = deflate_bytes(input);\n             let out = inflate_bytes(cmp);\n-            debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n+            debug2!(\"{} bytes deflated to {} ({:.1f}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as float) / (input.len() as float)));\n             assert_eq!(input, out);"}, {"sha": "1fd81626188c526c3279485b032e68d970cd2a71", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -261,14 +261,14 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n     fn recv(&self) -> T {\n         match self.try_recv() {\n             Some(val) => val,\n-            None => fail!(\"port is closed\")\n+            None => fail2!(\"port is closed\")\n         }\n     }\n     fn try_recv(&self) -> Option<T> {\n         let command = match self.byte_port.try_recv(CONTINUE.len()) {\n             Some(c) => c,\n             None => {\n-                warn!(\"flatpipe: broken pipe\");\n+                warn2!(\"flatpipe: broken pipe\");\n                 return None;\n             }\n         };\n@@ -279,7 +279,7 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n                     io::u64_from_be_bytes(bytes, 0, size_of::<u64>())\n                 },\n                 None => {\n-                    warn!(\"flatpipe: broken pipe\");\n+                    warn2!(\"flatpipe: broken pipe\");\n                     return None;\n                 }\n             };\n@@ -291,13 +291,13 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n                     Some(self.unflattener.unflatten(bytes))\n                 }\n                 None => {\n-                    warn!(\"flatpipe: broken pipe\");\n+                    warn2!(\"flatpipe: broken pipe\");\n                     return None;\n                 }\n             }\n         }\n         else {\n-            fail!(\"flatpipe: unrecognized command\");\n+            fail2!(\"flatpipe: unrecognized command\");\n         }\n     }\n }\n@@ -477,7 +477,7 @@ pub mod flatteners {\n                 Ok(json) => {\n                     json::Decoder(json)\n                 }\n-                Err(e) => fail!(\"flatpipe: can't parse json: %?\", e)\n+                Err(e) => fail2!(\"flatpipe: can't parse json: {:?}\", e)\n             }\n         }\n     }\n@@ -536,7 +536,7 @@ pub mod bytepipes {\n             if left == 0 {\n                 return Some(bytes);\n             } else {\n-                warn!(\"flatpipe: dropped %? broken bytes\", left);\n+                warn2!(\"flatpipe: dropped {} broken bytes\", left);\n                 return None;\n             }\n         }\n@@ -797,7 +797,7 @@ mod test {\n             let listen_res = do tcp::listen(\n                 addr.clone(), port, 128, iotask, |_kill_ch| {\n                     // Tell the sender to initiate the connection\n-                    debug!(\"listening\");\n+                    debug2!(\"listening\");\n                     begin_connect_chan.send(())\n                 }) |new_conn, kill_ch| {\n \n@@ -820,7 +820,7 @@ mod test {\n             // Wait for the server to start listening\n             begin_connect_port.recv();\n \n-            debug!(\"connecting\");\n+            debug2!(\"connecting\");\n             let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(addr.clone(), port, iotask);\n             assert!(connect_result.is_ok());\n@@ -831,7 +831,7 @@ mod test {\n             let chan = writer_chan(socket_buf);\n \n             for i in range(0, 10) {\n-                debug!(\"sending %?\", i);\n+                debug2!(\"sending {}\", i);\n                 chan.send(i)\n             }\n         }\n@@ -841,9 +841,9 @@ mod test {\n             // Wait for a connection\n             let (conn, res_chan) = accept_port.recv();\n \n-            debug!(\"accepting connection\");\n+            debug2!(\"accepting connection\");\n             let accept_result = tcp::accept(conn);\n-            debug!(\"accepted\");\n+            debug2!(\"accepted\");\n             assert!(accept_result.is_ok());\n             let sock = result::unwrap(accept_result);\n             res_chan.send(());\n@@ -855,7 +855,7 @@ mod test {\n \n             for i in range(0, 10) {\n                 let j = port.recv();\n-                debug!(\"received %?\", j);\n+                debug2!(\"received {:?}\", j);\n                 assert_eq!(i, j);\n             }\n "}, {"sha": "516a34f531283c14ca1df5f6019ec2d125a5fd13", "filename": "src/libextra/future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -57,7 +57,7 @@ impl<A> Future<A> {\n         let state = replace(&mut this.state, Evaluating);\n         match state {\n             Forced(v) => v,\n-            _ => fail!( \"Logic error.\" ),\n+            _ => fail2!( \"Logic error.\" ),\n         }\n     }\n \n@@ -69,10 +69,10 @@ impl<A> Future<A> {\n         */\n         match self.state {\n             Forced(ref v) => return v,\n-            Evaluating => fail!(\"Recursive forcing of future!\"),\n+            Evaluating => fail2!(\"Recursive forcing of future!\"),\n             Pending(_) => {\n                 match replace(&mut self.state, Evaluating) {\n-                    Forced(_) | Evaluating => fail!(\"Logic error.\"),\n+                    Forced(_) | Evaluating => fail2!(\"Logic error.\"),\n                     Pending(f) => {\n                         self.state = Forced(f());\n                         self.get_ref()\n@@ -217,7 +217,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_futurefail() {\n-        let mut f = Future::spawn(|| fail!());\n+        let mut f = Future::spawn(|| fail2!());\n         let _x: ~str = f.get();\n     }\n "}, {"sha": "e9ccbbf605a371ec7a32e90092871cebf7eff763", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -60,7 +60,7 @@\n //!     ];\n //!     let matches = match getopts(args.tail(), opts) {\n //!         Ok(m) => { m }\n-//!         Err(f) => { fail!(f.to_err_msg()) }\n+//!         Err(f) => { fail2!(f.to_err_msg()) }\n //!     };\n //!     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n //!         print_usage(program, opts);\n@@ -185,7 +185,7 @@ impl Matches {\n     pub fn opt_vals(&self, nm: &str) -> ~[Optval] {\n         match find_opt(self.opts, Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n-            None => fail!(\"No option '%s' defined\", nm)\n+            None => fail2!(\"No option '{}' defined\", nm)\n         }\n     }\n \n@@ -365,19 +365,19 @@ impl Fail_ {\n     pub fn to_err_msg(self) -> ~str {\n         match self {\n             ArgumentMissing(ref nm) => {\n-                fmt!(\"Argument to option '%s' missing.\", *nm)\n+                format!(\"Argument to option '{}' missing.\", *nm)\n             }\n             UnrecognizedOption(ref nm) => {\n-                fmt!(\"Unrecognized option: '%s'.\", *nm)\n+                format!(\"Unrecognized option: '{}'.\", *nm)\n             }\n             OptionMissing(ref nm) => {\n-                fmt!(\"Required option '%s' missing.\", *nm)\n+                format!(\"Required option '{}' missing.\", *nm)\n             }\n             OptionDuplicated(ref nm) => {\n-                fmt!(\"Option '%s' given more than once.\", *nm)\n+                format!(\"Option '{}' given more than once.\", *nm)\n             }\n             UnexpectedArgument(ref nm) => {\n-                fmt!(\"Option '%s' does not take an argument.\", *nm)\n+                format!(\"Option '{}' does not take an argument.\", *nm)\n             }\n         }\n     }\n@@ -551,7 +551,7 @@ pub mod groups {\n             } = (*self).clone();\n \n             match (short_name.len(), long_name.len()) {\n-                (0,0) => fail!(\"this long-format option was given no name\"),\n+                (0,0) => fail2!(\"this long-format option was given no name\"),\n                 (0,_) => Opt {\n                     name: Long((long_name)),\n                     hasarg: hasarg,\n@@ -577,7 +577,7 @@ pub mod groups {\n                         }\n                     ]\n                 },\n-                (_,_) => fail!(\"something is wrong with the long-form opt\")\n+                (_,_) => fail2!(\"something is wrong with the long-form opt\")\n             }\n         }\n     }\n@@ -696,7 +696,7 @@ pub mod groups {\n                     row.push_str(short_name);\n                     row.push_char(' ');\n                 }\n-                _ => fail!(\"the short name should only be 1 ascii char long\"),\n+                _ => fail2!(\"the short name should only be 1 ascii char long\"),\n             }\n \n             // long option\n@@ -752,7 +752,7 @@ pub mod groups {\n             row\n         });\n \n-        fmt!(\"%s\\n\\nOptions:\\n%s\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+        format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n     }\n \n     /// Splits a string into substrings with possibly internal whitespace,\n@@ -810,7 +810,7 @@ pub mod groups {\n \n                 (B, Cr, UnderLim) => { B }\n                 (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                                => fail!(\"word starting with %? longer than limit!\",\n+                                => fail2!(\"word starting with {} longer than limit!\",\n                                         ss.slice(last_start, i + 1)),\n                 (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n                 (B, Ws, UnderLim) => { last_end = i; C }\n@@ -883,7 +883,7 @@ mod tests {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => { fail!(\"test_reqopt_long failed\"); }\n+          _ => { fail2!(\"test_reqopt_long failed\"); }\n         }\n     }\n \n@@ -894,7 +894,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -905,7 +905,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -916,7 +916,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -930,7 +930,7 @@ mod tests {\n             assert!(m.opt_present(\"t\"));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -941,7 +941,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -952,7 +952,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -963,7 +963,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -979,7 +979,7 @@ mod tests {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -990,7 +990,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1001,7 +1001,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1012,7 +1012,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1026,7 +1026,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1037,7 +1037,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1048,7 +1048,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1059,7 +1059,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1072,7 +1072,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1083,7 +1083,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1094,10 +1094,10 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => {\n-            error!(f.clone().to_err_msg());\n+            error2!(\"{:?}\", f.clone().to_err_msg());\n             check_fail_type(f, UnexpectedArgument_);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1108,7 +1108,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1119,7 +1119,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1130,7 +1130,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1145,7 +1145,7 @@ mod tests {\n \n             assert!(m.free[0] == ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1156,7 +1156,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1170,7 +1170,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 1);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1183,7 +1183,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1196,7 +1196,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1209,7 +1209,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 1);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1222,7 +1222,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 2);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1237,7 +1237,7 @@ mod tests {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1248,7 +1248,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1259,7 +1259,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1276,7 +1276,7 @@ mod tests {\n               assert!(pair[0] == ~\"20\");\n               assert!(pair[1] == ~\"30\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1290,7 +1290,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1301,7 +1301,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1312,7 +1312,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1329,7 +1329,7 @@ mod tests {\n             assert!(pair[0] == ~\"20\");\n             assert!(pair[1] == ~\"30\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1340,7 +1340,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1351,7 +1351,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1383,7 +1383,7 @@ mod tests {\n             assert!(pair[1] == ~\"-60 70\");\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1394,7 +1394,7 @@ mod tests {\n         let args_single = ~[~\"-e\", ~\"foo\"];\n         let matches_single = &match getopts(args_single, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => fail2!()\n         };\n         assert!(matches_single.opts_present([~\"e\"]));\n         assert!(matches_single.opts_present([~\"encrypt\", ~\"e\"]));\n@@ -1410,7 +1410,7 @@ mod tests {\n         let args_both = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let matches_both = &match getopts(args_both, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => fail2!()\n         };\n         assert!(matches_both.opts_present([~\"e\"]));\n         assert!(matches_both.opts_present([~\"encrypt\"]));\n@@ -1432,7 +1432,7 @@ mod tests {\n         let opts = ~[optmulti(\"L\"), optmulti(\"M\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => fail2!()\n         };\n         assert!(matches.opts_present([~\"L\"]));\n         assert_eq!(matches.opts_str([~\"L\"]).unwrap(), ~\"foo\");\n@@ -1575,8 +1575,8 @@ Options:\n \n         let generated_usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug!(\"expected: <<%s>>\", expected);\n-        debug!(\"generated: <<%s>>\", generated_usage);\n+        debug2!(\"expected: <<{}>>\", expected);\n+        debug2!(\"generated: <<{}>>\", generated_usage);\n         assert_eq!(generated_usage, expected);\n     }\n \n@@ -1603,8 +1603,8 @@ Options:\n \n         let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug!(\"expected: <<%s>>\", expected);\n-        debug!(\"generated: <<%s>>\", usage);\n+        debug2!(\"expected: <<{}>>\", expected);\n+        debug2!(\"generated: <<{}>>\", usage);\n         assert!(usage == expected)\n     }\n \n@@ -1630,8 +1630,8 @@ Options:\n \n         let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug!(\"expected: <<%s>>\", expected);\n-        debug!(\"generated: <<%s>>\", usage);\n+        debug2!(\"expected: <<{}>>\", expected);\n+        debug2!(\"generated: <<{}>>\", usage);\n         assert!(usage == expected)\n     }\n }"}, {"sha": "9af2f1acc693138d431a3a52ab81f4c57fe003a5", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -552,13 +552,13 @@ mod test {\n \n         let pat = Pattern::new(\"a[0-9]b\");\n         for i in range(0, 10) {\n-            assert!(pat.matches(fmt!(\"a%db\", i)));\n+            assert!(pat.matches(format!(\"a{}b\", i)));\n         }\n         assert!(!pat.matches(\"a_b\"));\n \n         let pat = Pattern::new(\"a[!0-9]b\");\n         for i in range(0, 10) {\n-            assert!(!pat.matches(fmt!(\"a%db\", i)));\n+            assert!(!pat.matches(format!(\"a{}b\", i)));\n         }\n         assert!(pat.matches(\"a_b\"));\n "}, {"sha": "709b4a95981f2c6f72dde1ddd64676665090933b", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -102,8 +102,8 @@ impl<'self> FromHex for &'self str {\n                     buf >>= 4;\n                     loop\n                 }\n-                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n-                                     self.char_at(idx), idx))\n+                _ => return Err(format!(\"Invalid character '{}' at position {}\",\n+                                        self.char_at(idx), idx))\n             }\n \n             modulus += 1;\n@@ -158,15 +158,15 @@ mod tests {\n     #[test]\n     pub fn test_to_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!([i as u8].to_hex(), fmt!(\"%02x\", i as uint));\n+            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n         }\n     }\n \n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!(fmt!(\"%02x\", i as uint).from_hex().unwrap(), ~[i as u8]);\n-            assert_eq!(fmt!(\"%02X\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(format!(\"{:02x}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(format!(\"{:02X}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n         }\n     }\n "}, {"sha": "fe1bbfc9ae4c862d57a682afee5fa2cc308868d0", "filename": "src/libextra/json.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -885,10 +885,10 @@ pub fn Decoder(json: Json) -> Decoder {\n \n impl serialize::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n-        debug!(\"read_nil\");\n+        debug2!(\"read_nil\");\n         match self.stack.pop() {\n             Null => (),\n-            value => fail!(\"not a null: %?\", value)\n+            value => fail2!(\"not a null: {:?}\", value)\n         }\n     }\n \n@@ -905,71 +905,71 @@ impl serialize::Decoder for Decoder {\n     fn read_int(&mut self) -> int { self.read_float() as int }\n \n     fn read_bool(&mut self) -> bool {\n-        debug!(\"read_bool\");\n+        debug2!(\"read_bool\");\n         match self.stack.pop() {\n             Boolean(b) => b,\n-            value => fail!(\"not a boolean: %?\", value)\n+            value => fail2!(\"not a boolean: {:?}\", value)\n         }\n     }\n \n     fn read_f64(&mut self) -> f64 { self.read_float() as f64 }\n     fn read_f32(&mut self) -> f32 { self.read_float() as f32 }\n     fn read_float(&mut self) -> float {\n-        debug!(\"read_float\");\n+        debug2!(\"read_float\");\n         match self.stack.pop() {\n             Number(f) => f,\n-            value => fail!(\"not a number: %?\", value)\n+            value => fail2!(\"not a number: {:?}\", value)\n         }\n     }\n \n     fn read_char(&mut self) -> char {\n         let mut v = ~[];\n         let s = self.read_str();\n         for c in s.iter() { v.push(c) }\n-        if v.len() != 1 { fail!(\"string must have one character\") }\n+        if v.len() != 1 { fail2!(\"string must have one character\") }\n         v[0]\n     }\n \n     fn read_str(&mut self) -> ~str {\n-        debug!(\"read_str\");\n+        debug2!(\"read_str\");\n         match self.stack.pop() {\n             String(s) => s,\n-            json => fail!(\"not a string: %?\", json)\n+            json => fail2!(\"not a string: {:?}\", json)\n         }\n     }\n \n     fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Decoder) -> T) -> T {\n-        debug!(\"read_enum(%s)\", name);\n+        debug2!(\"read_enum({})\", name);\n         f(self)\n     }\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n                             f: &fn(&mut Decoder, uint) -> T)\n                             -> T {\n-        debug!(\"read_enum_variant(names=%?)\", names);\n+        debug2!(\"read_enum_variant(names={:?})\", names);\n         let name = match self.stack.pop() {\n             String(s) => s,\n             Object(o) => {\n                 let n = match o.find(&~\"variant\").expect(\"invalidly encoded json\") {\n                     &String(ref s) => s.clone(),\n-                    _ => fail!(\"invalidly encoded json\"),\n+                    _ => fail2!(\"invalidly encoded json\"),\n                 };\n                 match o.find(&~\"fields\").expect(\"invalidly encoded json\") {\n                     &List(ref l) => {\n                         for field in l.rev_iter() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    _ => fail!(\"invalidly encoded json\")\n+                    _ => fail2!(\"invalidly encoded json\")\n                 }\n                 n\n             }\n-            ref json => fail!(\"invalid variant: %?\", *json),\n+            ref json => fail2!(\"invalid variant: {:?}\", *json),\n         };\n         let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n-            None => fail!(\"Unknown variant name: %?\", name),\n+            None => fail2!(\"Unknown variant name: {}\", name),\n         };\n         f(self, idx)\n     }\n@@ -978,15 +978,15 @@ impl serialize::Decoder for Decoder {\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+        debug2!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n                                    f: &fn(&mut Decoder, uint) -> T)\n                                    -> T {\n-        debug!(\"read_enum_struct_variant(names=%?)\", names);\n+        debug2!(\"read_enum_struct_variant(names={:?})\", names);\n         self.read_enum_variant(names, f)\n     }\n \n@@ -996,7 +996,7 @@ impl serialize::Decoder for Decoder {\n                                          idx: uint,\n                                          f: &fn(&mut Decoder) -> T)\n                                          -> T {\n-        debug!(\"read_enum_struct_variant_field(name=%?, idx=%u)\", name, idx);\n+        debug2!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n@@ -1005,7 +1005,7 @@ impl serialize::Decoder for Decoder {\n                       len: uint,\n                       f: &fn(&mut Decoder) -> T)\n                       -> T {\n-        debug!(\"read_struct(name=%s, len=%u)\", name, len);\n+        debug2!(\"read_struct(name={}, len={})\", name, len);\n         let value = f(self);\n         self.stack.pop();\n         value\n@@ -1016,12 +1016,12 @@ impl serialize::Decoder for Decoder {\n                             idx: uint,\n                             f: &fn(&mut Decoder) -> T)\n                             -> T {\n-        debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+        debug2!(\"read_struct_field(name={}, idx={})\", name, idx);\n         match self.stack.pop() {\n             Object(obj) => {\n                 let mut obj = obj;\n                 let value = match obj.pop(&name.to_owned()) {\n-                    None => fail!(\"no such field: %s\", name),\n+                    None => fail2!(\"no such field: {}\", name),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f(self)\n@@ -1030,36 +1030,36 @@ impl serialize::Decoder for Decoder {\n                 self.stack.push(Object(obj));\n                 value\n             }\n-            value => fail!(\"not an object: %?\", value)\n+            value => fail2!(\"not an object: {:?}\", value)\n         }\n     }\n \n     fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug!(\"read_tuple()\");\n+        debug2!(\"read_tuple()\");\n         self.read_seq(f)\n     }\n \n     fn read_tuple_arg<T>(&mut self,\n                          idx: uint,\n                          f: &fn(&mut Decoder) -> T)\n                          -> T {\n-        debug!(\"read_tuple_arg(idx=%u)\", idx);\n+        debug2!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T>(&mut self,\n                             name: &str,\n                             f: &fn(&mut Decoder, uint) -> T)\n                             -> T {\n-        debug!(\"read_tuple_struct(name=%?)\", name);\n+        debug2!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(f)\n     }\n \n     fn read_tuple_struct_arg<T>(&mut self,\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-        debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+        debug2!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n@@ -1071,7 +1071,7 @@ impl serialize::Decoder for Decoder {\n     }\n \n     fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug!(\"read_seq()\");\n+        debug2!(\"read_seq()\");\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n@@ -1080,18 +1080,18 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            _ => fail!(\"not a list\"),\n+            _ => fail2!(\"not a list\"),\n         };\n         f(self, len)\n     }\n \n     fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T) -> T {\n-        debug!(\"read_seq_elt(idx=%u)\", idx);\n+        debug2!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug!(\"read_map()\");\n+        debug2!(\"read_map()\");\n         let len = match self.stack.pop() {\n             Object(obj) => {\n                 let len = obj.len();\n@@ -1101,7 +1101,7 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            json => fail!(\"not an object: %?\", json),\n+            json => fail2!(\"not an object: {:?}\", json),\n         };\n         f(self, len)\n     }\n@@ -1110,13 +1110,13 @@ impl serialize::Decoder for Decoder {\n                            idx: uint,\n                            f: &fn(&mut Decoder) -> T)\n                            -> T {\n-        debug!(\"read_map_elt_key(idx=%u)\", idx);\n+        debug2!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n-        debug!(\"read_map_elt_val(idx=%u)\", idx);\n+        debug2!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n     }\n }\n@@ -1321,7 +1321,7 @@ impl to_str::ToStr for Json {\n \n impl to_str::ToStr for Error {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n+        format!(\"{}:{}: {}\", self.line, self.col, *self.msg)\n     }\n }\n "}, {"sha": "5283edbf475e08a3a47f68971c5a9fee406f66de", "filename": "src/libextra/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -96,7 +96,7 @@ pub fn len<T>(ls: @List<T>) -> uint {\n pub fn tail<T>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n-        Nil => fail!(\"list empty\")\n+        Nil => fail2!(\"list empty\")\n     }\n }\n \n@@ -105,7 +105,7 @@ pub fn head<T:Clone>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(ref hd, _) => (*hd).clone(),\n       // makes me sad\n-      _ => fail!(\"head invoked on empty list\")\n+      _ => fail2!(\"head invoked on empty list\")\n     }\n }\n "}, {"sha": "2ec9c7471799f76a3abe59812e679e37b8cb133a", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -352,7 +352,7 @@ impl Rem<BigUint, BigUint> for BigUint {\n \n impl Neg<BigUint> for BigUint {\n     #[inline]\n-    fn neg(&self) -> BigUint { fail!() }\n+    fn neg(&self) -> BigUint { fail2!() }\n }\n \n impl Integer for BigUint {\n@@ -374,7 +374,7 @@ impl Integer for BigUint {\n     }\n \n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail!() }\n+        if other.is_zero() { fail2!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return ((*self).clone(), Zero::zero()); }\n \n@@ -726,7 +726,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (1475789056, 8),\n         15 => (2562890625, 8),\n         16 => (4294967296, 8),\n-        _  => fail!()\n+        _  => fail2!()\n     }\n }\n \n@@ -750,7 +750,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (38416, 4),\n         15 => (50625, 4),\n         16 => (65536, 4),\n-        _  => fail!()\n+        _  => fail2!()\n     }\n }\n \n@@ -1004,7 +1004,7 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let r = BigInt::from_biguint(Plus, r_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n+            (_,    Zero)   => fail2!(),\n             (Plus, Plus)  | (Zero, Plus)  => ( d,  r),\n             (Plus, Minus) | (Zero, Minus) => (-d,  r),\n             (Minus, Plus)                 => (-d, -r),\n@@ -1030,7 +1030,7 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n+            (_,    Zero)   => fail2!(),\n             (Plus, Plus)  | (Zero, Plus)  => (d, m),\n             (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n                 (-d, Zero::zero())\n@@ -1742,7 +1742,7 @@ mod biguint_tests {\n              ~\"2\" +\n              str::from_chars(vec::from_elem(bits / 2 - 1, '0')) + \"1\"),\n             (10, match bits {\n-                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail!()\n+                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail2!()\n             }),\n             (16,\n              ~\"2\" +\n@@ -1759,7 +1759,7 @@ mod biguint_tests {\n             (10, match bits {\n                 32 => ~\"55340232229718589441\",\n                 16 => ~\"12885032961\",\n-                _ => fail!()\n+                _ => fail2!()\n             }),\n             (16, ~\"3\" +\n              str::from_chars(vec::from_elem(bits / 4 - 1, '0')) + \"2\" +\n@@ -1814,7 +1814,7 @@ mod biguint_tests {\n         fn check(n: uint, s: &str) {\n             let n = factor(n);\n             let ans = match FromStrRadix::from_str_radix(s, 10) {\n-                Some(x) => x, None => fail!()\n+                Some(x) => x, None => fail2!()\n             };\n             assert_eq!(n, ans);\n         }"}, {"sha": "8943e2ac012df6b10232b5653af1ee288b815170", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -172,19 +172,19 @@ impl<T: Clone + Num> One for Cmplx<T> {\n impl<T: ToStr + Num + Ord> ToStr for Cmplx<T> {\n     fn to_str(&self) -> ~str {\n         if self.im < Zero::zero() {\n-            fmt!(\"%s-%si\", self.re.to_str(), (-self.im).to_str())\n+            format!(\"{}-{}i\", self.re.to_str(), (-self.im).to_str())\n         } else {\n-            fmt!(\"%s+%si\", self.re.to_str(), self.im.to_str())\n+            format!(\"{}+{}i\", self.re.to_str(), self.im.to_str())\n         }\n     }\n }\n \n impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         if self.im < Zero::zero() {\n-            fmt!(\"%s-%si\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n+            format!(\"{}-{}i\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n         } else {\n-            fmt!(\"%s+%si\", self.re.to_str_radix(radix), self.im.to_str_radix(radix))\n+            format!(\"{}+{}i\", self.re.to_str_radix(radix), self.im.to_str_radix(radix))\n         }\n     }\n }"}, {"sha": "e7142f6f9ff243c15d4d0e52730083326ad959e4", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -50,7 +50,7 @@ impl<T: Clone + Integer + Ord>\n     #[inline]\n     pub fn new(numer: T, denom: T) -> Ratio<T> {\n         if denom == Zero::zero() {\n-            fail!(\"denominator == 0\");\n+            fail2!(\"denominator == 0\");\n         }\n         let mut ret = Ratio::new_raw(numer, denom);\n         ret.reduce();\n@@ -254,13 +254,13 @@ impl<T: Clone + Integer + Ord> Fractional for Ratio<T> {\n impl<T: ToStr> ToStr for Ratio<T> {\n     /// Renders as `numer/denom`.\n     fn to_str(&self) -> ~str {\n-        fmt!(\"%s/%s\", self.numer.to_str(), self.denom.to_str())\n+        format!(\"{}/{}\", self.numer.to_str(), self.denom.to_str())\n     }\n }\n impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     /// Renders as `numer/denom` where the numbers are in base `radix`.\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        fmt!(\"%s/%s\", self.numer.to_str_radix(radix), self.denom.to_str_radix(radix))\n+        format!(\"{}/{}\", self.numer.to_str_radix(radix), self.denom.to_str_radix(radix))\n     }\n }\n "}, {"sha": "5738faeca956b8d61beb99ba64b503cf0fc336d3", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -127,7 +127,7 @@ impl<T> RingBuf<T> {\n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         let idx = self.raw_index(i);\n         match self.elts[idx] {\n-            None => fail!(),\n+            None => fail2!(),\n             Some(ref v) => v\n         }\n     }\n@@ -138,7 +138,7 @@ impl<T> RingBuf<T> {\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n         let idx = self.raw_index(i);\n         match self.elts[idx] {\n-            None => fail!(),\n+            None => fail2!(),\n             Some(ref mut v) => v\n         }\n     }\n@@ -373,21 +373,21 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_back(137);\n         assert_eq!(d.len(), 4u);\n-        debug!(d.front());\n+        debug2!(\"{:?}\", d.front());\n         assert_eq!(*d.front().unwrap(), 42);\n-        debug!(d.back());\n+        debug2!(\"{:?}\", d.back());\n         assert_eq!(*d.back().unwrap(), 137);\n         let mut i = d.pop_front();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(42));\n         i = d.pop_back();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n         d.push_back(3);\n@@ -398,10 +398,10 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n-        debug!(d.get(0));\n-        debug!(d.get(1));\n-        debug!(d.get(2));\n-        debug!(d.get(3));\n+        debug2!(\"{:?}\", d.get(0));\n+        debug2!(\"{:?}\", d.get(1));\n+        debug2!(\"{:?}\", d.get(2));\n+        debug2!(\"{:?}\", d.get(3));\n         assert_eq!(*d.get(0), 1);\n         assert_eq!(*d.get(1), 2);\n         assert_eq!(*d.get(2), 3);"}, {"sha": "fff10533af18535d3099e46d48d5fd61c03acfe4", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -86,16 +86,16 @@ pub struct Version {\n impl ToStr for Version {\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n+        let s = format!(\"{}.{}.{}\", self.major, self.minor, self.patch);\n         let s = if self.pre.is_empty() {\n             s\n         } else {\n-            fmt!(\"%s-%s\", s, self.pre.map(|i| i.to_str()).connect(\".\"))\n+            format!(\"{}-{}\", s, self.pre.map(|i| i.to_str()).connect(\".\"))\n         };\n         if self.build.is_empty() {\n             s\n         } else {\n-            fmt!(\"%s+%s\", s, self.build.map(|i| i.to_str()).connect(\".\"))\n+            format!(\"{}+{}\", s, self.build.map(|i| i.to_str()).connect(\".\"))\n         }\n     }\n }\n@@ -158,7 +158,7 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     if buf.is_empty() {\n         bad_parse::cond.raise(())\n     }\n-    debug!(\"extracted nonempty prefix: %s\", buf);\n+    debug2!(\"extracted nonempty prefix: {}\", buf);\n     (buf, ch)\n }\n \n@@ -234,7 +234,7 @@ pub fn parse(s: &str) -> Option<Version> {\n     }\n     let s = s.trim();\n     let mut bad = false;\n-    do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n+    do bad_parse::cond.trap(|_| { debug2!(\"bad\"); bad = true }).inside {\n         do io::with_str_reader(s) |rdr| {\n             let v = parse_reader(rdr);\n             if bad || v.to_str() != s.to_owned() {"}, {"sha": "2108415f468ffaf5c37c62f8ae41f692f42996dd", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -265,7 +265,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => fail2!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "5293a2c3fd7ce3396b9ac00c225dba9996cc532b", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -564,7 +564,7 @@ impl<T:Clone + Ord> MergeState<T> {\n             shift_vec(array, dest, c2, len2);\n             swap(&mut array[dest+len2], &mut tmp[c1]);\n         } else if len1 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n+            fail2!(\"Comparison violates its contract!\");\n         } else {\n             assert_eq!(len2, 0);\n             assert!(len1 > 1);\n@@ -683,7 +683,7 @@ impl<T:Clone + Ord> MergeState<T> {\n             shift_vec(array, dest+1, c1+1, len1);\n             swap(&mut array[dest], &mut tmp[c2]);\n         } else if len2 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n+            fail2!(\"Comparison violates its contract!\");\n         } else {\n             assert_eq!(len1, 0);\n             assert!(len2 != 0);\n@@ -790,7 +790,7 @@ mod test_qsort {\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n         while i < len {\n-            // debug!(v2[i]);\n+            // debug2!(v2[i]);\n             assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n@@ -833,7 +833,7 @@ mod test_qsort {\n         let immut_names = names;\n \n         for (&a, &b) in expected.iter().zip(immut_names.iter()) {\n-            debug!(\"%d %d\", a, b);\n+            debug2!(\"{} {}\", a, b);\n             assert_eq!(a, b);\n         }\n     }\n@@ -851,7 +851,7 @@ mod tests {\n         let v3 = merge_sort::<int>(v1, f);\n         let mut i = 0u;\n         while i < len {\n-            debug!(v3[i]);\n+            debug2!(\"{:?}\", v3[i]);\n             assert_eq!(v3[i], v2[i]);\n             i += 1;\n         }\n@@ -922,7 +922,7 @@ mod test_tim_sort {\n         fn lt(&self, other: &CVal) -> bool {\n             let mut rng = rand::rng();\n             if rng.gen::<float>() > 0.995 {\n-                fail!(\"It's happening!!!\");\n+                fail2!(\"It's happening!!!\");\n             }\n             (*self).val < other.val\n         }\n@@ -936,7 +936,7 @@ mod test_tim_sort {\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n-            // debug!(v2[i]);\n+            // debug2!(v2[i]);\n             assert_eq!(v2[i], v1[i]);\n             i += 1u;\n         }\n@@ -977,7 +977,7 @@ mod test_tim_sort {\n         };\n \n         tim_sort(arr);\n-        fail!(\"Guarantee the fail\");\n+        fail2!(\"Guarantee the fail\");\n     }\n \n     #[deriving(Clone)]\n@@ -1045,7 +1045,7 @@ mod big_tests {\n         fn isSorted<T:Ord>(arr: &[T]) {\n             for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n+                    fail2!(\"Array not sorted\");\n                 }\n             }\n         }\n@@ -1116,7 +1116,7 @@ mod big_tests {\n         fn isSorted<T:Ord>(arr: &[@T]) {\n             for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n+                    fail2!(\"Array not sorted\");\n                 }\n             }\n         }"}, {"sha": "64c4a4a03fd56ecf5d69ac61f00f4033fdfc9e74", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -267,12 +267,12 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n     let (q1,q2,q3) = s.quartiles;\n-    w.write_str(fmt!(\"(min=%f, q1=%f, med=%f, q3=%f, max=%f)\",\n-                     s.min as float,\n-                     q1 as float,\n-                     q2 as float,\n-                     q3 as float,\n-                     s.max as float));\n+    w.write_str(format!(\"(min={}, q1={}, med={}, q3={}, max={})\",\n+                     s.min,\n+                     q1,\n+                     q2,\n+                     q3,\n+                     s.max));\n }\n \n /// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the"}, {"sha": "75060166f8c0a302b9108b8a27e2aa25d3ee2220", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -307,9 +307,9 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n                         blk: &fn() -> U) -> U {\n     match out_of_bounds {\n         Some(0) =>\n-            fail!(\"%s with illegal ID %u - this lock has no condvars!\", act, id),\n+            fail2!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n         Some(length) =>\n-            fail!(\"%s with illegal ID %u - ID must be less than %u\", act, id, length),\n+            fail2!(\"{} with illegal ID {} - ID must be less than {}\", act, id, length),\n         None => blk()\n     }\n }\n@@ -634,7 +634,7 @@ impl RWLock {\n     pub fn downgrade<'a>(&self, token: RWLockWriteMode<'a>)\n                          -> RWLockReadMode<'a> {\n         if !borrow::ref_eq(self, token.lock) {\n-            fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n+            fail2!(\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n         unsafe {\n             do task::unkillable {\n@@ -918,7 +918,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try {\n             do m2.lock {\n-                fail!();\n+                fail2!();\n             }\n         };\n         assert!(result.is_err());\n@@ -938,7 +938,7 @@ mod tests {\n             do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n-                fail!();\n+                fail2!();\n             }\n             do m2.lock_cond |cond| {\n                 c.send(()); // tell sibling go ahead\n@@ -976,9 +976,9 @@ mod tests {\n                         do (|| {\n                             cond.wait(); // block forever\n                         }).finally {\n-                            error!(\"task unwinding and sending\");\n+                            error2!(\"task unwinding and sending\");\n                             c.send(());\n-                            error!(\"task unwinding and done sending\");\n+                            error2!(\"task unwinding and done sending\");\n                         }\n                     }\n                 }\n@@ -988,7 +988,7 @@ mod tests {\n             }\n             do m2.lock { }\n             c.send(sibling_convos); // let parent wait on all children\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n@@ -1028,7 +1028,7 @@ mod tests {\n             let _ = p.recv();\n             do m.lock_cond |cond| {\n                 if !cond.signal_on(0) {\n-                    fail!(); // success; punt sibling awake.\n+                    fail2!(); // success; punt sibling awake.\n                 }\n             }\n         };\n@@ -1272,7 +1272,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try || {\n             do lock_rwlock_in_mode(&x2, mode1) {\n-                fail!();\n+                fail2!();\n             }\n         };\n         assert!(result.is_err());\n@@ -1319,7 +1319,7 @@ mod tests {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(xopt.take_unwrap());\n-                error!(\"oops, y.downgrade(x) should have failed!\");\n+                error2!(\"oops, y.downgrade(x) should have failed!\");\n             }\n         }\n     }"}, {"sha": "c7f2650790243ef4393642f1f7c5fa7293eb4c68", "filename": "src/libextra/term.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -147,7 +147,7 @@ impl Terminal {\n                 self.out.write(s.unwrap());\n                 return true\n             } else {\n-                warn!(\"%s\", s.unwrap_err());\n+                warn2!(\"{}\", s.unwrap_err());\n             }\n         }\n         false\n@@ -167,7 +167,7 @@ impl Terminal {\n                 self.out.write(s.unwrap());\n                 return true\n             } else {\n-                warn!(\"%s\", s.unwrap_err());\n+                warn2!(\"{}\", s.unwrap_err());\n             }\n         }\n         false\n@@ -188,7 +188,7 @@ impl Terminal {\n                         self.out.write(s.unwrap());\n                         return true\n                     } else {\n-                        warn!(\"%s\", s.unwrap_err());\n+                        warn2!(\"{}\", s.unwrap_err());\n                     }\n                 }\n                 false\n@@ -226,11 +226,11 @@ impl Terminal {\n         if s.is_ok() {\n             self.out.write(s.unwrap());\n         } else if self.num_colors > 0 {\n-            warn!(\"%s\", s.unwrap_err());\n+            warn2!(\"{}\", s.unwrap_err());\n         } else {\n-            // if we support attributes but not color, it would be nice to still warn!()\n+            // if we support attributes but not color, it would be nice to still warn2!()\n             // but it's not worth testing all known attributes just for this.\n-            debug!(\"%s\", s.unwrap_err());\n+            debug2!(\"{}\", s.unwrap_err());\n         }\n     }\n "}, {"sha": "81c4b35d8d0d99a2b4e6fd83e93cded10b4a8e84", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -278,7 +278,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n-                    _ => return Err(fmt!(\"unrecognized format option %c\", cur))\n+                    _ => return Err(format!(\"unrecognized format option {}\", cur))\n                 }\n             },\n             PushParam => {\n@@ -461,7 +461,7 @@ impl FormatOp {\n             'x' => FormatHex,\n             'X' => FormatHEX,\n             's' => FormatString,\n-            _ => fail!(\"bad FormatOp char\")\n+            _ => fail2!(\"bad FormatOp char\")\n         }\n     }\n     fn to_char(self) -> char {\n@@ -551,7 +551,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                     s\n                 }\n                 _ => {\n-                    return Err(fmt!(\"non-string on stack with %%%c\", op.to_char()))\n+                    return Err(format!(\"non-string on stack with %{}\", op.to_char()))\n                 }\n             }\n         }\n@@ -606,23 +606,23 @@ mod test {\n         for cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n-                    \"Op %s succeeded incorrectly with 0 stack entries\", *cap);\n+                    \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" { String(~\"foo\") } else { Number(97) };\n             let res = expand((bytes!(\"%p1\")).to_owned() + cap.as_bytes(), [p], vars);\n             assert!(res.is_ok(),\n-                    \"Op %s failed with 1 stack entry: %s\", *cap, res.unwrap_err());\n+                    \"Op {} failed with 1 stack entry: {}\", *cap, res.unwrap_err());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n         for cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n-                    \"Binop %s succeeded incorrectly with 0 stack entries\", *cap);\n+                    \"Binop {} succeeded incorrectly with 0 stack entries\", *cap);\n             let res = expand((bytes!(\"%{1}\")).to_owned() + cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n-                    \"Binop %s succeeded incorrectly with 1 stack entry\", *cap);\n+                    \"Binop {} succeeded incorrectly with 1 stack entry\", *cap);\n             let res = expand((bytes!(\"%{1}%{2}\")).to_owned() + cap.as_bytes(), [], vars);\n             assert!(res.is_ok(),\n-                    \"Binop %s failed with 2 stack entries: %s\", *cap, res.unwrap_err());\n+                    \"Binop {} failed with 2 stack entries: {}\", *cap, res.unwrap_err());\n         }\n     }\n \n@@ -635,15 +635,15 @@ mod test {\n     fn test_comparison_ops() {\n         let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n         for &(op, bs) in v.iter() {\n-            let s = fmt!(\"%%{1}%%{2}%%%c%%d\", op);\n+            let s = format!(\"%\\\\{1\\\\}%\\\\{2\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), ~['0' as u8 + bs[0]]);\n-            let s = fmt!(\"%%{1}%%{1}%%%c%%d\", op);\n+            let s = format!(\"%\\\\{1\\\\}%\\\\{1\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), ~['0' as u8 + bs[1]]);\n-            let s = fmt!(\"%%{2}%%{1}%%%c%%d\", op);\n+            let s = format!(\"%\\\\{2\\\\}%\\\\{1\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), ~['0' as u8 + bs[2]]);"}, {"sha": "caef3e70ce80ab1528dee96eba5fce2537d64332", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -178,7 +178,8 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     // Check magic number\n     let magic = file.read_le_u16();\n     if (magic != 0x011A) {\n-        return Err(fmt!(\"invalid magic number: expected %x but found %x\", 0x011A, magic as uint));\n+        return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n+                           0x011A, magic as uint));\n     }\n \n     let names_bytes          = file.read_le_i16() as int;\n@@ -189,26 +190,26 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     assert!(names_bytes          > 0);\n \n-    debug!(\"names_bytes = %?\", names_bytes);\n-    debug!(\"bools_bytes = %?\", bools_bytes);\n-    debug!(\"numbers_count = %?\", numbers_count);\n-    debug!(\"string_offsets_count = %?\", string_offsets_count);\n-    debug!(\"string_table_bytes = %?\", string_table_bytes);\n+    debug2!(\"names_bytes = {}\", names_bytes);\n+    debug2!(\"bools_bytes = {}\", bools_bytes);\n+    debug2!(\"numbers_count = {}\", numbers_count);\n+    debug2!(\"string_offsets_count = {}\", string_offsets_count);\n+    debug2!(\"string_table_bytes = {}\", string_table_bytes);\n \n     if (bools_bytes as uint) > boolnames.len() {\n-        error!(\"expected bools_bytes to be less than %? but found %?\", boolnames.len(),\n+        error2!(\"expected bools_bytes to be less than {} but found {}\", boolnames.len(),\n                bools_bytes);\n         return Err(~\"incompatible file: more booleans than expected\");\n     }\n \n     if (numbers_count as uint) > numnames.len() {\n-        error!(\"expected numbers_count to be less than %? but found %?\", numnames.len(),\n+        error2!(\"expected numbers_count to be less than {} but found {}\", numnames.len(),\n                numbers_count);\n         return Err(~\"incompatible file: more numbers than expected\");\n     }\n \n     if (string_offsets_count as uint) > stringnames.len() {\n-        error!(\"expected string_offsets_count to be less than %? but found %?\", stringnames.len(),\n+        error2!(\"expected string_offsets_count to be less than {} but found {}\", stringnames.len(),\n                string_offsets_count);\n         return Err(~\"incompatible file: more string offsets than expected\");\n     }\n@@ -218,26 +219,26 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     file.read_byte(); // consume NUL\n \n-    debug!(\"term names: %?\", term_names);\n+    debug2!(\"term names: {:?}\", term_names);\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n             let b = file.read_byte();\n             if b < 0 {\n-                error!(\"EOF reading bools after %? entries\", i);\n+                error2!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n             } else if b == 1 {\n-                debug!(\"%s set\", bnames[i]);\n+                debug2!(\"{} set\", bnames[i]);\n                 bools_map.insert(bnames[i].to_owned(), true);\n             }\n         }\n     }\n \n-    debug!(\"bools: %?\", bools_map);\n+    debug2!(\"bools: {:?}\", bools_map);\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n-        debug!(\"adjusting for padding between bools and numbers\");\n+        debug2!(\"adjusting for padding between bools and numbers\");\n         file.read_byte(); // compensate for padding\n     }\n \n@@ -246,13 +247,13 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n         for i in range(0, numbers_count) {\n             let n = file.read_le_u16();\n             if n != 0xFFFF {\n-                debug!(\"%s#%?\", nnames[i], n);\n+                debug2!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n             }\n         }\n     }\n \n-    debug!(\"numbers: %?\", numbers_map);\n+    debug2!(\"numbers: {:?}\", numbers_map);\n \n     let mut string_map = HashMap::new();\n \n@@ -262,12 +263,12 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n             string_offsets.push(file.read_le_u16());\n         }\n \n-        debug!(\"offsets: %?\", string_offsets);\n+        debug2!(\"offsets: {:?}\", string_offsets);\n \n         let string_table = file.read_bytes(string_table_bytes as uint);\n \n         if string_table.len() != string_table_bytes as uint {\n-            error!(\"EOF reading string table after %? bytes, wanted %?\", string_table.len(),\n+            error2!(\"EOF reading string table after {} bytes, wanted {}\", string_table.len(),\n                    string_table_bytes);\n             return Err(~\"error: hit EOF before end of string table\");\n         }"}, {"sha": "5c7efdb298f271fdadd9ac31fd13e9bab7812965", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -60,7 +60,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n             return Some(newp);\n         }\n         // on some installations the dir is named after the hex of the char (e.g. OS X)\n-        let newp = ~p.push_many(&[fmt!(\"%x\", first_char as uint), term.to_owned()]);\n+        let newp = ~p.push_many(&[format!(\"{:x}\", first_char as uint), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);\n         }\n@@ -72,7 +72,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n pub fn open(term: &str) -> Result<@Reader, ~str> {\n     match get_dbpath_for_term(term) {\n         Some(x) => file_reader(x),\n-        None => Err(fmt!(\"could not find terminfo entry for %s\", term))\n+        None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }\n "}, {"sha": "16937e38695b789ad4b499907309d8975f160466", "filename": "src/libextra/test.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -125,10 +125,10 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            Some(Err(msg)) => fail!(msg),\n+            Some(Err(msg)) => fail2!(\"{}\", msg),\n             None => return\n         };\n-    if !run_tests_console(&opts, tests) { fail!(\"Some tests failed\"); }\n+    if !run_tests_console(&opts, tests) { fail2!(\"Some tests failed\"); }\n }\n \n // A variant optimized for invocation with a static test vector.\n@@ -148,7 +148,7 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n             TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n \n             _ => {\n-                fail!(\"non-static tests passed to test::test_main_static\");\n+                fail2!(\"non-static tests passed to test::test_main_static\");\n             }\n         }\n     };\n@@ -192,7 +192,7 @@ fn optgroups() -> ~[getopts::groups::OptGroup] {\n fn usage(binary: &str, helpstr: &str) {\n     #[fixed_stack_segment]; #[inline(never)];\n \n-    let message = fmt!(\"Usage: %s [OPTIONS] [FILTER]\", binary);\n+    let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n     println(groups::usage(message, optgroups()));\n     println(\"\");\n     if helpstr == \"help\" {\n@@ -210,7 +210,7 @@ Test Attributes:\n     #[bench]       - Indicates a function is a benchmark to be run. This\n                      function takes one argument (extra::test::BenchHarness).\n     #[should_fail] - This function (also labeled with #[test]) will only pass if\n-                     the code causes a failure (an assertion failure or fail!)\n+                     the code causes a failure (an assertion failure or fail2!)\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n@@ -327,7 +327,7 @@ impl ConsoleTestState {\n                                                      io::Truncate]) {\n                 result::Ok(w) => Some(w),\n                 result::Err(ref s) => {\n-                    fail!(\"can't open output file: %s\", *s)\n+                    fail2!(\"can't open output file: {}\", *s)\n                 }\n             },\n             None => None\n@@ -408,11 +408,11 @@ impl ConsoleTestState {\n     pub fn write_run_start(&mut self, len: uint) {\n         self.total = len;\n         let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n-        self.out.write_line(fmt!(\"\\nrunning %u %s\", len, noun));\n+        self.out.write_line(format!(\"\\nrunning {} {}\", len, noun));\n     }\n \n     pub fn write_test_start(&self, test: &TestDesc) {\n-        self.out.write_str(fmt!(\"test %s ... \", test.name.to_str()));\n+        self.out.write_str(format!(\"test {} ... \", test.name.to_str()));\n     }\n \n     pub fn write_result(&self, result: &TestResult) {\n@@ -436,7 +436,7 @@ impl ConsoleTestState {\n         match self.log_out {\n             None => (),\n             Some(out) => {\n-                out.write_line(fmt!(\"%s %s\",\n+                out.write_line(format!(\"{} {}\",\n                                     match *result {\n                                         TrOk => ~\"ok\",\n                                         TrFailed => ~\"failed\",\n@@ -456,7 +456,7 @@ impl ConsoleTestState {\n         }\n         sort::tim_sort(failures);\n         for name in failures.iter() {\n-            self.out.write_line(fmt!(\"    %s\", name.to_str()));\n+            self.out.write_line(format!(\"    {}\", name.to_str()));\n         }\n     }\n \n@@ -473,31 +473,31 @@ impl ConsoleTestState {\n                 MetricAdded => {\n                     added += 1;\n                     self.write_added();\n-                    self.out.write_line(fmt!(\": %s\", *k));\n+                    self.out.write_line(format!(\": {}\", *k));\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n                     self.write_removed();\n-                    self.out.write_line(fmt!(\": %s\", *k));\n+                    self.out.write_line(format!(\": {}\", *k));\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n                     self.out.write_str(*k);\n                     self.out.write_str(\": \");\n                     self.write_improved();\n-                    self.out.write_line(fmt!(\" by %.2f%%\", pct as float))\n+                    self.out.write_line(format!(\" by {:.2f}%\", pct as float))\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n                     self.out.write_str(*k);\n                     self.out.write_str(\": \");\n                     self.write_regressed();\n-                    self.out.write_line(fmt!(\" by %.2f%%\", pct as float))\n+                    self.out.write_line(format!(\" by {:.2f}%\", pct as float))\n                 }\n             }\n         }\n-        self.out.write_line(fmt!(\"result of ratchet: %u matrics added, %u removed, \\\n-                                  %u improved, %u regressed, %u noise\",\n+        self.out.write_line(format!(\"result of ratchet: {} matrics added, {} removed, \\\n+                                  {} improved, {} regressed, {} noise\",\n                                  added, removed, improved, regressed, noise));\n         if regressed == 0 {\n             self.out.write_line(\"updated ratchet file\")\n@@ -514,11 +514,11 @@ impl ConsoleTestState {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                self.out.write_str(fmt!(\"\\nusing metrics ratchet: %s\\n\", pth.to_str()));\n+                self.out.write_str(format!(\"\\nusing metrics ratchet: {}\\n\", pth.to_str()));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                    self.out.write_str(fmt!(\"with noise-tolerance forced to: %f%%\\n\",\n+                    self.out.write_str(format!(\"with noise-tolerance forced to: {}%%\\n\",\n                                             pct as float))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n@@ -541,15 +541,15 @@ impl ConsoleTestState {\n         } else {\n             self.write_failed();\n         }\n-        self.out.write_str(fmt!(\". %u passed; %u failed; %u ignored; %u measured\\n\\n\",\n+        self.out.write_str(format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                                 self.passed, self.failed, self.ignored, self.measured));\n         return success;\n     }\n }\n \n pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n     let v : ~[~str] = mm.iter()\n-        .map(|(k,v)| fmt!(\"%s: %f (+/- %f)\",\n+        .map(|(k,v)| format!(\"{}: {} (+/- {})\",\n                           *k,\n                           v.value as float,\n                           v.noise as float))\n@@ -559,12 +559,12 @@ pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n \n pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n     if bs.mb_s != 0 {\n-        fmt!(\"%u ns/iter (+/- %u) = %u MB/s\",\n+        format!(\"{} ns/iter (+/- {}) = {} MB/s\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n              bs.mb_s)\n     } else {\n-        fmt!(\"%u ns/iter (+/- %u)\",\n+        format!(\"{} ns/iter (+/- {})\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n     }\n@@ -574,7 +574,7 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n     fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n-        debug!(\"callback(event=%?)\", event);\n+        debug2!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test) => st.write_test_start(test),\n@@ -612,7 +612,7 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => (),\n         Some(ref pth) => {\n             st.metrics.save(pth);\n-            st.out.write_str(fmt!(\"\\nmetrics saved to: %s\", pth.to_str()));\n+            st.out.write_str(format!(\"\\nmetrics saved to: {}\", pth.to_str()));\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n@@ -688,7 +688,7 @@ fn run_tests(opts: &TestOpts,\n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n-    debug!(\"using %u test tasks\", concurrency);\n+    debug2!(\"using {} test tasks\", concurrency);\n \n     let mut remaining = filtered_tests;\n     remaining.reverse();\n@@ -735,7 +735,7 @@ fn get_concurrency() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(s);\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => fail!(\"RUST_TEST_TASKS is `%s`, should be a positive integer.\", s)\n+                _ => fail2!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)\n             }\n         }\n         None => {\n@@ -1001,7 +1001,7 @@ impl MetricMap {\n         };\n \n         if ok {\n-            debug!(\"rewriting file '%s' with updated metrics\");\n+            debug2!(\"rewriting file '{:?}' with updated metrics\", p);\n             self.save(p);\n         }\n         return (diff, ok)\n@@ -1040,7 +1040,7 @@ impl BenchHarness {\n \n     pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n         self.iterations = n;\n-        debug!(\"running benchmark for %u iterations\",\n+        debug2!(\"running benchmark for {} iterations\",\n                n as uint);\n         f(self);\n     }\n@@ -1081,7 +1081,7 @@ impl BenchHarness {\n             stats::winsorize(samples, 5.0);\n             let summ5 = stats::Summary::new(samples);\n \n-            debug!(\"%u samples, median %f, MAD=%f, MADP=%f\",\n+            debug2!(\"{} samples, median {}, MAD={}, MADP={}\",\n                    samples.len(),\n                    summ.median as float,\n                    summ.median_abs_dev as float,\n@@ -1153,7 +1153,7 @@ mod tests {\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n-        fn f() { fail!(); }\n+        fn f() { fail2!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1189,7 +1189,7 @@ mod tests {\n \n     #[test]\n     fn test_should_fail() {\n-        fn f() { fail!(); }\n+        fn f() { fail2!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1228,7 +1228,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n+            _ => fail2!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(\"filter\" == opts.filter.clone().unwrap());\n     }\n@@ -1238,7 +1238,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            _ => fail!(\"Malformed arg in parse_ignored_flag\")\n+            _ => fail2!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));\n     }"}, {"sha": "7f08fcd908aea958bcd16d8f40631117d6502970", "filename": "src/libextra/time.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -259,7 +259,7 @@ impl Tm {\n             let mut m = num::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            s + fmt!(\"%c%02d:%02d\", sign, h as int, m as int)\n+            s + format!(\"{}{:02d}:{:02d}\", sign, h as int, m as int)\n         }\n     }\n }\n@@ -364,7 +364,7 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         if c == range.ch {\n             Ok(range.next)\n         } else {\n-            Err(fmt!(\"Expected %?, found %?\",\n+            Err(format!(\"Expected {}, found {}\",\n                 str::from_char(c),\n                 str::from_char(range.ch)))\n         }\n@@ -671,7 +671,7 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           '%' => parse_char(s, pos, '%'),\n           ch => {\n-            Err(fmt!(\"unknown formatting type: %?\", str::from_char(ch)))\n+            Err(format!(\"unknown formatting type: {}\", str::from_char(ch)))\n           }\n         }\n     }\n@@ -736,7 +736,7 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n-      let die = || fmt!(\"strftime: can't understand this format %c \", ch);\n+      let die = || format!(\"strftime: can't understand this format {} \", ch);\n         match ch {\n           'A' => match tm.tm_wday as int {\n             0 => ~\"Sunday\",\n@@ -788,68 +788,68 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n             11 => ~\"Dec\",\n             _  => die()\n           },\n-          'C' => fmt!(\"%02d\", (tm.tm_year as int + 1900) / 100),\n+          'C' => format!(\"{:02d}\", (tm.tm_year as int + 1900) / 100),\n           'c' => {\n-            fmt!(\"%s %s %s %s %s\",\n+            format!(\"{} {} {} {} {}\",\n                 parse_type('a', tm),\n                 parse_type('b', tm),\n                 parse_type('e', tm),\n                 parse_type('T', tm),\n                 parse_type('Y', tm))\n           }\n           'D' | 'x' => {\n-            fmt!(\"%s/%s/%s\",\n+            format!(\"{}/{}/{}\",\n                 parse_type('m', tm),\n                 parse_type('d', tm),\n                 parse_type('y', tm))\n           }\n-          'd' => fmt!(\"%02d\", tm.tm_mday as int),\n-          'e' => fmt!(\"%2d\", tm.tm_mday as int),\n-          'f' => fmt!(\"%09d\", tm.tm_nsec as int),\n+          'd' => format!(\"{:02d}\", tm.tm_mday),\n+          'e' => format!(\"{:2d}\", tm.tm_mday),\n+          'f' => format!(\"{:09d}\", tm.tm_nsec),\n           'F' => {\n-            fmt!(\"%s-%s-%s\",\n+            format!(\"{}-{}-{}\",\n                 parse_type('Y', tm),\n                 parse_type('m', tm),\n                 parse_type('d', tm))\n           }\n           //'G' {}\n           //'g' {}\n-          'H' => fmt!(\"%02d\", tm.tm_hour as int),\n+          'H' => format!(\"{:02d}\", tm.tm_hour),\n           'I' => {\n-            let mut h = tm.tm_hour as int;\n+            let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            fmt!(\"%02d\", h)\n+            format!(\"{:02d}\", h)\n           }\n-          'j' => fmt!(\"%03d\", tm.tm_yday as int + 1),\n-          'k' => fmt!(\"%2d\", tm.tm_hour as int),\n+          'j' => format!(\"{:03d}\", tm.tm_yday + 1),\n+          'k' => format!(\"{:2d}\", tm.tm_hour),\n           'l' => {\n-            let mut h = tm.tm_hour as int;\n+            let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            fmt!(\"%2d\", h)\n+            format!(\"{:2d}\", h)\n           }\n-          'M' => fmt!(\"%02d\", tm.tm_min as int),\n-          'm' => fmt!(\"%02d\", tm.tm_mon as int + 1),\n+          'M' => format!(\"{:02d}\", tm.tm_min),\n+          'm' => format!(\"{:02d}\", tm.tm_mon + 1),\n           'n' => ~\"\\n\",\n           'P' => if (tm.tm_hour as int) < 12 { ~\"am\" } else { ~\"pm\" },\n           'p' => if (tm.tm_hour as int) < 12 { ~\"AM\" } else { ~\"PM\" },\n           'R' => {\n-            fmt!(\"%s:%s\",\n+            format!(\"{}:{}\",\n                 parse_type('H', tm),\n                 parse_type('M', tm))\n           }\n           'r' => {\n-            fmt!(\"%s:%s:%s %s\",\n+            format!(\"{}:{}:{} {}\",\n                 parse_type('I', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm),\n                 parse_type('p', tm))\n           }\n-          'S' => fmt!(\"%02d\", tm.tm_sec as int),\n-          's' => fmt!(\"%d\", tm.to_timespec().sec as int),\n+          'S' => format!(\"{:02d}\", tm.tm_sec),\n+          's' => format!(\"{}\", tm.to_timespec().sec),\n           'T' | 'X' => {\n-            fmt!(\"%s:%s:%s\",\n+            format!(\"{}:{}:{}\",\n                 parse_type('H', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm))\n@@ -862,7 +862,7 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           }\n           //'V' {}\n           'v' => {\n-            fmt!(\"%s-%s-%s\",\n+            format!(\"{}-{}-{}\",\n                 parse_type('e', tm),\n                 parse_type('b', tm),\n                 parse_type('Y', tm))\n@@ -872,14 +872,14 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           //'X' {}\n           //'x' {}\n           'Y' => (tm.tm_year as int + 1900).to_str(),\n-          'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n+          'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n           'Z' => tm.tm_zone.clone(),\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            fmt!(\"%c%02d%02d\", sign, h as int, m as int)\n+            format!(\"{}{:02d}{:02d}\", sign, h, m)\n           }\n           //'+' {}\n           '%' => ~\"%\",\n@@ -914,13 +914,13 @@ mod tests {\n         static SOME_FUTURE_DATE: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n-        debug!(\"tv1=%? sec + %? nsec\", tv1.sec as uint, tv1.nsec as uint);\n+        debug2!(\"tv1={:?} sec + {:?} nsec\", tv1.sec as uint, tv1.nsec as uint);\n \n         assert!(tv1.sec > SOME_RECENT_DATE);\n         assert!(tv1.nsec < 1000000000i32);\n \n         let tv2 = get_time();\n-        debug!(\"tv2=%? sec + %? nsec\", tv2.sec as uint, tv2.nsec as uint);\n+        debug2!(\"tv2={:?} sec + {:?} nsec\", tv2.sec as uint, tv2.nsec as uint);\n \n         assert!(tv2.sec >= tv1.sec);\n         assert!(tv2.sec < SOME_FUTURE_DATE);\n@@ -934,16 +934,16 @@ mod tests {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n-        debug!(\"s0=%s sec\", float::to_str_digits(s0, 9u));\n+        debug2!(\"s0={} sec\", float::to_str_digits(s0, 9u));\n         assert!(s0 > 0.);\n         let ns0 = (s0 * 1000000000.) as u64;\n-        debug!(\"ns0=%? ns\", ns0);\n+        debug2!(\"ns0={:?} ns\", ns0);\n \n-        debug!(\"ns1=%? ns\", ns0);\n+        debug2!(\"ns1={:?} ns\", ns0);\n         assert!(ns1 >= ns0);\n \n         let ns2 = precise_time_ns();\n-        debug!(\"ns2=%? ns\", ns0);\n+        debug2!(\"ns2={:?} ns\", ns0);\n         assert!(ns2 >= ns1);\n     }\n \n@@ -975,7 +975,7 @@ mod tests {\n         let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n-        error!(\"time_at: %?\", local);\n+        error2!(\"time_at: {:?}\", local);\n \n         assert!(local.tm_sec == 30_i32);\n         assert!(local.tm_min == 31_i32);\n@@ -1050,7 +1050,7 @@ mod tests {\n             == Err(~\"Invalid time\"));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n-          Err(e) => fail!(e),\n+          Err(e) => fail2!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n             assert!(tm.tm_min == 31_i32);\n@@ -1070,7 +1070,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format) == s.to_owned(),\n-              Err(e) => fail!(e)\n+              Err(e) => fail2!(e)\n             }\n         }\n \n@@ -1196,7 +1196,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        error!(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n+        error2!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n \n         assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n         assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");"}, {"sha": "ee7ba4a888b86a977b6462c4983a178c2cffdafc", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -831,7 +831,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n       }\n     }\n     return match node.take() {\n-        Some(~TreeNode{value, _}) => Some(value), None => fail!()\n+        Some(~TreeNode{value, _}) => Some(value), None => fail2!()\n     };\n }\n \n@@ -900,7 +900,7 @@ mod test_treemap {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-          None => fail!(), Some(x) => *x = new\n+          None => fail2!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "7a10c0439daf4975dec8402d7413a6b256b1485d", "filename": "src/libextra/url.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -93,10 +93,10 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                         out.push_char(ch);\n                       }\n \n-                      _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n+                      _ => out.push_str(format!(\"%{:X}\", ch as uint))\n                     }\n                 } else {\n-                    out.push_str(fmt!(\"%%%X\", ch as uint));\n+                    out.push_str(format!(\"%{:X}\", ch as uint));\n                 }\n               }\n             }\n@@ -192,7 +192,7 @@ fn encode_plus(s: &str) -> ~str {\n                 out.push_char(ch);\n               }\n               ' ' => out.push_char('+'),\n-              _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n+              _ => out.push_str(format!(\"%{:X}\", ch as uint))\n             }\n         }\n \n@@ -218,7 +218,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n                 first = false;\n             }\n \n-            out.push_str(fmt!(\"%s=%s\", key, encode_plus(*value)));\n+            out.push_str(format!(\"{}={}\", key, encode_plus(*value)));\n         }\n     }\n \n@@ -324,8 +324,8 @@ fn userinfo_from_str(uinfo: &str) -> UserInfo {\n \n fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n     match userinfo.pass {\n-        Some(ref pass) => fmt!(\"%s:%s@\", userinfo.user, *pass),\n-        None => fmt!(\"%s@\", userinfo.user),\n+        Some(ref pass) => format!(\"{}:{}@\", userinfo.user, *pass),\n+        None => format!(\"{}@\", userinfo.user),\n     }\n }\n \n@@ -345,7 +345,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n     for kv in query.iter() {\n         match kv {\n             &(ref k, ref v) => {\n-                strvec.push(fmt!(\"%s=%s\",\n+                strvec.push(format!(\"{}={}\",\n                     encode_component(*k),\n                     encode_component(*v))\n                 );\n@@ -673,21 +673,21 @@ pub fn to_str(url: &Url) -> ~str {\n     let authority = if url.host.is_empty() {\n         ~\"\"\n     } else {\n-        fmt!(\"//%s%s\", user, url.host)\n+        format!(\"//{}{}\", user, url.host)\n     };\n \n     let query = if url.query.is_empty() {\n         ~\"\"\n     } else {\n-        fmt!(\"?%s\", query_to_str(&url.query))\n+        format!(\"?{}\", query_to_str(&url.query))\n     };\n \n     let fragment = match url.fragment {\n-        Some(ref fragment) => fmt!(\"#%s\", encode_component(*fragment)),\n+        Some(ref fragment) => format!(\"\\\\#{}\", encode_component(*fragment)),\n         None => ~\"\",\n     };\n \n-    fmt!(\"%s:%s%s%s%s\", url.scheme, authority, url.path, query, fragment)\n+    format!(\"{}:{}{}{}{}\", url.scheme, authority, url.path, query, fragment)\n }\n \n impl ToStr for Url {"}, {"sha": "6da97d8628a8779805627861b096cd06e0831074", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -129,17 +129,17 @@ impl ToStr for ParseError {\n     fn to_str(&self) -> ~str {\n         match *self {\n             ErrorInvalidLength(found) =>\n-                fmt!(\"Invalid length; expecting 32, 36 or 45 chars, found %u\",\n-                    found),\n+                format!(\"Invalid length; expecting 32, 36 or 45 chars, found {}\",\n+                        found),\n             ErrorInvalidCharacter(found, pos) =>\n-                fmt!(\"Invalid character; found `%c` (0x%02x) at offset %u\",\n-                    found, found as uint, pos),\n+                format!(\"Invalid character; found `{}` (0x{:02x}) at offset {}\",\n+                        found, found as uint, pos),\n             ErrorInvalidGroups(found) =>\n-                fmt!(\"Malformed; wrong number of groups: expected 1 or 5, found %u\",\n-                    found),\n+                format!(\"Malformed; wrong number of groups: expected 1 or 5, found {}\",\n+                        found),\n             ErrorInvalidGroupLength(group, found, expecting) =>\n-                fmt!(\"Malformed; length of group %u was %u, expecting %u\",\n-                    group, found, expecting),\n+                format!(\"Malformed; length of group {} was {}, expecting {}\",\n+                        group, found, expecting),\n         }\n     }\n }\n@@ -303,7 +303,7 @@ impl Uuid {\n     pub fn to_simple_str(&self) -> ~str {\n         let mut s: ~[u8] = vec::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n-            let digit = fmt!(\"%02x\", self.bytes[i] as uint);\n+            let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n             s[i*2+0] = digit[0];\n             s[i*2+1] = digit[1];\n         }\n@@ -324,12 +324,13 @@ impl Uuid {\n         uf.data1 = to_be32(uf.data1 as i32) as u32;\n         uf.data2 = to_be16(uf.data2 as i16) as u16;\n         uf.data3 = to_be16(uf.data3 as i16) as u16;\n-        let s = fmt!(\"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n-            uf.data1 as uint,\n-            uf.data2 as uint, uf.data3 as uint,\n-            uf.data4[0] as uint, uf.data4[1] as uint,\n-            uf.data4[2] as uint, uf.data4[3] as uint, uf.data4[4] as uint,\n-            uf.data4[5] as uint, uf.data4[6] as uint, uf.data4[7] as uint);\n+        let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n+                         {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n+            uf.data1,\n+            uf.data2, uf.data3,\n+            uf.data4[0], uf.data4[1],\n+            uf.data4[2], uf.data4[3], uf.data4[4],\n+            uf.data4[5], uf.data4[6], uf.data4[7]);\n         s\n     }\n "}, {"sha": "32a2d83d814e1869115ddb08ef4f21ea1fdc9444", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -183,11 +183,11 @@ impl Database {\n         assert!(os::path_exists(&self.db_filename));\n         let f = io::file_reader(&self.db_filename);\n         match f {\n-            Err(e) => fail!(\"Couldn't load workcache database %s: %s\",\n+            Err(e) => fail2!(\"Couldn't load workcache database {}: {}\",\n                             self.db_filename.to_str(), e.to_str()),\n             Ok(r) =>\n                 match json::from_reader(r) {\n-                    Err(e) => fail!(\"Couldn't parse workcache database (from file %s): %s\",\n+                    Err(e) => fail2!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.to_str(), e.to_str()),\n                     Ok(r) => {\n                         let mut decoder = json::Decoder(r);\n@@ -264,7 +264,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n \n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n-    debug!(\"json decoding: %s\", s);\n+    debug2!(\"json decoding: {}\", s);\n     do io::with_str_reader(s) |rdr| {\n         let j = json::from_reader(rdr).unwrap();\n         let mut decoder = json::Decoder(j);\n@@ -321,15 +321,15 @@ impl Exec {\n                           dependency_kind: &str,\n                           dependency_name: &str,\n                           dependency_val: &str) {\n-        debug!(\"Discovering input %s %s %s\", dependency_kind, dependency_name, dependency_val);\n+        debug2!(\"Discovering input {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_inputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n                                  dependency_val.to_owned());\n     }\n     pub fn discover_output(&mut self,\n                            dependency_kind: &str,\n                            dependency_name: &str,\n                            dependency_val: &str) {\n-        debug!(\"Discovering output %s %s %s\", dependency_kind, dependency_name, dependency_val);\n+        debug2!(\"Discovering output {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_outputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n                                  dependency_val.to_owned());\n     }\n@@ -368,7 +368,7 @@ impl<'self> Prep<'self> {\n \n impl<'self> Prep<'self> {\n     pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n-        debug!(\"Declaring input %s %s %s\", kind, name, val);\n+        debug2!(\"Declaring input {} {} {}\", kind, name, val);\n         self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n                                  val.to_owned());\n     }\n@@ -377,17 +377,17 @@ impl<'self> Prep<'self> {\n                 name: &str, val: &str) -> bool {\n         let k = kind.to_owned();\n         let f = self.ctxt.freshness.get().find(&k);\n-        debug!(\"freshness for: %s/%s/%s/%s\", cat, kind, name, val)\n+        debug2!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n-            None => fail!(\"missing freshness-function for '%s'\", kind),\n+            None => fail2!(\"missing freshness-function for '{}'\", kind),\n             Some(f) => (*f)(name, val)\n         };\n         do self.ctxt.logger.write |lg| {\n             if fresh {\n-                lg.info(fmt!(\"%s %s:%s is fresh\",\n+                lg.info(format!(\"{} {}:{} is fresh\",\n                              cat, kind, name));\n             } else {\n-                lg.info(fmt!(\"%s %s:%s is not fresh\",\n+                lg.info(format!(\"{} {}:{} is not fresh\",\n                              cat, kind, name))\n             }\n         };\n@@ -418,7 +418,7 @@ impl<'self> Prep<'self> {\n             &'self self, blk: ~fn(&mut Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n \n-        debug!(\"exec_work: looking up %s and %?\", self.fn_name,\n+        debug2!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n                self.declared_inputs);\n         let cached = do self.ctxt.db.read |db| {\n             db.prepare(self.fn_name, &self.declared_inputs)\n@@ -429,14 +429,14 @@ impl<'self> Prep<'self> {\n             if self.all_fresh(\"declared input\",&self.declared_inputs) &&\n                self.all_fresh(\"discovered input\", disc_in) &&\n                self.all_fresh(\"discovered output\", disc_out) => {\n-                debug!(\"Cache hit!\");\n-                debug!(\"Trying to decode: %? / %? / %?\",\n+                debug2!(\"Cache hit!\");\n+                debug2!(\"Trying to decode: {:?} / {:?} / {}\",\n                        disc_in, disc_out, *res);\n                 Work::from_value(json_decode(*res))\n             }\n \n             _ => {\n-                debug!(\"Cache miss!\");\n+                debug2!(\"Cache miss!\");\n                 let (port, chan) = oneshot();\n                 let blk = bo.take_unwrap();\n                 let chan = Cell::new(chan);"}, {"sha": "ca2e1cbde7b8188a19176a524b7b7ca58c08e13b", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -131,13 +131,13 @@ pub mod jit {\n             for cratepath in r.iter() {\n                 let path = cratepath.to_str();\n \n-                debug!(\"linking: %s\", path);\n+                debug2!(\"linking: {}\", path);\n \n                 do path.with_c_str |buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n-                    debug!(\"linked: %s\", path);\n+                    debug2!(\"linked: {}\", path);\n                 }\n             }\n \n@@ -305,7 +305,7 @@ pub mod write {\n             for pass in sess.opts.custom_passes.iter() {\n                 do pass.with_c_str |s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n-                        sess.warn(fmt!(\"Unknown pass %s, ignoring\", *pass));\n+                        sess.warn(format!(\"Unknown pass {}, ignoring\", *pass));\n                     }\n                 }\n             }\n@@ -383,9 +383,9 @@ pub mod write {\n         let prog = run::process_output(cc_prog, cc_args);\n \n         if prog.status != 0 {\n-            sess.err(fmt!(\"building with `%s` failed with code %d\",\n+            sess.err(format!(\"building with `{}` failed with code {}\",\n                         cc_prog, prog.status));\n-            sess.note(fmt!(\"%s arguments: %s\",\n+            sess.note(format!(\"{} arguments: {}\",\n                         cc_prog, cc_args.connect(\" \")));\n             sess.note(str::from_utf8(prog.error + prog.output));\n             sess.abort_if_errors();\n@@ -556,7 +556,7 @@ pub fn build_link_meta(sess: Session,\n                               dep_hashes: ~[@str],\n                               pkg_id: Option<@str>) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n-            fmt!(\"%u_%s\", s.len(), s)\n+            format!(\"{}_{}\", s.len(), s)\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> ~str {\n@@ -601,7 +601,7 @@ pub fn build_link_meta(sess: Session,\n \n     fn warn_missing(sess: Session, name: &str, default: &str) {\n         if !*sess.building_library { return; }\n-        sess.warn(fmt!(\"missing crate link meta `%s`, using `%s` as default\",\n+        sess.warn(format!(\"missing crate link meta `{}`, using `{}` as default\",\n                        name, default));\n     }\n \n@@ -614,7 +614,7 @@ pub fn build_link_meta(sess: Session,\n                 // filestem that returned an @str\n                 let name = session::expect(sess,\n                                            output.filestem(),\n-                                           || fmt!(\"output file name `%s` doesn't\\\n+                                           || format!(\"output file name `{}` doesn't\\\n                                                     appear to have a stem\",\n                                                    output.to_str())).to_managed();\n                 if name.is_empty() {\n@@ -764,7 +764,7 @@ pub fn mangle(sess: Session, ss: path,\n \n     let push = |s: &str| {\n         let sani = sanitize(s);\n-        n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+        n.push_str(format!(\"{}{}\", sani.len(), sani));\n     };\n \n     // First, connect each component with <len, name> pairs.\n@@ -876,7 +876,7 @@ pub fn output_dll_filename(os: session::Os, lm: LinkMeta) -> ~str {\n         session::OsAndroid => (android::DLL_PREFIX, android::DLL_SUFFIX),\n         session::OsFreebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n-    fmt!(\"%s%s-%s-%s%s\", dll_prefix, lm.name, lm.extras_hash, lm.vers, dll_suffix)\n+    format!(\"{}{}-{}-{}{}\", dll_prefix, lm.name, lm.extras_hash, lm.vers, dll_suffix)\n }\n \n pub fn get_cc_prog(sess: Session) -> ~str {\n@@ -892,7 +892,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n             session::OsAndroid =>\n                 match &sess.opts.android_cross_path {\n                     &Some(ref path) => {\n-                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n+                        format!(\"{}/bin/arm-linux-androideabi-gcc\", *path)\n                     }\n                     &None => {\n                         sess.fatal(\"need Android NDK path for linking \\\n@@ -917,29 +917,29 @@ pub fn link_binary(sess: Session,\n \n     let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n-        debug!(\"link_meta.name:  %s\", lm.name);\n-        debug!(\"long_libname: %s\", long_libname);\n-        debug!(\"out_filename: %s\", out_filename.to_str());\n-        debug!(\"dirname(out_filename): %s\", out_filename.dir_path().to_str());\n+        debug2!(\"link_meta.name:  {}\", lm.name);\n+        debug2!(\"long_libname: {}\", long_libname);\n+        debug2!(\"out_filename: {}\", out_filename.to_str());\n+        debug2!(\"dirname(out_filename): {}\", out_filename.dir_path().to_str());\n \n         out_filename.dir_path().push(long_libname)\n     } else {\n         out_filename.clone()\n     };\n \n-    debug!(\"output: %s\", output.to_str());\n+    debug2!(\"output: {}\", output.to_str());\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n-    debug!(\"%s link args: %s\", cc_prog, cc_args.connect(\" \"));\n+    debug2!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n-        io::println(fmt!(\"%s link args: %s\", cc_prog, cc_args.connect(\" \")));\n+        io::println(format!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \")));\n     }\n \n     // We run 'cc' here\n     let prog = run::process_output(cc_prog, cc_args);\n     if 0 != prog.status {\n-        sess.err(fmt!(\"linking with `%s` failed with code %d\",\n+        sess.err(format!(\"linking with `{}` failed with code {}\",\n                       cc_prog, prog.status));\n-        sess.note(fmt!(\"%s arguments: %s\",\n+        sess.note(format!(\"{} arguments: {}\",\n                        cc_prog, cc_args.connect(\" \")));\n         sess.note(str::from_utf8(prog.error + prog.output));\n         sess.abort_if_errors();\n@@ -953,7 +953,7 @@ pub fn link_binary(sess: Session,\n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n         if ! os::remove_file(obj_filename) {\n-            sess.warn(fmt!(\"failed to delete object file `%s`\",\n+            sess.warn(format!(\"failed to delete object file `{}`\",\n                            obj_filename.to_str()));\n         }\n     }"}, {"sha": "60289e0ebe5a190d649a17ecd908996a14db4e22", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -29,7 +29,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n         return ~[];\n     }\n \n-    debug!(\"preparing the RPATH!\");\n+    debug2!(\"preparing the RPATH!\");\n \n     let sysroot = sess.filesearch.sysroot();\n     let output = out_filename;\n@@ -49,21 +49,21 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n }\n \n pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n-    rpaths.iter().map(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n+    rpaths.iter().map(|rpath| format!(\"-Wl,-rpath,{}\",rpath.to_str())).collect()\n }\n \n fn get_rpaths(os: session::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n               target_triple: &str) -> ~[Path] {\n-    debug!(\"sysroot: %s\", sysroot.to_str());\n-    debug!(\"output: %s\", output.to_str());\n-    debug!(\"libs:\");\n+    debug2!(\"sysroot: {}\", sysroot.to_str());\n+    debug2!(\"output: {}\", output.to_str());\n+    debug2!(\"libs:\");\n     for libpath in libs.iter() {\n-        debug!(\"    %s\", libpath.to_str());\n+        debug2!(\"    {}\", libpath.to_str());\n     }\n-    debug!(\"target_triple: %s\", target_triple);\n+    debug2!(\"target_triple: {}\", target_triple);\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n@@ -78,9 +78,9 @@ fn get_rpaths(os: session::Os,\n     let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n \n     fn log_rpaths(desc: &str, rpaths: &[Path]) {\n-        debug!(\"%s rpaths:\", desc);\n+        debug2!(\"{} rpaths:\", desc);\n         for rpath in rpaths.iter() {\n-            debug!(\"    %s\", rpath.to_str());\n+            debug2!(\"    {}\", rpath.to_str());\n         }\n     }\n \n@@ -172,7 +172,7 @@ mod test {\n         let res = get_install_prefix_rpath(\"triple\");\n         let d = Path(env!(\"CFG_PREFIX\"))\n             .push_rel(&Path(\"lib/rustc/triple/lib\"));\n-        debug!(\"test_prefix_path: %s vs. %s\",\n+        debug2!(\"test_prefix_path: {} vs. {}\",\n                res.to_str(),\n                d.to_str());\n         assert!(res.to_str().ends_with(d.to_str()));\n@@ -233,7 +233,7 @@ mod test {\n     #[test]\n     fn test_get_absolute_rpath() {\n         let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n-        debug!(\"test_get_absolute_rpath: %s vs. %s\",\n+        debug2!(\"test_get_absolute_rpath: {} vs. {}\",\n                res.to_str(),\n                os::make_absolute(&Path(\"lib\")).to_str());\n "}, {"sha": "76f48577fe672641eff18e9db06953e9bbe6cab1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -386,33 +386,33 @@ pub fn phase_6_link_output(sess: Session,\n \n pub fn stop_after_phase_3(sess: Session) -> bool {\n    if sess.opts.no_trans {\n-        debug!(\"invoked with --no-trans, returning early from compile_input\");\n+        debug2!(\"invoked with --no-trans, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n pub fn stop_after_phase_1(sess: Session) -> bool {\n     if sess.opts.parse_only {\n-        debug!(\"invoked with --parse-only, returning early from compile_input\");\n+        debug2!(\"invoked with --parse-only, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n pub fn stop_after_phase_5(sess: Session) -> bool {\n     if sess.opts.output_type != link::output_type_exe {\n-        debug!(\"not building executable, returning early from compile_input\");\n+        debug2!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n \n     if sess.opts.is_static && *sess.building_library {\n-        debug!(\"building static library, returning early from compile_input\");\n+        debug2!(\"building static library, returning early from compile_input\");\n         return true;\n     }\n \n     if sess.opts.jit {\n-        debug!(\"running JIT, returning early from compile_input\");\n+        debug2!(\"running JIT, returning early from compile_input\");\n         return true;\n     }\n     return false;\n@@ -670,7 +670,7 @@ pub fn build_session_options(binary: @str,\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n-                early_error(demitter, fmt!(\"unknown %s flag: %s\",\n+                early_error(demitter, format!(\"unknown {} flag: {}\",\n                                            level_name, lint_name));\n               }\n               Some(lint) => {\n@@ -690,7 +690,7 @@ pub fn build_session_options(binary: @str,\n             if name == debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0u {\n-            early_error(demitter, fmt!(\"unknown debug flag: %s\", *debug_flag))\n+            early_error(demitter, format!(\"unknown debug flag: {}\", *debug_flag))\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -1033,7 +1033,7 @@ pub fn build_output_filenames(input: &input,\n \n pub fn early_error(emitter: @diagnostic::Emitter, msg: ~str) -> ! {\n     emitter.emit(None, msg, diagnostic::fatal);\n-    fail!();\n+    fail2!();\n }\n \n pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n@@ -1058,7 +1058,7 @@ mod test {\n         let matches =\n             &match getopts([~\"--test\"], optgroups()) {\n               Ok(m) => m,\n-              Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", f.to_err_msg())\n+              Err(f) => fail2!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n         let sessopts = build_session_options(\n             @\"rustc\",\n@@ -1079,7 +1079,8 @@ mod test {\n             &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(m) => m,\n               Err(f) => {\n-                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", f.to_err_msg());\n+                fail2!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\",\n+                       f.to_err_msg());\n               }\n             };\n         let sessopts = build_session_options("}, {"sha": "892715c62cea12e2b3f40761f98378b057200571", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -298,7 +298,7 @@ impl Session_ {\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n+        self.span_bug(sp, format!(\"Impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(verbose) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(time_passes) }"}, {"sha": "e4904863a94bc195a66b4d28e5e84e9abeeb1663", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -78,7 +78,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n     fn fold_item(&self, i: @ast::item) -> Option<@ast::item> {\n         self.cx.path.push(i.ident);\n-        debug!(\"current path: %s\",\n+        debug2!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.clone()));\n \n         if is_test_fn(self.cx, i) || is_bench_fn(i) {\n@@ -91,7 +91,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                                      tests\");\n                 }\n                 _ => {\n-                    debug!(\"this is a test function\");\n+                    debug2!(\"this is a test function\");\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.clone(),\n@@ -100,7 +100,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                         should_fail: should_fail(i)\n                     };\n                     self.cx.testfns.push(test);\n-                    // debug!(\"have %u test/bench functions\",\n+                    // debug2!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n             }\n@@ -327,7 +327,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n         span: dummy_sp(),\n      };\n \n-    debug!(\"Synthetic test module:\\n%s\\n\",\n+    debug2!(\"Synthetic test module:\\n{}\\n\",\n            pprust::item_to_str(@item.clone(), cx.sess.intr()));\n \n     return @item;\n@@ -381,7 +381,7 @@ fn is_extra(crate: &ast::Crate) -> bool {\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n-    debug!(\"building test vector from %u tests\", cx.testfns.len());\n+    debug2!(\"building test vector from {} tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for test in cx.testfns.iter() {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n@@ -404,7 +404,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();\n \n-    debug!(\"encoding %s\", ast_util::path_name_i(path));\n+    debug2!(\"encoding {}\", ast_util::path_name_i(path));\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));"}, {"sha": "b3c2f595039c90878da961f4c6c262d5786059cd", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -2271,33 +2271,33 @@ impl TypeNames {\n                 Metadata => ~\"Metadata\",\n                 X86_MMX => ~\"X86_MMAX\",\n                 Integer => {\n-                    fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty.to_ref()) as int)\n+                    format!(\"i{}\", llvm::LLVMGetIntTypeWidth(ty.to_ref()) as int)\n                 }\n                 Function => {\n                     let out_ty = ty.return_type();\n                     let args = ty.func_params();\n                     let args =\n                         args.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n                     let out_ty = self.type_to_str_depth(out_ty, depth-1);\n-                    fmt!(\"fn(%s) -> %s\", args, out_ty)\n+                    format!(\"fn({}) -> {}\", args, out_ty)\n                 }\n                 Struct => {\n                     let tys = ty.field_types();\n                     let tys = tys.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n-                    fmt!(\"{%s}\", tys)\n+                    format!(\"\\\\{{}\\\\}\", tys)\n                 }\n                 Array => {\n                     let el_ty = ty.element_type();\n                     let el_ty = self.type_to_str_depth(el_ty, depth-1);\n                     let len = ty.array_length();\n-                    fmt!(\"[%s x %u]\", el_ty, len)\n+                    format!(\"[{} x {}]\", el_ty, len)\n                 }\n                 Pointer => {\n                     let el_ty = ty.element_type();\n                     let el_ty = self.type_to_str_depth(el_ty, depth-1);\n-                    fmt!(\"*%s\", el_ty)\n+                    format!(\"*{}\", el_ty)\n                 }\n-                _ => fail!(\"Unknown Type Kind (%u)\", kind as uint)\n+                _ => fail2!(\"Unknown Type Kind ({})\", kind as uint)\n             }\n         }\n     }\n@@ -2308,7 +2308,7 @@ impl TypeNames {\n \n     pub fn types_to_str(&self, tys: &[Type]) -> ~str {\n         let strs = tys.map(|t| self.type_to_str(*t));\n-        fmt!(\"[%s]\", strs.connect(\",\"))\n+        format!(\"[{}]\", strs.connect(\",\"))\n     }\n \n     pub fn val_to_str(&self, val: ValueRef) -> ~str {"}, {"sha": "c41e1d78f6486b3a22dc79fb92ba2e9e5c9faaf8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -74,11 +74,11 @@ struct cache_entry {\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n-    debug!(\"resolved crates:\");\n+    debug2!(\"resolved crates:\");\n     for entry in crate_cache.iter() {\n-        debug!(\"cnum: %?\", entry.cnum);\n-        debug!(\"span: %?\", entry.span);\n-        debug!(\"hash: %?\", entry.hash);\n+        debug2!(\"cnum: {:?}\", entry.cnum);\n+        debug2!(\"span: {:?}\", entry.span);\n+        debug2!(\"hash: {:?}\", entry.hash);\n     }\n }\n \n@@ -97,7 +97,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!(\"using multiple versions of crate `%s`\", name));\n+                format!(\"using multiple versions of crate `{}`\", name));\n             for match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n@@ -154,7 +154,7 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n                   }\n             }\n           };\n-          debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n+          debug2!(\"resolving extern mod stmt. ident: {:?}, meta: {:?}\",\n                  ident, meta_items);\n           let cnum = resolve_crate(e,\n                                    ident,\n@@ -317,7 +317,7 @@ fn resolve_crate(e: @mut Env,\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n-    debug!(\"resolving deps of external crate\");\n+    debug2!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let mut cnum_map = HashMap::new();\n@@ -326,18 +326,18 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n         let extrn_cnum = dep.cnum;\n         let cname_str = token::ident_to_str(&dep.name);\n         let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n-        debug!(\"resolving dep crate %s ver: %s hash: %s\",\n+        debug2!(\"resolving dep crate {} ver: {} hash: {}\",\n                cname_str, dep.vers, dep.hash);\n         match existing_match(e,\n                              metas_with_ident(cname_str, cmetas.clone()),\n                              dep.hash) {\n           Some(local_cnum) => {\n-            debug!(\"already have it\");\n+            debug2!(\"already have it\");\n             // We've already seen this crate\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n           None => {\n-            debug!(\"need to load it\");\n+            debug2!(\"need to load it\");\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span."}, {"sha": "6def597b89fb3bc2bff41043a566b2e36f50454c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -210,17 +210,17 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n-    debug!(\"Looking up %?\", class_id);\n+    debug2!(\"Looking up {:?}\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n-                           || fmt!(\"get_field_type: class ID %? not found\",\n+                           || format!(\"get_field_type: class ID {:?} not found\",\n                                    class_id) );\n-    debug!(\"looking up %? : %?\", def, class_doc);\n+    debug2!(\"looking up {:?} : {:?}\", def, class_doc);\n     let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n-        || fmt!(\"get_field_type: in class %?, field ID %? not found\",\n+        || format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                  class_id, def) );\n-    debug!(\"got field data %?\", the_field);\n+    debug2!(\"got field data {:?}\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: @~[],"}, {"sha": "03af7c98b877490dde7bb13a7f96dccec530d8a8", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -152,7 +152,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);\n-        debug!(\"Add hash[%s]: %s %s\", cdata.name, vers, hash);\n+        debug2!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n         result.push(crate_hash {\n             name: cdata.name,\n             vers: vers,\n@@ -164,9 +164,9 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n     };\n \n-    debug!(\"sorted:\");\n+    debug2!(\"sorted:\");\n     for x in sorted.iter() {\n-        debug!(\"  hash[%s]: %s\", x.name, x.hash);\n+        debug2!(\"  hash[{}]: {}\", x.name, x.hash);\n     }\n \n     sorted.map(|ch| ch.hash)"}, {"sha": "5c6a7c4f3b7c752f94d3f0524e373e3d46412059", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -89,7 +89,7 @@ pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n \n fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n     match maybe_find_item(item_id, items) {\n-       None => fail!(\"lookup_item: id not found: %d\", item_id),\n+       None => fail2!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n     }\n }\n@@ -148,7 +148,7 @@ fn item_family(item: ebml::Doc) -> Family {\n       'g' => PublicField,\n       'j' => PrivateField,\n       'N' => InheritedField,\n-       c => fail!(\"unexpected family char: %c\", c)\n+       c => fail2!(\"unexpected family char: {}\", c)\n     }\n }\n \n@@ -160,7 +160,7 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n                 'y' => ast::public,\n                 'n' => ast::private,\n                 'i' => ast::inherited,\n-                _ => fail!(\"unknown visibility character\")\n+                _ => fail2!(\"unknown visibility character\")\n             }\n         }\n     }\n@@ -494,8 +494,8 @@ pub enum DefLike {\n pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n     match def_like {\n         DlDef(def) => return def,\n-        DlImpl(*) => fail!(\"found impl in def_like_to_def\"),\n-        DlField => fail!(\"found field in def_like_to_def\")\n+        DlImpl(*) => fail2!(\"found impl in def_like_to_def\"),\n+        DlField => fail2!(\"found field in def_like_to_def\")\n     }\n }\n \n@@ -550,14 +550,14 @@ impl<'self> EachItemContext<'self> {\n         let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n         match def_like {\n             DlDef(def) => {\n-                debug!(\"(iterating over each item of a module) processing \\\n-                        `%s` (def %?)\",\n+                debug2!(\"(iterating over each item of a module) processing \\\n+                        `{}` (def {:?})\",\n                        *self.path_builder,\n                        def);\n             }\n             _ => {\n-                debug!(\"(iterating over each item of a module) processing \\\n-                        `%s` (%d:%d)\",\n+                debug2!(\"(iterating over each item of a module) processing \\\n+                        `{}` ({}:{})\",\n                        *self.path_builder,\n                        def_id.crate,\n                        def_id.node);\n@@ -631,8 +631,8 @@ impl<'self> EachItemContext<'self> {\n                 reader::get_doc(root, tag_items)\n             };\n \n-            debug!(\"(iterating over each item of a module) looking up item \\\n-                    %d:%d in `%s`, crate %d\",\n+            debug2!(\"(iterating over each item of a module) looking up item \\\n+                    {}:{} in `{}`, crate {}\",\n                    child_def_id.crate,\n                    child_def_id.node,\n                    *self.path_builder,\n@@ -644,8 +644,8 @@ impl<'self> EachItemContext<'self> {\n                 Some(child_item_doc) => {\n                     // Push the name.\n                     let child_name = item_name(self.intr, child_item_doc);\n-                    debug!(\"(iterating over each item of a module) pushing \\\n-                            name `%s` onto `%s`\",\n+                    debug2!(\"(iterating over each item of a module) pushing \\\n+                            name `{}` onto `{}`\",\n                            token::ident_to_str(&child_name),\n                            *self.path_builder);\n                     let old_len =\n@@ -682,9 +682,9 @@ impl<'self> EachItemContext<'self> {\n             let name = name_doc.as_str_slice();\n \n             // Push the name.\n-            debug!(\"(iterating over each item of a module) pushing \\\n-                    reexported name `%s` onto `%s` (crate %d, orig %d, \\\n-                    in crate %d)\",\n+            debug2!(\"(iterating over each item of a module) pushing \\\n+                    reexported name `{}` onto `{}` (crate {}, orig {}, \\\n+                    in crate {})\",\n                    name,\n                    *self.path_builder,\n                    def_id.crate,\n@@ -899,7 +899,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n                           id: ast::NodeId,\n                           decode_inlined_item: decode_inlined_item)\n                        -> csearch::found_ast {\n-    debug!(\"Looking up item: %d\", id);\n+    debug2!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data);\n     let path = {\n         let item_path = item_path(item_doc);\n@@ -964,7 +964,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n         match ch as char {\n             'i' => ast::MutImmutable,\n             'm' => ast::MutMutable,\n-            _ => fail!(\"unknown mutability character: `%c`\", ch as char),\n+            _ => fail2!(\"unknown mutability character: `{}`\", ch as char),\n         }\n     }\n \n@@ -982,7 +982,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n             return ast::sty_region(None, get_mutability(string[1]));\n         }\n         _ => {\n-            fail!(\"unknown self type code: `%c`\", explicit_self_kind as char);\n+            fail2!(\"unknown self type code: `{}`\", explicit_self_kind as char);\n         }\n     }\n }\n@@ -1163,7 +1163,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n                 match item_family(impl_method_doc) {\n                     StaticMethod => purity = ast::impure_fn,\n                     UnsafeStaticMethod => purity = ast::unsafe_fn,\n-                    _ => fail!()\n+                    _ => fail2!()\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n@@ -1199,7 +1199,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n       PublicField => ast::public,\n       PrivateField => ast::private,\n       InheritedField => ast::inherited,\n-      _ => fail!()\n+      _ => fail2!()\n     }\n }\n \n@@ -1265,7 +1265,7 @@ fn describe_def(items: ebml::Doc, id: ast::DefId) -> ~str {\n     if id.crate != ast::LOCAL_CRATE { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n-        None => fail!(\"describe_def: item not found %?\", id)\n+        None => fail2!(\"describe_def: item not found {:?}\", id)\n     };\n     return item_family_to_str(item_family(it));\n }\n@@ -1355,17 +1355,17 @@ fn list_meta_items(intr: @ident_interner,\n                    out: @io::Writer) {\n     let r = get_meta_items(meta_items);\n     for mi in r.iter() {\n-        out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n+        out.write_str(format!(\"{}\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n \n fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n                          out: @io::Writer) {\n-    out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n+    out.write_str(format!(\"=Crate Attributes ({})=\\n\", hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n+        out.write_str(format!(\"{}\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n     out.write_str(\"\\n\\n\");\n@@ -1409,7 +1409,7 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n         out.write_str(\n-            fmt!(\"%d %s-%s-%s\\n\",\n+            format!(\"{} {}-{}-{}\\n\",\n                  dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));\n     }\n \n@@ -1452,7 +1452,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n \n     match cdata.cnum_map.find(&did.crate) {\n       option::Some(&n) => ast::DefId { crate: n, node: did.node },\n-      option::None => fail!(\"didn't find a crate in the cnum_map\")\n+      option::None => fail2!(\"didn't find a crate in the cnum_map\")\n     }\n }\n "}, {"sha": "ff59376aa37f2622f9f4e9108978e2606a6617ab", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -185,7 +185,7 @@ fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n }\n \n pub fn def_to_str(did: DefId) -> ~str {\n-    fmt!(\"%d:%d\", did.crate, did.node)\n+    format!(\"{}:{}\", did.crate, did.node)\n }\n \n fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n@@ -284,12 +284,12 @@ fn encode_symbol(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n-            debug!(\"encode_symbol(id=%?, str=%s)\", id, *x);\n+            debug2!(\"encode_symbol(id={:?}, str={})\", id, *x);\n             ebml_w.writer.write(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                fmt!(\"encode_symbol: id not found %d\", id));\n+                format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n     ebml_w.end_tag();\n@@ -339,7 +339,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<i64>],\n                             generics: &ast::Generics) {\n-    debug!(\"encode_enum_variant_info(id=%?)\", id);\n+    debug2!(\"encode_enum_variant_info(id={:?})\", id);\n \n     let mut disr_val = 0;\n     let mut i = 0;\n@@ -425,14 +425,14 @@ fn encode_reexported_static_method(ecx: &EncodeContext,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n                                    method_ident: Ident) {\n-    debug!(\"(encode reexported static method) %s::%s\",\n+    debug2!(\"(encode reexported static method) {}::{}\",\n             exp.name, ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n     ebml_w.wr_str(def_to_str(method_def_id));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(fmt!(\"%s::%s\", exp.name, ecx.tcx.sess.str_of(method_ident)));\n+    ebml_w.wr_str(format!(\"{}::{}\", exp.name, ecx.tcx.sess.str_of(method_ident)));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -498,14 +498,14 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             if mod_path != *path || exp.name != original_name {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n-                        debug!(fmt!(\"(encode reexported static methods) %s \\\n-                                    [trait]\",\n-                                    original_name));\n+                        debug2!(\"(encode reexported static methods) {} \\\n+                                 [trait]\",\n+                                original_name);\n                     }\n                 }\n                 else {\n-                    debug!(fmt!(\"(encode reexported static methods) %s [base]\",\n-                                original_name));\n+                    debug2!(\"(encode reexported static methods) {} [base]\",\n+                            original_name);\n                 }\n             }\n         }\n@@ -552,13 +552,13 @@ fn encode_reexports(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     id: NodeId,\n                     path: &[ast_map::path_elt]) {\n-    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+    debug2!(\"(encoding info for module) encoding reexports for {}\", id);\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n-            debug!(\"(encoding info for module) found reexports for %d\", id);\n+            debug2!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n-                debug!(\"(encoding info for module) reexport '%s' (%d/%d) for \\\n-                        %d\",\n+                debug2!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n+                        {}\",\n                        exp.name,\n                        exp.def_id.crate,\n                        exp.def_id.node,\n@@ -575,7 +575,7 @@ fn encode_reexports(ecx: &EncodeContext,\n             }\n         }\n         None => {\n-            debug!(\"(encoding info for module) found no reexports for %d\",\n+            debug2!(\"(encoding info for module) found no reexports for {}\",\n                    id);\n         }\n     }\n@@ -592,7 +592,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ecx, ebml_w, name);\n-    debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n+    debug2!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in md.items.iter() {\n@@ -610,8 +610,8 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         match item.node {\n             item_impl(*) => {\n                 let (ident, did) = (item.ident, item.id);\n-                debug!(\"(encoding info for module) ... encoding impl %s \\\n-                        (%?/%?)\",\n+                debug2!(\"(encoding info for module) ... encoding impl {} \\\n+                        ({:?}/{:?})\",\n                         ecx.tcx.sess.str_of(ident),\n                         did,\n                         ast_map::node_id_to_str(ecx.tcx.items, did, token::get_ident_interner()));\n@@ -628,7 +628,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == public {\n-        debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+        debug2!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, ebml_w, id, path);\n     }\n \n@@ -730,7 +730,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         global_index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n-        debug!(\"encode_info_for_struct: doing %s %d\",\n+        debug2!(\"encode_info_for_struct: doing {} {}\",\n                tcx.sess.str_of(nm), id);\n         encode_struct_field_family(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n@@ -794,7 +794,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           parent_id: NodeId,\n                           ast_method_opt: Option<@method>) {\n \n-    debug!(\"encode_info_for_method: %? %s\", m.def_id,\n+    debug2!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            ecx.tcx.sess.str_of(m.ident));\n     ebml_w.start_tag(tag_items_data_item);\n \n@@ -834,7 +834,7 @@ fn purity_static_method_family(p: purity) -> char {\n     match p {\n       unsafe_fn => 'U',\n       impure_fn => 'F',\n-      _ => fail!(\"extern fn can't be static\")\n+      _ => fail2!(\"extern fn can't be static\")\n     }\n }\n \n@@ -893,7 +893,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n     let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n \n-    debug!(\"encoding info for item at %s\",\n+    debug2!(\"encoding info for item at {}\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n@@ -1220,7 +1220,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n-      item_mac(*) => fail!(\"item macros unimplemented\")\n+      item_mac(*) => fail2!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1279,15 +1279,15 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n             };\n             encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, vis);\n         }\n-        _ => fail!(\"bad item\")\n+        _ => fail2!(\"bad item\")\n     }\n }\n \n fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::Encoder,\n                          ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n     match items.get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n-            debug!(\"writing foreign item %s::%s\",\n+            debug2!(\"writing foreign item {}::{}\",\n                    ast_map::path_to_str(\n                        *pt,\n                        token::get_ident_interner()),\n@@ -1304,7 +1304,7 @@ fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::\n                                          abi);\n         }\n         // case for separate item and foreign-item tables\n-        _ => fail!(\"bad foreign item\")\n+        _ => fail2!(\"bad foreign item\")\n     }\n }\n "}, {"sha": "6761445b74e2212c2c26a993dfe283d1e6cb8a5c", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -53,7 +53,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             let mut visited_dirs = HashSet::new();\n             let mut found = false;\n \n-            debug!(\"filesearch: searching additional lib search paths [%?]\",\n+            debug2!(\"filesearch: searching additional lib search paths [{:?}]\",\n                    self.addl_lib_search_paths.len());\n             for path in self.addl_lib_search_paths.iter() {\n                 match f(path) {\n@@ -63,7 +63,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                 visited_dirs.insert(path.to_str());\n             }\n \n-            debug!(\"filesearch: searching target lib path\");\n+            debug2!(\"filesearch: searching target lib path\");\n             let tlib_path = make_target_lib_path(self.sysroot,\n                                         self.target_triple);\n             if !visited_dirs.contains(&tlib_path.to_str()) {\n@@ -78,7 +78,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                 let rustpath = rust_path();\n                 for path in rustpath.iter() {\n                     let tlib_path = make_rustpkg_target_lib_path(path, self.target_triple);\n-                    debug!(\"is %s in visited_dirs? %?\", tlib_path.to_str(),\n+                    debug2!(\"is {} in visited_dirs? {:?}\", tlib_path.to_str(),\n                             visited_dirs.contains(&tlib_path.to_str()));\n \n                     if !visited_dirs.contains(&tlib_path.to_str()) {\n@@ -104,7 +104,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n-    debug!(\"using sysroot = %s\", sysroot.to_str());\n+    debug2!(\"using sysroot = {}\", sysroot.to_str());\n     @FileSearchImpl {\n         sysroot: sysroot,\n         addl_lib_search_paths: addl_lib_search_paths,\n@@ -114,19 +114,19 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n \n pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n-        debug!(\"searching %s\", lib_search_path.to_str());\n+        debug2!(\"searching {}\", lib_search_path.to_str());\n         let r = os::list_dir_path(lib_search_path);\n         let mut rslt = FileDoesntMatch;\n         for path in r.iter() {\n-            debug!(\"testing %s\", path.to_str());\n+            debug2!(\"testing {}\", path.to_str());\n             let maybe_picked = pick(path);\n             match maybe_picked {\n                 FileMatches => {\n-                    debug!(\"picked %s\", path.to_str());\n+                    debug2!(\"picked {}\", path.to_str());\n                     rslt = FileMatches;\n                 }\n                 FileDoesntMatch => {\n-                    debug!(\"rejected %s\", path.to_str());\n+                    debug2!(\"rejected {}\", path.to_str());\n                 }\n             }\n         }\n@@ -153,7 +153,7 @@ fn make_rustpkg_target_lib_path(dir: &Path,\n pub fn get_or_default_sysroot() -> Path {\n     match os::self_exe_path() {\n       option::Some(ref p) => (*p).pop(),\n-      option::None => fail!(\"can't determine value for sysroot\")\n+      option::None => fail2!(\"can't determine value for sysroot\")\n     }\n }\n "}, {"sha": "4d69a2ffce85d88ad91d028c7269a21afb56e7b5", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -59,7 +59,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       Some(t) => t,\n       None => {\n         cx.diag.span_fatal(cx.span,\n-                           fmt!(\"can't find crate for `%s`\",\n+                           format!(\"can't find crate for `{}`\",\n                                 cx.ident));\n       }\n     }\n@@ -90,28 +90,28 @@ fn find_library_crate_aux(\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-    let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n+    let prefix = format!(\"{}{}-\", prefix, crate_name);\n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| -> FileMatch {\n       let path_str = path.filename();\n       match path_str {\n           None => FileDoesntMatch,\n           Some(path_str) =>\n               if path_str.starts_with(prefix) && path_str.ends_with(suffix) {\n-                  debug!(\"%s is a candidate\", path.to_str());\n+                  debug2!(\"{} is a candidate\", path.to_str());\n                   match get_metadata_section(cx.os, path) {\n                       Some(cvec) =>\n                           if !crate_matches(cvec, cx.metas, cx.hash) {\n-                              debug!(\"skipping %s, metadata doesn't match\",\n+                              debug2!(\"skipping {}, metadata doesn't match\",\n                                   path.to_str());\n                               FileDoesntMatch\n                           } else {\n-                              debug!(\"found %s with matching metadata\", path.to_str());\n+                              debug2!(\"found {} with matching metadata\", path.to_str());\n                               matches.push((path.to_str(), cvec));\n                               FileMatches\n                           },\n                       _ => {\n-                          debug!(\"could not load metadata for %s\", path.to_str());\n+                          debug2!(\"could not load metadata for {}\", path.to_str());\n                           FileDoesntMatch\n                       }\n                   }\n@@ -127,12 +127,12 @@ fn find_library_crate_aux(\n         1 => Some(matches[0]),\n         _ => {\n             cx.diag.span_err(\n-                    cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n+                    cx.span, format!(\"multiple matching crates for `{}`\", crate_name));\n                 cx.diag.handler().note(\"candidates:\");\n                 for pair in matches.iter() {\n                     let ident = pair.first();\n                     let data = pair.second();\n-                    cx.diag.handler().note(fmt!(\"path: %s\", ident));\n+                    cx.diag.handler().note(format!(\"path: {}\", ident));\n                     let attrs = decoder::get_crate_attributes(data);\n                     note_linkage_attrs(cx.intr, cx.diag, attrs);\n                 }\n@@ -149,7 +149,7 @@ pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n             _ => {}\n         }\n     }\n-    fail!(\"expected to find the crate name\")\n+    fail2!(\"expected to find the crate name\")\n }\n \n pub fn package_id_from_metas(metas: &[@ast::MetaItem]) -> Option<@str> {\n@@ -167,7 +167,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n                           attrs: ~[ast::Attribute]) {\n     let r = attr::find_linkage_metas(attrs);\n     for mi in r.iter() {\n-        diag.handler().note(fmt!(\"meta: %s\", pprust::meta_item_to_str(*mi,intr)));\n+        diag.handler().note(format!(\"meta: {}\", pprust::meta_item_to_str(*mi,intr)));\n     }\n }\n \n@@ -188,7 +188,7 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n \n // extern_metas: metas we read from the crate\n // local_metas: metas we're looking for\n-    debug!(\"matching %u metadata requirements against %u items\",\n+    debug2!(\"matching {} metadata requirements against {} items\",\n            local_metas.len(), extern_metas.len());\n \n     do local_metas.iter().all |needed| {\n@@ -211,14 +211,14 @@ fn get_metadata_section(os: Os,\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = str::raw::from_c_str(name_buf);\n-            debug!(\"get_metadata_section: name %s\", name);\n+            debug2!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found = None;\n                 let cvbuf: *u8 = cast::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n-                debug!(\"checking %u bytes of metadata-version stamp\",\n+                debug2!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = num::min(vlen, csz);\n                 let mut version_ok = false;\n@@ -229,7 +229,7 @@ fn get_metadata_section(os: Os,\n                 if !version_ok { return None; }\n \n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n-                debug!(\"inflating %u bytes of compressed metadata\",\n+                debug2!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n@@ -273,7 +273,7 @@ pub fn list_file_metadata(intr: @ident_interner,\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n-        out.write_str(fmt!(\"could not find metadata in %s.\\n\", path.to_str()))\n+        out.write_str(format!(\"could not find metadata in {}.\\n\", path.to_str()))\n       }\n     }\n }"}, {"sha": "b44051ef56058424ef31d9faaa9eb437ff93cce9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -80,10 +80,10 @@ fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n            op: &fn(&[u8]) -> R) -> R\n {\n     let start_pos = st.pos;\n-    debug!(\"scan: '%c' (start)\", st.data[st.pos] as char);\n+    debug2!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n     while !is_last(st.data[st.pos] as char) {\n         st.pos += 1;\n-        debug!(\"scan: '%c'\", st.data[st.pos] as char);\n+        debug2!(\"scan: '{}'\", st.data[st.pos] as char);\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n@@ -161,7 +161,7 @@ fn parse_sigil(st: &mut PState) -> ast::Sigil {\n         '@' => ast::ManagedSigil,\n         '~' => ast::OwnedSigil,\n         '&' => ast::BorrowedSigil,\n-        c => st.tcx.sess.bug(fmt!(\"parse_sigil(): bad input '%c'\", c))\n+        c => st.tcx.sess.bug(format!(\"parse_sigil(): bad input '{}'\", c))\n     }\n }\n \n@@ -179,7 +179,7 @@ fn parse_vstore(st: &mut PState) -> ty::vstore {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n       '&' => ty::vstore_slice(parse_region(st)),\n-      c => st.tcx.sess.bug(fmt!(\"parse_vstore(): bad input '%c'\", c))\n+      c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n     }\n }\n \n@@ -188,7 +188,7 @@ fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n         '&' => ty::RegionTraitStore(parse_region(st)),\n-        c => st.tcx.sess.bug(fmt!(\"parse_trait_store(): bad input '%c'\", c))\n+        c => st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\", c))\n     }\n }\n \n@@ -221,7 +221,7 @@ fn parse_region_substs(st: &mut PState) -> ty::RegionSubsts {\n             assert_eq!(next(st), '.');\n             ty::NonerasedRegions(regions)\n         }\n-        _ => fail!(\"parse_bound_region: bad input\")\n+        _ => fail2!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -239,7 +239,7 @@ fn parse_bound_region(st: &mut PState) -> ty::bound_region {\n         assert_eq!(next(st), '|');\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n-      _ => fail!(\"parse_bound_region: bad input\")\n+      _ => fail2!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -268,15 +268,15 @@ fn parse_region(st: &mut PState) -> ty::Region {\n       'e' => {\n         ty::re_static\n       }\n-      _ => fail!(\"parse_region: bad input\")\n+      _ => fail2!(\"parse_region: bad input\")\n     }\n }\n \n fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),\n-      _ => fail!(\"parse_opt: bad input\")\n+      _ => fail2!(\"parse_opt: bad input\")\n     }\n }\n \n@@ -317,7 +317,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           'D' => return ty::mk_mach_int(ast::ty_i64),\n           'f' => return ty::mk_mach_float(ast::ty_f32),\n           'F' => return ty::mk_mach_float(ast::ty_f64),\n-          _ => fail!(\"parse_ty: bad numeric type\")\n+          _ => fail2!(\"parse_ty: bad numeric type\")\n         }\n       }\n       'c' => return ty::mk_char(),\n@@ -340,7 +340,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, conv);\n-        debug!(\"parsed ty_param: did=%?\", did);\n+        debug2!(\"parsed ty_param: did={:?}\", did);\n         return ty::mk_param(st.tcx, parse_uint(st), did);\n       }\n       's' => {\n@@ -417,7 +417,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n-      c => { error!(\"unexpected char in type string: %c\", c); fail!();}\n+      c => { error2!(\"unexpected char in type string: {}\", c); fail2!();}\n     }\n }\n \n@@ -467,7 +467,7 @@ fn parse_purity(c: char) -> purity {\n       'u' => unsafe_fn,\n       'i' => impure_fn,\n       'c' => extern_fn,\n-      _ => fail!(\"parse_purity: bad purity %c\", c)\n+      _ => fail2!(\"parse_purity: bad purity {}\", c)\n     }\n }\n \n@@ -488,7 +488,7 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     match c {\n         'o' => ast::Once,\n         'm' => ast::Many,\n-        _ => fail!(\"parse_onceness: bad onceness\")\n+        _ => fail2!(\"parse_onceness: bad onceness\")\n     }\n }\n \n@@ -539,21 +539,21 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n-        error!(\"didn't find ':' when parsing def id\");\n-        fail!();\n+        error2!(\"didn't find ':' when parsing def id\");\n+        fail2!();\n     }\n \n     let crate_part = buf.slice(0u, colon_idx);\n     let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,\n-       None => fail!(\"internal error: parse_def_id: crate number expected, but found %?\",\n+       None => fail2!(\"internal error: parse_def_id: crate number expected, but found {:?}\",\n                      crate_part)\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n        Some(dn) => dn as int,\n-       None => fail!(\"internal error: parse_def_id: id expected, but found %?\",\n+       None => fail2!(\"internal error: parse_def_id: id expected, but found {:?}\",\n                      def_part)\n     };\n     ast::DefId { crate: crate_num, node: def_num }\n@@ -599,7 +599,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 return param_bounds;\n             }\n             _ => {\n-                fail!(\"parse_bounds: bad bounds\")\n+                fail2!(\"parse_bounds: bad bounds\")\n             }\n         }\n     }"}, {"sha": "09c776a9fab5d8a12a31b200f58a2904e020f4ea", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -86,7 +86,7 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n           let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n           if abbrev_len < len {\n               // I.e. it's actually an abbreviation.\n-              let s = fmt!(\"#%x:%x#\", pos, len).to_managed();\n+              let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len).to_managed();\n               let a = ty_abbrev { pos: pos, len: len, s: s };\n               abbrevs.insert(t, a);\n           }\n@@ -336,18 +336,18 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_struct(def, ref substs) => {\n-          debug!(\"~~~~ %s\", \"a[\");\n+          debug2!(\"~~~~ {}\", \"a[\");\n           w.write_str(&\"a[\");\n           let s = (cx.ds)(def);\n-          debug!(\"~~~~ %s\", s);\n+          debug2!(\"~~~~ {}\", s);\n           w.write_str(s);\n-          debug!(\"~~~~ %s\", \"|\");\n+          debug2!(\"~~~~ {}\", \"|\");\n           w.write_char('|');\n           enc_substs(w, cx, substs);\n-          debug!(\"~~~~ %s\", \"]\");\n+          debug2!(\"~~~~ {}\", \"]\");\n           w.write_char(']');\n       }\n-      ty::ty_err => fail!(\"Shouldn't encode error type\")\n+      ty::ty_err => fail2!(\"Shouldn't encode error type\")\n     }\n }\n "}, {"sha": "902f90eb7cd5c8dd8aea899d501d3e3d85078e81", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -84,7 +84,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n-    debug!(\"> Encoding inlined item: %s::%s (%u)\",\n+    debug2!(\"> Encoding inlined item: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n            ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n@@ -97,7 +97,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n     ebml_w.end_tag();\n \n-    debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n+    debug2!(\"< Encoded inlined fn: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n            ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n@@ -117,7 +117,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,\n       Some(ast_doc) => {\n-        debug!(\"> Decoding inlined fn: %s::?\",\n+        debug2!(\"> Decoding inlined fn: {}::?\",\n                ast_map::path_to_str(path, token::get_ident_interner()));\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n@@ -129,8 +129,8 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         };\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n-        debug!(\"< Decoded inlined fn: %s::%s\",\n+        debug2!(\"Fn named: {}\", tcx.sess.str_of(ii.ident()));\n+        debug2!(\"< Decoded inlined fn: {}::{}\",\n                ast_map::path_to_str(path, token::get_ident_interner()),\n                tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n@@ -140,7 +140,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::ii_item(i) => {\n-            debug!(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n+            debug2!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n           }\n           _ => { }\n@@ -305,7 +305,7 @@ impl fold::ast_fold for NestedItemsDropper {\n                     node: ast::DeclItem(_),\n                     span: _\n                 }, _) => None,\n-                ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n+                ast::StmtMac(*) => fail2!(\"unexpanded macro in astencode\")\n             }\n         }.collect();\n         let blk_sans_items = ast::Block {\n@@ -741,7 +741,7 @@ impl vtable_decoder_helpers for reader::Decoder {\n                     )\n                   }\n                   // hard to avoid - user input\n-                  _ => fail!(\"bad enum variant\")\n+                  _ => fail2!(\"bad enum variant\")\n                 }\n             }\n         }\n@@ -896,7 +896,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n-    debug!(\"Encoding side tables for id %d\", id);\n+    debug2!(\"Encoding side tables for id {}\", id);\n \n     {\n         let r = tcx.def_map.find(&id);\n@@ -1091,7 +1091,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n-            debug!(\"read_ty(%s) = %s\",\n+            debug2!(\"read_ty({}) = {}\",\n                    type_string(doc),\n                    ty_to_str(xcx.dcx.tcx, ty));\n \n@@ -1176,7 +1176,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n             NominalType | TypeWithId => xcx.tr_def_id(did),\n             TypeParameter => xcx.tr_intern_def_id(did)\n         };\n-        debug!(\"convert_def_id(source=%?, did=%?)=%?\", source, did, r);\n+        debug2!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n     }\n }\n@@ -1189,14 +1189,14 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n         let id = xcx.tr_id(id0);\n \n-        debug!(\">> Side table document with tag 0x%x \\\n-                found for id %d (orig %d)\",\n+        debug2!(\">> Side table document with tag 0x{:x} \\\n+                found for id {} (orig {})\",\n                tag, id, id0);\n \n         match c::astencode_tag::from_uint(tag) {\n             None => {\n                 xcx.dcx.tcx.sess.bug(\n-                    fmt!(\"unknown tag found in side tables: %x\", tag));\n+                    format!(\"unknown tag found in side tables: {:x}\", tag));\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1210,7 +1210,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(xcx);\n-                        debug!(\"inserting ty for node %?: %s\",\n+                        debug2!(\"inserting ty for node {:?}: {}\",\n                                id, ty_to_str(dcx.tcx, ty));\n                         dcx.tcx.node_types.insert(id as uint, ty);\n                     }\n@@ -1257,13 +1257,13 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug(\n-                            fmt!(\"unknown tag found in side tables: %x\", tag));\n+                            format!(\"unknown tag found in side tables: {:x}\", tag));\n                     }\n                 }\n             }\n         }\n \n-        debug!(\">< Side table doc loaded\");\n+        debug2!(\">< Side table doc loaded\");\n         true\n     };\n }\n@@ -1381,6 +1381,6 @@ fn test_simplification() {\n                      == pprust::item_to_str(item_exp,\n                                             token::get_ident_interner()));\n       }\n-      _ => fail!()\n+      _ => fail2!()\n     }\n }"}, {"sha": "5334bf7cc1de4cc0e59d640c07f75a957daaa752", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -65,7 +65,7 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n                    body: &ast::Block) {\n-    debug!(\"check_loans(body id=%?)\", body.id);\n+    debug2!(\"check_loans(body id={:?})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n@@ -94,12 +94,12 @@ impl<'self> CheckLoanCtxt<'self> {\n             MoveWhileBorrowed(loan_path, loan_span) => {\n                 self.bccx.span_err(\n                     cap_var.span,\n-                    fmt!(\"cannot move `%s` into closure \\\n+                    format!(\"cannot move `{}` into closure \\\n                           because it is borrowed\",\n                          self.bccx.loan_path_to_str(move_path)));\n                 self.bccx.span_note(\n                     loan_span,\n-                    fmt!(\"borrow of `%s` occurs here\",\n+                    format!(\"borrow of `{}` occurs here\",\n                          self.bccx.loan_path_to_str(loan_path)));\n             }\n         }\n@@ -197,10 +197,10 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! issued when we enter `scope_id` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n \n-        debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n+        debug2!(\"check_for_conflicting_loans(scope_id={:?})\", scope_id);\n \n         let new_loan_indices = self.loans_generated_by(scope_id);\n-        debug!(\"new_loan_indices = %?\", new_loan_indices);\n+        debug2!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n         do self.each_issued_loan(scope_id) |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n@@ -225,7 +225,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n-        debug!(\"report_error_if_loans_conflict(old_loan=%s, new_loan=%s)\",\n+        debug2!(\"report_error_if_loans_conflict(old_loan={}, new_loan={})\",\n                old_loan.repr(self.tcx()),\n                new_loan.repr(self.tcx()));\n \n@@ -249,8 +249,8 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Checks whether the restrictions introduced by `loan1` would\n         //! prohibit `loan2`. Returns false if an error is reported.\n \n-        debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n-                loan1=%s, loan2=%s)\",\n+        debug2!(\"report_error_if_loan_conflicts_with_restriction(\\\n+                loan1={}, loan2={})\",\n                loan1.repr(self.tcx()),\n                loan2.repr(self.tcx()));\n \n@@ -260,7 +260,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             ImmutableMutability => RESTR_ALIAS | RESTR_FREEZE,\n             ConstMutability     => RESTR_ALIAS,\n         };\n-        debug!(\"illegal_if=%?\", illegal_if);\n+        debug2!(\"illegal_if={:?}\", illegal_if);\n \n         for restr in loan1.restrictions.iter() {\n             if !restr.set.intersects(illegal_if) { loop; }\n@@ -270,27 +270,27 @@ impl<'self> CheckLoanCtxt<'self> {\n                 (MutableMutability, MutableMutability) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        fmt!(\"cannot borrow `%s` as mutable \\\n+                        format!(\"cannot borrow `{}` as mutable \\\n                               more than once at a time\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path)));\n                     self.bccx.span_note(\n                         old_loan.span,\n-                        fmt!(\"second borrow of `%s` as mutable occurs here\",\n+                        format!(\"second borrow of `{}` as mutable occurs here\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path)));\n                     return false;\n                 }\n \n                 _ => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        fmt!(\"cannot borrow `%s` as %s because \\\n-                              it is also borrowed as %s\",\n+                        format!(\"cannot borrow `{}` as {} because \\\n+                              it is also borrowed as {}\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path),\n                              self.bccx.mut_to_str(new_loan.mutbl),\n                              self.bccx.mut_to_str(old_loan.mutbl)));\n                     self.bccx.span_note(\n                         old_loan.span,\n-                        fmt!(\"second borrow of `%s` occurs here\",\n+                        format!(\"second borrow of `{}` occurs here\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path)));\n                     return false;\n                 }\n@@ -317,7 +317,7 @@ impl<'self> CheckLoanCtxt<'self> {\n          * is using a moved/uninitialized value\n          */\n \n-        debug!(\"check_if_path_is_moved(id=%?, use_kind=%?, lp=%s)\",\n+        debug2!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n         do self.move_data.each_move_of(id, lp) |move, moved_lp| {\n             self.bccx.report_use_of_moved_value(\n@@ -338,7 +338,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             Some(&adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n \n-        debug!(\"check_assignment(cmt=%s)\", cmt.repr(self.tcx()));\n+        debug2!(\"check_assignment(cmt={})\", cmt.repr(self.tcx()));\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n@@ -372,7 +372,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         // Otherwise, just a plain error.\n         self.bccx.span_err(\n             expr.span,\n-            fmt!(\"cannot assign to %s %s\",\n+            format!(\"cannot assign to {} {}\",\n                  cmt.mutbl.to_user_str(),\n                  self.bccx.cmt_to_str(cmt)));\n         return;\n@@ -387,7 +387,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n             let mut cmt = cmt;\n             loop {\n-                debug!(\"mark_writes_through_upvars_as_used_mut(cmt=%s)\",\n+                debug2!(\"mark_writes_through_upvars_as_used_mut(cmt={})\",\n                        cmt.repr(this.tcx()));\n                 match cmt.cat {\n                     mc::cat_local(id) |\n@@ -435,7 +435,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n-            debug!(\"check_for_aliasable_mutable_writes(cmt=%s, guarantor=%s)\",\n+            debug2!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n                 mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) => {\n@@ -451,7 +451,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                         id: guarantor.id,\n                         derefs: deref_count\n                     };\n-                    debug!(\"Inserting write guard at %?\", key);\n+                    debug2!(\"Inserting write guard at {:?}\", key);\n                     this.bccx.write_guard_map.insert(key);\n                 }\n \n@@ -646,11 +646,11 @@ impl<'self> CheckLoanCtxt<'self> {\n                                    loan: &Loan) {\n         self.bccx.span_err(\n             expr.span,\n-            fmt!(\"cannot assign to `%s` because it is borrowed\",\n+            format!(\"cannot assign to `{}` because it is borrowed\",\n                  self.bccx.loan_path_to_str(loan_path)));\n         self.bccx.span_note(\n             loan.span,\n-            fmt!(\"borrow of `%s` occurs here\",\n+            format!(\"borrow of `{}` occurs here\",\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n@@ -674,12 +674,12 @@ impl<'self> CheckLoanCtxt<'self> {\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n                     self.bccx.span_err(\n                         span,\n-                        fmt!(\"cannot move out of `%s` \\\n+                        format!(\"cannot move out of `{}` \\\n                               because it is borrowed\",\n                              self.bccx.loan_path_to_str(move_path)));\n                     self.bccx.span_note(\n                         loan_span,\n-                        fmt!(\"borrow of `%s` occurs here\",\n+                        format!(\"borrow of `{}` occurs here\",\n                              self.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n@@ -690,7 +690,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n                                  move_path: @LoanPath) -> MoveError {\n-        debug!(\"analyze_move_out_from(expr_id=%?, move_path=%s)\",\n+        debug2!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n                expr_id, move_path.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n@@ -772,12 +772,12 @@ fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n                     this.bccx.span_err(\n                         cap_var.span,\n-                        fmt!(\"cannot move `%s` into closure \\\n+                        format!(\"cannot move `{}` into closure \\\n                               because it is borrowed\",\n                              this.bccx.loan_path_to_str(move_path)));\n                     this.bccx.span_note(\n                         loan_span,\n-                        fmt!(\"borrow of `%s` occurs here\",\n+                        format!(\"borrow of `{}` occurs here\",\n                              this.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n@@ -794,7 +794,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n                            expr: @ast::Expr) {\n     visit::walk_expr(this, expr, ());\n \n-    debug!(\"check_loans_in_expr(expr=%s)\",\n+    debug2!(\"check_loans_in_expr(expr={})\",\n            expr.repr(this.tcx()));\n \n     this.check_for_conflicting_loans(expr.id);\n@@ -805,7 +805,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       ast::ExprPath(*) => {\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n-              debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n+              debug2!(\"path cmt={}\", cmt.repr(this.tcx()));\n               let r = opt_loan_path(cmt);\n               for &lp in r.iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);"}, {"sha": "a6db028a4919ba0a504d16e3533eef7aa0441792", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -105,7 +105,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n         mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n             bccx.span_err(\n                 cmt0.span,\n-                fmt!(\"cannot move out of %s\",\n+                format!(\"cannot move out of {}\",\n                      bccx.cmt_to_str(cmt)));\n             false\n         }\n@@ -120,7 +120,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n             };\n             bccx.span_err(\n                 cmt0.span,\n-                fmt!(\"cannot move out of %s%s\", bccx.cmt_to_str(cmt), once_hint));\n+                format!(\"cannot move out of {}{}\", bccx.cmt_to_str(cmt), once_hint));\n             false\n         }\n \n@@ -158,7 +158,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                     if ty::has_dtor(bccx.tcx, did) {\n                         bccx.span_err(\n                             cmt0.span,\n-                            fmt!(\"cannot move out of type `%s`, \\\n+                            format!(\"cannot move out of type `{}`, \\\n                                   which defines the `Drop` trait\",\n                                  b.ty.user_string(bccx.tcx)));\n                         false"}, {"sha": "485004a642cfbcce25a8911ecfd476e50d06f6e6", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -27,7 +27,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n                           loan_mutbl: LoanMutability) {\n-    debug!(\"guarantee_lifetime(cmt=%s, loan_region=%s)\",\n+    debug2!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope_id: item_scope_id,\n@@ -101,7 +101,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                     // L-Deref-Managed-Mut-Compiler-Root\n                     self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n                 } else {\n-                    debug!(\"omitting root, base=%s, base_scope=%?\",\n+                    debug2!(\"omitting root, base={}, base_scope={:?}\",\n                            base.repr(self.tcx()), base_scope);\n                 }\n             }\n@@ -189,8 +189,8 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                   derefs: uint,\n                   ptr_mutbl: ast::Mutability,\n                   discr_scope: Option<ast::NodeId>) {\n-        debug!(\"check_root(cmt_deref=%s, cmt_base=%s, derefs=%?, ptr_mutbl=%?, \\\n-                discr_scope=%?)\",\n+        debug2!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n+                discr_scope={:?})\",\n                cmt_deref.repr(self.tcx()),\n                cmt_base.repr(self.tcx()),\n                derefs,\n@@ -213,7 +213,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 // the check above should fail for anything is not re_scope\n                 self.bccx.tcx.sess.span_bug(\n                     cmt_base.span,\n-                    fmt!(\"Cannot issue root for scope region: %?\",\n+                    format!(\"Cannot issue root for scope region: {:?}\",\n                          self.loan_region));\n             }\n         };\n@@ -247,16 +247,16 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         // FIXME(#3511) grow to the nearest cleanup scope---this can\n         // cause observable errors if freezing!\n         if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n-            debug!(\"%? is not a cleanup scope, adjusting\", root_scope);\n+            debug2!(\"{:?} is not a cleanup scope, adjusting\", root_scope);\n \n             let cleanup_scope =\n                 self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n \n             if opt_dyna.is_some() {\n                 self.tcx().sess.span_warn(\n                     self.span,\n-                    fmt!(\"Dynamic freeze scope artifically extended \\\n-                          (see Issue #6248)\"));\n+                    format!(\"Dynamic freeze scope artifically extended \\\n+                          (see Issue \\\\#6248)\"));\n                 note_and_explain_region(\n                     self.bccx.tcx,\n                     \"managed value only needs to be frozen for \",\n@@ -277,7 +277,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n         self.bccx.root_map.insert(rm_key, root_info);\n \n-        debug!(\"root_key: %? root_info: %?\", rm_key, root_info);\n+        debug2!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n     }\n \n     fn check_scope(&self, max_scope: ty::Region) {\n@@ -310,7 +310,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n             r @ mc::cat_discr(*) => {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n-                    fmt!(\"illegal guarantor category: %?\", r));\n+                    format!(\"illegal guarantor category: {:?}\", r));\n             }\n         }\n     }"}, {"sha": "b3980c2e045b93de80165c693921b761ea1cf797", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -136,7 +136,7 @@ fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n                       id: ast::NodeId) {\n     match fk {\n         &visit::fk_item_fn(*) | &visit::fk_method(*) => {\n-            fail!(\"cannot occur, due to visit_item override\");\n+            fail2!(\"cannot occur, due to visit_item override\");\n         }\n \n         // Visit closures as part of the containing item.\n@@ -196,7 +196,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     let bccx = this.bccx;\n     let tcx = bccx.tcx;\n \n-    debug!(\"gather_loans_in_expr(expr=%?/%s)\",\n+    debug2!(\"gather_loans_in_expr(expr={:?}/{})\",\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     this.id_range.add(ex.id);\n@@ -330,20 +330,20 @@ impl<'self> GatherLoanCtxt<'self> {\n     pub fn guarantee_adjustments(&mut self,\n                                  expr: @ast::Expr,\n                                  adjustment: &ty::AutoAdjustment) {\n-        debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n+        debug2!(\"guarantee_adjustments(expr={}, adjustment={:?})\",\n                expr.repr(self.tcx()), adjustment);\n         let _i = indenter();\n \n         match *adjustment {\n             ty::AutoAddEnv(*) => {\n-                debug!(\"autoaddenv -- no autoref\");\n+                debug2!(\"autoaddenv -- no autoref\");\n                 return;\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: None, _ }) => {\n-                debug!(\"no autoref\");\n+                debug2!(\"no autoref\");\n                 return;\n             }\n \n@@ -355,7 +355,7 @@ impl<'self> GatherLoanCtxt<'self> {\n                     tcx: self.tcx(),\n                     method_map: self.bccx.method_map};\n                 let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n-                debug!(\"after autoderef, cmt=%s\", cmt.repr(self.tcx()));\n+                debug2!(\"after autoderef, cmt={}\", cmt.repr(self.tcx()));\n \n                 match *autoref {\n                     ty::AutoPtr(r, m) => {\n@@ -412,8 +412,8 @@ impl<'self> GatherLoanCtxt<'self> {\n                            cmt: mc::cmt,\n                            req_mutbl: LoanMutability,\n                            loan_region: ty::Region) {\n-        debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n-                req_mutbl=%?, loan_region=%?)\",\n+        debug2!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n+                req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n                req_mutbl,\n@@ -470,16 +470,16 @@ impl<'self> GatherLoanCtxt<'self> {\n                     ty::re_infer(*) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            fmt!(\"Invalid borrow lifetime: %?\", loan_region));\n+                            format!(\"Invalid borrow lifetime: {:?}\", loan_region));\n                     }\n                 };\n-                debug!(\"loan_scope = %?\", loan_scope);\n+                debug2!(\"loan_scope = {:?}\", loan_scope);\n \n                 let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n-                debug!(\"gen_scope = %?\", gen_scope);\n+                debug2!(\"gen_scope = {:?}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n-                debug!(\"kill_scope = %?\", kill_scope);\n+                debug2!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_mutbl == MutableMutability {\n                     self.mark_loan_path_as_mutated(loan_path);\n@@ -499,7 +499,7 @@ impl<'self> GatherLoanCtxt<'self> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id=%?), loan=%s\",\n+        debug2!(\"guarantee_valid(borrow_id={:?}), loan={}\",\n                borrow_id, loan.repr(self.tcx()));\n \n         // let loan_path = loan.loan_path;\n@@ -785,7 +785,7 @@ impl<'self> GatherLoanCtxt<'self> {\n             _ => {\n                 self.tcx().sess.span_bug(\n                     pat.span,\n-                    fmt!(\"Type of slice pattern is not a slice\"));\n+                    format!(\"Type of slice pattern is not a slice\"));\n             }\n         }\n     }"}, {"sha": "f2bfc6fb4ec2e4ba8828420834774177af348a43", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -117,7 +117,7 @@ pub fn check_crate(\n     fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n         let total = bccx.stats.guaranteed_paths as float;\n-        fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n+        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100f / total)\n     }\n }\n \n@@ -135,7 +135,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n         &visit::fk_item_fn(*) |\n         &visit::fk_method(*) => {\n-            debug!(\"borrowck_fn(id=%?)\", id);\n+            debug2!(\"borrowck_fn(id={:?})\", id);\n \n             // Check the body of fn items.\n             let (id_range, all_loans, move_data) =\n@@ -561,15 +561,15 @@ impl BorrowckCtxt {\n             move_data::Declared => {\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    fmt!(\"%s of possibly uninitialized value: `%s`\",\n+                    format!(\"{} of possibly uninitialized value: `{}`\",\n                          verb,\n                          self.loan_path_to_str(lp)));\n             }\n             _ => {\n                 let partially = if lp == moved_lp {\"\"} else {\"partially \"};\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    fmt!(\"%s of %smoved value: `%s`\",\n+                    format!(\"{} of {}moved value: `{}`\",\n                          verb,\n                          partially,\n                          self.loan_path_to_str(lp)));\n@@ -585,7 +585,7 @@ impl BorrowckCtxt {\n                         \"moved by default (use `copy` to override)\");\n                 self.tcx.sess.span_note(\n                     expr.span,\n-                    fmt!(\"`%s` moved here because it has type `%s`, which is %s\",\n+                    format!(\"`{}` moved here because it has type `{}`, which is {}\",\n                          self.loan_path_to_str(moved_lp),\n                          expr_ty.user_string(self.tcx), suggestion));\n             }\n@@ -594,7 +594,7 @@ impl BorrowckCtxt {\n                 let pat_ty = ty::node_id_to_type(self.tcx, pat.id);\n                 self.tcx.sess.span_note(\n                     pat.span,\n-                    fmt!(\"`%s` moved here because it has type `%s`, \\\n+                    format!(\"`{}` moved here because it has type `{}`, \\\n                           which is moved by default (use `ref` to override)\",\n                          self.loan_path_to_str(moved_lp),\n                          pat_ty.user_string(self.tcx)));\n@@ -607,8 +607,8 @@ impl BorrowckCtxt {\n                          capture that instead to override)\");\n                 self.tcx.sess.span_note(\n                     expr.span,\n-                    fmt!(\"`%s` moved into closure environment here because it \\\n-                          has type `%s`, which is %s\",\n+                    format!(\"`{}` moved into closure environment here because it \\\n+                          has type `{}`, which is {}\",\n                          self.loan_path_to_str(moved_lp),\n                          expr_ty.user_string(self.tcx), suggestion));\n             }\n@@ -634,11 +634,11 @@ impl BorrowckCtxt {\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err(\n             span,\n-            fmt!(\"re-assignment of immutable variable `%s`\",\n+            format!(\"re-assignment of immutable variable `{}`\",\n                  self.loan_path_to_str(lp)));\n         self.tcx.sess.span_note(\n             assign.span,\n-            fmt!(\"prior assignment occurs here\"));\n+            format!(\"prior assignment occurs here\"));\n     }\n \n     pub fn span_err(&self, s: Span, m: &str) {\n@@ -652,23 +652,23 @@ impl BorrowckCtxt {\n     pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n             err_mutbl(lk) => {\n-                fmt!(\"cannot borrow %s %s as %s\",\n+                format!(\"cannot borrow {} {} as {}\",\n                      err.cmt.mutbl.to_user_str(),\n                      self.cmt_to_str(err.cmt),\n                      self.mut_to_str(lk))\n             }\n             err_out_of_root_scope(*) => {\n-                fmt!(\"cannot root managed value long enough\")\n+                format!(\"cannot root managed value long enough\")\n             }\n             err_out_of_scope(*) => {\n-                fmt!(\"borrowed value does not live long enough\")\n+                format!(\"borrowed value does not live long enough\")\n             }\n             err_freeze_aliasable_const => {\n                 // Means that the user borrowed a ~T or enum value\n                 // residing in &const or @const pointer.  Terrible\n                 // error message, but then &const and @const are\n                 // supposed to be going away.\n-                fmt!(\"unsafe borrow of aliasable, const value\")\n+                format!(\"unsafe borrow of aliasable, const value\")\n             }\n         }\n     }\n@@ -686,27 +686,27 @@ impl BorrowckCtxt {\n             mc::AliasableOther => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in an aliasable location\", prefix));\n+                    format!(\"{} in an aliasable location\", prefix));\n             }\n             mc::AliasableManaged(ast::MutMutable) => {\n                 // FIXME(#6269) reborrow @mut to &mut\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in a `@mut` pointer; \\\n+                    format!(\"{} in a `@mut` pointer; \\\n                           try borrowing as `&mut` first\", prefix));\n             }\n             mc::AliasableManaged(m) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in a `@%s` pointer; \\\n+                    format!(\"{} in a `@{}` pointer; \\\n                           try an `@mut` instead\",\n                          prefix,\n                          self.mut_to_keyword(m)));\n             }\n             mc::AliasableBorrowed(m) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in a `&%s` pointer; \\\n+                    format!(\"{} in a `&{}` pointer; \\\n                           try an `&mut` instead\",\n                          prefix,\n                          self.mut_to_keyword(m)));\n@@ -774,7 +774,7 @@ impl BorrowckCtxt {\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n-                            fmt!(\"Loan path LpVar(%?) maps to %?, not local\",\n+                            format!(\"Loan path LpVar({:?}) maps to {:?}, not local\",\n                                  id, r));\n                     }\n                 }\n@@ -849,7 +849,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n \n impl Repr for Loan {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"Loan_%?(%s, %?, %?-%?, %s)\",\n+        format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n              self.index,\n              self.loan_path.repr(tcx),\n              self.mutbl,\n@@ -861,7 +861,7 @@ impl Repr for Loan {\n \n impl Repr for Restriction {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"Restriction(%s, %x)\",\n+        format!(\"Restriction({}, {:x})\",\n              self.loan_path.repr(tcx),\n              self.set.bits as uint)\n     }\n@@ -871,15 +871,15 @@ impl Repr for LoanPath {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match self {\n             &LpVar(id) => {\n-                fmt!(\"$(%?)\", id)\n+                format!(\"$({:?})\", id)\n             }\n \n             &LpExtend(lp, _, LpDeref(_)) => {\n-                fmt!(\"%s.*\", lp.repr(tcx))\n+                format!(\"{}.*\", lp.repr(tcx))\n             }\n \n             &LpExtend(lp, _, LpInterior(ref interior)) => {\n-                fmt!(\"%s.%s\", lp.repr(tcx), interior.repr(tcx))\n+                format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n             }\n         }\n     }"}, {"sha": "239254e82dd5232b6ccba407aa2ff4bc77761b6e", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -244,7 +244,7 @@ impl MoveData {\n             }\n         };\n \n-        debug!(\"move_path(lp=%s, index=%?)\",\n+        debug2!(\"move_path(lp={}, index={:?})\",\n                lp.repr(tcx),\n                index);\n \n@@ -304,7 +304,7 @@ impl MoveData {\n          * location `id` with kind `kind`.\n          */\n \n-        debug!(\"add_move(lp=%s, id=%?, kind=%?)\",\n+        debug2!(\"add_move(lp={}, id={:?}, kind={:?})\",\n                lp.repr(tcx),\n                id,\n                kind);\n@@ -334,7 +334,7 @@ impl MoveData {\n          * location `id` with the given `span`.\n          */\n \n-        debug!(\"add_assignment(lp=%s, assign_id=%?, assignee_id=%?\",\n+        debug2!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n                lp.repr(tcx), assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp);\n@@ -348,12 +348,12 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp=%s, assignment=%u, path_index=%?)\",\n+            debug2!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n                    lp.repr(tcx), self.var_assignments.len(), path_index);\n \n             self.var_assignments.push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp=%s, path_index=%?)\",\n+            debug2!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n \n             self.path_assignments.push(assignment);"}, {"sha": "9e92bd3829c5da59568b98c853f437fc97aed1da", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -239,7 +239,7 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref body, _) => {\n                 //\n@@ -504,13 +504,13 @@ impl CFGBuilder {\n                         }\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            fmt!(\"No loop scope for id %?\", loop_id));\n+                            format!(\"No loop scope for id {:?}\", loop_id));\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                            format!(\"Bad entry `{:?}` in def_map for label\", r));\n                     }\n                 }\n             }"}, {"sha": "30cf827cb72cfc9551c6994f659c583666c342f2", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -153,7 +153,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n               Some(&DefStruct(_)) => { }\n \n               Some(&def) => {\n-                debug!(\"(checking const) found bad def: %?\", def);\n+                debug2!(\"(checking const) found bad def: {:?}\", def);\n                 sess.span_err(\n                     e.span,\n                     \"paths in constants may only refer to \\\n@@ -266,7 +266,7 @@ impl Visitor<()> for CheckItemRecursionVisitor {\n                         ast_map::node_item(it, _) => {\n                             self.visit_item(it, ());\n                         }\n-                        _ => fail!(\"const not bound to an item\")\n+                        _ => fail2!(\"const not bound to an item\")\n                     },\n                 _ => ()\n             },"}, {"sha": "8befb42f300e2898d9c9251329416812a1c52f2c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -86,8 +86,8 @@ pub fn check_expr(v: &mut CheckMatchVisitor,\n        if (*arms).is_empty() {\n            if !type_is_empty(cx.tcx, pat_ty) {\n                // We know the type is inhabited, so this must be wrong\n-               cx.tcx.sess.span_err(ex.span, fmt!(\"non-exhaustive patterns: \\\n-                            type %s is non-empty\",\n+               cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n+                            type {} is non-empty\",\n                             ty_to_str(cx.tcx, pat_ty)));\n            }\n            // If the type *is* empty, it's vacuously exhaustive\n@@ -180,20 +180,20 @@ pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                 ty::ty_enum(id, _) => {\n                     let vid = match *ctor {\n                         variant(id) => id,\n-                        _ => fail!(\"check_exhaustive: non-variant ctor\"),\n+                        _ => fail2!(\"check_exhaustive: non-variant ctor\"),\n                     };\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n                     match variants.iter().find(|v| v.id == vid) {\n                         Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n                         None => {\n-                            fail!(\"check_exhaustive: bad variant in ctor\")\n+                            fail2!(\"check_exhaustive: bad variant in ctor\")\n                         }\n                     }\n                 }\n                 ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                     match *ctor {\n-                        vec(n) => Some(fmt!(\"vectors of length %u\", n).to_managed()),\n+                        vec(n) => Some(format!(\"vectors of length {}\", n).to_managed()),\n                         _ => None\n                     }\n                 }\n@@ -202,7 +202,7 @@ pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n         }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-        Some(ref s) => fmt!(\": %s not covered\",  *s),\n+        Some(ref s) => format!(\": {} not covered\",  *s),\n         None => ~\"\"\n     };\n     cx.tcx.sess.span_err(sp, msg);\n@@ -408,7 +408,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n                     return Some(variant(v.id));\n                 }\n             }\n-            fail!();\n+            fail2!();\n         } else { None }\n       }\n       ty::ty_nil => None,\n@@ -420,7 +420,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n               Some(val(const_bool(false))) => false_found = true,\n-              _ => fail!(\"impossible case\")\n+              _ => fail2!(\"impossible case\")\n             }\n         }\n         if true_found && false_found { None }\n@@ -510,10 +510,10 @@ pub fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match *ctor { variant(id) => id,\n-          _ => fail!(\"impossible case\") };\n+          _ => fail2!(\"impossible case\") };\n         match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n             Some(v) => v.args.len(),\n-            None => fail!(\"impossible case\")\n+            None => fail2!(\"impossible case\")\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n@@ -584,7 +584,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                 }\n                             }\n                             single => true,\n-                            _ => fail!(\"type error\")\n+                            _ => fail2!(\"type error\")\n                         };\n                         if match_ {\n                             Some(r.tail().to_owned())\n@@ -631,7 +631,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                 }\n                             }\n                             single => true,\n-                            _ => fail!(\"type error\")\n+                            _ => fail2!(\"type error\")\n                         };\n                         if match_ {\n                             Some(r.tail().to_owned())\n@@ -693,7 +693,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                             _ => {\n                                 cx.tcx.sess.span_bug(\n                                     pat_span,\n-                                    fmt!(\"struct pattern resolved to %s, \\\n+                                    format!(\"struct pattern resolved to {}, \\\n                                           not a struct\",\n                                          ty_to_str(cx.tcx, left_ty)));\n                             }\n@@ -739,7 +739,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                         }\n                     }\n                     single => true,\n-                    _ => fail!(\"type error\")\n+                    _ => fail2!(\"type error\")\n                 };\n                 if match_ { Some(r.tail().to_owned()) } else { None }\n             }\n@@ -748,7 +748,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     val(ref v) => (*v, *v),\n                     range(ref lo, ref hi) => (*lo, *hi),\n                     single => return Some(r.tail().to_owned()),\n-                    _ => fail!(\"type error\")\n+                    _ => fail2!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n                 let v_hi = eval_const_expr(cx.tcx, hi);\n@@ -929,8 +929,8 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     _ => {\n                         cx.tcx.sess.span_bug(\n                             p.span,\n-                            fmt!(\"Binding pattern %d is \\\n-                                  not an identifier: %?\",\n+                            format!(\"Binding pattern {} is \\\n+                                  not an identifier: {:?}\",\n                                  p.id, p.node));\n                     }\n                 }"}, {"sha": "b9355d326637726985783cb2b6955a48cc62e4fb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -103,20 +103,20 @@ impl<O:DataFlowOperator> pprust::pp_ann for DataFlowContext<O> {\n \n             let gens = self.gens.slice(start, end);\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n-                fmt!(\" gen: %s\", bits_to_str(gens))\n+                format!(\" gen: {}\", bits_to_str(gens))\n             } else {\n                 ~\"\"\n             };\n \n             let kills = self.kills.slice(start, end);\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n-                fmt!(\" kill: %s\", bits_to_str(kills))\n+                format!(\" kill: {}\", bits_to_str(kills))\n             } else {\n                 ~\"\"\n             };\n \n-            let comment_str = fmt!(\"id %d: %s%s%s\",\n-                                   id, entry_str, gens_str, kills_str);\n+            let comment_str = format!(\"id {}: {}{}{}\",\n+                                      id, entry_str, gens_str, kills_str);\n             pprust::synth_comment(ps, comment_str);\n             pp::space(ps.s);\n         }\n@@ -131,7 +131,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                bits_per_id: uint) -> DataFlowContext<O> {\n         let words_per_id = (bits_per_id + uint::bits - 1) / uint::bits;\n \n-        debug!(\"DataFlowContext::new(id_range=%?, bits_per_id=%?, words_per_id=%?)\",\n+        debug2!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n                id_range, bits_per_id, words_per_id);\n \n         let gens = ~[];\n@@ -154,7 +154,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n \n-        debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n+        debug2!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n             let gens = self.gens.mut_slice(start, end);\n@@ -165,7 +165,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n \n-        debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n+        debug2!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n             let kills = self.kills.mut_slice(start, end);\n@@ -176,25 +176,25 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     fn apply_gen_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n \n-        debug!(\"apply_gen_kill(id=%?, bits=%s) [before]\",\n+        debug2!(\"apply_gen_kill(id={:?}, bits={}) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n         let gens = self.gens.slice(start, end);\n         bitwise(bits, gens, |a, b| a | b);\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, |a, b| a & !b);\n \n-        debug!(\"apply_gen_kill(id=%?, bits=%s) [after]\",\n+        debug2!(\"apply_gen_kill(id={:?}, bits={}) [after]\",\n                id, mut_bits_to_str(bits));\n     }\n \n     fn apply_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n-        debug!(\"apply_kill(id=%?, bits=%s) [before]\",\n+        debug2!(\"apply_kill(id={:?}, bits={}) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, |a, b| a & !b);\n-        debug!(\"apply_kill(id=%?, bits=%s) [after]\",\n+        debug2!(\"apply_kill(id={:?}, bits={}) [after]\",\n                id, mut_bits_to_str(bits));\n     }\n \n@@ -242,7 +242,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"each_bit_on_entry_frozen(id=%?, on_entry=%s)\",\n+        debug2!(\"each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n@@ -255,7 +255,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n         let (start, end) = self.compute_id_range(id);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n+        debug2!(\"each_bit_on_entry(id={:?}, on_entry={})\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n@@ -267,7 +267,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n         let (start, end) = self.compute_id_range(id);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+        debug2!(\"each_gen_bit(id={:?}, gens={})\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n@@ -281,7 +281,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+        debug2!(\"each_gen_bit(id={:?}, gens={})\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n@@ -346,8 +346,8 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n             }\n         }\n \n-        debug!(\"Dataflow result:\");\n-        debug!(\"%s\", {\n+        debug2!(\"Dataflow result:\");\n+        debug2!(\"{}\", {\n             let this = @(*self).clone();\n             this.pretty_print_to(io::stderr(), blk);\n             \"\"\n@@ -374,7 +374,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                   blk: &ast::Block,\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_block(blk.id=%?, in_out=%s)\",\n+        debug2!(\"DataFlowContext::walk_block(blk.id={:?}, in_out={})\",\n                blk.id, bits_to_str(reslice(in_out)));\n \n         self.merge_with_entry_set(blk.id, in_out);\n@@ -425,7 +425,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                  expr: &ast::Expr,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_expr(expr=%s, in_out=%s)\",\n+        debug2!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n                expr.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n         self.merge_with_entry_set(expr.id, in_out);\n@@ -569,7 +569,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref blk, _) => {\n                 //\n@@ -756,7 +756,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         let tcx = self.tcx();\n         let region_maps = tcx.region_maps;\n \n-        debug!(\"pop_scopes(from_expr=%s, to_scope=%?, in_out=%s)\",\n+        debug2!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n                from_expr.repr(tcx), to_scope.loop_id,\n                bits_to_str(reslice(in_out)));\n \n@@ -769,7 +769,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 None => {\n                     tcx.sess.span_bug(\n                         from_expr.span,\n-                        fmt!(\"pop_scopes(from_expr=%s, to_scope=%?) \\\n+                        format!(\"pop_scopes(from_expr={}, to_scope={:?}) \\\n                               to_scope does not enclose from_expr\",\n                              from_expr.repr(tcx), to_scope.loop_id));\n                 }\n@@ -784,7 +784,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         self.pop_scopes(from_expr, to_scope, in_out);\n         self.dfcx.apply_kill(from_expr.id, in_out);\n         join_bits(&self.dfcx.oper, reslice(in_out), to_scope.break_bits);\n-        debug!(\"break_from_to(from_expr=%s, to_scope=%?) final break_bits=%s\",\n+        debug2!(\"break_from_to(from_expr={}, to_scope={:?}) final break_bits={}\",\n                from_expr.repr(self.tcx()),\n                to_scope.loop_id,\n                bits_to_str(reslice(in_out)));\n@@ -833,11 +833,11 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 pat: @ast::Pat,\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n+        debug2!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n         do ast_util::walk_pat(pat) |p| {\n-            debug!(\"  p.id=%? in_out=%s\", p.id, bits_to_str(reslice(in_out)));\n+            debug2!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n             true\n@@ -882,15 +882,15 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                             None => {\n                                 self.tcx().sess.span_bug(\n                                     expr.span,\n-                                    fmt!(\"No loop scope for id %?\", loop_id));\n+                                    format!(\"No loop scope for id {:?}\", loop_id));\n                             }\n                         }\n                     }\n \n                     r => {\n                         self.tcx().sess.span_bug(\n                             expr.span,\n-                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                            format!(\"Bad entry `{:?}` in def_map for label\", r));\n                     }\n                 }\n             }\n@@ -909,15 +909,15 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n-        debug!(\"add_to_entry_set(id=%?, pred_bits=%s)\",\n+        debug2!(\"add_to_entry_set(id={:?}, pred_bits={})\",\n                id, bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n             let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             join_bits(&self.dfcx.oper, pred_bits, on_entry)\n         };\n         if changed {\n-            debug!(\"changed entry set for %? to %s\",\n+            debug2!(\"changed entry set for {:?} to {}\",\n                    id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n@@ -926,7 +926,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     fn merge_with_entry_set(&mut self,\n                             id: ast::NodeId,\n                             pred_bits: &mut [uint]) {\n-        debug!(\"merge_with_entry_set(id=%?, pred_bits=%s)\",\n+        debug2!(\"merge_with_entry_set(id={:?}, pred_bits={})\",\n                id, mut_bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n@@ -936,7 +936,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             changed\n         };\n         if changed {\n-            debug!(\"changed entry set for %? to %s\",\n+            debug2!(\"changed entry set for {:?} to {}\",\n                    id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n@@ -957,7 +957,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n         let mut v = word;\n         for _ in range(0u, uint::bytes) {\n             result.push_char(sep);\n-            result.push_str(fmt!(\"%02x\", v & 0xFF));\n+            result.push_str(format!(\"{:02x}\", v & 0xFF));\n             v >>= 8;\n             sep = '-';\n         }\n@@ -992,12 +992,12 @@ fn bitwise(out_vec: &mut [uint],\n }\n \n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n-    debug!(\"set_bit: words=%s bit=%s\",\n+    debug2!(\"set_bit: words={} bit={}\",\n            mut_bits_to_str(words), bit_str(bit));\n     let word = bit / uint::bits;\n     let bit_in_word = bit % uint::bits;\n     let bit_mask = 1 << bit_in_word;\n-    debug!(\"word=%u bit_in_word=%u bit_mask=%u\", word, bit_in_word, word);\n+    debug2!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];\n     let newv = oldv | bit_mask;\n     words[word] = newv;\n@@ -1007,7 +1007,7 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n fn bit_str(bit: uint) -> ~str {\n     let byte = bit >> 8;\n     let lobits = 1 << (bit & 0xFF);\n-    fmt!(\"[%u:%u-%02x]\", bit, byte, lobits)\n+    format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n \n fn reslice<'a>(v: &'a mut [uint]) -> &'a [uint] {"}, {"sha": "6d479ca220a06e8b1c4762391127b092029de6ae", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -58,12 +58,12 @@ impl EffectCheckVisitor {\n             SafeContext => {\n                 // Report an error.\n                 self.tcx.sess.span_err(span,\n-                                  fmt!(\"%s requires unsafe function or block\",\n+                                  format!(\"{} requires unsafe function or block\",\n                                        description))\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n-                debug!(\"effect: recording unsafe block as used: %?\", block_id);\n+                debug2!(\"effect: recording unsafe block as used: {:?}\", block_id);\n                 let _ = self.tcx.used_unsafe.insert(block_id);\n             }\n             UnsafeFn => {}\n@@ -119,7 +119,7 @@ impl Visitor<()> for EffectCheckVisitor {\n             match expr.node {\n                 ExprMethodCall(callee_id, _, _, _, _, _) => {\n                     let base_type = ty::node_id_to_type(self.tcx, callee_id);\n-                    debug!(\"effect: method call case, base type is %s\",\n+                    debug2!(\"effect: method call case, base type is {}\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n                         self.require_unsafe(expr.span,\n@@ -128,15 +128,15 @@ impl Visitor<()> for EffectCheckVisitor {\n                 }\n                 ExprCall(base, _, _) => {\n                     let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                    debug!(\"effect: call case, base type is %s\",\n+                    debug2!(\"effect: call case, base type is {}\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n                         self.require_unsafe(expr.span, \"call to unsafe function\")\n                     }\n                 }\n                 ExprUnary(_, UnDeref, base) => {\n                     let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                    debug!(\"effect: unary case, base type is %s\",\n+                    debug2!(\"effect: unary case, base type is {}\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n                     match ty::get(base_type).sty {\n                         ty_ptr(_) => {"}, {"sha": "383c37952d7a7984252a6f8fd3347d44ee7abfa5", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -53,7 +53,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n               ast::ExprPath(*) | ast::ExprSelf => {\n                   let mut i = 0;\n                   match self.def_map.find(&expr.id) {\n-                    None => fail!(\"path not found\"),\n+                    None => fail2!(\"path not found\"),\n                     Some(&df) => {\n                       let mut def = df;\n                       while i < depth {\n@@ -137,7 +137,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> freevar_info {\n     match tcx.freevars.find(&fid) {\n-      None => fail!(\"get_freevars: %d has no freevars\", fid),\n+      None => fail2!(\"get_freevars: {} has no freevars\", fid),\n       Some(&d) => return d\n     }\n }"}, {"sha": "98912b57572a61abf68f8be73bd909a7b498b1d3", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -343,7 +343,7 @@ mod test {\n         do graph.each_incoming_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_incoming.len());\n-            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+            debug2!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_incoming[counter], edge_index, edge);\n             match expected_incoming[counter] {\n                 (ref e, ref n) => {\n@@ -361,7 +361,7 @@ mod test {\n         do graph.each_outgoing_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_outgoing.len());\n-            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+            debug2!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_outgoing[counter], edge_index, edge);\n             match expected_outgoing[counter] {\n                 (ref e, ref n) => {"}, {"sha": "b20cb8ed809b95de49c56a6cf29c88b0b9823aab", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -124,13 +124,13 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n-    debug!(\"checking impl with self type %?\", ty::get(self_ty).sty);\n+    debug2!(\"checking impl with self type {:?}\", ty::get(self_ty).sty);\n     do check_builtin_bounds(cx, self_ty, trait_def.bounds) |missing| {\n         cx.tcx.sess.span_err(self_type.span,\n-            fmt!(\"the type `%s', which does not fulfill `%s`, cannot implement this \\\n+            format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n                   trait\", ty_to_str(cx.tcx, self_ty), missing.user_string(cx.tcx)));\n         cx.tcx.sess.span_note(self_type.span,\n-            fmt!(\"types implementing this trait must fulfill `%s`\",\n+            format!(\"types implementing this trait must fulfill `{}`\",\n                  trait_def.bounds.user_string(cx.tcx)));\n     }\n \n@@ -238,7 +238,7 @@ fn with_appropriate_checker(cx: &Context, id: NodeId,\n         }\n         ref s => {\n             cx.tcx.sess.bug(\n-                fmt!(\"expect fn type in kind checker, not %?\", s));\n+                format!(\"expect fn type in kind checker, not {:?}\", s));\n         }\n     }\n }\n@@ -265,7 +265,7 @@ fn check_fn(\n }\n \n pub fn check_expr(cx: &mut Context, e: @Expr) {\n-    debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n+    debug2!(\"kind::check_expr({})\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n     let type_parameter_id = match e.get_callee_id() {\n@@ -292,9 +292,9 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n             };\n             if ts.len() != type_param_defs.len() {\n                 // Fail earlier to make debugging easier\n-                fail!(\"internal error: in kind::check_expr, length \\\n+                fail2!(\"internal error: in kind::check_expr, length \\\n                       mismatch between actual and declared bounds: actual = \\\n-                      %s, declared = %s\",\n+                      {}, declared = {}\",\n                       ts.repr(cx.tcx),\n                       type_param_defs.repr(cx.tcx));\n             }\n@@ -375,8 +375,8 @@ pub fn check_typaram_bounds(cx: &Context,\n     do check_builtin_bounds(cx, ty, type_param_def.bounds.builtin_bounds) |missing| {\n         cx.tcx.sess.span_err(\n             sp,\n-            fmt!(\"instantiating a type parameter with an incompatible type \\\n-                  `%s`, which does not fulfill `%s`\",\n+            format!(\"instantiating a type parameter with an incompatible type \\\n+                  `{}`, which does not fulfill `{}`\",\n                  ty_to_str(cx.tcx, ty),\n                  missing.user_string(cx.tcx)));\n     }\n@@ -390,17 +390,17 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n         // Emit a less mysterious error message in this case.\n         match referenced_ty {\n             Some(rty) => cx.tcx.sess.span_err(sp,\n-                fmt!(\"cannot implicitly borrow variable of type `%s` in a bounded \\\n-                      stack closure (implicit reference does not fulfill `%s`)\",\n+                format!(\"cannot implicitly borrow variable of type `{}` in a bounded \\\n+                      stack closure (implicit reference does not fulfill `{}`)\",\n                      ty_to_str(cx.tcx, rty), missing.user_string(cx.tcx))),\n             None => cx.tcx.sess.span_err(sp,\n-                fmt!(\"cannot capture variable of type `%s`, which does \\\n-                      not fulfill `%s`, in a bounded closure\",\n+                format!(\"cannot capture variable of type `{}`, which does \\\n+                      not fulfill `{}`, in a bounded closure\",\n                      ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx))),\n         }\n         cx.tcx.sess.span_note(\n             sp,\n-            fmt!(\"this closure's environment must satisfy `%s`\",\n+            format!(\"this closure's environment must satisfy `{}`\",\n                  bounds.user_string(cx.tcx)));\n     }\n }\n@@ -409,8 +409,8 @@ pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n         cx.tcx.sess.span_err(sp,\n-            fmt!(\"cannot pack type `%s`, which does not fulfill \\\n-                  `%s`, as a trait bounded by %s\",\n+            format!(\"cannot pack type `{}`, which does not fulfill \\\n+                  `{}`, as a trait bounded by {}\",\n                  ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n                  bounds.user_string(cx.tcx)));\n     }\n@@ -445,27 +445,27 @@ fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n         _ => {\n             cx.tcx.sess.span_bug(\n                 sp,\n-                fmt!(\"unknown def for free variable: %?\", def));\n+                format!(\"unknown def for free variable: {:?}\", def));\n         }\n     }\n }\n \n fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n-    debug!(\"type_contents(%s)=%s\",\n+    debug2!(\"type_contents({})={}\",\n            ty_to_str(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_str());\n     if ty::type_moves_by_default(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n-            sp, fmt!(\"copying a value of non-copyable type `%s`\",\n+            sp, format!(\"copying a value of non-copyable type `{}`\",\n                      ty_to_str(cx.tcx, ty)));\n-        cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason));\n+        cx.tcx.sess.span_note(sp, format!(\"{}\", reason));\n     }\n }\n \n pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_sendable(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n-            sp, fmt!(\"value has non-sendable type `%s`\",\n+            sp, format!(\"value has non-sendable type `{}`\",\n                      ty_to_str(cx.tcx, ty)));\n         false\n     } else {\n@@ -565,8 +565,8 @@ pub fn check_cast_for_escaping_regions(\n             // if !target_regions.iter().any(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n             //         source.span,\n-            //         fmt!(\"source contains borrowed pointer with lifetime \\\n-            //               not found in the target type `%s`\",\n+            //         format!(\"source contains borrowed pointer with lifetime \\\n+            //               not found in the target type `{}`\",\n             //              ty_to_str(cx.tcx, target_ty)));\n             //     note_and_explain_region(\n             //         cx.tcx, \"source data is only valid for \", r, \"\");"}, {"sha": "f154255e7b6f21bf8712ef5335442ba7bc7da487", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -154,7 +154,7 @@ impl LanguageItems {\n     pub fn require(&self, it: LangItem) -> Result<DefId, ~str> {\n         match self.items[it as uint] {\n             Some(id) => Ok(id),\n-            None => Err(fmt!(\"requires `%s` lang_item\",\n+            None => Err(format!(\"requires `{}` lang_item\",\n                              LanguageItems::item_name(it as uint)))\n         }\n     }\n@@ -398,7 +398,7 @@ impl<'self> LanguageItemCollector<'self> {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n-                self.session.err(fmt!(\"duplicate entry for `%s`\",\n+                self.session.err(format!(\"duplicate entry for `{}`\",\n                                       LanguageItems::item_name(item_index)));\n             }\n             Some(_) | None => {"}, {"sha": "591ca2ada5a12c65d56f40beb218413a8fbb424d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -430,7 +430,7 @@ impl Context {\n                 return *k;\n             }\n         }\n-        fail!(\"unregistered lint %?\", lint);\n+        fail2!(\"unregistered lint {:?}\", lint);\n     }\n \n     fn span_lint(&self, lint: lint, span: Span, msg: &str) {\n@@ -444,9 +444,9 @@ impl Context {\n         let mut note = None;\n         let msg = match src {\n             Default | CommandLine => {\n-                fmt!(\"%s [-%c %s%s]\", msg, match level {\n+                format!(\"{} [-{} {}{}]\", msg, match level {\n                         warn => 'W', deny => 'D', forbid => 'F',\n-                        allow => fail!()\n+                        allow => fail2!()\n                     }, self.lint_to_str(lint).replace(\"_\", \"-\"),\n                     if src == Default { \" (default)\" } else { \"\" })\n             },\n@@ -458,7 +458,7 @@ impl Context {\n         match level {\n             warn =>          { self.tcx.sess.span_warn(span, msg); }\n             deny | forbid => { self.tcx.sess.span_err(span, msg);  }\n-            allow => fail!(),\n+            allow => fail2!(),\n         }\n \n         for &span in note.iter() {\n@@ -483,15 +483,15 @@ impl Context {\n                     self.span_lint(\n                         unrecognized_lint,\n                         meta.span,\n-                        fmt!(\"unknown `%s` attribute: `%s`\",\n+                        format!(\"unknown `{}` attribute: `{}`\",\n                         level_to_str(level), lintname));\n                 }\n                 Some(lint) => {\n                     let lint = lint.lint;\n                     let now = self.get_level(lint);\n                     if now == forbid && level != forbid {\n                         self.tcx.sess.span_err(meta.span,\n-                        fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n+                        format!(\"{}({}) overruled by outer forbid({})\",\n                         level_to_str(level),\n                         lintname, lintname));\n                     } else if now != level {\n@@ -757,7 +757,7 @@ impl TypeLimitsLintVisitor {\n             ast::BiGt => v >= min,\n             ast::BiGe => v > min,\n             ast::BiEq | ast::BiNe => v >= min && v <= max,\n-            _ => fail!()\n+            _ => fail2!()\n         }\n     }\n \n@@ -821,7 +821,7 @@ impl TypeLimitsLintVisitor {\n                         ast::lit_int_unsuffixed(v) => v,\n                         _ => return true\n                     },\n-                    _ => fail!()\n+                    _ => fail2!()\n                 };\n                 self.is_valid(norm_binop, lit_val, min, max)\n             }\n@@ -834,7 +834,7 @@ impl TypeLimitsLintVisitor {\n                         ast::lit_int_unsuffixed(v) => v as u64,\n                         _ => return true\n                     },\n-                    _ => fail!()\n+                    _ => fail2!()\n                 };\n                 self.is_valid(norm_binop, lit_val, min, max)\n             }\n@@ -1071,7 +1071,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(\n                 non_camel_case_types, span,\n-                fmt!(\"%s `%s` should have a camel case identifier\",\n+                format!(\"{} `{}` should have a camel case identifier\",\n                     sort, cx.tcx.sess.str_of(ident)));\n         }\n     }\n@@ -1437,7 +1437,7 @@ impl StabilityLintVisitor {\n                         None => return\n                     }\n                 }\n-                _ => cx.tcx.sess.bug(fmt!(\"handle_def: %? not found\", id))\n+                _ => cx.tcx.sess.bug(format!(\"handle_def: {:?} not found\", id))\n             }\n         } else {\n             // cross-crate\n@@ -1466,9 +1466,9 @@ impl StabilityLintVisitor {\n \n         let msg = match stability {\n             Some(attr::Stability { text: Some(ref s), _ }) => {\n-                fmt!(\"use of %s item: %s\", label, *s)\n+                format!(\"use of {} item: {}\", label, *s)\n             }\n-            _ => fmt!(\"use of %s item\", label)\n+            _ => format!(\"use of {} item\", label)\n         };\n \n         cx.span_lint(lint, sp, msg);\n@@ -1613,8 +1613,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: &ast::Crate) {\n         for t in v.iter() {\n             match *t {\n                 (lint, span, ref msg) =>\n-                    tcx.sess.span_bug(span, fmt!(\"unprocessed lint %? at %s: \\\n-                                                  %s\",\n+                    tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: \\\n+                                                  {}\",\n                                                  lint,\n                                                  ast_map::node_id_to_str(\n                                                  tcx.items,"}, {"sha": "e9119e75287a3d96994a5672e60f2435114ea960", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -144,9 +144,9 @@ enum LiveNodeKind {\n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     let cm = cx.sess.codemap;\n     match lnk {\n-        FreeVarNode(s) => fmt!(\"Free var node [%s]\", cm.span_to_str(s)),\n-        ExprNode(s)    => fmt!(\"Expr node [%s]\", cm.span_to_str(s)),\n-        VarDefNode(s)  => fmt!(\"Var def node [%s]\", cm.span_to_str(s)),\n+        FreeVarNode(s) => format!(\"Free var node [{}]\", cm.span_to_str(s)),\n+        ExprNode(s)    => format!(\"Expr node [{}]\", cm.span_to_str(s)),\n+        VarDefNode(s)  => format!(\"Var def node [{}]\", cm.span_to_str(s)),\n         ExitNode       => ~\"Exit node\"\n     }\n }\n@@ -176,11 +176,11 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n impl to_str::ToStr for LiveNode {\n-    fn to_str(&self) -> ~str { fmt!(\"ln(%u)\", **self) }\n+    fn to_str(&self) -> ~str { format!(\"ln({})\", **self) }\n }\n \n impl to_str::ToStr for Variable {\n-    fn to_str(&self) -> ~str { fmt!(\"v(%u)\", **self) }\n+    fn to_str(&self) -> ~str { format!(\"v({})\", **self) }\n }\n \n // ______________________________________________________________________\n@@ -276,7 +276,7 @@ impl IrMaps {\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n \n-        debug!(\"%s is of kind %s\", ln.to_str(),\n+        debug2!(\"{} is of kind {}\", ln.to_str(),\n                live_node_kind_to_str(lnk, self.tcx));\n \n         ln\n@@ -288,7 +288,7 @@ impl IrMaps {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        debug!(\"%s is node %d\", ln.to_str(), node_id);\n+        debug2!(\"{} is node {}\", ln.to_str(), node_id);\n     }\n \n     pub fn add_variable(&mut self, vk: VarKind) -> Variable {\n@@ -303,7 +303,7 @@ impl IrMaps {\n             ImplicitRet => {}\n         }\n \n-        debug!(\"%s is %?\", v.to_str(), vk);\n+        debug2!(\"{} is {:?}\", v.to_str(), vk);\n \n         v\n     }\n@@ -313,7 +313,7 @@ impl IrMaps {\n           Some(&var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n-                span, fmt!(\"No variable registered for id %d\", node_id));\n+                span, format!(\"No variable registered for id {}\", node_id));\n           }\n         }\n     }\n@@ -367,7 +367,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n             sp: Span,\n             id: NodeId,\n             this: @mut IrMaps) {\n-    debug!(\"visit_fn: id=%d\", id);\n+    debug2!(\"visit_fn: id={}\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n@@ -376,13 +376,13 @@ fn visit_fn(v: &mut LivenessVisitor,\n                               this.capture_map);\n \n     unsafe {\n-        debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n+        debug2!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {\n         do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n-            debug!(\"adding argument %d\", arg_id);\n+            debug2!(\"adding argument {}\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n             fn_maps.add_variable(Arg(arg_id, ident));\n         }\n@@ -429,7 +429,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.pat) |_bm, p_id, sp, path| {\n-        debug!(\"adding local variable %d\", p_id);\n+        debug2!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         this.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.init {\n@@ -450,7 +450,7 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n-            debug!(\"adding local variable %d from match with bm %?\",\n+            debug2!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n             this.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -470,7 +470,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) | ExprSelf => {\n         let def = this.tcx.def_map.get_copy(&expr.id);\n-        debug!(\"expr %d: path that leads to %?\", expr.id, def);\n+        debug2!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n@@ -515,7 +515,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n-      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+      ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n       ExprBinary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n@@ -609,7 +609,7 @@ impl Liveness {\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n             self.tcx.sess.span_bug(\n-                span, fmt!(\"No live node registered for node %d\",\n+                span, format!(\"No live node registered for node {}\",\n                            node_id));\n           }\n         }\n@@ -788,7 +788,7 @@ impl Liveness {\n             wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(\") of kind \");\n-            wr.write_str(fmt!(\"%?\", self.ir.lnks[*ln]));\n+            wr.write_str(format!(\"{:?}\", self.ir.lnks[*ln]));\n             wr.write_str(\" reads\");\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             wr.write_str(\"  writes\");\n@@ -819,7 +819,7 @@ impl Liveness {\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             self.users[idx] = self.users[succ_idx]\n         });\n-        debug!(\"init_from_succ(ln=%s, succ=%s)\",\n+        debug2!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n@@ -843,7 +843,7 @@ impl Liveness {\n             }\n         }\n \n-        debug!(\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n+        debug2!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n@@ -866,7 +866,7 @@ impl Liveness {\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n \n-        debug!(\"%s defines %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n+        debug2!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n     }\n \n@@ -891,7 +891,7 @@ impl Liveness {\n             user.used = true;\n         }\n \n-        debug!(\"%s accesses[%x] %s: %s\",\n+        debug2!(\"{} accesses[{:x}] {}: {}\",\n                ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n     }\n \n@@ -902,18 +902,18 @@ impl Liveness {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for block, %s\", block_to_str(body,\n+        debug2!(\"compute: using id for block, {}\", block_to_str(body,\n                       self.tcx.sess.intr()));\n \n         let entry_ln: LiveNode =\n             self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n               || { self.propagate_through_fn_block(decl, body) });\n \n-        // hack to skip the loop unless debug! is enabled:\n-        debug!(\"^^ liveness computation results for body %d (entry=%s)\",\n+        // hack to skip the loop unless debug2! is enabled:\n+        debug2!(\"^^ liveness computation results for body {} (entry={})\",\n                {\n                    for ln_idx in range(0u, self.ir.num_live_nodes) {\n-                       debug!(\"%s\", self.ln_str(LiveNode(ln_idx)));\n+                       debug2!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n                },\n@@ -1007,7 +1007,7 @@ impl Liveness {\n \n     pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n                                   -> LiveNode {\n-        debug!(\"propagate_through_expr: %s\",\n+        debug2!(\"propagate_through_expr: {}\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n         match expr.node {\n@@ -1022,7 +1022,7 @@ impl Liveness {\n           }\n \n           ExprFnBlock(_, ref blk) => {\n-              debug!(\"%s is an expr_fn_block\",\n+              debug2!(\"{} is an expr_fn_block\",\n                    expr_to_str(expr, self.tcx.sess.intr()));\n \n               /*\n@@ -1070,7 +1070,7 @@ impl Liveness {\n             self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n-          ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+          ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n@@ -1379,7 +1379,7 @@ impl Liveness {\n             self.merge_from_succ(ln, succ, first_merge);\n             first_merge = false;\n         }\n-        debug!(\"propagate_through_loop: using id for loop body %d %s\",\n+        debug2!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, block_to_str(body, self.tcx.sess.intr()));\n \n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n@@ -1407,7 +1407,7 @@ impl Liveness {\n                               cont_ln: LiveNode,\n                               f: &fn() -> R)\n                               -> R {\n-      debug!(\"with_loop_nodes: %d %u\", loop_node_id, *break_ln);\n+      debug2!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);\n         self.cont_ln.insert(loop_node_id, cont_ln);\n@@ -1430,7 +1430,7 @@ fn check_local(this: &mut Liveness, local: @Local) {\n         // No initializer: the variable might be unused; if not, it\n         // should not be live at this point.\n \n-        debug!(\"check_local() with no initializer\");\n+        debug2!(\"check_local() with no initializer\");\n         do this.pat_bindings(local.pat) |ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 match this.live_on_exit(ln, var) {\n@@ -1501,7 +1501,7 @@ fn check_expr(this: &mut Liveness, expr: @Expr) {\n       ExprParen(*) | ExprFnBlock(*) | ExprPath(*) | ExprSelf(*) => {\n         visit::walk_expr(this, expr, ());\n       }\n-      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n+      ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\")\n     }\n }\n \n@@ -1596,17 +1596,17 @@ impl Liveness {\n           FreeVarNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"capture of %s: `%s`\", msg, name));\n+                format!(\"capture of {}: `{}`\", msg, name));\n           }\n           ExprNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"use of %s: `%s`\", msg, name));\n+                format!(\"use of {}: `{}`\", msg, name));\n           }\n           ExitNode | VarDefNode(_) => {\n             self.tcx.sess.span_bug(\n                 chk_span,\n-                fmt!(\"illegal reader: %?\", lnk));\n+                format!(\"illegal reader: {:?}\", lnk));\n           }\n         }\n     }\n@@ -1655,11 +1655,11 @@ impl Liveness {\n \n                 if is_assigned {\n                     self.tcx.sess.add_lint(unused_variable, id, sp,\n-                        fmt!(\"variable `%s` is assigned to, \\\n+                        format!(\"variable `{}` is assigned to, \\\n                                   but never used\", *name));\n                 } else {\n                     self.tcx.sess.add_lint(unused_variable, id, sp,\n-                        fmt!(\"unused variable: `%s`\", *name));\n+                        format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n             true\n@@ -1677,7 +1677,7 @@ impl Liveness {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n                 self.tcx.sess.add_lint(dead_assignment, id, sp,\n-                    fmt!(\"value assigned to `%s` is never read\", *name));\n+                    format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }\n     }"}, {"sha": "19be4d041edfd308e31ab7ea33247c1c5fd69311", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -214,7 +214,7 @@ pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n       Some(k) => k,\n       None => {\n         tcx.sess.bug(\n-            fmt!(\"deref_cat() invoked on non-derefable type %s\",\n+            format!(\"deref_cat() invoked on non-derefable type {}\",\n                  ty_to_str(tcx, t)));\n       }\n     }\n@@ -288,7 +288,7 @@ pub struct mem_categorization_ctxt {\n \n impl ToStr for MutabilityCategory {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -383,7 +383,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: @ast::Expr) -> cmt {\n-        debug!(\"cat_expr: id=%d expr=%s\",\n+        debug2!(\"cat_expr: id={} expr={}\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n         let expr_ty = self.expr_ty(expr);\n@@ -436,7 +436,7 @@ impl mem_categorization_ctxt {\n             return self.cat_rvalue_node(expr, expr_ty);\n           }\n \n-          ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n+          ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n@@ -544,7 +544,7 @@ impl mem_categorization_ctxt {\n                   _ => {\n                       self.tcx.sess.span_bug(\n                           span,\n-                          fmt!(\"Upvar of non-closure %? - %s\",\n+                          format!(\"Upvar of non-closure {:?} - {}\",\n                                fn_node_id, ty.repr(self.tcx)));\n                   }\n               }\n@@ -651,7 +651,7 @@ impl mem_categorization_ctxt {\n             None => {\n                 self.tcx.sess.span_bug(\n                     node.span(),\n-                    fmt!(\"Explicit deref of non-derefable type: %s\",\n+                    format!(\"Explicit deref of non-derefable type: {}\",\n                          ty_to_str(self.tcx, base_cmt.ty)));\n             }\n         };\n@@ -741,7 +741,7 @@ impl mem_categorization_ctxt {\n           None => {\n             self.tcx.sess.span_bug(\n                 elt.span(),\n-                fmt!(\"Explicit index of non-index type `%s`\",\n+                format!(\"Explicit index of non-index type `{}`\",\n                      ty_to_str(self.tcx, base_cmt.ty)));\n           }\n         };\n@@ -872,7 +872,7 @@ impl mem_categorization_ctxt {\n         // get the type of the *subpattern* and use that.\n \n         let tcx = self.tcx;\n-        debug!(\"cat_pattern: id=%d pat=%s cmt=%s\",\n+        debug2!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                cmt.repr(tcx));\n         let _i = indenter();\n@@ -1020,7 +1020,7 @@ impl mem_categorization_ctxt {\n               ~\"argument\"\n           }\n           cat_deref(_, _, pk) => {\n-              fmt!(\"dereference of %s pointer\", ptr_sigil(pk))\n+              format!(\"dereference of {} pointer\", ptr_sigil(pk))\n           }\n           cat_interior(_, InteriorField(NamedField(_))) => {\n               ~\"field\"\n@@ -1177,7 +1177,7 @@ impl cmt_ {\n \n impl Repr for cmt_ {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"{%s id:%d m:%? ty:%s}\",\n+        format!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n              self.cat.repr(tcx),\n              self.id,\n              self.mutbl,\n@@ -1194,19 +1194,19 @@ impl Repr for categorization {\n             cat_local(*) |\n             cat_self(*) |\n             cat_arg(*) => {\n-                fmt!(\"%?\", *self)\n+                format!(\"{:?}\", *self)\n             }\n             cat_deref(cmt, derefs, ptr) => {\n-                fmt!(\"%s->(%s, %u)\", cmt.cat.repr(tcx),\n+                format!(\"{}->({}, {})\", cmt.cat.repr(tcx),\n                      ptr_sigil(ptr), derefs)\n             }\n             cat_interior(cmt, interior) => {\n-                fmt!(\"%s.%s\",\n+                format!(\"{}.{}\",\n                      cmt.cat.repr(tcx),\n                      interior.repr(tcx))\n             }\n             cat_downcast(cmt) => {\n-                fmt!(\"%s->(enum)\", cmt.cat.repr(tcx))\n+                format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n             cat_stack_upvar(cmt) |\n             cat_discr(cmt, _) => {\n@@ -1229,7 +1229,7 @@ impl Repr for InteriorKind {\n     fn repr(&self, _tcx: ty::ctxt) -> ~str {\n         match *self {\n             InteriorField(NamedField(fld)) => token::interner_get(fld).to_owned(),\n-            InteriorField(PositionalField(i)) => fmt!(\"#%?\", i),\n+            InteriorField(PositionalField(i)) => format!(\"\\\\#{:?}\", i),\n             InteriorElement(_) => ~\"[]\",\n         }\n     }"}, {"sha": "71d0621fc16aefdd8e40390bc5682d2f30833efb", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -275,7 +275,7 @@ impl VisitContext {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"consume_expr(expr=%s)\",\n+        debug2!(\"consume_expr(expr={})\",\n                expr.repr(self.tcx));\n \n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n@@ -293,7 +293,7 @@ impl VisitContext {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"consume_block(blk.id=%?)\", blk.id);\n+        debug2!(\"consume_block(blk.id={:?})\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n             self.visit_stmt(*stmt, ());\n@@ -312,7 +312,7 @@ impl VisitContext {\n          * in turn trigger calls to the subcomponents of `expr`.\n          */\n \n-        debug!(\"use_expr(expr=%s, mode=%?)\",\n+        debug2!(\"use_expr(expr={}, mode={:?})\",\n                expr.repr(self.tcx),\n                expr_mode);\n \n@@ -326,7 +326,7 @@ impl VisitContext {\n             _ => expr_mode\n         };\n \n-        debug!(\"comp_mode = %?\", comp_mode);\n+        debug2!(\"comp_mode = {:?}\", comp_mode);\n \n         match expr.node {\n             ExprPath(*) | ExprSelf => {\n@@ -375,7 +375,7 @@ impl VisitContext {\n                     ty::ty_bare_fn(*) => Read,\n                     ref x =>\n                         self.tcx.sess.span_bug(callee.span,\n-                            fmt!(\"non-function type in moves for expr_call: %?\", x)),\n+                            format!(\"non-function type in moves for expr_call: {:?}\", x)),\n                 };\n                 // Note we're not using consume_expr, which uses type_moves_by_default\n                 // to determine the mode, for this. The reason is that while stack\n@@ -411,7 +411,7 @@ impl VisitContext {\n                         ref r => {\n                            self.tcx.sess.span_bug(\n                                 with_expr.span,\n-                                fmt!(\"bad base expr type in record: %?\", r))\n+                                format!(\"bad base expr type in record: {:?}\", r))\n                         }\n                     };\n \n@@ -435,7 +435,7 @@ impl VisitContext {\n                     if consume_with {\n                         if has_dtor(self.tcx, with_ty) {\n                             self.tcx.sess.span_err(with_expr.span,\n-                                                   fmt!(\"cannot move out of type `%s`, \\\n+                                                   format!(\"cannot move out of type `{}`, \\\n                                                          which defines the `Drop` trait\",\n                                                         with_ty.user_string(self.tcx)));\n                         }\n@@ -500,7 +500,7 @@ impl VisitContext {\n                 self.consume_block(blk);\n             }\n \n-            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, _, lhs) => {\n                 if !self.use_overloaded_operator(expr, lhs, [])\n@@ -620,15 +620,15 @@ impl VisitContext {\n                 BindByRef(_) => false,\n                 BindInfer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    debug!(\"pattern %? %s type is %s\",\n+                    debug2!(\"pattern {:?} {} type is {}\",\n                            id,\n                            ast_util::path_to_ident(path).repr(self.tcx),\n                            pat_ty.repr(self.tcx));\n                     ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };\n \n-            debug!(\"pattern binding %?: bm=%?, binding_moves=%b\",\n+            debug2!(\"pattern binding {:?}: bm={:?}, binding_moves={}\",\n                    id, bm, binding_moves);\n \n             if binding_moves {\n@@ -678,7 +678,7 @@ impl VisitContext {\n     }\n \n     pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> @[CaptureVar] {\n-        debug!(\"compute_capture_vars(fn_expr_id=%?)\", fn_expr_id);\n+        debug2!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n@@ -696,7 +696,7 @@ impl VisitContext {\n                 let fvar = &freevars[i];\n                 let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n                 let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                debug!(\"fvar_def_id=%? fvar_ty=%s\",\n+                debug2!(\"fvar_def_id={:?} fvar_ty={}\",\n                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n                 let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n                     CapMove"}, {"sha": "8b2e581836bd817171cf947e35c3755d3dffea13", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -111,8 +111,8 @@ impl PrivacyVisitor {\n             // WRONG\n             Public\n         };\n-        debug!(\"parental_privacy = %?\", parental_privacy);\n-        debug!(\"vis = %?, priv = %?\",\n+        debug2!(\"parental_privacy = {:?}\", parental_privacy);\n+        debug2!(\"vis = {:?}, priv = {:?}\",\n                variant_info.vis,\n                visibility_to_privacy(variant_info.vis))\n         // inherited => privacy of the enum item\n@@ -175,7 +175,7 @@ impl PrivacyVisitor {\n             }\n             Some(_) => {\n                 self.tcx.sess.span_bug(span,\n-                                  fmt!(\"method_is_private: method was a %s?!\",\n+                                  format!(\"method_is_private: method was a {}?!\",\n                                        ast_map::node_id_to_str(\n                                             self.tcx.items,\n                                             method_id,\n@@ -205,8 +205,8 @@ impl PrivacyVisitor {\n                 Some(&node_trait_method(_, trait_did, _)) => f(trait_did.node),\n                 Some(_) => {\n                     self.tcx.sess.span_bug(span,\n-                                      fmt!(\"local_item_is_private: item was \\\n-                                            a %s?!\",\n+                                      format!(\"local_item_is_private: item was \\\n+                                            a {}?!\",\n                                            ast_map::node_id_to_str(\n                                                 self.tcx.items,\n                                                 item_id,\n@@ -227,7 +227,7 @@ impl PrivacyVisitor {\n         for field in fields.iter() {\n             if field.name != ident.name { loop; }\n             if field.vis == private {\n-                self.tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n+                self.tcx.sess.span_err(span, format!(\"field `{}` is private\",\n                                              token::ident_to_str(&ident)));\n             }\n             break;\n@@ -248,26 +248,26 @@ impl PrivacyVisitor {\n                     (container_id.crate != LOCAL_CRATE ||\n                      !self.privileged_items.iter().any(|x| x == &(container_id.node))) {\n                 self.tcx.sess.span_err(span,\n-                                  fmt!(\"method `%s` is private\",\n+                                  format!(\"method `{}` is private\",\n                                        token::ident_to_str(name)));\n             }\n         } else {\n             let visibility =\n                 csearch::get_item_visibility(self.tcx.sess.cstore, method_id);\n             if visibility != public {\n                 self.tcx.sess.span_err(span,\n-                                  fmt!(\"method `%s` is private\",\n+                                  format!(\"method `{}` is private\",\n                                        token::ident_to_str(name)));\n             }\n         }\n     }\n \n     // Checks that a private path is in scope.\n     fn check_path(&mut self, span: Span, def: Def, path: &Path) {\n-        debug!(\"checking path\");\n+        debug2!(\"checking path\");\n         match def {\n             DefStaticMethod(method_id, _, _) => {\n-                debug!(\"found static method def, checking it\");\n+                debug2!(\"found static method def, checking it\");\n                 self.check_method_common(span,\n                                          method_id,\n                                          &path.segments.last().identifier)\n@@ -277,7 +277,7 @@ impl PrivacyVisitor {\n                     if self.local_item_is_private(span, def_id.node) &&\n                             !self.privileged_items.iter().any(|x| x == &def_id.node) {\n                         self.tcx.sess.span_err(span,\n-                                          fmt!(\"function `%s` is private\",\n+                                          format!(\"function `{}` is private\",\n                                                token::ident_to_str(\n                                                 &path.segments\n                                                      .last()\n@@ -286,7 +286,7 @@ impl PrivacyVisitor {\n                 //} else if csearch::get_item_visibility(self.tcx.sess.cstore,\n                 //                                       def_id) != public {\n                 //    self.tcx.sess.span_err(span,\n-                //                      fmt!(\"function `%s` is private\",\n+                //                      format!(\"function `{}` is private\",\n                 //                           token::ident_to_str(\n                 //                                &path.segments\n                 //                                     .last()\n@@ -333,7 +333,7 @@ impl PrivacyVisitor {\n                                              !self.privileged_items.iter()\n                                              .any(|x| x == &(trait_id.node)) => {\n                                             self.tcx.sess.span_err(span,\n-                                                              fmt!(\"method `%s` is private\",\n+                                                              format!(\"method `{}` is private\",\n                                                                    token::ident_to_str(&method\n                                                                                         .ident)));\n                                         }\n@@ -476,7 +476,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                         ty_struct(id, _)\n                         if id.crate != LOCAL_CRATE || !self.privileged_items.iter()\n                                 .any(|x| x == &(id.node)) => {\n-                            debug!(\"(privacy checking) checking field access\");\n+                            debug2!(\"(privacy checking) checking field access\");\n                             self.check_field(expr.span, id, ident);\n                         }\n                         _ => {}\n@@ -497,7 +497,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                                                        method map\");\n                                 }\n                                 Some(ref entry) => {\n-                                    debug!(\"(privacy checking) checking \\\n+                                    debug2!(\"(privacy checking) checking \\\n                                             impl method\");\n                                     self.check_method(expr.span, &entry.origin, ident);\n                                 }\n@@ -515,7 +515,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                             if id.crate != LOCAL_CRATE ||\n                                     !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in (*fields).iter() {\n-                                        debug!(\"(privacy checking) checking \\\n+                                        debug2!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n                                     self.check_field(expr.span, id, field.ident);\n                                 }\n@@ -527,7 +527,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                                 match self.tcx.def_map.get_copy(&expr.id) {\n                                     DefVariant(_, variant_id, _) => {\n                                         for field in (*fields).iter() {\n-                                                debug!(\"(privacy checking) \\\n+                                                debug2!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n                                                         literal\");\n@@ -582,7 +582,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                             if id.crate != LOCAL_CRATE ||\n                                     !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in fields.iter() {\n-                                        debug!(\"(privacy checking) checking \\\n+                                        debug2!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n                                     self.check_field(pattern.span, id, field.ident);\n                                 }\n@@ -594,7 +594,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                                 match self.tcx.def_map.find(&pattern.id) {\n                                     Some(&DefVariant(_, variant_id, _)) => {\n                                         for field in fields.iter() {\n-                                            debug!(\"(privacy checking) \\\n+                                            debug2!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");\n                                             self.check_field(pattern.span, variant_id, field.ident);"}, {"sha": "6973b46c92c47c58d79e4d5898520392efe0c406", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -400,14 +400,14 @@ impl ReachableContext {\n                     let desc = ast_map::node_id_to_str(self.tcx.items,\n                                                        search_item,\n                                                        ident_interner);\n-                    self.tcx.sess.bug(fmt!(\"found unexpected thingy in \\\n-                                            worklist: %s\",\n-                                            desc))\n+                    self.tcx.sess.bug(format!(\"found unexpected thingy in \\\n+                                               worklist: {}\",\n+                                               desc))\n                 }\n                 None => {\n-                    self.tcx.sess.bug(fmt!(\"found unmapped ID in worklist: \\\n-                                            %d\",\n-                                           search_item))\n+                    self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n+                                               {}\",\n+                                              search_item))\n                 }\n             }\n         }"}, {"sha": "0afcf87817ab53d0988050d2983102305c3a7bba", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -93,13 +93,13 @@ impl RegionMaps {\n             None => {}\n         }\n \n-        debug!(\"relate_free_regions(sub=%?, sup=%?)\", sub, sup);\n+        debug2!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n \n         self.free_region_map.insert(sub, ~[sup]);\n     }\n \n     pub fn record_parent(&mut self, sub: ast::NodeId, sup: ast::NodeId) {\n-        debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n+        debug2!(\"record_parent(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n \n         self.scope_map.insert(sub, sup);\n@@ -125,7 +125,7 @@ impl RegionMaps {\n \n         match self.scope_map.find(&id) {\n             Some(&r) => r,\n-            None => { fail!(\"No enclosing scope for id %?\", id); }\n+            None => { fail2!(\"No enclosing scope for id {:?}\", id); }\n         }\n     }\n \n@@ -168,7 +168,7 @@ impl RegionMaps {\n         while superscope != s {\n             match self.scope_map.find(&s) {\n                 None => {\n-                    debug!(\"is_subscope_of(%?, %?, s=%?)=false\",\n+                    debug2!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n \n                     return false;\n@@ -177,7 +177,7 @@ impl RegionMaps {\n             }\n         }\n \n-        debug!(\"is_subscope_of(%?, %?)=true\",\n+        debug2!(\"is_subscope_of({:?}, {:?})=true\",\n                subscope, superscope);\n \n         return true;\n@@ -231,7 +231,7 @@ impl RegionMaps {\n          * duplicated with the code in infer.rs.\n          */\n \n-        debug!(\"is_subregion_of(sub_region=%?, super_region=%?)\",\n+        debug2!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n                sub_region, super_region);\n \n         sub_region == super_region || {\n@@ -303,7 +303,7 @@ impl RegionMaps {\n         fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)\n             -> ~[ast::NodeId]\n         {\n-            // debug!(\"ancestors_of(scope=%d)\", scope);\n+            // debug2!(\"ancestors_of(scope={})\", scope);\n             let mut result = ~[scope];\n             let mut scope = scope;\n             loop {\n@@ -314,7 +314,7 @@ impl RegionMaps {\n                         scope = superscope;\n                     }\n                 }\n-                // debug!(\"ancestors_of_loop(scope=%d)\", scope);\n+                // debug2!(\"ancestors_of_loop(scope={})\", scope);\n             }\n         }\n     }\n@@ -323,7 +323,7 @@ impl RegionMaps {\n /// Records the current parent (if any) as the parent of `child_id`.\n fn parent_to_expr(visitor: &mut RegionResolutionVisitor,\n                   cx: Context, child_id: ast::NodeId, sp: Span) {\n-    debug!(\"region::parent_to_expr(span=%?)\",\n+    debug2!(\"region::parent_to_expr(span={:?})\",\n            visitor.sess.codemap.span_to_str(sp));\n     for parent_id in cx.parent.iter() {\n         visitor.region_maps.record_parent(child_id, *parent_id);\n@@ -437,10 +437,10 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               sp: Span,\n               id: ast::NodeId,\n               cx: Context) {\n-    debug!(\"region::resolve_fn(id=%?, \\\n-                               span=%?, \\\n-                               body.id=%?, \\\n-                               cx.parent=%?)\",\n+    debug2!(\"region::resolve_fn(id={:?}, \\\n+                               span={:?}, \\\n+                               body.id={:?}, \\\n+                               cx.parent={:?})\",\n            id,\n            visitor.sess.codemap.span_to_str(sp),\n            body.id,\n@@ -619,7 +619,7 @@ impl DetermineRpCtxt {\n           Some(v) => join_variance(v, variance)\n         };\n \n-        debug!(\"add_rp() variance for %s: %? == %? ^ %?\",\n+        debug2!(\"add_rp() variance for {}: {:?} == {:?} ^ {:?}\",\n                ast_map::node_id_to_str(self.ast_map, id,\n                                        token::get_ident_interner()),\n                joined_variance, old_variance, variance);\n@@ -637,7 +637,7 @@ impl DetermineRpCtxt {\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n     pub fn add_dep(&mut self, from: ast::NodeId) {\n-        debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n+        debug2!(\"add dependency from {} -> {} ({} -> {}) with variance {:?}\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n                                        token::get_ident_interner()),\n@@ -715,7 +715,7 @@ impl DetermineRpCtxt {\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        debug!(\"with_item_id(%d, %b)\",\n+        debug2!(\"with_item_id({}, {})\",\n                item_id,\n                anon_implies_rp);\n         let _i = ::util::common::indenter();\n@@ -787,7 +787,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n     let sess = cx.sess;\n     match ty.node {\n         ast::ty_rptr(ref r, _) => {\n-            debug!(\"referenced rptr type %s\",\n+            debug2!(\"referenced rptr type {}\",\n                    pprust::ty_to_str(ty, sess.intr()));\n \n             if cx.region_is_relevant(r) {\n@@ -797,7 +797,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n         }\n \n         ast::ty_closure(ref f) => {\n-            debug!(\"referenced fn type: %s\",\n+            debug2!(\"referenced fn type: {}\",\n                    pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n                 Some(_) => {\n@@ -837,7 +837,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n                 match csearch::get_region_param(cstore, did) {\n                   None => {}\n                   Some(variance) => {\n-                    debug!(\"reference to external, rp'd type %s\",\n+                    debug2!(\"reference to external, rp'd type {}\",\n                            pprust::ty_to_str(ty, sess.intr()));\n                     if cx.region_is_relevant(&path.segments.last().lifetime) {\n                         let rv = cx.add_variance(variance);\n@@ -967,7 +967,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         while cx.worklist.len() != 0 {\n             let c_id = cx.worklist.pop();\n             let c_variance = cx.region_paramd_items.get_copy(&c_id);\n-            debug!(\"popped %d from worklist\", c_id);\n+            debug2!(\"popped {} from worklist\", c_id);\n             match cx.dep_map.find(&c_id) {\n               None => {}\n               Some(deps) => {\n@@ -980,11 +980,11 @@ pub fn determine_rp_in_crate(sess: Session,\n         }\n     }\n \n-    debug!(\"%s\", {\n-        debug!(\"Region variance results:\");\n+    debug2!(\"{}\", {\n+        debug2!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n         for (&key, &value) in region_paramd_items.iter() {\n-            debug!(\"item %? (%s) is parameterized with variance %?\",\n+            debug2!(\"item {:?} ({}) is parameterized with variance {:?}\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,\n                                            token::get_ident_interner()),"}, {"sha": "4b5141f1630e0f7f440ad60984c942c3711d29a5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 210, "deletions": 206, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -646,7 +646,7 @@ impl NameBindings {\n     pub fn get_module(&mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n-                fail!(\"get_module called on a node with no module \\\n+                fail2!(\"get_module called on a node with no module \\\n                        definition!\")\n             }\n             Some(module_def) => module_def\n@@ -1096,14 +1096,14 @@ impl Resolver {\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n                     self.resolve_error(sp,\n-                        fmt!(\"duplicate definition of %s `%s`\",\n+                        format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_str(duplicate_type),\n                              self.session.str_of(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n-                                 fmt!(\"first definition of %s `%s` here\",\n+                                 format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_str(duplicate_type),\n                                       self.session.str_of(name)));\n                         }\n@@ -1427,7 +1427,7 @@ impl Resolver {\n                     }\n                     match self.method_map.find_mut(name) {\n                         Some(s) => { s.insert(def_id); },\n-                        _ => fail!(\"Can't happen\"),\n+                        _ => fail2!(\"Can't happen\"),\n                     }\n                 }\n \n@@ -1436,7 +1436,7 @@ impl Resolver {\n             }\n \n             item_mac(*) => {\n-                fail!(\"item macros unimplemented\")\n+                fail2!(\"item macros unimplemented\")\n             }\n         }\n     }\n@@ -1620,8 +1620,8 @@ impl Resolver {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n-            debug!(\"(building reduced graph for block) creating a new \\\n-                    anonymous module for block %d\",\n+            debug2!(\"(building reduced graph for block) creating a new \\\n+                    anonymous module for block {}\",\n                    block_id);\n \n             let parent_module = self.get_module_from_parent(parent);\n@@ -1645,22 +1645,22 @@ impl Resolver {\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n-        debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv %?\",\n+        debug2!(\"(building reduced graph for \\\n+                external crate) building external def, priv {:?}\",\n                privacy);\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n           DefTy(def_id) => {\n             match child_name_bindings.type_def {\n               Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n-                debug!(\"(building reduced graph for external crate) \\\n+                debug2!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n               }\n               Some(_) | None => {\n-                debug!(\"(building reduced graph for \\\n+                debug2!(\"(building reduced graph for \\\n                         external crate) building module \\\n-                        %s\", final_ident);\n+                        {}\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n \n                 child_name_bindings.define_module(privacy,\n@@ -1678,8 +1678,8 @@ impl Resolver {\n         match def {\n           DefMod(_) | DefForeignMod(_) => {}\n           DefVariant(_, variant_id, is_struct) => {\n-            debug!(\"(building reduced graph for external crate) building \\\n-                    variant %s\",\n+            debug2!(\"(building reduced graph for external crate) building \\\n+                    variant {}\",\n                    final_ident);\n             // We assume the parent is visible, or else we wouldn't have seen\n             // it.\n@@ -1693,13 +1693,13 @@ impl Resolver {\n             }\n           }\n           DefFn(*) | DefStaticMethod(*) | DefStatic(*) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building value (fn/static) %s\", final_ident);\n+            debug2!(\"(building reduced graph for external \\\n+                    crate) building value (fn/static) {}\", final_ident);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n           }\n           DefTrait(def_id) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type %s\", final_ident);\n+              debug2!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n \n               // If this is a trait, add all the method names\n               // to the trait info.\n@@ -1712,9 +1712,9 @@ impl Resolver {\n                       get_method_name_and_explicit_self(self.session.cstore,\n                                                         method_def_id);\n \n-                  debug!(\"(building reduced graph for \\\n+                  debug2!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n-                          trait method '%s'\",\n+                          trait method '{}'\",\n                          self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n@@ -1728,7 +1728,7 @@ impl Resolver {\n                   }\n                   match self.method_map.find_mut(name) {\n                       Some(s) => { s.insert(def_id); },\n-                      _ => fail!(\"Can't happen\"),\n+                      _ => fail2!(\"Can't happen\"),\n                   }\n               }\n \n@@ -1744,14 +1744,14 @@ impl Resolver {\n                                                   dummy_sp())\n           }\n           DefTy(_) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type %s\", final_ident);\n+              debug2!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n \n               child_name_bindings.define_type(privacy, def, dummy_sp());\n           }\n           DefStruct(def_id) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building type and value for %s\",\n+            debug2!(\"(building reduced graph for external \\\n+                    crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(privacy, def, dummy_sp());\n             if get_struct_fields(self.session.cstore, def_id).len() == 0 {\n@@ -1766,7 +1766,7 @@ impl Resolver {\n           DefPrimTy(*) | DefTyParam(*) | DefBinding(*) |\n           DefUse(*) | DefUpvar(*) | DefRegion(*) |\n           DefTyParamBinder(*) | DefLabel(*) | DefSelfTy(*) => {\n-            fail!(\"didn't expect `%?`\", def);\n+            fail2!(\"didn't expect `{:?}`\", def);\n           }\n         }\n     }\n@@ -1821,9 +1821,9 @@ impl Resolver {\n                         match static_methods_opt {\n                             Some(ref static_methods) if\n                                 static_methods.len() >= 1 => {\n-                                debug!(\"(building reduced graph for \\\n+                                debug2!(\"(building reduced graph for \\\n                                         external crate) processing \\\n-                                        static methods for type name %s\",\n+                                        static methods for type name {}\",\n                                         self.session.str_of(\n                                             final_ident));\n \n@@ -1873,9 +1873,9 @@ impl Resolver {\n                                 for static_method_info in\n                                         static_methods.iter() {\n                                     let ident = static_method_info.ident;\n-                                    debug!(\"(building reduced graph for \\\n+                                    debug2!(\"(building reduced graph for \\\n                                              external crate) creating \\\n-                                             static method '%s'\",\n+                                             static method '{}'\",\n                                            self.session.str_of(ident));\n \n                                     let (method_name_bindings, _) =\n@@ -1901,28 +1901,28 @@ impl Resolver {\n                 }\n             }\n             DlField => {\n-                debug!(\"(building reduced graph for external crate) \\\n+                debug2!(\"(building reduced graph for external crate) \\\n                         ignoring field\");\n             }\n         }\n     }\n \n     /// Builds the reduced graph rooted at the given external module.\n     fn populate_external_module(&mut self, module: @mut Module) {\n-        debug!(\"(populating external module) attempting to populate %s\",\n+        debug2!(\"(populating external module) attempting to populate {}\",\n                self.module_to_str(module));\n \n         let def_id = match module.def_id {\n             None => {\n-                debug!(\"(populating external module) ... no def ID!\");\n+                debug2!(\"(populating external module) ... no def ID!\");\n                 return\n             }\n             Some(def_id) => def_id,\n         };\n \n         do csearch::each_child_of_item(self.session.cstore, def_id)\n                 |def_like, child_ident, visibility| {\n-            debug!(\"(populating external module) ... found ident: %s\",\n+            debug2!(\"(populating external module) ... found ident: {}\",\n                    token::ident_to_str(&child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n@@ -1972,15 +1972,15 @@ impl Resolver {\n \n         match *subclass {\n             SingleImport(target, _) => {\n-                debug!(\"(building import directive) building import \\\n-                        directive: privacy %? %s::%s\",\n+                debug2!(\"(building import directive) building import \\\n+                        directive: privacy {:?} {}::{}\",\n                        privacy,\n                        self.idents_to_str(directive.module_path),\n                        self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target.name) {\n                     Some(&resolution) => {\n-                        debug!(\"(building import directive) bumping \\\n+                        debug2!(\"(building import directive) bumping \\\n                                 reference\");\n                         resolution.outstanding_references += 1;\n \n@@ -1990,7 +1990,7 @@ impl Resolver {\n                         resolution.value_id = id;\n                     }\n                     None => {\n-                        debug!(\"(building import directive) creating new\");\n+                        debug2!(\"(building import directive) creating new\");\n                         let resolution = @mut ImportResolution::new(privacy, id);\n                         resolution.outstanding_references = 1;\n                         module_.import_resolutions.insert(target.name, resolution);\n@@ -2022,14 +2022,14 @@ impl Resolver {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n-            debug!(\"(resolving imports) iteration %u, %u imports left\",\n+            debug2!(\"(resolving imports) iteration {}, {} imports left\",\n                    i, self.unresolved_imports);\n \n             let module_root = self.graph_root.get_module();\n             self.resolve_imports_for_module_subtree(module_root);\n \n             if self.unresolved_imports == 0 {\n-                debug!(\"(resolving imports) success\");\n+                debug2!(\"(resolving imports) success\");\n                 break;\n             }\n \n@@ -2047,7 +2047,7 @@ impl Resolver {\n     /// submodules.\n     pub fn resolve_imports_for_module_subtree(&mut self,\n                                               module_: @mut Module) {\n-        debug!(\"(resolving imports for module subtree) resolving %s\",\n+        debug2!(\"(resolving imports for module subtree) resolving {}\",\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n@@ -2071,8 +2071,8 @@ impl Resolver {\n     /// Attempts to resolve imports for the given module only.\n     pub fn resolve_imports_for_module(&mut self, module: @mut Module) {\n         if module.all_imports_resolved() {\n-            debug!(\"(resolving imports for module) all imports resolved for \\\n-                   %s\",\n+            debug2!(\"(resolving imports for module) all imports resolved for \\\n+                   {}\",\n                    self.module_to_str(module));\n             return;\n         }\n@@ -2085,7 +2085,7 @@ impl Resolver {\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n-                    let msg = fmt!(\"failed to resolve import `%s`\",\n+                    let msg = format!(\"failed to resolve import `{}`\",\n                                    self.import_path_to_str(\n                                        import_directive.module_path,\n                                        *import_directive.subclass));\n@@ -2142,7 +2142,7 @@ impl Resolver {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n-            (fmt!(\"%s::%s\",\n+            (format!(\"{}::{}\",\n                   self.idents_to_str(idents),\n                   self.import_directive_subclass_to_str(subclass))).to_managed()\n         }\n@@ -2160,8 +2160,8 @@ impl Resolver {\n         let mut resolution_result = Failed;\n         let module_path = &import_directive.module_path;\n \n-        debug!(\"(resolving import for module) resolving import `%s::...` in \\\n-                `%s`\",\n+        debug2!(\"(resolving import for module) resolving import `{}::...` in \\\n+                `{}`\",\n                self.idents_to_str(*module_path),\n                self.module_to_str(module_));\n \n@@ -2263,8 +2263,8 @@ impl Resolver {\n                                  source: Ident,\n                                  directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n-                `%s`\",\n+        debug2!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n+                `{}`\",\n                self.session.str_of(target),\n                self.module_to_str(containing_module),\n                self.session.str_of(source),\n@@ -2304,7 +2304,7 @@ impl Resolver {\n                 // able to resolve this import.\n \n                 if containing_module.glob_count > 0 {\n-                    debug!(\"(resolving single import) unresolved glob; \\\n+                    debug2!(\"(resolving single import) unresolved glob; \\\n                             bailing out\");\n                     return Indeterminate;\n                 }\n@@ -2369,7 +2369,7 @@ impl Resolver {\n                     }\n                     Some(_) => {\n                         // The import is unresolved. Bail out.\n-                        debug!(\"(resolving single import) unresolved import; \\\n+                        debug2!(\"(resolving single import) unresolved import; \\\n                                 bailing out\");\n                         return Indeterminate;\n                     }\n@@ -2402,27 +2402,27 @@ impl Resolver {\n \n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found value target\");\n+                debug2!(\"(resolving single import) found value target\");\n                 import_resolution.value_target =\n                     Some(Target::new(target_module, name_bindings));\n                 import_resolution.value_id = directive.id;\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail!(\"value result should be known at this point\");\n+                fail2!(\"value result should be known at this point\");\n             }\n         }\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found type target: %?\",\n+                debug2!(\"(resolving single import) found type target: {:?}\",\n                         name_bindings.type_def.unwrap().type_def);\n                 import_resolution.type_target =\n                     Some(Target::new(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail!(\"type result should be known at this point\");\n+                fail2!(\"type result should be known at this point\");\n             }\n         }\n \n@@ -2469,15 +2469,15 @@ impl Resolver {\n \n         let span = directive.span;\n         if resolve_fail {\n-            let msg = fmt!(\"unresolved import: there is no `%s` in `%s`\",\n-                           self.session.str_of(source),\n-                           self.module_to_str(containing_module));\n+            let msg = format!(\"unresolved import: there is no `{}` in `{}`\",\n+                              self.session.str_of(source),\n+                              self.module_to_str(containing_module));\n             self.resolve_error(span, msg);\n             return Failed;\n         } else if priv_fail {\n-            let msg = fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n-                           private\", self.session.str_of(source),\n-                           self.module_to_str(containing_module));\n+            let msg = format!(\"unresolved import: found `{}` in `{}` but it is \\\n+                              private\", self.session.str_of(source),\n+                              self.module_to_str(containing_module));\n             self.resolve_error(span, msg);\n             return Failed;\n         }\n@@ -2505,7 +2505,7 @@ impl Resolver {\n             None => {}\n         }\n \n-        debug!(\"(resolving single import) successfully resolved import\");\n+        debug2!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -2521,12 +2521,12 @@ impl Resolver {\n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n         // node.\n-        debug!(\"(resolving glob import) resolving %? glob import\", privacy);\n+        debug2!(\"(resolving glob import) resolving {:?} glob import\", privacy);\n \n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n         if !(*containing_module).all_imports_resolved() {\n-            debug!(\"(resolving glob import) target module has unresolved \\\n+            debug2!(\"(resolving glob import) target module has unresolved \\\n                     imports; bailing out\");\n             return Indeterminate;\n         }\n@@ -2536,8 +2536,8 @@ impl Resolver {\n         // Add all resolved imports from the containing module.\n         for (ident, target_import_resolution) in containing_module.import_resolutions.iter() {\n \n-            debug!(\"(resolving glob import) writing module resolution \\\n-                    %? into `%s`\",\n+            debug2!(\"(resolving glob import) writing module resolution \\\n+                    {:?} into `{}`\",\n                    target_import_resolution.type_target.is_none(),\n                    self.module_to_str(module_));\n \n@@ -2597,22 +2597,22 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n-                    to `%s`, privacy=%?\",\n+            debug2!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n+                    to `{}`, privacy={:?}\",\n                    interner_get(name),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    dest_import_resolution.privacy);\n \n             // Merge the child item into the import resolution.\n             if name_bindings.defined_in_public_namespace(ValueNS) {\n-                debug!(\"(resolving glob import) ... for value target\");\n+                debug2!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n                     Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.value_id = id;\n             }\n             if name_bindings.defined_in_public_namespace(TypeNS) {\n-                debug!(\"(resolving glob import) ... for type target\");\n+                debug2!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n                     Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.type_id = id;\n@@ -2640,7 +2640,7 @@ impl Resolver {\n             None => {}\n         }\n \n-        debug!(\"(resolving glob import) successfully resolved import\");\n+        debug2!(\"(resolving glob import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -2675,19 +2675,19 @@ impl Resolver {\n                             expn_info: span.expn_info,\n                         };\n                         self.resolve_error(span,\n-                                              fmt!(\"unresolved import. maybe \\\n+                                              format!(\"unresolved import. maybe \\\n                                                     a missing `extern mod \\\n-                                                    %s`?\",\n+                                                    {}`?\",\n                                                     segment_name));\n                         return Failed;\n                     }\n-                    self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` in \\\n-                                                     `%s`.\", segment_name, module_name));\n+                    self.resolve_error(span, format!(\"unresolved import: could not find `{}` in \\\n+                                                     `{}`.\", segment_name, module_name));\n                     return Failed;\n                 }\n                 Indeterminate => {\n-                    debug!(\"(resolving module path for import) module \\\n-                            resolution is indeterminate: %s\",\n+                    debug2!(\"(resolving module path for import) module \\\n+                            resolution is indeterminate: {}\",\n                             self.session.str_of(name));\n                     return Indeterminate;\n                 }\n@@ -2700,8 +2700,8 @@ impl Resolver {\n                                 None => {\n                                     // Not a module.\n                                     self.resolve_error(span,\n-                                                          fmt!(\"not a \\\n-                                                                module `%s`\",\n+                                                          format!(\"not a \\\n+                                                                module `{}`\",\n                                                                self.session.\n                                                                    str_of(\n                                                                     name)));\n@@ -2729,7 +2729,7 @@ impl Resolver {\n                         None => {\n                             // There are no type bindings at all.\n                             self.resolve_error(span,\n-                                                  fmt!(\"not a module `%s`\",\n+                                                  format!(\"not a module `{}`\",\n                                                        self.session.str_of(\n                                                             name)));\n                             return Failed;\n@@ -2764,8 +2764,8 @@ impl Resolver {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n-        debug!(\"(resolving module path for import) processing `%s` rooted at \\\n-               `%s`\",\n+        debug2!(\"(resolving module path for import) processing `{}` rooted at \\\n+               `{}`\",\n                self.idents_to_str(module_path),\n                self.module_to_str(module_));\n \n@@ -2780,8 +2780,8 @@ impl Resolver {\n                 let mpath = self.idents_to_str(module_path);\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n-                        self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` \\\n-                                                         in `%s`\",\n+                        self.resolve_error(span, format!(\"unresolved import: could not find `{}` \\\n+                                                         in `{}`\",\n                                                          // idx +- 1 to account for the colons\n                                                          // on either side\n                                                          mpath.slice_from(idx + 1),\n@@ -2792,7 +2792,7 @@ impl Resolver {\n                 return Failed;\n             }\n             Indeterminate => {\n-                debug!(\"(resolving module path for import) indeterminate; \\\n+                debug2!(\"(resolving module path for import) indeterminate; \\\n                         bailing\");\n                 return Indeterminate;\n             }\n@@ -2820,7 +2820,7 @@ impl Resolver {\n                                 return Failed;\n                             }\n                             Indeterminate => {\n-                                debug!(\"(resolving module path for import) \\\n+                                debug2!(\"(resolving module path for import) \\\n                                         indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n@@ -2854,8 +2854,8 @@ impl Resolver {\n                                          search_through_modules:\n                                          SearchThroughModulesFlag)\n                                          -> ResolveResult<Target> {\n-        debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n-                namespace %? in `%s`\",\n+        debug2!(\"(resolving item in lexical scope) resolving `{}` in \\\n+                namespace {:?} in `{}`\",\n                self.session.str_of(name),\n                namespace,\n                self.module_to_str(module_));\n@@ -2883,12 +2883,12 @@ impl Resolver {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     None => {\n                         // Not found; continue.\n-                        debug!(\"(resolving item in lexical scope) found \\\n-                                import resolution, but not in namespace %?\",\n+                        debug2!(\"(resolving item in lexical scope) found \\\n+                                import resolution, but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n-                        debug!(\"(resolving item in lexical scope) using \\\n+                        debug2!(\"(resolving item in lexical scope) using \\\n                                 import resolution\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n                         return Success(target);\n@@ -2917,7 +2917,7 @@ impl Resolver {\n             match search_module.parent_link {\n                 NoParentLink => {\n                     // No more parents. This module was unresolved.\n-                    debug!(\"(resolving item in lexical scope) unresolved \\\n+                    debug2!(\"(resolving item in lexical scope) unresolved \\\n                             module\");\n                     return Failed;\n                 }\n@@ -2927,7 +2927,7 @@ impl Resolver {\n                             match search_module.kind {\n                                 NormalModuleKind => {\n                                     // We stop the search here.\n-                                    debug!(\"(resolving item in lexical \\\n+                                    debug2!(\"(resolving item in lexical \\\n                                             scope) unresolved module: not \\\n                                             searching through module \\\n                                             parents\");\n@@ -2963,7 +2963,7 @@ impl Resolver {\n                     // We couldn't see through the higher scope because of an\n                     // unresolved import higher up. Bail.\n \n-                    debug!(\"(resolving item in lexical scope) indeterminate \\\n+                    debug2!(\"(resolving item in lexical scope) indeterminate \\\n                             higher scope; bailing\");\n                     return Indeterminate;\n                 }\n@@ -2991,7 +2991,7 @@ impl Resolver {\n                     Some(ref type_def) => {\n                         match (*type_def).module_def {\n                             None => {\n-                                error!(\"!!! (resolving module in lexical \\\n+                                error2!(\"!!! (resolving module in lexical \\\n                                         scope) module wasn't actually a \\\n                                         module!\");\n                                 return Failed;\n@@ -3002,19 +3002,19 @@ impl Resolver {\n                         }\n                     }\n                     None => {\n-                        error!(\"!!! (resolving module in lexical scope) module\n+                        error2!(\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\");\n                         return Failed;\n                     }\n                 }\n             }\n             Indeterminate => {\n-                debug!(\"(resolving module in lexical scope) indeterminate; \\\n+                debug2!(\"(resolving module in lexical scope) indeterminate; \\\n                         bailing\");\n                 return Indeterminate;\n             }\n             Failed => {\n-                debug!(\"(resolving module in lexical scope) failed to \\\n+                debug2!(\"(resolving module in lexical scope) failed to \\\n                         resolve\");\n                 return Failed;\n             }\n@@ -3087,7 +3087,7 @@ impl Resolver {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n                 \"super\" == token::ident_to_str(&module_path[i]) {\n-            debug!(\"(resolving module prefix) resolving `super` at %s\",\n+            debug2!(\"(resolving module prefix) resolving `super` at {}\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed,\n@@ -3098,7 +3098,7 @@ impl Resolver {\n             }\n         }\n \n-        debug!(\"(resolving module prefix) finished resolving prefix at %s\",\n+        debug2!(\"(resolving module prefix) finished resolving prefix at {}\",\n                self.module_to_str(containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n@@ -3113,7 +3113,7 @@ impl Resolver {\n                                   namespace: Namespace,\n                                   name_search_type: NameSearchType)\n                                   -> ResolveResult<Target> {\n-        debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n+        debug2!(\"(resolving name in module) resolving `{}` in `{}`\",\n                self.session.str_of(name),\n                self.module_to_str(module_));\n \n@@ -3122,7 +3122,7 @@ impl Resolver {\n         match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n-                debug!(\"(resolving name in module) found node as child\");\n+                debug2!(\"(resolving name in module) found node as child\");\n                 return Success(Target::new(module_, *name_bindings));\n             }\n             Some(_) | None => {\n@@ -3144,28 +3144,28 @@ impl Resolver {\n             Some(import_resolution) => {\n                 if import_resolution.privacy == Public &&\n                         import_resolution.outstanding_references != 0 {\n-                    debug!(\"(resolving name in module) import \\\n+                    debug2!(\"(resolving name in module) import \\\n                             unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n \n                 match import_resolution.target_for_namespace(namespace) {\n                     None => {\n-                        debug!(\"(resolving name in module) name found, \\\n-                                but not in namespace %?\",\n+                        debug2!(\"(resolving name in module) name found, \\\n+                                but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target)\n                             if name_search_type ==\n                                 PathPublicOrPrivateSearch ||\n                             import_resolution.privacy == Public => {\n-                        debug!(\"(resolving name in module) resolved to \\\n+                        debug2!(\"(resolving name in module) resolved to \\\n                                 import\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n                         return Success(target);\n                     }\n                     Some(_) => {\n-                        debug!(\"(resolving name in module) name found, \\\n+                        debug2!(\"(resolving name in module) name found, \\\n                                 but not public\");\n                     }\n                 }\n@@ -3187,7 +3187,7 @@ impl Resolver {\n         }\n \n         // We're out of luck.\n-        debug!(\"(resolving name in module) failed to resolve `%s`\",\n+        debug2!(\"(resolving name in module) failed to resolve `{}`\",\n                self.session.str_of(name));\n         return Failed;\n     }\n@@ -3201,7 +3201,7 @@ impl Resolver {\n             if sn.contains(\"::\") {\n                 self.resolve_error(imports[index].span, \"unresolved import\");\n             } else {\n-                let err = fmt!(\"unresolved import (maybe you meant `%s::*`?)\",\n+                let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                sn.slice(0, sn.len()));\n                 self.resolve_error(imports[index].span, err);\n             }\n@@ -3247,20 +3247,20 @@ impl Resolver {\n         match module_.def_id {\n             Some(def_id) if def_id.crate == LOCAL_CRATE => {\n                 // OK. Continue.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for local module `%s`\",\n+                debug2!(\"(recording exports for module subtree) recording \\\n+                        exports for local module `{}`\",\n                        self.module_to_str(module_));\n             }\n             None => {\n                 // Record exports for the root module.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for root module `%s`\",\n+                debug2!(\"(recording exports for module subtree) recording \\\n+                        exports for root module `{}`\",\n                        self.module_to_str(module_));\n             }\n             Some(_) => {\n                 // Bail out.\n-                debug!(\"(recording exports for module subtree) not recording \\\n-                        exports for `%s`\",\n+                debug2!(\"(recording exports for module subtree) not recording \\\n+                        exports for `{}`\",\n                        self.module_to_str(module_));\n                 return;\n             }\n@@ -3292,7 +3292,7 @@ impl Resolver {\n         match module_.def_id {\n             Some(def_id) => {\n                 self.export_map2.insert(def_id.node, exports2);\n-                debug!(\"(computing exports) writing exports for %d (some)\",\n+                debug2!(\"(computing exports) writing exports for {} (some)\",\n                        def_id.node);\n             }\n             None => {}\n@@ -3308,7 +3308,7 @@ impl Resolver {\n         match (namebindings.def_for_namespace(ns),\n                namebindings.privacy_for_namespace(ns)) {\n             (Some(d), Some(Public)) => {\n-                debug!(\"(computing exports) YES: %s '%s' => %?\",\n+                debug2!(\"(computing exports) YES: {} '{}' => {:?}\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n                        interner_get(name),\n                        def_id_of_def(d));\n@@ -3319,10 +3319,10 @@ impl Resolver {\n                 });\n             }\n             (Some(_), Some(privacy)) => {\n-                debug!(\"(computing reexports) NO: privacy %?\", privacy);\n+                debug2!(\"(computing reexports) NO: privacy {:?}\", privacy);\n             }\n             (d_opt, p_opt) => {\n-                debug!(\"(computing reexports) NO: %?, %?\", d_opt, p_opt);\n+                debug2!(\"(computing reexports) NO: {:?}, {:?}\", d_opt, p_opt);\n             }\n         }\n     }\n@@ -3332,15 +3332,15 @@ impl Resolver {\n                                   module_: @mut Module) {\n         for (name, importresolution) in module_.import_resolutions.iter() {\n             if importresolution.privacy != Public {\n-                debug!(\"(computing exports) not reexporting private `%s`\",\n+                debug2!(\"(computing exports) not reexporting private `{}`\",\n                        interner_get(*name));\n                 loop;\n             }\n             let xs = [TypeNS, ValueNS];\n             for ns in xs.iter() {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n-                        debug!(\"(computing exports) maybe reexport '%s'\",\n+                        debug2!(\"(computing exports) maybe reexport '{}'\",\n                                interner_get(*name));\n                         self.add_exports_of_namebindings(&mut *exports2,\n                                                          *name,\n@@ -3384,15 +3384,15 @@ impl Resolver {\n                 self.populate_module_if_necessary(orig_module);\n                 match orig_module.children.find(&name.name) {\n                     None => {\n-                        debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n+                        debug2!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                self.session.str_of(name),\n                                self.module_to_str(orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n-                                debug!(\"!!! (with scope) didn't find module \\\n-                                        for `%s` in `%s`\",\n+                                debug2!(\"!!! (with scope) didn't find module \\\n+                                        for `{}` in `{}`\",\n                                        self.session.str_of(name),\n                                        self.module_to_str(orig_module));\n                             }\n@@ -3551,13 +3551,13 @@ impl Resolver {\n     }\n \n     pub fn resolve_crate(&mut self, crate: &ast::Crate) {\n-        debug!(\"(resolving crate) starting\");\n+        debug2!(\"(resolving crate) starting\");\n \n         visit::walk_crate(self, crate, ());\n     }\n \n     pub fn resolve_item(&mut self, item: @item) {\n-        debug!(\"(resolving item) resolving %s\",\n+        debug2!(\"(resolving item) resolving {}\",\n                self.session.str_of(item.ident));\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n@@ -3727,7 +3727,7 @@ impl Resolver {\n             }\n \n           item_mac(*) => {\n-            fail!(\"item macros unimplemented\")\n+            fail2!(\"item macros unimplemented\")\n           }\n         }\n \n@@ -3746,7 +3746,7 @@ impl Resolver {\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let ident = type_parameter.ident;\n-                    debug!(\"with_type_parameter_rib: %d %d\", node_id,\n+                    debug2!(\"with_type_parameter_rib: {} {}\", node_id,\n                            type_parameter.id);\n                     let def_like = DlDef(DefTyParam\n                         (local_def(type_parameter.id),\n@@ -3844,7 +3844,7 @@ impl Resolver {\n \n                         this.resolve_type(&argument.ty);\n \n-                        debug!(\"(resolving function) recorded argument\");\n+                        debug2!(\"(resolving function) recorded argument\");\n                     }\n \n                     this.resolve_type(&declaration.output);\n@@ -3854,7 +3854,7 @@ impl Resolver {\n             // Resolve the function body.\n             this.resolve_block(block);\n \n-            debug!(\"(resolving function) leaving function\");\n+            debug2!(\"(resolving function) leaving function\");\n         }\n \n         self.label_ribs.pop();\n@@ -3894,11 +3894,11 @@ impl Resolver {\n                     TraitDerivation            => \"derive\"\n                 };\n \n-                let msg = fmt!(\"attempt to %s a nonexistent trait `%s`\", usage_str, path_str);\n+                let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n                 self.resolve_error(trait_reference.path.span, msg);\n             }\n             Some(def) => {\n-                debug!(\"(resolving trait) found trait def: %?\", def);\n+                debug2!(\"(resolving trait) found trait def: {:?}\", def);\n                 self.record_def(trait_reference.ref_id, def);\n             }\n         }\n@@ -3916,7 +3916,7 @@ impl Resolver {\n                         Some(&prev_field) => {\n                             let ident_str = self.session.str_of(ident);\n                             self.resolve_error(field.span,\n-                                fmt!(\"field `%s` is already declared\", ident_str));\n+                                format!(\"field `{}` is already declared\", ident_str));\n                             self.session.span_note(prev_field.span,\n                                 \"Previously declared here\");\n                         },\n@@ -4049,7 +4049,7 @@ impl Resolver {\n                           _name: Ident,\n                           id: NodeId) {\n         // Write the implementations in scope into the module metadata.\n-        debug!(\"(resolving module) resolving module ID %d\", id);\n+        debug2!(\"(resolving module) resolving module ID {}\", id);\n         visit::walk_mod(self, module_, ());\n     }\n \n@@ -4101,16 +4101,16 @@ impl Resolver {\n                   None => {\n                     self.resolve_error(\n                         p.span,\n-                        fmt!(\"variable `%s` from pattern #1 is \\\n-                                  not bound in pattern #%u\",\n+                        format!(\"variable `{}` from pattern \\\\#1 is \\\n+                                  not bound in pattern \\\\#{}\",\n                              interner_get(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.resolve_error(\n                             binding_i.span,\n-                            fmt!(\"variable `%s` is bound with different \\\n-                                      mode in pattern #%u than in pattern #1\",\n+                            format!(\"variable `{}` is bound with different \\\n+                                      mode in pattern \\\\#{} than in pattern \\\\#1\",\n                                  interner_get(key), i + 1));\n                     }\n                   }\n@@ -4121,8 +4121,8 @@ impl Resolver {\n                 if !map_0.contains_key(&key) {\n                     self.resolve_error(\n                         binding.span,\n-                        fmt!(\"variable `%s` from pattern #%u is \\\n-                                  not bound in pattern #1\",\n+                        format!(\"variable `{}` from pattern \\\\#{} is \\\n+                                  not bound in pattern \\\\#1\",\n                              interner_get(key), i + 1));\n                 }\n             }\n@@ -4149,15 +4149,15 @@ impl Resolver {\n     }\n \n     pub fn resolve_block(&mut self, block: &Block) {\n-        debug!(\"(resolving block) entering block\");\n+        debug2!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         match self.current_module.anonymous_children.find(&block.id) {\n             None => { /* Nothing to do. */ }\n             Some(&anonymous_module) => {\n-                debug!(\"(resolving block) found anonymous module, moving \\\n+                debug2!(\"(resolving block) found anonymous module, moving \\\n                         down\");\n                 self.current_module = anonymous_module;\n             }\n@@ -4170,7 +4170,7 @@ impl Resolver {\n         self.current_module = orig_module;\n \n         self.value_ribs.pop();\n-        debug!(\"(resolving block) leaving block\");\n+        debug2!(\"(resolving block) leaving block\");\n     }\n \n     pub fn resolve_type(&mut self, ty: &Ty) {\n@@ -4224,8 +4224,8 @@ impl Resolver {\n                                                 TypeNS,\n                                                 true) {\n                             Some(def) => {\n-                                debug!(\"(resolving type) resolved `%s` to \\\n-                                        type %?\",\n+                                debug2!(\"(resolving type) resolved `{}` to \\\n+                                        type {:?}\",\n                                        self.session.str_of(path.segments\n                                                                .last()\n                                                                .identifier),\n@@ -4243,15 +4243,15 @@ impl Resolver {\n                 match result_def {\n                     Some(def) => {\n                         // Write the result into the def map.\n-                        debug!(\"(resolving type) writing resolution for `%s` \\\n-                                (id %d)\",\n+                        debug2!(\"(resolving type) writing resolution for `{}` \\\n+                                (id {})\",\n                                self.path_idents_to_str(path),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n-                        let msg = fmt!(\"use of undeclared type name `%s`\",\n-                                       self.path_idents_to_str(path));\n+                        let msg = format!(\"use of undeclared type name `{}`\",\n+                                          self.path_idents_to_str(path));\n                         self.resolve_error(ty.span, msg);\n                     }\n                 }\n@@ -4307,7 +4307,7 @@ impl Resolver {\n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def)\n                                 if mode == RefutableMode => {\n-                            debug!(\"(resolving pattern) resolving `%s` to \\\n+                            debug2!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n                                    interner_get(renamed));\n \n@@ -4319,14 +4319,14 @@ impl Resolver {\n                         }\n                         FoundStructOrEnumVariant(_) => {\n                             self.resolve_error(pattern.span,\n-                                                  fmt!(\"declaration of `%s` \\\n+                                                  format!(\"declaration of `{}` \\\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n                                                        interner_get(renamed)));\n                         }\n                         FoundConst(def) if mode == RefutableMode => {\n-                            debug!(\"(resolving pattern) resolving `%s` to \\\n+                            debug2!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n                                    interner_get(renamed));\n \n@@ -4342,7 +4342,7 @@ impl Resolver {\n                                                    allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n-                            debug!(\"(resolving pattern) binding `%s`\",\n+                            debug2!(\"(resolving pattern) binding `{}`\",\n                                    interner_get(renamed));\n \n                             let is_mutable = mutability == Mutable;\n@@ -4392,7 +4392,7 @@ impl Resolver {\n                                       // in the same disjunct, which is an\n                                       // error\n                                      self.resolve_error(pattern.span,\n-                                       fmt!(\"Identifier `%s` is bound more \\\n+                                       format!(\"Identifier `{}` is bound more \\\n                                              than once in the same pattern\",\n                                             path_to_str(path, self.session\n                                                         .intr())));\n@@ -4435,7 +4435,7 @@ impl Resolver {\n                         Some(_) => {\n                             self.resolve_error(\n                                 path.span,\n-                                fmt!(\"`%s` is not an enum variant or constant\",\n+                                format!(\"`{}` is not an enum variant or constant\",\n                                      self.session.str_of(\n                                          path.segments.last().identifier)))\n                         }\n@@ -4465,16 +4465,16 @@ impl Resolver {\n                         Some(_) => {\n                             self.resolve_error(\n                                 path.span,\n-                                fmt!(\"`%s` is not an enum variant, struct or const\",\n+                                format!(\"`{}` is not an enum variant, struct or const\",\n                                      self.session\n                                          .str_of(path.segments\n                                                      .last()\n                                                      .identifier)));\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n-                                               fmt!(\"unresolved enum variant, \\\n-                                                    struct or const `%s`\",\n+                                               format!(\"unresolved enum variant, \\\n+                                                    struct or const `{}`\",\n                                                     self.session\n                                                         .str_of(path.segments\n                                                                     .last()\n@@ -4515,10 +4515,10 @@ impl Resolver {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n-                            debug!(\"(resolving pattern) didn't find struct \\\n-                                    def: %?\", result);\n-                            let msg = fmt!(\"`%s` does not name a structure\",\n-                                           self.path_idents_to_str(path));\n+                            debug2!(\"(resolving pattern) didn't find struct \\\n+                                    def: {:?}\", result);\n+                            let msg = format!(\"`{}` does not name a structure\",\n+                                              self.path_idents_to_str(path));\n                             self.resolve_error(path.span, msg);\n                         }\n                     }\n@@ -4542,7 +4542,7 @@ impl Resolver {\n             Success(target) => {\n                 match target.bindings.value_def {\n                     None => {\n-                        fail!(\"resolved name in the value namespace to a \\\n+                        fail2!(\"resolved name in the value namespace to a \\\n                               set of name bindings with no def?!\");\n                     }\n                     Some(def) => {\n@@ -4562,7 +4562,7 @@ impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail!(\"unexpected indeterminate result\");\n+                fail2!(\"unexpected indeterminate result\");\n             }\n \n             Failed => {\n@@ -4732,14 +4732,14 @@ impl Resolver {\n                                        path.span,\n                                        PathPublicOnlySearch) {\n             Failed => {\n-                let msg = fmt!(\"use of undeclared module `%s`\",\n-                               self.idents_to_str(module_path_idents));\n+                let msg = format!(\"use of undeclared module `{}`\",\n+                                  self.idents_to_str(module_path_idents));\n                 self.resolve_error(path.span, msg);\n                 return None;\n             }\n \n             Indeterminate => {\n-                fail!(\"indeterminate unexpected\");\n+                fail2!(\"indeterminate unexpected\");\n             }\n \n             Success(resulting_module) => {\n@@ -4766,7 +4766,7 @@ impl Resolver {\n                     Some(s) => {\n                         match containing_module.def_id {\n                             Some(def_id) if s.contains(&def_id) => {\n-                                debug!(\"containing module was a trait or impl \\\n+                                debug2!(\"containing module was a trait or impl \\\n                                         and name was a method -> not resolved\");\n                                 return None;\n                             },\n@@ -4799,14 +4799,14 @@ impl Resolver {\n                                                  path.span,\n                                                  PathPublicOrPrivateSearch) {\n             Failed => {\n-                let msg = fmt!(\"use of undeclared module `::%s`\",\n-                               self.idents_to_str(module_path_idents));\n+                let msg = format!(\"use of undeclared module `::{}`\",\n+                                  self.idents_to_str(module_path_idents));\n                 self.resolve_error(path.span, msg);\n                 return None;\n             }\n \n             Indeterminate => {\n-                fail!(\"indeterminate unexpected\");\n+                fail2!(\"indeterminate unexpected\");\n             }\n \n             Success(resulting_module) => {\n@@ -4852,8 +4852,8 @@ impl Resolver {\n \n         match search_result {\n             Some(DlDef(def)) => {\n-                debug!(\"(resolving path in local ribs) resolved `%s` to \\\n-                        local: %?\",\n+                debug2!(\"(resolving path in local ribs) resolved `{}` to \\\n+                        local: {:?}\",\n                        self.session.str_of(ident),\n                        def);\n                 return Some(def);\n@@ -4913,15 +4913,15 @@ impl Resolver {\n                         return None;\n                     }\n                     Some(def) => {\n-                        debug!(\"(resolving item path in lexical scope) \\\n-                                resolved `%s` to item\",\n+                        debug2!(\"(resolving item path in lexical scope) \\\n+                                resolved `{}` to item\",\n                                self.session.str_of(ident));\n                         return Some(def);\n                     }\n                 }\n             }\n             Indeterminate => {\n-                fail!(\"unexpected indeterminate result\");\n+                fail2!(\"unexpected indeterminate result\");\n             }\n             Failed => {\n                 return None;\n@@ -5000,7 +5000,7 @@ impl Resolver {\n                 match self.resolve_path(expr.id, path, ValueNS, true) {\n                     Some(def) => {\n                         // Write the result into the def map.\n-                        debug!(\"(resolving expr) resolved `%s`\",\n+                        debug2!(\"(resolving expr) resolved `{}`\",\n                                self.path_idents_to_str(path));\n \n                         // First-class methods are not supported yet; error\n@@ -5031,11 +5031,15 @@ impl Resolver {\n                             Some(DefTy(struct_id))\n                               if self.structs.contains(&struct_id) => {\n                                 self.resolve_error(expr.span,\n-                                        fmt!(\"`%s` is a structure name, but this expression \\\n-                                            uses it like a function name\", wrong_name));\n+                                        format!(\"`{}` is a structure name, but \\\n+                                                 this expression \\\n+                                                 uses it like a function name\",\n+                                                wrong_name));\n \n-                                self.session.span_note(expr.span, fmt!(\"Did you mean to write: \\\n-                                            `%s { /* fields */ }`?\", wrong_name));\n+                                self.session.span_note(expr.span,\n+                                    format!(\"Did you mean to write: \\\n+                                            `{} \\\\{ /* fields */ \\\\}`?\",\n+                                            wrong_name));\n \n                             }\n                             _ =>\n@@ -5044,14 +5048,14 @@ impl Resolver {\n                                match self.find_best_match_for_name(wrong_name, 5) {\n                                    Some(m) => {\n                                        self.resolve_error(expr.span,\n-                                           fmt!(\"unresolved name `%s`. \\\n-                                               Did you mean `%s`?\",\n-                                               wrong_name, m));\n+                                           format!(\"unresolved name `{}`. \\\n+                                                    Did you mean `{}`?\",\n+                                                    wrong_name, m));\n                                    }\n                                    None => {\n                                        self.resolve_error(expr.span,\n-                                            fmt!(\"unresolved name `%s`.\",\n-                                                wrong_name));\n+                                            format!(\"unresolved name `{}`.\",\n+                                                    wrong_name));\n                                    }\n                                }\n                         }\n@@ -5082,10 +5086,10 @@ impl Resolver {\n                         self.record_def(expr.id, definition);\n                     }\n                     result => {\n-                        debug!(\"(resolving expression) didn't find struct \\\n-                                def: %?\", result);\n-                        let msg = fmt!(\"`%s` does not name a structure\",\n-                                       self.path_idents_to_str(path));\n+                        debug2!(\"(resolving expression) didn't find struct \\\n+                                def: {:?}\", result);\n+                        let msg = format!(\"`{}` does not name a structure\",\n+                                          self.path_idents_to_str(path));\n                         self.resolve_error(path.span, msg);\n                     }\n                 }\n@@ -5104,15 +5108,15 @@ impl Resolver {\n                 }\n             }\n \n-            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n                         self.resolve_error(expr.span,\n-                                              fmt!(\"use of undeclared label \\\n-                                                   `%s`\",\n+                                              format!(\"use of undeclared label \\\n+                                                   `{}`\",\n                                                    interner_get(label))),\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         self.record_def(expr.id, def)\n@@ -5154,8 +5158,8 @@ impl Resolver {\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n             ExprMethodCall(_, _, ident, _, _, _) => {\n-                debug!(\"(recording candidate traits for expr) recording \\\n-                        traits for %d\",\n+                debug2!(\"(recording candidate traits for expr) recording \\\n+                        traits for {}\",\n                        expr.id);\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n@@ -5229,7 +5233,7 @@ impl Resolver {\n \n     pub fn search_for_traits_containing_method(&mut self, name: Ident)\n                                                -> ~[DefId] {\n-        debug!(\"(searching for traits containing method) looking for '%s'\",\n+        debug2!(\"(searching for traits containing method) looking for '{}'\",\n                self.session.str_of(name));\n \n         let mut found_traits = ~[];\n@@ -5331,7 +5335,7 @@ impl Resolver {\n                           found_traits: &mut ~[DefId],\n                           trait_def_id: DefId,\n                           name: Ident) {\n-        debug!(\"(adding trait info) found trait %d:%d for method '%s'\",\n+        debug2!(\"(adding trait info) found trait {}:{} for method '{}'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n                self.session.str_of(name));\n@@ -5350,14 +5354,14 @@ impl Resolver {\n     }\n \n     pub fn record_def(&mut self, node_id: NodeId, def: Def) {\n-        debug!(\"(recording def) recording %? for %?\", def, node_id);\n+        debug2!(\"(recording def) recording {:?} for {:?}\", def, node_id);\n         do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n             if def != *old_value {\n-                self.session.bug(fmt!(\"node_id %? resolved first to %? \\\n-                                      and then %?\", node_id, *old_value, def));\n+                self.session.bug(format!(\"node_id {:?} resolved first to {:?} \\\n+                                      and then {:?}\", node_id, *old_value, def));\n             }\n         };\n     }\n@@ -5371,7 +5375,7 @@ impl Resolver {\n             BindByRef(*) => {\n                 self.resolve_error(\n                     pat.span,\n-                    fmt!(\"cannot use `ref` binding mode with %s\",\n+                    format!(\"cannot use `ref` binding mode with {}\",\n                          descr));\n             }\n         }\n@@ -5459,15 +5463,15 @@ impl Resolver {\n     }\n \n     pub fn dump_module(&mut self, module_: @mut Module) {\n-        debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n+        debug2!(\"Dump of module `{}`:\", self.module_to_str(module_));\n \n-        debug!(\"Children:\");\n+        debug2!(\"Children:\");\n         self.populate_module_if_necessary(module_);\n         for (&name, _) in module_.children.iter() {\n-            debug!(\"* %s\", interner_get(name));\n+            debug2!(\"* {}\", interner_get(name));\n         }\n \n-        debug!(\"Import resolutions:\");\n+        debug2!(\"Import resolutions:\");\n         for (name, import_resolution) in module_.import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n@@ -5487,7 +5491,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", interner_get(*name),\n+            debug2!(\"* {}:{}{}\", interner_get(*name),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "1c572b2cbadbfaa1be234e1f9b490ab377cb8bb5", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -123,20 +123,20 @@ fn stack_check_fn<'a>(v: &mut StackCheckVisitor,\n         }\n     };\n     let new_cx = Context {safe_stack: safe_stack};\n-    debug!(\"stack_check_fn(safe_stack=%b, id=%?)\", safe_stack, id);\n+    debug2!(\"stack_check_fn(safe_stack={}, id={:?})\", safe_stack, id);\n     visit::walk_fn(v, fk, decl, body, sp, id, new_cx);\n }\n \n fn stack_check_expr<'a>(v: &mut StackCheckVisitor,\n                         expr: @ast::Expr,\n                         cx: Context) {\n-    debug!(\"stack_check_expr(safe_stack=%b, expr=%s)\",\n+    debug2!(\"stack_check_expr(safe_stack={}, expr={})\",\n            cx.safe_stack, expr.repr(v.tcx));\n     if !cx.safe_stack {\n         match expr.node {\n             ast::ExprCall(callee, _, _) => {\n                 let callee_ty = ty::expr_ty(v.tcx, callee);\n-                debug!(\"callee_ty=%s\", callee_ty.repr(v.tcx));\n+                debug2!(\"callee_ty={}\", callee_ty.repr(v.tcx));\n                 match ty::get(callee_ty).sty {\n                     ty::ty_bare_fn(ref fty) => {\n                         if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {\n@@ -177,6 +177,6 @@ fn call_to_extern_fn(v: &mut StackCheckVisitor, callee: @ast::Expr) {\n     v.tcx.sess.add_lint(lint::cstack,\n                          callee.id,\n                          callee.span,\n-                         fmt!(\"invoking non-Rust fn in fn without \\\n-                              #[fixed_stack_segment]\"));\n+                         format!(\"invoking non-Rust fn in fn without \\\n+                              \\\\#[fixed_stack_segment]\"));\n }"}, {"sha": "40cd693b5c109394590d79974a16ca8357a77b8a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -183,9 +183,9 @@ impl Subst for ty::Region {\n                     ty::NonerasedRegions(ref regions) => {\n                         if regions.len() != 1 {\n                             tcx.sess.bug(\n-                                fmt!(\"ty::Region#subst(): \\\n+                                format!(\"ty::Region\\\\#subst(): \\\n                                       Reference to self region when \\\n-                                      given substs with no self region: %s\",\n+                                      given substs with no self region: {}\",\n                                      substs.repr(tcx)));\n                         }\n                         *regions.get(0)"}, {"sha": "a159512aee5b94156f70a05c65ac8a2368c3eca8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -264,7 +264,7 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                                 a_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n-                            fail!(\"UnitLikeStructLit should have been handled \\\n+                            fail2!(\"UnitLikeStructLit should have been handled \\\n                                     above\")\n                         }\n                     }\n@@ -277,14 +277,14 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                                 b_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n-                            fail!(\"UnitLikeStructLit should have been handled \\\n+                            fail2!(\"UnitLikeStructLit should have been handled \\\n                                     above\")\n                         }\n                     }\n \n                     match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n                         Some(val1) => val1 == 0,\n-                        None => fail!(\"compare_list_exprs: type mismatch\"),\n+                        None => fail2!(\"compare_list_exprs: type mismatch\"),\n                     }\n                 }\n             }\n@@ -294,7 +294,7 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n             let m2 = const_eval::compare_lit_exprs(tcx, a2, b2);\n             match (m1, m2) {\n                 (Some(val1), Some(val2)) => (val1 == 0 && val2 == 0),\n-                _ => fail!(\"compare_list_exprs: type mismatch\"),\n+                _ => fail2!(\"compare_list_exprs: type mismatch\"),\n             }\n         }\n         (&var(a, _), &var(b, _)) => a == b,\n@@ -419,7 +419,7 @@ impl<'self> Repr for Match<'self> {\n             // for many programs, this just take too long to serialize\n             self.pats.repr(tcx)\n         } else {\n-            fmt!(\"%u pats\", self.pats.len())\n+            format!(\"{} pats\", self.pats.len())\n         }\n     }\n }\n@@ -439,7 +439,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   col: uint,\n                                   val: ValueRef)\n                               -> ~[Match<'r>] {\n-    debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -472,7 +472,7 @@ fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n-            fmt!(\"Expected an identifier pattern but found p: %s\",\n+            format!(\"Expected an identifier pattern but found p: {}\",\n                  p.repr(bcx.tcx())));\n     }\n }\n@@ -486,7 +486,7 @@ fn enter_match<'r>(bcx: @mut Block,\n                        val: ValueRef,\n                        e: enter_pat)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -523,7 +523,7 @@ fn enter_match<'r>(bcx: @mut Block,\n         }\n     }\n \n-    debug!(\"result=%s\", result.repr(bcx.tcx()));\n+    debug2!(\"result={}\", result.repr(bcx.tcx()));\n \n     return result;\n }\n@@ -535,7 +535,7 @@ fn enter_default<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      chk: FailureHandler)\n                       -> ~[Match<'r>] {\n-    debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -605,7 +605,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n                      variant_size: uint,\n                      val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_opt(bcx=%s, m=%s, opt=%?, col=%u, val=%s)\",\n+    debug2!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            *opt,\n@@ -741,7 +741,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                fields: &[ast::Ident],\n                                val: ValueRef)\n                             -> ~[Match<'r>] {\n-    debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -776,7 +776,7 @@ fn enter_tup<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      n_elts: uint)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -802,7 +802,7 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               val: ValueRef,\n                               n_elts: uint)\n                           -> ~[Match<'r>] {\n-    debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -827,7 +827,7 @@ fn enter_box<'r>(bcx: @mut Block,\n                      col: uint,\n                      val: ValueRef)\n                  -> ~[Match<'r>] {\n-    debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_box(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -854,7 +854,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n                       col: uint,\n                       val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -881,7 +881,7 @@ fn enter_region<'r>(bcx: @mut Block,\n                         col: uint,\n                         val: ValueRef)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -1232,7 +1232,7 @@ impl FailureHandler {\n     fn handle_fail(&self) -> BasicBlockRef {\n         match *self {\n             Infallible => {\n-                fail!(\"attempted to fail in infallible failure handler!\")\n+                fail2!(\"attempted to fail in infallible failure handler!\")\n             }\n             JumpToBasicBlock(basic_block) => basic_block,\n             CustomFailureHandlerClass(custom_failure_handler) => {\n@@ -1295,7 +1295,7 @@ fn compare_values(cx: @mut Block,\n             let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n             Store(cx, rhs, scratch_rhs);\n             let did = langcall(cx, None,\n-                               fmt!(\"comparison of `%s`\", cx.ty_to_str(rhs_t)),\n+                               format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n                                UniqStrEqFnLangItem);\n             let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n             Result {\n@@ -1305,7 +1305,7 @@ fn compare_values(cx: @mut Block,\n         }\n         ty::ty_estr(_) => {\n             let did = langcall(cx, None,\n-                               fmt!(\"comparison of `%s`\", cx.ty_to_str(rhs_t)),\n+                               format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n                                StrEqFnLangItem);\n             let result = callee::trans_lang_call(cx, did, [lhs, rhs], None);\n             Result {\n@@ -1383,7 +1383,7 @@ fn insert_lllocals(bcx: @mut Block,\n             }\n         };\n \n-        debug!(\"binding %? to %s\", binding_info.id, bcx.val_to_str(llval));\n+        debug2!(\"binding {:?} to {}\", binding_info.id, bcx.val_to_str(llval));\n         llmap.insert(binding_info.id, llval);\n \n         if bcx.sess().opts.extra_debuginfo {\n@@ -1404,7 +1404,7 @@ fn compile_guard(bcx: @mut Block,\n                      vals: &[ValueRef],\n                      chk: FailureHandler)\n                   -> @mut Block {\n-    debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%s)\",\n+    debug2!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n            m.repr(bcx.tcx()),\n@@ -1458,7 +1458,7 @@ fn compile_submatch(bcx: @mut Block,\n                     m: &[Match],\n                     vals: &[ValueRef],\n                     chk: FailureHandler) {\n-    debug!(\"compile_submatch(bcx=%s, m=%s, vals=%s)\",\n+    debug2!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n@@ -1624,7 +1624,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n     // Decide what kind of branch we need\n     let opts = get_options(bcx, m, col);\n-    debug!(\"options=%?\", opts);\n+    debug2!(\"options={:?}\", opts);\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n@@ -2113,13 +2113,13 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n      * - binding_mode: is this for an argument or a local variable?\n      */\n \n-    debug!(\"bind_irrefutable_pat(bcx=%s, pat=%s, binding_mode=%?)\",\n+    debug2!(\"bind_irrefutable_pat(bcx={}, pat={}, binding_mode={:?})\",\n            bcx.to_str(),\n            pat.repr(bcx.tcx()),\n            binding_mode);\n \n     if bcx.sess().asm_comments() {\n-        add_comment(bcx, fmt!(\"bind_irrefutable_pat(pat=%s)\",\n+        add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n                               pat.repr(bcx.tcx())));\n     }\n \n@@ -2241,7 +2241,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n         ast::PatVec(*) => {\n             bcx.tcx().sess.span_bug(\n                 pat.span,\n-                fmt!(\"vector patterns are never irrefutable!\"));\n+                format!(\"vector patterns are never irrefutable!\"));\n         }\n         ast::PatWild | ast::PatLit(_) | ast::PatRange(_, _) => ()\n     }"}, {"sha": "0fdbc04a6c1e058b72732e16eebf4291cec12671", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -113,13 +113,13 @@ pub fn represent_node(bcx: @mut Block, node: ast::NodeId) -> @Repr {\n \n /// Decides how to represent a given type.\n pub fn represent_type(cx: &mut CrateContext, t: ty::t) -> @Repr {\n-    debug!(\"Representing: %s\", ty_to_str(cx.tcx, t));\n+    debug2!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n     match cx.adt_reprs.find(&t) {\n         Some(repr) => return *repr,\n         None => { }\n     }\n     let repr = @represent_type_uncached(cx, t);\n-    debug!(\"Represented as: %?\", repr)\n+    debug2!(\"Represented as: {:?}\", repr)\n     cx.adt_reprs.insert(t, repr);\n     return repr;\n }\n@@ -179,7 +179,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n-                cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n+                cx.sess.bug(format!(\"non-C-like enum {} with specified \\\n                                   discriminants\",\n                                  ty::item_path_str(cx.tcx, def_id)))\n             }"}, {"sha": "4a960b1721d2d5d49412416fd424f528c45a3c1b", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -47,7 +47,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n         let e = match out.node {\n             ast::ExprAddrOf(_, e) => e,\n-            _ => fail!(\"Expression must be addr of\")\n+            _ => fail2!(\"Expression must be addr of\")\n         };\n \n         unpack_result!(bcx, {\n@@ -89,7 +89,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n     let mut clobbers = getClobbers();\n     if !ia.clobbers.is_empty() && !clobbers.is_empty() {\n-        clobbers = fmt!(\"%s,%s\", ia.clobbers, clobbers);\n+        clobbers = format!(\"{},{}\", ia.clobbers, clobbers);\n     } else {\n         clobbers.push_str(ia.clobbers);\n     };\n@@ -102,7 +102,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         constraints.push_str(clobbers);\n     }\n \n-    debug!(\"Asm Constraints: %?\", constraints);\n+    debug2!(\"Asm Constraints: {:?}\", constraints);\n \n     let numOutputs = outputs.len();\n "}, {"sha": "3a35f144ab50423062e5511f6766b1e4731f5dfc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -351,7 +351,7 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n         match li.require(it) {\n             Ok(id) => id,\n             Err(s) => {\n-                bcx.tcx().sess.fatal(fmt!(\"allocation of `%s` %s\",\n+                bcx.tcx().sess.fatal(format!(\"allocation of `{}` {}\",\n                                           bcx.ty_to_str(t), s));\n             }\n         }\n@@ -379,7 +379,7 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n                 (ty::mk_imm_box,\n                  require_alloc_fn(bcx, t, ClosureExchangeMallocFnLangItem))\n             }\n-            _ => fail!(\"heap_exchange already handled\")\n+            _ => fail2!(\"heap_exchange already handled\")\n         };\n \n         // Grab the TypeRef type of box_ptr_ty.\n@@ -911,20 +911,18 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n     }\n \n     match bcx.node_info {\n-        None => debug!(\"invoke at ???\"),\n+        None => debug2!(\"invoke at ???\"),\n         Some(node_info) => {\n-            debug!(\"invoke at %s\",\n+            debug2!(\"invoke at {}\",\n                    bcx.sess().codemap.span_to_str(node_info.span));\n         }\n     }\n \n     if need_invoke(bcx) {\n         unsafe {\n-            debug!(\"invoking %x at %x\",\n-                   ::std::cast::transmute(llfn),\n-                   ::std::cast::transmute(bcx.llbb));\n+            debug2!(\"invoking {} at {}\", llfn, bcx.llbb);\n             for &llarg in llargs.iter() {\n-                debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n+                debug2!(\"arg: {}\", llarg);\n             }\n         }\n         let normal_bcx = sub_block(bcx, \"normal return\");\n@@ -937,11 +935,9 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n         return (llresult, normal_bcx);\n     } else {\n         unsafe {\n-            debug!(\"calling %x at %x\",\n-                   ::std::cast::transmute(llfn),\n-                   ::std::cast::transmute(bcx.llbb));\n+            debug2!(\"calling {} at {}\", llfn, bcx.llbb);\n             for &llarg in llargs.iter() {\n-                debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n+                debug2!(\"arg: {}\", llarg);\n             }\n         }\n         let llresult = Call(bcx, llfn, llargs, attributes);\n@@ -1092,7 +1088,7 @@ pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block\n             }\n             None => {\n                 bcx_sid = match bcx_sid.parent {\n-                    None => bcx.tcx().sess.bug(fmt!(\"no enclosing scope with id %d\", scope_id)),\n+                    None => bcx.tcx().sess.bug(format!(\"no enclosing scope with id {}\", scope_id)),\n                     Some(bcx_par) => bcx_par\n                 };\n                 bcx_sid.scope\n@@ -1161,7 +1157,7 @@ pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n \n pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n \n-    debug!(\"init_local(bcx=%s, local.id=%?)\",\n+    debug2!(\"init_local(bcx={}, local.id={:?})\",\n            bcx.to_str(), local.id);\n     let _indenter = indenter();\n \n@@ -1182,7 +1178,7 @@ pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n \n pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n     let _icx = push_ctxt(\"trans_stmt\");\n-    debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n+    debug2!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n     if cx.sess().asm_comments() {\n         add_span_comment(cx, s.span, stmt_to_str(s, cx.ccx().sess.intr()));\n@@ -1345,12 +1341,12 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     let mut bcx = bcx;\n     let is_lpad = leave == None;\n     loop {\n-        debug!(\"cleanup_and_leave: leaving %s\", cur.to_str());\n+        debug2!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                (fmt!(\"cleanup_and_leave(%s)\", cur.to_str())).to_managed());\n+                (format!(\"cleanup_and_leave({})\", cur.to_str())).to_managed());\n         }\n \n         let mut cur_scope = cur.scope;\n@@ -1419,12 +1415,12 @@ pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block\n     let mut cur = bcx;\n     let mut bcx = bcx;\n     loop {\n-        debug!(\"cleanup_block: %s\", cur.to_str());\n+        debug2!(\"cleanup_block: {}\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                (fmt!(\"cleanup_block(%s)\", cur.to_str())).to_managed());\n+                (format!(\"cleanup_block({})\", cur.to_str())).to_managed());\n         }\n \n         let mut cur_scope = cur.scope;\n@@ -1469,7 +1465,7 @@ pub fn with_scope(bcx: @mut Block,\n                   f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n-    debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n+    debug2!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n@@ -1599,7 +1595,7 @@ pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n-    assert!(!ty::type_has_params(t), \"Type has params: %s\", ty_to_str(ccx.tcx, t));\n+    assert!(!ty::type_has_params(t));\n     let val = alloca(bcx, ty, name);\n     return val;\n }\n@@ -1688,8 +1684,8 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                      -> @mut FunctionContext {\n     for p in param_substs.iter() { p.validate(); }\n \n-    debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, \\\n-            param_substs=%s)\",\n+    debug2!(\"new_fn_ctxt_w_id(path={}, id={:?}, \\\n+            param_substs={})\",\n            path_str(ccx.sess, path),\n            id,\n            param_substs.repr(ccx.tcx));\n@@ -1802,7 +1798,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::t]) -> @mut Block {\n-    debug!(\"copy_args_to_allocas: raw_llargs=%s arg_tys=%s\",\n+    debug2!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n            raw_llargs.llrepr(fcx.ccx),\n            arg_tys.repr(fcx.ccx.tcx));\n \n@@ -1926,7 +1922,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n-    debug!(\"trans_closure(..., param_substs=%s)\",\n+    debug2!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx));\n \n     let fcx = new_fn_ctxt_w_id(ccx,\n@@ -2006,7 +2002,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n \n     let the_path_str = path_str(ccx.sess, path);\n     let _s = StatRecorder::new(ccx, the_path_str);\n-    debug!(\"trans_fn(self_arg=%?, param_substs=%s)\",\n+    debug2!(\"trans_fn(self_arg={:?}, param_substs={})\",\n            self_arg,\n            param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n@@ -2042,7 +2038,7 @@ fn insert_synthetic_type_entries(bcx: @mut Block,\n \n     let tcx = bcx.tcx();\n     for i in range(0u, fn_args.len()) {\n-        debug!(\"setting type of argument %u (pat node %d) to %s\",\n+        debug2!(\"setting type of argument {} (pat node {}) to {}\",\n                i, fn_args[i].pat.id, bcx.ty_to_str(arg_tys[i]));\n \n         let pat_id = fn_args[i].pat.id;\n@@ -2141,8 +2137,8 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n         _ => ccx.sess.bug(\n-            fmt!(\"trans_enum_variant_or_tuple_like_struct: \\\n-                  unexpected ctor return type %s\",\n+            format!(\"trans_enum_variant_or_tuple_like_struct: \\\n+                  unexpected ctor return type {}\",\n                  ty_to_str(ccx.tcx, ctor_ty)))\n     };\n \n@@ -2218,7 +2214,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n-        _ => fail!(\"trans_item\"),\n+        _ => fail2!(\"trans_item\"),\n     };\n     match item.node {\n       ast::item_fn(ref decl, purity, _abis, ref generics, ref body) => {\n@@ -2360,7 +2356,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n             f\n         }\n-        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+        _ => fail2!(\"expected bare rust fn or an intrinsic\")\n     };\n \n     let llfn = decl_rust_fn(ccx, f.sig.inputs, f.sig.output, sym);\n@@ -2376,7 +2372,7 @@ pub fn register_fn_llvmty(ccx: @mut CrateContext,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type)\n                           -> ValueRef {\n-    debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n+    debug2!(\"register_fn_fuller creating fn for item {} with path {}\",\n            node_id,\n            ast_map::path_to_str(item_path(ccx, &node_id), token::get_ident_interner()));\n \n@@ -2455,7 +2451,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n                 (start_fn, args)\n             } else {\n-                debug!(\"using user-defined start fn\");\n+                debug2!(\"using user-defined start fn\");\n                 let args = ~[\n                     C_null(Type::opaque_box(ccx).ptr_to()),\n                     llvm::LLVMGetParam(llfn, 0 as c_uint),\n@@ -2503,7 +2499,7 @@ fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::At\n }\n \n pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n-    debug!(\"get_item_val(id=`%?`)\", id);\n+    debug2!(\"get_item_val(id=`{:?}`)\", id);\n \n     let val = ccx.item_vals.find_copy(&id);\n     match val {\n@@ -2525,10 +2521,10 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             // we need to get the symbol from csearch instead of\n                             // using the current crate's name/version\n                             // information in the hash of the symbol\n-                            debug!(\"making %s\", sym);\n+                            debug2!(\"making {}\", sym);\n                             let sym = match ccx.external_srcs.find(&i.id) {\n                                 Some(&did) => {\n-                                    debug!(\"but found in other crate...\");\n+                                    debug2!(\"but found in other crate...\");\n                                     csearch::get_symbol(ccx.sess.cstore, did)\n                                 }\n                                 None => sym\n@@ -2579,7 +2575,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 }\n \n                                 if !inlineable {\n-                                    debug!(\"%s not inlined\", sym);\n+                                    debug2!(\"{} not inlined\", sym);\n                                     ccx.non_inlineable_statics.insert(id);\n                                 }\n                                 ccx.item_symbols.insert(i.id, sym);\n@@ -2600,7 +2596,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             llfn\n                         }\n \n-                        _ => fail!(\"get_item_val: weird result in table\")\n+                        _ => fail2!(\"get_item_val: weird result in table\")\n                     };\n \n                     match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n@@ -2616,7 +2612,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ast_map::node_trait_method(trait_method, _, pth) => {\n-                    debug!(\"get_item_val(): processing a node_trait_method\");\n+                    debug2!(\"get_item_val(): processing a node_trait_method\");\n                     match *trait_method {\n                         ast::required(_) => {\n                             ccx.sess.bug(\"unexpected variant: required trait method in \\\n@@ -2673,11 +2669,11 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 ast::item_enum(_, _) => {\n                                     register_fn(ccx, (*v).span, sym, id, ty)\n                                 }\n-                                _ => fail!(\"node_variant, shouldn't happen\")\n+                                _ => fail2!(\"node_variant, shouldn't happen\")\n                             };\n                         }\n                         ast::struct_variant_kind(_) => {\n-                            fail!(\"struct variant kind unexpected in get_item_val\")\n+                            fail2!(\"struct variant kind unexpected in get_item_val\")\n                         }\n                     }\n                     set_inline_hint(llfn);\n@@ -2704,7 +2700,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ref variant => {\n-                    ccx.sess.bug(fmt!(\"get_item_val(): unexpected variant: %?\",\n+                    ccx.sess.bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n                                  variant))\n                 }\n             };\n@@ -2959,7 +2955,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n     let mapname = if *sess.building_library {\n-        fmt!(\"%s_%s_%s\", mapmeta.name, mapmeta.vers, mapmeta.extras_hash)\n+        format!(\"{}_{}_{}\", mapmeta.name, mapmeta.vers, mapmeta.extras_hash)\n     } else {\n         ~\"toplevel\"\n     };\n@@ -2988,7 +2984,7 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n-        let nm = fmt!(\"_rust_crate_map_%s_%s_%s\",\n+        let nm = format!(\"_rust_crate_map_{}_{}_{}\",\n                       cdata.name,\n                       cstore::get_crate_vers(cstore, i),\n                       cstore::get_crate_hash(cstore, i));"}, {"sha": "1754741a1f4fe86a0f4238c075a7e86a96455c79", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -29,7 +29,7 @@ pub fn terminate(cx: &mut Block, _: &str) {\n \n pub fn check_not_terminated(cx: &Block) {\n     if cx.terminated {\n-        fail!(\"already terminated!\");\n+        fail2!(\"already terminated!\");\n     }\n }\n \n@@ -117,7 +117,7 @@ pub fn Invoke(cx: @mut Block,\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n-    debug!(\"Invoke(%s with arguments (%s))\",\n+    debug2!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_str(Fn),\n            Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n     B(cx).invoke(Fn, Args, Then, Catch, attributes)"}, {"sha": "febe4de730da7188617e8b7d1a7445279c036966", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -476,7 +476,7 @@ impl Builder {\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n-        debug!(\"Store %s -> %s\",\n+        debug2!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n         assert!(is_not_null(self.llbuilder));\n@@ -487,7 +487,7 @@ impl Builder {\n     }\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n-        debug!(\"Store %s -> %s\",\n+        debug2!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n         self.count_insn(\"store.atomic\");\n@@ -725,16 +725,16 @@ impl Builder {\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n         if self.ccx.sess.asm_comments() {\n-            let s = fmt!(\"%s (%s)\", text, self.ccx.sess.codemap.span_to_str(sp));\n-            debug!(\"%s\", s);\n+            let s = format!(\"{} ({})\", text, self.ccx.sess.codemap.span_to_str(sp));\n+            debug2!(\"{}\", s);\n             self.add_comment(s);\n         }\n     }\n \n     pub fn add_comment(&self, text: &str) {\n         if self.ccx.sess.asm_comments() {\n             let sanitized = text.replace(\"$\", \"\");\n-            let comment_text = fmt!(\"# %s\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n+            let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n             let asm = do comment_text.with_c_str |c| {\n                 unsafe {\n@@ -758,11 +758,11 @@ impl Builder {\n                          else          { lib::llvm::False };\n \n         let argtys = do inputs.map |v| {\n-            debug!(\"Asm Input Type: %?\", self.ccx.tn.val_to_str(*v));\n+            debug2!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n             val_ty(*v)\n         };\n \n-        debug!(\"Asm Output Type: %?\", self.ccx.tn.type_to_str(output));\n+        debug2!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n         let fty = Type::func(argtys, &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm("}, {"sha": "2cba0615310f71c8e3a1f9a6dd5ebed6b8adfe04", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -49,7 +49,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail!(\"ty_align: unhandled type\")\n+        _ => fail2!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -79,7 +79,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => fail2!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "3d11c3dafb2e9ca8e30a3b803a4af4b936313a8b", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -51,7 +51,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => fail2!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -81,7 +81,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => fail2!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "9f098fe3cc116ffab71e886cb3d2e41738588106", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -112,7 +112,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 let elt = ty.element_type();\n                 ty_align(elt)\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n+            _ => fail2!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -141,7 +141,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 let eltsz = ty_size(elt);\n                 len * eltsz\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n+            _ => fail2!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -232,7 +232,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                     i += 1u;\n                 }\n             }\n-            _ => fail!(\"classify: unhandled type\")\n+            _ => fail2!(\"classify: unhandled type\")\n         }\n     }\n \n@@ -325,7 +325,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n             SSEDs => {\n                 tys.push(Type::f64());\n             }\n-            _ => fail!(\"llregtype: unhandled class\")\n+            _ => fail2!(\"llregtype: unhandled class\")\n         }\n         i += 1u;\n     }"}, {"sha": "c1a9f7649626ad077cc182d46131b15489059389", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -79,7 +79,7 @@ pub struct Callee {\n \n pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n-    debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n+    debug2!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n@@ -105,7 +105,7 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n             _ => {\n                 bcx.tcx().sess.span_bug(\n                     expr.span,\n-                    fmt!(\"Type of callee is neither bare-fn nor closure: %s\",\n+                    format!(\"Type of callee is neither bare-fn nor closure: {}\",\n                          bcx.ty_to_str(datum.ty)));\n             }\n         }\n@@ -153,7 +153,7 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n             ast::DefSelfTy(*) | ast::DefMethod(*) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    fmt!(\"Cannot translate def %? \\\n+                    format!(\"Cannot translate def {:?} \\\n                           to a callable thing!\", def));\n             }\n         }\n@@ -180,7 +180,7 @@ pub fn trans_fn_ref(bcx: @mut Block,\n \n     let type_params = node_id_type_params(bcx, ref_id);\n     let vtables = node_vtables(bcx, ref_id);\n-    debug!(\"trans_fn_ref(def_id=%s, ref_id=%?, type_params=%s, vtables=%s)\",\n+    debug2!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n     trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n@@ -266,8 +266,8 @@ pub fn trans_fn_ref_with_vtables(\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_fn_ref_with_vtables(bcx=%s, def_id=%s, ref_id=%?, \\\n-            type_params=%s, vtables=%s)\",\n+    debug2!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, ref_id={:?}, \\\n+            type_params={}, vtables={})\",\n            bcx.to_str(),\n            def_id.repr(bcx.tcx()),\n            ref_id,\n@@ -329,11 +329,11 @@ pub fn trans_fn_ref_with_vtables(\n                 resolve_default_method_vtables(bcx, impl_id,\n                                                method, &substs, vtables);\n \n-            debug!(\"trans_fn_with_vtables - default method: \\\n-                    substs = %s, trait_subst = %s, \\\n-                    first_subst = %s, new_subst = %s, \\\n-                    vtables = %s, \\\n-                    self_vtable = %s, param_vtables = %s\",\n+            debug2!(\"trans_fn_with_vtables - default method: \\\n+                    substs = {}, trait_subst = {}, \\\n+                    first_subst = {}, new_subst = {}, \\\n+                    vtables = {}, \\\n+                    self_vtable = {}, param_vtables = {}\",\n                    substs.repr(tcx), trait_ref.substs.repr(tcx),\n                    first_subst.repr(tcx), new_substs.repr(tcx),\n                    vtables.repr(tcx),\n@@ -365,7 +365,7 @@ pub fn trans_fn_ref_with_vtables(\n         let map_node = session::expect(\n             ccx.sess,\n             ccx.tcx.items.find(&def_id.node),\n-            || fmt!(\"local item should be in ast map\"));\n+            || format!(\"local item should be in ast map\"));\n \n         match *map_node {\n             ast_map::node_foreign_item(_, abis, _, _) => {\n@@ -472,7 +472,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n                          dest: expr::Dest)\n                          -> @mut Block {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n+    debug2!(\"trans_method_call(call_ex={}, rcvr={})\",\n            call_ex.repr(in_cx.tcx()),\n            rcvr.repr(in_cx.tcx()));\n     trans_call_inner(\n@@ -483,7 +483,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n         |cx| {\n             match cx.ccx().maps.method_map.find_copy(&call_ex.id) {\n                 Some(origin) => {\n-                    debug!(\"origin for %s: %s\",\n+                    debug2!(\"origin for {}: {}\",\n                            call_ex.repr(in_cx.tcx()),\n                            origin.repr(in_cx.tcx()));\n \n@@ -562,7 +562,7 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n                                                       substituted);\n                     new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n                 }\n-                _ => fail!()\n+                _ => fail2!()\n             }\n             Callee { bcx: callee.bcx, data: Fn(FnData { llfn: new_llval }) }\n         },\n@@ -840,7 +840,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s)\",\n+    debug2!(\"trans_arg_expr(formal_arg_ty=({}), self_mode={:?}, arg_expr={})\",\n            formal_arg_ty.repr(bcx.tcx()),\n            self_mode,\n            arg_expr.repr(bcx.tcx()));\n@@ -850,7 +850,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n     let arg_datum = arg_datumblock.datum;\n     let bcx = arg_datumblock.bcx;\n \n-    debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));\n+    debug2!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n \n     let mut val;\n     if ty::type_is_bot(arg_datum.ty) {\n@@ -890,11 +890,11 @@ pub fn trans_arg_expr(bcx: @mut Block,\n \n                 val = match self_mode {\n                     ty::ByRef => {\n-                        debug!(\"by ref arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n+                        debug2!(\"by ref arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n                         arg_datum.to_ref_llval(bcx)\n                     }\n                     ty::ByCopy => {\n-                        debug!(\"by copy arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n+                        debug2!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n                         arg_datum.to_appropriate_llval(bcx)\n                     }\n                 }\n@@ -904,12 +904,12 @@ pub fn trans_arg_expr(bcx: @mut Block,\n         if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-            debug!(\"casting actual type (%s) to match formal (%s)\",\n+            debug2!(\"casting actual type ({}) to match formal ({})\",\n                    bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }\n \n-    debug!(\"--- trans_arg_expr passing %s\", bcx.val_to_str(val));\n+    debug2!(\"--- trans_arg_expr passing {}\", bcx.val_to_str(val));\n     return rslt(bcx, val);\n }"}, {"sha": "875be5d3af54a69091370e4a5e5cb41625c43863", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -127,7 +127,7 @@ impl EnvAction {\n \n impl EnvValue {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n+        format!(\"{}({})\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }\n \n@@ -151,7 +151,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n         }\n     });\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug!(\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty));\n+    debug2!(\"cdata_ty={}\", ty_to_str(tcx, cdata_ty));\n     return cdata_ty;\n }\n \n@@ -224,15 +224,15 @@ pub fn store_environment(bcx: @mut Block,\n     let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n \n     let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n-    debug!(\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty));\n+    debug2!(\"tuplify_box_ty = {}\", ty_to_str(tcx, cbox_ty));\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n     for (i, bv) in bound_values.iter().enumerate() {\n-        debug!(\"Copy %s into closure\", bv.to_str(ccx));\n+        debug2!(\"Copy {} into closure\", bv.to_str(ccx));\n \n         if ccx.sess.asm_comments() {\n-            add_comment(bcx, fmt!(\"Copy %s into closure\",\n+            add_comment(bcx, format!(\"Copy {} into closure\",\n                                   bv.to_str(ccx)));\n         }\n \n@@ -268,7 +268,7 @@ pub fn build_closure(bcx0: @mut Block,\n     // Package up the captured upvars\n     let mut env_vals = ~[];\n     for cap_var in cap_vars.iter() {\n-        debug!(\"Building closure: captured variable %?\", *cap_var);\n+        debug2!(\"Building closure: captured variable {:?}\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n@@ -384,7 +384,7 @@ pub fn trans_expr_fn(bcx: @mut Block,\n     let fty = node_id_type(bcx, outer_id);\n     let f = match ty::get(fty).sty {\n         ty::ty_closure(ref f) => f,\n-        _ => fail!(\"expected closure\")\n+        _ => fail2!(\"expected closure\")\n     };\n \n     let sub_path = vec::append_one(bcx.fcx.path.clone(),"}, {"sha": "4d46ae385eb2fec791d1aa117b8b6f4c30684db1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -169,7 +169,7 @@ impl param_substs {\n }\n \n fn param_substs_to_str(this: &param_substs, tcx: ty::ctxt) -> ~str {\n-    fmt!(\"param_substs {tys:%s, vtables:%s}\",\n+    format!(\"param_substs \\\\{tys:{}, vtables:{}\\\\}\",\n          this.tys.repr(tcx),\n          this.vtables.repr(tcx))\n }\n@@ -436,7 +436,7 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n         return\n     }\n \n-    debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n+    debug2!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx, None) |scope_info| {\n@@ -451,7 +451,7 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n \n pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n-    debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n+    debug2!(\"add_clean_temp_immediate({}, {}, {})\",\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n@@ -480,7 +480,7 @@ pub fn add_clean_temp_mem_in_scope(bcx: @mut Block,\n pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeId>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n-    debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n+    debug2!(\"add_clean_temp_mem({}, {}, {})\",\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n@@ -509,7 +509,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n     //! box was frozen initially. Here, both `frozen_val_ref` and\n     //! `bits_val_ref` are in fact pointers to stack slots.\n \n-    debug!(\"add_clean_return_to_mut(%s, %s, %s)\",\n+    debug2!(\"add_clean_return_to_mut({}, {}, {})\",\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n@@ -705,8 +705,8 @@ impl Block {\n         match self.tcx().def_map.find(&nid) {\n             Some(&v) => v,\n             None => {\n-                self.tcx().sess.bug(fmt!(\n-                    \"No def associated with node id %?\", nid));\n+                self.tcx().sess.bug(format!(\n+                    \"No def associated with node id {:?}\", nid));\n             }\n         }\n     }\n@@ -726,8 +726,8 @@ impl Block {\n     pub fn to_str(&self) -> ~str {\n         unsafe {\n             match self.node_info {\n-                Some(node_info) => fmt!(\"[block %d]\", node_info.id),\n-                None => fmt!(\"[block %x]\", transmute(&*self)),\n+                Some(node_info) => format!(\"[block {}]\", node_info.id),\n+                None => format!(\"[block {}]\", transmute::<&Block, *Block>(self)),\n             }\n         }\n     }\n@@ -763,15 +763,15 @@ pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mu\n             Some(inf) => match scope_id {\n                 Some(wanted) => match inf.node_info {\n                     Some(NodeInfo { id: actual, _ }) if wanted == actual => {\n-                        debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                        debug2!(\"in_scope_cx: selected cur={} (cx={})\",\n                                cur.to_str(), cx.to_str());\n                         f(inf);\n                         return;\n                     },\n                     _ => inf.parent,\n                 },\n                 None => {\n-                    debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                    debug2!(\"in_scope_cx: selected cur={} (cx={})\",\n                            cur.to_str(), cx.to_str());\n                     f(inf);\n                     return;\n@@ -788,7 +788,7 @@ pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mu\n pub fn block_parent(cx: @mut Block) -> @mut Block {\n     match cx.parent {\n       Some(b) => b,\n-      None    => cx.sess().bug(fmt!(\"block_parent called on root block %?\",\n+      None    => cx.sess().bug(format!(\"block_parent called on root block {:?}\",\n                                    cx))\n     }\n }\n@@ -881,7 +881,7 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n         };\n \n         let gsym = token::gensym(\"str\");\n-        let g = do fmt!(\"str%u\", gsym).with_c_str |buf| {\n+        let g = do format!(\"str{}\", gsym).with_c_str |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(g, sc);\n@@ -964,7 +964,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n         };\n \n-        debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n+        debug2!(\"const_get_elt(v={}, us={:?}, r={})\",\n                cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));\n \n         return r;\n@@ -1115,7 +1115,7 @@ pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n \n     if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n-            fmt!(\"Type parameters for node %d include inference types: %s\",\n+            format!(\"Type parameters for node {} include inference types: {}\",\n                  id, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n     }\n \n@@ -1193,7 +1193,7 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n                     find_vtable(tcx, substs, n_param, n_bound)\n                 }\n                 _ => {\n-                    tcx.sess.bug(fmt!(\n+                    tcx.sess.bug(format!(\n                         \"resolve_vtable_under_param_substs: asked to lookup \\\n                          but no vtables in the fn_ctxt!\"))\n                 }\n@@ -1207,7 +1207,7 @@ pub fn find_vtable(tcx: ty::ctxt,\n                    n_param: typeck::param_index,\n                    n_bound: uint)\n                    -> typeck::vtable_origin {\n-    debug!(\"find_vtable(n_param=%?, n_bound=%u, ps=%s)\",\n+    debug2!(\"find_vtable(n_param={:?}, n_bound={}, ps={})\",\n            n_param, n_bound, ps.repr(tcx));\n \n     let param_bounds = match n_param {\n@@ -1248,7 +1248,7 @@ pub fn langcall(bcx: @mut Block, span: Option<Span>, msg: &str,\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,\n         Err(s) => {\n-            let msg = fmt!(\"%s %s\", msg, s);\n+            let msg = format!(\"{} {}\", msg, s);\n             match span {\n                 Some(span) => { bcx.tcx().sess.span_fatal(span, msg); }\n                 None => { bcx.tcx().sess.fatal(msg); }"}, {"sha": "aa56631438638d7b31f5a859edb95736bf133c97", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -52,7 +52,7 @@ pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n             C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n           }\n           _ => cx.sess.span_bug(lit.span,\n-                   fmt!(\"integer literal has type %s (expected int or uint)\",\n+                   format!(\"integer literal has type {} (expected int or uint)\",\n                         ty_to_str(cx.tcx, lit_int_ty)))\n         }\n       }\n@@ -144,14 +144,14 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n                     const_deref_newtype(cx, v, t)\n                 }\n                 _ => {\n-                    cx.sess.bug(fmt!(\"Unexpected dereferenceable type %s\",\n+                    cx.sess.bug(format!(\"Unexpected dereferenceable type {}\",\n                                      ty_to_str(cx.tcx, t)))\n                 }\n             };\n             (dv, mt.ty)\n         }\n         None => {\n-            cx.sess.bug(fmt!(\"Can't dereference const of type %s\",\n+            cx.sess.bug(format!(\"Can't dereference const of type {}\",\n                              ty_to_str(cx.tcx, t)))\n         }\n     }\n@@ -189,8 +189,8 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n             llconst = C_struct([llconst, C_null(Type::opaque_box(cx).ptr_to())])\n         }\n         Some(@ty::AutoAddEnv(ref r, ref s)) => {\n-            cx.sess.span_bug(e.span, fmt!(\"unexpected static function: \\\n-                                           region %? sigil %?\", *r, *s))\n+            cx.sess.span_bug(e.span, format!(\"unexpected static function: \\\n+                                           region {:?} sigil {:?}\", *r, *s))\n         }\n         Some(@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n@@ -234,8 +234,8 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                         }\n                         _ => {\n                             cx.sess.span_bug(e.span,\n-                                             fmt!(\"unimplemented const \\\n-                                                   autoref %?\", autoref))\n+                                             format!(\"unimplemented const \\\n+                                                   autoref {:?}\", autoref))\n                         }\n                     }\n                 }\n@@ -253,7 +253,7 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess.bug(fmt!(\"const %s of type %s has size %u instead of %u\",\n+        cx.sess.bug(format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx), ty_to_str(cx.tcx, ety),\n                          csize, tsize));\n     }"}, {"sha": "d2a3557d85b9eabf7fdc03be67cda3008c8b4df2", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -252,7 +252,7 @@ impl CrateContext {\n     pub fn const_inbounds_gepi(&self,\n                                pointer: ValueRef,\n                                indices: &[uint]) -> ValueRef {\n-        debug!(\"const_inbounds_gepi: pointer=%s indices=%?\",\n+        debug2!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n                self.tn.val_to_str(pointer), indices);\n         let v: ~[ValueRef] =\n             indices.iter().map(|i| C_i32(*i as i32)).collect();"}, {"sha": "105cb6e5606db60772d51a4fc2880f8b9dc8a853", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -50,7 +50,7 @@ pub fn trans_if(bcx: @mut Block,\n             els: Option<@ast::Expr>,\n             dest: expr::Dest)\n          -> @mut Block {\n-    debug!(\"trans_if(bcx=%s, cond=%s, thn=%?, dest=%s)\",\n+    debug2!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -119,7 +119,7 @@ pub fn trans_if(bcx: @mut Block,\n       }\n     };\n \n-    debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n+    debug2!(\"then_bcx_in={}, else_bcx_in={}\",\n            then_bcx_in.to_str(), else_bcx_in.to_str());\n \n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);"}, {"sha": "7842215912640c61c34839daa16630a308fe4d7a", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -242,7 +242,7 @@ impl Datum {\n                           action: CopyAction,\n                           datum: Datum)\n                           -> @mut Block {\n-        debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n+        debug2!(\"store_to_datum(self={}, action={:?}, datum={})\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, action, datum.val)\n@@ -275,7 +275,7 @@ impl Datum {\n             return bcx;\n         }\n \n-        debug!(\"copy_to(self=%s, action=%?, dst=%s)\",\n+        debug2!(\"copy_to(self={}, action={:?}, dst={})\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         // Watch out for the case where we are writing the copying the\n@@ -340,7 +340,7 @@ impl Datum {\n         let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n-        debug!(\"move_to(self=%s, action=%?, dst=%s)\",\n+        debug2!(\"move_to(self={}, action={:?}, dst={})\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         if ty::type_is_voidish(self.ty) {\n@@ -380,7 +380,7 @@ impl Datum {\n             }\n             ByRef(ZeroMem) => {\n                 bcx.tcx().sess.bug(\n-                    fmt!(\"Cannot add clean to a 'zero-mem' datum\"));\n+                    format!(\"Cannot add clean to a 'zero-mem' datum\"));\n             }\n         }\n     }\n@@ -404,7 +404,7 @@ impl Datum {\n     }\n \n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"Datum { val=%s, ty=%s, mode=%? }\",\n+        format!(\"Datum \\\\{ val={}, ty={}, mode={:?} \\\\}\",\n              ccx.tn.val_to_str(self.val),\n              ty_to_str(ccx.tcx, self.ty),\n              self.mode)\n@@ -573,8 +573,8 @@ impl Datum {\n                 (unboxed_vec_ty, true)\n             }\n             _ => {\n-                bcx.tcx().sess.bug(fmt!(\n-                    \"box_body() invoked on non-box type %s\",\n+                bcx.tcx().sess.bug(format!(\n+                    \"box_body() invoked on non-box type {}\",\n                     ty_to_str(bcx.tcx(), self.ty)));\n             }\n         };\n@@ -620,7 +620,7 @@ impl Datum {\n                      -> (Option<Datum>, @mut Block) {\n         let ccx = bcx.ccx();\n \n-        debug!(\"try_deref(expr_id=%?, derefs=%?, is_auto=%b, self=%?)\",\n+        debug2!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n \n         let bcx =\n@@ -745,7 +745,7 @@ impl Datum {\n                      -> DatumBlock {\n         let _icx = push_ctxt(\"autoderef\");\n \n-        debug!(\"autoderef(expr_id=%d, max=%?, self=%?)\",\n+        debug2!(\"autoderef(expr_id={}, max={:?}, self={:?})\",\n                expr_id, max, self.to_str(bcx.ccx()));\n         let _indenter = indenter();\n "}, {"sha": "3f4c2e8abc586bedfb0e8c9997941df0c48e6935", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -142,7 +142,7 @@ pub struct CrateDebugContext {\n \n impl CrateDebugContext {\n     pub fn new(llmod: ModuleRef, crate: ~str) -> CrateDebugContext {\n-        debug!(\"CrateDebugContext::new\");\n+        debug2!(\"CrateDebugContext::new\");\n         let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n@@ -240,7 +240,7 @@ pub fn finalize(cx: @mut CrateContext) {\n         return;\n     }\n \n-    debug!(\"finalize\");\n+    debug2!(\"finalize\");\n     compile_unit_metadata(cx);\n     unsafe {\n         llvm::LLVMDIBuilderFinalize(DIB(cx));\n@@ -268,7 +268,8 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n         let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n-                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+                bcx.tcx().sess.span_bug(span,\n+                    format!(\"No entry in lllocals table for {:?}\", node_id));\n             }\n         };\n \n@@ -310,8 +311,8 @@ pub fn create_captured_var_metadata(bcx: @mut Block,\n             ast_util::path_to_ident(path)\n         }\n         _ => {\n-            cx.sess.span_bug(span, fmt!(\"debuginfo::create_captured_var_metadata() - \\\n-                Captured var-id refers to unexpected ast_map variant: %?\", ast_item));\n+            cx.sess.span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n+                Captured var-id refers to unexpected ast_map variant: {:?}\", ast_item));\n         }\n     };\n \n@@ -366,7 +367,7 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n     let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n         Some(v) => v,\n         None => {\n-            bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+            bcx.tcx().sess.span_bug(span, format!(\"No entry in lllocals table for {:?}\", node_id));\n         }\n     };\n \n@@ -408,7 +409,7 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n             explicit_self.span\n         }\n         _ => bcx.ccx().sess.bug(\n-                fmt!(\"create_self_argument_metadata: unexpected sort of node: %?\", fnitem))\n+                format!(\"create_self_argument_metadata: unexpected sort of node: {:?}\", fnitem))\n     };\n \n     let scope_metadata = bcx.fcx.debug_context.get_ref(bcx.ccx(), span).fn_metadata;\n@@ -459,7 +460,8 @@ pub fn create_argument_metadata(bcx: @mut Block,\n         let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n-                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in llargs table for %?\", node_id));\n+                bcx.tcx().sess.span_bug(span,\n+                    format!(\"No entry in llargs table for {:?}\", node_id));\n             }\n         };\n \n@@ -501,7 +503,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let cx = fcx.ccx;\n \n-    debug!(\"set_source_location: %s\", cx.sess.codemap.span_to_str(span));\n+    debug2!(\"set_source_location: {}\", cx.sess.codemap.span_to_str(span));\n \n     if fcx.debug_context.get_ref(cx, span).source_locations_enabled {\n         let loc = span_start(cx, span);\n@@ -574,7 +576,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n                 ast::ExprFnBlock(ref fn_decl, ref top_level_block) => {\n-                    let name = fmt!(\"fn%u\", token::gensym(\"fn\"));\n+                    let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name);\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n@@ -606,7 +608,8 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ast_map::node_struct_ctor(*) => {\n             return FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess.bug(fmt!(\"create_function_debug_context: unexpected sort of node: %?\", fnitem))\n+        _ => cx.sess.bug(format!(\"create_function_debug_context: \\\n+                                  unexpected sort of node: {:?}\", fnitem))\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -637,8 +640,8 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         }\n         None => {\n             // This branch is only hit when there is a bug in the NamespaceVisitor.\n-            cx.sess.span_warn(span, fmt!(\"debuginfo: Could not find namespace node for function\n-                                          with name %s. This is a bug! Please report this to\n+            cx.sess.span_warn(span, format!(\"debuginfo: Could not find namespace node for function\n+                                          with name {}. This is a bug! Please report this to\n                                           github.com/mozilla/rust/issues\", function_name));\n             (function_name.clone(), file_metadata)\n         }\n@@ -870,10 +873,10 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let dcx = debug_context(cx);\n     let crate_name: &str = dcx.crate_file;\n \n-    debug!(\"compile_unit_metadata: %?\", crate_name);\n+    debug2!(\"compile_unit_metadata: {:?}\", crate_name);\n \n     let work_dir = cx.sess.working_dir.to_str();\n-    let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n+    let producer = format!(\"rustc version {}\", env!(\"CFG_VERSION\"));\n \n     do crate_name.with_c_str |crate_name| {\n     do work_dir.with_c_str |work_dir| {\n@@ -980,7 +983,7 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         None => ()\n     }\n \n-    debug!(\"file_metadata: %s\", full_path);\n+    debug2!(\"file_metadata: {}\", full_path);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let file_name =\n@@ -1015,14 +1018,14 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx.items.get_copy(&node_id);\n \n             fcx.ccx.sess.span_bug(span,\n-                fmt!(\"debuginfo: Could not find scope info for node %?\", node));\n+                format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n         }\n     }\n }\n \n fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n-    debug!(\"basic_type_metadata: %?\", ty::get(t));\n+    debug2!(\"basic_type_metadata: {:?}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n@@ -1340,8 +1343,8 @@ fn describe_variant(cx: &mut CrateContext,\n             Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n             ref node => {\n                 cx.sess.span_warn(span,\n-                    fmt!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n-                          type: %?. This is a bug.\", node));\n+                    format!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n+                          type: {:?}. This is a bug.\", node));\n                 codemap::dummy_sp()\n             }\n         }\n@@ -1659,7 +1662,7 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n                        span: Span)\n                     -> DICompositeType {\n     let box_type_name = match content_type_name {\n-        Some(content_type_name) => fmt!(\"Boxed<%s>\", content_type_name),\n+        Some(content_type_name) => format!(\"Boxed<{}>\", content_type_name),\n         None                    => ~\"BoxedType\"\n     };\n \n@@ -1768,7 +1771,7 @@ fn vec_metadata(cx: &mut CrateContext,\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = fmt!(\"[%s]\", ppaux::ty_to_str(cx.tcx, element_type));\n+    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n \n@@ -1824,7 +1827,7 @@ fn boxed_vec_metadata(cx: &mut CrateContext,\n                    -> DICompositeType {\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = fmt!(\"[%s]\", ppaux::ty_to_str(cx.tcx, element_type));\n+    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n     let vec_metadata = vec_metadata(cx, element_type, span);\n \n     return boxed_type_metadata(\n@@ -1841,7 +1844,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n                       span: Span)\n                    -> DICompositeType {\n \n-    debug!(\"vec_slice_metadata: %?\", ty::get(vec_type));\n+    debug2!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n     let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n@@ -1956,10 +1959,10 @@ fn trait_metadata(cx: &mut CrateContext,\n }\n \n fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n-    debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n+    debug2!(\"unimplemented_type_metadata: {:?}\", ty::get(t));\n \n     let name = ppaux::ty_to_str(cx.tcx, t);\n-    let metadata = do fmt!(\"NYI<%s>\", name).with_c_str |name| {\n+    let metadata = do format!(\"NYI<{}>\", name).with_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -2008,7 +2011,7 @@ fn type_metadata(cx: &mut CrateContext,\n         pointer_type_metadata(cx, pointer_type, box_metadata)\n     }\n \n-    debug!(\"type_metadata: %?\", ty::get(t));\n+    debug2!(\"type_metadata: {:?}\", ty::get(t));\n \n     let sty = &ty::get(t).sty;\n     let type_metadata = match *sty {\n@@ -2095,7 +2098,7 @@ fn type_metadata(cx: &mut CrateContext,\n         ty::ty_opaque_box => {\n             create_pointer_to_box_metadata(cx, t, ty::mk_nil())\n         }\n-        _ => cx.sess.bug(fmt!(\"debuginfo: unexpected type in type_metadata: %?\", sty))\n+        _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };\n \n     debug_context(cx).created_types.insert(cache_id, type_metadata);\n@@ -2127,7 +2130,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n \n     match debug_location {\n         KnownLocation { scope, line, col } => {\n-            debug!(\"setting debug location to %u %u\", line, col);\n+            debug2!(\"setting debug location to {} {}\", line, col);\n             let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n@@ -2136,7 +2139,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n             }\n         }\n         UnknownLocation => {\n-            debug!(\"clearing debug location \");\n+            debug2!(\"clearing debug location \");\n             metadata_node = ptr::null();\n         }\n     };\n@@ -2202,8 +2205,9 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n         let definition_span = match cx.tcx.items.find(&def_id.node) {\n             Some(&ast_map::node_item(@ast::item { span, _ }, _)) => span,\n             ref node => {\n-                cx.sess.span_warn(warning_span, fmt!(\"debuginfo::get_namespace_and_span_for_item() \\\n-                                                      - Unexpected node type: %?\", *node));\n+                cx.sess.span_warn(warning_span,\n+                    format!(\"debuginfo::get_namespace_and_span_for_item() \\\n+                             - Unexpected node type: {:?}\", *node));\n                 codemap::dummy_sp()\n             }\n         };\n@@ -2682,7 +2686,7 @@ impl NamespaceTreeNode {\n         let mut name = ~\"_ZN\";\n         fill_nested(self, &mut name);\n \n-        name.push_str(fmt!(\"%u%s\", item_name.len(), item_name));\n+        name.push_str(format!(\"{}{}\", item_name.len(), item_name));\n         name.push_char('E');\n \n         return name;\n@@ -2695,7 +2699,7 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let name = token::ident_to_str(&node.ident);\n-            output.push_str(fmt!(\"%u%s\", name.len(), name));\n+            output.push_str(format!(\"{}{}\", name.len(), name));\n         }\n     }\n }\n@@ -2704,7 +2708,7 @@ fn namespace_for_external_item(cx: &mut CrateContext,\n                                item_path: &ast_map::path)\n                             -> @NamespaceTreeNode {\n     if item_path.len() < 2 {\n-        cx.sess.bug(fmt!(\"debuginfo::namespace_for_external_item() - Invalid item_path: %s\",\n+        cx.sess.bug(format!(\"debuginfo::namespace_for_external_item() - Invalid item_path: {}\",\n             ast_map::path_to_str(*item_path, token::get_ident_interner())));\n     }\n "}, {"sha": "995b246788854b7cc972d9da04a067f8d327af52", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -169,7 +169,7 @@ pub enum Dest {\n impl Dest {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         match *self {\n-            SaveIn(v) => fmt!(\"SaveIn(%s)\", ccx.tn.val_to_str(v)),\n+            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n             Ignore => ~\"Ignore\"\n         }\n     }\n@@ -182,15 +182,15 @@ fn drop_and_cancel_clean(bcx: @mut Block, dat: Datum) -> @mut Block {\n }\n \n pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n-    debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n     let mut datum = unpack_datum!(bcx, trans_to_datum_unadjusted(bcx, expr));\n     let adjustment = match bcx.tcx().adjustments.find_copy(&expr.id) {\n         None => { return DatumBlock {bcx: bcx, datum: datum}; }\n         Some(adj) => { adj }\n     };\n-    debug!(\"unadjusted datum: %s\", datum.to_str(bcx.ccx()));\n+    debug2!(\"unadjusted datum: {}\", datum.to_str(bcx.ccx()));\n     match *adjustment {\n         AutoAddEnv(*) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n@@ -232,7 +232,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             };\n         }\n     }\n-    debug!(\"after adjustments, datum=%s\", datum.to_str(bcx.ccx()));\n+    debug2!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n     fn auto_ref(bcx: @mut Block, datum: Datum) -> DatumBlock {\n@@ -287,7 +287,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n+        debug2!(\"add_env(closure_ty={})\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, \"__adjust\", false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n         assert_eq!(datum.appropriate_mode(tcx), ByValue);\n@@ -311,7 +311,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                        source_datum: Datum) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"auto_borrow_obj(target=%s)\",\n+        debug2!(\"auto_borrow_obj(target={})\",\n                target_obj_ty.repr(tcx));\n \n         // Extract source store information\n@@ -320,7 +320,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             _ => {\n                 bcx.sess().span_bug(\n                     expr.span,\n-                    fmt!(\"auto_borrow_trait_obj expected a trait, found %s\",\n+                    format!(\"auto_borrow_trait_obj expected a trait, found {}\",\n                          source_datum.ty.repr(bcx.tcx())));\n             }\n         };\n@@ -432,7 +432,7 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n \n     let ty = expr_ty(bcx, expr);\n \n-    debug!(\"trans_into_unadjusted(expr=%s, dest=%s)\",\n+    debug2!(\"trans_into_unadjusted(expr={}, dest={})\",\n            bcx.expr_to_str(expr),\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -448,7 +448,7 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n     };\n \n     let kind = bcx.expr_kind(expr);\n-    debug!(\"expr kind = %?\", kind);\n+    debug2!(\"expr kind = {:?}\", kind);\n     return match kind {\n         ty::LvalueExpr => {\n             let datumblock = trans_lvalue_unadjusted(bcx, expr);\n@@ -490,7 +490,7 @@ fn trans_lvalue(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         Some(_) => {\n             bcx.sess().span_bug(\n                 expr.span,\n-                fmt!(\"trans_lvalue() called on an expression \\\n+                format!(\"trans_lvalue() called on an expression \\\n                       with adjustments\"));\n         }\n     };\n@@ -506,7 +506,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n     let mut bcx = bcx;\n \n-    debug!(\"trans_to_datum_unadjusted(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_to_datum_unadjusted(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n@@ -608,8 +608,8 @@ fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBloc\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_datum_unadjusted reached \\\n-                      fall-through case: %?\",\n+                format!(\"trans_rvalue_datum_unadjusted reached \\\n+                      fall-through case: {:?}\",\n                      expr.node));\n         }\n     }\n@@ -662,8 +662,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_stmt_unadjusted reached \\\n-                      fall-through case: %?\",\n+                format!(\"trans_rvalue_stmt_unadjusted reached \\\n+                      fall-through case: {:?}\",\n                      expr.node));\n         }\n     };\n@@ -718,7 +718,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n         ast::ExprFnBlock(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let sigil = ty::ty_closure_sigil(expr_ty);\n-            debug!(\"translating fn_block %s with type %s\",\n+            debug2!(\"translating fn_block {} with type {}\",\n                    expr_to_str(expr, tcx.sess.intr()),\n                    expr_ty.repr(tcx));\n             return closure::trans_expr_fn(bcx, sigil, decl, body,\n@@ -787,7 +787,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_dps_unadjusted reached fall-through case: %?\",\n+                format!(\"trans_rvalue_dps_unadjusted reached fall-through case: {:?}\",\n                      expr.node));\n         }\n     }\n@@ -836,8 +836,8 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n             return bcx;\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, fmt!(\n-                \"Non-DPS def %? referened by %s\",\n+            bcx.tcx().sess.span_bug(ref_expr.span, format!(\n+                \"Non-DPS def {:?} referened by {}\",\n                 def, bcx.node_id_to_str(ref_expr.id)));\n         }\n     }\n@@ -861,8 +861,8 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n                                              ref_expr.id)\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, fmt!(\n-                \"Non-DPS def %? referened by %s\",\n+            bcx.tcx().sess.span_bug(ref_expr.span, format!(\n+                \"Non-DPS def {:?} referened by {}\",\n                 def, bcx.node_id_to_str(ref_expr.id)));\n         }\n     };\n@@ -887,7 +887,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_lval\");\n     let mut bcx = bcx;\n \n-    debug!(\"trans_lvalue(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_lvalue(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n@@ -912,7 +912,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_lvalue reached fall-through case: %?\",\n+                format!(\"trans_lvalue reached fall-through case: {:?}\",\n                      expr.node));\n         }\n     };\n@@ -978,8 +978,8 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             base_datum.get_vec_base_and_len(bcx, index_expr.span,\n                                             index_expr.id, 0);\n \n-        debug!(\"trans_index: base %s\", bcx.val_to_str(base));\n-        debug!(\"trans_index: len %s\", bcx.val_to_str(len));\n+        debug2!(\"trans_index: base {}\", bcx.val_to_str(base));\n+        debug2!(\"trans_index: len {}\", bcx.val_to_str(len));\n \n         let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n         let bcx = do with_cond(bcx, bounds_check) |bcx| {\n@@ -1091,8 +1091,8 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n                     }\n                 }\n                 None => {\n-                    bcx.sess().bug(fmt!(\n-                        \"trans_local_var: no llval for upvar %? found\", nid));\n+                    bcx.sess().bug(format!(\n+                        \"trans_local_var: no llval for upvar {:?} found\", nid));\n                 }\n             }\n         }\n@@ -1106,13 +1106,13 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n                 Some(ref self_info) => *self_info,\n                 None => {\n-                    bcx.sess().bug(fmt!(\n+                    bcx.sess().bug(format!(\n                         \"trans_local_var: reference to self \\\n-                         out of context with id %?\", nid));\n+                         out of context with id {:?}\", nid));\n                 }\n             };\n \n-            debug!(\"def_self() reference, self_info.t=%s\",\n+            debug2!(\"def_self() reference, self_info.t={}\",\n                    self_info.t.repr(bcx.tcx()));\n \n             Datum {\n@@ -1122,8 +1122,8 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n             }\n         }\n         _ => {\n-            bcx.sess().unimpl(fmt!(\n-                \"unsupported def type in trans_local_var: %?\", def));\n+            bcx.sess().unimpl(format!(\n+                \"unsupported def type in trans_local_var: {:?}\", def));\n         }\n     };\n \n@@ -1133,12 +1133,12 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n         let v = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n-                bcx.sess().bug(fmt!(\n-                    \"trans_local_var: no llval for local/arg %? found\", nid));\n+                bcx.sess().bug(format!(\n+                    \"trans_local_var: no llval for local/arg {:?} found\", nid));\n             }\n         };\n         let ty = node_id_type(bcx, nid);\n-        debug!(\"take_local(nid=%?, v=%s, ty=%s)\",\n+        debug2!(\"take_local(nid={:?}, v={}, ty={})\",\n                nid, bcx.val_to_str(v), bcx.ty_to_str(ty));\n         Datum {\n             val: v,\n@@ -1164,8 +1164,8 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n             // We want the *variant* ID here, not the enum ID.\n             match node_id_opt {\n                 None => {\n-                    tcx.sess.bug(fmt!(\n-                        \"cannot get field types from the enum type %s \\\n+                    tcx.sess.bug(format!(\n+                        \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n                         ty.repr(tcx)));\n                 }\n@@ -1187,8 +1187,8 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n         }\n \n         _ => {\n-            tcx.sess.bug(fmt!(\n-                \"cannot get field types from the type %s\",\n+            tcx.sess.bug(format!(\n+                \"cannot get field types from the type {}\",\n                 ty.repr(tcx)));\n         }\n     }\n@@ -1733,14 +1733,14 @@ fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n                                               val_ty(lldiscrim_a),\n                                               lldiscrim_a, true),\n                     cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                    _ => ccx.sess.bug(fmt!(\"translating unsupported cast: \\\n-                                           %s (%?) -> %s (%?)\",\n+                    _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n+                                           {} ({:?}) -> {} ({:?})\",\n                                            t_in.repr(ccx.tcx), k_in,\n                                            t_out.repr(ccx.tcx), k_out))\n                 }\n             }\n-            _ => ccx.sess.bug(fmt!(\"translating unsupported cast: \\\n-                                   %s (%?) -> %s (%?)\",\n+            _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n+                                   {} ({:?}) -> {} ({:?})\",\n                                    t_in.repr(ccx.tcx), k_in,\n                                    t_out.repr(ccx.tcx), k_out))\n         };\n@@ -1757,7 +1757,7 @@ fn trans_assign_op(bcx: @mut Block,\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n-    debug!(\"trans_assign_op(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_lvalue_unadjusted(bcx, dst));"}, {"sha": "6ca0967f8eea827dda8bc1c24544c165ec6f4dfe", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -80,13 +80,13 @@ pub fn llvm_calling_convention(ccx: &mut CrateContext,\n         match *abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n-                ccx.sess.bug(fmt!(\"Asked to register intrinsic fn\"));\n+                ccx.sess.bug(format!(\"Asked to register intrinsic fn\"));\n             }\n \n             Rust => {\n                 // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n                 ccx.sess.unimpl(\n-                    fmt!(\"Foreign functions with Rust ABI\"));\n+                    format!(\"Foreign functions with Rust ABI\"));\n             }\n \n             Stdcall => lib::llvm::X86StdcallCallConv,\n@@ -110,9 +110,9 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n      * Just adds a LLVM global.\n      */\n \n-    debug!(\"register_foreign_item_fn(abis=%s, \\\n-            path=%s, \\\n-            foreign_item.id=%?)\",\n+    debug2!(\"register_foreign_item_fn(abis={}, \\\n+            path={}, \\\n+            foreign_item.id={:?})\",\n            abis.repr(ccx.tcx),\n            path.repr(ccx.tcx),\n            foreign_item.id);\n@@ -122,9 +122,9 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n             ccx.sess.fatal(\n-                fmt!(\"ABI `%s` has no suitable ABI \\\n+                format!(\"ABI `{}` has no suitable ABI \\\n                       for target architecture \\\n-                      in module %s\",\n+                      in module {}\",\n                      abis.user_string(ccx.tcx),\n                      ast_map::path_to_str(*path,\n                                           ccx.sess.intr())));\n@@ -165,9 +165,9 @@ pub fn trans_native_call(bcx: @mut Block,\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_native_call(callee_ty=%s, \\\n-            llfn=%s, \\\n-            llretptr=%s)\",\n+    debug2!(\"trans_native_call(callee_ty={}, \\\n+            llfn={}, \\\n+            llretptr={})\",\n            callee_ty.repr(tcx),\n            ccx.tn.val_to_str(llfn),\n            ccx.tn.val_to_str(llretptr));\n@@ -213,7 +213,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         // Does Rust pass this argument by pointer?\n         let rust_indirect = type_of::arg_is_indirect(ccx, fn_sig.inputs[i]);\n \n-        debug!(\"argument %u, llarg_rust=%s, rust_indirect=%b, arg_ty=%s\",\n+        debug2!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n                ccx.tn.val_to_str(llarg_rust),\n                rust_indirect,\n@@ -227,7 +227,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             llarg_rust = scratch;\n         }\n \n-        debug!(\"llarg_rust=%s (after indirection)\",\n+        debug2!(\"llarg_rust={} (after indirection)\",\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Check whether we need to do any casting\n@@ -236,7 +236,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             llarg_rust = BitCast(bcx, llarg_rust, foreignarg_ty.ptr_to());\n         }\n \n-        debug!(\"llarg_rust=%s (after casting)\",\n+        debug2!(\"llarg_rust={} (after casting)\",\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n@@ -247,7 +247,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             Load(bcx, llarg_rust)\n         };\n \n-        debug!(\"argument %u, llarg_foreign=%s\",\n+        debug2!(\"argument {}, llarg_foreign={}\",\n                i, ccx.tn.val_to_str(llarg_foreign));\n \n         llargs_foreign.push(llarg_foreign);\n@@ -258,7 +258,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n             ccx.sess.fatal(\n-                fmt!(\"ABI string `%s` has no suitable ABI \\\n+                format!(\"ABI string `{}` has no suitable ABI \\\n                       for target architecture\",\n                      fn_abis.user_string(ccx.tcx)));\n         }\n@@ -284,10 +284,10 @@ pub fn trans_native_call(bcx: @mut Block,\n         let llrust_ret_ty = llsig.llret_ty;\n         let llforeign_ret_ty = fn_type.ret_ty.ty;\n \n-        debug!(\"llretptr=%s\", ccx.tn.val_to_str(llretptr));\n-        debug!(\"llforeign_retval=%s\", ccx.tn.val_to_str(llforeign_retval));\n-        debug!(\"llrust_ret_ty=%s\", ccx.tn.type_to_str(llrust_ret_ty));\n-        debug!(\"llforeign_ret_ty=%s\", ccx.tn.type_to_str(llforeign_ret_ty));\n+        debug2!(\"llretptr={}\", ccx.tn.val_to_str(llretptr));\n+        debug2!(\"llforeign_retval={}\", ccx.tn.val_to_str(llforeign_retval));\n+        debug2!(\"llrust_ret_ty={}\", ccx.tn.type_to_str(llrust_ret_ty));\n+        debug2!(\"llforeign_ret_ty={}\", ccx.tn.type_to_str(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n             Store(bcx, llforeign_retval, llretptr);\n@@ -313,7 +313,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n             let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n             let llalign = uint::min(llforeign_align, llrust_align);\n-            debug!(\"llrust_size=%?\", llrust_size);\n+            debug2!(\"llrust_size={:?}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n                               C_uint(ccx, llrust_size), llalign as u32);\n         }\n@@ -372,7 +372,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                                         lib::llvm::CCallConv,\n                                         llfn_ty);\n     add_argument_attributes(&tys, llfn);\n-    debug!(\"register_rust_fn_with_foreign_abi(node_id=%?, llfn_ty=%s, llfn=%s)\",\n+    debug2!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n            node_id, ccx.tn.type_to_str(llfn_ty), ccx.tn.val_to_str(llfn));\n     llfn\n }\n@@ -416,14 +416,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                 f\n             }\n             _ => {\n-                ccx.sess.bug(fmt!(\"build_rust_fn: extern fn %s has ty %s, \\\n+                ccx.sess.bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                   expected a bare fn ty\",\n                                   path.repr(tcx),\n                                   t.repr(tcx)));\n             }\n         };\n \n-        debug!(\"build_rust_fn: path=%s id=%? t=%s\",\n+        debug2!(\"build_rust_fn: path={} id={:?} t={}\",\n                path.repr(tcx),\n                id,\n                t.repr(tcx));\n@@ -449,7 +449,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n         let tcx = ccx.tcx;\n \n-        debug!(\"build_wrap_fn(llrustfn=%s, llwrapfn=%s)\",\n+        debug2!(\"build_wrap_fn(llrustfn={}, llwrapfn={})\",\n                ccx.tn.val_to_str(llrustfn),\n                ccx.tn.val_to_str(llwrapfn));\n \n@@ -504,14 +504,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             // alloca some scratch space on the stack.\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {\n-                    debug!(\"out pointer, foreign=%s\",\n+                    debug2!(\"out pointer, foreign={}\",\n                            ccx.tn.val_to_str(llforeign_outptr));\n                     let llrust_retptr =\n                         llvm::LLVMBuildBitCast(builder,\n                                                llforeign_outptr,\n                                                llrust_ret_ty.ptr_to().to_ref(),\n                                                noname());\n-                    debug!(\"out pointer, foreign=%s (casted)\",\n+                    debug2!(\"out pointer, foreign={} (casted)\",\n                            ccx.tn.val_to_str(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n                     return_alloca = None;\n@@ -524,10 +524,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                                                       llrust_ret_ty.to_ref(),\n                                                       s))\n                     };\n-                    debug!(\"out pointer, \\\n-                            allocad=%s, \\\n-                            llrust_ret_ty=%s, \\\n-                            return_ty=%s\",\n+                    debug2!(\"out pointer, \\\n+                            allocad={}, \\\n+                            llrust_ret_ty={}, \\\n+                            return_ty={}\",\n                            ccx.tn.val_to_str(slot),\n                            ccx.tn.type_to_str(llrust_ret_ty),\n                            tys.fn_sig.output.repr(tcx));\n@@ -544,7 +544,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n \n         // Push an (null) env pointer\n         let env_pointer = base::null_env_ptr(ccx);\n-        debug!(\"env pointer=%s\", ccx.tn.val_to_str(env_pointer));\n+        debug2!(\"env pointer={}\", ccx.tn.val_to_str(env_pointer));\n         llrust_args.push(env_pointer);\n \n         // Build up the arguments to the call to the rust function.\n@@ -558,9 +558,9 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             let foreign_indirect = tys.fn_ty.attrs[foreign_index].is_some();\n             let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n \n-            debug!(\"llforeign_arg #%u: %s\",\n+            debug2!(\"llforeign_arg \\\\#{}: {}\",\n                    i, ccx.tn.val_to_str(llforeign_arg));\n-            debug!(\"rust_indirect = %b, foreign_indirect = %b\",\n+            debug2!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n \n             // Ensure that the foreign argument is indirect (by\n@@ -591,14 +591,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                 llvm::LLVMBuildLoad(builder, llforeign_arg, noname())\n             };\n \n-            debug!(\"llrust_arg #%u: %s\",\n+            debug2!(\"llrust_arg \\\\#{}: {}\",\n                    i, ccx.tn.val_to_str(llrust_arg));\n             llrust_args.push(llrust_arg);\n         }\n \n         // Perform the call itself\n         let llrust_ret_val = do llrust_args.as_imm_buf |ptr, len| {\n-            debug!(\"calling llrustfn = %s\", ccx.tn.val_to_str(llrustfn));\n+            debug2!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n             llvm::LLVMBuildCall(builder, llrustfn, ptr,\n                                 len as c_uint, noname())\n         };\n@@ -723,11 +723,11 @@ fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n                                        llsig.llarg_tys,\n                                        llsig.llret_ty,\n                                        ret_def);\n-    debug!(\"foreign_types_for_fn_ty(\\\n-           ty=%s, \\\n-           llsig=%s -> %s, \\\n-           fn_ty=%s -> %s, \\\n-           ret_def=%b\",\n+    debug2!(\"foreign_types_for_fn_ty(\\\n+           ty={}, \\\n+           llsig={} -> {}, \\\n+           fn_ty={} -> {}, \\\n+           ret_def={}\",\n            ty.repr(ccx.tcx),\n            ccx.tn.types_to_str(llsig.llarg_tys),\n            ccx.tn.type_to_str(llsig.llret_ty),"}, {"sha": "d420514e84f7f7bcc3da989561593fb1b23d37cf", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -213,51 +213,51 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n         match ti.take_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"take\");\n             ti.take_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, \"take\");\n-            debug!(\"--- lazily_emit_tydesc_glue TAKE %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n         match ti.drop_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue DROP %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"drop\");\n             ti.drop_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n-            debug!(\"--- lazily_emit_tydesc_glue DROP %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n         match ti.free_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue FREE %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"free\");\n             ti.free_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, \"free\");\n-            debug!(\"--- lazily_emit_tydesc_glue FREE %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n         match ti.visit_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n@@ -658,7 +658,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n-    debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n+    debug2!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n     let gvar = do name.with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n@@ -679,7 +679,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n         free_glue: None,\n         visit_glue: None\n     };\n-    debug!(\"--- declare_tydesc %s\", ppaux::ty_to_str(ccx.tcx, t));\n+    debug2!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n     return inf;\n }\n \n@@ -689,7 +689,7 @@ pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n-    debug!(\"%s is for type %s\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n+    debug2!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n     note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(llfn, t);\n@@ -730,7 +730,7 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n                          name: &str)\n                       -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t));\n+    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n     let _s = StatRecorder::new(ccx, glue_name);\n     make_generic_glue_inner(ccx, t, llfn, helper)\n }\n@@ -789,8 +789,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               }\n             };\n \n-        debug!(\"ti.borrow_offset: %s\",\n-               ccx.tn.val_to_str(ti.borrow_offset));\n+        debug2!(\"ti.borrow_offset: {}\", ccx.tn.val_to_str(ti.borrow_offset));\n \n         let tydesc = C_named_struct(ccx.tydesc_type,\n                                     [ti.size, // size"}, {"sha": "de117a7c037e9cc6c8d4e33a96b47aa603456bf3", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -29,7 +29,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n     match ccx.external.find(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n-            debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+            debug2!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n                    ty::item_path_str(ccx.tcx, fn_id), node_id);\n             return local_def(node_id);\n         }\n@@ -132,7 +132,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n-                      debug!(\"calling inline trans_fn with self_ty %s\",\n+                      debug2!(\"calling inline trans_fn with self_ty {}\",\n                              ty_to_str(ccx.tcx, self_ty));\n                       match mth.explicit_self.node {\n                           ast::sty_value => impl_self(self_ty, ty::ByRef),"}, {"sha": "da71e99badba3a765ac6f9362dd7f57e5271eaff", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -39,7 +39,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        substs: @param_substs,\n                        attributes: &[ast::Attribute],\n                        ref_id: Option<ast::NodeId>) {\n-    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n+    debug2!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n     fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n         assert!(num_args <= 4);\n@@ -299,13 +299,13 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             if in_type_size != out_type_size {\n                 let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n                     ast_map::node_expr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n+                    _ => fail2!(\"transmute has non-expr arg\"),\n                 };\n                 let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n                 ccx.sess.span_fatal(sp,\n-                                    fmt!(\"transmute called on types with \\\n-                                          different sizes: %s (%u bit%s) to \\\n-                                          %s (%u bit%s)\",\n+                                    format!(\"transmute called on types with \\\n+                                          different sizes: {} ({} bit{}) to \\\n+                                          {} ({} bit{})\",\n                                          ty_to_str(ccx.tcx, in_type),\n                                          in_type_size,\n                                          pluralize(in_type_size),"}, {"sha": "ffb70abcec5fca810a163018c6e77ec539250374", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -19,7 +19,7 @@ pub trait LlvmRepr {\n impl<'self, T:LlvmRepr> LlvmRepr for &'self [T] {\n     fn llrepr(&self, ccx: &CrateContext) -> ~str {\n         let reprs = self.map(|t| t.llrepr(ccx));\n-        fmt!(\"[%s]\", reprs.connect(\",\"))\n+        format!(\"[{}]\", reprs.connect(\",\"))\n     }\n }\n "}, {"sha": "03eb4f18784d5160cb1b2b2c3f2fe4284f4045d6", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -55,7 +55,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"impl::trans_impl\");\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_impl(path=%s, name=%s, id=%?)\",\n+    debug2!(\"trans_impl(path={}, name={}, id={:?})\",\n            path.repr(tcx), name.repr(tcx), id);\n \n     // Both here and below with generic methods, be sure to recurse and look for\n@@ -117,7 +117,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n                 ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n             }\n         };\n-        debug!(\"calling trans_fn with self_ty %s\",\n+        debug2!(\"calling trans_fn with self_ty {}\",\n                self_ty.repr(ccx.tcx));\n         match method.explicit_self.node {\n           ast::sty_value => impl_self(self_ty, ty::ByRef),\n@@ -161,7 +161,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                            -> Callee {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n \n-    debug!(\"trans_method_callee(callee_id=%?, this=%s, mentry=%s)\",\n+    debug2!(\"trans_method_callee(callee_id={:?}, this={}, mentry={})\",\n            callee_id,\n            bcx.expr_to_str(this),\n            mentry.repr(bcx.tcx()));\n@@ -199,7 +199,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n-                None => fail!(\"trans_method_callee: missing param_substs\")\n+                None => fail2!(\"trans_method_callee: missing param_substs\")\n             }\n         }\n \n@@ -220,8 +220,8 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n     let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_static_method_callee(method_id=%?, trait_id=%s, \\\n-            callee_id=%?)\",\n+    debug2!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n+            callee_id={:?})\",\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n            callee_id);\n@@ -250,17 +250,17 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(trait_method).ident\n             }\n-            _ => fail!(\"callee is not a trait method\")\n+            _ => fail2!(\"callee is not a trait method\")\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n         match path[path.len()-1] {\n             path_pretty_name(s, _) | path_name(s) => { s }\n-            path_mod(_) => { fail!(\"path doesn't have a name?\") }\n+            path_mod(_) => { fail2!(\"path doesn't have a name?\") }\n         }\n     };\n-    debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n-            name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n+    debug2!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\\n+            name={}\", method_id, callee_id, ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n@@ -287,7 +287,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n-            fail!(\"vtable_param left in monomorphized \\\n+            fail2!(\"vtable_param left in monomorphized \\\n                    function's vtable substs\");\n         }\n     }\n@@ -362,7 +362,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n           }\n       }\n       typeck::vtable_param(*) => {\n-          fail!(\"vtable_param left in monomorphized function's vtable substs\");\n+          fail2!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n     };\n \n@@ -395,13 +395,13 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n     let method = ty::method(ccx.tcx, mth_did);\n     let n_m_tps = method.generics.type_param_defs.len();\n     let node_substs = node_id_type_params(bcx, callee_id);\n-    debug!(\"rcvr_substs=%?\", rcvr_substs.repr(ccx.tcx));\n+    debug2!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n                       node_substs.tailn(node_substs.len() - n_m_tps));\n-    debug!(\"n_m_tps=%?\", n_m_tps);\n-    debug!(\"node_substs=%?\", node_substs.repr(ccx.tcx));\n-    debug!(\"ty_substs=%?\", ty_substs.repr(ccx.tcx));\n+    debug2!(\"n_m_tps={:?}\", n_m_tps);\n+    debug2!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n+    debug2!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -474,13 +474,13 @@ pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"(translating trait callee) loading second index from pair\");\n+    debug2!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n \n     // Load the function from the vtable and cast it to the expected type.\n-    debug!(\"(translating trait callee) loading method\");\n+    debug2!(\"(translating trait callee) loading method\");\n     let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n@@ -524,7 +524,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n         }\n \n         // can't this be checked at the callee?\n-        _ => fail!(\"vtable_id\")\n+        _ => fail2!(\"vtable_id\")\n     }\n }\n \n@@ -578,7 +578,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n \n         let tbl = C_struct(components);\n         let sym = token::gensym(\"vtable\");\n-        let vt_gvar = do fmt!(\"vtable%u\", sym).with_c_str |buf| {\n+        let vt_gvar = do format!(\"vtable{}\", sym).with_c_str |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n@@ -611,15 +611,15 @@ fn emit_vtable_methods(bcx: @mut Block,\n         // the method type from the impl to substitute into.\n         let m_id = method_with_name(ccx, impl_id, ident.name);\n         let m = ty::method(tcx, m_id);\n-        debug!(\"(making impl vtable) emitting method %s at subst %s\",\n+        debug2!(\"(making impl vtable) emitting method {} at subst {}\",\n                m.repr(tcx),\n                substs.repr(tcx));\n         let fty = ty::subst_tps(tcx,\n                                 substs,\n                                 None,\n                                 ty::mk_bare_fn(tcx, m.fty.clone()));\n         if m.generics.has_type_params() || ty::type_has_self(fty) {\n-            debug!(\"(making impl vtable) method has self or type params: %s\",\n+            debug2!(\"(making impl vtable) method has self or type params: {}\",\n                    tcx.sess.str_of(ident));\n             C_null(Type::nil().ptr_to())\n         } else {"}, {"sha": "79b3453037d103b8a0f392708a62ef44669cff1b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -36,12 +36,12 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool)\n {\n-    debug!(\"monomorphic_fn(\\\n-            fn_id=%s, \\\n-            real_substs=%s, \\\n-            vtables=%s, \\\n-            self_vtable=%s, \\\n-            ref_id=%?)\",\n+    debug2!(\"monomorphic_fn(\\\n+            fn_id={}, \\\n+            real_substs={}, \\\n+            vtables={}, \\\n+            self_vtable={}, \\\n+            ref_id={:?})\",\n            fn_id.repr(ccx.tcx),\n            real_substs.repr(ccx.tcx),\n            vtables.repr(ccx.tcx),\n@@ -68,17 +68,17 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         must_cast = true;\n     }\n \n-    debug!(\"monomorphic_fn(\\\n-            fn_id=%s, \\\n-            psubsts=%s, \\\n-            hash_id=%?)\",\n+    debug2!(\"monomorphic_fn(\\\n+            fn_id={}, \\\n+            psubsts={}, \\\n+            hash_id={:?})\",\n            fn_id.repr(ccx.tcx),\n            psubsts.repr(ccx.tcx),\n            hash_id);\n \n     match ccx.monomorphized.find(&hash_id) {\n       Some(&val) => {\n-        debug!(\"leaving monomorphic fn %s\",\n+        debug2!(\"leaving monomorphic fn {}\",\n                ty::item_path_str(ccx.tcx, fn_id));\n         return (val, must_cast);\n       }\n@@ -95,7 +95,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let map_node = session::expect(\n         ccx.sess,\n         ccx.tcx.items.find_copy(&fn_id.node),\n-        || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n+        || format!(\"While monomorphizing {:?}, couldn't find it in the item map \\\n                  (may have attempted to monomorphize an item \\\n                  defined in a different crate?)\", fn_id));\n     // Get the path so that we can create a symbol\n@@ -140,7 +140,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n-    debug!(\"monomorphic_fn about to subst into %s\", llitem_ty.repr(ccx.tcx));\n+    debug2!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n     let mono_ty = match is_static_provided {\n         None => ty::subst_tps(ccx.tcx, psubsts.tys,\n                               psubsts.self_ty, llitem_ty),\n@@ -164,7 +164,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                 (psubsts.tys.slice(0, idx) +\n                  &[psubsts.self_ty.unwrap()] +\n                  psubsts.tys.tailn(idx));\n-            debug!(\"static default: changed substitution to %s\",\n+            debug2!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx));\n \n             ty::subst_tps(ccx.tcx, substs, None, llitem_ty)\n@@ -176,7 +176,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n             f\n         }\n-        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+        _ => fail2!(\"expected bare rust fn or an intrinsic\")\n     };\n \n     ccx.stats.n_monos += 1;\n@@ -197,7 +197,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let mut pt = (*pt).clone();\n     pt.push(elt);\n     let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n-    debug!(\"monomorphize_fn mangled to %s\", s);\n+    debug2!(\"monomorphize_fn mangled to {}\", s);\n \n     let mk_lldecl = || {\n         let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n@@ -285,12 +285,12 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_block(*) |\n       ast_map::node_callee_scope(*) |\n       ast_map::node_local(*) => {\n-        ccx.tcx.sess.bug(fmt!(\"Can't monomorphize a %?\", map_node))\n+        ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\", map_node))\n       }\n     };\n     ccx.monomorphizing.insert(fn_id, depth);\n \n-    debug!(\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id));\n+    debug2!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx, fn_id));\n     (lldecl, must_cast)\n }\n \n@@ -302,7 +302,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n     let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n     let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match substs.vtables {\n       Some(vts) => {\n-        debug!(\"make_mono_id vtables=%s substs=%s\",\n+        debug2!(\"make_mono_id vtables={} substs={}\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n         let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n         vts_iter.zip(substs_iter).map(|(vtable, subst)| {"}, {"sha": "b63533b1559d3017fc33b5ac7414fea1b625e84b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -93,15 +93,15 @@ impl Reflector {\n         let tcx = self.bcx.tcx();\n         let mth_idx = ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n-            *self.visitor_methods).expect(fmt!(\"Couldn't find visit method \\\n-                                                for %s\", ty_name));\n+            *self.visitor_methods).expect(format!(\"Couldn't find visit method \\\n+                                                for {}\", ty_name));\n         let mth_ty =\n             ty::mk_bare_fn(tcx, self.visitor_methods[mth_idx].fty.clone());\n         let v = self.visitor_val;\n-        debug!(\"passing %u args:\", args.len());\n+        debug2!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n         for (i, a) in args.iter().enumerate() {\n-            debug!(\"arg %u: %s\", i, bcx.val_to_str(*a));\n+            debug2!(\"arg {}: {}\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n         let result = unpack_result!(bcx, callee::trans_call_inner(\n@@ -151,7 +151,7 @@ impl Reflector {\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n         let tcx = bcx.ccx().tcx;\n-        debug!(\"reflect::visit_ty %s\", ty_to_str(bcx.ccx().tcx, t));\n+        debug2!(\"reflect::visit_ty {}\", ty_to_str(bcx.ccx().tcx, t));\n \n         match ty::get(t).sty {\n           ty::ty_bot => self.leaf(\"bot\"),"}, {"sha": "896ce4be33726bc77e59ea9d9ccfe58a6fd3f4f7", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -149,7 +149,7 @@ pub struct VecTypes {\n \n impl VecTypes {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n+        format!(\"VecTypes \\\\{vec_ty={}, unit_ty={}, llunit_ty={}, llunit_size={}\\\\}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),\n              ccx.tn.type_to_str(self.llunit_ty),\n@@ -169,7 +169,7 @@ pub fn trans_fixed_vstore(bcx: @mut Block,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(vstore_expr=%s, dest=%?)\",\n+    debug2!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n \n@@ -199,7 +199,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n \n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_slice_vstore(vstore_expr=%s, dest=%s)\",\n+    debug2!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(ccx));\n     let _indenter = indenter();\n \n@@ -214,7 +214,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"vt=%s, count=%?\", vt.to_str(ccx), count);\n+    debug2!(\"vt={}, count={:?}\", vt.to_str(ccx), count);\n \n     // Make a fixed-length backing array and allocate it on the stack.\n     let llcount = C_uint(ccx, count);\n@@ -256,7 +256,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n     // different from trans_slice_vstore() above because it does need to copy\n     // the content anywhere.\n \n-    debug!(\"trans_lit_str(lit_expr=%s, dest=%s)\",\n+    debug2!(\"trans_lit_str(lit_expr={}, dest={})\",\n            bcx.expr_to_str(lit_expr),\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -287,7 +287,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n     // appropriate heap and write the array elements into them.\n \n-    debug!(\"trans_uniq_or_managed_vstore(vstore_expr=%s, heap=%?)\",\n+    debug2!(\"trans_uniq_or_managed_vstore(vstore_expr={}, heap={:?})\",\n            bcx.expr_to_str(vstore_expr), heap);\n     let _indenter = indenter();\n \n@@ -318,7 +318,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n                 _ => {}\n             }\n         }\n-        heap_exchange_closure => fail!(\"vectors use exchange_alloc\"),\n+        heap_exchange_closure => fail2!(\"vectors use exchange_alloc\"),\n         heap_managed | heap_managed_unique => {}\n     }\n \n@@ -330,7 +330,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     add_clean_free(bcx, val, heap);\n     let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val, vt.vec_ty));\n \n-    debug!(\"alloc_vec() returned val=%s, dataptr=%s\",\n+    debug2!(\"alloc_vec() returned val={}, dataptr={}\",\n            bcx.val_to_str(val), bcx.val_to_str(dataptr));\n \n     let bcx = write_content(bcx, &vt, vstore_expr,\n@@ -350,7 +350,7 @@ pub fn write_content(bcx: @mut Block,\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt=%s, dest=%s, vstore_expr=%?)\",\n+    debug2!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n            vt.to_str(bcx.ccx()),\n            dest.to_str(bcx.ccx()),\n            bcx.expr_to_str(vstore_expr));\n@@ -383,7 +383,7 @@ pub fn write_content(bcx: @mut Block,\n                     let mut temp_cleanups = ~[];\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n-                        debug!(\"writing index %? with lleltptr=%?\",\n+                        debug2!(\"writing index {:?} with lleltptr={:?}\",\n                                i, bcx.val_to_str(lleltptr));\n                         bcx = expr::trans_into(bcx, *element,\n                                                SaveIn(lleltptr));"}, {"sha": "4a7351c207dc6a247d2be0c32fa8309d6d8de7a7", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -364,7 +364,7 @@ impl Type {\n             Double => 64,\n             X86_FP80 => 80,\n             FP128 | PPC_FP128 => 128,\n-            _ => fail!(\"llvm_float_width called on a non-float type\")\n+            _ => fail2!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n }"}, {"sha": "72b7281148c3d3e1b3ee02253838d0cc97c814b7", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -162,7 +162,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n-            cx.tcx.sess.bug(fmt!(\"fictitious type %? in sizing_type_of()\", ty::get(t).sty))\n+            cx.tcx.sess.bug(format!(\"fictitious type {:?} in sizing_type_of()\", ty::get(t).sty))\n         }\n     };\n \n@@ -172,7 +172,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n-    debug!(\"type_of %?: %?\", t, ty::get(t));\n+    debug2!(\"type_of {:?}: {:?}\", t, ty::get(t));\n \n     // Check the cache.\n     match cx.lltypes.find(&t) {\n@@ -335,9 +335,9 @@ pub fn llvm_type_name(cx: &CrateContext,\n     let tstr = ppaux::parameterized(cx.tcx, ty::item_path_str(cx.tcx, did),\n                                     &ty::NonerasedRegions(opt_vec::Empty), tps);\n     if did.crate == 0 {\n-        fmt!(\"%s.%s\", name, tstr)\n+        format!(\"{}.{}\", name, tstr)\n     } else {\n-        fmt!(\"%s.%s[#%d]\", name, tstr, did.crate)\n+        format!(\"{}.{}[\\\\#{}]\", name, tstr, did.crate)\n     }\n }\n "}, {"sha": "f6c1741a9bd6e2993395f5228d0c720b6f9e5886", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -39,7 +39,7 @@ pub fn root_and_write_guard(datum: &Datum,\n                             expr_id: ast::NodeId,\n                             derefs: uint) -> @mut Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n-    debug!(\"write_guard::root_and_write_guard(key=%?)\", key);\n+    debug2!(\"write_guard::root_and_write_guard(key={:?})\", key);\n \n     // root the autoderef'd value, if necessary:\n     //\n@@ -66,7 +66,7 @@ pub fn return_to_mut(mut bcx: @mut Block,\n                      bits_val_ref: ValueRef,\n                      filename_val: ValueRef,\n                      line_val: ValueRef) -> @mut Block {\n-    debug!(\"write_guard::return_to_mut(root_key=%?, %s, %s, %s)\",\n+    debug2!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n            root_key,\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n@@ -111,13 +111,13 @@ fn root(datum: &Datum,\n     //! case, we will call this function, which will stash a copy\n     //! away until we exit the scope `scope_id`.\n \n-    debug!(\"write_guard::root(root_key=%?, root_info=%?, datum=%?)\",\n+    debug2!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n            root_key, root_info, datum.to_str(bcx.ccx()));\n \n     if bcx.sess().trace() {\n         trans_trace(\n             bcx, None,\n-            (fmt!(\"preserving until end of scope %d\",\n+            (format!(\"preserving until end of scope {}\",\n                   root_info.scope)).to_managed());\n     }\n \n@@ -184,7 +184,7 @@ fn root(datum: &Datum,\n fn perform_write_guard(datum: &Datum,\n                        bcx: @mut Block,\n                        span: Span) -> @mut Block {\n-    debug!(\"perform_write_guard\");\n+    debug2!(\"perform_write_guard\");\n \n     let llval = datum.to_value_llval(bcx);\n     let (filename, line) = filename_and_line_num_from_span(bcx, span);"}, {"sha": "ef6809c15c8955ed79e6cf35f46073e4e9acc826", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -794,31 +794,31 @@ impl Vid for TyVid {\n }\n \n impl ToStr for TyVid {\n-    fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { format!(\"<V{}>\", self.to_uint()) }\n }\n \n impl Vid for IntVid {\n     fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for IntVid {\n-    fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { format!(\"<VI{}>\", self.to_uint()) }\n }\n \n impl Vid for FloatVid {\n     fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for FloatVid {\n-    fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { format!(\"<VF{}>\", self.to_uint()) }\n }\n \n impl Vid for RegionVid {\n     fn to_uint(&self) -> uint { self.id }\n }\n \n impl ToStr for RegionVid {\n-    fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n+    fn to_str(&self) -> ~str { format!(\"{:?}\", self.id) }\n }\n \n impl ToStr for FnSig {\n@@ -1515,7 +1515,7 @@ pub fn fold_regions(\n     fldr: &fn(r: Region, in_fn: bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n                fldr: &fn(Region, bool) -> Region) -> t {\n-        debug!(\"do_fold(ty=%s, in_fn=%b)\", ty_to_str(cx, ty), in_fn);\n+        debug2!(\"do_fold(ty={}, in_fn={})\", ty_to_str(cx, ty), in_fn);\n         if !type_has_regions(ty) { return ty; }\n         fold_regions_and_ty(\n             cx, ty,\n@@ -1656,7 +1656,7 @@ pub fn simd_type(cx: ctxt, ty: t) -> t {\n             let fields = lookup_struct_fields(cx, did);\n             lookup_field_type(cx, did, fields[0].id, substs)\n         }\n-        _ => fail!(\"simd_type called on invalid type\")\n+        _ => fail2!(\"simd_type called on invalid type\")\n     }\n }\n \n@@ -1666,14 +1666,14 @@ pub fn simd_size(cx: ctxt, ty: t) -> uint {\n             let fields = lookup_struct_fields(cx, did);\n             fields.len()\n         }\n-        _ => fail!(\"simd_size called on invalid type\")\n+        _ => fail2!(\"simd_size called on invalid type\")\n     }\n }\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n     match get(ty).sty {\n       ty_tup(ref ts) => return ts[i],\n-      _ => fail!(\"get_element_type called on invalid type\")\n+      _ => fail2!(\"get_element_type called on invalid type\")\n     }\n }\n \n@@ -1950,7 +1950,7 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n \n impl ToStr for TypeContents {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"TypeContents(%s)\", self.bits.to_str_radix(2))\n+        format!(\"TypeContents({})\", self.bits.to_str_radix(2))\n     }\n }\n \n@@ -2324,7 +2324,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         let mut tc = TC_ALL;\n         do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n-            debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n+            debug2!(\"tc = {}, bound = {:?}\", tc.to_str(), bound);\n             tc = tc - match bound {\n                 BoundStatic => TypeContents::nonstatic(cx),\n                 BoundSend => TypeContents::nonsendable(cx),\n@@ -2334,7 +2334,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             };\n         }\n \n-        debug!(\"result = %s\", tc.to_str());\n+        debug2!(\"result = {}\", tc.to_str());\n         return tc;\n \n         // Iterates over all builtin bounds on the type parameter def, including\n@@ -2364,7 +2364,7 @@ pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: ctxt, seen: &mut ~[DefId],\n                      r_ty: t, ty: t) -> bool {\n-        debug!(\"type_requires(%s, %s)?\",\n+        debug2!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n@@ -2373,7 +2373,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 subtypes_require(cx, seen, r_ty, ty)\n         };\n \n-        debug!(\"type_requires(%s, %s)? %b\",\n+        debug2!(\"type_requires({}, {})? {}\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty),\n                r);\n@@ -2382,7 +2382,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n     fn subtypes_require(cx: ctxt, seen: &mut ~[DefId],\n                         r_ty: t, ty: t) -> bool {\n-        debug!(\"subtypes_require(%s, %s)?\",\n+        debug2!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n@@ -2456,7 +2456,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             }\n         };\n \n-        debug!(\"subtypes_require(%s, %s)? %b\",\n+        debug2!(\"subtypes_require({}, {})? {}\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty),\n                r);\n@@ -2473,7 +2473,7 @@ pub fn type_structurally_contains(cx: ctxt,\n                                   test: &fn(x: &sty) -> bool)\n                                -> bool {\n     let sty = &get(ty).sty;\n-    debug!(\"type_structurally_contains: %s\",\n+    debug2!(\"type_structurally_contains: {}\",\n            ::util::ppaux::ty_to_str(cx, ty));\n     if test(sty) { return true; }\n     match *sty {\n@@ -2786,18 +2786,18 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n-           fmt!(\"node_id_to_trait_ref: no trait ref for node `%s`\",\n+           format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n                 ast_map::node_id_to_str(cx.items, id,\n                                         token::get_ident_interner())))\n     }\n }\n \n pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n-    //printfln!(\"%?/%?\", id, cx.node_types.len());\n+    //printfln!(\"{:?}/{:?}\", id, cx.node_types.len());\n     match cx.node_types.find(&(id as uint)) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n-           fmt!(\"node_id_to_type: no type for node `%s`\",\n+           format!(\"node_id_to_type: no type for node `{}`\",\n                 ast_map::node_id_to_str(cx.items, id,\n                                         token::get_ident_interner())))\n     }\n@@ -2820,7 +2820,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n         ref s => {\n-            fail!(\"ty_fn_sig() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2831,7 +2831,7 @@ pub fn ty_fn_args(fty: t) -> ~[t] {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n         ref s => {\n-            fail!(\"ty_fn_args() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_args() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2840,7 +2840,7 @@ pub fn ty_closure_sigil(fty: t) -> Sigil {\n     match get(fty).sty {\n         ty_closure(ref f) => f.sigil,\n         ref s => {\n-            fail!(\"ty_closure_sigil() called on non-closure type: %?\", s)\n+            fail2!(\"ty_closure_sigil() called on non-closure type: {:?}\", s)\n         }\n     }\n }\n@@ -2850,7 +2850,7 @@ pub fn ty_fn_purity(fty: t) -> ast::purity {\n         ty_bare_fn(ref f) => f.purity,\n         ty_closure(ref f) => f.purity,\n         ref s => {\n-            fail!(\"ty_fn_purity() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_purity() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2860,7 +2860,7 @@ pub fn ty_fn_ret(fty: t) -> t {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n         ref s => {\n-            fail!(\"ty_fn_ret() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2877,7 +2877,7 @@ pub fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n         ty_evec(_, vstore) => vstore,\n         ty_estr(vstore) => vstore,\n-        ref s => fail!(\"ty_vstore() called on invalid sty: %?\", s)\n+        ref s => fail2!(\"ty_vstore() called on invalid sty: {:?}\", s)\n     }\n }\n \n@@ -2891,7 +2891,7 @@ pub fn ty_region(tcx: ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                fmt!(\"ty_region() invoked on in appropriate ty: %?\", s));\n+                format!(\"ty_region() invoked on in appropriate ty: {:?}\", s));\n         }\n     }\n }\n@@ -2902,7 +2902,7 @@ pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n         ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..*f}),\n         ref s => {\n             cx.sess.bug(\n-                fmt!(\"ty_fn_sig() called on non-fn type: %?\", s));\n+                format!(\"ty_fn_sig() called on non-fn type: {:?}\", s));\n         }\n     }\n }\n@@ -2921,8 +2921,8 @@ pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n             })\n         }\n         _ => {\n-            tcx.sess.bug(fmt!(\n-                \"replace_fn_ret() invoked with non-fn-type: %s\",\n+            tcx.sess.bug(format!(\n+                \"replace_fn_ret() invoked with non-fn-type: {}\",\n                 ty_to_str(tcx, fn_type)));\n         }\n     }\n@@ -3003,7 +3003,7 @@ pub fn adjust_ty(cx: ctxt,\n                 }\n                 ref b => {\n                     cx.sess.bug(\n-                        fmt!(\"add_env adjustment on non-bare-fn: %?\", b));\n+                        format!(\"add_env adjustment on non-bare-fn: {:?}\", b));\n                 }\n             }\n         }\n@@ -3018,7 +3018,7 @@ pub fn adjust_ty(cx: ctxt,\n                         None => {\n                             cx.sess.span_bug(\n                                 span,\n-                                fmt!(\"The %uth autoderef failed: %s\",\n+                                format!(\"The {}th autoderef failed: {}\",\n                                      i, ty_to_str(cx,\n                                                   adjusted_ty)));\n                         }\n@@ -3075,7 +3075,7 @@ pub fn adjust_ty(cx: ctxt,\n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    fmt!(\"borrow-vec associated with bad sty: %?\",\n+                    format!(\"borrow-vec associated with bad sty: {:?}\",\n                          s));\n             }\n         }\n@@ -3094,7 +3094,7 @@ pub fn adjust_ty(cx: ctxt,\n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    fmt!(\"borrow-fn associated with bad sty: %?\",\n+                    format!(\"borrow-fn associated with bad sty: {:?}\",\n                          s));\n             }\n         }\n@@ -3110,7 +3110,7 @@ pub fn adjust_ty(cx: ctxt,\n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    fmt!(\"borrow-trait-obj associated with bad sty: %?\",\n+                    format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n                          s));\n             }\n         }\n@@ -3185,8 +3185,8 @@ pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n     match tcx.def_map.find(&expr.id) {\n         Some(&def) => def,\n         None => {\n-            tcx.sess.span_bug(expr.span, fmt!(\n-                \"No def-map entry for expr %?\", expr.id));\n+            tcx.sess.span_bug(expr.span, format!(\n+                \"No def-map entry for expr {:?}\", expr.id));\n         }\n     }\n }\n@@ -3244,8 +3244,8 @@ pub fn expr_kind(tcx: ctxt,\n                 ast::DefSelf(*) => LvalueExpr,\n \n                 def => {\n-                    tcx.sess.span_bug(expr.span, fmt!(\n-                        \"Uncategorized def for expr %?: %?\",\n+                    tcx.sess.span_bug(expr.span, format!(\n+                        \"Uncategorized def for expr {:?}: {:?}\",\n                         expr.id, def));\n                 }\n             }\n@@ -3311,7 +3311,7 @@ pub fn expr_kind(tcx: ctxt,\n             RvalueStmtExpr\n         }\n \n-        ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+        ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n         ast::ExprLogLevel |\n         ast::ExprLit(_) | // Note: lit_str is carved out above\n@@ -3339,7 +3339,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n       ast::StmtDecl(_, id) | StmtExpr(_, id) | StmtSemi(_, id) => {\n         return id;\n       }\n-      ast::StmtMac(*) => fail!(\"unexpanded macro in trans\")\n+      ast::StmtMac(*) => fail2!(\"unexpanded macro in trans\")\n     }\n }\n \n@@ -3353,8 +3353,8 @@ pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n-    tcx.sess.bug(fmt!(\n-        \"No field named `%s` found in the list of fields `%?`\",\n+    tcx.sess.bug(format!(\n+        \"No field named `{}` found in the list of fields `{:?}`\",\n         token::interner_get(name),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n@@ -3418,7 +3418,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n         ::util::ppaux::ty_to_str(cx, t)\n       }\n \n-      ty_enum(id, _) => fmt!(\"enum %s\", item_path_str(cx, id)),\n+      ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n       ty_box(_) => ~\"@-ptr\",\n       ty_uniq(_) => ~\"~-ptr\",\n       ty_evec(_, _) => ~\"vector\",\n@@ -3427,8 +3427,8 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_rptr(_, _) => ~\"&-ptr\",\n       ty_bare_fn(_) => ~\"extern fn\",\n       ty_closure(_) => ~\"fn\",\n-      ty_trait(id, _, _, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n-      ty_struct(id, _) => fmt!(\"struct %s\", item_path_str(cx, id)),\n+      ty_trait(id, _, _, _, _) => format!(\"trait {}\", item_path_str(cx, id)),\n+      ty_struct(id, _) => format!(\"struct {}\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n       ty_infer(TyVar(_)) => ~\"inferred type\",\n       ty_infer(IntVar(_)) => ~\"integral variable\",\n@@ -3461,19 +3461,19 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     match *err {\n         terr_mismatch => ~\"types differ\",\n         terr_purity_mismatch(values) => {\n-            fmt!(\"expected %s fn but found %s fn\",\n+            format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n         terr_abi_mismatch(values) => {\n-            fmt!(\"expected %s fn but found %s fn\",\n+            format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n         terr_onceness_mismatch(values) => {\n-            fmt!(\"expected %s fn but found %s fn\",\n+            format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n         terr_sigil_mismatch(values) => {\n-            fmt!(\"expected %s closure, found %s closure\",\n+            format!(\"expected {} closure, found {} closure\",\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n@@ -3483,97 +3483,97 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_ptr_mutability => ~\"pointers differ in mutability\",\n         terr_ref_mutability => ~\"references differ in mutability\",\n         terr_ty_param_size(values) => {\n-            fmt!(\"expected a type with %u type params \\\n-                  but found one with %u type params\",\n+            format!(\"expected a type with {} type params \\\n+                  but found one with {} type params\",\n                  values.expected, values.found)\n         }\n         terr_tuple_size(values) => {\n-            fmt!(\"expected a tuple with %u elements \\\n-                  but found one with %u elements\",\n+            format!(\"expected a tuple with {} elements \\\n+                  but found one with {} elements\",\n                  values.expected, values.found)\n         }\n         terr_record_size(values) => {\n-            fmt!(\"expected a record with %u fields \\\n-                  but found one with %u fields\",\n+            format!(\"expected a record with {} fields \\\n+                  but found one with {} fields\",\n                  values.expected, values.found)\n         }\n         terr_record_mutability => {\n             ~\"record elements differ in mutability\"\n         }\n         terr_record_fields(values) => {\n-            fmt!(\"expected a record with field `%s` but found one with field \\\n-                  `%s`\",\n+            format!(\"expected a record with field `{}` but found one with field \\\n+                  `{}`\",\n                  cx.sess.str_of(values.expected),\n                  cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n         terr_regions_does_not_outlive(*) => {\n-            fmt!(\"lifetime mismatch\")\n+            format!(\"lifetime mismatch\")\n         }\n         terr_regions_not_same(*) => {\n-            fmt!(\"lifetimes are not the same\")\n+            format!(\"lifetimes are not the same\")\n         }\n         terr_regions_no_overlap(*) => {\n-            fmt!(\"lifetimes do not intersect\")\n+            format!(\"lifetimes do not intersect\")\n         }\n         terr_regions_insufficiently_polymorphic(br, _) => {\n-            fmt!(\"expected bound lifetime parameter %s, \\\n+            format!(\"expected bound lifetime parameter {}, \\\n                   but found concrete lifetime\",\n                  bound_region_ptr_to_str(cx, br))\n         }\n         terr_regions_overly_polymorphic(br, _) => {\n-            fmt!(\"expected concrete lifetime, \\\n-                  but found bound lifetime parameter %s\",\n+            format!(\"expected concrete lifetime, \\\n+                  but found bound lifetime parameter {}\",\n                  bound_region_ptr_to_str(cx, br))\n         }\n         terr_vstores_differ(k, ref values) => {\n-            fmt!(\"%s storage differs: expected %s but found %s\",\n+            format!(\"{} storage differs: expected {} but found {}\",\n                  terr_vstore_kind_to_str(k),\n                  vstore_to_str(cx, (*values).expected),\n                  vstore_to_str(cx, (*values).found))\n         }\n         terr_trait_stores_differ(_, ref values) => {\n-            fmt!(\"trait storage differs: expected %s but found %s\",\n+            format!(\"trait storage differs: expected {} but found {}\",\n                  trait_store_to_str(cx, (*values).expected),\n                  trait_store_to_str(cx, (*values).found))\n         }\n         terr_in_field(err, fname) => {\n-            fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n+            format!(\"in field `{}`, {}\", cx.sess.str_of(fname),\n                  type_err_to_str(cx, err))\n         }\n         terr_sorts(values) => {\n-            fmt!(\"expected %s but found %s\",\n+            format!(\"expected {} but found {}\",\n                  ty_sort_str(cx, values.expected),\n                  ty_sort_str(cx, values.found))\n         }\n         terr_traits(values) => {\n-            fmt!(\"expected trait %s but found trait %s\",\n+            format!(\"expected trait {} but found trait {}\",\n                  item_path_str(cx, values.expected),\n                  item_path_str(cx, values.found))\n         }\n         terr_builtin_bounds(values) => {\n             if values.expected.is_empty() {\n-                fmt!(\"expected no bounds but found `%s`\",\n+                format!(\"expected no bounds but found `{}`\",\n                      values.found.user_string(cx))\n             } else if values.found.is_empty() {\n-                fmt!(\"expected bounds `%s` but found no bounds\",\n+                format!(\"expected bounds `{}` but found no bounds\",\n                      values.expected.user_string(cx))\n             } else {\n-                fmt!(\"expected bounds `%s` but found bounds `%s`\",\n+                format!(\"expected bounds `{}` but found bounds `{}`\",\n                      values.expected.user_string(cx),\n                      values.found.user_string(cx))\n             }\n         }\n         terr_integer_as_char => {\n-            fmt!(\"expected an integral type but found char\")\n+            format!(\"expected an integral type but found char\")\n         }\n         terr_int_mismatch(ref values) => {\n-            fmt!(\"expected %s but found %s\",\n+            format!(\"expected {} but found {}\",\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n         terr_float_mismatch(ref values) => {\n-            fmt!(\"expected %s but found %s\",\n+            format!(\"expected {} but found {}\",\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n@@ -3633,7 +3633,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n                 match ast_util::split_trait_methods(*ms) {\n                    (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n                 },\n-            _ => cx.sess.bug(fmt!(\"provided_trait_methods: %? is not a trait\",\n+            _ => cx.sess.bug(format!(\"provided_trait_methods: {:?} is not a trait\",\n                                   id))\n         }\n     } else {\n@@ -3690,7 +3690,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     }\n \n     if def_id.crate == ast::LOCAL_CRATE {\n-        fail!(\"No def'n found for %? in tcx.%s\", def_id, descr);\n+        fail2!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -3733,7 +3733,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         None => {}\n     }\n     let ret = if id.crate == ast::LOCAL_CRATE {\n-        debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n+        debug2!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n                                      node: ast::item_impl(_, ref opt_trait, _, _),\n@@ -3979,7 +3979,7 @@ pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::path {\n           }\n \n           ref node => {\n-            cx.sess.bug(fmt!(\"cannot find item_path for node %?\", node));\n+            cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n           }\n         }\n     }\n@@ -4031,7 +4031,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n                             cx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            cx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n+                            cx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n                         }\n                     },\n                     None => {}\n@@ -4111,7 +4111,7 @@ pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n                     attrs: ref attrs,\n                     _\n                 }, _)) => attr::contains_name(*attrs, attr),\n-            _ => tcx.sess.bug(fmt!(\"has_attr: %? is not an item\",\n+            _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n                                    did))\n         }\n     } else {\n@@ -4182,7 +4182,7 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n        }\n        _ => {\n            cx.sess.bug(\n-               fmt!(\"struct ID not bound to an item: %s\",\n+               format!(\"struct ID not bound to an item: {}\",\n                     ast_map::node_id_to_str(cx.items, did.node,\n                                             token::get_ident_interner())));\n        }\n@@ -4486,7 +4486,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n \n         // Add the given trait ty to the hash map\n         while i < trait_refs.len() {\n-            debug!(\"each_bound_trait_and_supertraits(i=%?, trait_ref=%s)\",\n+            debug2!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n                    i, trait_refs[i].repr(tcx));\n \n             if !f(trait_refs[i]) {\n@@ -4496,7 +4496,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n             for &supertrait_ref in supertrait_refs.iter() {\n-                debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n+                debug2!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n \n                 let d_id = supertrait_ref.def_id;"}, {"sha": "91bb4df301707c5764b5b70c51f8c5f677b3b3a7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -92,12 +92,12 @@ pub fn get_region_reporting_err(\n         result::Err(ref e) => {\n             let descr = match a_r {\n                 &None => ~\"anonymous lifetime\",\n-                &Some(ref a) => fmt!(\"lifetime %s\",\n+                &Some(ref a) => format!(\"lifetime {}\",\n                                 lifetime_to_str(a, tcx.sess.intr()))\n             };\n             tcx.sess.span_err(\n                 span,\n-                fmt!(\"Illegal %s: %s\",\n+                format!(\"Illegal {}: {}\",\n                      descr, e.msg));\n             e.replacement\n         }\n@@ -157,7 +157,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         (&None, &Some(_)) => {\n             tcx.sess.span_err(\n                 path.span,\n-                fmt!(\"no region bound is allowed on `%s`, \\\n+                format!(\"no region bound is allowed on `{}`, \\\n                       which is not declared as containing region pointers\",\n                      ty::item_path_str(tcx, def_id)));\n             opt_vec::Empty\n@@ -182,7 +182,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     if decl_generics.type_param_defs.len() != supplied_type_parameter_count {\n         this.tcx().sess.span_fatal(\n             path.span,\n-            fmt!(\"wrong number of type arguments: expected %u but found %u\",\n+            format!(\"wrong number of type arguments: expected {} but found {}\",\n                  decl_generics.type_param_defs.len(),\n                  supplied_type_parameter_count));\n     }\n@@ -428,7 +428,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n       ast::ty_path(ref path, ref bounds, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n-              ast_ty.span, fmt!(\"unbound path %s\",\n+              ast_ty.span, format!(\"unbound path {}\",\n                                 path_to_str(path, tcx.sess.intr()))),\n           Some(&d) => d\n         };\n@@ -446,8 +446,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n               let path_str = path_to_str(path, tcx.sess.intr());\n               tcx.sess.span_err(\n                   ast_ty.span,\n-                  fmt!(\"reference to trait `%s` where a type is expected; \\\n-                        try `@%s`, `~%s`, or `&%s`\",\n+                  format!(\"reference to trait `{}` where a type is expected; \\\n+                        try `@{}`, `~{}`, or `&{}`\",\n                        path_str, path_str, path_str, path_str));\n               ty::mk_err()\n           }\n@@ -498,7 +498,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n           }\n           _ => {\n             tcx.sess.span_fatal(ast_ty.span,\n-                                fmt!(\"found value name used as a type: %?\", a_def));\n+                                format!(\"found value name used as a type: {:?}\", a_def));\n           }\n         }\n       }\n@@ -521,8 +521,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n           Err(ref r) => {\n             tcx.sess.span_fatal(\n                 ast_ty.span,\n-                fmt!(\"expected constant expr for vector length: %s\",\n-                     *r));\n+                format!(\"expected constant expr for vector length: {}\", *r));\n           }\n         }\n       }\n@@ -583,7 +582,7 @@ pub fn bound_lifetimes<AC:AstConv>(\n         if special_idents.iter().any(|&i| i == ast_lifetime.ident) {\n             this.tcx().sess.span_err(\n                 ast_lifetime.span,\n-                fmt!(\"illegal lifetime parameter name: `%s`\",\n+                format!(\"illegal lifetime parameter name: `{}`\",\n                      lifetime_to_str(ast_lifetime, this.tcx().sess.intr())));\n         } else {\n             bound_lifetime_names.push(ast_lifetime.ident);\n@@ -637,7 +636,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     opt_self_info: Option<&SelfInfo>,\n     decl: &ast::fn_decl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n {\n-    debug!(\"ty_of_bare_fn\");\n+    debug2!(\"ty_of_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -718,7 +717,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     // names or they are provided, but not both.\n     assert!(lifetimes.is_empty() || expected_sig.is_none());\n \n-    debug!(\"ty_of_fn_decl\");\n+    debug2!(\"ty_of_fn_decl\");\n     let _i = indenter();\n \n     // resolve the function bound region in the original region\n@@ -807,7 +806,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n                         }\n                         tcx.sess.span_fatal(\n                             b.path.span,\n-                            fmt!(\"only the builtin traits can be used \\\n+                            format!(\"only the builtin traits can be used \\\n                                   as closure or object bounds\"));\n                     }\n                     ast::RegionTyParamBound => {"}, {"sha": "f022f2b3c4bce1c429fb30079450a16dc00948eb", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -166,7 +166,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n                                                        expected.map_move_default(~\"\", |e| {\n-                        fmt!(\"mismatched types: expected `%s` but found %s\",\n+                        format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n                              Some(expected), ~\"a structure pattern\",\n                              None);\n@@ -215,7 +215,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n                                                expected.map_move_default(~\"\", |e| {\n-                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                    format!(\"mismatched types: expected `{}` but found {}\",\n                          e, actual)})},\n                     Some(expected), ~\"an enum or structure pattern\",\n                     None);\n@@ -241,7 +241,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n     if arg_len > 0 {\n         // N-ary variant.\n         if arg_len != subpats_len {\n-            let s = fmt!(\"this pattern has %u field%s, but the corresponding %s has %u field%s\",\n+            let s = format!(\"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n                          subpats_len,\n                          if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n                          kind_name,\n@@ -260,7 +260,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n         }\n     } else if subpats_len > 0 {\n         tcx.sess.span_err(pat.span,\n-                          fmt!(\"this pattern has %u field%s, but the corresponding %s has no \\\n+                          format!(\"this pattern has {} field{}, but the corresponding {} has no \\\n                                 fields\",\n                                subpats_len,\n                                if subpats_len == 1u { \"\" } else { \"s\" },\n@@ -319,7 +319,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 // up its type won't fail\n                 check_pat(pcx, field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n-                    fmt!(\"struct `%s` does not have a field named `%s`\",\n+                    format!(\"struct `{}` does not have a field named `{}`\",\n                          name,\n                          tcx.sess.str_of(field.ident)));\n             }\n@@ -333,7 +333,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 loop;\n             }\n             tcx.sess.span_err(span,\n-                              fmt!(\"pattern does not mention field `%s`\",\n+                              format!(\"pattern does not mention field `{}`\",\n                                    token::interner_get(field.name)));\n         }\n     }\n@@ -358,7 +358,7 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n         Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n-                              fmt!(\"mismatched types: expected `%s` but found `%s`\",\n+                              format!(\"mismatched types: expected `{}` but found `{}`\",\n                                    fcx.infcx().ty_to_str(expected),\n                                    name));\n         }\n@@ -396,8 +396,8 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n         Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n-                              fmt!(\"mismatched types: expected `%s` but \\\n-                                    found `%s`\",\n+                              format!(\"mismatched types: expected `{}` but \\\n+                                    found `{}`\",\n                                    fcx.infcx().ty_to_str(expected),\n                                    name));\n         }\n@@ -428,8 +428,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         let e_ty =\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(end));\n-        debug!(\"pat_range beginning type: %?\", b_ty);\n-        debug!(\"pat_range ending type: %?\", e_ty);\n+        debug2!(\"pat_range beginning type: {:?}\", b_ty);\n+        debug2!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n             || ~\"mismatched types in range\")\n@@ -488,7 +488,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, typ);\n \n-        debug!(\"(checking match) writing type for pat id %d\", pat.id);\n+        debug2!(\"(checking match) writing type for pat id {}\", pat.id);\n \n         match sub {\n           Some(p) => check_pat(pcx, p, expected),\n@@ -520,7 +520,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                 |expected, actual| {\n                             expected.map_move_default(~\"\", |e| {\n-                                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                                    format!(\"mismatched types: expected `{}` but found {}\",\n                                          e, actual)})},\n                                          Some(expected), ~\"a structure pattern\",\n                                          None);\n@@ -567,7 +567,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                 // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n                 expected.map_move_default(~\"\", |e| {\n-                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                    format!(\"mismatched types: expected `{}` but found {}\",\n                                      e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n@@ -617,7 +617,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                   pat.span,\n                   |expected, actual| {\n                       expected.map_move_default(~\"\", |e| {\n-                          fmt!(\"mismatched types: expected `%s` but found %s\",\n+                          format!(\"mismatched types: expected `{}` but found {}\",\n                                e, actual)})},\n                   Some(expected),\n                   ~\"a vector pattern\",\n@@ -676,10 +676,10 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                 span,\n                 |expected, actual| {\n                     expected.map_move_default(~\"\", |e| {\n-                        fmt!(\"mismatched types: expected `%s` but found %s\",\n+                        format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n                 Some(expected),\n-                fmt!(\"%s pattern\", match pointer_kind {\n+                format!(\"{} pattern\", match pointer_kind {\n                     Managed => \"an @-box\",\n                     Send => \"a ~-box\",\n                     Borrowed => \"an &-pointer\""}, {"sha": "a4538c961fd6d1e611b4358b5bc3edf85071bf61", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -151,18 +151,18 @@ pub fn lookup(\n     };\n \n     let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n-    debug!(\"method lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n+    debug2!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n            self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n-    debug!(\"searching inherent candidates\");\n+    debug2!(\"searching inherent candidates\");\n     lcx.push_inherent_candidates(self_ty);\n     let mme = lcx.search(self_ty);\n     if mme.is_some() {\n         return mme;\n     }\n \n-    debug!(\"searching extension candidates\");\n+    debug2!(\"searching extension candidates\");\n     lcx.reset_candidates();\n     lcx.push_bound_candidates(self_ty);\n     lcx.push_extension_candidates();\n@@ -215,7 +215,7 @@ impl<'self> LookupContext<'self> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n-            debug!(\"loop: self_ty=%s autoderefs=%u\",\n+            debug2!(\"loop: self_ty={} autoderefs={}\",\n                    self.ty_to_str(self_ty), autoderefs);\n \n             match self.deref_args {\n@@ -397,7 +397,7 @@ impl<'self> LookupContext<'self> {\n     fn push_inherent_candidates_from_object(&self,\n                                             did: DefId,\n                                             substs: &ty::substs) {\n-        debug!(\"push_inherent_candidates_from_object(did=%s, substs=%s)\",\n+        debug2!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n                substs_to_str(self.tcx(), substs));\n         let _indenter = indenter();\n@@ -446,7 +446,7 @@ impl<'self> LookupContext<'self> {\n     fn push_inherent_candidates_from_param(&self,\n                                            rcvr_ty: ty::t,\n                                            param_ty: param_ty) {\n-        debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n+        debug2!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n         let _indenter = indenter();\n \n@@ -456,7 +456,7 @@ impl<'self> LookupContext<'self> {\n             None => {\n                 tcx.sess.span_bug(\n                     self.expr.span,\n-                    fmt!(\"No param def for %?\", param_ty));\n+                    format!(\"No param def for {:?}\", param_ty));\n             }\n         };\n \n@@ -523,11 +523,11 @@ impl<'self> LookupContext<'self> {\n                     let cand = mk_cand(bound_trait_ref, method,\n                                        pos, this_bound_idx);\n \n-                    debug!(\"pushing inherent candidate for param: %?\", cand);\n+                    debug2!(\"pushing inherent candidate for param: {:?}\", cand);\n                     self.inherent_candidates.push(cand);\n                 }\n                 None => {\n-                    debug!(\"trait doesn't contain method: %?\",\n+                    debug2!(\"trait doesn't contain method: {:?}\",\n                     bound_trait_ref.def_id);\n                     // check next trait or bound\n                 }\n@@ -557,7 +557,7 @@ impl<'self> LookupContext<'self> {\n         if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n-        debug!(\"push_candidates_from_impl: %s %s %s\",\n+        debug2!(\"push_candidates_from_impl: {} {} {}\",\n                token::interner_get(self.m_name),\n                impl_info.ident.repr(self.tcx()),\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n@@ -603,8 +603,8 @@ impl<'self> LookupContext<'self> {\n         match self.search_for_method(self_ty) {\n             None => None,\n             Some(mme) => {\n-                debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment (%u) to %d\",\n+                debug2!(\"(searching for autoderef'd method) writing \\\n+                       adjustment ({}) to {}\",\n                        autoderefs,\n                        self.self_expr.id);\n                 self.fcx.write_adjustment(self.self_expr.id, @autoadjust);\n@@ -795,7 +795,7 @@ impl<'self> LookupContext<'self> {\n \n             ty_opaque_closure_ptr(_) | ty_unboxed_vec(_) |\n             ty_opaque_box | ty_type | ty_infer(TyVar(_)) => {\n-                self.bug(fmt!(\"Unexpected type: %s\",\n+                self.bug(format!(\"Unexpected type: {}\",\n                               self.ty_to_str(self_ty)));\n             }\n         }\n@@ -832,22 +832,22 @@ impl<'self> LookupContext<'self> {\n \n     fn search_for_method(&self, rcvr_ty: ty::t)\n                              -> Option<method_map_entry> {\n-        debug!(\"search_for_method(rcvr_ty=%s)\", self.ty_to_str(rcvr_ty));\n+        debug2!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n         // I am not sure that inherent methods should have higher\n         // priority, but it is necessary ATM to handle some of the\n         // existing code.\n \n-        debug!(\"searching inherent candidates\");\n+        debug2!(\"searching inherent candidates\");\n         match self.consider_candidates(rcvr_ty, self.inherent_candidates) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n-        debug!(\"searching extension candidates\");\n+        debug2!(\"searching extension candidates\");\n         match self.consider_candidates(rcvr_ty, self.extension_candidates) {\n             None => {\n                 return None;\n@@ -896,7 +896,7 @@ impl<'self> LookupContext<'self> {\n             let mut j = i + 1;\n             while j < candidates.len() {\n                 let candidate_b = &candidates[j];\n-                debug!(\"attempting to merge %? and %?\",\n+                debug2!(\"attempting to merge {:?} and {:?}\",\n                        candidate_a, candidate_b);\n                 let candidates_same = match (&candidate_a.origin,\n                                              &candidate_b.origin) {\n@@ -936,7 +936,7 @@ impl<'self> LookupContext<'self> {\n         let tcx = self.tcx();\n         let fty = ty::mk_bare_fn(tcx, candidate.method_ty.fty.clone());\n \n-        debug!(\"confirm_candidate(expr=%s, candidate=%s, fty=%s)\",\n+        debug2!(\"confirm_candidate(expr={}, candidate={}, fty={})\",\n                self.expr.repr(tcx),\n                self.cand_to_str(candidate),\n                self.ty_to_str(fty));\n@@ -992,11 +992,11 @@ impl<'self> LookupContext<'self> {\n         };\n \n         // Compute the method type with type parameters substituted\n-        debug!(\"fty=%s all_substs=%s\",\n+        debug2!(\"fty={} all_substs={}\",\n                self.ty_to_str(fty),\n                ty::substs_to_str(tcx, &all_substs));\n         let fty = ty::subst(tcx, &all_substs, fty);\n-        debug!(\"after subst, fty=%s\", self.ty_to_str(fty));\n+        debug2!(\"after subst, fty={}\", self.ty_to_str(fty));\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n@@ -1005,7 +1005,7 @@ impl<'self> LookupContext<'self> {\n             ref s => {\n                 tcx.sess.span_bug(\n                     self.expr.span,\n-                    fmt!(\"Invoking method with non-bare-fn ty: %?\", s));\n+                    format!(\"Invoking method with non-bare-fn ty: {:?}\", s));\n             }\n         };\n         let (_, opt_transformed_self_ty, fn_sig) =\n@@ -1019,7 +1019,7 @@ impl<'self> LookupContext<'self> {\n             purity: bare_fn_ty.purity,\n             abis: bare_fn_ty.abis.clone(),\n         });\n-        debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n+        debug2!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n \n         let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n \n@@ -1032,7 +1032,7 @@ impl<'self> LookupContext<'self> {\n                                 rcvr_ty, transformed_self_ty) {\n             result::Ok(_) => (),\n             result::Err(_) => {\n-                self.bug(fmt!(\"%s was a subtype of %s but now is not?\",\n+                self.bug(format!(\"{} was a subtype of {} but now is not?\",\n                               self.ty_to_str(rcvr_ty),\n                               self.ty_to_str(transformed_self_ty)));\n             }\n@@ -1106,7 +1106,7 @@ impl<'self> LookupContext<'self> {\n                     }\n                     _ => {\n                         self.bug(\n-                            fmt!(\"'impossible' transformed_self_ty: %s\",\n+                            format!(\"'impossible' transformed_self_ty: {}\",\n                                  transformed_self_ty.repr(self.tcx())));\n                     }\n                 }\n@@ -1189,12 +1189,12 @@ impl<'self> LookupContext<'self> {\n     // `rcvr_ty` is the type of the expression. It may be a subtype of a\n     // candidate method's `self_ty`.\n     fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n-        debug!(\"is_relevant(rcvr_ty=%s, candidate=%s)\",\n+        debug2!(\"is_relevant(rcvr_ty={}, candidate={})\",\n                self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n         return match candidate.method_ty.explicit_self {\n             sty_static => {\n-                debug!(\"(is relevant?) explicit self is static\");\n+                debug2!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n@@ -1203,7 +1203,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_region(_, m) => {\n-                debug!(\"(is relevant?) explicit self is a region\");\n+                debug2!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1220,7 +1220,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_box(m) => {\n-                debug!(\"(is relevant?) explicit self is a box\");\n+                debug2!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1237,7 +1237,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_uniq => {\n-                debug!(\"(is relevant?) explicit self is a unique pointer\");\n+                debug2!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n                         rcvr_matches_ty(self.fcx, mt.ty, candidate)\n@@ -1303,31 +1303,31 @@ impl<'self> LookupContext<'self> {\n         let span = if did.crate == ast::LOCAL_CRATE {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _)) => m.span,\n-              _ => fail!(\"report_static_candidate: bad item %?\", did)\n+              _ => fail2!(\"report_static_candidate: bad item {:?}\", did)\n             }\n         } else {\n             self.expr.span\n         };\n         self.tcx().sess.span_note(\n             span,\n-            fmt!(\"candidate #%u is `%s`\",\n+            format!(\"candidate \\\\#{} is `{}`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            fmt!(\"candidate #%u derives from the bound `%s`\",\n+            format!(\"candidate \\\\#{} derives from the bound `{}`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_trait_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            fmt!(\"candidate #%u derives from the type of the receiver, \\\n-                  which is the trait `%s`\",\n+            format!(\"candidate \\\\#{} derives from the type of the receiver, \\\n+                  which is the trait `{}`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n@@ -1345,7 +1345,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n     fn cand_to_str(&self, cand: &Candidate) -> ~str {\n-        fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, origin=%?)\",\n+        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n              cand.rcvr_match_condition.repr(self.tcx()),\n              ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n              cand.origin)\n@@ -1371,10 +1371,10 @@ impl Repr for RcvrMatchCondition {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             RcvrMatchesIfObject(d) => {\n-                fmt!(\"RcvrMatchesIfObject(%s)\", d.repr(tcx))\n+                format!(\"RcvrMatchesIfObject({})\", d.repr(tcx))\n             }\n             RcvrMatchesIfSubtype(t) => {\n-                fmt!(\"RcvrMatchesIfSubtype(%s)\", t.repr(tcx))\n+                format!(\"RcvrMatchesIfSubtype({})\", t.repr(tcx))\n             }\n         }\n     }"}, {"sha": "54de7fc1bab9996628bfa7743aab94bf9d80026c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 87, "deletions": 88, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -110,7 +110,6 @@ use util::ppaux::{bound_region_ptr_to_str};\n use util::ppaux;\n \n \n-use std::cast::transmute;\n use std::hashmap::HashMap;\n use std::result;\n use std::util::replace;\n@@ -363,7 +362,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n               _ => Some(self.fcx.to_ty(&local.ty))\n             };\n             self.assign(local.id, o_ty);\n-            debug!(\"Local variable %s is assigned type %s\",\n+            debug2!(\"Local variable {} is assigned type {}\",\n                    self.fcx.pat_to_str(local.pat),\n                    self.fcx.infcx().ty_to_str(\n                        self.fcx.inh.locals.get_copy(&local.id)));\n@@ -376,7 +375,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n               ast::PatIdent(_, ref path, _)\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n-                debug!(\"Pattern binding %s is assigned to %s\",\n+                debug2!(\"Pattern binding {} is assigned to {}\",\n                        self.tcx.sess.str_of(path.segments[0].identifier),\n                        self.fcx.infcx().ty_to_str(\n                            self.fcx.inh.locals.get_copy(&p.id)));\n@@ -451,7 +450,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     let arg_tys = fn_sig.inputs.map(|a| *a);\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys=%?, ret_ty=%?, opt_self_ty=%?)\",\n+    debug2!(\"check_fn(arg_tys={:?}, ret_ty={:?}, opt_self_ty={:?})\",\n            arg_tys.map(|&a| ppaux::ty_to_str(tcx, a)),\n            ppaux::ty_to_str(tcx, ret_ty),\n            opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n@@ -511,7 +510,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add the self parameter\n         for self_info in opt_self_info.iter() {\n             visit.assign(self_info.self_id, Some(self_info.self_ty));\n-            debug!(\"self is assigned to %s\",\n+            debug2!(\"self is assigned to {}\",\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&self_info.self_id)));\n         }\n@@ -565,7 +564,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         let orig_sp = field_names.find(&id).map_move(|x| *x);\n         match orig_sp {\n             Some(orig_sp) => {\n-                tcx.sess.span_err(sp, fmt!(\"Duplicate field name %s in record type declaration\",\n+                tcx.sess.span_err(sp, format!(\"Duplicate field name {} in record type declaration\",\n                                            tcx.sess.str_of(id)));\n                 tcx.sess.span_note(orig_sp, \"First declaration of this field occurred here\");\n                 break;\n@@ -589,7 +588,7 @@ pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: Span) {\n }\n \n pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n-    debug!(\"check_item(it.id=%d, it.ident=%s)\",\n+    debug2!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n@@ -607,7 +606,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       }\n       ast::item_impl(_, _, _, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n-        debug!(\"item_impl %s with id %d rp %?\",\n+        debug2!(\"item_impl {} with id {} rp {:?}\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         for m in ms.iter() {\n             check_method(ccx, *m);\n@@ -645,7 +644,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                 if tpt.generics.has_type_params() {\n                     ccx.tcx.sess.span_err(\n                         item.span,\n-                        fmt!(\"foreign items may not have type parameters\"));\n+                        format!(\"foreign items may not have type parameters\"));\n                 }\n             }\n         }\n@@ -691,7 +690,7 @@ impl FnCtxt {\n                 } else {\n                     result::Err(RegionError {\n                         msg: {\n-                            fmt!(\"named region `%s` not in scope here\",\n+                            format!(\"named region `{}` not in scope here\",\n                                  bound_region_ptr_to_str(self.tcx(), br))\n                         },\n                         replacement: {\n@@ -722,7 +721,7 @@ impl RegionScope for FnCtxt {\n impl FnCtxt {\n     pub fn tag(&self) -> ~str {\n         unsafe {\n-            fmt!(\"%x\", transmute(self))\n+            format!(\"{}\", self as *FnCtxt)\n         }\n     }\n \n@@ -732,7 +731,7 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n-                    fmt!(\"No type for local variable %?\", nid));\n+                    format!(\"No type for local variable {:?}\", nid));\n             }\n         }\n     }\n@@ -743,14 +742,14 @@ impl FnCtxt {\n \n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n-        debug!(\"write_ty(%d, %s) in fcx %s\",\n+        debug2!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n-            debug!(\"write_substs(%d, %s) in fcx %s\",\n+            debug2!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n                    ty::substs_to_str(self.tcx(), &substs),\n                    self.tag());\n@@ -782,7 +781,7 @@ impl FnCtxt {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             adj: @ty::AutoAdjustment) {\n-        debug!(\"write_adjustment(node_id=%?, adj=%?)\", node_id, adj);\n+        debug2!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n         self.inh.adjustments.insert(node_id, adj);\n     }\n \n@@ -808,7 +807,7 @@ impl FnCtxt {\n         match self.inh.node_types.find(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.bug(fmt!(\"no type for expr in fcx %s\",\n+                self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n                                          self.tag()));\n             }\n         }\n@@ -819,7 +818,7 @@ impl FnCtxt {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n-                    fmt!(\"no type for node %d: %s in fcx %s\",\n+                    format!(\"no type for node {}: {} in fcx {}\",\n                          id, ast_map::node_id_to_str(\n                              self.tcx().items, id,\n                              token::get_ident_interner()),\n@@ -833,7 +832,7 @@ impl FnCtxt {\n             Some(ts) => (*ts).clone(),\n             None => {\n                 self.tcx().sess.bug(\n-                    fmt!(\"no type substs for node %d: %s in fcx %s\",\n+                    format!(\"no type substs for node {}: {} in fcx {}\",\n                          id, ast_map::node_id_to_str(\n                              self.tcx().items, id,\n                              token::get_ident_interner()),\n@@ -1212,7 +1211,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                     function_context.tcx()\n                                     .sess\n                                     .span_err(path.span,\n-                                              fmt!(\"this %s has a lifetime \\\n+                                              format!(\"this {} has a lifetime \\\n                                                     parameter but no \\\n                                                     lifetime was specified\",\n                                                    name))\n@@ -1221,7 +1220,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                     function_context.tcx()\n                                     .sess\n                                     .span_err(path.span,\n-                                              fmt!(\"this %s has no lifetime \\\n+                                              format!(\"this {} has no lifetime \\\n                                                     parameter but a lifetime \\\n                                                     was specified\",\n                                                    name))\n@@ -1249,10 +1248,10 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                 function_context.tcx()\n                                 .sess\n                                 .span_err(path.span,\n-                                          fmt!(\"the %s referenced by this \\\n-                                                path has %u type \\\n-                                                parameter%s, but %u type \\\n-                                                parameter%s were supplied\",\n+                                          format!(\"the {} referenced by this \\\n+                                                path has {} type \\\n+                                                parameter{}, but {} type \\\n+                                                parameter{} were supplied\",\n                                                name,\n                                                trait_type_parameter_count,\n                                                trait_count_suffix,\n@@ -1283,7 +1282,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                 function_context.tcx()\n                                 .sess\n                                 .span_note(typ.span,\n-                                           fmt!(\"this is a %?\", def));\n+                                           format!(\"this is a {:?}\", def));\n             }\n         }\n     }\n@@ -1303,7 +1302,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::Expr,\n                                expected: Option<ty::t>,\n                                unifier: &fn()) {\n-    debug!(\">> typechecking\");\n+    debug2!(\">> typechecking\");\n \n     fn check_method_argument_types(\n         fcx: @mut FnCtxt,\n@@ -1329,7 +1328,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 _ => {\n                     fcx.tcx().sess.span_bug(\n                         sp,\n-                        fmt!(\"Method without bare fn type\"));\n+                        format!(\"Method without bare fn type\"));\n                 }\n             }\n         }\n@@ -1366,8 +1365,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 ast::ForSugar => \" (including the closure passed by \\\n                                   the `for` keyword)\"\n             };\n-            let msg = fmt!(\"this function takes %u parameter%s but \\\n-                            %u parameter%s supplied%s\",\n+            let msg = format!(\"this function takes {} parameter{} but \\\n+                            {} parameter{} supplied{}\",\n                            expected_arg_count,\n                            if expected_arg_count == 1 {\"\"}\n                            else {\"s\"},\n@@ -1381,7 +1380,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             vec::from_elem(supplied_arg_count, ty::mk_err())\n         };\n \n-        debug!(\"check_argument_types: formal_tys=%?\",\n+        debug2!(\"check_argument_types: formal_tys={:?}\",\n                formal_tys.map(|t| fcx.infcx().ty_to_str(*t)));\n \n         // Check the arguments.\n@@ -1393,7 +1392,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let xs = [false, true];\n         for check_blocks in xs.iter() {\n             let check_blocks = *check_blocks;\n-            debug!(\"check_blocks=%b\", check_blocks);\n+            debug2!(\"check_blocks={}\", check_blocks);\n \n             // More awful hacks: before we check the blocks, try to do\n             // an \"opportunistic\" vtable resolution of any trait\n@@ -1410,7 +1409,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 };\n \n                 if is_block == check_blocks {\n-                    debug!(\"checking the argument\");\n+                    debug2!(\"checking the argument\");\n                     let mut formal_ty = formal_tys[i];\n \n                     match deref_args {\n@@ -1459,8 +1458,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 match ty::get(output).sty {\n                     ty::ty_bool => {}\n                     _ => fcx.type_error_message(call_expr.span, |actual| {\n-                            fmt!(\"expected `for` closure to return `bool`, \\\n-                                  but found `%s`\", actual) },\n+                            format!(\"expected `for` closure to return `bool`, \\\n+                                  but found `{}`\", actual) },\n                             output, None)\n                 }\n                 ty::mk_nil()\n@@ -1508,8 +1507,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n-                    fmt!(\"expected function but \\\n-                          found `%s`\", actual) }, fn_ty, None);\n+                    format!(\"expected function but \\\n+                          found `{}`\", actual) }, fn_ty, None);\n                 &error_fn_sig\n             }\n         };\n@@ -1564,12 +1563,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 method_map.insert(expr.id, (*entry));\n             }\n             None => {\n-                debug!(\"(checking method call) failing expr is %d\", expr.id);\n+                debug2!(\"(checking method call) failing expr is {}\", expr.id);\n \n                 fcx.type_error_message(expr.span,\n                   |actual| {\n-                      fmt!(\"type `%s` does not implement any method in scope \\\n-                            named `%s`\",\n+                      format!(\"type `{}` does not implement any method in scope \\\n+                            named `{}`\",\n                            actual,\n                            fcx.ccx.tcx.sess.str_of(method_name))\n                   },\n@@ -1721,8 +1720,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_error(expr.id);\n             fcx.write_error(rhs.id);\n             fcx.type_error_message(expr.span, |actual| {\n-                fmt!(\"binary operation %s cannot be applied \\\n-                      to type `%s`\",\n+                format!(\"binary operation {} cannot be applied \\\n+                      to type `{}`\",\n                      ast_util::binop_to_str(op), actual)},\n                                    lhs_t, None)\n \n@@ -1742,8 +1741,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         } else {\n             fcx.type_error_message(expr.span,\n                                    |actual| {\n-                                        fmt!(\"binary operation %s cannot be \\\n-                                              applied to type `%s`\",\n+                                        format!(\"binary operation {} cannot be \\\n+                                              applied to type `{}`\",\n                                              ast_util::binop_to_str(op),\n                                              actual)\n                                    },\n@@ -1771,8 +1770,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             Some(ref name) => {\n                 let if_op_unbound = || {\n                     fcx.type_error_message(ex.span, |actual| {\n-                        fmt!(\"binary operation %s cannot be applied \\\n-                              to type `%s`\",\n+                        format!(\"binary operation {} cannot be applied \\\n+                              to type `{}`\",\n                              ast_util::binop_to_str(op), actual)},\n                             lhs_resolved_t, None)\n                 };\n@@ -1815,7 +1814,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             DoDerefArgs, DontAutoderefReceiver,\n             || {\n                 fcx.type_error_message(ex.span, |actual| {\n-                    fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n+                    format!(\"cannot apply unary operator `{}` to type `{}`\",\n                          op_str, actual)\n                 }, rhs_t, None);\n             }, expected_t)\n@@ -1918,7 +1917,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             ty::mk_closure(tcx, fn_ty_copy)\n         };\n \n-        debug!(\"check_expr_fn_with_unifier fty=%s\",\n+        debug2!(\"check_expr_fn_with_unifier fty={}\",\n                fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n@@ -1952,7 +1951,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n                 // (1) verify that the class id actually has a field called\n                 // field\n-                debug!(\"class named %s\", ppaux::ty_to_str(tcx, base_t));\n+                debug2!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n                 let cls_items = ty::lookup_struct_fields(tcx, base_id);\n                 match lookup_field_ty(tcx, base_id, cls_items,\n                                       field, &(*substs)) {\n@@ -1983,7 +1982,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        fmt!(\"attempted to take value of method `%s` on type `%s` \\\n+                        format!(\"attempted to take value of method `{}` on type `{}` \\\n                               (try writing an anonymous function)\",\n                              token::interner_get(field), actual)\n                     },\n@@ -1994,7 +1993,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        fmt!(\"attempted access of field `%s` on type `%s`, \\\n+                        format!(\"attempted access of field `{}` on type `{}`, \\\n                               but no field with that name was found\",\n                              token::interner_get(field), actual)\n                     },\n@@ -2032,14 +2031,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 None => {\n                     tcx.sess.span_err(\n                         field.span,\n-                        fmt!(\"structure has no field named `%s`\",\n+                        format!(\"structure has no field named `{}`\",\n                              tcx.sess.str_of(field.ident)));\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.span,\n-                        fmt!(\"field `%s` specified more than once\",\n+                        format!(\"field `{}` specified more than once\",\n                              tcx.sess.str_of(field.ident)));\n                     error_happened = true;\n                 }\n@@ -2079,7 +2078,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n \n                 tcx.sess.span_err(span,\n-                                  fmt!(\"missing field%s: %s\",\n+                                  format!(\"missing field{}: {}\",\n                                        if missing_fields.len() == 1 {\n                                            \"\"\n                                        } else {\n@@ -2419,7 +2418,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 _ => {\n                                     fcx.type_error_message(expr.span,\n                                         |actual| {\n-                                            fmt!(\"type %s cannot be dereferenced\", actual)\n+                                            format!(\"type {} cannot be dereferenced\", actual)\n                                     }, oprnd_t, None);\n                                 }\n                             }\n@@ -2567,7 +2566,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::ExprForLoop(*) =>\n-          fail!(\"non-desugared expr_for_loop\"),\n+          fail2!(\"non-desugared expr_for_loop\"),\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, (body));\n         if !may_break(tcx, expr.id, body) {\n@@ -2593,8 +2592,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => match expected {\n                 Some(expected_t) => {\n                     fcx.type_error_message(expr.span, |actual| {\n-                        fmt!(\"last argument in `do` call \\\n-                              has non-closure type: %s\",\n+                        format!(\"last argument in `do` call \\\n+                              has non-closure type: {}\",\n                              actual)\n                     }, expected_t, None);\n                     let err_ty = ty::mk_err();\n@@ -2615,7 +2614,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n           }\n           // argh\n-          _ => fail!(\"expected fn ty\")\n+          _ => fail2!(\"expected fn ty\")\n         }\n         fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n@@ -2659,8 +2658,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n-        debug!(\"t_1=%s\", fcx.infcx().ty_to_str(t_1));\n-        debug!(\"t_e=%s\", fcx.infcx().ty_to_str(t_e));\n+        debug2!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n+        debug2!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n \n         if ty::type_is_error(t_e) {\n             fcx.write_error(id);\n@@ -2676,12 +2675,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 _ => {\n                     if ty::type_is_nil(t_e) {\n                         fcx.type_error_message(expr.span, |actual| {\n-                            fmt!(\"cast from nil: `%s` as `%s`\", actual,\n+                            format!(\"cast from nil: `{}` as `{}`\", actual,\n                                  fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     } else if ty::type_is_nil(t_1) {\n                         fcx.type_error_message(expr.span, |actual| {\n-                            fmt!(\"cast to nil: `%s` as `%s`\", actual,\n+                            format!(\"cast to nil: `{}` as `{}`\", actual,\n                                  fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     }\n@@ -2698,7 +2697,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     } else if t_1_is_char {\n                         if ty::get(te).sty != ty::ty_uint(ast::ty_u8) {\n                             fcx.type_error_message(expr.span, |actual| {\n-                                fmt!(\"only `u8` can be cast as `char`, not `%s`\", actual)\n+                                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n                             }, t_e, None);\n                         }\n                     } else if ty::get(t1).sty == ty::ty_bool {\n@@ -2752,7 +2751,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         record the issue number in this comment.\n                         */\n                         fcx.type_error_message(expr.span, |actual| {\n-                            fmt!(\"non-scalar cast: `%s` as `%s`\", actual,\n+                            format!(\"non-scalar cast: `{}` as `{}`\", actual,\n                                  fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     }\n@@ -2864,8 +2863,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                       let error_message = || {\n                         fcx.type_error_message(expr.span,\n                                                |actual| {\n-                                                fmt!(\"cannot index a value \\\n-                                                      of type `%s`\",\n+                                                format!(\"cannot index a value \\\n+                                                      of type `{}`\",\n                                                      actual)\n                                                },\n                                                base_t,\n@@ -2889,9 +2888,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n        }\n     }\n \n-    debug!(\"type of expr(%d) %s is...\", expr.id,\n+    debug2!(\"type of expr({}) {} is...\", expr.id,\n            syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()));\n-    debug!(\"... %s, expected is %s\",\n+    debug2!(\"... {}, expected is {}\",\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                Some(t) => ppaux::ty_to_str(tcx, t),\n@@ -2904,7 +2903,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n-            fmt!(\"mismatched types: expected integral type but found `%s`\",\n+            format!(\"mismatched types: expected integral type but found `{}`\",\n                  actual)\n         }, t, None);\n     }\n@@ -3110,9 +3109,9 @@ pub fn check_instantiable(tcx: ty::ctxt,\n                           item_id: ast::NodeId) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n-        tcx.sess.span_err(sp, fmt!(\"this type cannot be instantiated \\\n+        tcx.sess.span_err(sp, format!(\"this type cannot be instantiated \\\n                   without an instance of itself; \\\n-                  consider using `Option<%s>`\",\n+                  consider using `Option<{}>`\",\n                                    ppaux::ty_to_str(tcx, item_ty)));\n     }\n }\n@@ -3171,7 +3170,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n \n             match v.node.disr_expr {\n                 Some(e) => {\n-                    debug!(\"disr expr, checking %s\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n+                    debug2!(\"disr expr, checking {}\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n \n                     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n@@ -3187,7 +3186,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            ccx.tcx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n+                            ccx.tcx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n                         }\n                     }\n                 },\n@@ -3301,15 +3300,15 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         def: ast::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {\n-    debug!(\">>> instantiate_path\");\n+    debug2!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n     let mut ty_substs_len = 0;\n     for segment in pth.segments.iter() {\n         ty_substs_len += segment.types.len()\n     }\n \n-    debug!(\"tpt=%s ty_param_count=%? ty_substs_len=%?\",\n+    debug2!(\"tpt={} ty_param_count={:?} ty_substs_len={:?}\",\n            tpt.repr(fcx.tcx()),\n            ty_param_count,\n            ty_substs_len);\n@@ -3364,13 +3363,13 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     } else if ty_substs_len > user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n-             fmt!(\"too many type parameters provided: expected %u, found %u\",\n+             format!(\"too many type parameters provided: expected {}, found {}\",\n                   user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len < user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n-             fmt!(\"not enough type parameters provided: expected %u, found %u\",\n+             format!(\"not enough type parameters provided: expected {}, found {}\",\n                   user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n@@ -3408,7 +3407,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     };\n     fcx.write_ty_substs(node_id, tpt.ty, substs);\n \n-    debug!(\"<<<\");\n+    debug2!(\"<<<\");\n }\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n@@ -3504,7 +3503,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n                              span: Span,\n                              tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n-    debug!(\"check_bounds_are_used(n_tps=%u, ty=%s)\",\n+    debug2!(\"check_bounds_are_used(n_tps={}, ty={})\",\n            tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n \n     // make a vector of booleans initially false, set to true when used\n@@ -3517,7 +3516,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         |t| {\n             match ty::get(t).sty {\n               ty::ty_param(param_ty {idx, _}) => {\n-                  debug!(\"Found use of ty param #%u\", idx);\n+                  debug2!(\"Found use of ty param \\\\#{}\", idx);\n                   tps_used[idx] = true;\n               }\n               _ => ()\n@@ -3528,7 +3527,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n     for (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n             ccx.tcx.sess.span_err(\n-                span, fmt!(\"type parameter `%s` is unused\",\n+                span, format!(\"type parameter `{}` is unused\",\n                            ccx.tcx.sess.str_of(tps.get(i).ident)));\n         }\n     }\n@@ -3577,7 +3576,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             }\n             op => {\n                 tcx.sess.span_err(it.span,\n-                                  fmt!(\"unrecognized atomic operation function: `%s`\",\n+                                  format!(\"unrecognized atomic operation function: `{}`\",\n                                        op));\n                 return;\n             }\n@@ -3860,7 +3859,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n \n             ref other => {\n                 tcx.sess.span_err(it.span,\n-                                  fmt!(\"unrecognized intrinsic function: `%s`\",\n+                                  format!(\"unrecognized intrinsic function: `{}`\",\n                                        *other));\n                 return;\n             }\n@@ -3876,14 +3875,14 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.type_param_defs.len();\n     if i_n_tps != n_tps {\n-        tcx.sess.span_err(it.span, fmt!(\"intrinsic has wrong number \\\n-                                         of type parameters: found %u, \\\n-                                         expected %u\", i_n_tps, n_tps));\n+        tcx.sess.span_err(it.span, format!(\"intrinsic has wrong number \\\n+                                         of type parameters: found {}, \\\n+                                         expected {}\", i_n_tps, n_tps));\n     } else {\n         require_same_types(\n             tcx, None, false, it.span, i_ty.ty, fty,\n-            || fmt!(\"intrinsic has wrong type: \\\n-                      expected `%s`\",\n+            || format!(\"intrinsic has wrong type: \\\n+                      expected `{}`\",\n                      ppaux::ty_to_str(ccx.tcx, fty)));\n     }\n }"}, {"sha": "edc2947d890042f68975f3746e061ca1bb67d3ea", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -68,7 +68,7 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n             }\n         }\n         _ => {\n-            tcx.sess.bug(fmt!(\"unexpected def in encl_region_of_def: %?\",\n+            tcx.sess.bug(format!(\"unexpected def in encl_region_of_def: {:?}\",\n                               def))\n         }\n     }\n@@ -211,7 +211,7 @@ fn visit_local(rcx: &mut Rcx, l: @ast::Local) {\n \n fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n-    debug!(\"regionck::visit_pat(pat=%s)\", pat.repr(tcx));\n+    debug2!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n     do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n@@ -244,7 +244,7 @@ fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n-    debug!(\"regionck::visit_expr(e=%s, repeating_scope=%?)\",\n+    debug2!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n@@ -302,7 +302,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n     {\n         let r = rcx.fcx.inh.adjustments.find(&expr.id);\n         for &adjustment in r.iter() {\n-            debug!(\"adjustment=%?\", adjustment);\n+            debug2!(\"adjustment={:?}\", adjustment);\n             match *adjustment {\n                 @ty::AutoDerefRef(\n                     ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n@@ -515,7 +515,7 @@ fn constrain_callee(rcx: &mut Rcx,\n             //\n             // tcx.sess.span_bug(\n             //     callee_expr.span,\n-            //     fmt!(\"Calling non-function: %s\", callee_ty.repr(tcx)));\n+            //     format!(\"Calling non-function: {}\", callee_ty.repr(tcx)));\n         }\n     }\n }\n@@ -535,7 +535,7 @@ fn constrain_call(rcx: &mut Rcx,\n     //! appear in the arguments appropriately.\n \n     let tcx = rcx.fcx.tcx();\n-    debug!(\"constrain_call(call_expr=%s, implicitly_ref_args=%?)\",\n+    debug2!(\"constrain_call(call_expr={}, implicitly_ref_args={:?})\",\n            call_expr.repr(tcx), implicitly_ref_args);\n     let callee_ty = rcx.resolve_node_type(callee_id);\n     if ty::type_is_error(callee_ty) {\n@@ -597,7 +597,7 @@ fn constrain_derefs(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     let r_deref_expr = ty::re_scope(deref_expr.id);\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_derefs(deref_expr=?, derefd_ty=%s, derefs=%?/%?\",\n+        debug2!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n \n@@ -638,7 +638,7 @@ fn constrain_index(rcx: &mut Rcx,\n      * includes the deref expr.\n      */\n \n-    debug!(\"constrain_index(index_expr=?, indexed_ty=%s\",\n+    debug2!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n     let r_index_expr = ty::re_scope(index_expr.id);\n@@ -662,13 +662,13 @@ fn constrain_free_variables(rcx: &mut Rcx,\n      */\n \n     let tcx = rcx.fcx.ccx.tcx;\n-    debug!(\"constrain_free_variables(%s, %s)\",\n+    debug2!(\"constrain_free_variables({}, {})\",\n            region.repr(tcx), expr.repr(tcx));\n     for freevar in get_freevars(tcx, expr.id).iter() {\n-        debug!(\"freevar def is %?\", freevar.def);\n+        debug2!(\"freevar def is {:?}\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n-        debug!(\"en_region = %s\", en_region.repr(tcx));\n+        debug2!(\"en_region = {}\", en_region.repr(tcx));\n         rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n                         region, en_region);\n     }\n@@ -692,8 +692,8 @@ fn constrain_regions_in_type_of_node(\n     let ty0 = rcx.resolve_node_type(id);\n     let adjustment = rcx.fcx.inh.adjustments.find_copy(&id);\n     let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n-    debug!(\"constrain_regions_in_type_of_node(\\\n-            ty=%s, ty0=%s, id=%d, minimum_lifetime=%?, adjustment=%?)\",\n+    debug2!(\"constrain_regions_in_type_of_node(\\\n+            ty={}, ty0={}, id={}, minimum_lifetime={:?}, adjustment={:?})\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n            id, minimum_lifetime, adjustment);\n     constrain_regions_in_type(rcx, minimum_lifetime, origin, ty)\n@@ -722,12 +722,12 @@ fn constrain_regions_in_type(\n     let e = rcx.errors_reported;\n     let tcx = rcx.fcx.ccx.tcx;\n \n-    debug!(\"constrain_regions_in_type(minimum_lifetime=%s, ty=%s)\",\n+    debug2!(\"constrain_regions_in_type(minimum_lifetime={}, ty={})\",\n            region_to_str(tcx, \"\", false, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n     do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n-        debug!(\"relate(r_sub=%s, r_sup=%s)\",\n+        debug2!(\"relate(r_sub={}, r_sup={})\",\n                region_to_str(tcx, \"\", false, r_sub),\n                region_to_str(tcx, \"\", false, r_sup));\n \n@@ -813,7 +813,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"guarantor::for_addr_of(base=?)\");\n+        debug2!(\"guarantor::for_addr_of(base=?)\");\n \n         let guarantor = guarantor(rcx, base);\n         link(rcx, expr.span, expr.id, guarantor);\n@@ -826,9 +826,9 @@ pub mod guarantor {\n          * linked to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"regionck::for_match()\");\n+        debug2!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n-        debug!(\"discr_guarantor=%s\", discr_guarantor.repr(rcx.tcx()));\n+        debug2!(\"discr_guarantor={}\", discr_guarantor.repr(rcx.tcx()));\n         for arm in arms.iter() {\n             for pat in arm.pats.iter() {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n@@ -847,10 +847,10 @@ pub mod guarantor {\n          * region pointers.\n          */\n \n-        debug!(\"guarantor::for_autoref(autoref=%?)\", autoref);\n+        debug2!(\"guarantor::for_autoref(autoref={:?})\", autoref);\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"    unadjusted cat=%?\", expr_ct.cat);\n+        debug2!(\"    unadjusted cat={:?}\", expr_ct.cat);\n         expr_ct = apply_autoderefs(\n             rcx, expr, autoderefs, expr_ct);\n \n@@ -898,10 +898,10 @@ pub mod guarantor {\n          */\n \n         let tcx = rcx.tcx();\n-        debug!(\"guarantor::for_by_ref(expr=%s, callee_scope=%?)\",\n+        debug2!(\"guarantor::for_by_ref(expr={}, callee_scope={:?})\",\n                expr.repr(tcx), callee_scope);\n         let expr_cat = categorize(rcx, expr);\n-        debug!(\"guarantor::for_by_ref(expr=%?, callee_scope=%?) category=%?\",\n+        debug2!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n                expr.id, callee_scope, expr_cat);\n         let minimum_lifetime = ty::re_scope(callee_scope);\n         for guarantor in expr_cat.guarantor.iter() {\n@@ -921,7 +921,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"link(id=%?, guarantor=%?)\", id, guarantor);\n+        debug2!(\"link(id={:?}, guarantor={:?})\", id, guarantor);\n \n         let bound = match guarantor {\n             None => {\n@@ -939,7 +939,7 @@ pub mod guarantor {\n         let rptr_ty = rcx.resolve_node_type(id);\n         if !ty::type_is_bot(rptr_ty) {\n             let tcx = rcx.fcx.ccx.tcx;\n-            debug!(\"rptr_ty=%s\", ty_to_str(tcx, rptr_ty));\n+            debug2!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n             let r = ty::ty_region(tcx, span, rptr_ty);\n             rcx.fcx.mk_subr(true, infer::Reborrow(span), r, bound);\n         }\n@@ -977,7 +977,7 @@ pub mod guarantor {\n          * `&expr`).\n          */\n \n-        debug!(\"guarantor()\");\n+        debug2!(\"guarantor()\");\n         match expr.node {\n             ast::ExprUnary(_, ast::UnDeref, b) => {\n                 let cat = categorize(rcx, b);\n@@ -1035,15 +1035,15 @@ pub mod guarantor {\n                     rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n                 None\n             }\n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n         }\n     }\n \n     fn categorize(rcx: &mut Rcx, expr: @ast::Expr) -> ExprCategorization {\n-        debug!(\"categorize()\");\n+        debug2!(\"categorize()\");\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n+        debug2!(\"before adjustments, cat={:?}\", expr_ct.cat);\n \n         match rcx.fcx.inh.adjustments.find(&expr.id) {\n             Some(&@ty::AutoAddEnv(*)) => {\n@@ -1056,7 +1056,7 @@ pub mod guarantor {\n             }\n \n             Some(&@ty::AutoDerefRef(ref adjustment)) => {\n-                debug!(\"adjustment=%?\", adjustment);\n+                debug2!(\"adjustment={:?}\", adjustment);\n \n                 expr_ct = apply_autoderefs(\n                     rcx, expr, adjustment.autoderefs, expr_ct);\n@@ -1067,7 +1067,7 @@ pub mod guarantor {\n                     Some(ty::AutoUnsafe(_)) => {\n                         expr_ct.cat.guarantor = None;\n                         expr_ct.cat.pointer = OtherPointer;\n-                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                        debug2!(\"autoref, cat={:?}\", expr_ct.cat);\n                     }\n                     Some(ty::AutoPtr(r, _)) |\n                     Some(ty::AutoBorrowVec(r, _)) |\n@@ -1078,22 +1078,22 @@ pub mod guarantor {\n                         // expression will be some sort of borrowed pointer.\n                         expr_ct.cat.guarantor = None;\n                         expr_ct.cat.pointer = BorrowedPointer(r);\n-                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                        debug2!(\"autoref, cat={:?}\", expr_ct.cat);\n                     }\n                 }\n             }\n \n             None => {}\n         }\n \n-        debug!(\"result=%?\", expr_ct.cat);\n+        debug2!(\"result={:?}\", expr_ct.cat);\n         return expr_ct.cat;\n     }\n \n     fn categorize_unadjusted(rcx: &mut Rcx,\n                              expr: @ast::Expr)\n                           -> ExprCategorizationType {\n-        debug!(\"categorize_unadjusted()\");\n+        debug2!(\"categorize_unadjusted()\");\n \n         let guarantor = {\n             if rcx.fcx.inh.method_map.contains_key(&expr.id) {\n@@ -1138,12 +1138,12 @@ pub mod guarantor {\n                 None => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        fmt!(\"Autoderef but type not derefable: %s\",\n+                        format!(\"Autoderef but type not derefable: {}\",\n                              ty_to_str(tcx, ct.ty)));\n                 }\n             }\n \n-            debug!(\"autoderef, cat=%?\", ct.cat);\n+            debug2!(\"autoderef, cat={:?}\", ct.cat);\n         }\n         return ct;\n     }\n@@ -1205,7 +1205,7 @@ pub mod guarantor {\n          * other pointers.\n          */\n \n-        debug!(\"link_ref_bindings_in_pat(pat=%s, guarantor=%?)\",\n+        debug2!(\"link_ref_bindings_in_pat(pat={}, guarantor={:?})\",\n                rcx.fcx.pat_to_str(pat), guarantor);\n \n         match pat.node {"}, {"sha": "1aae00edf51931cea8cc4898cf5957a45af28552", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -38,25 +38,25 @@ pub fn replace_bound_regions_in_fn_sig(\n \n     for &t in opt_self_ty.iter() { all_tys.push(t) }\n \n-    debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n-            all_tys=%?)\",\n+    debug2!(\"replace_bound_regions_in_fn_sig(self_ty={:?}, fn_sig={}, \\\n+            all_tys={:?})\",\n            opt_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n            ppaux::fn_sig_to_str(tcx, fn_sig),\n            all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n-        debug!(\"br=%?\", br);\n+        debug2!(\"br={:?}\", br);\n         mapf(br)\n     };\n     let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n     let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n \n-    debug!(\"result of replace_bound_regions_in_fn_sig: \\\n-            new_self_ty=%?, \\\n-            fn_sig=%s\",\n+    debug2!(\"result of replace_bound_regions_in_fn_sig: \\\n+            new_self_ty={:?}, \\\n+            fn_sig={}\",\n            new_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n            ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n@@ -146,8 +146,8 @@ pub fn replace_bound_regions_in_fn_sig(\n                   None if in_fn => r,\n                   None => {\n                     tcx.sess.bug(\n-                        fmt!(\"Bound region not found in \\\n-                              in_scope_regions list: %s\",\n+                        format!(\"Bound region not found in \\\n+                              in_scope_regions list: {}\",\n                              region_to_str(tcx, \"\", false, r)));\n                   }\n                 }\n@@ -255,7 +255,7 @@ pub fn relate_free_regions(\n      * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n      */\n \n-    debug!(\"relate_free_regions >>\");\n+    debug2!(\"relate_free_regions >>\");\n \n     let mut all_tys = ~[];\n     for arg in fn_sig.inputs.iter() {\n@@ -266,7 +266,7 @@ pub fn relate_free_regions(\n     }\n \n     for &t in all_tys.iter() {\n-        debug!(\"relate_free_regions(t=%s)\", ppaux::ty_to_str(tcx, t));\n+        debug2!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {\n                 (&ty::re_free(free_a), &ty::re_free(free_b)) => {\n@@ -277,5 +277,5 @@ pub fn relate_free_regions(\n         })\n     }\n \n-    debug!(\"<< relate_free_regions\");\n+    debug2!(\"<< relate_free_regions\");\n }"}, {"sha": "146be8b85ad97584c36321c1938ccbbf87a835aa", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -87,9 +87,9 @@ fn lookup_vtables(vcx: &VtableContext,\n                   type_param_defs: &[ty::TypeParameterDef],\n                   substs: &ty::substs,\n                   is_early: bool) -> vtable_res {\n-    debug!(\"lookup_vtables(location_info=%?, \\\n-            type_param_defs=%s, \\\n-            substs=%s\",\n+    debug2!(\"lookup_vtables(location_info={:?}, \\\n+            type_param_defs={}, \\\n+            substs={}\",\n            location_info,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()));\n@@ -108,11 +108,11 @@ fn lookup_vtables(vcx: &VtableContext,\n     result.reverse();\n \n     assert_eq!(substs.tps.len(), result.len());\n-    debug!(\"lookup_vtables result(\\\n-            location_info=%?, \\\n-            type_param_defs=%s, \\\n-            substs=%s, \\\n-            result=%s)\",\n+    debug2!(\"lookup_vtables result(\\\n+            location_info={:?}, \\\n+            type_param_defs={}, \\\n+            substs={}, \\\n+            result={})\",\n            location_info,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()),\n@@ -142,32 +142,32 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n         let trait_ref = substs.map_default(trait_ref, |substs| {\n-            debug!(\"about to subst: %s, %s\",\n+            debug2!(\"about to subst: {}, {}\",\n                    trait_ref.repr(tcx), substs.repr(tcx));\n             trait_ref.subst(tcx, *substs)\n         });\n \n-        debug!(\"after subst: %s\", trait_ref.repr(tcx));\n+        debug2!(\"after subst: {}\", trait_ref.repr(tcx));\n \n         match lookup_vtable(vcx, location_info, ty, trait_ref, is_early) {\n             Some(vtable) => param_result.push(vtable),\n             None => {\n                 vcx.tcx().sess.span_fatal(\n                     location_info.span,\n-                    fmt!(\"failed to find an implementation of \\\n-                          trait %s for %s\",\n+                    format!(\"failed to find an implementation of \\\n+                          trait {} for {}\",\n                          vcx.infcx.trait_ref_to_str(trait_ref),\n                          vcx.infcx.ty_to_str(ty)));\n             }\n         }\n         true\n     };\n \n-    debug!(\"lookup_vtables_for_param result(\\\n-            location_info=%?, \\\n-            type_param_bounds=%s, \\\n-            ty=%s, \\\n-            result=%s)\",\n+    debug2!(\"lookup_vtables_for_param result(\\\n+            location_info={:?}, \\\n+            type_param_bounds={}, \\\n+            ty={}, \\\n+            result={})\",\n            location_info,\n            type_param_bounds.repr(vcx.tcx()),\n            ty.repr(vcx.tcx()),\n@@ -211,7 +211,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n                 let tcx = vcx.tcx();\n                 tcx.sess.span_err(\n                     location_info.span,\n-                    fmt!(\"expected %s, but found %s (%s)\",\n+                    format!(\"expected {}, but found {} ({})\",\n                          ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n                          ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n                          ty::type_err_to_str(tcx, err)));\n@@ -228,7 +228,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                  is_early: bool)\n     -> Option<vtable_origin>\n {\n-    debug!(\"lookup_vtable(ty=%s, trait_ref=%s)\",\n+    debug2!(\"lookup_vtable(ty={}, trait_ref={})\",\n            vcx.infcx.ty_to_str(ty),\n            vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n@@ -291,7 +291,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n     let mut n_bound = 0;\n     let mut ret = None;\n     do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n-        debug!(\"checking bounds trait %s\",\n+        debug2!(\"checking bounds trait {}\",\n                bound_trait_ref.repr(vcx.tcx()));\n \n         if bound_trait_ref.def_id == trait_ref.def_id {\n@@ -300,7 +300,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                               bound_trait_ref,\n                               trait_ref);\n             let vtable = vtable_param(param, n_bound);\n-            debug!(\"found param vtable: %?\",\n+            debug2!(\"found param vtable: {:?}\",\n                    vtable);\n             ret = Some(vtable);\n             false\n@@ -383,7 +383,7 @@ fn search_for_vtable(vcx: &VtableContext,\n \n         // Now, in the previous example, for_ty is bound to\n         // the type self_ty, and substs is bound to [T].\n-        debug!(\"The self ty is %s and its substs are %s\",\n+        debug2!(\"The self ty is {} and its substs are {}\",\n                vcx.infcx.ty_to_str(for_ty),\n                vcx.infcx.tys_to_str(substs.tps));\n \n@@ -397,8 +397,8 @@ fn search_for_vtable(vcx: &VtableContext,\n         // some value of U) with some_trait<T>. This would fail if T\n         // and U weren't compatible.\n \n-        debug!(\"(checking vtable) @2 relating trait \\\n-                ty %s to of_trait_ref %s\",\n+        debug2!(\"(checking vtable) @2 relating trait \\\n+                ty {} to of_trait_ref {}\",\n                vcx.infcx.trait_ref_to_str(trait_ref),\n                vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n@@ -435,9 +435,9 @@ fn search_for_vtable(vcx: &VtableContext,\n             }\n         };\n \n-        debug!(\"The fixed-up substs are %s - \\\n+        debug2!(\"The fixed-up substs are {} - \\\n                 they will be unified with the bounds for \\\n-                the target ty, %s\",\n+                the target ty, {}\",\n                vcx.infcx.tys_to_str(substs_f.tps),\n                vcx.infcx.trait_ref_to_str(trait_ref));\n \n@@ -487,7 +487,7 @@ fn fixup_substs(vcx: &VtableContext,\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n-          _ => fail!(\"t_f should be a trait\")\n+          _ => fail2!(\"t_f should be a trait\")\n         }\n     }\n }\n@@ -502,8 +502,8 @@ fn fixup_ty(vcx: &VtableContext,\n         Err(e) if !is_early => {\n             tcx.sess.span_fatal(\n                 location_info.span,\n-                fmt!(\"cannot determine a type \\\n-                      for this bounded type parameter: %s\",\n+                format!(\"cannot determine a type \\\n+                      for this bounded type parameter: {}\",\n                      fixup_err_to_str(e)))\n         }\n         Err(_) => {\n@@ -533,7 +533,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n fn insert_vtables(fcx: @mut FnCtxt,\n                   callee_id: ast::NodeId,\n                   vtables: vtable_res) {\n-    debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n+    debug2!(\"insert_vtables(callee_id={}, vtables={:?})\",\n            callee_id, vtables.repr(fcx.tcx()));\n     fcx.inh.vtable_map.insert(callee_id, vtables);\n }\n@@ -554,23 +554,23 @@ pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n pub fn early_resolve_expr(ex: @ast::Expr,\n                           fcx: @mut FnCtxt,\n                           is_early: bool) {\n-    debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n+    debug2!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n     match ex.node {\n       ast::ExprPath(*) => {\n         do fcx.opt_node_ty_substs(ex.id) |substs| {\n-            debug!(\"vtable resolution on parameter bounds for expr %s\",\n+            debug2!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.get_copy(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n-            debug!(\"early resolve expr: def %? %?, %?, %s\", ex.id, did, def,\n+            debug2!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n             if has_trait_bounds(*item_ty.generics.type_param_defs) {\n-                debug!(\"early_resolve_expr: looking up vtables for type params %s\",\n+                debug2!(\"early_resolve_expr: looking up vtables for type params {}\",\n                        item_ty.generics.type_param_defs.repr(fcx.tcx()));\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n@@ -596,7 +596,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n       ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n-            debug!(\"vtable resolution on parameter bounds for method call %s\",\n+            debug2!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n                 let substs = fcx.node_ty_substs(callee_id);\n@@ -612,7 +612,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n         }\n       }\n       ast::ExprCast(src, _) => {\n-          debug!(\"vtable resolution on expr %s\", ex.repr(fcx.tcx()));\n+          debug2!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n               // Bounds of type's contents are not checked here, but in kind.rs.\n@@ -635,7 +635,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                       (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*))\n                         if !mutability_allowed(mt.mutbl, target_mutbl) => {\n                           fcx.tcx().sess.span_err(ex.span,\n-                                                  fmt!(\"types differ in mutability\"));\n+                                                  format!(\"types differ in mutability\"));\n                       }\n \n                       (&ty::ty_box(mt), ty::BoxTraitStore) |\n@@ -691,24 +691,24 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                       (_, ty::UniqTraitStore) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              fmt!(\"can only cast an ~-pointer \\\n-                                    to a ~-object, not a %s\",\n+                              format!(\"can only cast an ~-pointer \\\n+                                    to a ~-object, not a {}\",\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n                       (_, ty::BoxTraitStore) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              fmt!(\"can only cast an @-pointer \\\n-                                    to an @-object, not a %s\",\n+                              format!(\"can only cast an @-pointer \\\n+                                    to an @-object, not a {}\",\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n                       (_, ty::RegionTraitStore(_)) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              fmt!(\"can only cast an &-pointer \\\n-                                    to an &-object, not a %s\",\n+                              format!(\"can only cast an &-pointer \\\n+                                    to an &-object, not a {}\",\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n                   }\n@@ -753,7 +753,7 @@ pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n                 trait_bounds: ~[trait_ref]\n             };\n             let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n-            debug!(\"=== Doing a self lookup now.\");\n+            debug2!(\"=== Doing a self lookup now.\");\n             // Right now, we don't have any place to store this.\n             // We will need to make one so we can use this information\n             // for compiling default methods that refer to supertraits."}, {"sha": "4f281ce5f45701bc67c2a5d8c167334febc6c5a8", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -41,8 +41,8 @@ fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n             if !fcx.ccx.tcx.sess.has_errors() {\n                 fcx.ccx.tcx.sess.span_err(\n                     sp,\n-                    fmt!(\"cannot determine a type \\\n-                          for this expression: %s\",\n+                    format!(\"cannot determine a type \\\n+                          for this expression: {}\",\n                          infer::fixup_err_to_str(e)))\n             }\n             return None;\n@@ -70,8 +70,8 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n                 for t in r.iter() {\n                     let method_map = fcx.ccx.method_map;\n                     let new_entry = method_map_entry { self_ty: *t, ..*mme };\n-                    debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n-                            new_entry=%?)\",\n+                    debug2!(\"writeback::resolve_method_map_entry(id={:?}, \\\n+                            new_entry={:?})\",\n                            id, new_entry);\n                     method_map.insert(id, new_entry);\n                 }\n@@ -88,7 +88,7 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n             let r_origins = resolve_origins(fcx, sp, *origins);\n             let vtable_map = fcx.ccx.vtable_map;\n             vtable_map.insert(id, r_origins);\n-            debug!(\"writeback::resolve_vtable_map_entry(id=%d, vtables=%?)\",\n+            debug2!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n                    id, r_origins.repr(fcx.tcx()));\n         }\n     }\n@@ -128,12 +128,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 Err(e) => {\n                     // This should not, I think, happen:\n                     fcx.ccx.tcx.sess.span_err(\n-                        sp, fmt!(\"cannot resolve bound for closure: %s\",\n+                        sp, format!(\"cannot resolve bound for closure: {}\",\n                                  infer::fixup_err_to_str(e)));\n                 }\n                 Ok(r1) => {\n                     let resolved_adj = @ty::AutoAddEnv(r1, s);\n-                    debug!(\"Adjustments for node %d: %?\", id, resolved_adj);\n+                    debug2!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n                     fcx.tcx().adjustments.insert(id, resolved_adj);\n                 }\n             }\n@@ -146,7 +146,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                     Err(e) => {\n                         // This should not, I think, happen.\n                         fcx.ccx.tcx.sess.span_err(\n-                            sp, fmt!(\"cannot resolve scope of borrow: %s\",\n+                            sp, format!(\"cannot resolve scope of borrow: {}\",\n                                      infer::fixup_err_to_str(e)));\n                         r\n                     }\n@@ -162,7 +162,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 autoderefs: adj.autoderefs,\n                 autoref: resolved_autoref,\n             });\n-            debug!(\"Adjustments for node %d: %?\", id, resolved_adj);\n+            debug2!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n             fcx.tcx().adjustments.insert(id, resolved_adj);\n         }\n     }\n@@ -176,7 +176,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n       }\n \n       Some(t) => {\n-        debug!(\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n+        debug2!(\"resolve_type_vars_for_node(id={}, n_ty={}, t={})\",\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n         let mut ret = Some(t);\n@@ -284,7 +284,7 @@ fn visit_pat(p: @ast::Pat, wbcx: &mut WbCtxt) {\n     }\n \n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n-    debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n+    debug2!(\"Type for pattern binding {} (id {}) resolved to {}\",\n            pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n            wbcx.fcx.infcx().ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n@@ -297,7 +297,7 @@ fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n     let var_ty = wbcx.fcx.local_ty(l.span, l.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n         Ok(lty) => {\n-            debug!(\"Type for local %s (id %d) resolved to %s\",\n+            debug2!(\"Type for local {} (id {}) resolved to {}\",\n                    pat_to_str(l.pat, wbcx.fcx.tcx().sess.intr()),\n                    l.id,\n                    wbcx.fcx.infcx().ty_to_str(lty));\n@@ -306,8 +306,8 @@ fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n         Err(e) => {\n             wbcx.fcx.ccx.tcx.sess.span_err(\n                 l.span,\n-                fmt!(\"cannot determine a type \\\n-                      for this local variable: %s\",\n+                format!(\"cannot determine a type \\\n+                      for this local variable: {}\",\n                      infer::fixup_err_to_str(e)));\n             wbcx.success = false;\n         }"}, {"sha": "f6c24e3cd231a494ab0259747705cf87984583bc", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -76,7 +76,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n \n     match get(resolved_type).sty {\n         ty_enum(*) | ty_trait(*) | ty_struct(*) => {\n-            debug!(\"(getting base type) found base type\");\n+            debug2!(\"(getting base type) found base type\");\n             Some(resolved_type)\n         }\n \n@@ -85,7 +85,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         ty_infer(*) | ty_param(*) | ty_self(*) | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n-            debug!(\"(getting base type) no base type; found %?\",\n+            debug2!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n             None\n         }\n@@ -135,7 +135,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                     return Some(def_id);\n                 }\n                 _ => {\n-                    fail!(\"get_base_type() returned a type that wasn't an \\\n+                    fail2!(\"get_base_type() returned a type that wasn't an \\\n                            enum, struct, or trait\");\n                 }\n             }\n@@ -160,7 +160,7 @@ struct CoherenceCheckVisitor { cc: CoherenceChecker }\n impl visit::Visitor<()> for CoherenceCheckVisitor {\n     fn visit_item(&mut self, item:@item, _:()) {\n \n-//                debug!(\"(checking coherence) item '%s'\",\n+//                debug2!(\"(checking coherence) item '{}'\",\n //                       self.cc.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n@@ -266,8 +266,8 @@ impl CoherenceChecker {\n         // base type.\n \n         if associated_traits.len() == 0 {\n-            debug!(\"(checking implementation) no associated traits for item \\\n-                    '%s'\",\n+            debug2!(\"(checking implementation) no associated traits for item \\\n+                    '{}'\",\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n             match get_base_type_def_id(self.inference_context,\n@@ -290,7 +290,7 @@ impl CoherenceChecker {\n         for associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 self.crate_context.tcx, associated_trait.ref_id);\n-            debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n+            debug2!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n@@ -325,7 +325,7 @@ impl CoherenceChecker {\n                                        trait_ref: &ty::TraitRef,\n                                        all_methods: &mut ~[@Method]) {\n         let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n+        debug2!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n@@ -336,7 +336,7 @@ impl CoherenceChecker {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did=%? trait_method=%s\", new_did, trait_method.repr(tcx));\n+            debug2!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n@@ -348,7 +348,7 @@ impl CoherenceChecker {\n                     *trait_method,\n                     Some(trait_method.def_id));\n \n-            debug!(\"new_method_ty=%s\", new_method_ty.repr(tcx));\n+            debug2!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n             all_methods.push(new_method_ty);\n \n             // construct the polytype for the method based on the method_ty\n@@ -364,7 +364,7 @@ impl CoherenceChecker {\n                 generics: new_generics,\n                 ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n             };\n-            debug!(\"new_polytype=%s\", new_polytype.repr(tcx));\n+            debug2!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n             tcx.tcache.insert(new_did, new_polytype);\n             tcx.methods.insert(new_did, new_method_ty);\n@@ -440,7 +440,7 @@ impl CoherenceChecker {\n                         let session = self.crate_context.tcx.sess;\n                         session.span_err(\n                             self.span_of_impl(implementation_b),\n-                            fmt!(\"conflicting implementations for trait `%s`\",\n+                            format!(\"conflicting implementations for trait `{}`\",\n                                  ty::item_path_str(self.crate_context.tcx,\n                                                    trait_def_id)));\n                         session.span_note(self.span_of_impl(implementation_a),\n@@ -557,11 +557,11 @@ impl CoherenceChecker {\n \n         let r = ty::trait_methods(tcx, trait_did);\n         for method in r.iter() {\n-            debug!(\"checking for %s\", method.ident.repr(tcx));\n+            debug2!(\"checking for {}\", method.ident.repr(tcx));\n             if provided_names.contains(&method.ident.name) { loop; }\n \n             tcx.sess.span_err(trait_ref_span,\n-                              fmt!(\"missing method `%s`\",\n+                              format!(\"missing method `{}`\",\n                                    tcx.sess.str_of(method.ident)));\n         }\n     }"}, {"sha": "e5b01fea0617b7666bc98bcf9165650b3afebb4a", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -129,8 +129,8 @@ impl AstConv for CrateCtxt {\n                 ty_of_foreign_item(self, foreign_item, abis)\n               }\n               ref x => {\n-                self.tcx.sess.bug(fmt!(\"unexpected sort of item \\\n-                                        in get_item_ty(): %?\", (*x)));\n+                self.tcx.sess.bug(format!(\"unexpected sort of item \\\n+                                        in get_item_ty(): {:?}\", (*x)));\n               }\n             }\n         }\n@@ -347,7 +347,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n         new_type_param_defs.push_all(*substd_type_param_defs);\n \n-        debug!(\"static method %s type_param_defs=%s ty=%s, substs=%s\",\n+        debug2!(\"static method {} type_param_defs={} ty={}, substs={}\",\n                m.def_id.repr(tcx),\n                new_type_param_defs.repr(tcx),\n                ty.repr(tcx),\n@@ -453,7 +453,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                            trait_m: &ty::Method,\n                            trait_substs: &ty::substs,\n                            self_ty: ty::t) {\n-    debug!(\"compare_impl_method()\");\n+    debug2!(\"compare_impl_method()\");\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     let impl_m = &cm.mty;\n@@ -470,7 +470,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         (&ast::sty_static, _) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n+                format!(\"method `{}` has a `{}` declaration in the impl, \\\n                       but not in the trait\",\n                      tcx.sess.str_of(trait_m.ident),\n                      explicit_self_to_str(&impl_m.explicit_self, tcx.sess.intr())));\n@@ -479,7 +479,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         (_, &ast::sty_static) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n+                format!(\"method `{}` has a `{}` declaration in the trait, \\\n                       but not in the impl\",\n                      tcx.sess.str_of(trait_m.ident),\n                      explicit_self_to_str(&trait_m.explicit_self, tcx.sess.intr())));\n@@ -495,8 +495,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     if num_impl_m_type_params != num_trait_m_type_params {\n         tcx.sess.span_err(\n             cm.span,\n-            fmt!(\"method `%s` has %u type %s, but its trait \\\n-                  declaration has %u type %s\",\n+            format!(\"method `{}` has {} type {}, but its trait \\\n+                  declaration has {} type {}\",\n                  tcx.sess.str_of(trait_m.ident),\n                  num_impl_m_type_params,\n                  pluralize(num_impl_m_type_params, ~\"parameter\"),\n@@ -508,8 +508,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n         tcx.sess.span_err(\n             cm.span,\n-            fmt!(\"method `%s` has %u parameter%s \\\n-                  but the trait has %u\",\n+            format!(\"method `{}` has {} parameter{} \\\n+                  but the trait has {}\",\n                  tcx.sess.str_of(trait_m.ident),\n                  impl_m.fty.sig.inputs.len(),\n                  if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n@@ -529,8 +529,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         if !extra_bounds.is_empty() {\n            tcx.sess.span_err(\n                cm.span,\n-               fmt!(\"in method `%s`, \\\n-                     type parameter %u requires `%s`, \\\n+               format!(\"in method `{}`, \\\n+                     type parameter {} requires `{}`, \\\n                      which is not required by \\\n                      the corresponding type parameter \\\n                      in the trait declaration\",\n@@ -548,10 +548,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"in method `%s`, \\\n-                      type parameter %u has %u trait %s, but the \\\n+                format!(\"in method `{}`, \\\n+                      type parameter {} has {} trait {}, but the \\\n                       corresponding type parameter in \\\n-                      the trait declaration has %u trait %s\",\n+                      the trait declaration has {} trait {}\",\n                      tcx.sess.str_of(trait_m.ident),\n                      i, impl_param_def.bounds.trait_bounds.len(),\n                      pluralize(impl_param_def.bounds.trait_bounds.len(),\n@@ -632,10 +632,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n+        debug2!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n-    debug!(\"impl_fty (post-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n+    debug2!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n         let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n         let dummy_tps = do vec::from_fn(num_trait_m_type_params) |i| {\n@@ -649,19 +649,19 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        debug!(\"trait_fty (pre-subst): %s substs=%s\",\n+        debug2!(\"trait_fty (pre-subst): {} substs={}\",\n                trait_fty.repr(tcx), substs.repr(tcx));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n-    debug!(\"trait_fty (post-subst): %s\", trait_fty.repr(tcx));\n+    debug2!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n \n     match infer::mk_subty(infcx, false, infer::MethodCompatCheck(cm.span),\n                           impl_fty, trait_fty) {\n         result::Ok(()) => {}\n         result::Err(ref terr) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s` has an incompatible type: %s\",\n+                format!(\"method `{}` has an incompatible type: {}\",\n                      tcx.sess.str_of(trait_m.ident),\n                      ty::type_err_to_str(tcx, terr)));\n             ty::note_and_explain_type_err(tcx, terr);\n@@ -709,7 +709,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                 // This method is not part of the trait\n                 tcx.sess.span_err(\n                     impl_m.span,\n-                    fmt!(\"method `%s` is not a member of trait `%s`\",\n+                    format!(\"method `{}` is not a member of trait `{}`\",\n                          tcx.sess.str_of(impl_m.mty.ident),\n                          path_to_str(&a_trait_ty.path, tcx.sess.intr())));\n             }\n@@ -835,7 +835,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n-                fmt!(\"trait bounds are not allowed in %s definitions\",\n+                format!(\"trait bounds are not allowed in {} definitions\",\n                      thing));\n         }\n     }\n@@ -844,7 +844,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n-    debug!(\"convert: item %s with id %d rp %?\",\n+    debug2!(\"convert: item {} with id {} rp {:?}\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n       // These don't define types.\n@@ -1000,8 +1000,8 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n     let abis = match ccx.tcx.items.find(&i.id) {\n         Some(&ast_map::node_foreign_item(_, abis, _, _)) => abis,\n         ref x => {\n-            ccx.tcx.sess.bug(fmt!(\"unexpected sort of item \\\n-                                   in get_item_ty(): %?\", (*x)));\n+            ccx.tcx.sess.bug(format!(\"unexpected sort of item \\\n+                                   in get_item_ty(): {:?}\", (*x)));\n         }\n     };\n \n@@ -1038,7 +1038,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n         _ => {\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n-                fmt!(\"%s is not a trait\",\n+                format!(\"{} is not a trait\",\n                     path_to_str(&ast_trait_ref.path,\n                                 ccx.tcx.sess.intr())));\n         }\n@@ -1051,7 +1051,7 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n     } else {\n         match ccx.tcx.items.get(&trait_id.node) {\n             &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n-            _ => ccx.tcx.sess.bug(fmt!(\"get_trait_def(%d): not an item\",\n+            _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n                                        trait_id.node))\n         }\n     }\n@@ -1083,7 +1083,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                fmt!(\"trait_def_of_item invoked on %?\", s));\n+                format!(\"trait_def_of_item invoked on {:?}\", s));\n         }\n     }\n }\n@@ -1120,7 +1120,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             },\n             ty: ty::mk_bare_fn(ccx.tcx, tofd)\n         };\n-        debug!(\"type of %s (id %d) is %s\",\n+        debug2!(\"type of {} (id {}) is {}\",\n                tcx.sess.str_of(it.ident),\n                it.id,\n                ppaux::ty_to_str(tcx, tpt.ty));\n@@ -1161,7 +1161,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n       ast::item_trait(*) => {\n           tcx.sess.span_bug(\n               it.span,\n-              fmt!(\"Invoked ty_of_item on trait\"));\n+              format!(\"Invoked ty_of_item on trait\"));\n       }\n       ast::item_struct(_, ref generics) => {\n           let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n@@ -1174,8 +1174,8 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n           return tpt;\n       }\n       ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_foreign_mod(_) => fail!(),\n-      ast::item_mac(*) => fail!(\"item macros unimplemented\")\n+      ast::item_foreign_mod(_) => fail2!(),\n+      ast::item_mac(*) => fail2!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1222,7 +1222,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                         def_id: local_def(param.id),\n                         bounds: bounds\n                     };\n-                    debug!(\"def for param: %s\", def.repr(ccx.tcx));\n+                    debug2!(\"def for param: {}\", def.repr(ccx.tcx));\n                     ccx.tcx.ty_param_defs.insert(param.id, def);\n                     def\n                 }"}, {"sha": "8d1eaf34256bdfe1ed189492d94aeda54490bc63", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -87,7 +87,7 @@ pub struct Coerce(CombineFields);\n \n impl Coerce {\n     pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n-        debug!(\"Coerce.tys(%s => %s)\",\n+        debug2!(\"Coerce.tys({} => {})\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _indent = indenter();\n@@ -172,8 +172,8 @@ impl Coerce {\n             Err(e) => {\n                 self.infcx.tcx.sess.span_bug(\n                     self.trace.origin.span(),\n-                    fmt!(\"Failed to resolve even without \\\n-                          any force options: %?\", e));\n+                    format!(\"Failed to resolve even without \\\n+                          any force options: {:?}\", e));\n             }\n         }\n     }\n@@ -184,7 +184,7 @@ impl Coerce {\n                                    b: ty::t,\n                                    mt_b: ty::mt)\n                                    -> CoerceResult {\n-        debug!(\"coerce_borrowed_pointer(a=%s, sty_a=%?, b=%s, mt_b=%?)\",\n+        debug2!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx), mt_b);\n \n@@ -221,7 +221,7 @@ impl Coerce {\n                                   sty_a: &ty::sty,\n                                   b: ty::t)\n                                   -> CoerceResult {\n-        debug!(\"coerce_borrowed_string(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -248,7 +248,7 @@ impl Coerce {\n                                   b: ty::t,\n                                   mt_b: ty::mt)\n                                   -> CoerceResult {\n-        debug!(\"coerce_borrowed_vector(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -277,7 +277,7 @@ impl Coerce {\n                               b: ty::t,\n                               b_mutbl: ast::Mutability) -> CoerceResult\n     {\n-        debug!(\"coerce_borrowed_object(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -306,7 +306,7 @@ impl Coerce {\n                               sty_a: &ty::sty,\n                               b: ty::t)\n                               -> CoerceResult {\n-        debug!(\"coerce_borrowed_fn(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -361,7 +361,7 @@ impl Coerce {\n          * \"rust\" fn`) into a closure.\n          */\n \n-        debug!(\"coerce_from_bare_fn(a=%s, b=%s)\",\n+        debug2!(\"coerce_from_bare_fn(a={}, b={})\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if !fn_ty_a.abis.is_rust() {\n@@ -389,7 +389,7 @@ impl Coerce {\n                              b: ty::t,\n                              mt_b: ty::mt)\n                              -> CoerceResult {\n-        debug!(\"coerce_unsafe_ptr(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n "}, {"sha": "3f6248eae1236b14ec91abfe9b264d6d404103d5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -116,7 +116,7 @@ pub trait Combine {\n                 // substs and one of them has a self_ty and one\n                 // doesn't...? I could be wrong about this.\n                 self.infcx().tcx.sess.bug(\n-                                          fmt!(\"substitution a had a self_ty \\\n+                                          format!(\"substitution a had a self_ty \\\n                                                and substitution b didn't, \\\n                                                or vice versa\"));\n             }\n@@ -270,7 +270,7 @@ pub trait Combine {\n     fn vstores(&self, vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n \n-        debug!(\"%s.vstores(a=%?, b=%?)\", self.tag(), a, b);\n+        debug2!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n@@ -295,7 +295,7 @@ pub trait Combine {\n                     b: ty::TraitStore)\n                  -> cres<ty::TraitStore> {\n \n-        debug!(\"%s.trait_stores(a=%?, b=%?)\", self.tag(), a, b);\n+        debug2!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n@@ -365,7 +365,7 @@ pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n \n pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n                           -> ures {\n-    debug!(\"eq_regions(%s, %s)\",\n+    debug2!(\"eq_regions({}, {})\",\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n     let sub = this.sub();\n@@ -406,8 +406,8 @@ pub fn eq_opt_regions<C:Combine>(\n         // consistently have a region parameter or not have a\n         // region parameter.\n         this.infcx().tcx.sess.bug(\n-            fmt!(\"substitution a had opt_region %s and \\\n-                  b had opt_region %s\",\n+            format!(\"substitution a had opt_region {} and \\\n+                  b had opt_region {}\",\n                  a.inf_str(this.infcx()),\n                  b.inf_str(this.infcx())));\n       }\n@@ -446,7 +446,7 @@ pub fn super_tys<C:Combine>(\n       (&ty::ty_infer(TyVar(_)), _) |\n       (_, &ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug(\n-            fmt!(\"%s: bot and var types should have been handled (%s,%s)\",\n+            format!(\"{}: bot and var types should have been handled ({},{})\",\n                  this.tag(),\n                  a.inf_str(this.infcx()),\n                  b.inf_str(this.infcx())));"}, {"sha": "3f38850c8ffda4648baa44fcfc09aef000f1e950", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -163,7 +163,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_err(\n             trace.origin.span(),\n-            fmt!(\"%s: %s (%s)\",\n+            format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n                  ty::type_err_to_str(tcx, terr)));\n@@ -173,7 +173,7 @@ impl ErrorReporting for InferCtxt {\n \n     fn values_str(@mut self, values: &ValuePairs) -> Option<~str> {\n         /*!\n-         * Returns a string of the form \"expected `%s` but found `%s`\",\n+         * Returns a string of the form \"expected `{}` but found `{}`\",\n          * or None if this is a derived error.\n          */\n         match *values {\n@@ -201,7 +201,7 @@ impl ErrorReporting for InferCtxt {\n             return None;\n         }\n \n-        Some(fmt!(\"expected `%s` but found `%s`\",\n+        Some(format!(\"expected `{}` but found `{}`\",\n                   expected.user_string(self.tcx),\n                   found.user_string(self.tcx)))\n     }\n@@ -284,7 +284,7 @@ impl ErrorReporting for InferCtxt {\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"index of slice outside its lifetime\"));\n+                    format!(\"index of slice outside its lifetime\"));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the slice is only valid for \",\n@@ -375,7 +375,7 @@ impl ErrorReporting for InferCtxt {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n+                    format!(\"in type `{}`, pointer has a longer lifetime than \\\n                           the data it references\",\n                          ty.user_string(self.tcx)));\n                 note_and_explain_region(\n@@ -400,7 +400,7 @@ impl ErrorReporting for InferCtxt {\n                                sup_region: Region) {\n         self.tcx.sess.span_err(\n             var_origin.span(),\n-            fmt!(\"cannot infer an appropriate lifetime \\\n+            format!(\"cannot infer an appropriate lifetime \\\n                   due to conflicting requirements\"));\n \n         note_and_explain_region(\n@@ -411,7 +411,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             sup_origin.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n \n         note_and_explain_region(\n             self.tcx,\n@@ -421,7 +421,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             sub_origin.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n     }\n \n     fn report_sup_sup_conflict(@mut self,\n@@ -432,7 +432,7 @@ impl ErrorReporting for InferCtxt {\n                                region2: Region) {\n         self.tcx.sess.span_err(\n             var_origin.span(),\n-            fmt!(\"cannot infer an appropriate lifetime \\\n+            format!(\"cannot infer an appropriate lifetime \\\n                   due to conflicting requirements\"));\n \n         note_and_explain_region(\n@@ -443,7 +443,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             origin1.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n \n         note_and_explain_region(\n             self.tcx,\n@@ -453,7 +453,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             origin2.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n     }\n }\n "}, {"sha": "5e9eb51cbb64df369d629a23106c2d338939d36d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -44,7 +44,7 @@ impl Combine for Glb {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug!(\"%s.mts(%s, %s)\",\n+        debug2!(\"{}.mts({}, {})\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -100,7 +100,7 @@ impl Combine for Glb {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"%s.regions(%?, %?)\",\n+        debug2!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -121,7 +121,7 @@ impl Combine for Glb {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        debug!(\"%s.fn_sigs(%?, %?)\",\n+        debug2!(\"{}.fn_sigs({:?}, {:?})\",\n                self.tag(), a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n@@ -143,7 +143,7 @@ impl Combine for Glb {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n+        debug2!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n@@ -155,7 +155,7 @@ impl Combine for Glb {\n                 |r, _in_fn| generalize_region(self, snapshot,\n                                               new_vars, a_isr, a_vars, b_vars,\n                                               r));\n-        debug!(\"sig1 = %s\", sig1.inf_str(self.infcx));\n+        debug2!(\"sig1 = {}\", sig1.inf_str(self.infcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n@@ -237,7 +237,7 @@ impl Combine for Glb {\n                 Some(x) => x,\n                 None => this.infcx.tcx.sess.span_bug(\n                             this.trace.origin.span(),\n-                            fmt!(\"could not find original bound region for %?\", r))\n+                            format!(\"could not find original bound region for {:?}\", r))\n             }\n         }\n "}, {"sha": "919ad68a818fa7fec68fe90e6c1be027f4a2e9fb", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -131,7 +131,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let a_bounds = node_a.possible_types.clone();\n         let b_bounds = node_b.possible_types.clone();\n \n-        debug!(\"vars(%s=%s <: %s=%s)\",\n+        debug2!(\"vars({}={} <: {}={})\",\n                a_id.to_str(), a_bounds.inf_str(self.infcx),\n                b_id.to_str(), b_bounds.inf_str(self.infcx));\n \n@@ -179,7 +179,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let a_bounds = &node_a.possible_types;\n         let b_bounds = &Bounds { lb: None, ub: Some(b.clone()) };\n \n-        debug!(\"var_sub_t(%s=%s <: %s)\",\n+        debug2!(\"var_sub_t({}={} <: {})\",\n                a_id.to_str(),\n                a_bounds.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -203,7 +203,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let b_id = node_b.root.clone();\n         let b_bounds = &node_b.possible_types;\n \n-        debug!(\"t_sub_var(%s <: %s=%s)\",\n+        debug2!(\"t_sub_var({} <: {}={})\",\n                a.inf_str(self.infcx),\n                b_id.to_str(),\n                b_bounds.inf_str(self.infcx));\n@@ -222,7 +222,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n          *\n          * Combines two bounds into a more general bound. */\n \n-        debug!(\"merge_bnd(%s,%s)\",\n+        debug2!(\"merge_bnd({},{})\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();\n@@ -273,7 +273,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         //       A     \\ / A\n         //              B\n \n-        debug!(\"merge(%s,%s,%s)\",\n+        debug2!(\"merge({},{},{})\",\n                v_id.to_str(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -290,7 +290,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let ub = if_ok!(self.merge_bnd(&a.ub, &b.ub, LatticeValue::glb));\n         let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n         let bounds = Bounds { lb: lb, ub: ub };\n-        debug!(\"merge(%s): bounds=%s\",\n+        debug2!(\"merge({}): bounds={}\",\n                v_id.to_str(),\n                bounds.inf_str(self.infcx));\n \n@@ -305,7 +305,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n                                                a: &Bound<T>,\n                                                b: &Bound<T>)\n                                                -> ures {\n-        debug!(\"bnds(%s <: %s)\", a.inf_str(self.infcx),\n+        debug2!(\"bnds({} <: {})\", a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();\n \n@@ -370,7 +370,7 @@ pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n     this: &L,\n     a: ty::t,\n     b: ty::t) -> cres<ty::t> {\n-    debug!(\"%s.lattice_tys(%s, %s)\", this.tag(),\n+    debug2!(\"{}.lattice_tys({}, {})\", this.tag(),\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n     let _r = indenter();\n@@ -448,7 +448,7 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     let a_bounds = &nde_a.possible_types;\n     let b_bounds = &nde_b.possible_types;\n \n-    debug!(\"%s.lattice_vars(%s=%s <: %s=%s)\",\n+    debug2!(\"{}.lattice_vars({}={} <: {}={})\",\n            this.tag(),\n            a_vid.to_str(), a_bounds.inf_str(this.infcx()),\n            b_vid.to_str(), b_bounds.inf_str(this.infcx()));\n@@ -494,7 +494,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    debug!(\"%s.lattice_var_and_t(%s=%s <: %s)\",\n+    debug2!(\"{}.lattice_var_and_t({}={} <: {})\",\n            this.tag(),\n            a_id.to_str(),\n            a_bounds.inf_str(this.infcx()),\n@@ -503,13 +503,13 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     match this.bnd(a_bounds) {\n         Some(ref a_bnd) => {\n             // If a has an upper bound, return the LUB(a.ub, b)\n-            debug!(\"bnd=Some(%s)\", a_bnd.inf_str(this.infcx()));\n+            debug2!(\"bnd=Some({})\", a_bnd.inf_str(this.infcx()));\n             lattice_dir_op(a_bnd, b)\n         }\n         None => {\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n-            debug!(\"bnd=None\");\n+            debug2!(\"bnd=None\");\n             let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n             do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n                 this.infcx().set(a_id.clone(),\n@@ -532,7 +532,7 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n-                    fmt!(\"Found non-region-vid: %?\", r));\n+                    format!(\"Found non-region-vid: {:?}\", r));\n             }\n         }\n         true"}, {"sha": "c8974a722fd88de6df8edaccd6b9e52a42077f51", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -50,7 +50,7 @@ impl Combine for Lub {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug!(\"%s.mts(%s, %s)\",\n+        debug2!(\"{}.mts({}, {})\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -106,7 +106,7 @@ impl Combine for Lub {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"%s.regions(%?, %?)\",\n+        debug2!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -134,7 +134,7 @@ impl Combine for Lub {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n+        debug2!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n@@ -154,7 +154,7 @@ impl Combine for Lub {\n                              r0: ty::Region) -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n-                debug!(\"generalize_region(r0=%?): not new variable\", r0);\n+                debug2!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n \n@@ -164,8 +164,8 @@ impl Combine for Lub {\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n             if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0=%?): \\\n-                        non-new-variables found in %?\",\n+                debug2!(\"generalize_region(r0={:?}): \\\n+                        non-new-variables found in {:?}\",\n                        r0, tainted);\n                 return r0;\n             }\n@@ -179,8 +179,8 @@ impl Combine for Lub {\n             do list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n                 if tainted.iter().any(|x| x == &a_r) {\n-                    debug!(\"generalize_region(r0=%?): \\\n-                            replacing with %?, tainted=%?\",\n+                    debug2!(\"generalize_region(r0={:?}): \\\n+                            replacing with {:?}, tainted={:?}\",\n                            r0, a_br, tainted);\n                     ret = Some(ty::re_bound(a_br));\n                     false\n@@ -193,7 +193,7 @@ impl Combine for Lub {\n                 Some(x) => x,\n                 None => this.infcx.tcx.sess.span_bug(\n                             this.trace.origin.span(),\n-                            fmt!(\"Region %? is not associated with \\\n+                            format!(\"Region {:?} is not associated with \\\n                                   any bound region from A!\", r0))\n             }\n         }"}, {"sha": "89e9f626ca581f77e1178d7da491318642321f6a", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -244,7 +244,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n       cyclic_ty(_) => ~\"cyclic type of infinite size\",\n       unresolved_region(_) => ~\"unconstrained region\",\n       region_var_bound_by_region_var(r1, r2) => {\n-        fmt!(\"region var %? bound by another region var %?; this is \\\n+        format!(\"region var {:?} bound by another region var {:?}; this is \\\n               a bug in rustc\", r1, r2)\n       }\n     }\n@@ -285,7 +285,7 @@ pub fn common_supertype(cx: @mut InferCtxt,\n      * not possible, reports an error and returns ty::err.\n      */\n \n-    debug!(\"common_supertype(%s, %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"common_supertype({}, {})\", a.inf_str(cx), b.inf_str(cx));\n \n     let trace = TypeTrace {\n         origin: origin,\n@@ -311,7 +311,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n                 a: ty::t,\n                 b: ty::t)\n              -> ures {\n-    debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -324,7 +324,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n }\n \n pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let trace = TypeTrace {\n@@ -341,7 +341,7 @@ pub fn mk_subr(cx: @mut InferCtxt,\n                origin: SubregionOrigin,\n                a: ty::Region,\n                b: ty::Region) {\n-    debug!(\"mk_subr(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_subr({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit();\n@@ -353,7 +353,7 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n                a: ty::t,\n                b: ty::t)\n             -> ures {\n-    debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_eqty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -373,7 +373,7 @@ pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n                          b: @ty::TraitRef)\n     -> ures\n {\n-    debug!(\"mk_sub_trait_refs(%s <: %s)\",\n+    debug2!(\"mk_sub_trait_refs({} <: {})\",\n            a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -403,7 +403,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n                    a: ty::t,\n                    b: ty::t)\n                 -> CoerceResult {\n-    debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -416,7 +416,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n }\n \n pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let trace = TypeTrace {\n@@ -539,7 +539,7 @@ impl InferCtxt {\n     }\n \n     pub fn rollback_to(&mut self, snapshot: &Snapshot) {\n-        debug!(\"rollback!\");\n+        debug2!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n         rollback_to(&mut self.int_var_bindings,\n@@ -554,7 +554,7 @@ impl InferCtxt {\n     pub fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n-        debug!(\"commit()\");\n+        debug2!(\"commit()\");\n         do indent {\n             let r = self.try(|| f());\n \n@@ -567,7 +567,7 @@ impl InferCtxt {\n \n     /// Execute `f`, unroll bindings on failure\n     pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n-        debug!(\"try()\");\n+        debug2!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n@@ -581,7 +581,7 @@ impl InferCtxt {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n-        debug!(\"probe()\");\n+        debug2!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n@@ -654,7 +654,7 @@ impl InferCtxt {\n \n     pub fn tys_to_str(@mut self, ts: &[ty::t]) -> ~str {\n         let tstrs = ts.map(|t| self.ty_to_str(*t));\n-        fmt!(\"(%s)\", tstrs.connect(\", \"))\n+        format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n     pub fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n@@ -690,8 +690,8 @@ impl InferCtxt {\n             }\n             _ => {\n                 self.tcx.sess.bug(\n-                    fmt!(\"resolve_type_vars_if_possible() yielded %s \\\n-                          when supplied with %s\",\n+                    format!(\"resolve_type_vars_if_possible() yielded {} \\\n+                          when supplied with {}\",\n                          self.ty_to_str(dummy0),\n                          self.ty_to_str(dummy1)));\n             }\n@@ -725,21 +725,21 @@ impl InferCtxt {\n                                                 expected_ty: Option<ty::t>,\n                                                 actual_ty: ~str,\n                                                 err: Option<&ty::type_err>) {\n-        debug!(\"hi! expected_ty = %?, actual_ty = %s\", expected_ty, actual_ty);\n+        debug2!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let error_str = do err.map_move_default(~\"\") |t_err| {\n-            fmt!(\" (%s)\", ty::type_err_to_str(self.tcx, t_err))\n+            format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n         };\n         let resolved_expected = do expected_ty.map_move |e_ty| {\n             self.resolve_type_vars_if_possible(e_ty)\n         };\n         if !resolved_expected.map_move_default(false, |e| { ty::type_is_error(e) }) {\n             match resolved_expected {\n                 None => self.tcx.sess.span_err(sp,\n-                            fmt!(\"%s%s\", mk_msg(None, actual_ty), error_str)),\n+                            format!(\"{}{}\", mk_msg(None, actual_ty), error_str)),\n                 Some(e) => {\n                     self.tcx.sess.span_err(sp,\n-                        fmt!(\"%s%s\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n+                        format!(\"{}{}\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n                 }\n             }\n             for err in err.iter() {\n@@ -776,7 +776,7 @@ impl InferCtxt {\n             _ => {\n                 // if I leave out : ~str, it infers &str and complains\n                 |actual: ~str| {\n-                    fmt!(\"mismatched types: expected `%s` but found `%s`\",\n+                    format!(\"mismatched types: expected `{}` but found `{}`\",\n                          self.ty_to_str(resolved_expected), actual)\n                 }\n             }\n@@ -792,7 +792,7 @@ impl InferCtxt {\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n-                debug!(\"Bound region %s maps to %?\",\n+                debug2!(\"Bound region {} maps to {:?}\",\n                        bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n@@ -819,7 +819,7 @@ impl TypeTrace {\n \n impl Repr for TypeTrace {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"TypeTrace(%s)\", self.origin.repr(tcx))\n+        format!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n }\n \n@@ -840,13 +840,13 @@ impl TypeOrigin {\n impl Repr for TypeOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            MethodCompatCheck(a) => fmt!(\"MethodCompatCheck(%s)\", a.repr(tcx)),\n-            ExprAssignable(a) => fmt!(\"ExprAssignable(%s)\", a.repr(tcx)),\n-            Misc(a) => fmt!(\"Misc(%s)\", a.repr(tcx)),\n-            RelateTraitRefs(a) => fmt!(\"RelateTraitRefs(%s)\", a.repr(tcx)),\n-            RelateSelfType(a) => fmt!(\"RelateSelfType(%s)\", a.repr(tcx)),\n-            MatchExpression(a) => fmt!(\"MatchExpression(%s)\", a.repr(tcx)),\n-            IfExpression(a) => fmt!(\"IfExpression(%s)\", a.repr(tcx)),\n+            MethodCompatCheck(a) => format!(\"MethodCompatCheck({})\", a.repr(tcx)),\n+            ExprAssignable(a) => format!(\"ExprAssignable({})\", a.repr(tcx)),\n+            Misc(a) => format!(\"Misc({})\", a.repr(tcx)),\n+            RelateTraitRefs(a) => format!(\"RelateTraitRefs({})\", a.repr(tcx)),\n+            RelateSelfType(a) => format!(\"RelateSelfType({})\", a.repr(tcx)),\n+            MatchExpression(a) => format!(\"MatchExpression({})\", a.repr(tcx)),\n+            IfExpression(a) => format!(\"IfExpression({})\", a.repr(tcx)),\n         }\n     }\n }\n@@ -876,21 +876,23 @@ impl SubregionOrigin {\n impl Repr for SubregionOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            Subtype(a) => fmt!(\"Subtype(%s)\", a.repr(tcx)),\n-            InfStackClosure(a) => fmt!(\"InfStackClosure(%s)\", a.repr(tcx)),\n-            InvokeClosure(a) => fmt!(\"InvokeClosure(%s)\", a.repr(tcx)),\n-            DerefPointer(a) => fmt!(\"DerefPointer(%s)\", a.repr(tcx)),\n-            FreeVariable(a) => fmt!(\"FreeVariable(%s)\", a.repr(tcx)),\n-            IndexSlice(a) => fmt!(\"IndexSlice(%s)\", a.repr(tcx)),\n-            RelateObjectBound(a) => fmt!(\"RelateObjectBound(%s)\", a.repr(tcx)),\n-            Reborrow(a) => fmt!(\"Reborrow(%s)\", a.repr(tcx)),\n-            ReferenceOutlivesReferent(_, a) => fmt!(\"ReferenceOutlivesReferent(%s)\", a.repr(tcx)),\n-            BindingTypeIsNotValidAtDecl(a) => fmt!(\"BindingTypeIsNotValidAtDecl(%s)\", a.repr(tcx)),\n-            CallRcvr(a) => fmt!(\"CallRcvr(%s)\", a.repr(tcx)),\n-            CallArg(a) => fmt!(\"CallArg(%s)\", a.repr(tcx)),\n-            CallReturn(a) => fmt!(\"CallReturn(%s)\", a.repr(tcx)),\n-            AddrOf(a) => fmt!(\"AddrOf(%s)\", a.repr(tcx)),\n-            AutoBorrow(a) => fmt!(\"AutoBorrow(%s)\", a.repr(tcx)),\n+            Subtype(a) => format!(\"Subtype({})\", a.repr(tcx)),\n+            InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n+            InvokeClosure(a) => format!(\"InvokeClosure({})\", a.repr(tcx)),\n+            DerefPointer(a) => format!(\"DerefPointer({})\", a.repr(tcx)),\n+            FreeVariable(a) => format!(\"FreeVariable({})\", a.repr(tcx)),\n+            IndexSlice(a) => format!(\"IndexSlice({})\", a.repr(tcx)),\n+            RelateObjectBound(a) => format!(\"RelateObjectBound({})\", a.repr(tcx)),\n+            Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n+            ReferenceOutlivesReferent(_, a) =>\n+                format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx)),\n+            BindingTypeIsNotValidAtDecl(a) =>\n+                format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr(tcx)),\n+            CallRcvr(a) => format!(\"CallRcvr({})\", a.repr(tcx)),\n+            CallArg(a) => format!(\"CallArg({})\", a.repr(tcx)),\n+            CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n+            AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n+            AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n         }\n     }\n }\n@@ -916,20 +918,20 @@ impl RegionVariableOrigin {\n impl Repr for RegionVariableOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            MiscVariable(a) => fmt!(\"MiscVariable(%s)\", a.repr(tcx)),\n-            PatternRegion(a) => fmt!(\"PatternRegion(%s)\", a.repr(tcx)),\n-            AddrOfRegion(a) => fmt!(\"AddrOfRegion(%s)\", a.repr(tcx)),\n-            AddrOfSlice(a) => fmt!(\"AddrOfSlice(%s)\", a.repr(tcx)),\n-            Autoref(a) => fmt!(\"Autoref(%s)\", a.repr(tcx)),\n-            Coercion(a) => fmt!(\"Coercion(%s)\", a.repr(tcx)),\n-            BoundRegionInFnCall(a, b) => fmt!(\"BoundRegionInFnCall(%s,%s)\",\n+            MiscVariable(a) => format!(\"MiscVariable({})\", a.repr(tcx)),\n+            PatternRegion(a) => format!(\"PatternRegion({})\", a.repr(tcx)),\n+            AddrOfRegion(a) => format!(\"AddrOfRegion({})\", a.repr(tcx)),\n+            AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n+            Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n+            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            BoundRegionInFnCall(a, b) => format!(\"BoundRegionInFnCall({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInFnType(a, b) => fmt!(\"BoundRegionInFnType(%s,%s)\",\n+            BoundRegionInFnType(a, b) => format!(\"BoundRegionInFnType({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInTypeOrImpl(a) => fmt!(\"BoundRegionInTypeOrImpl(%s)\",\n+            BoundRegionInTypeOrImpl(a) => format!(\"BoundRegionInTypeOrImpl({})\",\n                                                a.repr(tcx)),\n-            BoundRegionInCoherence => fmt!(\"BoundRegionInCoherence\"),\n-            BoundRegionError(a) => fmt!(\"BoundRegionError(%s)\", a.repr(tcx)),\n+            BoundRegionInCoherence => format!(\"BoundRegionInCoherence\"),\n+            BoundRegionError(a) => format!(\"BoundRegionError({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "e5492453b98e2ffd201b7f3ef765011100853117", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -130,7 +130,7 @@ impl RegionVarBindings {\n     }\n \n     pub fn start_snapshot(&mut self) -> uint {\n-        debug!(\"RegionVarBindings: snapshot()=%u\", self.undo_log.len());\n+        debug2!(\"RegionVarBindings: snapshot()={}\", self.undo_log.len());\n         if self.in_snapshot() {\n             self.undo_log.len()\n         } else {\n@@ -140,17 +140,17 @@ impl RegionVarBindings {\n     }\n \n     pub fn commit(&mut self) {\n-        debug!(\"RegionVarBindings: commit()\");\n+        debug2!(\"RegionVarBindings: commit()\");\n         while self.undo_log.len() > 0 {\n             self.undo_log.pop();\n         }\n     }\n \n     pub fn rollback_to(&mut self, snapshot: uint) {\n-        debug!(\"RegionVarBindings: rollback_to(%u)\", snapshot);\n+        debug2!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         while self.undo_log.len() > snapshot {\n             let undo_item = self.undo_log.pop();\n-            debug!(\"undo_item=%?\", undo_item);\n+            debug2!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n@@ -181,7 +181,7 @@ impl RegionVarBindings {\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n-        debug!(\"created new region variable %? with origin %?\",\n+        debug2!(\"created new region variable {:?} with origin {:?}\",\n                vid, origin.repr(self.tcx));\n         return vid;\n     }\n@@ -218,7 +218,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: add_constraint(%?)\", constraint);\n+        debug2!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n         if self.constraints.insert(constraint, origin) {\n             if self.in_snapshot() {\n@@ -234,7 +234,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n+        debug2!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n           (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n@@ -248,12 +248,12 @@ impl RegionVarBindings {\n           (re_bound(br), _) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                fmt!(\"Cannot relate bound region as subregion: %?\", br));\n+                format!(\"Cannot relate bound region as subregion: {:?}\", br));\n           }\n           (_, re_bound(br)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                fmt!(\"Cannot relate bound region as superregion: %?\", br));\n+                format!(\"Cannot relate bound region as superregion: {:?}\", br));\n           }\n           _ => {\n             self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n@@ -269,7 +269,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n+        debug2!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, _) | (_, re_static) => {\n                 re_static // nothing lives longer than static\n@@ -292,7 +292,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n+        debug2!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -312,12 +312,12 @@ impl RegionVarBindings {\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n                 self.var_origins[rid.to_uint()].span(),\n-                fmt!(\"Attempt to resolve region variable before values have \\\n+                format!(\"Attempt to resolve region variable before values have \\\n                       been computed!\"));\n         }\n \n         let v = self.values.with_ref(|values| values[rid.to_uint()]);\n-        debug!(\"RegionVarBindings: resolve_var(%?=%u)=%?\",\n+        debug2!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n                rid, rid.to_uint(), v);\n         match v {\n             Value(r) => r,\n@@ -367,7 +367,7 @@ impl RegionVarBindings {\n         }\n         relate(self, a, re_infer(ReVar(c)));\n         relate(self, b, re_infer(ReVar(c)));\n-        debug!(\"combine_vars() c=%?\", c);\n+        debug2!(\"combine_vars() c={:?}\", c);\n         re_infer(ReVar(c))\n     }\n \n@@ -390,7 +390,7 @@ impl RegionVarBindings {\n          * regions.\n          */\n \n-        debug!(\"tainted(snapshot=%u, r0=%?)\", snapshot, r0);\n+        debug2!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n         let _indenter = indenter();\n \n         let undo_len = self.undo_log.len();\n@@ -404,7 +404,7 @@ impl RegionVarBindings {\n             // nb: can't use uint::range() here because result_set grows\n             let r = result_set[result_index];\n \n-            debug!(\"result_index=%u, r=%?\", result_index, r);\n+            debug2!(\"result_index={}, r={:?}\", result_index, r);\n \n             let mut undo_index = snapshot;\n             while undo_index < undo_len {\n@@ -469,7 +469,7 @@ impl RegionVarBindings {\n     errors are reported.\n     */\n     pub fn resolve_regions(&mut self) -> OptVec<RegionResolutionError> {\n-        debug!(\"RegionVarBindings: resolve_regions()\");\n+        debug2!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = opt_vec::Empty;\n         let v = self.infer_variable_values(&mut errors);\n         self.values.put_back(v);\n@@ -496,8 +496,8 @@ impl RegionVarBindings {\n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 self.var_origins[v_id.to_uint()].span(),\n-                fmt!(\"lub_concrete_regions invoked with \\\n-                      non-concrete regions: %?, %?\", a, b));\n+                format!(\"lub_concrete_regions invoked with \\\n+                      non-concrete regions: {:?}, {:?}\", a, b));\n           }\n \n           (f @ re_free(ref fr), re_scope(s_id)) |\n@@ -582,7 +582,7 @@ impl RegionVarBindings {\n                             a: Region,\n                             b: Region)\n                          -> cres<Region> {\n-        debug!(\"glb_concrete_regions(%?, %?)\", a, b);\n+        debug2!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -598,8 +598,8 @@ impl RegionVarBindings {\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n                     self.var_origins[v_id.to_uint()].span(),\n-                    fmt!(\"glb_concrete_regions invoked with \\\n-                          non-concrete regions: %?, %?\", a, b));\n+                    format!(\"glb_concrete_regions invoked with \\\n+                          non-concrete regions: {:?}, {:?}\", a, b));\n             }\n \n             (re_free(ref fr), s @ re_scope(s_id)) |\n@@ -691,7 +691,7 @@ impl RegionVarBindings {\n         // scopes or two free regions.  So, if one of\n         // these scopes is a subscope of the other, return\n         // it.  Otherwise fail.\n-        debug!(\"intersect_scopes(scope_a=%?, scope_b=%?, region_a=%?, region_b=%?)\",\n+        debug2!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n                scope_a, scope_b, region_a, region_b);\n         let rm = self.tcx.region_maps;\n         match rm.nearest_common_ancestor(scope_a, scope_b) {\n@@ -778,13 +778,13 @@ impl RegionVarBindings {\n                    b_vid: RegionVid,\n                    b_data: &mut VarData)\n                    -> bool {\n-        debug!(\"expand_node(%?, %? == %?)\",\n+        debug2!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region, b_vid, b_data.value);\n \n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug!(\"Setting initial value of %? to %?\", b_vid, a_region);\n+            debug2!(\"Setting initial value of {:?} to {:?}\", b_vid, a_region);\n \n             b_data.value = Value(a_region);\n             return true;\n@@ -796,7 +796,7 @@ impl RegionVarBindings {\n                 return false;\n             }\n \n-            debug!(\"Expanding value of %? from %? to %?\",\n+            debug2!(\"Expanding value of {:?} from {:?} to {:?}\",\n                    b_vid, cur_region, lub);\n \n             b_data.value = Value(lub);\n@@ -843,7 +843,7 @@ impl RegionVarBindings {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node(%? == %?/%?, %?)\",\n+        debug2!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n                a_vid, a_data.value, a_data.classification, b_region);\n \n         return match a_data.value {\n@@ -876,7 +876,7 @@ impl RegionVarBindings {\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n-                debug!(\"Setting %? to ErrorValue: %? not subregion of %?\",\n+                debug2!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n                        a_vid, a_region, b_region);\n                 a_data.value = ErrorValue;\n             }\n@@ -894,14 +894,14 @@ impl RegionVarBindings {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug!(\"Contracting value of %? from %? to %?\",\n+                        debug2!(\"Contracting value of {:?} from {:?} to {:?}\",\n                                a_vid, a_region, glb);\n                         a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n-                    debug!(\"Setting %? to ErrorValue: no glb of %?, %?\",\n+                    debug2!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n                            a_vid, a_region, b_region);\n                     a_data.value = ErrorValue;\n                     false\n@@ -930,7 +930,7 @@ impl RegionVarBindings {\n                 loop;\n             }\n \n-            debug!(\"ConcreteFailure: !(sub <= sup): sub=%?, sup=%?\",\n+            debug2!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n                    sub, sup);\n             let origin = self.constraints.get_copy(constraint);\n             errors.push(ConcreteFailure(origin, sub, sup));\n@@ -943,7 +943,7 @@ impl RegionVarBindings {\n         errors: &mut OptVec<RegionResolutionError>)\n         -> ~[VarValue]\n     {\n-        debug!(\"extract_values_and_collect_conflicts()\");\n+        debug2!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -1095,8 +1095,8 @@ impl RegionVarBindings {\n \n         self.tcx.sess.span_bug(\n             self.var_origins[node_idx.to_uint()].span(),\n-            fmt!(\"collect_error_for_expanding_node() could not find error \\\n-                  for var %?, lower_bounds=%s, upper_bounds=%s\",\n+            format!(\"collect_error_for_expanding_node() could not find error \\\n+                  for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n                  lower_bounds.map(|x| x.region).repr(self.tcx),\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n@@ -1140,8 +1140,8 @@ impl RegionVarBindings {\n \n         self.tcx.sess.span_bug(\n             self.var_origins[node_idx.to_uint()].span(),\n-            fmt!(\"collect_error_for_contracting_node() could not find error \\\n-                  for var %?, upper_bounds=%s\",\n+            format!(\"collect_error_for_contracting_node() could not find error \\\n+                  for var {:?}, upper_bounds={}\",\n                  node_idx,\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n@@ -1182,8 +1182,8 @@ impl RegionVarBindings {\n                 state.dup_found = true;\n             }\n \n-            debug!(\"collect_concrete_regions(orig_node_idx=%?, node_idx=%?, \\\n-                    classification=%?)\",\n+            debug2!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n+                    classification={:?})\",\n                    orig_node_idx, node_idx, classification);\n \n             // figure out the direction from which this node takes its\n@@ -1204,7 +1204,7 @@ impl RegionVarBindings {\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n-            debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n+            debug2!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.to_uint());\n             do graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n@@ -1240,31 +1240,31 @@ impl RegionVarBindings {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            debug!(\"---- %s Iteration #%u\", tag, iteration);\n+            debug2!(\"---- {} Iteration \\\\#{}\", tag, iteration);\n             for (constraint, _) in self.constraints.iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n-                    debug!(\"Updated due to constraint %s\",\n+                    debug2!(\"Updated due to constraint {}\",\n                            constraint.repr(self.tcx));\n                     changed = true;\n                 }\n             }\n         }\n-        debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n+        debug2!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n     }\n \n }\n \n impl Repr for Constraint {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            ConstrainVarSubVar(a, b) => fmt!(\"ConstrainVarSubVar(%s, %s)\",\n+            ConstrainVarSubVar(a, b) => format!(\"ConstrainVarSubVar({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n-            ConstrainRegSubVar(a, b) => fmt!(\"ConstrainRegSubVar(%s, %s)\",\n+            ConstrainRegSubVar(a, b) => format!(\"ConstrainRegSubVar({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n-            ConstrainVarSubReg(a, b) => fmt!(\"ConstrainVarSubReg(%s, %s)\",\n+            ConstrainVarSubReg(a, b) => format!(\"ConstrainVarSubReg({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n-            ConstrainRegSubReg(a, b) => fmt!(\"ConstrainRegSubReg(%s, %s)\",\n+            ConstrainRegSubReg(a, b) => format!(\"ConstrainRegSubReg({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n         }\n     }"}, {"sha": "57e0ecf874532520075109ae8845f07a642fad6c", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -104,7 +104,7 @@ impl ResolveState {\n     pub fn resolve_type_chk(&mut self, typ: ty::t) -> fres<ty::t> {\n         self.err = None;\n \n-        debug!(\"Resolving %s (modes=%x)\",\n+        debug2!(\"Resolving {} (modes={:x})\",\n                ty_to_str(self.infcx.tcx, typ),\n                self.modes);\n \n@@ -116,7 +116,7 @@ impl ResolveState {\n         assert!(self.v_seen.is_empty());\n         match self.err {\n           None => {\n-            debug!(\"Resolved to %s + %s (modes=%x)\",\n+            debug2!(\"Resolved to {} + {} (modes={:x})\",\n                    ty_to_str(self.infcx.tcx, rty),\n                    ty_to_str(self.infcx.tcx, rty),\n                    self.modes);\n@@ -137,7 +137,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n-        debug!(\"resolve_type(%s)\", typ.inf_str(self.infcx));\n+        debug2!(\"resolve_type({})\", typ.inf_str(self.infcx));\n         let _i = indenter();\n \n         if !ty::type_needs_infer(typ) {\n@@ -179,7 +179,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n-        debug!(\"Resolve_region(%s)\", orig.inf_str(self.infcx));\n+        debug2!(\"Resolve_region({})\", orig.inf_str(self.infcx));\n         match orig {\n           ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig"}, {"sha": "ad251a5be9e9597a7946269635f31bc531f478bb", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -56,7 +56,7 @@ impl Combine for Sub {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"%s.regions(%s, %s)\",\n+        debug2!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -65,7 +65,7 @@ impl Combine for Sub {\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        debug!(\"mts(%s <: %s)\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n+        debug2!(\"mts({} <: {})\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -110,7 +110,7 @@ impl Combine for Sub {\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        debug!(\"%s.tys(%s, %s)\", self.tag(),\n+        debug2!(\"{}.tys({}, {})\", self.tag(),\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         if a == b { return Ok(a); }\n         let _indenter = indenter();\n@@ -143,7 +143,7 @@ impl Combine for Sub {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        debug!(\"fn_sigs(a=%s, b=%s)\",\n+        debug2!(\"fn_sigs(a={}, b={})\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n@@ -172,15 +172,15 @@ impl Combine for Sub {\n             do replace_bound_regions_in_fn_sig(self.infcx.tcx, @Nil,\n                                               None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n-                debug!(\"Bound region %s skolemized to %?\",\n+                debug2!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             }\n         };\n \n-        debug!(\"a_sig=%s\", a_sig.inf_str(self.infcx));\n-        debug!(\"b_sig=%s\", b_sig.inf_str(self.infcx));\n+        debug2!(\"a_sig={}\", a_sig.inf_str(self.infcx));\n+        debug2!(\"b_sig={}\", b_sig.inf_str(self.infcx));\n \n         // Compare types now that bound regions have been replaced.\n         let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));"}, {"sha": "8792a068671d381a1b0b26dd0cd4fde944bc75d7", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -100,7 +100,7 @@ impl Env {\n         return match search_mod(self, &self.crate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n-                fail!(\"No item found: `%s`\", names.connect(\"::\"));\n+                fail2!(\"No item found: `%s`\", names.connect(\"::\"));\n             }\n         };\n \n@@ -153,15 +153,15 @@ impl Env {\n \n     pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n-            fail!(\"%s is not a subtype of %s, but it should be\",\n+            fail2!(\"%s is not a subtype of %s, but it should be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n     }\n \n     pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n-            fail!(\"%s is a subtype of %s, but it shouldn't be\",\n+            fail2!(\"%s is a subtype of %s, but it shouldn't be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n@@ -223,14 +223,14 @@ impl Env {\n     pub fn glb() -> Glb { Glb(self.infcx.combine_fields(true, dummy_sp())) }\n \n     pub fn resolve_regions(exp_count: uint) {\n-        debug!(\"resolve_regions(%u)\", exp_count);\n+        debug2!(\"resolve_regions(%u)\", exp_count);\n \n         self.infcx.resolve_regions();\n         if self.err_messages.len() != exp_count {\n             for msg in self.err_messages.iter() {\n-                debug!(\"Error encountered: %s\", *msg);\n+                debug2!(\"Error encountered: %s\", *msg);\n             }\n-            fmt!(\"Resolving regions encountered %u errors but expected %u!\",\n+            format!(\"Resolving regions encountered %u errors but expected %u!\",\n                  self.err_messages.len(),\n                  exp_count);\n         }\n@@ -240,7 +240,7 @@ impl Env {\n     pub fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n         match self.lub().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"Unexpected error computing LUB: %?\", e)\n+                fail2!(\"Unexpected error computing LUB: %?\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n@@ -256,13 +256,13 @@ impl Env {\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n-        debug!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n+        debug2!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n                self.ty_to_str(t1),\n                self.ty_to_str(t2),\n                self.ty_to_str(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"Unexpected error computing LUB: %?\", e)\n+                fail2!(\"Unexpected error computing LUB: %?\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);\n@@ -281,7 +281,7 @@ impl Env {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"Unexpected success computing LUB: %?\", self.ty_to_str(t))\n+                fail2!(\"Unexpected success computing LUB: %?\", self.ty_to_str(t))\n             }\n         }\n     }\n@@ -291,7 +291,7 @@ impl Env {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"Unexpected success computing GLB: %?\", self.ty_to_str(t))\n+                fail2!(\"Unexpected success computing GLB: %?\", self.ty_to_str(t))\n             }\n         }\n     }"}, {"sha": "2bb7a994593d7d45f3ff644778a8c9208eacffbd", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -31,7 +31,7 @@ impl InferStr for ty::t {\n \n impl InferStr for FnSig {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        fmt!(\"(%s) -> %s\",\n+        format!(\"({}) -> {}\",\n              self.inputs.map(|a| a.inf_str(cx)).connect(\", \"),\n              self.output.inf_str(cx))\n     }\n@@ -45,7 +45,7 @@ impl InferStr for ty::mt {\n \n impl InferStr for ty::Region {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -60,7 +60,7 @@ impl<V:InferStr> InferStr for Bound<V> {\n \n impl<T:InferStr> InferStr for Bounds<T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        fmt!(\"{%s <: %s}\",\n+        format!(\"\\\\{{} <: {}\\\\}\",\n              self.lb.inf_str(cx),\n              self.ub.inf_str(cx))\n     }\n@@ -69,8 +69,8 @@ impl<T:InferStr> InferStr for Bounds<T> {\n impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n-          Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n-          Root(ref pt, rk) => fmt!(\"Root(%s, %s)\", pt.inf_str(cx),\n+          Redirect(ref vid) => format!(\"Redirect({})\", vid.to_str()),\n+          Root(ref pt, rk) => format!(\"Root({}, {})\", pt.inf_str(cx),\n                                rk.to_str_radix(10u))\n         }\n     }"}, {"sha": "c05306a27be429fddbc1007e4328da3372c2995a", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -85,8 +85,8 @@ impl UnifyInferCtxtMethods for InferCtxt {\n             let var_val = match vb.vals.find(&vid_u) {\n                 Some(&ref var_val) => (*var_val).clone(),\n                 None => {\n-                    tcx.sess.bug(fmt!(\n-                        \"failed lookup of vid `%u`\", vid_u));\n+                    tcx.sess.bug(format!(\n+                        \"failed lookup of vid `{}`\", vid_u));\n                 }\n             };\n             match var_val {\n@@ -116,7 +116,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n          */\n \n-        debug!(\"Updating variable %s to %s\",\n+        debug2!(\"Updating variable {} to {}\",\n                vid.to_str(), new_v.inf_str(self));\n \n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n@@ -134,8 +134,8 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n \n-        debug!(\"unify(node_a(id=%?, rank=%?), \\\n-                node_b(id=%?, rank=%?))\",\n+        debug2!(\"unify(node_a(id={:?}, rank={:?}), \\\n+                node_b(id={:?}, rank={:?}))\",\n                node_a.root, node_a.rank,\n                node_b.root, node_b.rank);\n "}, {"sha": "5db706765e9b8f660bd6d95c93c32ff9a4aa94d3", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -178,15 +178,15 @@ impl Repr for vtable_origin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                fmt!(\"vtable_static(%?:%s, %s, %s)\",\n+                format!(\"vtable_static({:?}:{}, {}, {})\",\n                      def_id,\n                      ty::item_path_str(tcx, def_id),\n                      tys.repr(tcx),\n                      vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n-                fmt!(\"vtable_param(%?, %?)\", x, y)\n+                format!(\"vtable_param({:?}, {:?})\", x, y)\n             }\n         }\n     }\n@@ -208,7 +208,7 @@ pub struct impl_res {\n \n impl Repr for impl_res {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"impl_res {trait_vtables=%s, self_vtables=%s}\",\n+        format!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n              self.trait_vtables.repr(tcx),\n              self.self_vtables.repr(tcx))\n     }\n@@ -226,15 +226,15 @@ pub struct CrateCtxt {\n \n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n-    debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n+    debug2!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::NodeId,\n                            substs: ~[ty::t]) {\n     if substs.len() > 0u {\n-        debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n+        debug2!(\"write_substs_to_tcx({}, {:?})\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n         assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n         tcx.node_type_substs.insert(node_id, substs);\n@@ -361,12 +361,12 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n-                || fmt!(\"main function expects type: `%s`\",\n+                || format!(\"main function expects type: `{}`\",\n                         ppaux::ty_to_str(ccx.tcx, se_ty)));\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n-                              fmt!(\"main has a non-function type: found `%s`\",\n+                              format!(\"main has a non-function type: found `{}`\",\n                                    ppaux::ty_to_str(tcx, main_t)));\n         }\n     }\n@@ -409,12 +409,12 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n-                || fmt!(\"start function expects type: `%s`\", ppaux::ty_to_str(ccx.tcx, se_ty)));\n+                || format!(\"start function expects type: `{}`\", ppaux::ty_to_str(ccx.tcx, se_ty)));\n \n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n-                              fmt!(\"start has a non-function type: found `%s`\",\n+                              format!(\"start has a non-function type: found `{}`\",\n                                    ppaux::ty_to_str(tcx, start_t)));\n         }\n     }"}, {"sha": "f6483a48ed00dfad377b9c2b6c53405e07d4c481", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -235,7 +235,7 @@ impl RegionScope for TypeRscope {\n             None => {\n                 // if the self region is used, region parameterization should\n                 // have inferred that this type is RP\n-                fail!(\"region parameterization should have inferred that \\\n+                fail2!(\"region parameterization should have inferred that \\\n                         this type is RP\");\n             }\n             Some(ref region_parameterization) => {"}, {"sha": "a7065624395663a16c1a2fea3f755db19375d916", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -135,7 +135,7 @@ pub fn version(argv0: &str) {\n }\n \n pub fn usage(argv0: &str) {\n-    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n+    let message = format!(\"Usage: {} [OPTIONS] INPUT\", argv0);\n     println!(\"{}\\n\\\n Additional help:\n     -W help             Print 'lint' options and default settings\n@@ -388,7 +388,7 @@ pub fn monitor(f: ~fn(@diagnostic::Emitter)) {\n                 }\n             }\n             // Fail so the process returns a failure code\n-            fail!();\n+            fail2!();\n         }\n     }\n }"}, {"sha": "5058be7c16623daf3d2a058aeaf2ebe60ee6871a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -29,9 +29,9 @@ pub fn time<T, U>(do_it: bool, what: ~str, u: U, f: &fn(U) -> T) -> T {\n pub fn indent<R>(op: &fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n-    debug!(\">>\");\n+    debug2!(\">>\");\n     let r = op();\n-    debug!(\"<< (Result = %?)\", r);\n+    debug2!(\"<< (Result = {:?})\", r);\n     r\n }\n \n@@ -40,7 +40,7 @@ pub struct _indenter {\n }\n \n impl Drop for _indenter {\n-    fn drop(&mut self) { debug!(\"<<\"); }\n+    fn drop(&mut self) { debug2!(\"<<\"); }\n }\n \n pub fn _indenter(_i: ()) -> _indenter {\n@@ -50,7 +50,7 @@ pub fn _indenter(_i: ()) -> _indenter {\n }\n \n pub fn indenter() -> _indenter {\n-    debug!(\">>\");\n+    debug2!(\">>\");\n     _indenter(())\n }\n \n@@ -120,7 +120,7 @@ pub fn local_rhs_span(l: @ast::Local, def: Span) -> Span {\n \n pub fn pluralize(n: uint, s: ~str) -> ~str {\n     if n == 1 { s }\n-    else { fmt!(\"%ss\", s) }\n+    else { format!(\"{}s\", s) }\n }\n \n // A set of node IDs (used to keep track of which node IDs are for statements)"}, {"sha": "bbca28f134f8daedfef47b6aff0176e51db3adc9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -51,11 +51,11 @@ pub fn note_and_explain_region(cx: ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            fmt!(\"%s%s%s\", prefix, (*str), suffix));\n+            format!(\"{}{}{}\", prefix, (*str), suffix));\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            fmt!(\"%s%s%s\", prefix, (*str), suffix));\n+            format!(\"{}{}{}\", prefix, (*str), suffix));\n       }\n     }\n }\n@@ -98,29 +98,29 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (fmt!(\"unknown scope: %d.  Please report a bug.\", node_id),\n+            (format!(\"unknown scope: {}.  Please report a bug.\", node_id),\n              None)\n           }\n         }\n       }\n \n       re_free(ref fr) => {\n         let prefix = match fr.bound_region {\n-          br_anon(idx) => fmt!(\"the anonymous lifetime #%u defined on\",\n+          br_anon(idx) => format!(\"the anonymous lifetime \\\\#{} defined on\",\n                                idx + 1),\n-          br_fresh(_) => fmt!(\"an anonymous lifetime defined on\"),\n-          _ => fmt!(\"the lifetime %s as defined on\",\n+          br_fresh(_) => format!(\"an anonymous lifetime defined on\"),\n+          _ => format!(\"the lifetime {} as defined on\",\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n \n         match cx.items.find(&fr.scope_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n-            (fmt!(\"%s %s\", prefix, msg), opt_span)\n+            (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (fmt!(\"%s node %d\", prefix, fr.scope_id), None)\n+            (format!(\"{} node {}\", prefix, fr.scope_id), None)\n           }\n         }\n       }\n@@ -132,15 +132,15 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       re_infer(_) | re_bound(_) => {\n-        (fmt!(\"lifetime %?\", region), None)\n+        (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n \n     fn explain_span(cx: ctxt, heading: &str, span: Span)\n         -> (~str, Option<Span>)\n     {\n         let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n-        (fmt!(\"the %s at %u:%u\", heading,\n+        (format!(\"the {} at {}:{}\", heading,\n               lo.line, lo.col.to_uint()), Some(span))\n     }\n }\n@@ -154,11 +154,11 @@ pub fn bound_region_to_str(cx: ctxt,\n                            br: bound_region) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n \n-    if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, space_str); }\n+    if cx.sess.verbose() { return format!(\"{}{:?}{}\", prefix, br, space_str); }\n \n     match br {\n-      br_named(id)         => fmt!(\"%s'%s%s\", prefix, cx.sess.str_of(id), space_str),\n-      br_self              => fmt!(\"%s'self%s\", prefix, space_str),\n+      br_named(id)         => format!(\"{}'{}{}\", prefix, cx.sess.str_of(id), space_str),\n+      br_self              => format!(\"{}'self{}\", prefix, space_str),\n       br_anon(_)           => prefix.to_str(),\n       br_fresh(_)          => prefix.to_str(),\n       br_cap_avoid(_, br)  => bound_region_to_str(cx, prefix, space, *br)\n@@ -168,37 +168,37 @@ pub fn bound_region_to_str(cx: ctxt,\n pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.items.find(&node_id) {\n       Some(&ast_map::node_block(ref blk)) => {\n-        fmt!(\"<block at %s>\",\n+        format!(\"<block at {}>\",\n              cx.sess.codemap.span_to_str(blk.span))\n       }\n       Some(&ast_map::node_expr(expr)) => {\n         match expr.node {\n           ast::ExprCall(*) => {\n-            fmt!(\"<call at %s>\",\n+            format!(\"<call at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::ExprMatch(*) => {\n-            fmt!(\"<match at %s>\",\n+            format!(\"<match at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::ExprAssignOp(*) |\n           ast::ExprUnary(*) |\n           ast::ExprBinary(*) |\n           ast::ExprIndex(*) => {\n-            fmt!(\"<method at %s>\",\n+            format!(\"<method at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           _ => {\n-            fmt!(\"<expression at %s>\",\n+            format!(\"<expression at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n         }\n       }\n       None => {\n-        fmt!(\"<unknown-%d>\", node_id)\n+        format!(\"<unknown-{}>\", node_id)\n       }\n       _ => { cx.sess.bug(\n-          fmt!(\"re_scope refers to %s\",\n+          format!(\"re_scope refers to {}\",\n                ast_map::node_id_to_str(cx.items, node_id,\n                                        token::get_ident_interner()))) }\n     }\n@@ -215,7 +215,7 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n-        return fmt!(\"%s%?%s\", prefix, region, space_str);\n+        return format!(\"{}{:?}{}\", prefix, region, space_str);\n     }\n \n     // These printouts are concise.  They do not contain all the information\n@@ -230,8 +230,8 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n             bound_region_to_str(cx, prefix, space, br)\n         }\n         re_infer(ReVar(_)) => prefix.to_str(),\n-        re_static => fmt!(\"%s'static%s\", prefix, space_str),\n-        re_empty => fmt!(\"%s'<empty>%s\", prefix, space_str)\n+        re_static => format!(\"{}'static{}\", prefix, space_str),\n+        re_empty => format!(\"{}'<empty>{}\", prefix, space_str)\n     }\n }\n \n@@ -248,12 +248,12 @@ pub fn mt_to_str(cx: ctxt, m: &mt) -> ~str {\n \n pub fn mt_to_str_wrapped(cx: ctxt, before: &str, m: &mt, after: &str) -> ~str {\n     let mstr = mutability_to_str(m.mutbl);\n-    return fmt!(\"%s%s%s%s\", mstr, before, ty_to_str(cx, m.ty), after);\n+    return format!(\"{}{}{}{}\", mstr, before, ty_to_str(cx, m.ty), after);\n }\n \n pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n     match vs {\n-      ty::vstore_fixed(n) => fmt!(\"%u\", n),\n+      ty::vstore_fixed(n) => format!(\"{}\", n),\n       ty::vstore_uniq => ~\"~\",\n       ty::vstore_box => ~\"@\",\n       ty::vstore_slice(r) => region_ptr_to_str(cx, r)\n@@ -271,25 +271,25 @@ pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     match vs {\n         ty::vstore_fixed(_) => {\n-            fmt!(\"[%s, .. %s]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n+            format!(\"[{}, .. {}]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n         }\n         _ => {\n-            fmt!(\"%s%s\", vstore_to_str(cx, vs), mt_to_str_wrapped(cx, \"[\", mt, \"]\"))\n+            format!(\"{}{}\", vstore_to_str(cx, vs), mt_to_str_wrapped(cx, \"[\", mt, \"]\"))\n         }\n     }\n }\n \n pub fn vec_map_to_str<T>(ts: &[T], f: &fn(t: &T) -> ~str) -> ~str {\n     let tstrs = ts.map(f);\n-    fmt!(\"[%s]\", tstrs.connect(\", \"))\n+    format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     vec_map_to_str(ts, |t| ty_to_str(cx, *t))\n }\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n-    fmt!(\"fn%s -> %s\",\n+    format!(\"fn{} -> {}\",\n          tys_to_str(cx, typ.inputs.map(|a| *a)),\n          ty_to_str(cx, typ.output))\n }\n@@ -397,7 +397,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                        &m.fty.sig) + \";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return fmt!(\"%s: %s\", cx.sess.str_of(f.ident), mt_to_str(cx, &f.mt));\n+        return format!(\"{}: {}\", cx.sess.str_of(f.ident), mt_to_str(cx, &f.mt));\n     }\n \n     // if there is an id, print that instead of the structural type:\n@@ -425,7 +425,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_rptr(r, ref tm) => {\n         region_ptr_to_str(cx, r) + mt_to_str(cx, tm)\n       }\n-      ty_unboxed_vec(ref tm) => { fmt!(\"unboxed_vec<%s>\", mt_to_str(cx, tm)) }\n+      ty_unboxed_vec(ref tm) => { format!(\"unboxed_vec<{}>\", mt_to_str(cx, tm)) }\n       ty_type => ~\"type\",\n       ty_tup(ref elems) => {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n@@ -447,10 +447,10 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n               }\n               None => {\n                   // This should not happen...\n-                  fmt!(\"BUG[%?]\", id)\n+                  format!(\"BUG[{:?}]\", id)\n               }\n           };\n-          if !cx.sess.verbose() { ident } else { fmt!(\"%s:%?\", ident, did) }\n+          if !cx.sess.verbose() { ident } else { format!(\"{}:{:?}\", ident, did) }\n       }\n       ty_self(*) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n@@ -464,13 +464,13 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         let ty = parameterized(cx, base, &substs.regions, substs.tps);\n         let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n         let bound_str = bounds.repr(cx);\n-        fmt!(\"%s%s%s%s%s\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n+        format!(\"{}{}{}{}{}\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n                            bound_sep, bound_str)\n       }\n       ty_evec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)\n       }\n-      ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), \"str\"),\n+      ty_estr(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n       ty_opaque_box => ~\"@?\",\n       ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n       ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\",\n@@ -498,9 +498,9 @@ pub fn parameterized(cx: ctxt,\n     }\n \n     if strs.len() > 0u {\n-        fmt!(\"%s<%s>\", base, strs.connect(\",\"))\n+        format!(\"{}<{}>\", base, strs.connect(\",\"))\n     } else {\n-        fmt!(\"%s\", base)\n+        format!(\"{}\", base)\n     }\n }\n \n@@ -514,7 +514,7 @@ impl<T:Repr> Repr for Option<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n             &None => ~\"None\",\n-            &Some(ref t) => fmt!(\"Some(%s)\", t.repr(tcx))\n+            &Some(ref t) => format!(\"Some({})\", t.repr(tcx))\n         }\n     }\n }\n@@ -560,7 +560,7 @@ impl<T:Repr> Repr for ~[T] {\n \n impl Repr for ty::TypeParameterDef {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"TypeParameterDef {%?, bounds: %s}\",\n+        format!(\"TypeParameterDef \\\\{{:?}, bounds: {}\\\\}\",\n              self.def_id, self.bounds.repr(tcx))\n     }\n }\n@@ -573,7 +573,7 @@ impl Repr for ty::t {\n \n impl Repr for ty::substs {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"substs(regions=%s, self_ty=%s, tps=%s)\",\n+        format!(\"substs(regions={}, self_ty={}, tps={})\",\n              self.regions.repr(tcx),\n              self.self_ty.repr(tcx),\n              self.tps.repr(tcx))\n@@ -615,15 +615,15 @@ impl Repr for ty::TraitRef {\n \n impl Repr for ast::Expr {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"expr(%d: %s)\",\n+        format!(\"expr({}: {})\",\n              self.id,\n              pprust::expr_to_str(self, tcx.sess.intr()))\n     }\n }\n \n impl Repr for ast::Pat {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"pat(%d: %s)\",\n+        format!(\"pat({}: {})\",\n              self.id,\n              pprust::pat_to_str(self, tcx.sess.intr()))\n     }\n@@ -654,35 +654,35 @@ impl Repr for ast::DefId {\n                 Some(&ast_map::node_trait_method(*)) |\n                 Some(&ast_map::node_variant(*)) |\n                 Some(&ast_map::node_struct_ctor(*)) => {\n-                    return fmt!(\"%?:%s\", *self, ty::item_path_str(tcx, *self));\n+                    return format!(\"{:?}:{}\", *self, ty::item_path_str(tcx, *self));\n                 }\n                 _ => {}\n             }\n         }\n-        return fmt!(\"%?\", *self);\n+        return format!(\"{:?}\", *self);\n     }\n }\n \n impl Repr for ty::ty_param_bounds_and_ty {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"ty_param_bounds_and_ty {generics: %s, ty: %s}\",\n+        format!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n              self.generics.repr(tcx),\n              self.ty.repr(tcx))\n     }\n }\n \n impl Repr for ty::Generics {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"Generics {type_param_defs: %s, region_param: %?}\",\n+        format!(\"Generics \\\\{type_param_defs: {}, region_param: {:?}\\\\}\",\n              self.type_param_defs.repr(tcx),\n              self.region_param)\n     }\n }\n \n impl Repr for ty::Method {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method {ident: %s, generics: %s, transformed_self_ty: %s, \\\n-              fty: %s, explicit_self: %s, vis: %s, def_id: %s}\",\n+        format!(\"method \\\\{ident: {}, generics: {}, transformed_self_ty: {}, \\\n+              fty: {}, explicit_self: {}, vis: {}, def_id: {}\\\\}\",\n              self.ident.repr(tcx),\n              self.generics.repr(tcx),\n              self.transformed_self_ty.repr(tcx),\n@@ -701,19 +701,19 @@ impl Repr for ast::Ident {\n \n impl Repr for ast::explicit_self_ {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ast::visibility {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"BareFnTy {purity: %?, abis: %s, sig: %s}\",\n+        format!(\"BareFnTy \\\\{purity: {:?}, abis: {}, sig: {}\\\\}\",\n              self.purity,\n              self.abis.to_str(),\n              self.sig.repr(tcx))\n@@ -728,9 +728,9 @@ impl Repr for ty::FnSig {\n \n impl Repr for typeck::method_map_entry {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method_map_entry {self_arg: %s, \\\n-              explicit_self: %s, \\\n-              origin: %s}\",\n+        format!(\"method_map_entry \\\\{self_arg: {}, \\\n+              explicit_self: {}, \\\n+              origin: {}\\\\}\",\n              self.self_ty.repr(tcx),\n              self.explicit_self.repr(tcx),\n              self.origin.repr(tcx))\n@@ -741,7 +741,7 @@ impl Repr for typeck::method_origin {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n             &typeck::method_static(def_id) => {\n-                fmt!(\"method_static(%s)\", def_id.repr(tcx))\n+                format!(\"method_static({})\", def_id.repr(tcx))\n             }\n             &typeck::method_param(ref p) => {\n                 p.repr(tcx)\n@@ -755,7 +755,7 @@ impl Repr for typeck::method_origin {\n \n impl Repr for typeck::method_param {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method_param(%s,%?,%?,%?)\",\n+        format!(\"method_param({},{:?},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n              self.param_num,\n@@ -765,7 +765,7 @@ impl Repr for typeck::method_param {\n \n impl Repr for typeck::method_object {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method_object(%s,%?,%?)\",\n+        format!(\"method_object({},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n              self.real_index)\n@@ -775,7 +775,7 @@ impl Repr for typeck::method_object {\n \n impl Repr for ty::RegionVid {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -784,7 +784,7 @@ impl Repr for ty::TraitStore {\n         match self {\n             &ty::BoxTraitStore => ~\"@Trait\",\n             &ty::UniqTraitStore => ~\"~Trait\",\n-            &ty::RegionTraitStore(r) => fmt!(\"&%s Trait\", r.repr(tcx))\n+            &ty::RegionTraitStore(r) => format!(\"&{} Trait\", r.repr(tcx))\n         }\n     }\n }\n@@ -807,7 +807,7 @@ impl Repr for ast_map::path_elt {\n \n impl Repr for ty::BuiltinBound {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n "}, {"sha": "b0f2ba286e6915f7c464b1824df6243e4c363131", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -71,7 +71,7 @@ impl Clean<Crate> for visit_ast::RustdocVisitor {\n         Crate {\n             name: match maybe_meta {\n                 Some(x) => x.to_owned(),\n-                None => fail!(\"rustdoc_ng requires a #[link(name=\\\"foo\\\")] crate attribute\"),\n+                None => fail2!(\"rustdoc_ng requires a \\\\#[link(name=\\\"foo\\\")] crate attribute\"),\n             },\n             module: Some(self.module.clean()),\n         }\n@@ -575,9 +575,9 @@ pub enum Type {\n impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n-        debug!(\"cleaning type `%?`\", self);\n+        debug2!(\"cleaning type `{:?}`\", self);\n         let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n-        debug!(\"span corresponds to `%s`\", codemap.span_to_str(self.span));\n+        debug2!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             ty_nil => Unit,\n             ty_ptr(ref m) => RawPointer(m.mutbl.clean(), ~m.ty.clean()),\n@@ -595,7 +595,7 @@ impl Clean<Type> for ast::Ty {\n             ty_closure(ref c) => Closure(~c.clean()),\n             ty_bare_fn(ref barefn) => BareFunction(~barefn.clean()),\n             ty_bot => Bottom,\n-            ref x => fail!(\"Unimplemented type %?\", x),\n+            ref x => fail2!(\"Unimplemented type {:?}\", x),\n         }\n     }\n }\n@@ -873,7 +873,7 @@ pub struct Static {\n \n impl Clean<Item> for doctree::Static {\n     fn clean(&self) -> Item {\n-        debug!(\"claning static %s: %?\", self.name.clean(), self);\n+        debug2!(\"claning static {}: {:?}\", self.name.clean(), self);\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n@@ -1053,13 +1053,13 @@ trait ToSource {\n \n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n-        debug!(\"converting span %? to snippet\", self.clean());\n+        debug2!(\"converting span {:?} to snippet\", self.clean());\n         let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap.clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n             None    => ~\"\"\n         };\n-        debug!(\"got snippet %s\", sn);\n+        debug2!(\"got snippet {}\", sn);\n         sn\n     }\n }\n@@ -1084,17 +1084,17 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n         PatWild => ~\"_\",\n         PatIdent(_, ref p, _) => path_to_str(p),\n         PatEnum(ref p, _) => path_to_str(p),\n-        PatStruct(*) => fail!(\"tried to get argument name from pat_struct, \\\n+        PatStruct(*) => fail2!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n         PatTup(*) => ~\"(tuple arg NYI)\",\n         PatBox(p) => name_from_pat(p),\n         PatUniq(p) => name_from_pat(p),\n         PatRegion(p) => name_from_pat(p),\n-        PatLit(*) => fail!(\"tried to get argument name from pat_lit, \\\n+        PatLit(*) => fail2!(\"tried to get argument name from pat_lit, \\\n                             which is not allowed in function arguments\"),\n-        PatRange(*) => fail!(\"tried to get argument name from pat_range, \\\n+        PatRange(*) => fail2!(\"tried to get argument name from pat_range, \\\n                               which is not allowed in function arguments\"),\n-        PatVec(*) => fail!(\"tried to get argument name from pat_vec, \\\n+        PatVec(*) => fail2!(\"tried to get argument name from pat_vec, \\\n                              which is not allowed in function arguments\")\n     }\n }\n@@ -1117,14 +1117,14 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n     use syntax::ast::*;\n \n     let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n-    debug!(\"searching for %? in defmap\", id);\n+    debug2!(\"searching for {:?} in defmap\", id);\n     let d = match dm.find(&id) {\n         Some(k) => k,\n         None => {\n             let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n-            debug!(\"could not find %? in defmap (`%s`)\", id,\n+            debug2!(\"could not find {:?} in defmap (`{}`)\", id,\n                    syntax::ast_map::node_id_to_str(ctxt.tycx.items, id, ctxt.sess.intr()));\n-            fail!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n+            fail2!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n         }\n     };\n \n@@ -1133,7 +1133,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         DefSelf(i) | DefSelfTy(i) => return Self(i),\n         DefTy(i) => i,\n         DefTrait(i) => {\n-            debug!(\"saw DefTrait in def_to_id\");\n+            debug2!(\"saw DefTrait in def_to_id\");\n             i\n         },\n         DefPrimTy(p) => match p {\n@@ -1144,10 +1144,10 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         DefTyParam(i, _) => return Generic(i.node),\n         DefStruct(i) => i,\n         DefTyParamBinder(i) => {\n-            debug!(\"found a typaram_binder, what is it? %d\", i);\n+            debug2!(\"found a typaram_binder, what is it? {}\", i);\n             return TyParamBinder(i);\n         },\n-        x => fail!(\"resolved type maps to a weird def %?\", x),\n+        x => fail2!(\"resolved type maps to a weird def {:?}\", x),\n     };\n     ResolvedPath{ path: path, typarams: tpbs, did: def_id }\n }"}, {"sha": "7537366014e052ed9a4a55ac87ddb55aecbb3e8b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -62,15 +62,15 @@ fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n     crate = phase_2_configure_and_expand(sess, cfg, crate);\n     let analysis = phase_3_run_analysis_passes(sess, &crate);\n \n-    debug!(\"crate: %?\", crate);\n+    debug2!(\"crate: {:?}\", crate);\n     DocContext { crate: crate, tycx: analysis.ty_cx, sess: sess }\n }\n \n pub fn run_core (libs: ~[Path], path: &Path) -> clean::Crate {\n     let ctxt = @get_ast_and_resolve(path, libs);\n-    debug!(\"defmap:\");\n+    debug2!(\"defmap:\");\n     for (k, v) in ctxt.tycx.def_map.iter() {\n-        debug!(\"%?: %?\", k, v);\n+        debug2!(\"{:?}: {:?}\", k, v);\n     }\n     local_data::set(super::ctxtkey, ctxt);\n "}, {"sha": "441f25f33e6afcae89ad714a98d1a688822cf149", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -205,7 +205,7 @@ fn mkdir(path: &Path) {\n     do io::io_error::cond.trap(|err| {\n         error2!(\"Couldn't create directory `{}`: {}\",\n                 path.to_str(), err.desc);\n-        fail!()\n+        fail2!()\n     }).inside {\n         if !path.is_dir() {\n             file::mkdir(path);"}, {"sha": "8f1955fb423209d71c91e7259d3aa6eb2b9b42e4", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -32,7 +32,7 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n                         for innerattr in l.iter() {\n                             match innerattr {\n                                 &clean::Word(ref s) if \"hidden\" == *s => {\n-                                    debug!(\"found one in strip_hidden; removing\");\n+                                    debug2!(\"found one in strip_hidden; removing\");\n                                     return None;\n                                 },\n                                 _ => (),"}, {"sha": "57aa62d313cc73442a6ab04c23518eb65bab4ab4", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -238,7 +238,7 @@ fn jsonify(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     };\n     let crate_json = match extra::json::from_str(crate_json_str) {\n         Ok(j) => j,\n-        Err(_) => fail!(\"Rust generated JSON is invalid??\")\n+        Err(_) => fail2!(\"Rust generated JSON is invalid??\")\n     };\n \n     json.insert(~\"crate\", crate_json);"}, {"sha": "9fd4c43c2543759b3e025cfb3c4363416b353163", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -37,7 +37,7 @@ impl RustdocVisitor {\n         self.attrs = crate.attrs.clone();\n         fn visit_struct_def(item: &ast::item, sd: @ast::struct_def, generics:\n                             &ast::Generics) -> Struct {\n-            debug!(\"Visiting struct\");\n+            debug2!(\"Visiting struct\");\n             let struct_type = struct_type_from_def(sd);\n             Struct {\n                 id: item.id,\n@@ -52,7 +52,7 @@ impl RustdocVisitor {\n         }\n \n         fn visit_enum_def(it: &ast::item, def: &ast::enum_def, params: &ast::Generics) -> Enum {\n-            debug!(\"Visiting enum\");\n+            debug2!(\"Visiting enum\");\n             let mut vars: ~[Variant] = ~[];\n             for x in def.variants.iter() {\n                 vars.push(Variant {\n@@ -77,7 +77,7 @@ impl RustdocVisitor {\n \n         fn visit_fn(item: &ast::item, fd: &ast::fn_decl, purity: &ast::purity,\n                      _abi: &AbiSet, gen: &ast::Generics) -> Function {\n-            debug!(\"Visiting fn\");\n+            debug2!(\"Visiting fn\");\n             Function {\n                 id: item.id,\n                 vis: item.vis,\n@@ -96,7 +96,7 @@ impl RustdocVisitor {\n             let name = match am.find(&id) {\n                 Some(m) => match m {\n                     &ast_map::node_item(ref it, _) => Some(it.ident),\n-                    _ => fail!(\"mod id mapped to non-item in the ast map\")\n+                    _ => fail2!(\"mod id mapped to non-item in the ast map\")\n                 },\n                 None => None\n             };\n@@ -113,7 +113,7 @@ impl RustdocVisitor {\n         }\n \n         fn visit_item(item: &ast::item, om: &mut Module) {\n-            debug!(\"Visiting item %?\", item);\n+            debug2!(\"Visiting item {:?}\", item);\n             match item.node {\n                 ast::item_mod(ref m) => {\n                     om.mods.push(visit_mod_contents(item.span, item.attrs.clone(),"}, {"sha": "0053d7137768d3a9df03cd428fa9055bbb931ba5", "filename": "src/librusti/program.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -100,7 +100,7 @@ impl Program {\n         // It's easy to initialize things if we don't run things...\n         for (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n-            code.push_str(fmt!(\"let%s %s: %s = fail!();\\n\", mt, *name, var.ty));\n+            code.push_str(format!(\"let{} {}: {} = fail!();\\n\", mt, *name, var.ty));\n             var.alter(*name, &mut code);\n         }\n         code.push_str(\"{\\n\");\n@@ -115,7 +115,7 @@ impl Program {\n         }\n \n         for p in new_locals.iter() {\n-            code.push_str(fmt!(\"assert_encodable(&%s);\\n\", *p.first_ref()));\n+            code.push_str(format!(\"assert_encodable(&{});\\n\", *p.first_ref()));\n         }\n         code.push_str(\"};}\");\n         return code;\n@@ -138,22 +138,22 @@ impl Program {\n         // variables. This works by totally legitimately using the 'code'\n         // pointer of the 'tls_key' function as a uint, and then casting it back\n         // up to a function\n-        code.push_str(fmt!(\"\n-            let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe {\n-                let key = ::std::cast::transmute(%u);\n+        code.push_str(format!(\"\n+            let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe \\\\{\n+                let key = ::std::cast::transmute({});\n                 ::std::local_data::get(key, |k| k.map(|&x| *x)).unwrap()\n-            };\\n\", key as uint));\n+            \\\\};\\n\", key));\n \n         // Using this __tls_map handle, deserialize each variable binding that\n         // we know about\n         for (name, var) in self.local_vars.iter() {\n             let mt = var.mt();\n-            code.push_str(fmt!(\"let%s %s: %s = {\n-                let data = __tls_map.get_copy(&~\\\"%s\\\");\n+            code.push_str(format!(\"let{} {}: {} = \\\\{\n+                let data = __tls_map.get_copy(&~\\\"{}\\\");\n                 let doc = ::extra::ebml::reader::Doc(data);\n                 let mut decoder = ::extra::ebml::reader::Decoder(doc);\n                 ::extra::serialize::Decodable::decode(&mut decoder)\n-            };\\n\", mt, *name, var.ty, *name));\n+            \\\\};\\n\", mt, *name, var.ty, *name));\n             var.alter(*name, &mut code);\n         }\n \n@@ -162,7 +162,7 @@ impl Program {\n         code.push_char('\\n');\n \n         match *to_print {\n-            Some(ref s) => { code.push_str(fmt!(\"pp({\\n%s\\n});\", *s)); }\n+            Some(ref s) => { code.push_str(format!(\"pp(\\\\{\\n{}\\n\\\\});\", *s)); }\n             None => {}\n         }\n \n@@ -174,14 +174,14 @@ impl Program {\n         // After the input code is run, we can re-serialize everything back out\n         // into tls map (to be read later on by this task)\n         for (name, var) in self.local_vars.iter() {\n-            code.push_str(fmt!(\"{\n-                let local: %s = %s;\n-                let bytes = do ::std::io::with_bytes_writer |io| {\n+            code.push_str(format!(\"\\\\{\n+                let local: {} = {};\n+                let bytes = do ::std::io::with_bytes_writer |io| \\\\{\n                     let mut enc = ::extra::ebml::writer::Encoder(io);\n                     local.encode(&mut enc);\n-                };\n-                __tls_map.insert(~\\\"%s\\\", @bytes);\n-            }\\n\", var.real_ty(), *name, *name));\n+                \\\\};\n+                __tls_map.insert(~\\\"{}\\\", @bytes);\n+            \\\\}\\n\", var.real_ty(), *name, *name));\n         }\n \n         // Close things up, and we're done.\n@@ -193,14 +193,14 @@ impl Program {\n     fn program_header(&self) -> ~str {\n         // up front, disable lots of annoying lints, then include all global\n         // state such as items, view items, and extern mods.\n-        let mut code = fmt!(\"\n-            #[allow(warnings)];\n+        let mut code = format!(\"\n+            \\\\#[allow(warnings)];\n \n             extern mod extra;\n-            %s // extern mods\n+            {} // extern mods\n \n             use extra::serialize::*;\n-            %s // view items\n+            {} // view items\n         \", self.externs, self.view_items);\n         for (_, s) in self.structs.iter() {\n             // The structs aren't really useful unless they're encodable\n@@ -236,7 +236,7 @@ impl Program {\n         for (name, value) in cons_map.move_iter() {\n             match self.local_vars.find_mut(&name) {\n                 Some(v) => { v.data = (*value).clone(); }\n-                None => { fail!(\"unknown variable %s\", name) }\n+                None => { fail2!(\"unknown variable {}\", name) }\n             }\n         }\n     }\n@@ -272,7 +272,7 @@ impl Program {\n     /// Once the types are known, they are inserted into the local_vars map in\n     /// this Program (to be deserialized later on\n     pub fn register_new_vars(&mut self, blk: &ast::Block, tcx: ty::ctxt) {\n-        debug!(\"looking for new variables\");\n+        debug2!(\"looking for new variables\");\n         let newvars = @mut HashMap::new();\n         do each_user_local(blk) |local| {\n             let mutable = local.is_mutbl;\n@@ -378,7 +378,7 @@ impl Program {\n                     _ => {}\n                 }\n             }\n-            fail!(\"couldn't find user block\");\n+            fail2!(\"couldn't find user block\");\n         }\n     }\n }\n@@ -389,9 +389,9 @@ impl LocalVariable {\n     fn alter(&self, name: &str, code: &mut ~str) {\n         match self.alterations {\n             Some((ref real_ty, ref prefix)) => {\n-                code.push_str(fmt!(\"let%s %s: %s = %s%s;\\n\",\n-                                   self.mt(), name,\n-                                   *real_ty, *prefix, name));\n+                code.push_str(format!(\"let{} {}: {} = {}{};\\n\",\n+                                      self.mt(), name,\n+                                      *real_ty, *prefix, name));\n             }\n             None => {}\n         }"}, {"sha": "a3185ee943872d48047b5a7b7d0eb27815a2653c", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -156,7 +156,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     //\n     // Stage 1: parse the input and filter it into the program (as necessary)\n     //\n-    debug!(\"parsing: %s\", input);\n+    debug2!(\"parsing: {}\", input);\n     let crate = parse_input(sess, input);\n     let mut to_run = ~[];       // statements to run (emitted back into code)\n     let new_locals = @mut ~[];  // new locals being defined\n@@ -231,11 +231,11 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     // Stage 2: run everything up to typeck to learn the types of the new\n     //          variables introduced into the program\n     //\n-    info!(\"Learning about the new types in the program\");\n+    info2!(\"Learning about the new types in the program\");\n     program.set_cache(); // before register_new_vars (which changes them)\n     let input = to_run.connect(\"\\n\");\n     let test = program.test_code(input, &result, *new_locals);\n-    debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n+    debug2!(\"testing with ^^^^^^ {:?}\", (||{ println(test) })());\n     let dinput = driver::str_input(test.to_managed());\n     let cfg = driver::build_configuration(sess);\n \n@@ -252,9 +252,9 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     //\n     // Stage 3: Actually run the code in the JIT\n     //\n-    info!(\"actually running code\");\n+    info2!(\"actually running code\");\n     let code = program.code(input, &result);\n-    debug!(\"actually running ^^^^^^ %?\", (||{ println(code) })());\n+    debug2!(\"actually running ^^^^^^ {:?}\", (||{ println(code) })());\n     let input = driver::str_input(code.to_managed());\n     let cfg = driver::build_configuration(sess);\n     let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n@@ -272,7 +272,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     // Stage 4: Inform the program that computation is done so it can update all\n     //          local variable bindings.\n     //\n-    info!(\"cleaning up after code\");\n+    info2!(\"cleaning up after code\");\n     program.consume_cache();\n \n     //\n@@ -284,7 +284,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     return (program, jit::consume_engine());\n \n     fn parse_input(sess: session::Session, input: &str) -> ast::Crate {\n-        let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n+        let code = format!(\"fn main() \\\\{\\n {} \\n\\\\}\", input);\n         let input = driver::str_input(code.to_managed());\n         let cfg = driver::build_configuration(sess);\n         driver::phase_1_parse_input(sess, cfg.clone(), &input)\n@@ -302,7 +302,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n                 _ => {}\n             }\n         }\n-        fail!(\"main function was expected somewhere...\");\n+        fail2!(\"main function was expected somewhere...\");\n     }\n }\n \n@@ -355,7 +355,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n             None => { },\n         }\n         if (should_compile) {\n-            println(fmt!(\"compiling %s...\", src_filename));\n+            println(format!(\"compiling {}...\", src_filename));\n             let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n             let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n             let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n@@ -429,7 +429,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for crate in loaded_crates.iter() {\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n-                repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n+                repl.program.record_extern(format!(\"extern mod {};\", *crate));\n                 if !repl.lib_search_paths.iter().any(|x| x == &crate_dir) {\n                     repl.lib_search_paths.push(crate_dir);\n                 }\n@@ -445,7 +445,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             let mut end_multiline = false;\n             while (!end_multiline) {\n                 match get_line(use_rl, \"rusti| \") {\n-                    None => fail!(\"unterminated multiline command :{ .. :}\"),\n+                    None => fail2!(\"unterminated multiline command :\\\\{ .. :\\\\}\"),\n                     Some(line) => {\n                         if line.trim() == \":}\" {\n                             end_multiline = true;"}, {"sha": "de673972932d3847dda29c4ff991384adb09bb26", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -52,7 +52,7 @@ fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n \n pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     let db_file = p.push(\"rustpkg_db.json\"); // ??? probably wrong\n-    debug!(\"Workcache database file: %s\", db_file.to_str());\n+    debug2!(\"Workcache database file: {}\", db_file.to_str());\n     let db = RWArc::new(Database::new(db_file));\n     let lg = RWArc::new(Logger::new());\n     let cfg = Arc::new(TreeMap::new());"}, {"sha": "b7a295f00707ae15075fa244439916c7af9d71a7", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -150,7 +150,7 @@ impl Context {\n /// rustpkg from a Rust target directory. This is part of a\n /// kludgy hack used to adjust the sysroot.\n pub fn in_target(sysroot: &Path) -> bool {\n-    debug!(\"Checking whether %s is in target\", sysroot.to_str());\n+    debug2!(\"Checking whether {} is in target\", sysroot.to_str());\n     os::path_is_dir(&sysroot.pop().pop().push(\"rustc\"))\n }\n \n@@ -214,8 +214,8 @@ pub fn flags_ok_for_cmd(flags: &RustcFlags,\n                         cfgs: &[~str],\n                         cmd: &str, user_supplied_opt_level: bool) -> bool {\n     let complain = |s| {\n-        io::println(fmt!(\"The %s option can only be used with the build command:\n-                         rustpkg [options..] build %s [package-ID]\", s, s));\n+        println!(\"The {} option can only be used with the build command:\n+                  rustpkg [options..] build {} [package-ID]\", s, s);\n     };\n \n     if flags.linker.is_some() && cmd != \"build\" && cmd != \"install\" {"}, {"sha": "a3b807d1fc5b3c6448f793fdd18b671840d39eac", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -28,15 +28,15 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n         for lib in libfiles.iter() {\n             let lib = Path(*lib);\n-            debug!(\"Full name: %s\", lib.to_str());\n+            debug2!(\"Full name: {}\", lib.to_str());\n             match has_library(&lib) {\n                 Some(basename) => {\n-                    debug!(\"parent = %s, child = %s\",\n-                           p.push(\"lib\").to_str(), lib.to_str());\n+                    debug2!(\"parent = {}, child = {}\",\n+                            p.push(\"lib\").to_str(), lib.to_str());\n                     let rel_p = p.push(\"lib/\").get_relative_to(&lib);\n-                    debug!(\"Rel: %s\", rel_p.to_str());\n+                    debug2!(\"Rel: {}\", rel_p.to_str());\n                     let rel_path = rel_p.push(basename).to_str();\n-                    debug!(\"Rel name: %s\", rel_path);\n+                    debug2!(\"Rel name: {}\", rel_path);\n                     f(&PkgId::new(rel_path));\n                 }\n                 None => ()"}, {"sha": "68cfa3220f228599c034b8764532c4e31b21245e", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -66,7 +66,7 @@ impl PkgId {\n         if path.components.len() < 1 {\n             return cond.raise((path, ~\"0-length pkgid\"));\n         }\n-        let short_name = path.filestem().expect(fmt!(\"Strange path! %s\", s));\n+        let short_name = path.filestem().expect(format!(\"Strange path! {}\", s));\n \n         let version = match given_version {\n             Some(v) => v,\n@@ -87,13 +87,13 @@ impl PkgId {\n     }\n \n     pub fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.path.to_str(),\n-             hash(self.path.to_str() + self.version.to_str()),\n-             self.version.to_str())\n+        format!(\"{}-{}-{}\", self.path.to_str(),\n+                hash(self.path.to_str() + self.version.to_str()),\n+                self.version.to_str())\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {\n-        fmt!(\"%s%s\", self.short_name, self.version.to_str())\n+        format!(\"{}{}\", self.short_name, self.version.to_str())\n     }\n \n     /// True if the ID has multiple components\n@@ -112,7 +112,7 @@ impl PkgId {\n     // binaries for this package (as opposed to the built ones,\n     // which are per-crate).\n     pub fn install_tag(&self) -> ~str {\n-        fmt!(\"install(%s)\", self.to_str())\n+        format!(\"install({})\", self.to_str())\n     }\n }\n \n@@ -139,7 +139,7 @@ impl Iterator<(Path, Path)> for Prefixes {\n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n+        format!(\"{}-{}\", self.path.to_str(), self.version.to_str())\n     }\n }\n "}, {"sha": "d7e755b89754fa9b4fb946890dd2c2164e930a4f", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -43,9 +43,9 @@ pub struct PkgSrc {\n \n impl ToStr for PkgSrc {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"Package ID %s in start dir %s [workspace = %s]\",\n-             self.id.to_str(),\n-             self.start_dir.to_str(), self.workspace.to_str())\n+        format!(\"Package ID {} in start dir {} [workspace = {}]\",\n+                self.id.to_str(),\n+                self.start_dir.to_str(), self.workspace.to_str())\n     }\n }\n condition! {\n@@ -58,21 +58,21 @@ impl PkgSrc {\n     pub fn new(workspace: Path, use_rust_path_hack: bool, id: PkgId) -> PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Checking package source for package ID %s, \\\n-               workspace = %s use_rust_path_hack = %?\",\n+        debug2!(\"Checking package source for package ID {}, \\\n+               workspace = {} use_rust_path_hack = {:?}\",\n                id.to_str(), workspace.to_str(), use_rust_path_hack);\n \n         let mut to_try = ~[];\n         if use_rust_path_hack {\n             to_try.push(workspace.clone());\n         } else {\n-            let result = workspace.push(\"src\").push_rel(&id.path.pop()).push(fmt!(\"%s-%s\",\n+            let result = workspace.push(\"src\").push_rel(&id.path.pop()).push(format!(\"{}-{}\",\n                                                          id.short_name, id.version.to_str()));\n             to_try.push(result);\n             to_try.push(workspace.push(\"src\").push_rel(&id.path));\n         }\n \n-        debug!(\"Checking dirs: %?\", to_try.map(|s| s.to_str()).connect(\":\"));\n+        debug2!(\"Checking dirs: {:?}\", to_try.map(|s| s.to_str()).connect(\":\"));\n \n         let path = to_try.iter().find(|&d| os::path_exists(d));\n \n@@ -84,13 +84,13 @@ impl PkgSrc {\n                 for (prefix, suffix) in id.prefixes_iter() {\n                     let package_id = PkgId::new(prefix.to_str());\n                     let path = workspace.push(\"src\").push_rel(&package_id.path);\n-                    debug!(\"in loop: checking if %s is a directory\", path.to_str());\n+                    debug2!(\"in loop: checking if {} is a directory\", path.to_str());\n                     if os::path_is_dir(&path) {\n                         let ps = PkgSrc::new(workspace.clone(),\n                                              use_rust_path_hack,\n                                              PkgId::new(prefix.to_str()));\n-                        debug!(\"pkgsrc: Returning [%s|%s|%s]\", workspace.to_str(),\n-                               ps.start_dir.push_rel(&suffix).to_str(), ps.id.to_str());\n+                        debug2!(\"pkgsrc: Returning [{}|{}|{}]\", workspace.to_str(),\n+                                ps.start_dir.push_rel(&suffix).to_str(), ps.id.to_str());\n \n                         return PkgSrc {\n                             workspace: workspace,\n@@ -108,7 +108,7 @@ impl PkgSrc {\n                 // Ok, no prefixes work, so try fetching from git\n                 let mut ok_d = None;\n                 for w in to_try.iter() {\n-                    debug!(\"Calling fetch_git on %s\", w.to_str());\n+                    debug2!(\"Calling fetch_git on {}\", w.to_str());\n                     let gf = PkgSrc::fetch_git(w, &id);\n                     for p in gf.iter() {\n                         ok_d = Some(p.clone());\n@@ -138,14 +138,14 @@ impl PkgSrc {\n                 }\n             }\n         };\n-        debug!(\"For package id %s, returning %s\", id.to_str(), dir.to_str());\n+        debug2!(\"For package id {}, returning {}\", id.to_str(), dir.to_str());\n \n         if !os::path_is_dir(&dir) {\n             cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n         }\n \n-        debug!(\"pkgsrc: Returning {%s|%s|%s}\", workspace.to_str(),\n+        debug2!(\"pkgsrc: Returning \\\\{{}|{}|{}\\\\}\", workspace.to_str(),\n                dir.to_str(), id.to_str());\n \n         PkgSrc {\n@@ -176,13 +176,13 @@ impl PkgSrc {\n             None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n         };\n \n-        debug!(\"Checking whether %s (path = %s) exists locally. Cwd = %s, does it? %?\",\n+        debug2!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n                pkgid.to_str(), pkgid.path.to_str(),\n                os::getcwd().to_str(),\n                os::path_exists(&pkgid.path));\n \n         if os::path_exists(&pkgid.path) {\n-            debug!(\"%s exists locally! Cloning it into %s\",\n+            debug2!(\"{} exists locally! Cloning it into {}\",\n                    pkgid.path.to_str(), local.to_str());\n             // Ok to use local here; we know it will succeed\n             git_clone(&pkgid.path, local, &pkgid.version);\n@@ -194,8 +194,8 @@ impl PkgSrc {\n             return None;\n         }\n \n-        let url = fmt!(\"https://%s\", pkgid.path.to_str());\n-        debug!(\"Fetching package: git clone %s %s [version=%s]\",\n+        let url = format!(\"https://{}\", pkgid.path.to_str());\n+        debug2!(\"Fetching package: git clone {} {} [version={}]\",\n                   url, clone_target.to_str(), pkgid.version.to_str());\n \n         if git_clone_general(url, &clone_target, &pkgid.version) {\n@@ -219,7 +219,7 @@ impl PkgSrc {\n     // return the path for it. Otherwise, None\n     pub fn package_script_option(&self) -> Option<Path> {\n         let maybe_path = self.start_dir.push(\"pkg.rs\");\n-        debug!(\"package_script_option: checking whether %s exists\", maybe_path.to_str());\n+        debug2!(\"package_script_option: checking whether {} exists\", maybe_path.to_str());\n         if os::path_exists(&maybe_path) {\n             Some(maybe_path)\n         }\n@@ -239,7 +239,7 @@ impl PkgSrc {\n         for c in p.components.slice(prefix, p.components.len()).iter() {\n             sub = sub.push(*c);\n         }\n-        debug!(\"Will compile crate %s\", sub.to_str());\n+        debug2!(\"Will compile crate {}\", sub.to_str());\n         cs.push(Crate::new(&sub));\n     }\n \n@@ -253,7 +253,7 @@ impl PkgSrc {\n         use conditions::missing_pkg_files::cond;\n \n         let prefix = self.start_dir.components.len();\n-        debug!(\"Matching against %s\", self.id.short_name);\n+        debug2!(\"Matching against {}\", self.id.short_name);\n         do os::walk_dir(&self.start_dir) |pth| {\n             let maybe_known_crate_set = match pth.filename() {\n                 Some(filename) if filter(filename) => match filename {\n@@ -282,7 +282,7 @@ impl PkgSrc {\n             cond.raise(self.id.clone());\n         }\n \n-        debug!(\"In %s, found %u libs, %u mains, %u tests, %u benchs\",\n+        debug2!(\"In {}, found {} libs, {} mains, {} tests, {} benchs\",\n                self.start_dir.to_str(),\n                self.libs.len(),\n                self.mains.len(),\n@@ -298,12 +298,12 @@ impl PkgSrc {\n                     what: OutputType) {\n         for crate in crates.iter() {\n             let path = self.start_dir.push_rel(&crate.file).normalize();\n-            debug!(\"build_crates: compiling %s\", path.to_str());\n+            debug2!(\"build_crates: compiling {}\", path.to_str());\n             let path_str = path.to_str();\n             let cfgs = crate.cfgs + cfgs;\n \n             do ctx.workcache_context.with_prep(crate_tag(&path)) |prep| {\n-                debug!(\"Building crate %s, declaring it as an input\", path.to_str());\n+                debug2!(\"Building crate {}, declaring it as an input\", path.to_str());\n                 prep.declare_input(\"file\", path.to_str(),\n                                    workcache_support::digest_file_with_date(&path));\n                 let subpath = path.clone();\n@@ -323,7 +323,7 @@ impl PkgSrc {\n                                                subcfgs,\n                                                false,\n                                                what).to_str();\n-                    debug!(\"Result of compiling %s was %s\", subpath_str, result);\n+                    debug2!(\"Result of compiling {} was {}\", subpath_str, result);\n                     result\n                 }\n             };\n@@ -335,11 +335,11 @@ impl PkgSrc {\n     pub fn declare_inputs(&self, prep: &mut workcache::Prep) {\n         let to_do = ~[self.libs.clone(), self.mains.clone(),\n                       self.tests.clone(), self.benchs.clone()];\n-        debug!(\"In declare inputs, self = %s\", self.to_str());\n+        debug2!(\"In declare inputs, self = {}\", self.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n                 let path = self.start_dir.push_rel(&c.file).normalize();\n-                debug!(\"Declaring input: %s\", path.to_str());\n+                debug2!(\"Declaring input: {}\", path.to_str());\n                 prep.declare_input(\"file\",\n                                    path.to_str(),\n                                    workcache_support::digest_file_with_date(&path.clone()));\n@@ -357,17 +357,17 @@ impl PkgSrc {\n         // Determine the destination workspace (which depends on whether\n         // we're using the rust_path_hack)\n         let destination_workspace = if is_workspace(&self.workspace) {\n-            debug!(\"%s is indeed a workspace\", self.workspace.to_str());\n+            debug2!(\"{} is indeed a workspace\", self.workspace.to_str());\n             self.workspace.clone()\n         } else {\n             // It would be nice to have only one place in the code that checks\n             // for the use_rust_path_hack flag...\n             if build_context.context.use_rust_path_hack {\n                 let rs = default_workspace();\n-                debug!(\"Using hack: %s\", rs.to_str());\n+                debug2!(\"Using hack: {}\", rs.to_str());\n                 rs\n             } else {\n-                cond.raise(fmt!(\"Package root %s is not a workspace; pass in --rust_path_hack \\\n+                cond.raise(format!(\"Package root {} is not a workspace; pass in --rust_path_hack \\\n                                         if you want to treat it as a package source\",\n                                 self.workspace.to_str()))\n             }\n@@ -377,14 +377,14 @@ impl PkgSrc {\n         let mains = self.mains.clone();\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n-        debug!(\"Building libs in %s, destination = %s\",\n+        debug2!(\"Building libs in {}, destination = {}\",\n                destination_workspace.to_str(), destination_workspace.to_str());\n         self.build_crates(build_context, &destination_workspace, libs, cfgs, Lib);\n-        debug!(\"Building mains\");\n+        debug2!(\"Building mains\");\n         self.build_crates(build_context, &destination_workspace, mains, cfgs, Main);\n-        debug!(\"Building tests\");\n+        debug2!(\"Building tests\");\n         self.build_crates(build_context, &destination_workspace, tests, cfgs, Test);\n-        debug!(\"Building benches\");\n+        debug2!(\"Building benches\");\n         self.build_crates(build_context, &destination_workspace, benchs, cfgs, Bench);\n         destination_workspace.to_str()\n     }\n@@ -394,7 +394,7 @@ impl PkgSrc {\n         let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n         for crate_set in crate_sets.iter() {\n             for c in crate_set.iter() {\n-                debug!(\"Built crate: %s\", c.file.to_str())\n+                debug2!(\"Built crate: {}\", c.file.to_str())\n             }\n         }\n     }"}, {"sha": "9a440cb5f8ff097627f21499f477c5397ad6fa75", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -24,7 +24,7 @@ use messages::*;\n pub fn default_workspace() -> Path {\n     let p = rust_path();\n     if p.is_empty() {\n-        fail!(\"Empty RUST_PATH\");\n+        fail2!(\"Empty RUST_PATH\");\n     }\n     let result = p[0];\n     if !os::path_is_dir(&result) {\n@@ -88,9 +88,9 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     };\n \n     if found.is_some() {\n-        debug!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str());\n+        debug2!(\"Found {} in {}\", pkgid.to_str(), workspace.to_str());\n     } else {\n-        debug!(\"Didn't find %s in %s\", pkgid.to_str(), workspace.to_str());\n+        debug2!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.to_str());\n     }\n     found\n }\n@@ -119,13 +119,13 @@ fn target_bin_dir(workspace: &Path) -> Path {\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = target_build_dir(workspace);\n     result = mk_output_path(Main, Build, pkgid, result);\n-    debug!(\"built_executable_in_workspace: checking whether %s exists\",\n+    debug2!(\"built_executable_in_workspace: checking whether {} exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        debug!(\"built_executable_in_workspace: %s does not exist\", result.to_str());\n+        debug2!(\"built_executable_in_workspace: {} does not exist\", result.to_str());\n         None\n     }\n }\n@@ -146,13 +146,13 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     let mut result = target_build_dir(workspace);\n     // should use a target-specific subdirectory\n     result = mk_output_path(what, Build, pkgid, result);\n-    debug!(\"output_in_workspace: checking whether %s exists\",\n+    debug2!(\"output_in_workspace: checking whether {} exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        error!(fmt!(\"output_in_workspace: %s does not exist\", result.to_str()));\n+        error2!(\"output_in_workspace: {} does not exist\", result.to_str());\n         None\n     }\n }\n@@ -181,14 +181,14 @@ pub fn installed_library_in_workspace(pkg_path: &Path, workspace: &Path) -> Opti\n /// `short_name` is taken as the link name of the library.\n pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n                         workspace: &Path, prefix: &str, version: &Version) -> Option<Path> {\n-    debug!(\"library_in_workspace: checking whether a library named %s exists\",\n+    debug2!(\"library_in_workspace: checking whether a library named {} exists\",\n            short_name);\n \n     // We don't know what the hash is, so we have to search through the directory\n     // contents\n \n-    debug!(\"short_name = %s where = %? workspace = %s \\\n-            prefix = %s\", short_name, where, workspace.to_str(), prefix);\n+    debug2!(\"short_name = {} where = {:?} workspace = {} \\\n+            prefix = {}\", short_name, where, workspace.to_str(), prefix);\n \n     let dir_to_search = match where {\n         Build => target_build_dir(workspace).push_rel(path),\n@@ -204,14 +204,14 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n }\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n-    debug!(\"Listing directory %s\", dir_to_search.to_str());\n+    debug2!(\"Listing directory {}\", dir_to_search.to_str());\n     let dir_contents = os::list_dir(dir_to_search);\n-    debug!(\"dir has %? entries\", dir_contents.len());\n+    debug2!(\"dir has {:?} entries\", dir_contents.len());\n \n-    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, short_name);\n+    let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n     let lib_filetype = os::consts::DLL_SUFFIX;\n \n-    debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n+    debug2!(\"lib_prefix = {} and lib_filetype = {}\", lib_prefix, lib_filetype);\n \n     // Find a filename that matches the pattern:\n     // (lib_prefix)-hash-(version)(lib_suffix)\n@@ -221,7 +221,7 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n \n     let mut libraries = do paths.filter |p| {\n         let extension = p.filetype();\n-        debug!(\"p = %s, p's extension is %?\", p.to_str(), extension);\n+        debug2!(\"p = {}, p's extension is {:?}\", p.to_str(), extension);\n         match extension {\n             None => false,\n             Some(ref s) => lib_filetype == *s\n@@ -242,12 +242,12 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n             if f_name.is_empty() { break; }\n             match f_name.rfind('-') {\n                 Some(i) => {\n-                    debug!(\"Maybe %s is a version\", f_name.slice(i + 1, f_name.len()));\n+                    debug2!(\"Maybe {} is a version\", f_name.slice(i + 1, f_name.len()));\n                     match try_parsing_version(f_name.slice(i + 1, f_name.len())) {\n                        Some(ref found_vers) if version == found_vers => {\n                            match f_name.slice(0, i).rfind('-') {\n                                Some(j) => {\n-                                   debug!(\"Maybe %s equals %s\", f_name.slice(0, j), lib_prefix);\n+                                   debug2!(\"Maybe {} equals {}\", f_name.slice(0, j), lib_prefix);\n                                    if f_name.slice(0, j) == lib_prefix {\n                                        result_filename = Some(p_path.clone());\n                                    }\n@@ -265,15 +265,15 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     } // for\n \n     if result_filename.is_none() {\n-        debug!(\"warning: library_in_workspace didn't find a library in %s for %s\",\n+        debug2!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n                   dir_to_search.to_str(), short_name);\n     }\n \n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n     let abs_path = do result_filename.map |result_filename| {\n         let absolute_path = dir_to_search.push_rel(result_filename);\n-        debug!(\"result_filename = %s\", absolute_path.to_str());\n+        debug2!(\"result_filename = {}\", absolute_path.to_str());\n         absolute_path\n     };\n \n@@ -295,8 +295,8 @@ pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n     if !os::path_is_dir(workspace) {\n         cond.raise(((*workspace).clone(),\n-                    fmt!(\"Workspace supplied to target_library_in_workspace \\\n-                          is not a directory! %s\", workspace.to_str())));\n+                    format!(\"Workspace supplied to target_library_in_workspace \\\n+                             is not a directory! {}\", workspace.to_str())));\n     }\n     target_file_in_workspace(pkgid, workspace, Lib, Install)\n }\n@@ -333,8 +333,8 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n-        cond.raise((result.clone(), fmt!(\"target_file_in_workspace couldn't \\\n-            create the %s dir (pkgid=%s, workspace=%s, what=%?, where=%?\",\n+        cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n+            create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n             subdir, pkgid.to_str(), workspace.to_str(), what, where)));\n     }\n     mk_output_path(what, where, pkgid, result)\n@@ -347,22 +347,22 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n     let mut result = target_build_dir(workspace);\n     result = result.push_rel(&pkgid.path);\n-    debug!(\"Creating build dir %s for package id %s\", result.to_str(),\n+    debug2!(\"Creating build dir {} for package id {}\", result.to_str(),\n            pkgid.to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n     }\n     else {\n-        cond.raise((result, fmt!(\"Could not create directory for package %s\", pkgid.to_str())))\n+        cond.raise((result, format!(\"Could not create directory for package {}\", pkgid.to_str())))\n     }\n }\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n                       pkg_id: &PkgId, workspace: Path) -> Path {\n-    let short_name_with_version = fmt!(\"%s-%s\", pkg_id.short_name,\n-                                       pkg_id.version.to_str());\n+    let short_name_with_version = format!(\"{}-{}\", pkg_id.short_name,\n+                                          pkg_id.version.to_str());\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n@@ -371,14 +371,14 @@ pub fn mk_output_path(what: OutputType, where: Target,\n         // and if we're just building, it goes in a package-specific subdir\n         Build => workspace.push_rel(&pkg_id.path)\n     };\n-    debug!(\"[%?:%?] mk_output_path: short_name = %s, path = %s\", what, where,\n+    debug2!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n            if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n            dir.to_str());\n     let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n         Lib => dir.push(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n-        _ => dir.push(fmt!(\"%s%s%s\", pkg_id.short_name,\n+        _ => dir.push(format!(\"{}{}{}\", pkg_id.short_name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\",\n@@ -389,7 +389,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n     if !output_path.is_absolute() {\n         output_path = os::getcwd().push_rel(&output_path).normalize();\n     }\n-    debug!(\"mk_output_path: returning %s\", output_path.to_str());\n+    debug2!(\"mk_output_path: returning {}\", output_path.to_str());\n     output_path\n }\n \n@@ -407,7 +407,7 @@ pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n         did_something = true;\n     }\n     if !did_something {\n-        warn(fmt!(\"Warning: there don't seem to be any files for %s installed in %s\",\n+        warn(format!(\"Warning: there don't seem to be any files for {} installed in {}\",\n              pkgid.to_str(), workspace.to_str()));\n     }\n \n@@ -425,14 +425,14 @@ pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n         // Note that this only matches if the package ID being searched for\n         // has a name that's a single component\n         if dir.is_parent_of(&p.path) || dir.is_parent_of(&versionize(&p.path, &p.version)) {\n-            debug!(\"In find_dir_using_rust_path_hack: checking dir %s\", dir.to_str());\n+            debug2!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.to_str());\n             if dir_has_file(dir, \"lib.rs\") || dir_has_file(dir, \"main.rs\")\n                 || dir_has_file(dir, \"test.rs\") || dir_has_file(dir, \"bench.rs\") {\n-                debug!(\"Did find id %s in dir %s\", p.to_str(), dir.to_str());\n+                debug2!(\"Did find id {} in dir {}\", p.to_str(), dir.to_str());\n                 return Some(dir.clone());\n             }\n         }\n-        debug!(\"Didn't find id %s in dir %s\", p.to_str(), dir.to_str())\n+        debug2!(\"Didn't find id {} in dir {}\", p.to_str(), dir.to_str())\n     }\n     None\n }\n@@ -449,7 +449,7 @@ pub fn user_set_rust_path() -> bool {\n /// Append the version string onto the end of the path's filename\n fn versionize(p: &Path, v: &Version) -> Path {\n     let q = p.file_path().to_str();\n-    p.with_filename(fmt!(\"%s-%s\", q, v.to_str()))\n+    p.with_filename(format!(\"{}-{}\", q, v.to_str()))\n }\n \n "}, {"sha": "1ece56df60a3e5a04f5e1fa7ceb03bc91eb08054", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -102,7 +102,7 @@ impl<'self> PkgScript<'self> {\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n         // to the compiler\n-        debug!(\"pkgscript parse: %s\", sysroot.to_str());\n+        debug2!(\"pkgscript parse: {}\", sysroot.to_str());\n         let options = @session::options {\n             binary: binary,\n             maybe_sysroot: Some(sysroot),\n@@ -118,7 +118,7 @@ impl<'self> PkgScript<'self> {\n         let crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n-        debug!(\"Returning package script with id %s\", id.to_str());\n+        debug2!(\"Returning package script with id {}\", id.to_str());\n \n         PkgScript {\n             id: id,\n@@ -138,10 +138,10 @@ impl<'self> PkgScript<'self> {\n                   sysroot: &Path) -> (~[~str], ExitCode) {\n         let sess = self.sess;\n \n-        debug!(\"Working directory = %s\", self.build_dir.to_str());\n+        debug2!(\"Working directory = {}\", self.build_dir.to_str());\n         // Collect together any user-defined commands in the package script\n         let crate = util::ready_crate(sess, self.crate.take_unwrap());\n-        debug!(\"Building output filenames with script name %s\",\n+        debug2!(\"Building output filenames with script name {}\",\n                driver::source_name(&driver::file_input(self.input.clone())));\n         let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n@@ -150,7 +150,7 @@ impl<'self> PkgScript<'self> {\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n-        debug!(\"Running program: %s %s %s\", exe.to_str(),\n+        debug2!(\"Running program: {} {} {}\", exe.to_str(),\n                sysroot.to_str(), \"install\");\n         // Discover the output\n         exec.discover_output(\"binary\", exe.to_str(), digest_only_date(&exe));\n@@ -160,7 +160,7 @@ impl<'self> PkgScript<'self> {\n             return (~[], status);\n         }\n         else {\n-            debug!(\"Running program (configs): %s %s %s\",\n+            debug2!(\"Running program (configs): {} {} {}\",\n                    exe.to_str(), sysroot.to_str(), \"configs\");\n             let output = run::process_output(exe.to_str(), [sysroot.to_str(), ~\"configs\"]);\n             // Run the configs() function to get the configs\n@@ -223,7 +223,7 @@ impl CtxMethods for BuildContext {\n             let pkgid = PkgId::new(args[0].clone());\n             let mut dest_ws = None;\n             do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n-                debug!(\"found pkg %s in workspace %s, trying to build\",\n+                debug2!(\"found pkg {} in workspace {}, trying to build\",\n                        pkgid.to_str(), workspace.to_str());\n                 let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n                 dest_ws = Some(self.build(&mut pkg_src, what));\n@@ -290,7 +290,7 @@ impl CtxMethods for BuildContext {\n                     // argument\n                     let pkgid = PkgId::new(args[0]);\n                     let workspaces = pkg_parent_workspaces(&self.context, &pkgid);\n-                    debug!(\"package ID = %s, found it in %? workspaces\",\n+                    debug2!(\"package ID = {}, found it in {:?} workspaces\",\n                            pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n                         let rp = rust_path();\n@@ -349,15 +349,16 @@ impl CtxMethods for BuildContext {\n \n                 let pkgid = PkgId::new(args[0]);\n                 if !installed_packages::package_is_installed(&pkgid) {\n-                    warn(fmt!(\"Package %s doesn't seem to be installed! Doing nothing.\", args[0]));\n+                    warn(format!(\"Package {} doesn't seem to be installed! \\\n+                                  Doing nothing.\", args[0]));\n                     return;\n                 }\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n                     do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n-                        note(fmt!(\"Uninstalled package %s (was installed in %s)\",\n+                        note(format!(\"Uninstalled package {} (was installed in {})\",\n                                   pkgid.to_str(), workspace.to_str()));\n                         true\n                     };\n@@ -370,13 +371,13 @@ impl CtxMethods for BuildContext {\n \n                 self.unprefer(args[0], None);\n             }\n-            _ => fail!(fmt!(\"I don't know the command `%s`\", cmd))\n+            _ => fail2!(\"I don't know the command `{}`\", cmd)\n         }\n     }\n \n     fn do_cmd(&self, _cmd: &str, _pkgname: &str)  {\n         // stub\n-        fail!(\"`do` not yet implemented\");\n+        fail2!(\"`do` not yet implemented\");\n     }\n \n     /// Returns the destination workspace\n@@ -387,8 +388,8 @@ impl CtxMethods for BuildContext {\n         let workspace = pkg_src.workspace.clone();\n         let pkgid = pkg_src.id.clone();\n \n-        debug!(\"build: workspace = %s (in Rust path? %? is git dir? %? \\\n-                pkgid = %s pkgsrc start_dir = %s\", workspace.to_str(),\n+        debug2!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n+                pkgid = {} pkgsrc start_dir = {}\", workspace.to_str(),\n                in_rust_path(&workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n                pkgid.to_str(), pkg_src.start_dir.to_str());\n \n@@ -399,16 +400,16 @@ impl CtxMethods for BuildContext {\n             source_control::git_clone(&workspace.push_rel(&pkgid.path),\n                                       &out_dir, &pkgid.version);\n             let default_ws = default_workspace();\n-            debug!(\"Calling build recursively with %? and %?\", default_ws.to_str(),\n+            debug2!(\"Calling build recursively with {:?} and {:?}\", default_ws.to_str(),\n                    pkgid.to_str());\n             return self.build(&mut PkgSrc::new(default_ws, false, pkgid.clone()), what_to_build);\n         }\n \n         // Is there custom build logic? If so, use it\n         let mut custom = false;\n-        debug!(\"Package source directory = %s\", pkg_src.to_str());\n+        debug2!(\"Package source directory = {}\", pkg_src.to_str());\n         let opt = pkg_src.package_script_option();\n-        debug!(\"Calling pkg_script_option on %?\", opt);\n+        debug2!(\"Calling pkg_script_option on {:?}\", opt);\n         let cfgs = match pkg_src.package_script_option() {\n             Some(package_script_path) => {\n                 let sysroot = self.sysroot_to_use();\n@@ -428,16 +429,16 @@ impl CtxMethods for BuildContext {\n                         pscript.run_custom(exec, &sub_sysroot)\n                     }\n                 };\n-                debug!(\"Command return code = %?\", hook_result);\n+                debug2!(\"Command return code = {:?}\", hook_result);\n                 if hook_result != 0 {\n-                    fail!(\"Error running custom build command\")\n+                    fail2!(\"Error running custom build command\")\n                 }\n                 custom = true;\n                 // otherwise, the package script succeeded\n                 cfgs\n             }\n             None => {\n-                debug!(\"No package script, continuing\");\n+                debug2!(\"No package script, continuing\");\n                 ~[]\n             }\n         } + self.context.cfgs;\n@@ -454,7 +455,7 @@ impl CtxMethods for BuildContext {\n                 &JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n-                    debug!(\"JustOne: p = %s\", p.to_str());\n+                    debug2!(\"JustOne: p = {}\", p.to_str());\n                     assert!(os::path_exists(&pkg_src.start_dir.push_rel(p)));\n                     if is_lib(p) {\n                         PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n@@ -465,7 +466,7 @@ impl CtxMethods for BuildContext {\n                     } else if is_bench(p) {\n                         PkgSrc::push_crate(&mut pkg_src.benchs, 0, p);\n                     } else {\n-                        warn(fmt!(\"Not building any crates for dependency %s\", p.to_str()));\n+                        warn(format!(\"Not building any crates for dependency {}\", p.to_str()));\n                         return workspace.clone();\n                     }\n                 }\n@@ -486,19 +487,19 @@ impl CtxMethods for BuildContext {\n         // Do something reasonable for now\n \n         let dir = build_pkg_id_in_workspace(id, workspace);\n-        note(fmt!(\"Cleaning package %s (removing directory %s)\",\n+        note(format!(\"Cleaning package {} (removing directory {})\",\n                         id.to_str(), dir.to_str()));\n         if os::path_exists(&dir) {\n             os::remove_dir_recursive(&dir);\n-            note(fmt!(\"Removed directory %s\", dir.to_str()));\n+            note(format!(\"Removed directory {}\", dir.to_str()));\n         }\n \n-        note(fmt!(\"Cleaned package %s\", id.to_str()));\n+        note(format!(\"Cleaned package {}\", id.to_str()));\n     }\n \n     fn info(&self) {\n         // stub\n-        fail!(\"info not yet implemented\");\n+        fail2!(\"info not yet implemented\");\n     }\n \n     fn install(&self, mut pkg_src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]) {\n@@ -514,11 +515,11 @@ impl CtxMethods for BuildContext {\n \n         let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n                       pkg_src.tests.clone(), pkg_src.benchs.clone()];\n-        debug!(\"In declare inputs for %s\", id.to_str());\n+        debug2!(\"In declare inputs for {}\", id.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n                 let path = pkg_src.start_dir.push_rel(&c.file).normalize();\n-                debug!(\"Recording input: %s\", path.to_str());\n+                debug2!(\"Recording input: {}\", path.to_str());\n                 installed_files.push(path);\n             }\n         }\n@@ -532,15 +533,15 @@ impl CtxMethods for BuildContext {\n             else {\n             Path(destination_workspace)\n         };\n-        debug!(\"install: destination workspace = %s, id = %s, installing to %s\",\n+        debug2!(\"install: destination workspace = {}, id = {}, installing to {}\",\n                destination_workspace, id.to_str(), actual_workspace.to_str());\n         let result = self.install_no_build(&Path(destination_workspace),\n                                            &actual_workspace,\n                                            &id).map(|s| Path(*s));\n-        debug!(\"install: id = %s, about to call discover_outputs, %?\",\n+        debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n                id.to_str(), result.to_str());\n         installed_files = installed_files + result;\n-        note(fmt!(\"Installed package %s to %s\", id.to_str(), actual_workspace.to_str()));\n+        note(format!(\"Installed package {} to {}\", id.to_str(), actual_workspace.to_str()));\n         (installed_files, inputs)\n     }\n \n@@ -557,8 +558,8 @@ impl CtxMethods for BuildContext {\n         let target_exec = target_executable_in_workspace(id, target_workspace);\n         let target_lib = maybe_library.map(|_p| target_library_in_workspace(id, target_workspace));\n \n-        debug!(\"target_exec = %s target_lib = %? \\\n-               maybe_executable = %? maybe_library = %?\",\n+        debug2!(\"target_exec = {} target_lib = {:?} \\\n+               maybe_executable = {:?} maybe_library = {:?}\",\n                target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n@@ -582,7 +583,7 @@ impl CtxMethods for BuildContext {\n                 let mut outputs = ~[];\n \n                 for exec in subex.iter() {\n-                    debug!(\"Copying: %s -> %s\", exec.to_str(), sub_target_ex.to_str());\n+                    debug2!(\"Copying: {} -> {}\", exec.to_str(), sub_target_ex.to_str());\n                     if !(os::mkdir_recursive(&sub_target_ex.dir_path(), U_RWX) &&\n                          os::copy_file(exec, &sub_target_ex)) {\n                         cond.raise(((*exec).clone(), sub_target_ex.clone()));\n@@ -594,11 +595,11 @@ impl CtxMethods for BuildContext {\n                 }\n                 for lib in sublib.iter() {\n                     let target_lib = sub_target_lib\n-                        .clone().expect(fmt!(\"I built %s but apparently \\\n+                        .clone().expect(format!(\"I built {} but apparently \\\n                                              didn't install it!\", lib.to_str()));\n                     let target_lib = target_lib\n                         .pop().push(lib.filename().expect(\"weird target lib\"));\n-                    debug!(\"Copying: %s -> %s\", lib.to_str(), sub_target_lib.to_str());\n+                    debug2!(\"Copying: {} -> {}\", lib.to_str(), sub_target_lib.to_str());\n                     if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                          os::copy_file(lib, &target_lib)) {\n                         cond.raise(((*lib).clone(), target_lib.clone()));\n@@ -614,18 +615,18 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"prefer not yet implemented\");\n+        fail2!(\"prefer not yet implemented\");\n     }\n \n     fn test(&self, pkgid: &PkgId, workspace: &Path)  {\n         match built_test_in_workspace(pkgid, workspace) {\n             Some(test_exec) => {\n-                debug!(\"test: test_exec = %s\", test_exec.to_str());\n+                debug2!(\"test: test_exec = {}\", test_exec.to_str());\n                 let status = run::process_status(test_exec.to_str(), [~\"--test\"]);\n                 os::set_exit_status(status);\n             }\n             None => {\n-                error(fmt!(\"Internal error: test executable for package ID %s in workspace %s \\\n+                error(format!(\"Internal error: test executable for package ID {} in workspace {} \\\n                            wasn't built! Please report this as a bug.\",\n                            pkgid.to_str(), workspace.to_str()));\n             }\n@@ -640,11 +641,11 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"uninstall not yet implemented\");\n+        fail2!(\"uninstall not yet implemented\");\n     }\n \n     fn unprefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"unprefer not yet implemented\");\n+        fail2!(\"unprefer not yet implemented\");\n     }\n }\n \n@@ -677,7 +678,7 @@ pub fn main_args(args: &[~str]) -> int {\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n-            error(fmt!(\"%s\", f.to_err_msg()));\n+            error(format!(\"{}\", f.to_err_msg()));\n \n             return 1;\n         }\n@@ -812,8 +813,8 @@ pub fn main_args(args: &[~str]) -> int {\n         _ => filesearch::get_or_default_sysroot()\n     };\n \n-    debug!(\"Using sysroot: %s\", sroot.to_str());\n-    debug!(\"Will store workcache in %s\", default_workspace().to_str());\n+    debug2!(\"Using sysroot: {}\", sroot.to_str());\n+    debug2!(\"Will store workcache in {}\", default_workspace().to_str());\n \n     let rm_args = remaining_args.clone();\n     let sub_cmd = cmd.clone();"}, {"sha": "f0042e1f8e2d71991086b0aeddc1c36ec7b48688", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -17,7 +17,8 @@ use version::Version;\n /// FIXME #8711: This ignores the desired version.\n pub fn find_installed_library_in_rust_path(pkg_path: &Path, _version: &Version) -> Option<Path> {\n     let rp = rust_path();\n-    debug!(\"find_installed_library_in_rust_path: looking for path %s\", pkg_path.to_str());\n+    debug2!(\"find_installed_library_in_rust_path: looking for path {}\",\n+            pkg_path.to_str());\n     for p in rp.iter() {\n         match installed_library_in_workspace(pkg_path, p) {\n             Some(path) => return Some(path),"}, {"sha": "3d03d89bc20ab10845bcb30dcdaaec3dd725b1a8", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -19,26 +19,26 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n     assert!(os::path_is_dir(source));\n     assert!(is_git_dir(source));\n     if !os::path_exists(target) {\n-        debug!(\"Running: git clone %s %s\", source.to_str(), target.to_str());\n+        debug2!(\"Running: git clone {} {}\", source.to_str(), target.to_str());\n         let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n         if outp.status != 0 {\n             io::println(str::from_utf8_owned(outp.output.clone()));\n             io::println(str::from_utf8_owned(outp.error));\n-            fail!(\"Couldn't `git clone` %s\", source.to_str());\n+            fail2!(\"Couldn't `git clone` {}\", source.to_str());\n         }\n         else {\n             match v {\n                 &ExactRevision(ref s) => {\n-                    debug!(\"`Running: git --work-tree=%s --git-dir=%s checkout %s\",\n+                    debug2!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n                            *s, target.to_str(), target.push(\".git\").to_str());\n                     let outp = run::process_output(\"git\",\n-                                   [fmt!(\"--work-tree=%s\", target.to_str()),\n-                                    fmt!(\"--git-dir=%s\", target.push(\".git\").to_str()),\n-                                    ~\"checkout\", fmt!(\"%s\", *s)]);\n+                                   [format!(\"--work-tree={}\", target.to_str()),\n+                                    format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n+                                    ~\"checkout\", format!(\"{}\", *s)]);\n                     if outp.status != 0 {\n                         io::println(str::from_utf8_owned(outp.output.clone()));\n                         io::println(str::from_utf8_owned(outp.error));\n-                        fail!(\"Couldn't `git checkout %s` in %s\",\n+                        fail2!(\"Couldn't `git checkout {}` in {}\",\n                               *s, target.to_str());\n                     }\n                 }\n@@ -50,11 +50,12 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n         // Check that no version was specified. There's no reason to not handle the\n         // case where a version was requested, but I haven't implemented it.\n         assert!(*v == NoVersion);\n-        debug!(\"Running: git --work-tree=%s --git-dir=%s pull --no-edit %s\",\n+        debug2!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n                target.to_str(), target.push(\".git\").to_str(), source.to_str());\n-        let outp = run::process_output(\"git\", [fmt!(\"--work-tree=%s\", target.to_str()),\n-                                               fmt!(\"--git-dir=%s\", target.push(\".git\").to_str()),\n-                                               ~\"pull\", ~\"--no-edit\", source.to_str()]);\n+        let args = [format!(\"--work-tree={}\", target.to_str()),\n+                    format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n+                    ~\"pull\", ~\"--no-edit\", source.to_str()];\n+        let outp = run::process_output(\"git\", args);\n         assert!(outp.status == 0);\n     }\n }\n@@ -64,18 +65,18 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n pub fn git_clone_general(source: &str, target: &Path, v: &Version) -> bool {\n     let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n     if outp.status != 0 {\n-         debug!(str::from_utf8_owned(outp.output.clone()));\n-         debug!(str::from_utf8_owned(outp.error));\n+         debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n+         debug2!(\"{}\", str::from_utf8_owned(outp.error));\n          false\n     }\n     else {\n         match v {\n             &ExactRevision(ref s) | &Tagged(ref s) => {\n-                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", fmt!(\"%s\", *s)],\n+                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", format!(\"{}\", *s)],\n                                                          target);\n                     if outp.status != 0 {\n-                        debug!(str::from_utf8_owned(outp.output.clone()));\n-                        debug!(str::from_utf8_owned(outp.error));\n+                        debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n+                        debug2!(\"{}\", str::from_utf8_owned(outp.error));\n                         false\n                     }\n                     else {"}, {"sha": "5b56c312226c051b25f6916a2d7a2a1f1b9b2854", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 104, "deletions": 101, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -91,24 +91,24 @@ fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> Path {\n \n fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n     // include version number in directory name\n-    let package_dir = workspace.push_many([~\"src\", fmt!(\"%s-%s\",\n-                                                      short_name.to_str(), version.to_str())]);\n+    let package_dir = workspace.push_many([~\"src\", format!(\"{}-{}\",\n+                                                short_name.to_str(), version.to_str())]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     package_dir\n }\n \n fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n     let package_dir = mk_empty_workspace(short_name,\n-                          version, \"temp_workspace\").push_many([~\"src\", fmt!(\"%s-%s\",\n+                          version, \"temp_workspace\").push_many([~\"src\", format!(\"{}-{}\",\n                                                             short_name.to_str(),\n                                                             version.to_str())]);\n \n-    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n-    debug!(\"mk_workspace: creating %s\", package_dir.to_str());\n+    debug2!(\"mk_workspace: creating {}\", package_dir.to_str());\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n@@ -134,7 +134,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n     });\n     let rslt = prog.finish_with_output();\n     if rslt.status != 0 {\n-        fail!(\"%s [git returned %?, output = %s, error = %s]\", err_msg,\n+        fail2!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n            rslt.status, str::from_utf8(rslt.output), str::from_utf8(rslt.error));\n     }\n }\n@@ -147,13 +147,13 @@ fn init_git_repo(p: &Path) -> Path {\n     let work_dir = tmp.push_rel(p);\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n-    debug!(\"Running: git init in %s\", work_dir.to_str());\n+    debug2!(\"Running: git init in {}\", work_dir.to_str());\n     let ws = work_dir.to_str();\n     run_git([~\"init\"], None, &work_dir_for_opts,\n-        fmt!(\"Couldn't initialize git repository in %s\", ws));\n+        format!(\"Couldn't initialize git repository in {}\", ws));\n     // Add stuff to the dir so that git tag succeeds\n     writeFile(&work_dir.push(\"README\"), \"\");\n-    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, fmt!(\"Couldn't add in %s\", ws));\n+    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, format!(\"Couldn't add in {}\", ws));\n     git_commit(&work_dir_for_opts, ~\"whatever\");\n     tmp\n }\n@@ -165,19 +165,19 @@ fn add_all_and_commit(repo: &Path) {\n \n fn git_commit(repo: &Path, msg: ~str) {\n     run_git([~\"commit\", ~\"--author=tester <test@mozilla.com>\", ~\"-m\", msg],\n-            None, repo, fmt!(\"Couldn't commit in %s\", repo.to_str()));\n+            None, repo, format!(\"Couldn't commit in {}\", repo.to_str()));\n }\n \n fn git_add_all(repo: &Path) {\n-    run_git([~\"add\", ~\"-A\"], None, repo, fmt!(\"Couldn't add all files in %s\", repo.to_str()));\n+    run_git([~\"add\", ~\"-A\"], None, repo, format!(\"Couldn't add all files in {}\", repo.to_str()));\n }\n \n fn add_git_tag(repo: &Path, tag: ~str) {\n     assert!(repo.is_absolute());\n     git_add_all(repo);\n     git_commit(repo, ~\"whatever\");\n     run_git([~\"tag\", tag.clone()], None, repo,\n-            fmt!(\"Couldn't add git tag %s in %s\", tag, repo.to_str()));\n+            format!(\"Couldn't add git tag {} in {}\", tag, repo.to_str()));\n }\n \n fn is_rwx(p: &Path) -> bool {\n@@ -214,15 +214,15 @@ fn rustpkg_exec() -> Path {\n             second_try\n         }\n         else {\n-            fail!(\"in rustpkg test, can't find an installed rustpkg\");\n+            fail2!(\"in rustpkg test, can't find an installed rustpkg\");\n         }\n     }\n }\n \n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n     match command_line_test_with_env(args, cwd, None) {\n         Success(r) => r,\n-        _ => fail!(\"Command line test failed\")\n+        _ => fail2!(\"Command line test failed\")\n     }\n }\n \n@@ -242,10 +242,10 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     -> ProcessResult {\n     let cmd = rustpkg_exec().to_str();\n     let env_str = match env {\n-        Some(ref pairs) => pairs.map(|&(ref k, ref v)| { fmt!(\"%s=%s\", *k, *v) }).connect(\",\"),\n+        Some(ref pairs) => pairs.map(|&(ref k, ref v)| { format!(\"{}={}\", *k, *v) }).connect(\",\"),\n         None        => ~\"\"\n     };\n-    debug!(\"%s cd %s; %s %s\", env_str, cwd.to_str(), cmd, args.connect(\" \"));\n+    debug2!(\"{} cd {}; {} {}\", env_str, cwd.to_str(), cmd, args.connect(\" \"));\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n@@ -256,7 +256,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         err_fd: None\n     });\n     let output = prog.finish_with_output();\n-    debug!(\"Output from command %s with args %? was %s {%s}[%?]\",\n+    debug2!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n                     cmd, args, str::from_utf8(output.output),\n                    str::from_utf8(output.error),\n                    output.status);\n@@ -267,7 +267,7 @@ So tests that use this need to check the existence of a file\n to make sure the command succeeded\n */\n     if output.status != 0 {\n-        debug!(\"Command %s %? failed with exit code %?; its output was {{{ %s }}}\",\n+        debug2!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n               str::from_utf8(output.output) + str::from_utf8(output.error));\n         Fail(output.status)\n@@ -279,7 +279,7 @@ to make sure the command succeeded\n \n fn create_local_package(pkgid: &PkgId) -> Path {\n     let parent_dir = mk_temp_workspace(&pkgid.path, &pkgid.version);\n-    debug!(\"Created empty package dir for %s, returning %s\", pkgid.to_str(), parent_dir.to_str());\n+    debug2!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.to_str());\n     parent_dir.pop().pop()\n }\n \n@@ -289,7 +289,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n \n     // Create main, lib, test, and bench files\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+    debug2!(\"Created {} and does it exist? {:?}\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n@@ -305,7 +305,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n }\n \n fn create_local_package_with_test(pkgid: &PkgId) -> Path {\n-    debug!(\"Dry run -- would create package %s with test\");\n+    debug2!(\"Dry run -- would create package {:?} with test\", pkgid);\n     create_local_package(pkgid) // Already has tests???\n }\n \n@@ -314,7 +314,7 @@ fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> Path {\n     create_local_package_in(subord_pkgid, &package_dir);\n     // Write a main.rs file into pkgid that references subord_pkgid\n     writeFile(&package_dir.push_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n-              fmt!(\"extern mod %s;\\nfn main() {}\",\n+              format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n                    subord_pkgid.short_name));\n     // Write a lib.rs file into subord_pkgid that has something in it\n     writeFile(&package_dir.push_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n@@ -324,7 +324,7 @@ fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> Path {\n \n fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n                                                custom_build_hook: &str) -> Path {\n-    debug!(\"Dry run -- would create package %s with custom build hook %s\",\n+    debug2!(\"Dry run -- would create package {} with custom build hook {}\",\n            pkgid.to_str(), custom_build_hook);\n     create_local_package(pkgid)\n     // actually write the pkg.rs with the custom build hook\n@@ -336,9 +336,9 @@ fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Version) {\n }\n \n fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? version?\n-    debug!(\"assert_lib_exists: repo = %s, pkg_path = %s\", repo.to_str(), pkg_path.to_str());\n+    debug2!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.to_str(), pkg_path.to_str());\n     let lib = installed_library_in_workspace(pkg_path, repo);\n-    debug!(\"assert_lib_exists: checking whether %? exists\", lib);\n+    debug2!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n         os::path_exists(libname) && is_rwx(libname)\n@@ -350,13 +350,13 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"executable_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n     os::path_exists(&exec) && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"test_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"test_executable_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n     do exec.map_default(false) |exec| {\n         os::path_exists(exec) && is_rwx(exec)\n@@ -375,7 +375,8 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"assert_built_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n+            repo.to_str(), short_name);\n     let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n@@ -409,15 +410,15 @@ fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n \n fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n     os::path_exists(&target_build_dir(repo).push_many([short_name.to_owned(),\n-                                     fmt!(\"%s.%s\", short_name, extension)]))\n+                                     format!(\"{}.{}\", short_name, extension)]))\n }\n \n fn assert_built_library_exists(repo: &Path, short_name: &str) {\n     assert!(built_library_exists(repo, short_name));\n }\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"assert_built_library_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug2!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n     let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n@@ -439,7 +440,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n     let mut result = ~[];\n     let p_output = match command_line_test_with_env(args,\n         &os::getcwd(), Some(env)) {\n-        Fail(_) => fail!(\"Command-line test failed\"),\n+        Fail(_) => fail2!(\"Command-line test failed\"),\n         Success(r) => r\n     };\n     let test_output = str::from_utf8(p_output.output);\n@@ -451,7 +452,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n \n // assumes short_name and path are one and the same -- I should fix\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n-    debug!(\"lib_output_file_name: given %s and short name %s\",\n+    debug2!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.to_str(), short_name);\n     library_in_workspace(&Path(short_name),\n                          short_name,\n@@ -462,7 +463,7 @@ fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n }\n \n fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n-    target_build_dir(workspace).push(short_name).push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n+    target_build_dir(workspace).push(short_name).push(format!(\"{}{}\", short_name, os::EXE_SUFFIX))\n }\n \n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n@@ -485,20 +486,20 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     let pkg_src_dir = workspace.push_many([~\"src\", pkgid.to_str()]);\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.push(filename);\n-    debug!(\"Trying to frob %s -- %s\", pkg_src_dir.to_str(), filename);\n+    debug2!(\"Trying to frob {} -- {}\", pkg_src_dir.to_str(), filename);\n     if os::path_exists(&maybe_file) {\n         maybe_p = Some(maybe_file);\n     }\n-    debug!(\"Frobbed? %?\", maybe_p);\n+    debug2!(\"Frobbed? {:?}\", maybe_p);\n     match maybe_p {\n         Some(ref p) => {\n             let w = io::file_writer(p, &[io::Append]);\n             match w {\n-                Err(s) => { let _ = cond.raise((p.clone(), fmt!(\"Bad path: %s\", s))); }\n+                Err(s) => { let _ = cond.raise((p.clone(), format!(\"Bad path: {}\", s))); }\n                 Ok(w)  => w.write_line(\"/* hi */\")\n             }\n         }\n-        None => fail!(fmt!(\"frob_source_file failed to find a source file in %s\",\n+        None => fail2!(format!(\"frob_source_file failed to find a source file in {}\",\n                            pkg_src_dir.to_str()))\n     }\n }\n@@ -509,7 +510,7 @@ fn test_make_dir_rwx() {\n     let dir = temp.push(\"quux\");\n     assert!(!os::path_exists(&dir) ||\n             os::remove_dir_recursive(&dir));\n-    debug!(\"Trying to make %s\", dir.to_str());\n+    debug2!(\"Trying to make {}\", dir.to_str());\n     assert!(make_dir_rwx(&dir));\n     assert!(os::path_is_dir(&dir));\n     assert!(is_rwx(&dir));\n@@ -521,29 +522,29 @@ fn test_install_valid() {\n     use path_util::installed_library_in_workspace;\n \n     let sysroot = test_sysroot();\n-    debug!(\"sysroot = %s\", sysroot.to_str());\n+    debug2!(\"sysroot = {}\", sysroot.to_str());\n     let temp_pkg_id = fake_pkg();\n     let temp_workspace = mk_temp_workspace(&temp_pkg_id.path, &NoVersion).pop().pop();\n     let ctxt = fake_ctxt(sysroot, &temp_workspace);\n-    debug!(\"temp_workspace = %s\", temp_workspace.to_str());\n+    debug2!(\"temp_workspace = {}\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n     let src = PkgSrc::new(temp_workspace.clone(), false, temp_pkg_id.clone());\n     ctxt.install(src, &Everything);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n-    debug!(\"exec = %s\", exec.to_str());\n+    debug2!(\"exec = {}\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, &temp_workspace);\n-    debug!(\"lib = %?\", lib);\n+    debug2!(\"lib = {:?}\", lib);\n     assert!(lib.map_default(false, |l| os::path_exists(l)));\n     assert!(lib.map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n     let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n-    debug!(\"bench = %s\", bench.to_str());\n+    debug2!(\"bench = {}\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n \n@@ -568,12 +569,12 @@ fn test_install_invalid() {\n #[test]\n fn test_install_git() {\n     let sysroot = test_sysroot();\n-    debug!(\"sysroot = %s\", sysroot.to_str());\n+    debug2!(\"sysroot = {}\", sysroot.to_str());\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n-    debug!(\"repo = %s\", repo.to_str());\n+    debug2!(\"repo = {}\", repo.to_str());\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n-    debug!(\"repo_subdir = %s\", repo_subdir.to_str());\n+    debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n \n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -585,15 +586,15 @@ fn test_install_git() {\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    debug!(\"test_install_git: calling rustpkg install %s in %s\",\n+    debug2!(\"test_install_git: calling rustpkg install {} in {}\",\n            temp_pkg_id.path.to_str(), repo.to_str());\n     // should have test, bench, lib, and main\n     command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n     let ws = repo.push(\".rust\");\n     // Check that all files exist\n-    debug!(\"Checking for files in %s\", ws.to_str());\n+    debug2!(\"Checking for files in {}\", ws.to_str());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug!(\"exec = %s\", exec.to_str());\n+    debug2!(\"exec = {}\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let _built_lib =\n@@ -609,9 +610,9 @@ fn test_install_git() {\n     // And that the test and bench executables aren't installed\n     let test = target_test_in_workspace(&temp_pkg_id, &ws);\n     assert!(!os::path_exists(&test));\n-    debug!(\"test = %s\", test.to_str());\n+    debug2!(\"test = {}\", test.to_str());\n     let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n-    debug!(\"bench = %s\", bench.to_str());\n+    debug2!(\"bench = {}\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n \n@@ -661,7 +662,7 @@ fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n-    debug!(\"Writing files in: %s\", repo_subdir.to_str());\n+    debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n@@ -681,7 +682,7 @@ fn test_package_version() {\n     // we can still match on the filename to make sure it contains the 0.4 version\n     assert!(match built_library_in_workspace(&temp_pkg_id,\n                                              &ws) {\n-        Some(p) => p.to_str().ends_with(fmt!(\"0.4%s\", os::consts::DLL_SUFFIX)),\n+        Some(p) => p.to_str().ends_with(format!(\"0.4{}\", os::consts::DLL_SUFFIX)),\n         None    => false\n     });\n     assert!(built_executable_in_workspace(&temp_pkg_id, &ws)\n@@ -696,7 +697,7 @@ fn test_package_request_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n     let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test_pkg_version\"]);\n-    debug!(\"Writing files in: %s\", repo_subdir.to_str());\n+    debug2!(\"Writing files in: {}\", repo_subdir.to_str());\n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n@@ -710,12 +711,12 @@ fn test_package_request_version() {\n     writeFile(&repo_subdir.push(\"version-0.4-file.txt\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n-    command_line_test([~\"install\", fmt!(\"%s#0.3\", local_path)], &repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], &repo);\n \n     assert!(match installed_library_in_workspace(&Path(\"test_pkg_version\"), &repo.push(\".rust\")) {\n         Some(p) => {\n-            debug!(\"installed: %s\", p.to_str());\n-            p.to_str().ends_with(fmt!(\"0.3%s\", os::consts::DLL_SUFFIX))\n+            debug2!(\"installed: {}\", p.to_str());\n+            p.to_str().ends_with(format!(\"0.3{}\", os::consts::DLL_SUFFIX))\n         }\n         None    => false\n     });\n@@ -746,7 +747,7 @@ fn rustpkg_library_target() {\n     let foo_repo = init_git_repo(&Path(\"foo\"));\n     let package_dir = foo_repo.push(\"foo\");\n \n-    debug!(\"Writing files in: %s\", package_dir.to_str());\n+    debug2!(\"Writing files in: {}\", package_dir.to_str());\n     writeFile(&package_dir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&package_dir.push(\"lib.rs\"),\n@@ -772,13 +773,13 @@ fn rustpkg_local_pkg() {\n #[ignore (reason = \"test makes bogus assumptions about build directory layout: issue #8690\")]\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n-    debug!(\"dir = %s\", dir.to_str());\n+    debug2!(\"dir = {}\", dir.to_str());\n     let source = test_sysroot().pop().pop().pop().push_many(\n         [~\"src\", ~\"librustpkg\", ~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n-    debug!(\"package_script_with_default_build: %s\", source.to_str());\n+    debug2!(\"package_script_with_default_build: {}\", source.to_str());\n     if !os::copy_file(&source,\n                       &dir.push_many([~\"src\", ~\"fancy-lib-0.1\", ~\"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n+        fail2!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n     assert_lib_exists(&dir, &Path(\"fancy-lib\"), NoVersion);\n@@ -794,7 +795,7 @@ fn rustpkg_build_no_arg() {\n \n     writeFile(&package_dir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug!(\"build_no_arg: dir = %s\", package_dir.to_str());\n+    debug2!(\"build_no_arg: dir = {}\", package_dir.to_str());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n }\n@@ -808,7 +809,7 @@ fn rustpkg_install_no_arg() {\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     writeFile(&package_dir.push(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug!(\"install_no_arg: dir = %s\", package_dir.to_str());\n+    debug2!(\"install_no_arg: dir = {}\", package_dir.to_str());\n     command_line_test([~\"install\"], &package_dir);\n     assert_lib_exists(&tmp, &Path(\"foo\"), NoVersion);\n }\n@@ -822,7 +823,7 @@ fn rustpkg_clean_no_arg() {\n \n     writeFile(&package_dir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug!(\"clean_no_arg: dir = %s\", package_dir.to_str());\n+    debug2!(\"clean_no_arg: dir = {}\", package_dir.to_str());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n@@ -834,11 +835,11 @@ fn rustpkg_clean_no_arg() {\n fn rust_path_test() {\n     let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n     let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n-    debug!(\"dir = %s\", dir.to_str());\n+    debug2!(\"dir = {}\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n     let cwd = os::getcwd();\n-    debug!(\"cwd = %s\", cwd.to_str());\n+    debug2!(\"cwd = {}\", cwd.to_str());\n                                      // use command_line_test_with_env\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n                                &cwd,\n@@ -944,7 +945,7 @@ fn install_check_duplicates() {\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n-            fail!(\"package %s appears in `list` output more than once\", p.path.to_str());\n+            fail2!(\"package {} appears in `list` output more than once\", p.path.to_str());\n         }\n         else {\n             contents.push((*p).clone());\n@@ -983,8 +984,8 @@ fn no_rebuilding_dep() {\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], &workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n-        Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n+        Fail(status) if status == 65 => fail2!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n+        Fail(_) => fail2!(\"no_rebuilding_dep failed for some other reason\")\n     }\n \n     let bar_date_2 = datestamp(&lib_output_file_name(&workspace,\n@@ -1001,11 +1002,11 @@ fn do_rebuild_dep_dates_change() {\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_lib_name = lib_output_file_name(&workspace, \"bar\");\n     let bar_date = datestamp(&bar_lib_name);\n-    debug!(\"Datestamp on %s is %?\", bar_lib_name.to_str(), bar_date);\n+    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), bar_date);\n     touch_source_file(&workspace, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let new_bar_date = datestamp(&bar_lib_name);\n-    debug!(\"Datestamp on %s is %?\", bar_lib_name.to_str(), new_bar_date);\n+    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), new_bar_date);\n     assert!(new_bar_date > bar_date);\n }\n \n@@ -1074,7 +1075,7 @@ fn test_non_numeric_tag() {\n     writeFile(&repo_subdir.push(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-    command_line_test([~\"install\", fmt!(\"%s#testbranch\", temp_pkg_id.path.to_str())], &repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path.to_str())], &repo);\n     let file1 = repo.push_many([\"mockgithub.com\", \"catamorphism\",\n                                 \"test-pkg\", \"testbranch_only\"]);\n     let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n@@ -1119,7 +1120,7 @@ fn test_extern_mod() {\n     });\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n-        fail!(\"output was %s, error was %s\",\n+        fail2!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n@@ -1149,7 +1150,7 @@ fn test_extern_mod_simpler() {\n     let env = Some([(~\"RUST_PATH\", lib_depend_dir.to_str())] + os::env());\n     let rustpkg_exec = rustpkg_exec();\n     let rustc = rustpkg_exec.with_filename(\"rustc\");\n-    debug!(\"RUST_PATH=%s %s %s \\n --sysroot %s -o %s\",\n+    debug2!(\"RUST_PATH={} {} {} \\n --sysroot {} -o {}\",\n                      lib_depend_dir.to_str(),\n                      rustc.to_str(),\n                      main_file.to_str(),\n@@ -1168,7 +1169,7 @@ fn test_extern_mod_simpler() {\n     });\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n-        fail!(\"output was %s, error was %s\",\n+        fail2!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n@@ -1182,8 +1183,8 @@ fn test_import_rustpkg() {\n     writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    debug!(\"workspace = %s\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(fmt!(\"pkg%s\",\n+    debug2!(\"workspace = {}\", workspace.to_str());\n+    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1192,10 +1193,10 @@ fn test_macro_pkg_script() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     writeFile(&workspace.push_many([~\"src\", ~\"foo-0.1\", ~\"pkg.rs\"]),\n-              \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n+              \"extern mod rustpkg; fn main() { debug2!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    debug!(\"workspace = %s\", workspace.to_str());\n-    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(fmt!(\"pkg%s\",\n+    debug2!(\"workspace = {}\", workspace.to_str());\n+    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1207,11 +1208,11 @@ fn multiple_workspaces() {\n // Make a third package that uses foo, make sure we can build/install it\n     let a_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n     let b_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n-    debug!(\"Trying to install foo in %s\", a_loc.to_str());\n+    debug2!(\"Trying to install foo in {}\", a_loc.to_str());\n     command_line_test([~\"install\", ~\"foo\"], &a_loc);\n-    debug!(\"Trying to install foo in %s\", b_loc.to_str());\n+    debug2!(\"Trying to install foo in {}\", b_loc.to_str());\n     command_line_test([~\"install\", ~\"foo\"], &b_loc);\n-    let env = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", a_loc.to_str(), b_loc.to_str()))]);\n+    let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.to_str(), b_loc.to_str()))]);\n     let c_loc = create_local_package_with_dep(&PkgId::new(\"bar\"), &PkgId::new(\"foo\"));\n     command_line_test_with_env([~\"install\", ~\"bar\"], &c_loc, env);\n }\n@@ -1229,7 +1230,9 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let workspace = create_local_package(&p_id);\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\",\n-       fmt!(\"%s:%s\", dest_workspace.to_str(), workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n+       format!(\"{}:{}\",\n+               dest_workspace.to_str(),\n+               workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n                                ~[~\"foo\"], &dest_workspace, rust_path);\n    assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n@@ -1272,7 +1275,7 @@ fn rust_path_hack_cwd() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n-   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n    assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n    assert_built_library_exists(&dest_workspace, \"foo\");\n    assert!(!lib_exists(&cwd, &Path(\"foo\"), NoVersion));\n@@ -1291,7 +1294,7 @@ fn rust_path_hack_multi_path() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n-   debug!(\"Checking that %s exists in %s\", name, dest_workspace.to_str());\n+   debug2!(\"Checking that {} exists in {}\", name, dest_workspace.to_str());\n    assert_lib_exists(&dest_workspace, &Path(\"quux\"), NoVersion);\n    assert_built_library_exists(&dest_workspace, name);\n    assert!(!lib_exists(&subdir, &Path(\"quux\"), NoVersion));\n@@ -1309,7 +1312,7 @@ fn rust_path_hack_install_no_arg() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n    assert_lib_exists(&dest_workspace, &Path(\"foo\"), NoVersion);\n    assert_built_library_exists(&dest_workspace, \"foo\");\n    assert!(!lib_exists(&source_dir, &Path(\"foo\"), NoVersion));\n@@ -1327,7 +1330,7 @@ fn rust_path_hack_build_no_arg() {\n    let dest_workspace = mk_empty_workspace(&Path(\"bar\"), &NoVersion, \"dest_workspace\");\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.to_str())]);\n    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in %s\", dest_workspace.to_str());\n+   debug2!(\"Checking that foo exists in {}\", dest_workspace.to_str());\n    assert_built_library_exists(&dest_workspace, \"foo\");\n    assert!(!built_library_exists(&source_dir, \"foo\"));\n }\n@@ -1337,13 +1340,13 @@ fn rust_path_install_target() {\n     let dir_for_path = mkdtemp(&os::tmpdir(),\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n     let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n-    debug!(\"dir = %s\", dir.to_str());\n+    debug2!(\"dir = {}\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = mkdtemp(&os::tmpdir(),\n         \"dest_workspace\").expect(\"rust_path_install_target failed\");\n     let dir = dir.pop().pop();\n \n-    let rust_path = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", dir_to_install_to.to_str(),\n+    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dir_to_install_to.to_str(),\n                                                dir.to_str()))]);\n     let cwd = os::getcwd();\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n@@ -1491,7 +1494,7 @@ fn test_cfg_fail() {\n                        ~\"build\",\n                        ~\"foo\"],\n                       &workspace) {\n-        Success(*) => fail!(\"test_cfg_fail failed\"),\n+        Success(*) => fail2!(\"test_cfg_fail failed\"),\n         _          => ()\n     }\n }\n@@ -1627,7 +1630,7 @@ fn pkgid_pointing_to_subdir() {\n     writeFile(&foo_dir.push(\"lib.rs\"), \"pub fn f() {}\");\n     writeFile(&bar_dir.push(\"lib.rs\"), \"pub fn g() {}\");\n \n-    debug!(\"Creating a file in %s\", workspace.to_str());\n+    debug2!(\"Creating a file in {}\", workspace.to_str());\n     let testpkg_dir = workspace.push_many([~\"src\", ~\"testpkg-0.1\"]);\n     assert!(os::mkdir_recursive(&testpkg_dir, U_RWX));\n \n@@ -1654,7 +1657,7 @@ fn test_recursive_deps() {\n     writeFile(&b_workspace.push(\"src\").push(\"b-0.1\").push(\"lib.rs\"),\n                \"extern mod c; use c::g; pub fn f() { g(); }\");\n     let environment = Some(~[(~\"RUST_PATH\", b_workspace.to_str())]);\n-    debug!(\"RUST_PATH=%s\", b_workspace.to_str());\n+    debug2!(\"RUST_PATH={}\", b_workspace.to_str());\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                &a_workspace,\n                                environment);\n@@ -1669,9 +1672,9 @@ fn test_install_to_rust_path() {\n     let second_workspace = create_local_package(&p_id);\n     let first_workspace = mk_empty_workspace(&Path(\"p\"), &NoVersion, \"dest\");\n     let rust_path = Some(~[(~\"RUST_PATH\",\n-                            fmt!(\"%s:%s\", first_workspace.to_str(),\n+                            format!(\"{}:{}\", first_workspace.to_str(),\n                                  second_workspace.to_str()))]);\n-    debug!(\"RUST_PATH=%s:%s\", first_workspace.to_str(), second_workspace.to_str());\n+    debug2!(\"RUST_PATH={}:{}\", first_workspace.to_str(), second_workspace.to_str());\n     command_line_test_with_env([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"foo\"],\n@@ -1782,7 +1785,7 @@ fn correct_package_name_with_rust_path_hack() {\n     writeFile(&dest_workspace.push_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n               \"extern mod blat; fn main() { let _x = (); }\");\n \n-    let rust_path = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", dest_workspace.to_str(),\n+    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.to_str(),\n                         foo_workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n     // bar doesn't exist, but we want to make sure rustpkg doesn't think foo is bar\n     command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n@@ -1833,9 +1836,9 @@ fn test_rebuild_when_needed() {\n     frob_source_file(&foo_workspace, &foo_id, \"test.rs\");\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n-        Success(*) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n+        Success(*) => fail2!(\"test_rebuild_when_needed didn't rebuild\"),\n         Fail(status) if status == 65 => (), // ok\n-        Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n+        Fail(_) => fail2!(\"test_rebuild_when_needed failed for some other reason\")\n     }\n }\n \n@@ -1852,8 +1855,8 @@ fn test_no_rebuilding() {\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n-        Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n+        Fail(status) if status == 65 => fail2!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n+        Fail(_) => fail2!(\"test_no_rebuilding failed for some other reason\")\n     }\n }\n "}, {"sha": "17bda88339314067bc0290874a6e5974c8bcb3ec", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -174,7 +174,7 @@ pub fn compile_input(context: &BuildContext,\n                      what: OutputType) -> Option<Path> {\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input((*in_file).clone());\n-    debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n+    debug2!(\"compile_input: {} / {:?}\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n@@ -184,9 +184,9 @@ pub fn compile_input(context: &BuildContext,\n \n     let binary = os::args()[0].to_managed();\n \n-    debug!(\"flags: %s\", flags.connect(\" \"));\n-    debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n-    debug!(\"compile_input's sysroot = %s\", context.sysroot().to_str());\n+    debug2!(\"flags: {}\", flags.connect(\" \"));\n+    debug2!(\"cfgs: {}\", cfgs.connect(\" \"));\n+    debug2!(\"compile_input's sysroot = {}\", context.sysroot().to_str());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -203,7 +203,7 @@ pub fn compile_input(context: &BuildContext,\n                           + context.flag_strs()\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n                           driver::optgroups()).unwrap();\n-    debug!(\"rustc flags: %?\", matches);\n+    debug2!(\"rustc flags: {:?}\", matches);\n \n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n@@ -213,8 +213,8 @@ pub fn compile_input(context: &BuildContext,\n     else {\n         context.sysroot().pop().pop().pop()\n     };\n-    debug!(\"compile_input's sysroot = %s\", context.sysroot().to_str());\n-    debug!(\"sysroot_to_use = %s\", sysroot_to_use.to_str());\n+    debug2!(\"compile_input's sysroot = {}\", context.sysroot().to_str());\n+    debug2!(\"sysroot_to_use = {}\", sysroot_to_use.to_str());\n \n     let output_type = match context.compile_upto() {\n         Assemble => link::output_type_assembly,\n@@ -262,7 +262,7 @@ pub fn compile_input(context: &BuildContext,\n \n     find_and_install_dependencies(context, pkg_id, sess, exec, &crate,\n                                   |p| {\n-                                      debug!(\"a dependency: %s\", p.to_str());\n+                                      debug2!(\"a dependency: {}\", p.to_str());\n                                       // Pass the directory containing a dependency\n                                       // as an additional lib search path\n                                       if !addl_lib_search_paths.contains(&p) {\n@@ -275,23 +275,23 @@ pub fn compile_input(context: &BuildContext,\n     // Inject the link attributes so we get the right package name and version\n     if attr::find_linkage_metas(crate.attrs).is_empty() {\n         let name_to_use = match what {\n-            Test  => fmt!(\"%stest\", pkg_id.short_name).to_managed(),\n-            Bench => fmt!(\"%sbench\", pkg_id.short_name).to_managed(),\n+            Test  => format!(\"{}test\", pkg_id.short_name).to_managed(),\n+            Bench => format!(\"{}bench\", pkg_id.short_name).to_managed(),\n             _     => pkg_id.short_name.to_managed()\n         };\n-        debug!(\"Injecting link name: %s\", name_to_use);\n+        debug2!(\"Injecting link name: {}\", name_to_use);\n         let link_options =\n             ~[attr::mk_name_value_item_str(@\"name\", name_to_use),\n               attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n             ~[attr::mk_name_value_item_str(@\"package_id\",\n                                            pkg_id.path.to_str().to_managed())];\n \n-        debug!(\"link options: %?\", link_options);\n+        debug2!(\"link options: {:?}\", link_options);\n         crate.attrs = ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))];\n     }\n \n-    debug!(\"calling compile_crate_from_input, workspace = %s,\n-           building_library = %?\", out_dir.to_str(), sess.building_library);\n+    debug2!(\"calling compile_crate_from_input, workspace = {},\n+           building_library = {:?}\", out_dir.to_str(), sess.building_library);\n     let result = compile_crate_from_input(in_file,\n                                           exec,\n                                           context.compile_upto(),\n@@ -305,7 +305,7 @@ pub fn compile_input(context: &BuildContext,\n     else {\n         result\n     };\n-    debug!(\"About to discover output %s\", discovered_output.to_str());\n+    debug2!(\"About to discover output {}\", discovered_output.to_str());\n     for p in discovered_output.iter() {\n         if os::path_exists(p) {\n             exec.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n@@ -330,22 +330,22 @@ pub fn compile_crate_from_input(input: &Path,\n // Returns None if one of the flags that suppresses compilation output was\n // given\n                                 crate: ast::Crate) -> Option<Path> {\n-    debug!(\"Calling build_output_filenames with %s, building library? %?\",\n+    debug2!(\"Calling build_output_filenames with {}, building library? {:?}\",\n            out_dir.to_str(), sess.building_library);\n \n     // bad copy\n-    debug!(\"out_dir = %s\", out_dir.to_str());\n+    debug2!(\"out_dir = {}\", out_dir.to_str());\n     let outputs = driver::build_output_filenames(&driver::file_input(input.clone()),\n                                                  &Some(out_dir.clone()), &None,\n                                                  crate.attrs, sess);\n \n-    debug!(\"Outputs are out_filename: %s and obj_filename: %s and output type = %?\",\n+    debug2!(\"Outputs are out_filename: {} and obj_filename: {} and output type = {:?}\",\n            outputs.out_filename.to_str(),\n            outputs.obj_filename.to_str(),\n            sess.opts.output_type);\n-    debug!(\"additional libraries:\");\n+    debug2!(\"additional libraries:\");\n     for lib in sess.opts.addl_lib_search_paths.iter() {\n-        debug!(\"an additional library: %s\", lib.to_str());\n+        debug2!(\"an additional library: {}\", lib.to_str());\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, &crate);\n     if driver::stop_after_phase_3(sess) { return None; }\n@@ -362,7 +362,7 @@ pub fn compile_crate_from_input(input: &Path,\n     // Register dependency on the source file\n     exec.discover_input(\"file\", input.to_str(), digest_file_with_date(input));\n \n-    debug!(\"Built %s, date = %?\", outputs.out_filename.to_str(),\n+    debug2!(\"Built {}, date = {:?}\", outputs.out_filename.to_str(),\n            datestamp(&outputs.out_filename));\n \n     Some(outputs.out_filename)\n@@ -384,10 +384,10 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n                      what: OutputType) -> Option<Path> {\n-    debug!(\"compile_crate: crate=%s, workspace=%s\", crate.to_str(), workspace.to_str());\n-    debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n+    debug2!(\"compile_crate: crate={}, workspace={}\", crate.to_str(), workspace.to_str());\n+    debug2!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n-        debug!(\"+++ %s\", *fl);\n+        debug2!(\"+++ {}\", *fl);\n     }\n     compile_input(ctxt, exec, pkg_id, crate, workspace, flags, cfgs, opt, what)\n }\n@@ -403,19 +403,19 @@ struct ViewItemVisitor<'self> {\n \n impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n     fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n-        debug!(\"A view item!\");\n+        debug2!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n                 let lib_name = match path_opt {\n                     Some(p) => p,\n                     None => self.sess.str_of(lib_ident)\n                 };\n-                debug!(\"Finding and installing... %s\", lib_name);\n+                debug2!(\"Finding and installing... {}\", lib_name);\n                 // Check standard Rust library path first\n                 match system_library(&self.context.sysroot(), lib_name) {\n                     Some(ref installed_path) => {\n-                        debug!(\"It exists: %s\", installed_path.to_str());\n+                        debug2!(\"It exists: {}\", installed_path.to_str());\n                         // Say that [path for c] has a discovered dependency on\n                         // installed_path\n                         // For binary files, we only hash the datestamp, not the contents.\n@@ -428,15 +428,15 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n-                        debug!(\"Trying to install library %s, rebuilding it\",\n+                        debug2!(\"Trying to install library {}, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n                         let pkg_id = PkgId::new(lib_name);\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n                                                                &pkg_id);\n                         let source_workspace = if workspaces.is_empty() {\n-                            error(fmt!(\"Couldn't find package %s \\\n-                                       in any of the workspaces in the RUST_PATH (%s)\",\n+                            error(format!(\"Couldn't find package {} \\\n+                                       in any of the workspaces in the RUST_PATH ({})\",\n                                        lib_name,\n                                        rust_path().map(|s| s.to_str()).connect(\":\")));\n                             cond.raise((pkg_id.clone(), ~\"Dependency not found\"))\n@@ -452,14 +452,14 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                              pkg_id),\n                                                  &JustOne(Path(\n                                     lib_crate_filename)));\n-                        debug!(\"Installed %s, returned %? dependencies and \\\n-                               %? transitive dependencies\",\n+                        debug2!(\"Installed {}, returned {:?} dependencies and \\\n+                               {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n                         // It must have installed *something*...\n                         assert!(!outputs_disc.is_empty());\n                         let target_workspace = outputs_disc[0].pop();\n                         for dep in outputs_disc.iter() {\n-                            debug!(\"Discovering a binary input: %s\", dep.to_str());\n+                            debug2!(\"Discovering a binary input: {}\", dep.to_str());\n                             self.exec.discover_input(\"binary\",\n                                                      dep.to_str(),\n                                                      digest_only_date(dep));\n@@ -476,11 +476,11 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                          digest_only_date(&Path(*dep)));\n                             }\n                                 else {\n-                                fail!(\"Bad kind: %s\", *what);\n+                                fail2!(\"Bad kind: {}\", *what);\n                             }\n                         }\n                         // Also, add an additional search path\n-                        debug!(\"Installed %s into %s\", lib_name, target_workspace.to_str());\n+                        debug2!(\"Installed {} into {}\", lib_name, target_workspace.to_str());\n                         (self.save)(target_workspace);\n                     }\n                 }\n@@ -501,7 +501,7 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                                      exec: &mut workcache::Exec,\n                                      c: &ast::Crate,\n                                      save: &fn(Path)) {\n-    debug!(\"In find_and_install_dependencies...\");\n+    debug2!(\"In find_and_install_dependencies...\");\n     let mut visitor = ViewItemVisitor {\n         context: context,\n         parent: parent,\n@@ -553,8 +553,8 @@ fn debug_flags() -> ~[~str] { ~[] }\n \n /// Returns the last-modified date as an Option\n pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    debug!(\"Scrutinizing datestamp for %s - does it exist? %?\", p.to_str(), os::path_exists(p));\n+    debug2!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.to_str(), os::path_exists(p));\n     let out = p.stat().map(|stat| stat.st_mtime);\n-    debug!(\"Date = %?\", out);\n+    debug2!(\"Date = {:?}\", out);\n     out.map(|t| { *t as libc::time_t })\n }"}, {"sha": "a59d2bb28870cad01b62bd98b1f28fcc11c093d5", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -79,8 +79,8 @@ impl Ord for Version {\n impl ToStr for Version {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            ExactRevision(ref n) | Tagged(ref n) => fmt!(\"%s\", n.to_str()),\n-            SemanticVersion(ref v) => fmt!(\"%s\", v.to_str()),\n+            ExactRevision(ref n) | Tagged(ref n) => format!(\"{}\", n.to_str()),\n+            SemanticVersion(ref v) => format!(\"{}\", v.to_str()),\n             NoVersion => ~\"0.1\"\n         }\n     }\n@@ -104,9 +104,9 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n             loop;\n         }\n         let outp = run::process_output(\"git\",\n-                                   [fmt!(\"--git-dir=%s\", git_dir.to_str()), ~\"tag\", ~\"-l\"]);\n+                                   [format!(\"--git-dir={}\", git_dir.to_str()), ~\"tag\", ~\"-l\"]);\n \n-        debug!(\"git --git-dir=%s tag -l ~~~> %?\", git_dir.to_str(), outp.status);\n+        debug2!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.to_str(), outp.status);\n \n         if outp.status != 0 {\n             loop;\n@@ -134,25 +134,27 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n     if is_url_like(remote_path) {\n         let tmp_dir = mkdtemp(&os::tmpdir(),\n                               \"test\").expect(\"try_getting_version: couldn't create temp dir\");\n-        debug!(\"(to get version) executing {git clone https://%s %s}\",\n+        debug2!(\"(to get version) executing \\\\{git clone https://{} {}\\\\}\",\n                remote_path.to_str(),\n                tmp_dir.to_str());\n-        let outp  = run::process_output(\"git\", [~\"clone\", fmt!(\"https://%s\", remote_path.to_str()),\n+        let outp  = run::process_output(\"git\", [~\"clone\",\n+                                                format!(\"https://{}\",\n+                                                        remote_path.to_str()),\n                                                 tmp_dir.to_str()]);\n         if outp.status == 0 {\n-            debug!(\"Cloned it... ( %s, %s )\",\n+            debug2!(\"Cloned it... ( {}, {} )\",\n                    str::from_utf8(outp.output),\n                    str::from_utf8(outp.error));\n             let mut output = None;\n-            debug!(\"(getting version, now getting tags) executing {git --git-dir=%s tag -l}\",\n+            debug2!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n                    tmp_dir.push(\".git\").to_str());\n             let outp = run::process_output(\"git\",\n-                                           [fmt!(\"--git-dir=%s\", tmp_dir.push(\".git\").to_str()),\n+                                           [format!(\"--git-dir={}\", tmp_dir.push(\".git\").to_str()),\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_utf8(outp.output);\n-            debug!(\"Full output: ( %s ) [%?]\", output_text, outp.status);\n+            debug2!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n             for l in output_text.line_iter() {\n-                debug!(\"A line of output: %s\", l);\n+                debug2!(\"A line of output: {}\", l);\n                 if !l.is_whitespace() {\n                     output = Some(l);\n                 }\n@@ -179,7 +181,7 @@ enum ParseState {\n \n pub fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n-    debug!(\"Attempting to parse: %s\", s);\n+    debug2!(\"Attempting to parse: {}\", s);\n     let mut parse_state = Start;\n     for c in s.iter() {\n         if char::is_digit(c) {\n@@ -242,7 +244,7 @@ fn test_parse_version() {\n #[test]\n fn test_split_version() {\n     let s = \"a/b/c#0.1\";\n-    debug!(\"== %? ==\", split_version(s));\n+    debug2!(\"== {:?} ==\", split_version(s));\n     assert!(split_version(s) == Some((s.slice(0, 5), ExactRevision(~\"0.1\"))));\n     assert!(split_version(\"a/b/c\") == None);\n     let s = \"a#1.2\";"}, {"sha": "8af24ff4c3889064fe7750e6a81beb961e0f35fe", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -25,12 +25,12 @@ pub fn digest_file_with_date(path: &Path) -> ~str {\n             (*sha).input_str(s);\n             let st = match path.stat() {\n                 Some(st) => st,\n-                None => cond1.raise((path.clone(), fmt!(\"Couldn't get file access time\")))\n+                None => cond1.raise((path.clone(), format!(\"Couldn't get file access time\")))\n             };\n             (*sha).input_str(st.st_mtime.to_str());\n             (*sha).result_str()\n         }\n-        Err(e) => cond.raise((path.clone(), fmt!(\"Couldn't read file: %s\", e))).to_str()\n+        Err(e) => cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e))).to_str()\n     }\n }\n \n@@ -41,17 +41,17 @@ pub fn digest_only_date(path: &Path) -> ~str {\n     let mut sha = ~Sha1::new();\n     let st = match path.stat() {\n                 Some(st) => st,\n-                None => cond.raise((path.clone(), fmt!(\"Couldn't get file access time\")))\n+                None => cond.raise((path.clone(), format!(\"Couldn't get file access time\")))\n     };\n     (*sha).input_str(st.st_mtime.to_str());\n     (*sha).result_str()\n }\n \n /// Adds multiple discovered outputs\n pub fn discover_outputs(e: &mut workcache::Exec, outputs: ~[Path]) {\n-    debug!(\"Discovering %? outputs\", outputs.len());\n+    debug2!(\"Discovering {:?} outputs\", outputs.len());\n     for p in outputs.iter() {\n-        debug!(\"Discovering output! %s\", p.to_str());\n+        debug2!(\"Discovering output! {}\", p.to_str());\n         // For now, assume that all discovered outputs are binaries\n         e.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n     }"}, {"sha": "9642d004de316ecaa323e82d79a644710fd10721", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -25,8 +25,8 @@ pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path)\n     let workspaces = pkg_parent_workspaces(cx, pkgid);\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n-        fail!(\"Package %s not found in any of \\\n-                    the following workspaces: %s\",\n+        fail2!(\"Package {} not found in any of \\\n+                    the following workspaces: {}\",\n                    pkgid.path.to_str(),\n                    rust_path().to_str());\n     }"}, {"sha": "93a66f6d917709c32f93d2ee4d94341cd3b7b6da", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -236,7 +236,7 @@ pub mod raw {\n                 let alloc = n * (*ty).size;\n                 let total_size = alloc + sys::size_of::<Vec<()>>();\n                 if alloc / (*ty).size != n || total_size < alloc {\n-                    fail!(\"vector size is too large: %u\", n);\n+                    fail2!(\"vector size is too large: {}\", n);\n                 }\n                 (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n                 (**ptr).data.alloc = alloc;"}, {"sha": "8118907322bf79c48318fc57e05a47405fa3f69a", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -116,7 +116,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n         f(self.buf)\n     }\n \n@@ -126,7 +126,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n         f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n     }\n \n@@ -152,7 +152,7 @@ impl CString {\n     /// Fails if the CString is null.\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n         unsafe {\n             cast::transmute((self.buf, self.len() + 1))\n         }\n@@ -273,7 +273,7 @@ impl<'self> ToCStr for &'self [u8] {\n         do self.as_imm_buf |self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n-                fail!(\"failed to allocate memory!\");\n+                fail2!(\"failed to allocate memory!\");\n             }\n \n             ptr::copy_memory(buf, self_buf, self_len);"}, {"sha": "4bbb0a5935aeeba50617ab06c0af99c7cea65c86", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -44,7 +44,7 @@ impl<T> Cell<T> {\n     pub fn take(&self) -> T {\n         let this = unsafe { transmute_mut(self) };\n         if this.is_empty() {\n-            fail!(\"attempt to take an empty cell\");\n+            fail2!(\"attempt to take an empty cell\");\n         }\n \n         this.value.take_unwrap()\n@@ -60,7 +60,7 @@ impl<T> Cell<T> {\n     pub fn put_back(&self, value: T) {\n         let this = unsafe { transmute_mut(self) };\n         if !this.is_empty() {\n-            fail!(\"attempt to put a value back into a full cell\");\n+            fail2!(\"attempt to put a value back into a full cell\");\n         }\n         this.value = Some(value);\n     }"}, {"sha": "54613adf3fec15ebf8efd82089c17cb1c82e8a81", "filename": "src/libstd/char.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -187,7 +187,7 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n-        fail!(\"to_digit: radix %? is to high (maximum 36)\", radix);\n+        fail2!(\"to_digit: radix {} is to high (maximum 36)\", radix);\n     }\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n@@ -214,7 +214,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        fail!(\"from_digit: radix %? is to high (maximum 36)\", num);\n+        fail2!(\"from_digit: radix {} is to high (maximum 36)\", num);\n     }\n     if num < radix {\n         unsafe {\n@@ -342,7 +342,7 @@ pub fn len_utf8_bytes(c: char) -> uint {\n         _ if code < MAX_TWO_B   => 2u,\n         _ if code < MAX_THREE_B => 3u,\n         _ if code < MAX_FOUR_B  => 4u,\n-        _                       => fail!(\"invalid character!\"),\n+        _                       => fail2!(\"invalid character!\"),\n     }\n }\n "}, {"sha": "77f8cb937fac000b6357061db9df89fd2fc04f64", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -56,7 +56,7 @@ do my_error::cond.trap(|raised_int| {\n Condition handling is useful in cases where propagating errors is either to\n cumbersome or just not necessary in the first place. It should also be noted,\n though, that if there is not handler installed when a condition is raised, then\n-the task invokes `fail!()` and will terminate.\n+the task invokes `fail2!()` and will terminate.\n \n ## More Info\n \n@@ -127,20 +127,20 @@ impl<T, U> Condition<T, U> {\n     /// If a handler is found, its return value is returned, otherwise this\n     /// function will not return.\n     pub fn raise(&self, t: T) -> U {\n-        let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n-        self.raise_default(t, || fail!(msg.clone()))\n+        let msg = format!(\"Unhandled condition: {}: {:?}\", self.name, t);\n+        self.raise_default(t, || fail2!(\"{}\", msg.clone()))\n     }\n \n     /// Performs the same functionality as `raise`, except that when no handler\n     /// is found the `default` argument is called instead of failing the task.\n     pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n         match local_data::pop(self.key) {\n             None => {\n-                debug!(\"Condition.raise: found no handler\");\n+                debug2!(\"Condition.raise: found no handler\");\n                 default()\n             }\n             Some(handler) => {\n-                debug!(\"Condition.raise: found handler\");\n+                debug2!(\"Condition.raise: found handler\");\n                 match handler.prev {\n                     None => {}\n                     Some(hp) => local_data::set(self.key, hp)\n@@ -183,7 +183,7 @@ impl<'self, T, U> Trap<'self, T, U> {\n     /// ```\n     pub fn inside<V>(&self, inner: &'self fn() -> V) -> V {\n         let _g = Guard { cond: self.cond };\n-        debug!(\"Trap: pushing handler to TLS\");\n+        debug2!(\"Trap: pushing handler to TLS\");\n         local_data::set(self.cond.key, self.handler);\n         inner()\n     }\n@@ -197,7 +197,7 @@ struct Guard<'self, T, U> {\n #[unsafe_destructor]\n impl<'self, T, U> Drop for Guard<'self, T, U> {\n     fn drop(&mut self) {\n-        debug!(\"Guard: popping handler from TLS\");\n+        debug2!(\"Guard: popping handler from TLS\");\n         let curr = local_data::pop(self.cond.key);\n         match curr {\n             None => {}\n@@ -216,20 +216,20 @@ mod test {\n     }\n \n     fn trouble(i: int) {\n-        debug!(\"trouble: raising condition\");\n+        debug2!(\"trouble: raising condition\");\n         let j = sadness::cond.raise(i);\n-        debug!(\"trouble: handler recovered with %d\", j);\n+        debug2!(\"trouble: handler recovered with {}\", j);\n     }\n \n     fn nested_trap_test_inner() {\n         let mut inner_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_inner: in handler\");\n+            debug2!(\"nested_trap_test_inner: in handler\");\n             inner_trapped = true;\n             0\n         }).inside {\n-            debug!(\"nested_trap_test_inner: in protected block\");\n+            debug2!(\"nested_trap_test_inner: in protected block\");\n             trouble(1);\n         }\n \n@@ -241,10 +241,10 @@ mod test {\n         let mut outer_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_outer: in handler\");\n+            debug2!(\"nested_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n         }).inside {\n-            debug!(\"nested_guard_test_outer: in protected block\");\n+            debug2!(\"nested_guard_test_outer: in protected block\");\n             nested_trap_test_inner();\n             trouble(1);\n         }\n@@ -256,13 +256,13 @@ mod test {\n         let mut inner_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_inner: in handler\");\n+            debug2!(\"nested_reraise_trap_test_inner: in handler\");\n             inner_trapped = true;\n             let i = 10;\n-            debug!(\"nested_reraise_trap_test_inner: handler re-raising\");\n+            debug2!(\"nested_reraise_trap_test_inner: handler re-raising\");\n             sadness::cond.raise(i)\n         }).inside {\n-            debug!(\"nested_reraise_trap_test_inner: in protected block\");\n+            debug2!(\"nested_reraise_trap_test_inner: in protected block\");\n             trouble(1);\n         }\n \n@@ -274,10 +274,10 @@ mod test {\n         let mut outer_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_outer: in handler\");\n+            debug2!(\"nested_reraise_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n         }).inside {\n-            debug!(\"nested_reraise_trap_test_outer: in protected block\");\n+            debug2!(\"nested_reraise_trap_test_outer: in protected block\");\n             nested_reraise_trap_test_inner();\n         }\n \n@@ -289,10 +289,10 @@ mod test {\n         let mut trapped = false;\n \n         do sadness::cond.trap(|j| {\n-            debug!(\"test_default: in handler\");\n+            debug2!(\"test_default: in handler\");\n             sadness::cond.raise_default(j, || { trapped=true; 5 })\n         }).inside {\n-            debug!(\"test_default: in protected block\");\n+            debug2!(\"test_default: in protected block\");\n             trouble(1);\n         }\n "}, {"sha": "657212fc692270f32fffd317ae0c35718eaeefa8", "filename": "src/libstd/either.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -78,7 +78,7 @@ impl<L, R> Either<L, R> {\n     pub fn expect_left(self, reason: &str) -> L {\n         match self {\n             Left(x) => x,\n-            Right(_) => fail!(reason.to_owned())\n+            Right(_) => fail2!(\"{}\", reason.to_owned())\n         }\n     }\n \n@@ -94,7 +94,7 @@ impl<L, R> Either<L, R> {\n     pub fn expect_right(self, reason: &str) -> R {\n         match self {\n             Right(x) => x,\n-            Left(_) => fail!(reason.to_owned())\n+            Left(_) => fail2!(\"{}\", reason.to_owned())\n         }\n     }\n "}, {"sha": "b185b67d09cbf10269848de012fc50d28dc79d3d", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -234,7 +234,7 @@ impl<'self> Parser<'self> {\n             Some((_, c @ '#')) | Some((_, c @ '{')) |\n             Some((_, c @ '\\\\')) | Some((_, c @ '}')) => { c }\n             Some((_, c)) => {\n-                self.err(fmt!(\"invalid escape character `%c`\", c));\n+                self.err(format!(\"invalid escape character `{}`\", c));\n                 c\n             }\n             None => {\n@@ -378,7 +378,7 @@ impl<'self> Parser<'self> {\n                 return None;\n             }\n             method => {\n-                self.err(fmt!(\"unknown method: `%s`\", method));\n+                self.err(format!(\"unknown method: `{}`\", method));\n                 return None;\n             }\n         }\n@@ -448,8 +448,8 @@ impl<'self> Parser<'self> {\n                     Some((_, 'f')) => {\n                         let word = self.word();\n                         if word != \"offset\" {\n-                            self.err(fmt!(\"expected `offset`, found `%s`\",\n-                                          word));\n+                            self.err(format!(\"expected `offset`, found `{}`\",\n+                                             word));\n                         } else {\n                             if !self.consume(':') {\n                                 self.err(~\"`offset` must be followed by `:`\");\n@@ -490,7 +490,8 @@ impl<'self> Parser<'self> {\n                     \"few\"   => Left(Few),\n                     \"many\"  => Left(Many),\n                     word    => {\n-                        self.err(fmt!(\"unexpected plural selector `%s`\", word));\n+                        self.err(format!(\"unexpected plural selector `{}`\",\n+                                         word));\n                         if word == \"\" {\n                             break\n                         } else {"}, {"sha": "d63acb74acdb1e5313331b0f6d505608ddc825e4", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -493,18 +493,18 @@ mod tests {\n         }\n \n         while t < 64 {\n-            debug!(\"siphash test %?\", t);\n+            debug2!(\"siphash test {}\", t);\n             let vec = u8to64_le!(vecs[t], 0);\n             let out = Bytes(buf.as_slice()).hash_keyed(k0, k1);\n-            debug!(\"got %?, expected %?\", out, vec);\n+            debug2!(\"got {:?}, expected {:?}\", out, vec);\n             assert_eq!(vec, out);\n \n             stream_full.reset();\n             stream_full.input(buf);\n             let f = stream_full.result_str();\n             let i = stream_inc.result_str();\n             let v = to_hex_str(&vecs[t]);\n-            debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n+            debug2!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n \n             assert!(f == i && f == v);\n "}, {"sha": "7b18bed0098928dc09ddfda7c25f5c839dd53531", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -179,7 +179,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n         match self.buckets[idx] {\n             Some(ref bkt) => &bkt.value,\n-            None => fail!(\"HashMap::find: internal logic error\"),\n+            None => fail2!(\"HashMap::find: internal logic error\"),\n         }\n     }\n \n@@ -196,7 +196,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     /// True if there was no previous entry with that key\n     fn insert_internal(&mut self, hash: uint, k: K, v: V) -> Option<V> {\n         match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => { fail!(\"Internal logic error\"); }\n+            TableFull => { fail2!(\"Internal logic error\"); }\n             FoundHole(idx) => {\n                 self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n                                                 value: v});\n@@ -205,7 +205,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n             }\n             FoundEntry(idx) => {\n                 match self.buckets[idx] {\n-                    None => { fail!(\"insert_internal: Internal logic error\") }\n+                    None => { fail2!(\"insert_internal: Internal logic error\") }\n                     Some(ref mut b) => {\n                         b.hash = hash;\n                         b.key = k;\n@@ -374,7 +374,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n+            TableFull => fail2!(\"Internal logic error\"),\n             FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n             FoundHole(idx) => {\n                 let v = not_found(&k, a);\n@@ -413,7 +413,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: %?\", k),\n+            None => fail2!(\"No entry found for key: {:?}\", k),\n         }\n     }\n \n@@ -422,7 +422,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: %?\", k),\n+            None => fail2!(\"No entry found for key: {:?}\", k),\n         }\n     }\n \n@@ -826,7 +826,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => fail2!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }\n@@ -943,7 +943,7 @@ mod test_map {\n         assert!(m.find(&1).is_none());\n         m.insert(1, 2);\n         match m.find(&1) {\n-            None => fail!(),\n+            None => fail2!(),\n             Some(v) => assert!(*v == 2)\n         }\n     }"}, {"sha": "dfe517932fcf65048d3b4aa0185cc32588519751", "filename": "src/libstd/io.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -947,9 +947,8 @@ impl Reader for *libc::FILE {\n                   match libc::ferror(*self) {\n                     0 => (),\n                     _ => {\n-                      error!(\"error reading buffer\");\n-                      error!(\"%s\", os::last_os_error());\n-                      fail!();\n+                      error2!(\"error reading buffer: {}\", os::last_os_error());\n+                      fail2!();\n                     }\n                   }\n                 }\n@@ -1194,9 +1193,8 @@ impl Writer for *libc::FILE {\n                                         len as size_t,\n                                         *self);\n                 if nout != len as size_t {\n-                    error!(\"error writing buffer\");\n-                    error!(\"%s\", os::last_os_error());\n-                    fail!();\n+                    error2!(\"error writing buffer: {}\", os::last_os_error());\n+                    fail2!();\n                 }\n             }\n         }\n@@ -1264,22 +1262,21 @@ impl Writer for fd_t {\n                     let vb = ptr::offset(vbuf, count as int) as *c_void;\n                     let nout = libc::write(*self, vb, len as IoSize);\n                     if nout < 0 as IoRet {\n-                        error!(\"error writing buffer\");\n-                        error!(\"%s\", os::last_os_error());\n-                        fail!();\n+                        error2!(\"error writing buffer: {}\", os::last_os_error());\n+                        fail2!();\n                     }\n                     count += nout as uint;\n                 }\n             }\n         }\n     }\n     fn seek(&self, _offset: int, _whence: SeekStyle) {\n-        error!(\"need 64-bit foreign calls for seek, sorry\");\n-        fail!();\n+        error2!(\"need 64-bit foreign calls for seek, sorry\");\n+        fail2!();\n     }\n     fn tell(&self) -> uint {\n-        error!(\"need 64-bit foreign calls for tell, sorry\");\n-        fail!();\n+        error2!(\"need 64-bit foreign calls for tell, sorry\");\n+        fail2!();\n     }\n     fn flush(&self) -> int { 0 }\n     fn get_type(&self) -> WriterType {\n@@ -1347,7 +1344,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n         }\n     };\n     if fd < (0 as c_int) {\n-        Err(fmt!(\"error opening %s: %s\", path.to_str(), os::last_os_error()))\n+        Err(format!(\"error opening {}: {}\", path.to_str(), os::last_os_error()))\n     } else {\n         Ok(fd_writer(fd, true))\n     }\n@@ -1924,17 +1921,17 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         let tmpfile = &Path(\"tmp/lib-io-test-simple.tmp\");\n-        debug!(tmpfile);\n+        debug2!(\"{:?}\", tmpfile);\n         let frood: ~str =\n             ~\"A hoopy frood who really knows where his towel is.\";\n-        debug!(frood.clone());\n+        debug2!(\"{}\", frood.clone());\n         {\n             let out = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n             out.write_str(frood);\n         }\n         let inp = io::file_reader(tmpfile).unwrap();\n         let frood2: ~str = inp.read_c_str();\n-        debug!(frood2.clone());\n+        debug2!(\"{}\", frood2.clone());\n         assert_eq!(frood, frood2);\n     }\n \n@@ -1951,14 +1948,14 @@ mod tests {\n         {\n             let file = io::file_reader(&path).unwrap();\n             do file.each_byte() |_| {\n-                fail!(\"must be empty\")\n+                fail2!(\"must be empty\")\n             };\n         }\n \n         {\n             let file = io::file_reader(&path).unwrap();\n             do file.each_char() |_| {\n-                fail!(\"must be empty\")\n+                fail2!(\"must be empty\")\n             };\n         }\n     }\n@@ -2045,7 +2042,7 @@ mod tests {\n           Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n-          Ok(_) => fail!()\n+          Ok(_) => fail2!()\n         }\n     }\n \n@@ -2085,7 +2082,7 @@ mod tests {\n           Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n-          Ok(_) => fail!()\n+          Ok(_) => fail2!()\n         }\n     }\n \n@@ -2095,7 +2092,7 @@ mod tests {\n           Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n-          Ok(_) => fail!()\n+          Ok(_) => fail2!()\n         }\n     }\n "}, {"sha": "f1e0eff5616c930021444df95ab14ef7bb72eadf", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -723,7 +723,7 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n                 Some(x) => {\n                     i = match i.checked_sub(&1) {\n                         Some(x) => x,\n-                        None => fail!(\"rposition: incorrect ExactSize\")\n+                        None => fail2!(\"rposition: incorrect ExactSize\")\n                     };\n                     if predicate(x) {\n                         return Some(i)\n@@ -2452,7 +2452,7 @@ mod tests {\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x.is_even()));\n         assert!(!v.iter().all(|&x| x > 100));\n-        assert!(v.slice(0, 0).iter().all(|_| fail!()));\n+        assert!(v.slice(0, 0).iter().all(|_| fail2!()));\n     }\n \n     #[test]\n@@ -2461,7 +2461,7 @@ mod tests {\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x.is_even()));\n         assert!(!v.iter().any(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n+        assert!(!v.slice(0, 0).iter().any(|_| fail2!()));\n     }\n \n     #[test]\n@@ -2602,7 +2602,7 @@ mod tests {\n         let mut i = 0;\n         do v.iter().rposition |_elt| {\n             if i == 2 {\n-                fail!()\n+                fail2!()\n             }\n             i += 1;\n             false\n@@ -2746,12 +2746,12 @@ mod tests {\n     fn test_double_ended_range() {\n         assert_eq!(range(11i, 14).invert().collect::<~[int]>(), ~[13i, 12, 11]);\n         for _ in range(10i, 0).invert() {\n-            fail!(\"unreachable\");\n+            fail2!(\"unreachable\");\n         }\n \n         assert_eq!(range(11u, 14).invert().collect::<~[uint]>(), ~[13u, 12, 11]);\n         for _ in range(10u, 0).invert() {\n-            fail!(\"unreachable\");\n+            fail2!(\"unreachable\");\n         }\n     }\n "}, {"sha": "54c77e2d9f64dcaf75ffa21b5c0d154f45fdd098", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -143,8 +143,8 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n         match *entry {\n             Some((k, _, loan)) if k == key_value => {\n                 if loan != NoLoan {\n-                    fail!(\"TLS value cannot be removed because it is currently \\\n-                          borrowed as %s\", loan.describe());\n+                    fail2!(\"TLS value cannot be removed because it is currently \\\n+                          borrowed as {}\", loan.describe());\n                 }\n                 // Move the data out of the `entry` slot via util::replace.\n                 // This is guaranteed to succeed because we already matched\n@@ -240,8 +240,8 @@ fn get_with<T: 'static, U>(key: Key<T>,\n                         }\n                         (ImmLoan, ImmLoan) => {}\n                         (want, cur) => {\n-                            fail!(\"TLS slot cannot be borrowed as %s because \\\n-                                   it is already borrowed as %s\",\n+                            fail2!(\"TLS slot cannot be borrowed as {} because \\\n+                                    it is already borrowed as {}\",\n                                   want.describe(), cur.describe());\n                         }\n                     }\n@@ -304,8 +304,8 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n             match *entry {\n                 Some((ekey, _, loan)) if key == ekey => {\n                     if loan != NoLoan {\n-                        fail!(\"TLS value cannot be overwritten because it is\n-                               already borrowed as %s\", loan.describe())\n+                        fail2!(\"TLS value cannot be overwritten because it is\n+                               already borrowed as {}\", loan.describe())\n                     }\n                     true\n                 }\n@@ -388,15 +388,15 @@ mod tests {\n         static my_key: Key<@~str> = &Key;\n         modify(my_key, |data| {\n             match data {\n-                Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n+                Some(@ref val) => fail2!(\"unwelcome value: {}\", *val),\n                 None           => Some(@~\"first data\")\n             }\n         });\n         modify(my_key, |data| {\n             match data {\n                 Some(@~\"first data\") => Some(@~\"next data\"),\n-                Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n-                None                 => fail!(\"missing value\")\n+                Some(@ref val)       => fail2!(\"wrong value: {}\", *val),\n+                None                 => fail2!(\"missing value\")\n             }\n         });\n         assert!(*(pop(my_key).unwrap()) == ~\"next data\");\n@@ -456,11 +456,11 @@ mod tests {\n             set(str_key, @~\"string data\");\n             set(box_key, @@());\n             set(int_key, @42);\n-            fail!();\n+            fail2!();\n         }\n         // Not quite nondeterministic.\n         set(int_key, @31337);\n-        fail!();\n+        fail2!();\n     }\n \n     #[test]"}, {"sha": "0b1475ff3801420b5526bda14833ce1185b873d4", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -12,16 +12,16 @@\n #[doc(hidden)];\n \n macro_rules! rterrln (\n-    ($( $arg:expr),+) => ( {\n-        ::rt::util::dumb_println(fmt!( $($arg),+ ));\n+    ($($arg:tt)*) => ( {\n+        ::rt::util::dumb_println(format!($($arg)*));\n     } )\n )\n \n // Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n macro_rules! rtdebug (\n-    ($( $arg:expr),+) => ( {\n+    ($($arg:tt)*) => ( {\n         if cfg!(rtdebug) {\n-            rterrln!( $($arg),+ )\n+            rterrln!($($arg)*)\n         }\n     })\n )\n@@ -30,29 +30,30 @@ macro_rules! rtassert (\n     ( $arg:expr ) => ( {\n         if ::rt::util::ENFORCE_SANITY {\n             if !$arg {\n-                rtabort!(\"assertion failed: %s\", stringify!($arg));\n+                rtabort!(\"assertion failed: {}\", stringify!($arg));\n             }\n         }\n     } )\n )\n \n \n macro_rules! rtabort(\n-    ($( $msg:expr),+) => ( {\n-        ::rt::util::abort(fmt!($($msg),+));\n+    ($($msg:tt)*) => ( {\n+        ::rt::util::abort(format!($($msg)*));\n     } )\n )\n \n macro_rules! assert_once_ever(\n-    ($( $msg:expr),+) => ( {\n+    ($($msg:tt)+) => ( {\n         // FIXME(#8472) extra function should not be needed to hide unsafe\n         fn assert_once_ever() {\n             unsafe {\n                 static mut already_happened: int = 0;\n                 // Double-check lock to avoid a swap in the common case.\n                 if already_happened != 0 ||\n                     ::unstable::intrinsics::atomic_xchg_relaxed(&mut already_happened, 1) != 0 {\n-                        fail!(fmt!(\"assert_once_ever happened twice: %s\", fmt!($($msg),+)));\n+                        fail2!(\"assert_once_ever happened twice: {}\",\n+                               format!($($msg)+));\n                 }\n             }\n         }"}, {"sha": "8d76786c6d1ec2ae753dc4935b93941fda4a2312", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -816,8 +816,8 @@ impl num::ToStrRadix for f32 {\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail!(\"number has a special value, \\\n-                          try to_str_radix_special() if those are expected\") }\n+        if special { fail2!(\"number has a special value, \\\n+                             try to_str_radix_special() if those are expected\") }\n         r\n     }\n }"}, {"sha": "6cd0ba63828122871f1c44f6e18bc478f8b166e7", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -864,8 +864,8 @@ impl num::ToStrRadix for f64 {\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail!(\"number has a special value, \\\n-                          try to_str_radix_special() if those are expected\") }\n+        if special { fail2!(\"number has a special value, \\\n+                             try to_str_radix_special() if those are expected\") }\n         r\n     }\n }"}, {"sha": "4f676545d4f068c98cca83f08eb5cd62c4139339", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -181,7 +181,7 @@ impl num::ToStrRadix for float {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, radix, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail!(\"number has a special value, \\\n+        if special { fail2!(\"number has a special value, \\\n                              try to_str_radix_special() if those are expected\") }\n         r\n     }\n@@ -1329,16 +1329,16 @@ mod tests {\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str::<float>(\"NaN\") {\n             Some(f) => assert!(f.is_nan()),\n-            None => fail!()\n+            None => fail2!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str::<float>(\"-0\") {\n             Some(v) if v.is_zero() => assert!(v.is_negative()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n         match from_str::<float>(\"0\") {\n             Some(v) if v.is_zero() => assert!(v.is_positive()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n \n         assert!(from_str::<float>(\"\").is_none());\n@@ -1376,16 +1376,16 @@ mod tests {\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str_hex(\"NaN\") {\n             Some(f) => assert!(f.is_nan()),\n-            None => fail!()\n+            None => fail2!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str_hex(\"-0\") {\n             Some(v) if v.is_zero() => assert!(v.is_negative()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n         match from_str_hex(\"0\") {\n             Some(v) if v.is_zero() => assert!(v.is_positive()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n         assert_eq!(from_str_hex(\"e\"), Some(14.));\n         assert_eq!(from_str_hex(\"E\"), Some(14.));"}, {"sha": "19e6a2dd0ef6b92d3059496e1393109ec25a99a4", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -474,19 +474,19 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n         ) -> Option<T> {\n     match exponent {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail!(\"from_str_bytes_common: radix %? incompatible with \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n         ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail!(\"from_str_bytes_common: radix %? incompatible with \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     use of 'p' as binary exponent\", radix),\n         _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => fail!(\"from_str_bytes_common: radix %? incompatible with \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     special values 'inf' and 'NaN'\", radix),\n         _ if (radix as int) < 2\n-          => fail!(\"from_str_bytes_common: radix %? to low, \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} to low, \\\n                     must lie in the range [2, 36]\", radix),\n         _ if (radix as int) > 36\n-          => fail!(\"from_str_bytes_common: radix %? to high, \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} to high, \\\n                     must lie in the range [2, 36]\", radix),\n         _ => ()\n     }"}, {"sha": "033515875ddc6ebc87570f978ea844ac0d626c20", "filename": "src/libstd/option.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99", "patch": "@@ -278,7 +278,7 @@ impl<T> Option<T> {\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Some(ref x) => x,\n-            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n+            None => fail2!(\"called `Option::get_ref()` on a `None` value\"),\n         }\n     }\n \n@@ -298,7 +298,7 @@ impl<T> Option<T> {\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n             Some(ref mut x) => x,\n-            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n+            None => fail2!(\"called `Option::get_mut_ref()` on a `None` value\"),\n         }\n     }\n \n@@ -320,7 +320,7 @@ impl<T> Option<T> {\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(x) => x,\n-            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n+            None => fail2!(\"called `Option::unwrap()` on a `None` value\"),\n         }\n     }\n \n@@ -333,7 +333,7 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn take_unwrap(&mut self) -> T {\n         if self.is_none() {\n-            fail!(\"called `Option::take_unwrap()` on a `None` value\")\n+            fail2!(\"called `Option::take_unwrap()` on a `None` value\")\n         }\n         self.take().unwrap()\n     }\n@@ -348,7 +348,7 @@ impl<T> Option<T> {\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n             Some(val) => val,\n-            None => fail!(reason.to_owned()),\n+            None => fail2!(\"{}\", reason.to_owned()),\n         }\n     }\n \n@@ -722,21 +722,23 @@ mod tests {\n         let new_val = 11;\n \n         let mut x = Some(val);\n-        let mut it = x.mut_iter();\n+        {\n+            let mut it = x.mut_iter();\n \n-        assert_eq!(it.size_hint(), (1, Some(1)));\n+            assert_eq!(it.size_hint(), (1, Some(1)));\n \n-        match it.next() {\n-            Some(interior) => {\n-                assert_eq!(*interior, val);\n-                *interior = new_val;\n-                assert_eq!(x, Some(new_val));\n+            match it.next() {\n+                Some(interior) => {\n+                    assert_eq!(*interior, val);\n+                    *interior = new_val;\n+                }\n+                None => assert!(false),\n             }\n-            None => assert!(false),\n-        }\n \n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert!(it.next().is_none());\n+        }\n+        assert_eq!(x, Some(new_val));\n     }\n \n     #[test]"}, {"sha": "7b9bb249a3cc4ecf69c2062cbd364c84e41b637c", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "0d4bcb4ec47f998a8a6c6bf499884730c5e7b7ea", "filename": "src/libstd/path.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "c27665d76985acacde8b3995ae3b4532c0912452", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "cc0e843b8965083c304ae13f58fc84115782efdd", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "e9d1accbd4795cdeb64e3af73f278e8012e5dc5b", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "34efe1cfbf14b04a71e41535912601e17d787254", "filename": "src/libstd/result.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "100ea3e05461fdec61a9a0d4bb6dba16b0f6abf4", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "d703272420cbb4423baaa6b15dcd306b3ec0bdef", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "7d61b556bb595eaf02e6c48443832ba29883da2e", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "853cc08a0ba773d3d511709f1b894b79b4be3c1f", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "2844cc81892dd0b633a00b0b3846e613361663f4", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "495d1f97cd2bafd71f51f0e6e5e8e4c364524ad5", "filename": "src/libstd/rt/io/comm_adapters.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "69f0423bf5d37aa038c1f78535318413623a246e", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "a18eec8773ebd8d6e75c5e3334591f5e6c75ec7b", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "72029d07263e316a87d030f0614568a9c5fea0f3", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "1f396a4476e1e61f7484c017b20601ab9d40a1b9", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "c2f137ba119ab14a18470b08ee5dfed74e513bb0", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f5f77f4e853f9421e49461b1b254c2e8a4ac6608", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "6a6619cc548208214b177271ed64c4da728517c8", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "c1cda5ad681160c4850e6bf6aa6b02d4cf687ac0", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "e47b9b9e925cb2736771a518190b49f5134102ef", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "07de33935ee2a6a9b7581dba8450fb3051fe2805", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "4186cce8c8d001d8a76077eabb540f64f26b9d00", "filename": "src/libstd/rt/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "734a40429a62f70b03fa29c59edbbbfec3ddbdad", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "19b33feacbd868028419bd5613e54ff67fd7d52a", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "09f99b9302eeb23b570599fa2425f90287e3d95e", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "51eb2505f550c3e8348ed1295adb4baa5ad9f8d7", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "bddcb700433c744482567bca9ceb7af79a44c922", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "0068d1030738e15d86a0ef750705d762234b24b9", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "b6611eee9e62dacf2058ba86bbdcf173f8733687", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "68996a3a2a50db196b0099ce4d92490f8f8b4366", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "dc5b512e56ea65cf3b00559003b2aa29438f3228", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "0c5351ea9e46d6367f1ce9c1fb1f3028ce496020", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ca42fd32f096b15dd91c1b978761060fe9fb9688", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ddaf0c2872519de7be5a47af6ac92b7b3bbb5683", "filename": "src/libstd/rt/uv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f9b71db70434794202d31d8a98ec874b6409870f", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "074c232e14915f21c14b1ad0fe364edcc87364c5", "filename": "src/libstd/run.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "2554a0ad58823ae6d9d4ab23b2ab4989f8dc5efb", "filename": "src/libstd/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "6c9992b81391acfffff0d976eade6ffce2269185", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "25425e07577d0bd3311416896594b50733ef07e5", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "200e2de0271cde96475729e663b4d5fd092fdb4e", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "a77c9744298025f5cc1f92857a4cef68252dab7e", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "554b9a851004835dba303540008bf3b68546e579", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "c1b0cd500d6a1a77a128d9c11e978fd9b0cb414a", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "0045aef06f106b4d797039ded7a108f891038471", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "b224c22df20a63aee7d085081b21ae9728731b89", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "9fe3435c21ba1510ff2cbcead90222814639d638", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "fca477763c5e6f5751d74369ff5d89b1bd8f78ec", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "066c2173b5af2334753949e0b190d5c79c557545", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "aa927d0f0a03b2c1138c1d2b4c9d607fd2df0046", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "4875ef6d3caa55c95dc3950a4f3cfcc392071895", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f2d7ebdd5993fe7598562c635a24ae43e1442a21", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "105d222926e2326e42bbb8ead618ef11ae62ad45", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f93fc1e81da23065d13b8d1e1bba79b9e748d20d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "31905f6ccc7aa9e957d9eec4a44be42cb8d58a25", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "de8f45c880d2acd160c3112b4d11780215d1ae8c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "03b47f89ab6cdca5cb37544e215aa12ca5a9b31b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "9241e8c4fbcb1a5df6e9e19650a1b6c220be4439", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "3b4be1de3e81b34c69967cc565ea9318e2741f34", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "5b107a49175ad003d49241c842ef22b937865ee7", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "91fe71c54145e5c4eda539c34d46d833482c78e9", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "d1c436c045d2b4cb66c71154c94e0da13a17c197", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f5e45eec7e0365924baab62ee01a38cccd397011", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "a428c6704f9642077be8b6d16e63a74b6d100103", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "63a45b06e164472c565bc8e7343c89fee44ed426", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "e8307bf578698844837a4de950df4e2b5076e4df", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 103, "deletions": 89, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "cd364e7ad64a75e7e71ba834f5fd6e8e866ee991", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "a9e5318db404245eb7d85611aa65077a32c6eefc", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "24a5f9d5e3c8775b6ebeecd758af7295b8c21200", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "7db64feb809854e92fec357eb9f83e50011f6ce4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f8d48d00db9185d1fa7e3b06fbf1d38b984867d3", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "909f5e5c4434aabc2caa34dad58c4e2740853c9b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ca93cbaea39e07923f7dcf03d4d348418a3ad672", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "dba2f0b94171745070da5fa06446a752359b427e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f163bec7d4eef3403dc352bce05ea5d516fef99a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "640c7c220e5e294b090c043c70f5b7586e385aa8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "67bcab319562ee960e742bd891110cbea9dd6474", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "adf0c208da4df078acce458559d33c938a2e0a7d", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "4dd09cbcbd2f9aa33fc9771b4706807bb980b3bf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 58, "deletions": 59, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "d0faf917688d7ad9188aed11488429c27d2652ba", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "58d73ad687c49cc59196e40c7f1cfe6f88b60271", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "bc1a47212074271e7211f46a70afff8c8a23b912", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "78f9d62087baf0c48434b817360db8dca1bca31b", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "906928d1b79203edf7c985e4aaafefa0329a4173", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "626947306c7297aace6a2c5446620a198045771a", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ecc094a612103db250d2cb0f8a1825b1800d04c7", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "20b3a3280ec8293ebbcc606e960aa99151ccf082", "filename": "src/test/auxiliary/issue2378a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "384f69c736cf0b2309962bf2f6782009d7f2fce0", "filename": "src/test/auxiliary/issue_2723_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ef173d52bc4fe55ff694876d2d30304f7d7bbe39", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "a4c07371f678012607dbb23feced724ed7b7b786", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "fa2b74ef44c63134fdb8fb37b1cc3d2e6966d14a", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ef6610cd93a3f3d4738cabac1946adc3767650ba", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ba7682f5bbd4d3c5dde7227e512203c1ef20a064", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "1db73f9a95d12e4239f88aa2acc6a157d33c6711", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "c3296cbff9be132757617117d85bb02787d6e454", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "4c246bbe3f70695ccb02635d214cebfe2ac37098", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "5a1f735001028d2c1c9f061055ab5acff4917941", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "2e812ba2d09587ad96ca7bec43f75180c0133848", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "91d9c9656af96663554aa1362c978b4a02d20890", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "639cbd05cbf7a3b7aa0d8dc72dd0202660a541ae", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ac028686f08e18cb42a2ea507324bbcf0d3c02bc", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "b029d9e4fc84472ab9b50573f16771a22ec5ecda", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "f60b67cf8420f037d4eb94b7de4f875a6729eb72", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "32f27f64f54d596a57d56b3a7317ef70a05e90ca", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "ae911b54107908ad8db90dfc314858ff6e805586", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "a9e9ed64d9a37375f3b46ab04feb266eda4dfdd1", "filename": "src/test/compile-fail/bad-bang-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "095a85ab21e96c05c1056b67abf6627d044e4c63", "filename": "src/test/compile-fail/bad-const-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "262248f9dc3b795691610c6a5dd79407d152f5ad", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "bf665e6fb60b28eb43422e9435d4a4a66ba50a82", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "fcb9dbb300c82e3aca02689fcd55ec18c7937cd0", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "19076181c512293253c49a5bb02fae3d83bf0bfb", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "5c0274b03d09a76ad806977c6ec0225b4bdf5328", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}, {"sha": "9b7cc41e5c875729b7028f4febd5632c247b1e48", "filename": "src/test/compile-fail/bind-by-move-no-sub-bindings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb48cc1e607a7189c80c1d0f3f5567312bf1a99/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs?ref=8bb48cc1e607a7189c80c1d0f3f5567312bf1a99"}]}