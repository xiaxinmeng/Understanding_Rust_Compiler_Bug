{"sha": "86369c3ad44a59cad44514c4b466ee3877a4b2a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MzY5YzNhZDQ0YTU5Y2FkNDQ1MTRjNGI0NjZlZTM4NzdhNGIyYTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-10T07:01:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-01T22:29:12Z"}, "message": "slice iterators: ZST iterators no longer just \"make up\" addresses", "tree": {"sha": "5ee3a368fa5321e85bc0f77fe53bbaa00f1f7f25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ee3a368fa5321e85bc0f77fe53bbaa00f1f7f25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86369c3ad44a59cad44514c4b466ee3877a4b2a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86369c3ad44a59cad44514c4b466ee3877a4b2a5", "html_url": "https://github.com/rust-lang/rust/commit/86369c3ad44a59cad44514c4b466ee3877a4b2a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86369c3ad44a59cad44514c4b466ee3877a4b2a5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "html_url": "https://github.com/rust-lang/rust/commit/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796"}], "stats": {"total": 439, "additions": 228, "deletions": 211}, "files": [{"sha": "10ca4a3ce465da6851427bb0592fad8a027d4135", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 128, "deletions": 211, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/86369c3ad44a59cad44514c4b466ee3877a4b2a5/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86369c3ad44a59cad44514c4b466ee3877a4b2a5/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=86369c3ad44a59cad44514c4b466ee3877a4b2a5", "patch": "@@ -75,44 +75,6 @@ struct FatPtr<T> {\n // Extension traits\n //\n \n-// Use macros to be generic over const/mut\n-macro_rules! slice_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            (ptr as *mut i8).wrapping_offset($by) as _\n-        } else {\n-            ptr.offset($by)\n-        }\n-    }};\n-}\n-\n-// make a &T from a *const T\n-macro_rules! make_ref {\n-    ($ptr:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            // Use a non-null pointer value\n-            &*(1 as *mut _)\n-        } else {\n-            &*ptr\n-        }\n-    }};\n-}\n-\n-// make a &mut T from a *mut T\n-macro_rules! make_ref_mut {\n-    ($ptr:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            // Use a non-null pointer value\n-            &mut *(1 as *mut _)\n-        } else {\n-            &mut *ptr\n-        }\n-    }};\n-}\n-\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n@@ -580,17 +542,18 @@ impl<T> [T] {\n     #[inline]\n     pub fn iter(&self) -> Iter<T> {\n         unsafe {\n-            let p = if mem::size_of::<T>() == 0 {\n-                1 as *const _\n+            let ptr = self.as_ptr();\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as usize).wrapping_add(self.len()) as *const _\n             } else {\n-                let p = self.as_ptr();\n-                assume(!p.is_null());\n-                p\n+                ptr.offset(self.len() as isize)\n             };\n \n             Iter {\n-                ptr: p,\n-                end: slice_offset!(p, self.len() as isize),\n+                ptr,\n+                end,\n                 _marker: marker::PhantomData\n             }\n         }\n@@ -611,17 +574,18 @@ impl<T> [T] {\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         unsafe {\n-            let p = if mem::size_of::<T>() == 0 {\n-                1 as *mut _\n+            let ptr = self.as_mut_ptr();\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as usize).wrapping_add(self.len()) as *mut _\n             } else {\n-                let p = self.as_mut_ptr();\n-                assume(!p.is_null());\n-                p\n+                ptr.offset(self.len() as isize)\n             };\n \n             IterMut {\n-                ptr: p,\n-                end: slice_offset!(p, self.len() as isize),\n+                ptr,\n+                end,\n                 _marker: marker::PhantomData\n             }\n         }\n@@ -2373,14 +2337,66 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n-#[inline]\n-fn size_from_ptr<T>(_: *const T) -> usize {\n-    mem::size_of::<T>()\n-}\n-\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty, $mkref:ident) => {\n+    (struct $name:ident -> $ptr:ty, $elem:ty, $raw_mut:tt, $( $mut_:tt )*) => {\n+        impl<'a, T> $name<'a, T> {\n+            // Helper function for creating a slice from the iterator.\n+            #[inline(always)]\n+            fn make_slice(&self) -> &'a [T] {\n+                unsafe { from_raw_parts(self.ptr, self.len()) }\n+            }\n+\n+            // Helper function for moving the start of the iterator forwards by `offset` elements,\n+            // returning the old start.\n+            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            #[inline(always)]\n+            unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n+                if mem::size_of::<T>() == 0 {\n+                    self.end = (self.end as isize).wrapping_sub(offset) as * $raw_mut T;\n+                    self.ptr\n+                } else {\n+                    let old = self.ptr;\n+                    self.ptr = self.ptr.offset(offset);\n+                    old\n+                }\n+            }\n+\n+            // Helper function for moving the end of the iterator backwards by `offset` elements,\n+            // returning the new end.\n+            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            #[inline(always)]\n+            unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n+                if mem::size_of::<T>() == 0 {\n+                    self.end = (self.end as isize).wrapping_sub(offset) as * $raw_mut T;\n+                    self.ptr\n+                } else {\n+                    self.end = self.end.offset(-offset);\n+                    self.end\n+                }\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, T> ExactSizeIterator for $name<'a, T> {\n+            #[inline(always)]\n+            fn len(&self) -> usize {\n+                if mem::size_of::<T>() == 0 {\n+                    // end is really ptr+len\n+                    (self.end as usize).wrapping_sub(self.ptr as usize)\n+                } else {\n+                    unsafe { self.end.offset_from(self.ptr) as usize }\n+                }\n+            }\n+\n+            #[inline(always)]\n+            fn is_empty(&self) -> bool {\n+                // The way we encode the length of a ZST iterator, this works both for ZST\n+                // and non-ZST.\n+                self.ptr == self.end\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n@@ -2389,21 +2405,21 @@ macro_rules! iterator {\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    assume(!self.ptr.is_null());\n                     if mem::size_of::<T>() != 0 {\n-                        assume(!self.ptr.is_null());\n                         assume(!self.end.is_null());\n                     }\n-                    if self.ptr == self.end {\n+                    if self.is_empty() {\n                         None\n                     } else {\n-                        Some($mkref!(self.ptr.post_inc()))\n+                        Some(& $( $mut_ )* *self.post_inc_start(1))\n                     }\n                 }\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let exact = unsafe { ptrdistance(self.ptr, self.end) };\n+                let exact = self.len();\n                 (exact, Some(exact))\n             }\n \n@@ -2414,8 +2430,21 @@ macro_rules! iterator {\n \n             #[inline]\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n-                // Call helper method. Can't put the definition here because mut versus const.\n-                self.iter_nth(n)\n+                if n >= self.len() {\n+                    // This iterator is now empty.  The way we encode the length of a non-ZST\n+                    // iterator, this works for both ZST and non-ZST.\n+                    // For a ZST we would usually do `self.end = self.ptr`, but since\n+                    // we will not give out an address any more after this there is no\n+                    // way to observe the difference.\n+                    self.ptr = self.end;\n+                    return None;\n+                }\n+                // We are in bounds. `offset` does the right thing even for ZSTs.\n+                unsafe {\n+                    let elem = Some(& $( $mut_ )* *self.ptr.offset(n as isize));\n+                    self.post_inc_start((n as isize).wrapping_add(1));\n+                    elem\n+                }\n             }\n \n             #[inline]\n@@ -2430,14 +2459,14 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while ptrdistance(self.ptr, self.end) >= 4 {\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                    while self.len() >= 4 {\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                     }\n-                    while self.ptr != self.end {\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                    while !self.is_empty() {\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -2464,7 +2493,7 @@ macro_rules! iterator {\n             {\n                 // The addition might panic on overflow\n                 // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let n = make_slice!(self.ptr, self.end).len();\n+                let n = self.make_slice().len();\n                 self.try_fold(0, move |i, x| {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i + 1) }\n@@ -2483,7 +2512,7 @@ macro_rules! iterator {\n                 // No need for an overflow check here, because `ExactSizeIterator`\n                 // implies that the number of elements fits into a `usize`.\n                 // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let n = make_slice!(self.ptr, self.end).len();\n+                let n = self.make_slice().len();\n                 self.try_rfold(n, move |i, x| {\n                     let i = i - 1;\n                     if predicate(x) { Err(i) }\n@@ -2502,14 +2531,14 @@ macro_rules! iterator {\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    assume(!self.ptr.is_null());\n                     if mem::size_of::<T>() != 0 {\n-                        assume(!self.ptr.is_null());\n                         assume(!self.end.is_null());\n                     }\n-                    if self.end == self.ptr {\n+                    if self.is_empty() {\n                         None\n                     } else {\n-                        Some($mkref!(self.end.pre_dec()))\n+                        Some(& $( $mut_ )* *self.pre_dec_end(1))\n                     }\n                 }\n             }\n@@ -2521,14 +2550,14 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while ptrdistance(self.ptr, self.end) >= 4 {\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                    while self.len() >= 4 {\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                     }\n-                    while self.ptr != self.end {\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                    while !self.is_empty() {\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -2556,34 +2585,6 @@ macro_rules! iterator {\n     }\n }\n \n-macro_rules! make_slice {\n-    ($start: expr, $end: expr) => {{\n-        let start = $start;\n-        let diff = ($end as usize).wrapping_sub(start as usize);\n-        if size_from_ptr(start) == 0 {\n-            // use a non-null pointer value\n-            unsafe { from_raw_parts(1 as *const _, diff) }\n-        } else {\n-            let len = diff / size_from_ptr(start);\n-            unsafe { from_raw_parts(start, len) }\n-        }\n-    }}\n-}\n-\n-macro_rules! make_mut_slice {\n-    ($start: expr, $end: expr) => {{\n-        let start = $start;\n-        let diff = ($end as usize).wrapping_sub(start as usize);\n-        if size_from_ptr(start) == 0 {\n-            // use a non-null pointer value\n-            unsafe { from_raw_parts_mut(1 as *mut _, diff) }\n-        } else {\n-            let len = diff / size_from_ptr(start);\n-            unsafe { from_raw_parts_mut(start, len) }\n-        }\n-    }}\n-}\n-\n /// Immutable slice iterator\n ///\n /// This struct is created by the [`iter`] method on [slices].\n@@ -2607,7 +2608,9 @@ macro_rules! make_mut_slice {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n-    end: *const T,\n+    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+                   // ptr == end is a quick test for the Iterator being empty, that works\n+                   // for both ZST and non-ZST.\n     _marker: marker::PhantomData<&'a T>,\n }\n \n@@ -2652,32 +2655,11 @@ impl<'a, T> Iter<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn as_slice(&self) -> &'a [T] {\n-        make_slice!(self.ptr, self.end)\n-    }\n-\n-    // Helper function for Iter::nth\n-    fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n-        match self.as_slice().get(n) {\n-            Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n-                Some(elem_ref)\n-            },\n-            None => {\n-                self.ptr = self.end;\n-                None\n-            }\n-        }\n+        self.make_slice()\n     }\n }\n \n-iterator!{struct Iter -> *const T, &'a T, make_ref}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n-    fn is_empty(&self) -> bool {\n-        self.ptr == self.end\n-    }\n-}\n+iterator!{struct Iter -> *const T, &'a T, const, /* no mut */}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n@@ -2718,15 +2700,17 @@ impl<'a, T> AsRef<[T]> for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n-    end: *mut T,\n+    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+                 // ptr == end is a quick test for the Iterator being empty, that works\n+                 // for both ZST and non-ZST.\n     _marker: marker::PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"IterMut\")\n-            .field(&make_slice!(self.ptr, self.end))\n+            .field(&self.make_slice())\n             .finish()\n     }\n }\n@@ -2772,77 +2756,11 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        make_mut_slice!(self.ptr, self.end)\n-    }\n-\n-    // Helper function for IterMut::nth\n-    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n-        match make_mut_slice!(self.ptr, self.end).get_mut(n) {\n-            Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n-                Some(elem_ref)\n-            },\n-            None => {\n-                self.ptr = self.end;\n-                None\n-            }\n-        }\n+        unsafe { from_raw_parts_mut(self.ptr, self.len()) }\n     }\n }\n \n-iterator!{struct IterMut -> *mut T, &'a mut T, make_ref_mut}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n-    fn is_empty(&self) -> bool {\n-        self.ptr == self.end\n-    }\n-}\n-\n-// Return the number of elements of `T` from `start` to `end`.\n-// Return the arithmetic difference if `T` is zero size.\n-#[inline(always)]\n-unsafe fn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n-    if mem::size_of::<T>() == 0 {\n-        (end as usize).wrapping_sub(start as usize)\n-    } else {\n-        end.offset_from(start) as usize\n-    }\n-}\n-\n-// Extension methods for raw pointers, used by the iterators\n-trait PointerExt : Copy {\n-    unsafe fn slice_offset(self, i: isize) -> Self;\n-\n-    /// Increments `self` by 1, but returns the old value.\n-    #[inline(always)]\n-    unsafe fn post_inc(&mut self) -> Self {\n-        let current = *self;\n-        *self = self.slice_offset(1);\n-        current\n-    }\n-\n-    /// Decrements `self` by 1, and returns the new value.\n-    #[inline(always)]\n-    unsafe fn pre_dec(&mut self) -> Self {\n-        *self = self.slice_offset(-1);\n-        *self\n-    }\n-}\n-\n-impl<T> PointerExt for *const T {\n-    #[inline(always)]\n-    unsafe fn slice_offset(self, i: isize) -> Self {\n-        slice_offset!(self, i)\n-    }\n-}\n-\n-impl<T> PointerExt for *mut T {\n-    #[inline(always)]\n-    unsafe fn slice_offset(self, i: isize) -> Self {\n-        slice_offset!(self, i)\n-    }\n-}\n+iterator!{struct IterMut -> *mut T, &'a mut T, mut, mut}\n \n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once.\n@@ -3927,12 +3845,11 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n /// ```\n /// use std::slice;\n ///\n-/// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const usize;\n-/// let amt = 10;\n-/// unsafe {\n-///     let slice = slice::from_raw_parts(ptr, amt);\n-/// }\n+/// // manifest a slice for a single element\n+/// let x = 42;\n+/// let ptr = &x as *const _;\n+/// let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n+/// assert_eq!(slice[0], 42);\n /// ```\n ///\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling"}, {"sha": "e4230b08497060d2fd3d1356c34879fcb865c1c7", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/86369c3ad44a59cad44514c4b466ee3877a4b2a5/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86369c3ad44a59cad44514c4b466ee3877a4b2a5/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=86369c3ad44a59cad44514c4b466ee3877a4b2a5", "patch": "@@ -390,6 +390,106 @@ fn test_windows_zip() {\n     assert_eq!(res, [14, 18, 22, 26]);\n }\n \n+#[test]\n+#[allow(const_err)]\n+fn test_iter_ref_consistency() {\n+    use std::fmt::Debug;\n+\n+    fn helper<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &[T] = &[x, x, x];\n+        let v_ptrs : [*const T; 3] = match v {\n+            [ref v1, ref v2, ref v3] => [v1 as *const _, v2 as *const _, v3 as *const _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        for i in 0..len {\n+            assert_eq!(&v[i] as *const _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter().nth(i).unwrap();\n+            assert_eq!(nth as *const _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len{\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len{\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *const _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    fn helper_mut<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &mut [T] = &mut [x, x, x];\n+        let v_ptrs : [*mut T; 3] = match v {\n+            [ref v1, ref v2, ref v3] =>\n+              [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        for i in 0..len {\n+            assert_eq!(&mut v[i] as *mut _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter_mut().nth(i).unwrap();\n+            assert_eq!(nth as *mut _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *mut _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len{\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *mut _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    // Make sure iterators and slice patterns yield consistent addresses for various types,\n+    // including ZSTs.\n+    helper(0u32);\n+    helper(());\n+    helper([0u32; 0]); // ZST with alignment > 0\n+    helper_mut(0u32);\n+    helper_mut(());\n+    helper_mut([0u32; 0]); // ZST with alignment > 0\n+}\n+\n // The current implementation of SliceIndex fails to handle methods\n // orthogonally from range types; therefore, it is worth testing\n // all of the indexing operations on each input."}]}