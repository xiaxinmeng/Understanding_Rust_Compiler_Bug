{"sha": "5403e826818a3c669f476909b24b4470e6e3749c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MDNlODI2ODE4YTNjNjY5ZjQ3NjkwOWIyNGI0NDcwZTZlMzc0OWM=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T17:32:21Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-22T12:34:39Z"}, "message": "matches: new module, move single_match lint there", "tree": {"sha": "31a373b2e74c50f1817f77c5ce3d68ce540b7351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31a373b2e74c50f1817f77c5ce3d68ce540b7351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5403e826818a3c669f476909b24b4470e6e3749c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5403e826818a3c669f476909b24b4470e6e3749c", "html_url": "https://github.com/rust-lang/rust/commit/5403e826818a3c669f476909b24b4470e6e3749c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5403e826818a3c669f476909b24b4470e6e3749c/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "371584a637d2065fd45b25249bb2b406d2aee7a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/371584a637d2065fd45b25249bb2b406d2aee7a8", "html_url": "https://github.com/rust-lang/rust/commit/371584a637d2065fd45b25249bb2b406d2aee7a8"}], "stats": {"total": 129, "additions": 65, "deletions": 64}, "files": [{"sha": "fbeebb210fe725caa78e12af8766c5c90a46003f", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5403e826818a3c669f476909b24b4470e6e3749c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5403e826818a3c669f476909b24b4470e6e3749c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5403e826818a3c669f476909b24b4470e6e3749c", "patch": "@@ -38,11 +38,11 @@ pub mod returns;\n pub mod lifetimes;\n pub mod loops;\n pub mod ranges;\n+pub mod matches;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box types::TypePass as LintPassObject);\n-    reg.register_lint_pass(box misc::MiscPass as LintPassObject);\n     reg.register_lint_pass(box misc::TopLevelRefPass as LintPassObject);\n     reg.register_lint_pass(box misc::CmpNan as LintPassObject);\n     reg.register_lint_pass(box eq_op::EqOp as LintPassObject);\n@@ -71,6 +71,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box ranges::StepByZero as LintPassObject);\n     reg.register_lint_pass(box types::CastPass as LintPassObject);\n     reg.register_lint_pass(box types::TypeComplexityPass as LintPassObject);\n+    reg.register_lint_pass(box matches::MatchPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n@@ -87,6 +88,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,\n+        matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::STR_TO_STRING,\n@@ -96,7 +98,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::FLOAT_CMP,\n         misc::MODULO_ONE,\n         misc::PRECEDENCE,\n-        misc::SINGLE_MATCH,\n         misc::TOPLEVEL_REF_ARG,\n         mut_mut::MUT_MUT,\n         needless_bool::NEEDLESS_BOOL,"}, {"sha": "b9f6cbc43268c29b39835a256999d2c388809e77", "filename": "src/matches.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5403e826818a3c669f476909b24b4470e6e3749c/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5403e826818a3c669f476909b24b4470e6e3749c/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=5403e826818a3c669f476909b24b4470e6e3749c", "patch": "@@ -0,0 +1,61 @@\n+use rustc::lint::*;\n+use syntax::ast;\n+use syntax::ast::*;\n+use std::borrow::Cow;\n+\n+use utils::{snippet, snippet_block, span_help_and_lint};\n+\n+declare_lint!(pub SINGLE_MATCH, Warn,\n+              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n+               is `_ => {}`) is used; recommends `if let` instead\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct MatchPass;\n+\n+impl LintPass for MatchPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(SINGLE_MATCH)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n+            // check preconditions: only two arms\n+            if arms.len() == 2 &&\n+                // both of the arms have a single pattern and no guard\n+                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n+                // since the exhaustiveness check will ensure the last one is a catch-all,\n+                // but in some cases, an explicit match is preferred to catch situations\n+                // when an enum is extended, so we don't consider these cases\n+                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n+                // finally, we don't want any content in the second arm (unit or empty block)\n+                is_unit_expr(&*arms[1].body)\n+            {\n+                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n+                let body_code = if let ExprBlock(_) = arms[0].body.node {\n+                    body_code\n+                } else {\n+                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n+                };\n+                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                      \"you seem to be trying to use match for \\\n+                      destructuring a single pattern. Did you mean to \\\n+                      use `if let`?\",\n+                      &*format!(\"try\\nif let {} = {} {}\",\n+                                snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                snippet(cx, ex.span, \"..\"),\n+                                body_code)\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_unit_expr(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprTup(ref v) if v.is_empty() => true,\n+        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "49324de8de91c781f46ad7cda29c4cf23cf0ac37", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5403e826818a3c669f476909b24b4470e6e3749c/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5403e826818a3c669f476909b24b4470e6e3749c/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=5403e826818a3c669f476909b24b4470e6e3749c", "patch": "@@ -1,75 +1,14 @@\n use rustc::lint::*;\n use syntax::ptr::P;\n-use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n use rustc::middle::ty;\n-use std::borrow::Cow;\n \n-use utils::{match_path, snippet, snippet_block, span_lint, span_help_and_lint, walk_ptrs_ty};\n+use utils::{match_path, snippet, span_lint, walk_ptrs_ty};\n use consts::constant;\n \n-/// Handles uncategorized lints\n-/// Currently handles linting of if-let-able matches\n-#[allow(missing_copy_implementations)]\n-pub struct MiscPass;\n-\n-\n-declare_lint!(pub SINGLE_MATCH, Warn,\n-              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n-               is `_ => {}`) is used; recommends `if let` instead\");\n-\n-impl LintPass for MiscPass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n-            // check preconditions: only two arms\n-            if arms.len() == 2 &&\n-                // both of the arms have a single pattern and no guard\n-                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n-                // since the exhaustiveness check will ensure the last one is a catch-all,\n-                // but in some cases, an explicit match is preferred to catch situations\n-                // when an enum is extended, so we don't consider these cases\n-                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n-                // finally, we don't want any content in the second arm (unit or empty block)\n-                is_unit_expr(&*arms[1].body)\n-            {\n-                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n-                let body_code = if let ExprBlock(_) = arms[0].body.node {\n-                    body_code\n-                } else {\n-                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n-                };\n-                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                      \"you seem to be trying to use match for \\\n-                      destructuring a single pattern. Did you mean to \\\n-                      use `if let`?\",\n-                      &*format!(\"try\\nif let {} = {} {}\",\n-                                snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                snippet(cx, ex.span, \"..\"),\n-                                body_code)\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_unit_expr(expr: &Expr) -> bool {\n-    match expr.node {\n-        ExprTup(ref v) if v.is_empty() => true,\n-        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n-        _ => false,\n-    }\n-}\n-\n-\n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n               \"a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not \\\n                `fn foo((ref x, ref y): (u8, u8))`)\");"}]}