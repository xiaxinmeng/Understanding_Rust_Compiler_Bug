{"sha": "2855bf039a574865c13c67a43cefbf8cead49c1b", "node_id": "C_kwDOAAsO6NoAKDI4NTViZjAzOWE1NzQ4NjVjMTNjNjdhNDNjZWZiZjhjZWFkNDljMWI", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-06-01T21:02:09Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-10-07T02:44:50Z"}, "message": "Factor scraping and rendering into separate calls to rustdoc\n\nSimplify toggle UI logic, add workspace root for URLs", "tree": {"sha": "0806531ed66c12fff6ed2d5654a0a15cb9a9d376", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0806531ed66c12fff6ed2d5654a0a15cb9a9d376"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2855bf039a574865c13c67a43cefbf8cead49c1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2855bf039a574865c13c67a43cefbf8cead49c1b", "html_url": "https://github.com/rust-lang/rust/commit/2855bf039a574865c13c67a43cefbf8cead49c1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2855bf039a574865c13c67a43cefbf8cead49c1b/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7831fee9f8c4409c80380c6ebed52ae267971438", "url": "https://api.github.com/repos/rust-lang/rust/commits/7831fee9f8c4409c80380c6ebed52ae267971438", "html_url": "https://github.com/rust-lang/rust/commit/7831fee9f8c4409c80380c6ebed52ae267971438"}], "stats": {"total": 301, "additions": 143, "deletions": 158}, "files": [{"sha": "ab5b6000a185949cf36df23a5e4da91c4d4c11c7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -42,7 +42,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n-use crate::scrape_examples::FnCallLocations;\n+use crate::scrape_examples::{self, FnCallLocations};\n \n use self::FnRetTy::*;\n use self::ItemKind::*;\n@@ -1261,9 +1261,9 @@ crate struct Function {\n impl Function {\n     crate fn load_call_locations(&mut self, def_id: hir::def_id::DefId, cx: &DocContext<'_>) {\n         if let Some(call_locations) = cx.render_options.call_locations.as_ref() {\n-            let key = cx.tcx.def_path(def_id).to_string_no_crate_verbose();\n+            let key = scrape_examples::def_id_call_key(cx.tcx, def_id);\n             self.call_locations = call_locations.get(&key).cloned();\n-            debug!(\"call_locations: {} -- {:?}\", key, self.call_locations);\n+            debug!(\"call_locations: {:?} -- {:?}\", key, self.call_locations);\n         }\n     }\n }"}, {"sha": "65c38566a058e10ca4301990392928ff5ff764c1", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -2,6 +2,7 @@ use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::ffi::OsStr;\n use std::fmt;\n+use std::fs;\n use std::path::PathBuf;\n use std::str::FromStr;\n \n@@ -160,7 +161,12 @@ crate struct Options {\n     /// Whether to skip capturing stdout and stderr of tests.\n     crate nocapture: bool,\n \n-    crate scrape_examples: Vec<String>,\n+    // Options for scraping call sites from examples/ directory\n+    /// Path to output file to write JSON of call sites. If this option is Some(..) then\n+    /// the compiler will scrape examples and not generate documentation.\n+    crate scrape_examples: Option<PathBuf>,\n+    /// Path to the root of the workspace, used to generate workspace-relative file paths.\n+    crate workspace_root: Option<PathBuf>,\n }\n \n impl fmt::Debug for Options {\n@@ -677,7 +683,32 @@ impl Options {\n         }\n \n         let repository_url = matches.opt_str(\"repository-url\");\n-        let scrape_examples = matches.opt_strs(\"scrape-examples\");\n+        let scrape_examples = matches.opt_str(\"scrape-examples\").map(PathBuf::from);\n+        let workspace_root = matches.opt_str(\"workspace-root\").map(PathBuf::from);\n+        let with_examples = matches.opt_strs(\"with-examples\");\n+        let each_call_locations = with_examples\n+            .into_iter()\n+            .map(|path| {\n+                let bytes = fs::read(&path).map_err(|e| format!(\"{} (for path {})\", e, path))?;\n+                let calls: AllCallLocations =\n+                    serde_json::from_slice(&bytes).map_err(|e| format!(\"{}\", e))?;\n+                Ok(calls)\n+            })\n+            .collect::<Result<Vec<_>, _>>()\n+            .map_err(|e: String| {\n+                diag.err(&format!(\"failed to load examples with error: {}\", e));\n+                1\n+            })?;\n+        let call_locations = (each_call_locations.len() > 0).then(move || {\n+            each_call_locations.into_iter().fold(FxHashMap::default(), |mut acc, map| {\n+                for (function, calls) in map.into_iter() {\n+                    acc.entry(function)\n+                        .or_insert_with(FxHashMap::default)\n+                        .extend(calls.into_iter());\n+                }\n+                acc\n+            })\n+        });\n \n         let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n \n@@ -745,13 +776,14 @@ impl Options {\n                 ),\n                 emit,\n                 generate_link_to_definition,\n-                call_locations: None,\n+                call_locations,\n                 repository_url,\n             },\n             crate_name,\n             output_format,\n             json_unused_externs,\n             scrape_examples,\n+            workspace_root,\n         })\n     }\n "}, {"sha": "f8f5e6be9d5194500b2ca40d98bc8e0fe311f5d4", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -45,7 +45,7 @@ crate struct TestOptions {\n     crate attrs: Vec<String>,\n }\n \n-crate fn run(options: Options) -> Result<(), ErrorReported> {\n+crate fn make_rustc_config(options: &Options) -> interface::Config {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = crate::lint::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -87,7 +87,7 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n     let mut cfgs = options.cfgs.clone();\n     cfgs.push(\"doc\".to_owned());\n     cfgs.push(\"doctest\".to_owned());\n-    let config = interface::Config {\n+    interface::Config {\n         opts: sessopts,\n         crate_cfg: interface::parse_cfgspecs(cfgs),\n         input,\n@@ -103,7 +103,11 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n         override_queries: None,\n         make_codegen_backend: None,\n         registry: rustc_driver::diagnostics_registry(),\n-    };\n+    }\n+}\n+\n+crate fn run(options: Options) -> Result<(), ErrorReported> {\n+    let config = make_rustc_config(&options);\n \n     let test_args = options.test_args.clone();\n     let display_doctest_warnings = options.display_doctest_warnings;"}, {"sha": "aa65ca474deee67e50ba01631cc2665284efcd01", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -2528,9 +2528,16 @@ fn render_call_locations(\n     write_example(w, it.next().unwrap());\n \n     if n_examples > 1 {\n-        write!(w, r#\"<div class=\"more-scraped-examples hidden\">\"#);\n+        write!(\n+            w,\n+            r#\"<details class=\"rustdoc-toggle more-examples-toggle\">\n+                  <summary class=\"hideme\">\n+                     <span>More examples</span>\n+                  </summary>\n+                  <div class=\"more-scraped-examples\">\"#\n+        );\n         it.for_each(|ex| write_example(w, ex));\n-        write!(w, \"</div>\");\n+        write!(w, \"</div></details>\");\n     }\n \n     write!(w, \"</div>\");"}, {"sha": "557a1d1194808c1a21a23093a8ea0b5117ab5686", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -2066,15 +2066,12 @@ details.undocumented[open] > summary::before {\n \tbackground: #f6fdb0;\n }\n \n+.more-examples-toggle summary {\n+\tcolor: #999;\n+}\n+\n .more-scraped-examples {\n \tpadding-left: 10px;\n \tborder-left: 1px solid #ccc;\n-}\n-\n-.toggle-examples .collapse-toggle {\n-\tposition: relative;\n-}\n-\n-.toggle-examples a {\n-\tcolor: #999 !important; // FIXME(wcrichto): why is important needed\n+\tmargin-left: 24px;\n }"}, {"sha": "fea1b4ecbf1e6fc385d0aa1f3fad4541a989dcd8", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -1136,54 +1136,21 @@ function hideThemeButtonState() {\n     }\n \n     function updateScrapedExamples() {\n-        onEach(document.getElementsByClassName('scraped-example-list'), function (exampleSet) {\n-            updateScrapedExample(\n-                exampleSet.querySelector(\".small-section-header + .scraped-example\")\n-            );\n-        });\n-\n-        onEach(document.getElementsByClassName(\"more-scraped-examples\"), function (more) {\n-            var toggle = createSimpleToggle(true);\n-            var label = \"More examples\";\n-            var wrapper = createToggle(toggle, label, 14, \"toggle-examples\", false);\n-            more.parentNode.insertBefore(wrapper, more);\n-            var examples_init = false;\n-\n-            // Show additional examples on click\n-            wrapper.onclick = function () {\n-                if (hasClass(this, \"collapsed\")) {\n-                    removeClass(this, \"collapsed\");\n-                    onEachLazy(this.parentNode.getElementsByClassName(\"hidden\"), function (x) {\n-                        if (hasClass(x, \"content\") === false) {\n-                            removeClass(x, \"hidden\");\n-                            addClass(x, \"x\")\n-                        }\n-                    }, true);\n-                    this.querySelector('.toggle-label').innerHTML = \"Hide examples\";\n-                    this.querySelector('.inner').innerHTML = labelForToggleButton(false);\n-                    if (!examples_init) {\n-                        examples_init = true;\n-                        onEach(more.getElementsByClassName('scraped-example'),\n-                               updateScrapedExample);\n-                    }\n-                } else {\n-                    addClass(this, \"collapsed\");\n-                    onEachLazy(this.parentNode.getElementsByClassName(\"x\"), function (x) {\n-                        if (hasClass(x, \"content\") === false) {\n-                            addClass(x, \"hidden\");\n-                            removeClass(x, \"x\")\n-                        }\n-                    }, true);\n-                    this.querySelector('.toggle-label').innerHTML = label;\n-                    this.querySelector('.inner').innerHTML = labelForToggleButton(true);\n-                }\n-            };\n+        var firstExamples = document.querySelectorAll('.scraped-example-list > .scraped-example');\n+        onEach(firstExamples, updateScrapedExample);\n+        onEach(document.querySelectorAll('.more-examples-toggle'), function(toggle) {\n+            var moreExamples = toggle.querySelectorAll('.scraped-example');\n+            toggle.querySelector('summary').addEventListener('click', function() {\n+                // Wrapping in setTimeout ensures the update happens after the elements are actually\n+                // visible. This is necessary since updateScrapedExample calls scrollToLoc which\n+                // depends on offsetHeight, a property that requires an element to be visible to\n+                // compute correctly.\n+                setTimeout(function() { onEach(moreExamples, updateScrapedExample); });\n+            }, {once: true});\n         });\n     }\n \n-    var start = Date.now();\n     updateScrapedExamples();\n-    console.log(\"updated examples took\", Date.now() - start, \"ms\");\n }());\n \n (function () {"}, {"sha": "9bcdbc406a6f7a7833484010a5628143ab09a128", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -619,8 +619,10 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"Make the identifiers in the HTML source code pages navigable\",\n             )\n         }),\n-        unstable(\"scrape-examples\", |o| o.optmulti(\"\", \"scrape-examples\", \"\", \"\")),\n+        unstable(\"scrape-examples\", |o| o.optopt(\"\", \"scrape-examples\", \"\", \"\")),\n+        unstable(\"workspace-root\", |o| o.optopt(\"\", \"workspace-root\", \"\", \"\")),\n         unstable(\"repository-url\", |o| o.optopt(\"\", \"repository-url\", \"\", \"\")),\n+        unstable(\"with-examples\", |o| o.optmulti(\"\", \"with-examples\", \"\", \"\")),\n     ]\n }\n \n@@ -700,28 +702,20 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n     }\n }\n \n-fn main_options(mut options: config::Options) -> MainResult {\n+fn main_options(options: config::Options) -> MainResult {\n     let diag = core::new_handler(options.error_format, None, &options.debugging_opts);\n \n-    match (options.should_test, options.markdown_input()) {\n-        (true, true) => return wrap_return(&diag, markdown::test(options)),\n-        (true, false) => return doctest::run(options),\n-        (false, true) => {\n+    match (options.should_test, options.markdown_input(), options.scrape_examples.is_some()) {\n+        (_, _, true) => return scrape_examples::run(options),\n+        (true, true, false) => return wrap_return(&diag, markdown::test(options)),\n+        (true, false, false) => return doctest::run(options),\n+        (false, true, false) => {\n             return wrap_return(\n                 &diag,\n                 markdown::render(&options.input, options.render_options, options.edition),\n             );\n         }\n-        (false, false) => {}\n-    }\n-\n-    if options.scrape_examples.len() > 0 {\n-        if let Some(crate_name) = &options.crate_name {\n-            options.render_options.call_locations =\n-                Some(scrape_examples::scrape(&options.scrape_examples, crate_name)?);\n-        } else {\n-            // raise an error?\n-        }\n+        (false, false, false) => {}\n     }\n \n     // need to move these items separately because we lose them by the time the closure is called,"}, {"sha": "67d80d01be75947f931d28a421bc167f795359eb", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 63, "deletions": 79, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2855bf039a574865c13c67a43cefbf8cead49c1b/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=2855bf039a574865c13c67a43cefbf8cead49c1b", "patch": "@@ -1,7 +1,8 @@\n //! This module analyzes provided crates to find examples of uses for items in the\n //! current crate being documented.\n \n-use rayon::prelude::*;\n+use crate::config::Options;\n+use crate::doctest::make_rustc_config;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{\n     self as hir,\n@@ -10,10 +11,12 @@ use rustc_hir::{\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::def_id::DefId;\n+use std::fs;\n \n+crate type DefIdCallKey = String;\n crate type FnCallLocations = FxHashMap<String, Vec<(usize, usize)>>;\n-crate type AllCallLocations = FxHashMap<String, FnCallLocations>;\n+crate type AllCallLocations = FxHashMap<DefIdCallKey, FnCallLocations>;\n \n /// Visitor for traversing a crate and finding instances of function calls.\n struct FindCalls<'a, 'tcx> {\n@@ -22,16 +25,20 @@ struct FindCalls<'a, 'tcx> {\n \n     /// Workspace-relative path to the root of the crate. Used to remember\n     /// which example a particular call came from.\n-    file_name: String,\n-\n-    /// Name of the crate being documented, to filter out calls to irrelevant\n-    /// functions.\n-    krate: Symbol,\n+    file_path: String,\n \n     /// Data structure to accumulate call sites across all examples.\n     calls: &'a mut AllCallLocations,\n }\n \n+crate fn def_id_call_key(tcx: TyCtxt<'_>, def_id: DefId) -> DefIdCallKey {\n+    format!(\n+        \"{}{}\",\n+        tcx.crate_name(def_id.krate).to_ident_string(),\n+        tcx.def_path(def_id).to_string_no_crate_verbose()\n+    )\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for FindCalls<'a, 'tcx>\n where\n     'tcx: 'a,\n@@ -46,9 +53,11 @@ where\n         intravisit::walk_expr(self, ex);\n \n         // Get type of function if expression is a function call\n-        let types = self.tcx.typeck(ex.hir_id.owner);\n         let (ty, span) = match ex.kind {\n-            hir::ExprKind::Call(f, _) => (types.node_type(f.hir_id), ex.span),\n+            hir::ExprKind::Call(f, _) => {\n+                let types = self.tcx.typeck(ex.hir_id.owner);\n+                (types.node_type(f.hir_id), ex.span)\n+            }\n             hir::ExprKind::MethodCall(_, _, _, span) => {\n                 let types = self.tcx.typeck(ex.hir_id.owner);\n                 let def_id = types.type_dependent_def_id(ex.hir_id).unwrap();\n@@ -59,80 +68,55 @@ where\n             }\n         };\n \n-        // Save call site if the function resovles to a concrete definition\n+        // Save call site if the function resolves to a concrete definition\n         if let ty::FnDef(def_id, _) = ty.kind() {\n-            if self.tcx.crate_name(def_id.krate) == self.krate {\n-                let key = self.tcx.def_path(*def_id).to_string_no_crate_verbose();\n-                let entries = self.calls.entry(key).or_insert_with(FxHashMap::default);\n-                entries\n-                    .entry(self.file_name.clone())\n-                    .or_insert_with(Vec::new)\n-                    .push((span.lo().0 as usize, span.hi().0 as usize));\n-            }\n+            let key = def_id_call_key(self.tcx, *def_id);\n+            let entries = self.calls.entry(key).or_insert_with(FxHashMap::default);\n+            entries\n+                .entry(self.file_path.clone())\n+                .or_insert_with(Vec::new)\n+                .push((span.lo().0 as usize, span.hi().0 as usize));\n         }\n     }\n }\n \n-struct Callbacks {\n-    calls: AllCallLocations,\n-    krate: String,\n-    file_name: String,\n-}\n-\n-impl rustc_driver::Callbacks for Callbacks {\n-    fn after_analysis<'tcx>(\n-        &mut self,\n-        _compiler: &rustc_interface::interface::Compiler,\n-        queries: &'tcx rustc_interface::Queries<'tcx>,\n-    ) -> rustc_driver::Compilation {\n-        queries.global_ctxt().unwrap().take().enter(|tcx| {\n-            let mut finder = FindCalls {\n-                calls: &mut self.calls,\n-                tcx,\n-                map: tcx.hir(),\n-                file_name: self.file_name.clone(),\n-                krate: Symbol::intern(&self.krate),\n-            };\n-            tcx.hir().krate().visit_all_item_likes(&mut finder.as_deep_visitor());\n-        });\n-\n-        rustc_driver::Compilation::Stop\n-    }\n-}\n-\n-/// Executes rustc on each example and collects call locations into a single structure.\n-///\n-/// # Arguments:\n-/// * `examples` is an array of invocations to rustc, generated by Cargo.\n-/// * `krate` is the name of the crate being documented.\n-pub fn scrape(examples: &[String], krate: &str) -> interface::Result<AllCallLocations> {\n-    // Scrape each crate in parallel\n-    // FIXME(wcrichto): do we need optional support for no rayon?\n-    let maps = examples\n-        .par_iter()\n-        .map(|example| {\n-            // FIXME(wcrichto): is there a more robust way to get arguments than split(\" \")?\n-            let mut args = example.split(\" \").map(|s| s.to_owned()).collect::<Vec<_>>();\n-            let file_name = args[0].clone();\n-            args.insert(0, \"_\".to_string());\n-\n-            // FIXME(wcrichto): is there any setup / cleanup that needs to be performed\n-            // here upon the invocation of rustc_driver?\n-            debug!(\"Scraping examples from krate {} with args:\\n{:?}\", krate, args);\n-            let mut callbacks =\n-                Callbacks { calls: FxHashMap::default(), file_name, krate: krate.to_string() };\n-            rustc_driver::RunCompiler::new(&args, &mut callbacks).run()?;\n-            Ok(callbacks.calls)\n+crate fn run(options: Options) -> interface::Result<()> {\n+    let inner = move || {\n+        let config = make_rustc_config(&options);\n+\n+        // Get input file path as relative to workspace root\n+        let file_path = options\n+            .input\n+            .strip_prefix(options.workspace_root.as_ref().unwrap())\n+            .map_err(|e| format!(\"{}\", e))?;\n+\n+        interface::run_compiler(config, |compiler| {\n+            compiler.enter(|queries| {\n+                let mut global_ctxt = queries.global_ctxt().unwrap().take();\n+                global_ctxt.enter(|tcx| {\n+                    // Run call-finder on all items\n+                    let mut calls = FxHashMap::default();\n+                    let mut finder = FindCalls {\n+                        calls: &mut calls,\n+                        tcx,\n+                        map: tcx.hir(),\n+                        file_path: file_path.display().to_string(),\n+                    };\n+                    tcx.hir().krate().visit_all_item_likes(&mut finder.as_deep_visitor());\n+\n+                    // Save output JSON to provided path\n+                    let calls_json = serde_json::to_string(&calls).map_err(|e| format!(\"{}\", e))?;\n+                    fs::write(options.scrape_examples.as_ref().unwrap(), &calls_json)\n+                        .map_err(|e| format!(\"{}\", e))?;\n+\n+                    Ok(())\n+                })\n+            })\n         })\n-        .collect::<interface::Result<Vec<_>>>()?;\n-\n-    // Merge the call locations into a single result\n-    let mut all_map = FxHashMap::default();\n-    for map in maps {\n-        for (function, calls) in map.into_iter() {\n-            all_map.entry(function).or_insert_with(FxHashMap::default).extend(calls.into_iter());\n-        }\n-    }\n+    };\n \n-    Ok(all_map)\n+    inner().map_err(|e: String| {\n+        eprintln!(\"{}\", e);\n+        rustc_errors::ErrorReported\n+    })\n }"}]}