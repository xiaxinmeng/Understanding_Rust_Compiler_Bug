{"sha": "1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZTcwZDMzZjdiYWYxMjk3OGNmYjNkZTg2MWU2MWIyYTVkNmZjYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-11T04:27:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-11T04:27:13Z"}, "message": "Auto merge of #31461 - jseyfried:remove_import_resolutions, r=nrc\n\nThis PR adds to `NameBinding` so it can more fully represent bindings from imports as well from items, refactors away `Target`, generalizes `ImportResolution` to a simpler type `NameResolution`, and uses a single `NameResolution`-valued map in place the existing maps `children` and `import_resolutions` (of `NameBinding`s and `ImportResolution`s, respectively), simplifying duplicate checking and name resolution.\n\nIt also unifies the `resolve_name_in_module` in `lib.rs` with its namesake in `resolve_imports.rs`, clarifying and improving the core logic (fixes #31403 and fixes #31404) while maintaining clear future-comparability with shadowable globs (i.e., never reporting that a resolution is a `Success` or is `Failing` unless this would also be knowable with shadowable globs).\n\nSince it fixes #31403, this is technically a [breaking-change], but it is exceedingly unlikely to cause breakage in practice. The following is an example of code that would break:\n```rust\nmod foo {\n    pub mod bar {} // This defines bar in the type namespace\n    pub use alpha::bar; // This defines bar in the value namespace\n\n    // This should define baz in both namespaces, but it only defines baz in the type namespace.\n    pub use self::bar as baz;\n    pub fn baz() {} // This should collide with baz, but now it does not.\n}\n\npub fn f() {}\nmod alpha {\n    pub use self::f as bar; // Changing this to `pub fn bar() {}` causes the collision right now.\n    pub use super::*;\n}\n```\n\nr? @nrc", "tree": {"sha": "773c0d6ec989d8dfd5472b299b668b3b464671d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/773c0d6ec989d8dfd5472b299b668b3b464671d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "html_url": "https://github.com/rust-lang/rust/commit/1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "106070b905d1d312e19f7d0e439d1a7e78d3dc05", "url": "https://api.github.com/repos/rust-lang/rust/commits/106070b905d1d312e19f7d0e439d1a7e78d3dc05", "html_url": "https://github.com/rust-lang/rust/commit/106070b905d1d312e19f7d0e439d1a7e78d3dc05"}, {"sha": "3df40c09ec5efb74e16c3da84fef6ce142dae73a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3df40c09ec5efb74e16c3da84fef6ce142dae73a", "html_url": "https://github.com/rust-lang/rust/commit/3df40c09ec5efb74e16c3da84fef6ce142dae73a"}], "stats": {"total": 1054, "additions": 377, "deletions": 677}, "files": [{"sha": "775ed34ab073cc01f957ea754256476dcfe940d7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "patch": "@@ -16,10 +16,9 @@\n use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use resolve_imports::ImportResolution;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, DefOrModule};\n+use {NameBinding, NameBindingKind};\n use {names_to_string, module_to_string};\n use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n@@ -82,8 +81,8 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, Span) {\n \n impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        let def = DefOrModule::Def(self.0);\n-        NameBinding { modifiers: self.2, def_or_module: def, span: Some(self.1) }\n+        let kind = NameBindingKind::Def(self.0);\n+        NameBinding { modifiers: self.2, kind: kind, span: Some(self.1) }\n     }\n }\n \n@@ -101,16 +100,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn try_define<T>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n         where T: ToNameBinding<'b>\n     {\n-        parent.try_define_child(name, ns, def.to_name_binding());\n+        let _ = parent.try_define_child(name, ns, self.new_name_binding(def.to_name_binding()));\n     }\n \n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n-        let binding = def.to_name_binding();\n-        let old_binding = match parent.try_define_child(name, ns, binding.clone()) {\n-            Some(old_binding) => old_binding,\n-            None => return,\n+        let binding = self.new_name_binding(def.to_name_binding());\n+        let old_binding = match parent.try_define_child(name, ns, binding) {\n+            Ok(()) => return,\n+            Err(old_binding) => old_binding,\n         };\n \n         let span = binding.span.unwrap_or(DUMMY_SP);\n@@ -699,18 +698,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 debug!(\"(building import directive) building import directive: {}::{}\",\n                        names_to_string(&module_.imports.borrow().last().unwrap().module_path),\n                        target);\n-\n-                let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-                for &ns in [TypeNS, ValueNS].iter() {\n-                    let mut resolution = import_resolutions.entry((target, ns)).or_insert(\n-                        ImportResolution::new(id, is_public)\n-                    );\n-\n-                    resolution.outstanding_references += 1;\n-                    // the source of this name is different now\n-                    resolution.id = id;\n-                    resolution.is_public = is_public;\n-                }\n+                module_.increment_outstanding_references_for(target, ValueNS);\n+                module_.increment_outstanding_references_for(target, TypeNS);\n             }\n             GlobImport => {\n                 // Set the glob flag. This tells us that we don't know the"}, {"sha": "5fbe06a868f07f0d420fc5fb088f4e5b01a46673", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 161, "deletions": 147, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "patch": "@@ -87,13 +87,12 @@ use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n use rustc_front::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n use rustc_front::util::walk_pat;\n \n-use std::collections::{hash_map, HashMap, HashSet};\n+use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n \n-use resolve_imports::{Target, ImportDirective, ImportResolution};\n-use resolve_imports::Shadowable;\n+use resolve_imports::{ImportDirective, NameResolution};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -343,12 +342,10 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             if let Some(sp) = resolver.ast_map.span_if_local(did) {\n                 err.span_note(sp, \"constant defined here\");\n             }\n-            if let Some(directive) = resolver.current_module\n-                                             .import_resolutions\n-                                             .borrow()\n-                                             .get(&(name, ValueNS)) {\n-                let item = resolver.ast_map.expect_item(directive.id);\n-                err.span_note(item.span, \"constant imported here\");\n+            if let Success(binding) = resolver.current_module.resolve_name(name, ValueNS, true) {\n+                if binding.is_import() {\n+                    err.span_note(binding.span.unwrap(), \"constant imported here\");\n+                }\n             }\n             err\n         }\n@@ -653,10 +650,10 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     }\n }\n \n-type ErrorMessage = Option<(Span, String)>;\n+pub type ErrorMessage = Option<(Span, String)>;\n \n #[derive(Clone, PartialEq, Eq)]\n-enum ResolveResult<T> {\n+pub enum ResolveResult<T> {\n     Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n     Indeterminate, // Couldn't determine due to unresolved globs.\n     Success(T), // Successfully resolved the import.\n@@ -670,6 +667,13 @@ impl<T> ResolveResult<T> {\n             Success(t) => f(t),\n         }\n     }\n+\n+    fn success(self) -> Option<T> {\n+        match self {\n+            Success(t) => Some(t),\n+            _ => None,\n+        }\n+    }\n }\n \n enum FallbackSuggestion {\n@@ -795,7 +799,7 @@ pub struct ModuleS<'a> {\n     is_public: bool,\n     is_extern_crate: bool,\n \n-    children: RefCell<HashMap<(Name, Namespace), NameBinding<'a>>>,\n+    children: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n@@ -814,8 +818,7 @@ pub struct ModuleS<'a> {\n     // entry block for `f`.\n     anonymous_children: RefCell<NodeMap<Module<'a>>>,\n \n-    // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<(Name, Namespace), ImportResolution<'a>>>,\n+    shadowed_traits: RefCell<Vec<&'a NameBinding<'a>>>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n@@ -847,7 +850,7 @@ impl<'a> ModuleS<'a> {\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n             anonymous_children: RefCell::new(NodeMap()),\n-            import_resolutions: RefCell::new(HashMap::new()),\n+            shadowed_traits: RefCell::new(Vec::new()),\n             glob_count: Cell::new(0),\n             pub_count: Cell::new(0),\n             pub_glob_count: Cell::new(0),\n@@ -856,26 +859,60 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    fn get_child(&self, name: Name, ns: Namespace) -> Option<NameBinding<'a>> {\n-        self.children.borrow().get(&(name, ns)).cloned()\n+    fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n+                    -> ResolveResult<&'a NameBinding<'a>> {\n+        let glob_count =\n+            if allow_private_imports { self.glob_count.get() } else { self.pub_glob_count.get() };\n+\n+        self.children.borrow().get(&(name, ns)).cloned().unwrap_or_default().result(glob_count)\n+            .and_then(|binding| {\n+                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n+                if allowed { Success(binding) } else { Failed(None) }\n+            })\n+    }\n+\n+    // Define the name or return the existing binding if there is a collision.\n+    fn try_define_child(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>)\n+                        -> Result<(), &'a NameBinding<'a>> {\n+        let mut children = self.children.borrow_mut();\n+        let resolution = children.entry((name, ns)).or_insert_with(Default::default);\n+\n+        // FIXME #31379: We can use methods from imported traits shadowed by non-import items\n+        if let Some(old_binding) = resolution.binding {\n+            if !old_binding.is_import() && binding.is_import() {\n+                if let Some(Def::Trait(_)) = binding.def() {\n+                    self.shadowed_traits.borrow_mut().push(binding);\n+                }\n+            }\n+        }\n+\n+        resolution.try_define(binding)\n+    }\n+\n+    fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n+        let mut children = self.children.borrow_mut();\n+        children.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n     }\n \n-    // If the name is not yet defined, define the name and return None.\n-    // Otherwise, return the existing definition.\n-    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n-                        -> Option<NameBinding<'a>> {\n-        match self.children.borrow_mut().entry((name, ns)) {\n-            hash_map::Entry::Vacant(entry) => { entry.insert(binding); None }\n-            hash_map::Entry::Occupied(entry) => { Some(entry.get().clone()) },\n+    fn decrement_outstanding_references_for(&self, name: Name, ns: Namespace) {\n+        match self.children.borrow_mut().get_mut(&(name, ns)).unwrap().outstanding_references {\n+            0 => panic!(\"No more outstanding references!\"),\n+            ref mut outstanding_references => { *outstanding_references -= 1; }\n         }\n     }\n \n-    fn for_each_local_child<F: FnMut(Name, Namespace, &NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(name, ns), name_binding) in self.children.borrow().iter() {\n-            if !name_binding.is_extern_crate() {\n+    fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n+        for (&(name, ns), name_resolution) in self.children.borrow().iter() {\n+            name_resolution.binding.map(|binding| f(name, ns, binding));\n+        }\n+    }\n+\n+    fn for_each_local_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n+        self.for_each_child(|name, ns, name_binding| {\n+            if !name_binding.is_import() && !name_binding.is_extern_crate() {\n                 f(name, ns, name_binding)\n             }\n-        }\n+        })\n     }\n \n     fn def_id(&self) -> Option<DefId> {\n@@ -951,21 +988,27 @@ bitflags! {\n         // Variants are considered `PUBLIC`, but some of them live in private enums.\n         // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n         const PRIVATE_VARIANT = 1 << 2,\n+        const PRELUDE = 1 << 3,\n+        const GLOB_IMPORTED = 1 << 4,\n     }\n }\n \n // Records a possibly-private value, type, or module definition.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct NameBinding<'a> {\n-    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n-    def_or_module: DefOrModule<'a>,\n+    modifiers: DefModifiers,\n+    kind: NameBindingKind<'a>,\n     span: Option<Span>,\n }\n \n-#[derive(Clone, Debug)]\n-enum DefOrModule<'a> {\n+#[derive(Debug)]\n+enum NameBindingKind<'a> {\n     Def(Def),\n     Module(Module<'a>),\n+    Import {\n+        binding: &'a NameBinding<'a>,\n+        id: NodeId,\n+    },\n }\n \n impl<'a> NameBinding<'a> {\n@@ -976,20 +1019,22 @@ impl<'a> NameBinding<'a> {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n \n-        NameBinding { modifiers: modifiers, def_or_module: DefOrModule::Module(module), span: span }\n+        NameBinding { modifiers: modifiers, kind: NameBindingKind::Module(module), span: span }\n     }\n \n     fn module(&self) -> Option<Module<'a>> {\n-        match self.def_or_module {\n-            DefOrModule::Module(ref module) => Some(module),\n-            DefOrModule::Def(_) => None,\n+        match self.kind {\n+            NameBindingKind::Module(module) => Some(module),\n+            NameBindingKind::Def(_) => None,\n+            NameBindingKind::Import { binding, .. } => binding.module(),\n         }\n     }\n \n     fn def(&self) -> Option<Def> {\n-        match self.def_or_module {\n-            DefOrModule::Def(def) => Some(def),\n-            DefOrModule::Module(ref module) => module.def,\n+        match self.kind {\n+            NameBindingKind::Def(def) => Some(def),\n+            NameBindingKind::Module(module) => module.def,\n+            NameBindingKind::Import { binding, .. } => binding.def(),\n         }\n     }\n \n@@ -1009,6 +1054,13 @@ impl<'a> NameBinding<'a> {\n     fn is_extern_crate(&self) -> bool {\n         self.module().map(|module| module.is_extern_crate).unwrap_or(false)\n     }\n+\n+    fn is_import(&self) -> bool {\n+        match self.kind {\n+            NameBindingKind::Import { .. } => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1112,6 +1164,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n+    name_bindings: arena::TypedArena<NameBinding<'a>>,\n }\n \n #[derive(PartialEq)]\n@@ -1177,6 +1230,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn arenas() -> ResolverArenas<'a> {\n         ResolverArenas {\n             modules: arena::TypedArena::new(),\n+            name_bindings: arena::TypedArena::new(),\n         }\n     }\n \n@@ -1188,6 +1242,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n     }\n \n+    fn new_name_binding(&self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n+        self.arenas.name_bindings.alloc(name_binding)\n+    }\n+\n     fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def) -> Module<'a> {\n         let mut module = ModuleS::new(parent_link, Some(def), false, true);\n         module.is_extern_crate = true;\n@@ -1199,14 +1257,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     #[inline]\n-    fn record_import_use(&mut self, name: Name, ns: Namespace, resolution: &ImportResolution<'a>) {\n-        let import_id = resolution.id;\n-        self.used_imports.insert((import_id, ns));\n-        match resolution.target.as_ref().and_then(|target| target.target_module.def_id()) {\n-            Some(DefId { krate, .. }) => { self.used_crates.insert(krate); }\n-            _ => {}\n+    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n+        // track extern crates for unused_extern_crate lint\n+        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n+            self.used_crates.insert(krate);\n+        }\n+\n+        let import_id = match binding.kind {\n+            NameBindingKind::Import { id, .. } => id,\n+            _ => return,\n         };\n \n+        self.used_imports.insert((import_id, ns));\n+\n         if !self.make_glob_map {\n             return;\n         }\n@@ -1237,8 +1300,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      lp: LastPrivate)\n                                      -> ResolveResult<(Module<'a>, LastPrivate)> {\n         fn search_parent_externals<'a>(needle: Name, module: Module<'a>) -> Option<Module<'a>> {\n-            match module.get_child(needle, TypeNS) {\n-                Some(ref binding) if binding.is_extern_crate() => Some(module),\n+            match module.resolve_name(needle, TypeNS, false) {\n+                Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n                         search_parent_externals(needle, parent)\n@@ -1295,20 +1358,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            name);\n                     return Indeterminate;\n                 }\n-                Success((target, used_proxy)) => {\n+                Success(binding) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    if let Some(module_def) = target.binding.module() {\n-                        // track extern crates for unused_extern_crate lint\n-                        if let Some(did) = module_def.def_id() {\n-                            self.used_crates.insert(did.krate);\n-                        }\n-\n+                    if let Some(module_def) = binding.module() {\n                         search_module = module_def;\n \n                         // Keep track of the closest private module used\n                         // when resolving this import chain.\n-                        if !used_proxy && !search_module.is_public {\n+                        if !binding.is_public() {\n                             if let Some(did) = search_module.def_id() {\n                                 closest_private = LastMod(DependsOn(did));\n                             }\n@@ -1399,7 +1457,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 debug!(\"(resolving module path for import) indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n-                            Success((target, _)) => match target.binding.module() {\n+                            Success(binding) => match binding.module() {\n                                 Some(containing_module) => {\n                                     search_module = containing_module;\n                                     start_index = 1;\n@@ -1433,7 +1491,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n-                                     -> ResolveResult<(Target<'a>, bool)> {\n+                                     -> ResolveResult<&'a NameBinding<'a>> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n@@ -1455,10 +1513,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n                     return Indeterminate;\n                 }\n-                Success((target, used_reexport)) => {\n+                Success(binding) => {\n                     // We found the module.\n                     debug!(\"(resolving item in lexical scope) found name in module, done\");\n-                    return Success((target, used_reexport));\n+                    return Success(binding);\n                 }\n             }\n \n@@ -1552,51 +1610,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Attempts to resolve the supplied name in the given module for the\n-    /// given namespace. If successful, returns the target corresponding to\n+    /// given namespace. If successful, returns the binding corresponding to\n     /// the name.\n-    ///\n-    /// The boolean returned on success is an indicator of whether this lookup\n-    /// passed through a public re-export proxy.\n     fn resolve_name_in_module(&mut self,\n-                              module_: Module<'a>,\n+                              module: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n                               allow_private_imports: bool,\n                               record_used: bool)\n-                              -> ResolveResult<(Target<'a>, bool)> {\n-        debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               name,\n-               module_to_string(&*module_));\n+                              -> ResolveResult<&'a NameBinding<'a>> {\n+        debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n \n-        // First, check the direct children of the module.\n-        build_reduced_graph::populate_module_if_necessary(self, module_);\n-\n-        if let Some(binding) = module_.get_child(name, namespace) {\n-            debug!(\"(resolving name in module) found node as child\");\n-            return Success((Target::new(module_, binding, Shadowable::Never), false));\n-        }\n-\n-        // Check the list of resolved imports.\n-        match module_.import_resolutions.borrow().get(&(name, namespace)) {\n-            Some(import_resolution) if allow_private_imports || import_resolution.is_public => {\n-                if import_resolution.is_public && import_resolution.outstanding_references != 0 {\n-                    debug!(\"(resolving name in module) import unresolved; bailing out\");\n-                    return Indeterminate;\n-                }\n-                if let Some(target) = import_resolution.target.clone() {\n-                    debug!(\"(resolving name in module) resolved to import\");\n-                    if record_used {\n-                        self.record_import_use(name, namespace, &import_resolution);\n-                    }\n-                    return Success((target, true));\n-                }\n+        build_reduced_graph::populate_module_if_necessary(self, module);\n+        module.resolve_name(name, namespace, allow_private_imports).and_then(|binding| {\n+            if record_used {\n+                self.record_use(name, namespace, binding);\n             }\n-            Some(..) | None => {} // Continue.\n-        }\n-\n-        // We're out of luck.\n-        debug!(\"(resolving name in module) failed to resolve `{}`\", name);\n-        return Failed(None);\n+            Success(binding)\n+        })\n     }\n \n     fn report_unresolved_imports(&mut self, module_: Module<'a>) {\n@@ -1659,22 +1690,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(name) => {\n                 build_reduced_graph::populate_module_if_necessary(self, &orig_module);\n \n-                match orig_module.get_child(name, TypeNS) {\n-                    None => {\n-                        debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n-                               name,\n-                               module_to_string(&*orig_module));\n-                    }\n-                    Some(name_binding) => {\n-                        match name_binding.module() {\n-                            None => {\n-                                debug!(\"!!! (with scope) didn't find module for `{}` in `{}`\",\n-                                       name,\n-                                       module_to_string(&*orig_module));\n-                            }\n-                            Some(module_) => {\n-                                self.current_module = module_;\n-                            }\n+                if let Success(name_binding) = orig_module.resolve_name(name, TypeNS, false) {\n+                    match name_binding.module() {\n+                        None => {\n+                            debug!(\"!!! (with scope) didn't find module for `{}` in `{}`\",\n+                                   name,\n+                                   module_to_string(orig_module));\n+                        }\n+                        Some(module) => {\n+                            self.current_module = module;\n                         }\n                     }\n                 }\n@@ -2619,11 +2643,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        -> BareIdentifierPatternResolution {\n         let module = self.current_module;\n         match self.resolve_item_in_lexical_scope(module, name, ValueNS, true) {\n-            Success((target, _)) => {\n+            Success(binding) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n-                       &target.binding);\n-                match target.binding.def() {\n+                       binding);\n+                match binding.def() {\n                     None => {\n                         panic!(\"resolved name in the value namespace to a set of name bindings \\\n                                 with no def?!\");\n@@ -2779,7 +2803,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module = self.current_module;\n         let name = identifier.unhygienic_name;\n         match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n-            Success((target, _)) => target.binding.def().map(LocalDef::from_def),\n+            Success(binding) => binding.def().map(LocalDef::from_def),\n             Failed(Some((span, msg))) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 None\n@@ -2917,15 +2941,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         let def = match result {\n-            Success((Target { binding, .. }, _)) => {\n+            Success(binding) => {\n                 let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n             }\n             _ => return None,\n         };\n-        if let Some(DefId{krate: kid, ..}) = containing_module.def_id() {\n-            self.used_crates.insert(kid);\n-        }\n         return Some(def);\n     }\n \n@@ -2976,7 +2997,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let name = segments.last().unwrap().identifier.name;\n         match self.resolve_name_in_module(containing_module, name, namespace, false, true) {\n-            Success((Target { binding, .. }, _)) => {\n+            Success(binding) => {\n                 let (def, lp) = binding.def_and_lp();\n                 Some((def, last_private.or(lp)))\n             }\n@@ -3014,12 +3035,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             if let AnonymousModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n-                if let Success((target, _)) = self.resolve_name_in_module(module,\n-                                                                          ident.unhygienic_name,\n-                                                                          namespace,\n-                                                                          true,\n-                                                                          true) {\n-                    if let Some(def) = target.binding.def() {\n+                if let Success(binding) = self.resolve_name_in_module(module,\n+                                                                      ident.unhygienic_name,\n+                                                                      namespace,\n+                                                                      true,\n+                                                                      true) {\n+                    if let Some(def) = binding.def() {\n                         return Some(LocalDef::from_def(def));\n                     }\n                 }\n@@ -3063,8 +3084,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if name_path.len() == 1 {\n                 match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n-                    None => this.current_module.get_child(*last_name, TypeNS)\n-                                               .as_ref()\n+                    None => this.current_module.resolve_name(*last_name, TypeNS, true).success()\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n@@ -3124,7 +3144,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n-            if let Some(binding) = module.get_child(name, ValueNS) {\n+            if let Success(binding) = module.resolve_name(name, ValueNS, true) {\n                 if let Some(Def::Method(did)) = binding.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));\n@@ -3447,32 +3467,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // Look for trait children.\n             build_reduced_graph::populate_module_if_necessary(self, &search_module);\n \n-            for (&(_, ns), name_binding) in search_module.children.borrow().iter() {\n-                if ns != TypeNS { continue }\n+            search_module.for_each_child(|_, ns, name_binding| {\n+                if ns != TypeNS { return }\n                 let trait_def_id = match name_binding.def() {\n                     Some(Def::Trait(trait_def_id)) => trait_def_id,\n-                    Some(..) | None => continue,\n+                    Some(..) | None => return,\n                 };\n                 if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n                     add_trait_info(&mut found_traits, trait_def_id, name);\n+                    let trait_name = self.get_trait_name(trait_def_id);\n+                    self.record_use(trait_name, TypeNS, name_binding);\n                 }\n-            }\n+            });\n \n-            // Look for imports.\n-            for (&(_, ns), import) in search_module.import_resolutions.borrow().iter() {\n-                if ns != TypeNS { continue }\n-                let target = match import.target {\n-                    Some(ref target) => target,\n-                    None => continue,\n-                };\n-                let did = match target.binding.def() {\n-                    Some(Def::Trait(trait_def_id)) => trait_def_id,\n-                    Some(..) | None => continue,\n-                };\n+            // Look for shadowed traits.\n+            for binding in search_module.shadowed_traits.borrow().iter() {\n+                let did = binding.def().unwrap().def_id();\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n                     let trait_name = self.get_trait_name(did);\n-                    self.record_import_use(trait_name, TypeNS, &import);\n+                    self.record_use(trait_name, TypeNS, binding);\n                 }\n             }\n "}, {"sha": "6667e48987087cc8b0e20a82474b99523a4ae751", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 203, "deletions": 506, "changes": 709, "blob_url": "https://github.com/rust-lang/rust/blob/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "patch": "@@ -11,10 +11,9 @@\n use self::ImportDirectiveSubclass::*;\n \n use DefModifiers;\n-use DefOrModule;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use NameBinding;\n+use {NameBinding, NameBindingKind};\n use ResolveResult;\n use ResolveResult::*;\n use Resolver;\n@@ -26,7 +25,6 @@ use build_reduced_graph;\n \n use rustc::lint;\n use rustc::middle::def::*;\n-use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::*;\n \n use syntax::ast::{NodeId, Name};\n@@ -78,66 +76,74 @@ impl ImportDirective {\n             shadowable: shadowable,\n         }\n     }\n-}\n \n-/// The item that an import resolves to.\n-#[derive(Clone,Debug)]\n-pub struct Target<'a> {\n-    pub target_module: Module<'a>,\n-    pub binding: NameBinding<'a>,\n-    pub shadowable: Shadowable,\n-}\n+    // Given the binding to which this directive resolves in a particular namespace,\n+    // this returns the binding for the name this directive defines in that namespace.\n+    fn import<'a>(&self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n+        let mut modifiers = match self.is_public {\n+            true => DefModifiers::PUBLIC | DefModifiers::IMPORTABLE,\n+            false => DefModifiers::empty(),\n+        };\n+        if let GlobImport = self.subclass {\n+            modifiers = modifiers | DefModifiers::GLOB_IMPORTED;\n+        }\n+        if self.shadowable == Shadowable::Always {\n+            modifiers = modifiers | DefModifiers::PRELUDE;\n+        }\n \n-impl<'a> Target<'a> {\n-    pub fn new(target_module: Module<'a>, binding: NameBinding<'a>, shadowable: Shadowable)\n-               -> Self {\n-        Target {\n-            target_module: target_module,\n-            binding: binding,\n-            shadowable: shadowable,\n+        NameBinding {\n+            kind: NameBindingKind::Import { binding: binding, id: self.id },\n+            span: Some(self.span),\n+            modifiers: modifiers,\n         }\n     }\n }\n \n-#[derive(Debug)]\n-/// An ImportResolution records what we know about an imported name in a given namespace.\n-/// More specifically, it records the number of unresolved `use` directives that import the name,\n-/// the `use` directive importing the name in the namespace, and the `NameBinding` to which the\n-/// name in the namespace resolves (if applicable).\n-/// Different `use` directives may import the same name in different namespaces.\n-pub struct ImportResolution<'a> {\n-    // When outstanding_references reaches zero, outside modules can count on the targets being\n-    // correct. Before then, all bets are off; future `use` directives could override the name.\n-    // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n-    // is if the name is imported by exactly two `use` directives, one of which resolves to a\n-    // value and the other of which resolves to a type.\n+#[derive(Clone, Default)]\n+/// Records information about the resolution of a name in a module.\n+pub struct NameResolution<'a> {\n+    /// The number of unresolved single imports that could define the name.\n     pub outstanding_references: usize,\n-\n-    /// Whether this resolution came from a `use` or a `pub use`.\n-    pub is_public: bool,\n-\n-    /// Resolution of the name in the namespace\n-    pub target: Option<Target<'a>>,\n-\n-    /// The source node of the `use` directive\n-    pub id: NodeId,\n+    /// The least shadowable known binding for this name, or None if there are no known bindings.\n+    pub binding: Option<&'a NameBinding<'a>>,\n }\n \n-impl<'a> ImportResolution<'a> {\n-    pub fn new(id: NodeId, is_public: bool) -> Self {\n-        ImportResolution {\n-            outstanding_references: 0,\n-            id: id,\n-            target: None,\n-            is_public: is_public,\n+impl<'a> NameResolution<'a> {\n+    pub fn result(&self, outstanding_globs: usize) -> ResolveResult<&'a NameBinding<'a>> {\n+        // If no unresolved imports (single or glob) can define the name, self.binding is final.\n+        if self.outstanding_references == 0 && outstanding_globs == 0 {\n+            return self.binding.map(Success).unwrap_or(Failed(None));\n+        }\n+\n+        if let Some(binding) = self.binding {\n+            // Single imports will never be shadowable by other single or glob imports.\n+            if !binding.defined_with(DefModifiers::GLOB_IMPORTED) { return Success(binding); }\n+            // Non-PRELUDE glob imports will never be shadowable by other glob imports.\n+            if self.outstanding_references == 0 && !binding.defined_with(DefModifiers::PRELUDE) {\n+                return Success(binding);\n+            }\n         }\n+\n+        Indeterminate\n     }\n \n-    pub fn shadowable(&self) -> Shadowable {\n-        match self.target {\n-            Some(ref target) => target.shadowable,\n-            None => Shadowable::Always,\n+    // Define the name or return the existing binding if there is a collision.\n+    pub fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n+        let is_prelude = |binding: &NameBinding| binding.defined_with(DefModifiers::PRELUDE);\n+        let old_binding = match self.binding {\n+            Some(_) if is_prelude(binding) => return Ok(()),\n+            Some(old_binding) if !is_prelude(old_binding) => old_binding,\n+            _ => { self.binding = Some(binding); return Ok(()); }\n+        };\n+\n+        // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n+        if !old_binding.is_import() && binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+            if let NameBindingKind::Import { binding, .. } = binding.kind {\n+                if binding.is_import() { return Ok(()); }\n+            }\n         }\n+\n+        Err(old_binding)\n     }\n }\n \n@@ -203,38 +209,18 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Resolves an `ImportResolvingError` into the correct enum discriminant\n     /// and passes that on to `resolve_error`.\n-    fn import_resolving_error(&self, e: ImportResolvingError) {\n+    fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n         // If it's a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n         if let SingleImport(target, _) = e.import_directive.subclass {\n-            let mut import_resolutions = e.source_module.import_resolutions.borrow_mut();\n-\n-            let resolution = import_resolutions.entry((target, ValueNS)).or_insert_with(|| {\n-                debug!(\"(resolving import error) adding import resolution for `{}`\",\n-                       target);\n-\n-                ImportResolution::new(e.import_directive.id,\n-                                      e.import_directive.is_public)\n+            let dummy_binding = self.resolver.new_name_binding(NameBinding {\n+                modifiers: DefModifiers::PRELUDE,\n+                kind: NameBindingKind::Def(Def::Err),\n+                span: None,\n             });\n \n-            if resolution.target.is_none() {\n-                debug!(\"(resolving import error) adding fake target to import resolution of `{}`\",\n-                       target);\n-\n-                let name_binding = NameBinding {\n-                    modifiers: DefModifiers::IMPORTABLE,\n-                    def_or_module: DefOrModule::Def(Def::Err),\n-                    span: None,\n-                };\n-\n-                // Create a fake target pointing to a fake name binding in our\n-                // own module\n-                let target = Target::new(e.source_module,\n-                                         name_binding,\n-                                         Shadowable::Always);\n-\n-                resolution.target = Some(target);\n-            }\n+            let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding);\n+            let _ = e.source_module.try_define_child(target, TypeNS, dummy_binding);\n         }\n \n         let path = import_path_to_string(&e.import_directive.module_path,\n@@ -373,70 +359,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             })\n     }\n \n-    /// Resolves the name in the namespace of the module because it is being imported by\n-    /// importing_module. Returns the module in which the name was defined (as opposed to imported),\n-    /// the name bindings defining the name, and whether or not the name was imported into `module`.\n-    fn resolve_name_in_module(&mut self,\n-                              module: Module<'b>, // Module containing the name\n-                              name: Name,\n-                              ns: Namespace,\n-                              importing_module: Module<'b>) // Module importing the name\n-                              -> (ResolveResult<(Module<'b>, NameBinding<'b>)>, bool) {\n-        build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n-        if let Some(name_binding) = module.get_child(name, ns) {\n-            if name_binding.is_extern_crate() {\n-                // track the extern crate as used.\n-                if let Some(DefId { krate, .. }) = name_binding.module().unwrap().def_id() {\n-                    self.resolver.used_crates.insert(krate);\n-                }\n-            }\n-            return (Success((module, name_binding)), false)\n-        }\n-\n-        // If there is an unresolved glob at this point in the containing module, bail out.\n-        // We don't know enough to be able to resolve the name.\n-        if module.pub_glob_count.get() > 0 {\n-            return (Indeterminate, false);\n-        }\n-\n-        match module.import_resolutions.borrow().get(&(name, ns)) {\n-            // The containing module definitely doesn't have an exported import with the\n-            // name in question. We can therefore accurately report that names are unbound.\n-            None => (Failed(None), false),\n-\n-            // The name is an import which has been fully resolved, so we just follow it.\n-            Some(resolution) if resolution.outstanding_references == 0 => {\n-                // Import resolutions must be declared with \"pub\" in order to be exported.\n-                if !resolution.is_public {\n-                    return (Failed(None), false);\n-                }\n-\n-                let target = resolution.target.clone();\n-                if let Some(Target { target_module, binding, shadowable: _ }) = target {\n-                    self.resolver.record_import_use(name, ns, &resolution);\n-                    (Success((target_module, binding)), true)\n-                } else {\n-                    (Failed(None), false)\n-                }\n-            }\n-\n-            // If module is the same module whose import we are resolving and\n-            // it has an unresolved import with the same name as `name`, then the user\n-            // is actually trying to import an item that is declared in the same scope\n-            //\n-            // e.g\n-            // use self::submodule;\n-            // pub mod submodule;\n-            //\n-            // In this case we continue as if we resolved the import and let\n-            // check_for_conflicts_between_imports_and_items handle the conflict\n-            Some(_) => match (importing_module.def_id(), module.def_id()) {\n-                (Some(id1), Some(id2)) if id1 == id2 => (Failed(None), false),\n-                _ => (Indeterminate, false)\n-            },\n-        }\n-    }\n-\n     fn resolve_single_import(&mut self,\n                              module_: Module<'b>,\n                              target_module: Module<'b>,\n@@ -463,16 +385,28 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             }\n         };\n \n+        // If this is a circular import, we temporarily count it as determined so that\n+        // it fails (as opposed to being indeterminate) when nothing else can define it.\n+        if target_module.def_id() == module_.def_id() && source == target {\n+            module_.decrement_outstanding_references_for(target, ValueNS);\n+            module_.decrement_outstanding_references_for(target, TypeNS);\n+        }\n+\n         // We need to resolve both namespaces for this to succeed.\n-        let (value_result, value_used_reexport) =\n-            self.resolve_name_in_module(target_module, source, ValueNS, module_);\n-        let (type_result, type_used_reexport) =\n-            self.resolve_name_in_module(target_module, source, TypeNS, module_);\n+        let value_result =\n+            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n+        let type_result =\n+            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n+\n+        if target_module.def_id() == module_.def_id() && source == target {\n+            module_.increment_outstanding_references_for(target, ValueNS);\n+            module_.increment_outstanding_references_for(target, TypeNS);\n+        }\n \n         match (&value_result, &type_result) {\n-            (&Success((_, ref name_binding)), _) if !value_used_reexport &&\n-                                                    directive.is_public &&\n-                                                    !name_binding.is_public() => {\n+            (&Success(name_binding), _) if !name_binding.is_import() &&\n+                                           directive.is_public &&\n+                                           !name_binding.is_public() => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"Consider marking `{}` as `pub` in the imported module\",\n                                         source);\n@@ -481,8 +415,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success((_, ref name_binding))) if !type_used_reexport &&\n-                                                    directive.is_public => {\n+            (_, &Success(name_binding)) if !name_binding.is_import() && directive.is_public => {\n                 if !name_binding.is_public() {\n                     let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                     let note_msg =\n@@ -504,120 +437,47 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => {}\n         }\n \n-        let mut lev_suggestion = \"\".to_owned();\n         match (&value_result, &type_result) {\n             (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n             (&Failed(_), &Failed(_)) => {\n                 let children = target_module.children.borrow();\n                 let names = children.keys().map(|&(ref name, _)| name);\n-                if let Some(name) = find_best_match_for_name(names, &source.as_str(), None) {\n-                    lev_suggestion = format!(\". Did you mean to use `{}`?\", name);\n-                } else {\n-                    let resolutions = target_module.import_resolutions.borrow();\n-                    let names = resolutions.keys().map(|&(ref name, _)| name);\n-                    if let Some(name) = find_best_match_for_name(names,\n-                                                                 &source.as_str(),\n-                                                                 None) {\n-                        lev_suggestion =\n-                            format!(\". Did you mean to use the re-exported import `{}`?\", name);\n-                    }\n-                }\n+                let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n+                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n+                    None => \"\".to_owned(),\n+                };\n+                let msg = format!(\"There is no `{}` in `{}`{}\",\n+                                  source,\n+                                  module_to_string(target_module), lev_suggestion);\n+                return Failed(Some((directive.span, msg)));\n             }\n             _ => (),\n         }\n \n-        let mut value_used_public = false;\n-        let mut type_used_public = false;\n-\n-        // We've successfully resolved the import. Write the results in.\n-        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-\n-        {\n-            let mut check_and_write_import = |namespace, result, used_public: &mut bool| {\n-                let result: &ResolveResult<(Module<'b>, NameBinding)> = result;\n-\n-                let import_resolution = import_resolutions.get_mut(&(target, namespace)).unwrap();\n-                let namespace_name = match namespace {\n-                    TypeNS => \"type\",\n-                    ValueNS => \"value\",\n-                };\n-\n-                match *result {\n-                    Success((ref target_module, ref name_binding)) => {\n-                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n-                               namespace_name,\n-                               name_binding.def());\n-                        self.check_for_conflicting_import(&import_resolution,\n-                                                          directive.span,\n-                                                          target,\n-                                                          namespace);\n-\n-                        self.check_that_import_is_importable(&name_binding,\n-                                                             directive.span,\n-                                                             target);\n-\n-                        import_resolution.target = Some(Target::new(target_module,\n-                                                                    name_binding.clone(),\n-                                                                    directive.shadowable));\n-                        import_resolution.id = directive.id;\n-                        import_resolution.is_public = directive.is_public;\n-\n-                        self.add_export(module_, target, &import_resolution);\n-                        *used_public = name_binding.is_public();\n-                    }\n-                    Failed(_) => {\n-                        // Continue.\n-                    }\n-                    Indeterminate => {\n-                        panic!(\"{:?} result should be known at this point\", namespace_name);\n-                    }\n+        for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n+            if let Success(binding) = *result {\n+                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n+                    let msg = format!(\"`{}` is not directly importable\", target);\n+                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n \n-                self.check_for_conflicts_between_imports_and_items(module_,\n-                                                                   import_resolution,\n-                                                                   directive.span,\n-                                                                   (target, namespace));\n-            };\n-            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n-            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n-        }\n-\n-        if let (&Failed(_), &Failed(_)) = (&value_result, &type_result) {\n-            let msg = format!(\"There is no `{}` in `{}`{}\",\n-                              source,\n-                              module_to_string(target_module), lev_suggestion);\n-            return Failed(Some((directive.span, msg)));\n+                self.define(module_, target, ns, directive.import(binding));\n+            }\n         }\n \n-        let value_used_public = value_used_reexport || value_used_public;\n-        let type_used_public = type_used_reexport || type_used_public;\n-\n-        let value_def_and_priv = {\n-            let import_resolution_value = import_resolutions.get_mut(&(target, ValueNS)).unwrap();\n-            assert!(import_resolution_value.outstanding_references >= 1);\n-            import_resolution_value.outstanding_references -= 1;\n-\n-            // Record what this import resolves to for later uses in documentation,\n-            // this may resolve to either a value or a type, but for documentation\n-            // purposes it's good enough to just favor one over the other.\n-            import_resolution_value.target.as_ref().map(|target| {\n-                let def = target.binding.def().unwrap();\n-                let last_private = if value_used_public { lp } else { DependsOn(def.def_id()) };\n-                (def, last_private)\n-            })\n-        };\n-\n-        let type_def_and_priv = {\n-            let import_resolution_type = import_resolutions.get_mut(&(target, TypeNS)).unwrap();\n-            assert!(import_resolution_type.outstanding_references >= 1);\n-            import_resolution_type.outstanding_references -= 1;\n+        // Record what this import resolves to for later uses in documentation,\n+        // this may resolve to either a value or a type, but for documentation\n+        // purposes it's good enough to just favor one over the other.\n+        module_.decrement_outstanding_references_for(target, ValueNS);\n+        module_.decrement_outstanding_references_for(target, TypeNS);\n \n-            import_resolution_type.target.as_ref().map(|target| {\n-                let def = target.binding.def().unwrap();\n-                let last_private = if type_used_public { lp } else { DependsOn(def.def_id()) };\n-                (def, last_private)\n-            })\n+        let def_and_priv = |binding: &NameBinding| {\n+            let def = binding.def().unwrap();\n+            let last_private = if binding.is_public() { lp } else { DependsOn(def.def_id()) };\n+            (def, last_private)\n         };\n+        let value_def_and_priv = value_result.success().map(&def_and_priv);\n+        let type_def_and_priv = type_result.success().map(&def_and_priv);\n \n         let import_lp = LastImport {\n             value_priv: value_def_and_priv.map(|(_, p)| p),\n@@ -626,22 +486,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             type_used: Used,\n         };\n \n-        if let Some((def, _)) = value_def_and_priv {\n-            self.resolver.def_map.borrow_mut().insert(directive.id,\n-                                                      PathResolution {\n-                                                          base_def: def,\n-                                                          last_private: import_lp,\n-                                                          depth: 0,\n-                                                      });\n-        }\n-        if let Some((def, _)) = type_def_and_priv {\n-            self.resolver.def_map.borrow_mut().insert(directive.id,\n-                                                      PathResolution {\n-                                                          base_def: def,\n-                                                          last_private: import_lp,\n-                                                          depth: 0,\n-                                                      });\n-        }\n+        let write_path_resolution = |(def, _)| {\n+            let path_resolution =\n+                PathResolution { base_def: def, last_private: import_lp, depth: 0 };\n+            self.resolver.def_map.borrow_mut().insert(directive.id, path_resolution);\n+        };\n+        value_def_and_priv.map(&write_path_resolution);\n+        type_def_and_priv.map(&write_path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -654,76 +505,41 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn resolve_glob_import(&mut self,\n                            module_: Module<'b>,\n                            target_module: Module<'b>,\n-                           import_directive: &ImportDirective,\n+                           directive: &ImportDirective,\n                            lp: LastPrivate)\n                            -> ResolveResult<()> {\n-        let id = import_directive.id;\n-        let is_public = import_directive.is_public;\n-\n-        // This function works in a highly imperative manner; it eagerly adds\n-        // everything it can to the list of import resolutions of the module\n-        // node.\n-        debug!(\"(resolving glob import) resolving glob import {}\", id);\n-\n-        // We must bail out if the node has unresolved imports of any kind\n-        // (including globs).\n-        if (*target_module).pub_count.get() > 0 {\n+        // We must bail out if the node has unresolved imports of any kind (including globs).\n+        if target_module.pub_count.get() > 0 {\n             debug!(\"(resolving glob import) target module has unresolved pub imports; bailing out\");\n-            return ResolveResult::Indeterminate;\n-        }\n-\n-        // Add all resolved imports from the containing module.\n-        let import_resolutions = target_module.import_resolutions.borrow();\n-\n-        if module_.import_resolutions.borrow_state() != ::std::cell::BorrowState::Unused {\n-            // In this case, target_module == module_\n-            // This means we are trying to glob import a module into itself,\n-            // and it is a no-go\n-            debug!(\"(resolving glob imports) target module is current module; giving up\");\n-            return ResolveResult::Failed(Some((import_directive.span,\n-                                               \"Cannot glob-import a module into itself.\".into())));\n+            return Indeterminate;\n         }\n \n-        for (&(name, ns), target_import_resolution) in import_resolutions.iter() {\n-            debug!(\"(resolving glob import) writing module resolution {} into `{}`\",\n-                   name,\n-                   module_to_string(module_));\n-\n-            // Here we merge two import resolutions.\n-            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            let mut dest_import_resolution =\n-                import_resolutions.entry((name, ns))\n-                                  .or_insert_with(|| ImportResolution::new(id, is_public));\n-\n-            match target_import_resolution.target {\n-                Some(ref target) if target_import_resolution.is_public => {\n-                    self.check_for_conflicting_import(&dest_import_resolution,\n-                                                      import_directive.span,\n-                                                      name,\n-                                                      ns);\n-                    dest_import_resolution.id = id;\n-                    dest_import_resolution.is_public = is_public;\n-                    dest_import_resolution.target = Some(target.clone());\n-                    self.add_export(module_, name, &dest_import_resolution);\n-                }\n-                _ => {}\n-            }\n+        if module_.def_id() == target_module.def_id() {\n+            // This means we are trying to glob import a module into itself, and it is a no-go\n+            let msg = \"Cannot glob-import a module into itself.\".into();\n+            return Failed(Some((directive.span, msg)));\n         }\n \n         // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n-\n-        target_module.for_each_local_child(|name, ns, name_binding| {\n-            self.merge_import_resolution(module_,\n-                                         target_module,\n-                                         import_directive,\n-                                         (name, ns),\n-                                         name_binding.clone());\n+        target_module.for_each_child(|name, ns, binding| {\n+            if !binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) { return }\n+            self.define(module_, name, ns, directive.import(binding));\n+\n+            if ns == TypeNS && directive.is_public &&\n+               binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n+                                   E0364), consider declaring its enum as `pub`\", name);\n+                self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                               directive.id,\n+                                               directive.span,\n+                                               msg);\n+            }\n         });\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n-            self.resolver.def_map.borrow_mut().insert(id,\n+            self.resolver.def_map.borrow_mut().insert(directive.id,\n                                                       PathResolution {\n                                                           base_def: Def::Mod(did),\n                                                           last_private: lp,\n@@ -732,196 +548,77 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n-        return ResolveResult::Success(());\n-    }\n-\n-    fn merge_import_resolution(&mut self,\n-                               module_: Module<'b>,\n-                               containing_module: Module<'b>,\n-                               import_directive: &ImportDirective,\n-                               (name, ns): (Name, Namespace),\n-                               name_binding: NameBinding<'b>) {\n-        let id = import_directive.id;\n-        let is_public = import_directive.is_public;\n-\n-        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry((name, ns)).or_insert_with(|| {\n-            ImportResolution::new(id, is_public)\n-        });\n-\n-        debug!(\"(resolving glob import) writing resolution `{}` in `{}` to `{}`\",\n-               name,\n-               module_to_string(&*containing_module),\n-               module_to_string(module_));\n-\n-        // Merge the child item into the import resolution.\n-        let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n-\n-        if ns == TypeNS && is_public && name_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n-            let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n-                               E0364), consider declaring its enum as `pub`\", name);\n-            self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                           import_directive.id,\n-                                           import_directive.span,\n-                                           msg);\n-        }\n-\n-        if name_binding.defined_with(modifier) {\n-            let namespace_name = match ns {\n-                TypeNS => \"type\",\n-                ValueNS => \"value\",\n-            };\n-            debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n-            if dest_import_resolution.shadowable() == Shadowable::Never {\n-                let msg = format!(\"a {} named `{}` has already been imported in this module\",\n-                                 namespace_name,\n-                                 name);\n-                span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n-            } else {\n-                let target = Target::new(containing_module,\n-                                         name_binding.clone(),\n-                                         import_directive.shadowable);\n-                dest_import_resolution.target = Some(target);\n-                dest_import_resolution.id = id;\n-                dest_import_resolution.is_public = is_public;\n-                self.add_export(module_, name, &dest_import_resolution);\n-            }\n-        }\n-\n-        self.check_for_conflicts_between_imports_and_items(module_,\n-                                                           dest_import_resolution,\n-                                                           import_directive.span,\n-                                                           (name, ns));\n-    }\n-\n-    fn add_export(&mut self, module: Module<'b>, name: Name, resolution: &ImportResolution<'b>) {\n-        if !resolution.is_public { return }\n-        let node_id = match module.def_id() {\n-            Some(def_id) => self.resolver.ast_map.as_local_node_id(def_id).unwrap(),\n-            None => return,\n-        };\n-        let export = match resolution.target.as_ref().unwrap().binding.def() {\n-            Some(def) => Export { name: name, def_id: def.def_id() },\n-            None => return,\n-        };\n-        self.resolver.export_map.entry(node_id).or_insert(Vec::new()).push(export);\n+        return Success(());\n     }\n \n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicting_import(&mut self,\n-                                    import_resolution: &ImportResolution,\n-                                    import_span: Span,\n-                                    name: Name,\n-                                    namespace: Namespace) {\n-        let target = &import_resolution.target;\n-        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               name,\n-               target.is_some());\n-\n-        match *target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                let ns_word = match namespace {\n-                    TypeNS => {\n-                        match target.binding.module() {\n-                            Some(ref module) if module.is_normal() => \"module\",\n-                            Some(ref module) if module.is_trait() => \"trait\",\n-                            _ => \"type\",\n-                        }\n-                    }\n-                    ValueNS => \"value\",\n-                };\n-                let use_id = import_resolution.id;\n-                let item = self.resolver.ast_map.expect_item(use_id);\n-                let mut err = struct_span_err!(self.resolver.session,\n-                                               import_span,\n-                                               E0252,\n-                                               \"a {} named `{}` has already been imported \\\n-                                                in this module\",\n-                                               ns_word,\n-                                               name);\n-                span_note!(&mut err,\n-                           item.span,\n-                           \"previous import of `{}` here\",\n-                           name);\n-                err.emit();\n+    fn define(&mut self,\n+              parent: Module<'b>,\n+              name: Name,\n+              ns: Namespace,\n+              binding: NameBinding<'b>) {\n+        let binding = self.resolver.new_name_binding(binding);\n+        if let Err(old_binding) = parent.try_define_child(name, ns, binding) {\n+            self.report_conflict(name, ns, binding, old_binding);\n+        } else if binding.is_public() { // Add to the export map\n+            if let (Some(parent_def_id), Some(def)) = (parent.def_id(), binding.def()) {\n+                let parent_node_id = self.resolver.ast_map.as_local_node_id(parent_def_id).unwrap();\n+                let export = Export { name: name, def_id: def.def_id() };\n+                self.resolver.export_map.entry(parent_node_id).or_insert(Vec::new()).push(export);\n             }\n-            Some(_) | None => {}\n         }\n     }\n \n-    /// Checks that an import is actually importable\n-    fn check_that_import_is_importable(&mut self,\n-                                       name_binding: &NameBinding,\n-                                       import_span: Span,\n-                                       name: Name) {\n-        if !name_binding.defined_with(DefModifiers::IMPORTABLE) {\n-            let msg = format!(\"`{}` is not directly importable\", name);\n-            span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n-        }\n-    }\n-\n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicts_between_imports_and_items(&mut self,\n-                                                     module: Module<'b>,\n-                                                     import: &ImportResolution<'b>,\n-                                                     import_span: Span,\n-                                                     (name, ns): (Name, Namespace)) {\n-        // Check for item conflicts.\n-        let name_binding = match module.get_child(name, ns) {\n-            None => {\n-                // There can't be any conflicts.\n-                return;\n-            }\n-            Some(name_binding) => name_binding,\n-        };\n-\n-        if ns == ValueNS {\n-            match import.target {\n-                Some(ref target) if target.shadowable != Shadowable::Always => {\n-                    let mut err = struct_span_err!(self.resolver.session,\n-                                                   import_span,\n-                                                   E0255,\n-                                                   \"import `{}` conflicts with \\\n-                                                    value in this module\",\n-                                                   name);\n-                    if let Some(span) = name_binding.span {\n-                        err.span_note(span, \"conflicting value here\");\n-                    }\n-                    err.emit();\n-                }\n-                Some(_) | None => {}\n-            }\n-        } else {\n-            match import.target {\n-                Some(ref target) if target.shadowable != Shadowable::Always => {\n-                    if name_binding.is_extern_crate() {\n-                        let msg = format!(\"import `{0}` conflicts with imported crate \\\n-                                           in this module (maybe you meant `use {0}::*`?)\",\n-                                          name);\n-                        span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n-                        return;\n-                    }\n-\n-                    let (what, note) = match name_binding.module() {\n-                        Some(ref module) if module.is_normal() =>\n-                            (\"existing submodule\", \"note conflicting module here\"),\n-                        Some(ref module) if module.is_trait() =>\n-                            (\"trait in this module\", \"note conflicting trait here\"),\n-                        _ => (\"type in this module\", \"note conflicting type here\"),\n-                    };\n-                    let mut err = struct_span_err!(self.resolver.session,\n-                                                   import_span,\n-                                                   E0256,\n-                                                   \"import `{}` conflicts with {}\",\n-                                                   name,\n-                                                   what);\n-                    if let Some(span) = name_binding.span {\n-                        err.span_note(span, note);\n-                    }\n-                    err.emit();\n-                }\n-                Some(_) | None => {}\n-            }\n+    fn report_conflict(&mut self,\n+                       name: Name,\n+                       ns: Namespace,\n+                       binding: &'b NameBinding<'b>,\n+                       old_binding: &'b NameBinding<'b>) {\n+        if old_binding.is_extern_crate() {\n+            let msg = format!(\"import `{0}` conflicts with imported crate \\\n+                               in this module (maybe you meant `use {0}::*`?)\",\n+                              name);\n+            span_err!(self.resolver.session, binding.span.unwrap(), E0254, \"{}\", &msg);\n+        } else if old_binding.is_import() {\n+            let ns_word = match (ns, old_binding.module()) {\n+                (ValueNS, _) => \"value\",\n+                (TypeNS, Some(module)) if module.is_normal() => \"module\",\n+                (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n+                (TypeNS, _) => \"type\",\n+            };\n+            let mut err = struct_span_err!(self.resolver.session,\n+                                           binding.span.unwrap(),\n+                                           E0252,\n+                                           \"a {} named `{}` has already been imported \\\n+                                            in this module\",\n+                                           ns_word,\n+                                           name);\n+            err.span_note(old_binding.span.unwrap(),\n+                          &format!(\"previous import of `{}` here\", name));\n+            err.emit();\n+        } else if ns == ValueNS { // Check for item conflicts in the value namespace\n+            let mut err = struct_span_err!(self.resolver.session,\n+                                           binding.span.unwrap(),\n+                                           E0255,\n+                                           \"import `{}` conflicts with value in this module\",\n+                                           name);\n+            err.span_note(old_binding.span.unwrap(), \"conflicting value here\");\n+            err.emit();\n+        } else { // Check for item conflicts in the type namespace\n+            let (what, note) = match old_binding.module() {\n+                Some(ref module) if module.is_normal() =>\n+                    (\"existing submodule\", \"note conflicting module here\"),\n+                Some(ref module) if module.is_trait() =>\n+                    (\"trait in this module\", \"note conflicting trait here\"),\n+                _ => (\"type in this module\", \"note conflicting type here\"),\n+            };\n+            let mut err = struct_span_err!(self.resolver.session,\n+                                           binding.span.unwrap(),\n+                                           E0256,\n+                                           \"import `{}` conflicts with {}\",\n+                                           name,\n+                                           what);\n+            err.span_note(old_binding.span.unwrap(), note);\n+            err.emit();\n         }\n     }\n }"}, {"sha": "923f95e69d122bb417f7361c34126658c10ffcc2", "filename": "src/test/compile-fail/double-type-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs?ref=1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "patch": "@@ -20,5 +20,5 @@ mod foo {\n }\n \n fn main() {\n-    let _ = foo::X; //~ ERROR unresolved name `foo::X`\n+    let _ = foo::X;\n }"}, {"sha": "b60d19fcab4aac6152f28133e3d10ed40bded478", "filename": "src/test/compile-fail/unresolved-import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de70d33f7baf12978cfb3de861e61b2a5d6fca7/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs?ref=1de70d33f7baf12978cfb3de861e61b2a5d6fca7", "patch": "@@ -14,9 +14,9 @@ use foo::bar; //~ ERROR unresolved import `foo::bar`. Maybe a missing `extern cr\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz`. There is no `Baz` in `bar`. Did you mean to use `Bar`?\n \n-use food::baz; //~ ERROR unresolved import `food::baz`. There is no `baz` in `food`. Did you mean to use the re-exported import `bag`?\n+use food::baz; //~ ERROR unresolved import `food::baz`. There is no `baz` in `food`. Did you mean to use `bag`?\n \n-use food::{beens as Foo}; //~ ERROR unresolved import `food::beens`. There is no `beens` in `food`. Did you mean to use the re-exported import `beans`?\n+use food::{beens as Foo}; //~ ERROR unresolved import `food::beens`. There is no `beens` in `food`. Did you mean to use `beans`?\n \n mod bar {\n     pub struct Bar;"}]}