{"sha": "e4c3000e5bf254ab19895b7a62413ff0d346d337", "node_id": "C_kwDOAAsO6NoAKGU0YzMwMDBlNWJmMjU0YWIxOTg5NWI3YTYyNDEzZmYwZDM0NmQzMzc", "commit": {"author": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-09-23T07:51:10Z"}, "committer": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-01T18:04:20Z"}, "message": "Initial implementation", "tree": {"sha": "12d72583190aea7b544e02164048f092f57d331c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12d72583190aea7b544e02164048f092f57d331c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4c3000e5bf254ab19895b7a62413ff0d346d337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c3000e5bf254ab19895b7a62413ff0d346d337", "html_url": "https://github.com/rust-lang/rust/commit/e4c3000e5bf254ab19895b7a62413ff0d346d337", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4c3000e5bf254ab19895b7a62413ff0d346d337/comments", "author": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe999e88edd2254124be6419607bd29156841f59", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe999e88edd2254124be6419607bd29156841f59", "html_url": "https://github.com/rust-lang/rust/commit/fe999e88edd2254124be6419607bd29156841f59"}], "stats": {"total": 225, "additions": 225, "deletions": 0}, "files": [{"sha": "df3fa2866c2d1694b1e3ebfa49fcb677a66070d0", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3000e5bf254ab19895b7a62413ff0d346d337/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3000e5bf254ab19895b7a62413ff0d346d337/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=e4c3000e5bf254ab19895b7a62413ff0d346d337", "patch": "@@ -2898,6 +2898,7 @@ Released 2018-09-13\n [`no_effect`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect\n [`non_ascii_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_ascii_literal\n [`non_octal_unix_permissions`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_octal_unix_permissions\n+[`non_send_field_in_send_ty`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_send_field_in_send_ty\n [`nonminimal_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonminimal_bool\n [`nonsensical_open_options`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonsensical_open_options\n [`nonstandard_macro_braces`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonstandard_macro_braces"}, {"sha": "1d9d2be34430f0fc19b801d8990fc484dd4bda0c", "filename": "clippy_lints/src/lib.mods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.mods.rs?ref=e4c3000e5bf254ab19895b7a62413ff0d346d337", "patch": "@@ -149,6 +149,7 @@ mod no_effect;\n mod non_copy_const;\n mod non_expressive_names;\n mod non_octal_unix_permissions;\n+mod non_send_field_in_send_ty;\n mod nonstandard_macro_braces;\n mod open_options;\n mod option_env_unwrap;"}, {"sha": "b1cd5aafe4c90bc53b49bfdfe409b71dfaebec52", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=e4c3000e5bf254ab19895b7a62413ff0d346d337", "patch": "@@ -366,6 +366,7 @@ store.register_lints(&[\n     non_expressive_names::MANY_SINGLE_CHAR_NAMES,\n     non_expressive_names::SIMILAR_NAMES,\n     non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS,\n+    non_send_field_in_send_ty::NON_SEND_FIELD_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     option_env_unwrap::OPTION_ENV_UNWRAP,"}, {"sha": "56b4f9d239132ed384a005ca6259cfc20b75ada0", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=e4c3000e5bf254ab19895b7a62413ff0d346d337", "patch": "@@ -16,6 +16,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n     LintId::of(mutex_atomic::MUTEX_INTEGER),\n+    LintId::of(non_send_field_in_send_ty::NON_SEND_FIELD_IN_SEND_TY),\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n     LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n     LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),"}, {"sha": "93b93bcba488b1169be7be250e45b7658145c783", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e4c3000e5bf254ab19895b7a62413ff0d346d337", "patch": "@@ -535,6 +535,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(feature_name::FeatureName));\n     store.register_late_pass(move || Box::new(iter_not_returning_iterator::IterNotReturningIterator));\n     store.register_late_pass(move || Box::new(if_then_panic::IfThenPanic));\n+    store.register_late_pass(|| Box::new(non_send_field_in_send_ty::NonSendFieldInSendTy));\n }\n \n #[rustfmt::skip]"}, {"sha": "5d6501196cd5ef65a5adcdfc36faa9aa817b03b4", "filename": "clippy_lints/src/non_send_field_in_send_ty.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Fnon_send_field_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3000e5bf254ab19895b7a62413ff0d346d337/clippy_lints%2Fsrc%2Fnon_send_field_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_send_field_in_send_ty.rs?ref=e4c3000e5bf254ab19895b7a62413ff0d346d337", "patch": "@@ -0,0 +1,126 @@\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note};\n+use clippy_utils::ty::{implements_trait, is_copy};\n+use rustc_ast::ImplPolarity;\n+use rustc_hir::{Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Warns about a field in a `Send` struct that is neither `Send` nor `Copy`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Sending the struct to another thread and drops it there will also drop\n+    /// the field in the new thread. This effectively changes the ownership of\n+    /// the field type to the new thread and creates a soundness issue by\n+    /// breaking breaks the non-`Send` invariant.\n+    ///\n+    /// ### Known Problems\n+    /// Data structures that contain raw pointers may cause false positives.\n+    /// They are sometimes safe to be sent across threads but do not implement\n+    /// the `Send` trait. This lint has a heuristic to filter out basic cases\n+    /// such as `Vec<*const T>`, but it's not perfect.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::sync::Arc;\n+    ///\n+    /// // There is no `RC: Send` bound here\n+    /// unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}\n+    ///\n+    /// #[derive(Debug, Clone)]\n+    /// pub struct ArcGuard<RC, T> {\n+    ///     inner: T,\n+    ///     // Possibly drops `Arc<RC>` (and in turn `RC`) on a wrong thread\n+    ///     head: Arc<RC>\n+    /// }\n+    /// ```\n+    pub NON_SEND_FIELD_IN_SEND_TY,\n+    nursery,\n+    \"a field in a `Send` struct does not implement `Send`\"\n+}\n+\n+declare_lint_pass!(NonSendFieldInSendTy => [NON_SEND_FIELD_IN_SEND_TY]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let send_trait = cx.tcx.get_diagnostic_item(sym::send_trait).unwrap();\n+\n+        // Check if we are in `Send` impl item\n+        if_chain! {\n+            if let ItemKind::Impl(hir_impl) = &item.kind;\n+            if let Some(trait_ref) = &hir_impl.of_trait;\n+            if let Some(trait_id) = trait_ref.trait_def_id();\n+            if send_trait == trait_id;\n+            if let ImplPolarity::Positive = hir_impl.polarity;\n+            if let Some(ty_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n+            if let self_ty = ty_trait_ref.self_ty();\n+            if let ty::Adt(adt_def, impl_trait_substs) = self_ty.kind();\n+            then {\n+                for variant in &adt_def.variants {\n+                    for field in &variant.fields {\n+                        let field_ty = field.ty(cx.tcx, impl_trait_substs);\n+\n+                        // TODO: substs rebase_onto\n+\n+                        if raw_pointer_in_ty_def(cx, field_ty)\n+                            || implements_trait(cx, field_ty, send_trait, &[])\n+                            || is_copy(cx, field_ty)\n+                        {\n+                            continue;\n+                        }\n+\n+                        if let Some(field_span) = cx.tcx.hir().span_if_local(field.did) {\n+                            if is_ty_param(field_ty) {\n+                                span_lint_and_help(\n+                                    cx,\n+                                    NON_SEND_FIELD_IN_SEND_TY,\n+                                    field_span,\n+                                    \"a field in a `Send` struct does not implement `Send`\",\n+                                    Some(item.span),\n+                                    &format!(\"add `{}: Send` in `Send` impl for `{}`\", field_ty, self_ty),\n+                                )\n+                            } else {\n+                                span_lint_and_note(\n+                                    cx,\n+                                    NON_SEND_FIELD_IN_SEND_TY,\n+                                    field_span,\n+                                    \"a field in a `Send` struct does not implement `Send`\",\n+                                    Some(item.span),\n+                                    &format!(\n+                                        \"type `{}` doesn't implement `Send` when `{}` is `Send`\",\n+                                        field_ty, self_ty\n+                                    ),\n+                                )\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns `true` if the type itself is a raw pointer or has a raw pointer as a\n+/// generic parameter, e.g., `Vec<*const u8>`.\n+/// Note that it does not look into enum variants or struct fields.\n+fn raw_pointer_in_ty_def<'tcx>(cx: &LateContext<'tcx>, target_ty: Ty<'tcx>) -> bool {\n+    for ty_node in target_ty.walk(cx.tcx) {\n+        if_chain! {\n+            if let GenericArgKind::Type(inner_ty) = ty_node.unpack();\n+            if let ty::RawPtr(_) = inner_ty.kind();\n+            then {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+/// Returns `true` if the type is a type parameter such as `T`.\n+fn is_ty_param<'tcx>(target_ty: Ty<'tcx>) -> bool {\n+    matches!(target_ty.kind(), ty::Param(_))\n+}"}, {"sha": "a0c574f8e59d14aa3ff665eb1d89066a09c1cd5d", "filename": "tests/ui/non_send_field_in_send_ty.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3000e5bf254ab19895b7a62413ff0d346d337/tests%2Fui%2Fnon_send_field_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3000e5bf254ab19895b7a62413ff0d346d337/tests%2Fui%2Fnon_send_field_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_send_field_in_send_ty.rs?ref=e4c3000e5bf254ab19895b7a62413ff0d346d337", "patch": "@@ -0,0 +1,94 @@\n+#![warn(clippy::non_send_field_in_send_ty)]\n+#![feature(extern_types)]\n+\n+use std::cell::UnsafeCell;\n+use std::ptr::NonNull;\n+use std::sync::{Arc, Mutex};\n+\n+// disrustor / RUSTSEC-2020-0150\n+pub struct RingBuffer<T> {\n+    data: Vec<UnsafeCell<T>>,\n+    capacity: usize,\n+    mask: usize,\n+}\n+\n+unsafe impl<T> Send for RingBuffer<T> {}\n+\n+// noise_search / RUSTSEC-2020-0141\n+pub struct MvccRwLock<T> {\n+    raw: *const T,\n+    lock: Mutex<Box<T>>,\n+}\n+\n+unsafe impl<T> Send for MvccRwLock<T> {}\n+\n+// async-coap / RUSTSEC-2020-0124\n+pub struct ArcGuard<RC, T> {\n+    inner: T,\n+    head: Arc<RC>,\n+}\n+\n+unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}\n+\n+// rusb / RUSTSEC-2020-0098\n+extern \"C\" {\n+    type libusb_device_handle;\n+}\n+\n+pub trait UsbContext {\n+    // some user trait that does not guarantee `Send`\n+}\n+\n+pub struct DeviceHandle<T: UsbContext> {\n+    context: T,\n+    handle: NonNull<libusb_device_handle>,\n+}\n+\n+unsafe impl<T: UsbContext> Send for DeviceHandle<T> {}\n+\n+// Raw pointers are allowed\n+extern \"C\" {\n+    type SomeFfiType;\n+}\n+\n+pub struct FpTest {\n+    vec: Vec<*const SomeFfiType>,\n+}\n+\n+unsafe impl Send for FpTest {}\n+\n+// Check raw pointer false positive\n+#[allow(clippy::non_send_field_in_send_ty)]\n+pub struct AttrTest1<T>(T);\n+\n+pub struct AttrTest2<T> {\n+    #[allow(clippy::non_send_field_in_send_ty)]\n+    field: T,\n+}\n+\n+pub enum AttrTest3<T> {\n+    #[allow(clippy::non_send_field_in_send_ty)]\n+    Enum1(T),\n+    Enum2(T),\n+}\n+\n+unsafe impl<T> Send for AttrTest1<T> {}\n+unsafe impl<T> Send for AttrTest2<T> {}\n+unsafe impl<T> Send for AttrTest3<T> {}\n+\n+pub struct MultiField<T> {\n+    field1: T,\n+    field2: T,\n+    field3: T,\n+}\n+\n+unsafe impl<T> Send for MultiField<T> {}\n+\n+pub enum MyOption<T> {\n+    MySome(T),\n+    MyNone,\n+}\n+\n+unsafe impl<T> Send for MyOption<T> {}\n+\n+fn main() {}"}]}