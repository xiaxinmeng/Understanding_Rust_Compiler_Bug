{"sha": "4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYjBjNTg4ZmYzYWRiOGU5YmY0MjA5YjU5ZTA4ZjkwZmUyODE5MDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-15T21:47:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-18T17:27:35Z"}, "message": "Switch the code to use De Bruijn indices rather than binder-ids.", "tree": {"sha": "2662099e242889e6c6ecff2a5229df96c70457b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2662099e242889e6c6ecff2a5229df96c70457b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "html_url": "https://github.com/rust-lang/rust/commit/4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23652efffb32de3f2babcb6204f49268b19cc0e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/23652efffb32de3f2babcb6204f49268b19cc0e6", "html_url": "https://github.com/rust-lang/rust/commit/23652efffb32de3f2babcb6204f49268b19cc0e6"}], "stats": {"total": 1618, "additions": 1071, "deletions": 547}, "files": [{"sha": "69be2e34915265666f65db69851240ddf570b53d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -294,7 +294,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     match next(st) {\n       'b' => {\n         assert_eq!(next(st), '[');\n-        let id = parse_uint(st) as ast::NodeId;\n+        let id = ty::DebruijnIndex::new(parse_uint(st));\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n@@ -579,8 +579,6 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n \n fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n-    let id = parse_uint(st) as ast::NodeId;\n-    assert_eq!(next(st), '|');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n         inputs.push(parse_ty(st, |x,y| conv(x,y)));\n@@ -598,8 +596,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n         }\n         _ => ty::FnConverging(parse_ty(st, |x,y| conv(x,y)))\n     };\n-    ty::FnSig {binder_id: id,\n-               inputs: inputs,\n+    ty::FnSig {inputs: inputs,\n                output: output,\n                variadic: variadic}\n }"}, {"sha": "a53f5fa187df28b74fc7141533817eca439b5f24", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -130,7 +130,7 @@ fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Regio\n pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n-            mywrite!(w, \"b[{}|\", id);\n+            mywrite!(w, \"b[{}|\", id.depth);\n             enc_bound_region(w, cx, br);\n             mywrite!(w, \"]\");\n         }\n@@ -331,7 +331,7 @@ pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy)\n }\n \n fn enc_fn_sig(w: &mut SeekableMemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n-    mywrite!(w, \"[{}|\", fsig.binder_id);\n+    mywrite!(w, \"[\");\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }"}, {"sha": "ff6965574be922cf528048edd135b9c4a64518cf", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -483,8 +483,8 @@ impl tr for def::Def {\n impl tr for ty::Region {\n     fn tr(&self, dcx: &DecodeContext) -> ty::Region {\n         match *self {\n-            ty::ReLateBound(id, br) => {\n-                ty::ReLateBound(dcx.tr_id(id), br.tr(dcx))\n+            ty::ReLateBound(debruijn, br) => {\n+                ty::ReLateBound(debruijn, br.tr(dcx))\n             }\n             ty::ReEarlyBound(id, space, index, ident) => {\n                 ty::ReEarlyBound(dcx.tr_id(id), space, index, ident)"}, {"sha": "7b2ff6d4b7db42b8817e621a57411874f33bbf89", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -39,8 +39,7 @@ pub enum DefRegion {\n     DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n                         /* index */ uint,\n                         /* lifetime decl */ ast::NodeId),\n-    DefLateBoundRegion(/* binder_id */ ast::NodeId,\n-                       /* depth */ uint,\n+    DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n     DefFreeRegion(/* block scope */ ast::NodeId,\n                   /* lifetime decl */ ast::NodeId),\n@@ -60,9 +59,9 @@ enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n     EarlyScope(subst::ParamSpace, &'a Vec<ast::LifetimeDef>, Scope<'a>),\n-    /// LateScope(binder_id, ['a, 'b, ...], s) extends s with late-bound\n+    /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n-    LateScope(ast::NodeId, &'a Vec<ast::LifetimeDef>, Scope<'a>),\n+    LateScope(&'a Vec<ast::LifetimeDef>, Scope<'a>),\n     /// lifetimes introduced by items within a code block are scoped\n     /// to that block.\n     BlockScope(ast::NodeId, Scope<'a>),\n@@ -115,12 +114,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, n: ast::NodeId) {\n+                b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n                 self.visit_early_late(\n-                    subst::FnSpace, n, generics,\n+                    subst::FnSpace, generics,\n                     |this| visit::walk_fn(this, fk, fd, b, s))\n             }\n             visit::FkFnBlock(..) => {\n@@ -130,21 +129,37 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        let lifetimes = match ty.node {\n-            ast::TyClosure(ref c) | ast::TyProc(ref c) => &c.lifetimes,\n-            ast::TyBareFn(ref c) => &c.lifetimes,\n-            _ => return visit::walk_ty(self, ty)\n-        };\n-\n-        self.with(LateScope(ty.id, lifetimes, self.scope), |this| {\n-            this.check_lifetime_defs(lifetimes);\n-            visit::walk_ty(this, ty);\n-        });\n+        match ty.node {\n+            ast::TyClosure(ref c) | ast::TyProc(ref c) => {\n+                // Careful, the bounds on a closure/proc are *not* within its binder.\n+                visit::walk_ty_param_bounds_helper(self, &c.bounds);\n+                visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n+                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n+                    this.check_lifetime_defs(&c.lifetimes);\n+                    for argument in c.decl.inputs.iter() {\n+                        this.visit_ty(&*argument.ty)\n+                    }\n+                    visit::walk_fn_ret_ty(this, &c.decl.output);\n+                });\n+            }\n+            ast::TyBareFn(ref c) => {\n+                visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n+                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n+                    // a bare fn has no bounds, so everything\n+                    // contained within is scoped within its binder.\n+                    this.check_lifetime_defs(&c.lifetimes);\n+                    visit::walk_ty(this, ty);\n+                });\n+            }\n+            _ => {\n+                visit::walk_ty(self, ty)\n+            }\n+        }\n     }\n \n     fn visit_ty_method(&mut self, m: &ast::TypeMethod) {\n         self.visit_early_late(\n-            subst::FnSpace, m.id, &m.generics,\n+            subst::FnSpace, &m.generics,\n             |this| visit::walk_ty_method(this, m))\n     }\n \n@@ -216,11 +231,25 @@ impl<'a> LifetimeContext<'a> {\n     fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n         self.visit_path(&trait_ref.path, trait_ref.ref_id);\n     }\n+}\n+\n+impl<'a> LifetimeContext<'a> {\n+    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n+        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n+        let mut this = LifetimeContext {\n+            sess: sess,\n+            named_region_map: *named_region_map,\n+            scope: &wrap_scope,\n+            def_map: self.def_map,\n+        };\n+        debug!(\"entering scope {}\", this.scope);\n+        f(&mut this);\n+        debug!(\"exiting scope {}\", this.scope);\n+    }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_early_late(&mut self,\n                         early_space: subst::ParamSpace,\n-                        binder_id: ast::NodeId,\n                         generics: &ast::Generics,\n                         walk: |&mut LifetimeContext|) {\n         /*!\n@@ -249,15 +278,14 @@ impl<'a> LifetimeContext<'a> {\n \n         let referenced_idents = early_bound_lifetime_names(generics);\n \n-        debug!(\"visit_early_late: binder_id={} referenced_idents={}\",\n-               binder_id,\n+        debug!(\"visit_early_late: referenced_idents={}\",\n                referenced_idents);\n \n         let (early, late) = generics.lifetimes.clone().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n         self.with(EarlyScope(early_space, &early, self.scope), |this| {\n-            this.with(LateScope(binder_id, &late, this.scope), |this| {\n+            this.with(LateScope(&late, this.scope), |this| {\n                 this.check_lifetime_defs(&generics.lifetimes);\n                 walk(this);\n             });\n@@ -271,7 +299,7 @@ impl<'a> LifetimeContext<'a> {\n         // block, then the lifetime is not bound but free, so switch\n         // over to `resolve_free_lifetime_ref()` to complete the\n         // search.\n-        let mut depth = 0;\n+        let mut late_depth = 0;\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n@@ -291,22 +319,22 @@ impl<'a> LifetimeContext<'a> {\n                             return;\n                         }\n                         None => {\n-                            depth += 1;\n                             scope = s;\n                         }\n                     }\n                 }\n \n-                LateScope(binder_id, lifetimes, s) => {\n+                LateScope(lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((_index, decl_id)) => {\n-                            let def = DefLateBoundRegion(binder_id, depth, decl_id);\n+                            let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n+                            let def = DefLateBoundRegion(debruijn, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n \n                         None => {\n-                            depth += 1;\n+                            late_depth += 1;\n                             scope = s;\n                         }\n                     }\n@@ -339,7 +367,7 @@ impl<'a> LifetimeContext<'a> {\n                 }\n \n                 EarlyScope(_, lifetimes, s) |\n-                LateScope(_, lifetimes, s) => {\n+                LateScope(lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n                         break;\n@@ -517,7 +545,7 @@ impl<'a> fmt::Show for ScopeChain<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({}, {})\", space, defs),\n-            LateScope(id, defs, _) => write!(fmt, \"LateScope({}, {})\", id, defs),\n+            LateScope(defs, _) => write!(fmt, \"LateScope({})\", defs),\n             BlockScope(id, _) => write!(fmt, \"BlockScope({})\", id),\n             RootScope => write!(fmt, \"RootScope\"),\n         }"}, {"sha": "ae7cb8645e112ea00e541d7d68b7a6cc7bb5a83e", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 107, "deletions": 30, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -14,8 +14,7 @@ pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n use middle::ty;\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFoldable, TypeFolder};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n@@ -506,11 +505,22 @@ struct SubstFolder<'a, 'tcx: 'a> {\n \n     // Depth of type stack\n     ty_stack_depth: uint,\n+\n+    // Number of region binders we have passed through while doing the substitution\n+    region_binders_passed: uint,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n+    fn enter_region_binder(&mut self) {\n+        self.region_binders_passed += 1;\n+    }\n+\n+    fn exit_region_binder(&mut self) {\n+        self.region_binders_passed -= 1;\n+    }\n+\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n@@ -524,7 +534,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     ErasedRegions => ty::ReStatic,\n                     NonerasedRegions(ref regions) =>\n                         match regions.opt_get(space, i) {\n-                            Some(t) => *t,\n+                            Some(&r) => {\n+                                self.shift_region_through_binders(r)\n+                            }\n                             None => {\n                                 let span = self.span.unwrap_or(DUMMY_SP);\n                                 self.tcx().sess.span_bug(\n@@ -557,12 +569,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n \n         let t1 = match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                check(self,\n-                      p,\n-                      t,\n-                      self.substs.types.opt_get(p.space, p.idx),\n-                      p.space,\n-                      p.idx)\n+                self.ty_for_param(p, t)\n             }\n             _ => {\n                 ty_fold::super_fold_ty(self, t)\n@@ -576,30 +583,100 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n \n         return t1;\n+    }\n+}\n \n-        fn check(this: &SubstFolder,\n-                 p: ty::ParamTy,\n-                 source_ty: ty::t,\n-                 opt_ty: Option<&ty::t>,\n-                 space: ParamSpace,\n-                 index: uint)\n-                 -> ty::t {\n-            match opt_ty {\n-                Some(t) => *t,\n-                None => {\n-                    let span = this.span.unwrap_or(DUMMY_SP);\n-                    this.tcx().sess.span_bug(\n-                        span,\n-                        format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n+impl<'a,'tcx> SubstFolder<'a,'tcx> {\n+    fn ty_for_param(&self, p: ty::ParamTy, source_ty: ty::t) -> ty::t {\n+        // Look up the type in the substitutions. It really should be in there.\n+        let opt_ty = self.substs.types.opt_get(p.space, p.idx);\n+        let ty = match opt_ty {\n+            Some(t) => *t,\n+            None => {\n+                let span = self.span.unwrap_or(DUMMY_SP);\n+                self.tcx().sess.span_bug(\n+                    span,\n+                    format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n                                  when substituting (root type={}) substs={}\",\n-                                p.repr(this.tcx()),\n-                                source_ty.repr(this.tcx()),\n-                                space,\n-                                index,\n-                                this.root_ty.repr(this.tcx()),\n-                                this.substs.repr(this.tcx())).as_slice());\n-                }\n+                            p.repr(self.tcx()),\n+                            source_ty.repr(self.tcx()),\n+                            p.space,\n+                            p.idx,\n+                            self.root_ty.repr(self.tcx()),\n+                            self.substs.repr(self.tcx())).as_slice());\n             }\n+        };\n+\n+        self.shift_regions_through_binders(ty)\n+    }\n+\n+    fn shift_regions_through_binders(&self, ty: ty::t) -> ty::t {\n+        /*!\n+         * It is sometimes necessary to adjust the debruijn indices\n+         * during substitution. This occurs when we are substituting a\n+         * type with escaping regions into a context where we have\n+         * passed through region binders. That's quite a\n+         * mouthful. Let's see an example:\n+         *\n+         * ```\n+         * type Func<A> = fn(A);\n+         * type MetaFunc = for<'a> fn(Func<&'a int>)\n+         * ```\n+         *\n+         * The type `MetaFunc`, when fully expanded, will be\n+         *\n+         *     for<'a> fn(fn(&'a int))\n+         *             ^~ ^~ ^~~\n+         *             |  |  |\n+         *             |  |  DebruijnIndex of 2\n+         *             Binders\n+         *\n+         * Here the `'a` lifetime is bound in the outer function, but\n+         * appears as an argument of the inner one. Therefore, that\n+         * appearance will have a DebruijnIndex of 2, because we must\n+         * skip over the inner binder (remember that we count Debruijn\n+         * indices from 1). However, in the definition of `MetaFunc`,\n+         * the binder is not visible, so the type `&'a int` will have\n+         * a debruijn index of 1. It's only during the substitution\n+         * that we can see we must increase the depth by 1 to account\n+         * for the binder that we passed through.\n+         *\n+         * As a second example, consider this twist:\n+         *\n+         * ```\n+         * type FuncTuple<A> = (A,fn(A));\n+         * type MetaFuncTuple = for<'a> fn(FuncTuple<&'a int>)\n+         * ```\n+         *\n+         * Here the final type will be:\n+         *\n+         *     for<'a> fn((&'a int, fn(&'a int)))\n+         *                 ^~~         ^~~\n+         *                 |           |\n+         *          DebruijnIndex of 1 |\n+         *                      DebruijnIndex of 2\n+         *\n+         * As indicated in the diagram, here the same type `&'a int`\n+         * is substituted once, but in the first case we do not\n+         * increase the Debruijn index and in the second case we\n+         * do. The reason is that only in the second case have we\n+         * passed through a fn binder.\n+         */\n+\n+        debug!(\"shift_regions(ty={}, region_binders_passed={}, type_has_escaping_regions={})\",\n+               ty.repr(self.tcx()), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n+\n+        if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n+            return ty;\n         }\n+\n+        let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n+        debug!(\"shift_regions: shifted result = {}\", result.repr(self.tcx()));\n+\n+        result\n+    }\n+\n+    fn shift_region_through_binders(&self, region: ty::Region) -> ty::Region {\n+        ty_fold::shift_region(region, self.region_binders_passed)\n     }\n }"}, {"sha": "a322fcb3fa118481f65ee30e50d32be3752466a7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 406, "deletions": 115, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -53,7 +53,7 @@ use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::typeck;\n-use middle::ty_fold::{mod, TypeFoldable,TypeFolder};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder, HigherRankedFoldable};\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n@@ -609,13 +609,14 @@ pub struct ctxt<'tcx> {\n // recursing over the type itself.\n bitflags! {\n     flags TypeFlags: u32 {\n-        const NO_TYPE_FLAGS = 0b0,\n-        const HAS_PARAMS    = 0b1,\n-        const HAS_SELF      = 0b10,\n-        const HAS_TY_INFER  = 0b100,\n-        const HAS_RE_INFER  = 0b1000,\n-        const HAS_REGIONS   = 0b10000,\n-        const HAS_TY_ERR    = 0b100000,\n+        const NO_TYPE_FLAGS       = 0b0,\n+        const HAS_PARAMS          = 0b1,\n+        const HAS_SELF            = 0b10,\n+        const HAS_TY_INFER        = 0b100,\n+        const HAS_RE_INFER        = 0b1000,\n+        const HAS_RE_LATE_BOUND   = 0b10000,\n+        const HAS_REGIONS         = 0b100000,\n+        const HAS_TY_ERR          = 0b1000000,\n         const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n     }\n }\n@@ -626,6 +627,9 @@ pub type t_box = &'static t_box_;\n pub struct t_box_ {\n     pub sty: sty,\n     pub flags: TypeFlags,\n+\n+    // the maximal depth of any bound regions appearing in this type.\n+    region_depth: uint,\n }\n \n impl fmt::Show for TypeFlags {\n@@ -670,6 +674,50 @@ pub fn type_needs_infer(t: t) -> bool {\n     tbox_has_flag(get(t), HAS_TY_INFER | HAS_RE_INFER)\n }\n \n+pub fn type_has_late_bound_regions(ty: t) -> bool {\n+    get(ty).flags.intersects(HAS_RE_LATE_BOUND)\n+}\n+\n+pub fn type_has_escaping_regions(t: t) -> bool {\n+    /*!\n+     * An \"escaping region\" is a bound region whose binder is not part of `t`.\n+     *\n+     * So, for example, consider a type like the following, which has two\n+     * binders:\n+     *\n+     *    for<'a> fn(x: for<'b> fn(&'a int, &'b int))\n+     *    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n+     *                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n+     *\n+     * This type has *bound regions* (`'a`, `'b`), but it does not\n+     * have escaping regions, because the binders of both `'a` and\n+     * `'b` are part of the type itself. However, if we consider the\n+     * *inner fn type*, that type has an escaping region: `'a`.\n+     *\n+     * Note that what I'm calling an \"escaping region\" is often just\n+     * called a \"free region\". However, we already use the term \"free\n+     * region\". It refers to the regions that we use to represent\n+     * bound regions on a fn definition while we are typechecking its\n+     * body.\n+     *\n+     * To clarify, conceptually there is no particular difference\n+     * between an \"escaping\" region and a \"free\" region. However,\n+     * there is a big difference in practice. Basically, when\n+     * \"entering\" a binding level, one is generally required to do\n+     * some sort of processing to a bound region, such as replacing it\n+     * with a fresh/skolemized region, or making an entry in the\n+     * environment to represent the scope to which it is attached,\n+     * etc. An escaping region represents a bound region for which\n+     * this processing has not yet been done.\n+     */\n+\n+    type_escapes_depth(t, 0)\n+}\n+\n+pub fn type_escapes_depth(t: t, depth: uint) -> bool {\n+    get(t).region_depth > depth\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct BareFnTy {\n     pub fn_style: ast::FnStyle,\n@@ -706,17 +754,16 @@ impl FnOutput {\n  * Signature of a function type, which I have arbitrarily\n  * decided to use to refer to the input/output types.\n  *\n- * - `binder_id` is the node id where this fn type appeared;\n- *   it is used to identify all the bound regions appearing\n- *   in the input/output types that are bound by this fn type\n- *   (vs some enclosing or enclosed fn type)\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n+ *\n+ * Note that a `FnSig` introduces a level of region binding, to\n+ * account for late-bound parameters that appear in the types of the\n+ * fn's arguments or the fn's return type.\n  */\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig {\n-    pub binder_id: ast::NodeId,\n     pub inputs: Vec<t>,\n     pub output: FnOutput,\n     pub variadic: bool\n@@ -729,6 +776,54 @@ pub struct ParamTy {\n     pub def_id: DefId\n }\n \n+/**\n+ * A [De Bruijn index][dbi] is a standard means of representing\n+ * regions (and perhaps later types) in a higher-ranked setting. In\n+ * particular, imagine a type like this:\n+ *\n+ *     for<'a> fn(for<'b> fn(&'b int, &'a int), &'a char)\n+ *     ^          ^            |        |         |\n+ *     |          |            |        |         |\n+ *     |          +------------+ 1      |         |\n+ *     |                                |         |\n+ *     +--------------------------------+ 2       |\n+ *     |                                          |\n+ *     +------------------------------------------+ 1\n+ *\n+ * In this type, there are two binders (the outer fn and the inner\n+ * fn). We need to be able to determine, for any given region, which\n+ * fn type it is bound by, the inner or the outer one. There are\n+ * various ways you can do this, but a De Bruijn index is one of the\n+ * more convenient and has some nice properties. The basic idea is to\n+ * count the number of binders, inside out. Some examples should help\n+ * clarify what I mean.\n+ *\n+ * Let's start with the reference type `&'b int` that is the first\n+ * argument to the inner function. This region `'b` is assigned a De\n+ * Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n+ * fn). The region `'a` that appears in the second argument type (`&'a\n+ * int`) would then be assigned a De Bruijn index of 2, meaning \"the\n+ * second-innermost binder\". (These indices are written on the arrays\n+ * in the diagram).\n+ *\n+ * What is interesting is that De Bruijn index attached to a particular\n+ * variable will vary depending on where it appears. For example,\n+ * the final type `&'a char` also refers to the region `'a` declared on\n+ * the outermost fn. But this time, this reference is not nested within\n+ * any other binders (i.e., it is not an argument to the inner fn, but\n+ * rather the outer one). Therefore, in this case, it is assigned a\n+ * De Bruijn index of 1, because the innermost binder in that location\n+ * is the outer fn.\n+ *\n+ * [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n+ */\n+#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+pub struct DebruijnIndex {\n+    // We maintain the invariant that this is never 0. So 1 indicates\n+    // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n+    pub depth: uint,\n+}\n+\n /// Representation of regions:\n #[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum Region {\n@@ -741,9 +836,8 @@ pub enum Region {\n                  ast::Name),\n \n     // Region bound in a function scope, which will be substituted when the\n-    // function is called. The first argument must be the `binder_id` of\n-    // some enclosing function signature.\n-    ReLateBound(/* binder_id */ ast::NodeId, BoundRegion),\n+    // function is called.\n+    ReLateBound(DebruijnIndex, BoundRegion),\n \n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n@@ -885,12 +979,19 @@ pub type UpvarBorrowMap = FnvHashMap<UpvarId, UpvarBorrow>;\n \n impl Region {\n     pub fn is_bound(&self) -> bool {\n-        match self {\n-            &ty::ReEarlyBound(..) => true,\n-            &ty::ReLateBound(..) => true,\n+        match *self {\n+            ty::ReEarlyBound(..) => true,\n+            ty::ReLateBound(..) => true,\n             _ => false\n         }\n     }\n+\n+    pub fn escapes_depth(&self, depth: uint) -> bool {\n+        match *self {\n+            ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n+            _ => false,\n+        }\n+    }\n }\n \n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n@@ -928,6 +1029,7 @@ mod primitives {\n             pub static $name: t_box_ = t_box_ {\n                 sty: $sty,\n                 flags: super::NO_TYPE_FLAGS,\n+                region_depth: 0,\n             };\n         )\n     )\n@@ -950,6 +1052,7 @@ mod primitives {\n     pub static TY_ERR: t_box_ = t_box_ {\n         sty: super::ty_err,\n         flags: super::HAS_TY_ERR,\n+        region_depth: 0,\n     };\n }\n \n@@ -1008,6 +1111,23 @@ pub struct TraitRef {\n     pub substs: Substs,\n }\n \n+/**\n+ * Binder serves as a synthetic binder for lifetimes. It is used when\n+ * we wish to replace the escaping higher-ranked lifetimes in a type\n+ * or something else that is not itself a binder (this is because the\n+ * `replace_late_bound_regions` function replaces all lifetimes bound\n+ * by the binder supplied to it; but a type is not a binder, so you\n+ * must introduce an artificial one).\n+ */\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct Binder<T> {\n+    pub value: T\n+}\n+\n+pub fn bind<T>(value: T) -> Binder<T> {\n+    Binder { value: value }\n+}\n+\n #[deriving(Clone, PartialEq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n@@ -1597,99 +1717,12 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         _ => ()\n     }\n \n-    let mut flags = NO_TYPE_FLAGS;\n-    fn rflags(r: Region) -> TypeFlags {\n-        HAS_REGIONS | {\n-            match r {\n-              ty::ReInfer(_) => HAS_RE_INFER,\n-              _ => NO_TYPE_FLAGS,\n-            }\n-        }\n-    }\n-    fn sflags(substs: &Substs) -> TypeFlags {\n-        let mut f = NO_TYPE_FLAGS;\n-        let mut i = substs.types.iter();\n-        for tt in i {\n-            f = f | get(*tt).flags;\n-        }\n-        match substs.regions {\n-            subst::ErasedRegions => {}\n-            subst::NonerasedRegions(ref regions) => {\n-                for r in regions.iter() {\n-                    f = f | rflags(*r)\n-                }\n-            }\n-        }\n-        return f;\n-    }\n-    fn flags_for_bounds(bounds: &ExistentialBounds) -> TypeFlags {\n-        rflags(bounds.region_bound)\n-    }\n-    match &st {\n-      &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_str => {}\n-      // You might think that we could just return ty_err for\n-      // any type containing ty_err as a component, and get\n-      // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n-      // the exception of function types that return bot).\n-      // But doing so caused sporadic memory corruption, and\n-      // neither I (tjc) nor nmatsakis could figure out why,\n-      // so we're doing it this way.\n-      &ty_err => flags = flags | HAS_TY_ERR,\n-      &ty_param(ref p) => {\n-          if p.space == subst::SelfSpace {\n-              flags = flags | HAS_SELF;\n-          } else {\n-              flags = flags | HAS_PARAMS;\n-          }\n-      }\n-      &ty_unboxed_closure(_, ref region, ref substs) => {\n-          flags = flags | rflags(*region);\n-          flags = flags | sflags(substs);\n-      }\n-      &ty_infer(_) => flags = flags | HAS_TY_INFER,\n-      &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n-          flags = flags | sflags(substs);\n-      }\n-      &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n-          flags = flags | sflags(&principal.substs);\n-          flags = flags | flags_for_bounds(bounds);\n-      }\n-      &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n-        flags = flags | get(tt).flags\n-      }\n-      &ty_ptr(ref m) => {\n-        flags = flags | get(m.ty).flags;\n-      }\n-      &ty_rptr(r, ref m) => {\n-        flags = flags | rflags(r);\n-        flags = flags | get(m.ty).flags;\n-      }\n-      &ty_tup(ref ts) => for tt in ts.iter() { flags = flags | get(*tt).flags; },\n-      &ty_bare_fn(ref f) => {\n-        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n-        if let ty::FnConverging(output) = f.sig.output {\n-            flags = flags | get(output).flags;\n-        }\n-      }\n-      &ty_closure(ref f) => {\n-        match f.store {\n-            RegionTraitStore(r, _) => {\n-                flags = flags | rflags(r);\n-            }\n-            _ => {}\n-        }\n-        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n-        if let ty::FnConverging(output) = f.sig.output {\n-            flags = flags | get(output).flags;\n-        }\n-        flags = flags | flags_for_bounds(&f.bounds);\n-      }\n-    }\n+    let flags = FlagComputation::for_sty(&st);\n \n     let t = cx.type_arena.alloc(t_box_ {\n         sty: st,\n-        flags: flags,\n+        flags: flags.flags,\n+        region_depth: flags.depth,\n     });\n \n     let sty_ptr = &t.sty as *const sty;\n@@ -1705,6 +1738,185 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     }\n }\n \n+struct FlagComputation {\n+    flags: TypeFlags,\n+\n+    // maximum depth of any bound region that we have seen thus far\n+    depth: uint,\n+}\n+\n+impl FlagComputation {\n+    fn new() -> FlagComputation {\n+        FlagComputation { flags: NO_TYPE_FLAGS, depth: 0 }\n+    }\n+\n+    fn for_sty(st: &sty) -> FlagComputation {\n+        let mut result = FlagComputation::new();\n+        result.add_sty(st);\n+        result\n+    }\n+\n+    fn add_flags(&mut self, flags: TypeFlags) {\n+        self.flags = self.flags | flags;\n+    }\n+\n+    fn add_depth(&mut self, depth: uint) {\n+        if depth > self.depth {\n+            self.depth = depth;\n+        }\n+    }\n+\n+    fn add_bound_computation(&mut self, computation: &FlagComputation) {\n+        /*!\n+         * Adds the flags/depth from a set of types that appear within\n+         * the current type, but within a region binder.\n+         */\n+\n+        self.add_flags(computation.flags);\n+\n+        // The types that contributed to `computation` occured within\n+        // a region binder, so subtract one from the region depth\n+        // within when adding the depth to `self`.\n+        let depth = computation.depth;\n+        if depth > 0 {\n+            self.add_depth(depth - 1);\n+        }\n+    }\n+\n+    fn add_sty(&mut self, st: &sty) {\n+        match st {\n+            &ty_bool |\n+            &ty_char |\n+            &ty_int(_) |\n+            &ty_float(_) |\n+            &ty_uint(_) |\n+            &ty_str => {\n+            }\n+\n+            // You might think that we could just return ty_err for\n+            // any type containing ty_err as a component, and get\n+            // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n+            // the exception of function types that return bot).\n+            // But doing so caused sporadic memory corruption, and\n+            // neither I (tjc) nor nmatsakis could figure out why,\n+            // so we're doing it this way.\n+            &ty_err => {\n+                self.add_flags(HAS_TY_ERR)\n+            }\n+\n+            &ty_param(ref p) => {\n+                if p.space == subst::SelfSpace {\n+                    self.add_flags(HAS_SELF);\n+                } else {\n+                    self.add_flags(HAS_PARAMS);\n+                }\n+            }\n+\n+            &ty_unboxed_closure(_, ref region, ref substs) => {\n+                self.add_region(*region);\n+                self.add_substs(substs);\n+            }\n+\n+            &ty_infer(_) => {\n+                self.add_flags(HAS_TY_INFER)\n+            }\n+\n+            &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n+                self.add_substs(substs);\n+            }\n+\n+            &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n+                self.add_substs(&principal.substs);\n+                self.add_bounds(bounds);\n+            }\n+\n+            &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n+                self.add_ty(tt)\n+            }\n+\n+            &ty_ptr(ref m) => {\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty_rptr(r, ref m) => {\n+                self.add_region(r);\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty_tup(ref ts) => {\n+                self.add_tys(ts[]);\n+            }\n+\n+            &ty_bare_fn(ref f) => {\n+                self.add_fn_sig(&f.sig);\n+            }\n+\n+            &ty_closure(ref f) => {\n+                match f.store {\n+                    RegionTraitStore(r, _) => {\n+                        self.add_region(r);\n+                    }\n+                    _ => {}\n+                }\n+                self.add_fn_sig(&f.sig);\n+                self.add_bounds(&f.bounds);\n+            }\n+        }\n+    }\n+\n+    fn add_ty(&mut self, t: t) {\n+        let t_box = get(t);\n+        self.add_flags(t_box.flags);\n+        self.add_depth(t_box.region_depth);\n+    }\n+\n+    fn add_tys(&mut self, tys: &[t]) {\n+        for &ty in tys.iter() {\n+            self.add_ty(ty);\n+        }\n+    }\n+\n+    fn add_fn_sig(&mut self, fn_sig: &FnSig) {\n+        let mut computation = FlagComputation::new();\n+\n+        computation.add_tys(fn_sig.inputs[]);\n+\n+        if let ty::FnConverging(output) = fn_sig.output {\n+            computation.add_ty(output);\n+        }\n+\n+        self.add_bound_computation(&computation);\n+    }\n+\n+    fn add_region(&mut self, r: Region) {\n+        self.add_flags(HAS_REGIONS);\n+        match r {\n+            ty::ReInfer(_) => { self.add_flags(HAS_RE_INFER); }\n+            ty::ReLateBound(debruijn, _) => {\n+                self.add_flags(HAS_RE_LATE_BOUND);\n+                self.add_depth(debruijn.depth);\n+            }\n+            _ => { }\n+        }\n+    }\n+\n+    fn add_substs(&mut self, substs: &Substs) {\n+        self.add_tys(substs.types.as_slice());\n+        match substs.regions {\n+            subst::ErasedRegions => {}\n+            subst::NonerasedRegions(ref regions) => {\n+                for &r in regions.iter() {\n+                    self.add_region(r);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_bounds(&mut self, bounds: &ExistentialBounds) {\n+        self.add_region(bounds.region_bound);\n+    }\n+}\n+\n #[inline]\n pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     unsafe {\n@@ -1855,7 +2067,6 @@ pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> t {\n }\n \n pub fn mk_ctor_fn(cx: &ctxt,\n-                  binder_id: ast::NodeId,\n                   input_tys: &[ty::t],\n                   output: ty::t) -> t {\n     let input_args = input_tys.iter().map(|t| *t).collect();\n@@ -1864,7 +2075,6 @@ pub fn mk_ctor_fn(cx: &ctxt,\n                    fn_style: ast::NormalFn,\n                    abi: abi::Rust,\n                    sig: FnSig {\n-                    binder_id: binder_id,\n                     inputs: input_args,\n                     output: ty::FnConverging(output),\n                     variadic: false\n@@ -4783,13 +4993,12 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n                             types: substs.types.fold_with(self) }\n         }\n \n-        fn fold_sig(&mut self,\n-                    sig: &ty::FnSig)\n-                    -> ty::FnSig {\n+        fn fold_fn_sig(&mut self,\n+                       sig: &ty::FnSig)\n+                       -> ty::FnSig {\n             // The binder-id is only relevant to bound regions, which\n             // are erased at trans time.\n             ty::FnSig {\n-                binder_id: ast::DUMMY_NODE_ID,\n                 inputs: sig.inputs.fold_with(self),\n                 output: sig.output.fold_with(self),\n                 variadic: sig.variadic,\n@@ -5589,3 +5798,85 @@ impl AutoDerefRef {\n         self.autoderefs == 0 && self.autoref.is_none()\n     }\n }\n+\n+pub fn liberate_late_bound_regions<HR>(\n+    tcx: &ty::ctxt,\n+    scope_id: ast::NodeId,\n+    value: &HR)\n+    -> HR\n+    where HR : HigherRankedFoldable\n+{\n+    /*!\n+     * Replace any late-bound regions bound in `value` with free variants\n+     * attached to scope-id `scope_id`.\n+     */\n+\n+    replace_late_bound_regions(\n+        tcx, value,\n+        |br, _| ty::ReFree(ty::FreeRegion{scope_id: scope_id, bound_region: br})).0\n+}\n+\n+pub fn erase_late_bound_regions<HR>(\n+    tcx: &ty::ctxt,\n+    value: &HR)\n+    -> HR\n+    where HR : HigherRankedFoldable\n+{\n+    /*!\n+     * Replace any late-bound regions bound in `value` with `'static`.\n+     * Useful in trans.\n+     */\n+\n+    replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n+}\n+\n+pub fn replace_late_bound_regions<HR>(\n+    tcx: &ty::ctxt,\n+    value: &HR,\n+    mapf: |BoundRegion, DebruijnIndex| -> ty::Region)\n+    -> (HR, FnvHashMap<ty::BoundRegion,ty::Region>)\n+    where HR : HigherRankedFoldable\n+{\n+    /*!\n+     * Replaces the late-bound-regions in `value` that are bound by `value`.\n+     */\n+\n+    debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n+\n+    let mut map = FnvHashMap::new();\n+    let value = {\n+        let mut f = ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n+            debug!(\"region={}\", region.repr(tcx));\n+            match region {\n+                ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n+                    * match map.entry(br) {\n+                        Vacant(entry) => entry.set(mapf(br, debruijn)),\n+                        Occupied(entry) => entry.into_mut(),\n+                    }\n+                }\n+                _ => {\n+                    region\n+                }\n+            }\n+        });\n+\n+        // Note: use `fold_contents` not `fold_with`. If we used\n+        // `fold_with`, it would consider the late-bound regions bound\n+        // by `value` to be bound, but we want to consider them as\n+        // `free`.\n+        value.fold_contents(&mut f)\n+    };\n+    debug!(\"resulting map: {} value: {}\", map, value.repr(tcx));\n+    (value, map)\n+}\n+\n+impl DebruijnIndex {\n+    pub fn new(depth: uint) -> DebruijnIndex {\n+        assert!(depth > 0);\n+        DebruijnIndex { depth: depth }\n+    }\n+\n+    pub fn shifted(&self, amount: uint) -> DebruijnIndex {\n+        DebruijnIndex { depth: self.depth + amount }\n+    }\n+}"}, {"sha": "c0686e1c8fcc35880706f6732169ca14877b2bf7", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 129, "deletions": 59, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -63,6 +63,17 @@ pub trait TypeFoldable {\n pub trait TypeFolder<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n+    /// Invoked by the `super_*` routines when we enter a region\n+    /// binding level (for example, when entering a function\n+    /// signature). This is used by clients that want to track the\n+    /// Debruijn index nesting level.\n+    fn enter_region_binder(&mut self) { }\n+\n+    /// Invoked by the `super_*` routines when we exit a region\n+    /// binding level. This is used by clients that want to\n+    /// track the Debruijn index nesting level.\n+    fn exit_region_binder(&mut self) { }\n+\n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         super_fold_ty(self, t)\n     }\n@@ -85,10 +96,10 @@ pub trait TypeFolder<'tcx> {\n         super_fold_substs(self, substs)\n     }\n \n-    fn fold_sig(&mut self,\n+    fn fold_fn_sig(&mut self,\n                 sig: &ty::FnSig)\n                 -> ty::FnSig {\n-        super_fold_sig(self, sig)\n+        super_fold_fn_sig(self, sig)\n     }\n \n     fn fold_output(&mut self,\n@@ -153,6 +164,12 @@ impl TypeFoldable for () {\n     }\n }\n \n+impl<T:TypeFoldable,U:TypeFoldable> TypeFoldable for (T, U) {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+        (self.0.fold_with(folder), self.1.fold_with(folder))\n+    }\n+}\n+\n impl<T:TypeFoldable> TypeFoldable for Option<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n@@ -171,6 +188,15 @@ impl<T:TypeFoldable> TypeFoldable for Vec<T> {\n     }\n }\n \n+impl<T:TypeFoldable> TypeFoldable for ty::Binder<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+        folder.enter_region_binder();\n+        let result = ty::bind(self.value.fold_with(folder));\n+        folder.exit_region_binder();\n+        result\n+    }\n+}\n+\n impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n@@ -179,7 +205,24 @@ impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n \n impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n-        self.map(|t| t.fold_with(folder))\n+\n+        // Things in the Fn space take place under an additional level\n+        // of region binding relative to the other spaces. This is\n+        // because those entries are attached to a method, and methods\n+        // always introduce a level of region binding.\n+\n+        let result = self.map_enumerated(|(space, index, elem)| {\n+            if space == subst::FnSpace && index == 0 {\n+                // enter new level when/if we reach the first thing in fn space\n+                folder.enter_region_binder();\n+            }\n+            elem.fold_with(folder)\n+        });\n+        if result.len(subst::FnSpace) > 0 {\n+            // if there was anything in fn space, exit the region binding level\n+            folder.exit_region_binder();\n+        }\n+        result\n     }\n }\n \n@@ -221,7 +264,7 @@ impl TypeFoldable for ty::FnOutput {\n \n impl TypeFoldable for ty::FnSig {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n-        folder.fold_sig(self)\n+        folder.fold_fn_sig(self)\n     }\n }\n \n@@ -457,11 +500,21 @@ pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                     types: substs.types.fold_with(this) }\n }\n \n-pub fn super_fold_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                 sig: &ty::FnSig)\n-                                                 -> ty::FnSig {\n-    ty::FnSig { binder_id: sig.binder_id,\n-                inputs: sig.inputs.fold_with(this),\n+pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                    sig: &ty::FnSig)\n+                                                    -> ty::FnSig\n+{\n+    this.enter_region_binder();\n+    let result = super_fold_fn_sig_contents(this, sig);\n+    this.exit_region_binder();\n+    result\n+}\n+\n+pub fn super_fold_fn_sig_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                             sig: &ty::FnSig)\n+                                                             -> ty::FnSig\n+{\n+    ty::FnSig { inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n                 variadic: sig.variadic }\n }\n@@ -622,6 +675,27 @@ pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n+// Higher-ranked things\n+\n+/**\n+ * Designates a \"binder\" for late-bound regions.\n+ */\n+pub trait HigherRankedFoldable : Repr {\n+    /// Folds the contents of `self`, ignoring the region binder created\n+    /// by `self`.\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+}\n+\n+impl HigherRankedFoldable for ty::FnSig {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n+        super_fold_fn_sig_contents(folder, self)\n+    }\n+}\n+impl<T:TypeFoldable+Repr> HigherRankedFoldable for ty::Binder<T> {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+        ty::bind(self.value.fold_with(folder))\n+    }\n+}\n // Some sample folders\n \n pub struct BottomUpFolder<'a, 'tcx: 'a> {\n@@ -655,77 +729,43 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n /// current position of the fold.)\n pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    fld_t: |ty::t|: 'a -> ty::t,\n-    fld_r: |ty::Region|: 'a -> ty::Region,\n-    within_binder_ids: Vec<ast::NodeId>,\n+    current_depth: uint,\n+    fld_r: |ty::Region, uint|: 'a -> ty::Region,\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn general(tcx: &'a ty::ctxt<'tcx>,\n-                   fld_r: |ty::Region|: 'a -> ty::Region,\n-                   fld_t: |ty::t|: 'a -> ty::t)\n-                   -> RegionFolder<'a, 'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region, uint|: 'a -> ty::Region)\n+               -> RegionFolder<'a, 'tcx> {\n         RegionFolder {\n             tcx: tcx,\n-            fld_t: fld_t,\n+            current_depth: 1,\n             fld_r: fld_r,\n-            within_binder_ids: vec![],\n         }\n     }\n-\n-    pub fn regions(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region|: 'a -> ty::Region)\n-                   -> RegionFolder<'a, 'tcx> {\n-        fn noop(t: ty::t) -> ty::t { t }\n-\n-        RegionFolder {\n-            tcx: tcx,\n-            fld_t: noop,\n-            fld_r: fld_r,\n-            within_binder_ids: vec![],\n-        }\n-    }\n-}\n-\n-/// If `ty` has `FnSig` (i.e. closure or fn), return its binder_id;\n-/// else None.\n-fn opt_binder_id_of_function(t: ty::t) -> Option<ast::NodeId> {\n-    match ty::get(t).sty {\n-        ty::ty_closure(ref f) => Some(f.sig.binder_id),\n-        ty::ty_bare_fn(ref f) => Some(f.sig.binder_id),\n-        _                     => None,\n-    }\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n-        debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));\n-        let opt_binder_id = opt_binder_id_of_function(ty);\n-        match opt_binder_id {\n-            Some(binder_id) => self.within_binder_ids.push(binder_id),\n-            None => {}\n-        }\n-\n-        let t1 = super_fold_ty(self, ty);\n-        let ret = (self.fld_t)(t1);\n-\n-        if opt_binder_id.is_some() {\n-            self.within_binder_ids.pop();\n-        }\n+    fn enter_region_binder(&mut self) {\n+        self.current_depth += 1;\n+    }\n \n-        ret\n+    fn exit_region_binder(&mut self) {\n+        self.current_depth -= 1;\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n-            ty::ReLateBound(binder_id, _) if self.within_binder_ids.contains(&binder_id) => {\n-                debug!(\"RegionFolder.fold_region({}) skipped bound region\", r.repr(self.tcx()));\n+            ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n+                debug!(\"RegionFolder.fold_region({}) skipped bound region (current depth={})\",\n+                       r.repr(self.tcx()), self.current_depth);\n                 r\n             }\n             _ => {\n-                debug!(\"RegionFolder.fold_region({}) folding free region\", r.repr(self.tcx()));\n-                (self.fld_r)(r)\n+                debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n+                       r.repr(self.tcx()), self.current_depth);\n+                (self.fld_r)(r, self.current_depth)\n             }\n         }\n     }\n@@ -755,3 +795,33 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Region shifter\n+//\n+// Shifts the De Bruijn indices on all escaping bound regions by a\n+// fixed amount. Useful in substitution or when otherwise introducing\n+// a binding level that is not intended to capture the existing bound\n+// regions. See comment on `shift_regions_through_binders` method in\n+// `subst.rs` for more details.\n+\n+pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n+    match region {\n+        ty::ReLateBound(debruijn, br) => {\n+            ty::ReLateBound(debruijn.shifted(amount), br)\n+        }\n+        _ => {\n+            region\n+        }\n+    }\n+}\n+\n+pub fn shift_regions<T:TypeFoldable+Repr>(tcx: &ty::ctxt, amount: uint, value: &T) -> T {\n+    debug!(\"shift_regions(value={}, amount={})\",\n+           value.repr(tcx), amount);\n+\n+    value.fold_with(&mut RegionFolder::new(tcx, |region, _current_depth| {\n+        shift_region(region, amount)\n+    }))\n+}\n+"}, {"sha": "3cb3494fb305b7edfe642784f5379a430dadf725", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -106,9 +106,8 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n             ty::ReStatic\n         }\n \n-        Some(&rl::DefLateBoundRegion(binder_id, _, id)) => {\n-            ty::ReLateBound(binder_id, ty::BrNamed(ast_util::local_def(id),\n-                                                   lifetime.name))\n+        Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n+            ty::ReLateBound(debruijn, ty::BrNamed(ast_util::local_def(id), lifetime.name))\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n@@ -210,8 +209,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n     associated_ty: Option<ty::t>,\n-    path: &ast::Path,\n-    binder_id: ast::NodeId)\n+    path: &ast::Path)\n     -> Substs\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -463,8 +461,7 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n-    path: &ast::Path,\n-    binder_id: ast::NodeId)\n+    path: &ast::Path)\n     -> TypeAndSubsts\n {\n     let tcx = this.tcx();\n@@ -473,14 +470,13 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = ast_path_substs(this,\n-                                 rscope,\n-                                 did,\n-                                 &generics,\n-                                 None,\n-                                 None,\n-                                 path,\n-                                 binder_id);\n+    let substs = ast_path_substs_for_ty(this,\n+                                        rscope,\n+                                        did,\n+                                        &generics,\n+                                        None,\n+                                        None,\n+                                        path);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n@@ -494,8 +490,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n-    path: &ast::Path,\n-    binder_id: ast::NodeId)\n+    path: &ast::Path)\n     -> TypeAndSubsts\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n@@ -521,7 +516,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs(this, rscope, did, &generics, None, None, path, binder_id)\n+        ast_path_substs_for_ty(this, rscope, did, &generics, None, None, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -628,7 +623,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             match a_def {\n                 def::DefTy(did, _) |\n                 def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n-                    let ty = ast_path_to_ty(this, rscope, did, path, id).ty;\n+                    let ty = ast_path_to_ty(this, rscope, did, path).ty;\n                     match ty::get(ty).sty {\n                         ty::ty_struct(struct_def_id, ref substs) => {\n                             assert_eq!(struct_def_id, did);\n@@ -689,8 +684,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        trait_def_id,\n                                                        None,\n                                                        None,\n-                                                       path,\n-                                                       id);\n+                                                       path);\n                     let empty_vec = [];\n                     let bounds = match *opt_bounds { None => empty_vec.as_slice(),\n                                                      Some(ref bounds) => bounds.as_slice() };\n@@ -752,12 +746,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           trait_did,\n                                           None,\n                                           Some(for_type),\n-                                          trait_path,\n-                                          ast::DUMMY_NODE_ID); // *see below\n-\n-    // * The trait in a qualified path cannot be \"higher-ranked\" and\n-    // hence cannot use the parenthetical sugar, so the binder-id is\n-    // irrelevant.\n+                                          trait_path);\n \n     debug!(\"associated_ty_to_ty(trait_ref={})\",\n            trait_ref.repr(this.tcx()));\n@@ -830,8 +819,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n-                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n-                                                  bf.abi, &*bf.decl))\n+                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, bf.fn_style, bf.abi, &*bf.decl))\n             }\n             ast::TyClosure(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n@@ -842,7 +830,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                      [].as_slice(),\n                                                      f.bounds.as_slice());\n                 let fn_decl = ty_of_closure(this,\n-                                            ast_ty.id,\n                                             f.fn_style,\n                                             f.onceness,\n                                             bounds,\n@@ -863,7 +850,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                      f.bounds.as_slice());\n \n                 let fn_decl = ty_of_closure(this,\n-                                            ast_ty.id,\n                                             f.fn_style,\n                                             f.onceness,\n                                             bounds,\n@@ -910,8 +896,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            trait_def_id,\n                                                            None,\n                                                            None,\n-                                                           path,\n-                                                           id);\n+                                                           path);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n                             Some(ref b) => b.as_slice(),\n@@ -927,7 +912,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                      bounds)\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path, id).ty\n+                        ast_path_to_ty(this, rscope, did, path).ty\n                     }\n                     def::DefTyParam(space, id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -1056,7 +1041,6 @@ struct SelfInfo<'a> {\n \n pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n-                    id: ast::NodeId,\n                     fn_style: ast::FnStyle,\n                     untransformed_self_ty: ty::t,\n                     explicit_self: &ast::ExplicitSelf,\n@@ -1069,25 +1053,21 @@ pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n     });\n     let (bare_fn_ty, optional_explicit_self_category) =\n         ty_of_method_or_bare_fn(this,\n-                                id,\n                                 fn_style,\n                                 abi,\n                                 self_info,\n                                 decl);\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, id: ast::NodeId,\n-                                              fn_style: ast::FnStyle, abi: abi::Abi,\n+pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, fn_style: ast::FnStyle, abi: abi::Abi,\n                                               decl: &ast::FnDecl) -> ty::BareFnTy {\n-    let (bare_fn_ty, _) =\n-        ty_of_method_or_bare_fn(this, id, fn_style, abi, None, decl);\n+    let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, fn_style, abi, None, decl);\n     bare_fn_ty\n }\n \n fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                            this: &AC,\n-                           id: ast::NodeId,\n                            fn_style: ast::FnStyle,\n                            abi: abi::Abi,\n                            opt_self_info: Option<SelfInfo>,\n@@ -1098,7 +1078,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n \n     // New region names that appear inside of the arguments of the function\n     // declaration are bound to that function type.\n-    let rb = rscope::BindingRscope::new(id);\n+    let rb = rscope::BindingRscope::new();\n \n     // `implied_output_region` is the region that will be assumed for any\n     // region parameters in the return type. In accordance with the rules for\n@@ -1114,7 +1094,9 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                 determine_explicit_self_category(this, &rb, &self_info);\n             explicit_self_category_result = Some(explicit_self_category);\n             match explicit_self_category {\n-                ty::StaticExplicitSelfCategory => (None, None),\n+                ty::StaticExplicitSelfCategory => {\n+                    (None, None)\n+                }\n                 ty::ByValueExplicitSelfCategory => {\n                     (Some(self_info.untransformed_self_ty), None)\n                 }\n@@ -1205,7 +1187,6 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n         fn_style: fn_style,\n         abi: abi,\n         sig: ty::FnSig {\n-            binder_id: id,\n             inputs: self_and_input_tys,\n             output: output_ty,\n             variadic: decl.variadic\n@@ -1290,7 +1271,6 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n \n pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     this: &AC,\n-    id: ast::NodeId,\n     fn_style: ast::FnStyle,\n     onceness: ast::Onceness,\n     bounds: ty::ExistentialBounds,\n@@ -1300,13 +1280,14 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     expected_sig: Option<ty::FnSig>)\n     -> ty::ClosureTy\n {\n-    debug!(\"ty_of_fn_decl\");\n+    debug!(\"ty_of_closure(expected_sig={})\",\n+           expected_sig.repr(this.tcx()));\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let rb = rscope::BindingRscope::new(id);\n+    let rb = rscope::BindingRscope::new();\n \n-    let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n+    let input_tys: Vec<_> = decl.inputs.iter().enumerate().map(|(i, a)| {\n         let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n@@ -1331,14 +1312,16 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n         ast::NoReturn(_) => ty::FnDiverging\n     };\n \n+    debug!(\"ty_of_closure: input_tys={}\", input_tys.repr(this.tcx()));\n+    debug!(\"ty_of_closure: output_ty={}\", output_ty.repr(this.tcx()));\n+\n     ty::ClosureTy {\n         fn_style: fn_style,\n         onceness: onceness,\n         store: store,\n         bounds: bounds,\n         abi: abi,\n-        sig: ty::FnSig {binder_id: id,\n-                        inputs: input_tys,\n+        sig: ty::FnSig {inputs: input_tys,\n                         output: output_ty,\n                         variadic: decl.variadic}\n     }"}, {"sha": "c7598eadaab9224f23f2aee2ac6238b9bf86f837", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -528,9 +528,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     // First, we have to replace any bound regions in the fn type with free ones.\n     // The free region references will be bound the node_id of the body block.\n-    let (_, fn_sig) = replace_late_bound_regions(tcx, fn_sig.binder_id, fn_sig, |br| {\n-        ty::ReFree(ty::FreeRegion {scope_id: body.id, bound_region: br})\n-    });\n+    let fn_sig = liberate_late_bound_regions(tcx, body.id, fn_sig);\n \n     let arg_tys = fn_sig.inputs.as_slice();\n     let ret_ty = fn_sig.output;\n@@ -3031,7 +3029,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n         let error_fn_sig = FnSig {\n-            binder_id: ast::CRATE_NODE_ID,\n             inputs: err_args(args.len()),\n             output: ty::FnConverging(ty::mk_err()),\n             variadic: false\n@@ -3051,11 +3048,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Replace any bound regions that appear in the function\n         // signature with region variables\n         let fn_sig =\n-            fcx.infcx().replace_late_bound_regions_with_fresh_var(\n-                fn_sig.binder_id,\n-                call_expr.span,\n-                infer::FnCall,\n-                fn_sig).0;\n+            fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                  infer::FnCall,\n+                                                                  fn_sig).0;\n \n         // Call the generic checker.\n         check_argument_types(fcx,\n@@ -3437,7 +3432,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              body: &ast::Block) {\n         let mut fn_ty = astconv::ty_of_closure(\n             fcx,\n-            expr.id,\n             ast::NormalFn,\n             ast::Many,\n \n@@ -3508,6 +3502,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                      expected: Expectation) {\n         let tcx = fcx.ccx.tcx;\n \n+        debug!(\"check_expr_fn(expr={}, expected={})\",\n+               expr.repr(tcx),\n+               expected.repr(tcx));\n+\n         // Find the expected input/output types (if any). Substitute\n         // fresh bound regions for any bound regions we find in the\n         // expected types so as to avoid capture.\n@@ -3517,10 +3515,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n              expected_bounds) = {\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n-                    let (_, sig) =\n+                    let (sig, _) =\n                         replace_late_bound_regions(\n-                            tcx, cenv.sig.binder_id, &cenv.sig,\n-                            |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n+                            tcx,\n+                            &cenv.sig,\n+                            |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n                     let onceness = match (&store, &cenv.store) {\n                         // As the closure type and onceness go, only three\n                         // combinations are legit:\n@@ -3561,7 +3560,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n-                                           expr.id,\n                                            ast::NormalFn,\n                                            expected_onceness,\n                                            expected_bounds,\n@@ -5943,7 +5941,6 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         fn_style: ast::UnsafeFn,\n         abi: abi::RustIntrinsic,\n         sig: FnSig {\n-            binder_id: it.id,\n             inputs: inputs,\n             output: output,\n             variadic: false,"}, {"sha": "2e727a8ef9aa594901f3b86bfc1a46dc163ca061", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -14,47 +14,14 @@ pub use self::WfConstraint::*;\n \n use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty;\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFolder};\n \n use syntax::ast;\n \n-use std::collections::hash_map::{Occupied, Vacant};\n-use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n-pub fn replace_late_bound_regions<T>(\n-    tcx: &ty::ctxt,\n-    binder_id: ast::NodeId,\n-    value: &T,\n-    map_fn: |ty::BoundRegion| -> ty::Region)\n-    -> (FnvHashMap<ty::BoundRegion,ty::Region>, T)\n-    where T : TypeFoldable + Repr\n-{\n-    debug!(\"replace_late_bound_regions(binder_id={}, value={})\",\n-           binder_id, value.repr(tcx));\n-\n-    let mut map = FnvHashMap::new();\n-    let new_value = {\n-        let mut folder = ty_fold::RegionFolder::regions(tcx, |r| {\n-            match r {\n-                ty::ReLateBound(s, br) if s == binder_id => {\n-                    match map.entry(br) {\n-                        Vacant(entry) => *entry.set(map_fn(br)),\n-                        Occupied(entry) => *entry.into_mut(),\n-                    }\n-                }\n-                _ => r\n-            }\n-        });\n-        value.fold_with(&mut folder)\n-    };\n-    debug!(\"resulting map: {}\", map);\n-    (map, new_value)\n-}\n-\n pub enum WfConstraint {\n     RegionSubRegionConstraint(Option<ty::t>, ty::Region, ty::Region),\n     RegionSubParamConstraint(Option<ty::t>, ty::Region, ty::ParamTy),"}, {"sha": "254f46f846676361584709789ddb2eedd44478c1", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -372,16 +372,12 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n             ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n                 self.binding_count += 1;\n \n-                let (_, fn_sig) =\n-                    replace_late_bound_regions(\n-                        self.fcx.tcx(), fn_sig.binder_id, fn_sig,\n-                        |br| ty::ReFree(ty::FreeRegion{scope_id: self.scope_id,\n-                                                       bound_region: br}));\n+                let fn_sig = liberate_late_bound_regions(self.fcx.tcx(), self.scope_id, fn_sig);\n \n                 debug!(\"late-bound regions replaced: {}\",\n                        fn_sig.repr(self.tcx()));\n \n-                self.fold_sig(&fn_sig);\n+                self.fold_fn_sig(&fn_sig);\n \n                 self.binding_count -= 1;\n             }"}, {"sha": "3f90f59247393f01143442b0df82ed4e7a4568e4", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -214,12 +214,11 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     for variant in variants.iter() {\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n-        let scope = variant.node.id;\n         let result_ty = match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n+                ty::mk_ctor_fn(tcx, input_tys.as_slice(), enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -403,7 +402,6 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n             let trait_self_ty = ty::mk_self_type(tmcx.tcx(),\n                                                  local_def(trait_id));\n             astconv::ty_of_method(&tmcx,\n-                                  *m_id,\n                                   *m_fn_style,\n                                   trait_self_ty,\n                                   m_explicit_self,\n@@ -588,7 +586,6 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n                     method_generics: &m_ty_generics,\n                 };\n                 astconv::ty_of_method(&imcx,\n-                                      m.id,\n                                       m.pe_fn_style(),\n                                       untransformed_rcvr_ty,\n                                       m.pe_explicit_self(),\n@@ -603,7 +600,6 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n                     method_generics: &m_ty_generics,\n                 };\n                 astconv::ty_of_method(&tmcx,\n-                                      m.id,\n                                       m.pe_fn_style(),\n                                       untransformed_rcvr_ty,\n                                       m.pe_explicit_self(),\n@@ -1294,7 +1290,6 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                         |field| (*tcx.tcache.borrow())[\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n-                                                ctor_id,\n                                                 inputs.as_slice(),\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n@@ -1465,11 +1460,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                     ccx: ccx,\n                     generics: &ty_generics,\n                 };\n-                astconv::ty_of_bare_fn(&fcx,\n-                                       it.id,\n-                                       fn_style,\n-                                       abi,\n-                                       &**decl)\n+                astconv::ty_of_bare_fn(&fcx, fn_style, abi, &**decl)\n             };\n             let pty = Polytype {\n                 generics: ty_generics,\n@@ -2091,7 +2082,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n             ast_generics,\n             ty::Generics::empty(),\n             DontCreateTypeParametersForAssociatedTypes);\n-    let rb = BindingRscope::new(def_id.node);\n+    let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n                         .map(|a| ty_of_arg(ccx, &rb, a, None))\n@@ -2109,8 +2100,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ty::BareFnTy {\n             abi: abi,\n             fn_style: ast::UnsafeFn,\n-            sig: ty::FnSig {binder_id: def_id.node,\n-                            inputs: input_tys,\n+            sig: ty::FnSig {inputs: input_tys,\n                             output: output,\n                             variadic: decl.variadic}\n         });"}, {"sha": "f0d480c719a9bdeb047db015681f0978a961bee9", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -334,48 +334,6 @@ pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n     }\n }\n \n-pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n-                                             a: &ty::FnSig,\n-                                             b: &ty::FnSig)\n-                                             -> cres<ty::FnSig> {\n-\n-    fn argvecs<'tcx, C: Combine<'tcx>>(this: &C,\n-                                       a_args: &[ty::t],\n-                                       b_args: &[ty::t])\n-                                       -> cres<Vec<ty::t>> {\n-        if a_args.len() == b_args.len() {\n-            a_args.iter().zip(b_args.iter())\n-                  .map(|(a, b)| this.args(*a, *b)).collect()\n-        } else {\n-            Err(ty::terr_arg_count)\n-        }\n-    }\n-\n-    if a.variadic != b.variadic {\n-        return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n-    }\n-\n-    let inputs = try!(argvecs(this,\n-                                a.inputs.as_slice(),\n-                                b.inputs.as_slice()));\n-\n-    let output = try!(match (a.output, b.output) {\n-        (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-            Ok(ty::FnConverging(try!(this.tys(a_ty, b_ty)))),\n-        (ty::FnDiverging, ty::FnDiverging) =>\n-            Ok(ty::FnDiverging),\n-        (a, b) =>\n-            Err(ty::terr_convergence_mismatch(\n-                expected_found(this, a != ty::FnDiverging, b != ty::FnDiverging)\n-            )),\n-    });\n-\n-    Ok(FnSig {binder_id: a.binder_id,\n-              inputs: inputs,\n-              output: output,\n-              variadic: a.variadic})\n-}\n-\n pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     let tcx = this.infcx().tcx;"}, {"sha": "287a5cfba9e34aabd4316b9aa5b2bc7205c6e11f", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -125,4 +125,8 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         self.higher_ranked_glb(a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        self.higher_ranked_glb(a, b)\n+    }\n }"}, {"sha": "6f75192e6019d750be432da354d7b6d56cb9d0d1", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -797,8 +797,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         subst::Substs::new_trait(type_parameters, regions, assoc_type_parameters, self_ty)\n     }\n \n-    pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n-        self.region_vars.new_bound(binder_id)\n+    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {\n+        self.region_vars.new_bound(debruijn)\n     }\n \n     pub fn resolve_regions_and_report_errors(&self) {\n@@ -968,30 +968,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn replace_late_bound_regions_with_fresh_var<T>(\n         &self,\n-        binder_id: ast::NodeId,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &T)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : TypeFoldable + Repr\n+        where T : HigherRankedFoldable\n     {\n-        let (map, value) =\n-            replace_late_bound_regions(\n-                self.tcx,\n-                binder_id,\n-                value,\n-                |br| self.next_region_var(LateBoundRegion(span, br, lbrct)));\n-        (value, map)\n+        ty::replace_late_bound_regions(\n+            self.tcx,\n+            value,\n+            |br, _| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n }\n \n-pub fn fold_regions_in_sig(tcx: &ty::ctxt,\n-                           fn_sig: &ty::FnSig,\n-                           fldr: |r: ty::Region| -> ty::Region)\n-                           -> ty::FnSig {\n-    ty_fold::RegionFolder::regions(tcx, fldr).fold_sig(fn_sig)\n-}\n-\n impl TypeTrace {\n     pub fn span(&self) -> Span {\n         self.origin.span()"}, {"sha": "54fb7872f3b03ccab1be84f4c66904c71dbf8d62", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         ReInfer(ReSkolemized(sc, br))\n     }\n \n-    pub fn new_bound(&self, binder_id: ast::NodeId) -> Region {\n+    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\"rollover in RegionInference new_bound()\");\n         }\n \n-        ReLateBound(binder_id, BrFresh(sc))\n+        ReLateBound(debruijn, BrFresh(sc))\n     }\n \n     fn values_are_none(&self) -> bool {"}, {"sha": "24d11b25a60f2c3df05ced17d6568b3dcba8702a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -383,7 +383,6 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 fn_style: ast::NormalFn,\n                 abi: abi::Rust,\n                 sig: ty::FnSig {\n-                    binder_id: main_id,\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(ty::mk_nil(tcx)),\n                     variadic: false\n@@ -432,7 +431,6 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 fn_style: ast::NormalFn,\n                 abi: abi::Rust,\n                 sig: ty::FnSig {\n-                    binder_id: start_id,\n                     inputs: vec!(\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))"}, {"sha": "745c76eb77f581831c47ab3aa0952705487a8b75", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -104,22 +104,20 @@ impl RegionScope for SpecificRscope {\n /// A scope in which we generate anonymous, late-bound regions for\n /// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n-    binder_id: ast::NodeId,\n     anon_bindings: Cell<uint>,\n }\n \n impl BindingRscope {\n-    pub fn new(binder_id: ast::NodeId) -> BindingRscope {\n+    pub fn new() -> BindingRscope {\n         BindingRscope {\n-            binder_id: binder_id,\n             anon_bindings: Cell::new(0),\n         }\n     }\n \n     fn next_region(&self) -> ty::Region {\n         let idx = self.anon_bindings.get();\n         self.anon_bindings.set(idx + 1);\n-        ty::ReLateBound(self.binder_id, ty::BrAnon(idx))\n+        ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(idx))\n     }\n }\n "}, {"sha": "ec8b49c108cd168353325fc58aeee6b15b275b4c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -252,8 +252,7 @@ pub fn vec_map_to_string<T>(ts: &[T], f: |t: &T| -> String) -> String {\n }\n \n pub fn fn_sig_to_string(cx: &ctxt, typ: &ty::FnSig) -> String {\n-    format!(\"fn{}{} -> {}\", typ.binder_id, typ.inputs.repr(cx),\n-            typ.output.repr(cx))\n+    format!(\"fn{} -> {}\", typ.inputs.repr(cx), typ.output.repr(cx))\n }\n \n pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n@@ -262,11 +261,11 @@ pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n \n pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n     fn bare_fn_to_string(cx: &ctxt,\n-                      fn_style: ast::FnStyle,\n-                      abi: abi::Abi,\n-                      ident: Option<ast::Ident>,\n-                      sig: &ty::FnSig)\n-                      -> String {\n+                         fn_style: ast::FnStyle,\n+                         abi: abi::Abi,\n+                         ident: Option<ast::Ident>,\n+                         sig: &ty::FnSig)\n+                         -> String {\n         let mut s = String::new();\n         match fn_style {\n             ast::NormalFn => {}\n@@ -1301,3 +1300,8 @@ impl<A:Repr,B:Repr> Repr for (A,B) {\n     }\n }\n \n+impl<T:Repr> Repr for ty::Binder<T> {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"Binder({})\", self.value.repr(tcx))\n+    }\n+}"}, {"sha": "c063c22b234d0411d7dceecced940c81bffb694d", "filename": "src/librustc_trans/test.rs", "status": "modified", "additions": 289, "deletions": 107, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc_trans%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc_trans%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftest.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -14,9 +14,6 @@\n \n */\n \n-// This is only used by tests, hence allow dead code.\n-#![allow(dead_code)]\n-\n use driver::diagnostic;\n use driver::diagnostic::Emitter;\n use driver::driver;\n@@ -25,17 +22,20 @@ use middle::region;\n use middle::resolve;\n use middle::resolve_lifetime;\n use middle::stability;\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::ty;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::glb::Glb;\n-use session::{mod, config};\n+use session::{mod,config};\n+use syntax::{abi, ast, ast_map, ast_util};\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n-use syntax::{ast, ast_map};\n-use util::ppaux::{ty_to_string, UserString};\n+use syntax::parse::token;\n+use util::ppaux::{ty_to_string, Repr, UserString};\n \n use arena::TypedArena;\n \n@@ -97,12 +97,12 @@ fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, uint) {\n     (box ExpectErrorEmitter { messages: v } as Box<Emitter+Send>, msgs.len())\n }\n \n-fn test_env(_test_name: &str,\n-            source_string: &str,\n+fn test_env(source_string: &str,\n             (emitter, expected_err_count): (Box<Emitter+Send>, uint),\n             body: |Env|) {\n-    let options =\n+    let mut options =\n         config::basic_options();\n+    options.debugging_opts |= config::VERBOSE;\n     let codemap =\n         CodeMap::new();\n     let diagnostic_handler =\n@@ -125,7 +125,7 @@ fn test_env(_test_name: &str,\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n     let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n         resolve::resolve_crate(&sess, &lang_items, krate);\n-    let named_region_map = resolve_lifetime::krate(&sess, krate);\n+    let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);\n     let type_arena = TypedArena::new();\n@@ -164,6 +164,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                             sub: &[]}]});\n     }\n \n+    #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n     pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n         return match search_mod(self, &self.infcx.tcx.map.krate().module, 0, names) {\n             Some(id) => id,\n@@ -237,14 +238,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         }\n     }\n \n-    pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n-        if self.is_subtype(a, b) {\n-            panic!(\"{} is a subtype of {}, but it shouldn't be\",\n-                  self.ty_to_string(a),\n-                  self.ty_to_string(b));\n-        }\n-    }\n-\n     pub fn assert_eq(&self, a: ty::t, b: ty::t) {\n         self.assert_subtype(a, b);\n         self.assert_subtype(b, a);\n@@ -255,36 +248,91 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_fn(&self,\n-                binder_id: ast::NodeId,\n                 input_tys: &[ty::t],\n                 output_ty: ty::t)\n                 -> ty::t\n     {\n-        ty::mk_ctor_fn(self.infcx.tcx, binder_id, input_tys, output_ty)\n+        ty::mk_ctor_fn(self.infcx.tcx, input_tys, output_ty)\n+    }\n+\n+    pub fn t_nil(&self) -> ty::t {\n+        ty::mk_nil(self.infcx.tcx)\n+    }\n+\n+    pub fn t_pair(&self, ty1: ty::t, ty2: ty::t) -> ty::t\n+    {\n+        ty::mk_tup(self.infcx.tcx, vec![ty1, ty2])\n+    }\n+\n+    pub fn t_closure(&self,\n+                     input_tys: &[ty::t],\n+                     output_ty: ty::t,\n+                     region_bound: ty::Region)\n+                     -> ty::t\n+    {\n+        ty::mk_closure(self.infcx.tcx, ty::ClosureTy {\n+            fn_style: ast::NormalFn,\n+            onceness: ast::Many,\n+            store: ty::RegionTraitStore(region_bound, ast::MutMutable),\n+            bounds: ty::region_existential_bound(region_bound),\n+            sig: ty::FnSig {\n+                inputs: input_tys.to_vec(),\n+                output: ty::FnConverging(output_ty),\n+                variadic: false,\n+            },\n+            abi: abi::Rust,\n+        })\n+    }\n+\n+    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> ty::t {\n+        ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n+    }\n+\n+    pub fn re_early_bound(&self,\n+                          space: subst::ParamSpace,\n+                          index: uint,\n+                          name: &'static str)\n+                          -> ty::Region\n+    {\n+        let name = token::intern(name);\n+        ty::ReEarlyBound(ast::DUMMY_NODE_ID, space, index, name)\n+    }\n+\n+    pub fn re_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> ty::Region {\n+        ty::ReLateBound(debruijn, ty::BrAnon(id))\n+    }\n+\n+    pub fn t_rptr(&self, r: ty::Region) -> ty::t {\n+        ty::mk_imm_rptr(self.infcx.tcx, r, ty::mk_int())\n     }\n \n-    pub fn t_int(&self) -> ty::t {\n-        ty::mk_int()\n+    pub fn t_rptr_late_bound(&self, id: uint) -> ty::t {\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1)),\n+                        ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound(&self, binder_id: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReLateBound(binder_id, ty::BrAnon(id)),\n-                        self.t_int())\n+    pub fn t_rptr_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> ty::t {\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.re_late_bound_with_debruijn(id, debruijn),\n+                        ty::mk_int())\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), ty::mk_int())\n+    }\n+\n+    pub fn re_free(&self, nid: ast::NodeId, id: uint) -> ty::Region {\n+        ty::ReFree(ty::FreeRegion {scope_id: nid,\n+                                   bound_region: ty::BrAnon(id)})\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        ty::ReFree(ty::FreeRegion {scope_id: nid,\n-                                                    bound_region: ty::BrAnon(id)}),\n-                        self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, self.re_free(nid, id), ty::mk_int())\n     }\n \n     pub fn t_rptr_static(&self) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, ty::mk_int())\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace {\n@@ -301,10 +349,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         Glb(self.infcx.combine_fields(true, trace))\n     }\n \n-    pub fn resolve_regions(&self) {\n-        self.infcx.resolve_regions_and_report_errors();\n-    }\n-\n     pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n@@ -345,31 +389,11 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Checks that `LUB(t1,t2)` is undefined\n-    pub fn check_no_lub(&self, t1: ty::t, t2: ty::t) {\n-        match self.lub().tys(t1, t2) {\n-            Err(_) => {}\n-            Ok(t) => {\n-                panic!(\"unexpected success computing LUB: {}\", self.ty_to_string(t))\n-            }\n-        }\n-    }\n-\n-    /// Checks that `GLB(t1,t2)` is undefined\n-    pub fn check_no_glb(&self, t1: ty::t, t2: ty::t) {\n-        match self.glb().tys(t1, t2) {\n-            Err(_) => {}\n-            Ok(t) => {\n-                panic!(\"unexpected success computing GLB: {}\", self.ty_to_string(t))\n-            }\n-        }\n-    }\n }\n \n #[test]\n fn contravariant_region_ptr_ok() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr1 = env.t_rptr_scope(1);\n         let t_rptr10 = env.t_rptr_scope(10);\n@@ -381,8 +405,7 @@ fn contravariant_region_ptr_ok() {\n \n #[test]\n fn contravariant_region_ptr_err() {\n-    test_env(\"contravariant_region_ptr\",\n-             EMPTY_SOURCE_STR,\n+    test_env(EMPTY_SOURCE_STR,\n              errors(&[\"lifetime mismatch\"]),\n              |env| {\n                  env.create_simple_region_hierarchy();\n@@ -398,114 +421,273 @@ fn contravariant_region_ptr_err() {\n \n #[test]\n fn lub_bound_bound() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_bound_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free1], env.t_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_bound_static() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_bound_bound_inverse_order() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n-                      env.t_fn(22, &[t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n-                      env.t_fn(22, &[t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n+        env.check_lub(env.t_fn(&[t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n+                      env.t_fn(&[t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n+                      env.t_fn(&[t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n     })\n }\n \n #[test]\n fn lub_free_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_returning_scope() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR,\n+    test_env(EMPTY_SOURCE_STR,\n              errors(&[\"cannot infer an appropriate lifetime\"]), |env| {\n                  let t_rptr_scope10 = env.t_rptr_scope(10);\n                  let t_rptr_scope11 = env.t_rptr_scope(11);\n \n                  // this should generate an error when regions are resolved\n-                 env.make_lub_ty(env.t_fn(22, &[], t_rptr_scope10),\n-                                 env.t_fn(22, &[], t_rptr_scope11));\n+                 env.make_lub_ty(env.t_fn(&[], t_rptr_scope10),\n+                                 env.t_fn(&[], t_rptr_scope11));\n              })\n }\n \n #[test]\n fn glb_free_free_with_common_scope() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_scope = env.t_rptr_scope(0);\n-        env.check_glb(env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_scope], env.t_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_scope], ty::mk_int()));\n     })\n }\n \n #[test]\n fn glb_bound_bound() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn glb_bound_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn glb_bound_static() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n+\n+#[test]\n+fn subst_ty_renumber_bound() {\n+    /*!\n+     * Test substituting a bound region into a function, which introduces another\n+     * level of binding. This requires adjusting the Debruijn index.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors([]), |env| {\n+        // Situation:\n+        // Theta = [A -> &'a foo]\n+\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+\n+        // t_source = fn(A)\n+        let t_source = {\n+            let t_param = env.t_param(subst::TypeSpace, 0);\n+            env.t_fn([t_param], env.t_nil())\n+        };\n+\n+        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+\n+        // t_expected = fn(&'a int)\n+        let t_expected = {\n+            let t_ptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+            env.t_fn([t_ptr_bound2], env.t_nil())\n+        };\n+\n+        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n+               t_source.repr(env.infcx.tcx),\n+               substs.repr(env.infcx.tcx),\n+               t_substituted.repr(env.infcx.tcx),\n+               t_expected.repr(env.infcx.tcx));\n+\n+        assert_eq!(t_substituted, t_expected);\n+    })\n+}\n+\n+#[test]\n+fn subst_ty_renumber_some_bounds() {\n+    /*!\n+     * Test substituting a bound region into a function, which introduces another\n+     * level of binding. This requires adjusting the Debruijn index.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors([]), |env| {\n+        // Situation:\n+        // Theta = [A -> &'a foo]\n+\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+\n+        // t_source = (A, fn(A))\n+        let t_source = {\n+            let t_param = env.t_param(subst::TypeSpace, 0);\n+            env.t_pair(t_param, env.t_fn([t_param], env.t_nil()))\n+        };\n+\n+        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+\n+        // t_expected = (&'a int, fn(&'a int))\n+        //\n+        // but not that the Debruijn index is different in the different cases.\n+        let t_expected = {\n+            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+            env.t_pair(t_rptr_bound1, env.t_fn([t_rptr_bound2], env.t_nil()))\n+        };\n+\n+        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n+               t_source.repr(env.infcx.tcx),\n+               substs.repr(env.infcx.tcx),\n+               t_substituted.repr(env.infcx.tcx),\n+               t_expected.repr(env.infcx.tcx));\n+\n+        assert_eq!(t_substituted, t_expected);\n+    })\n+}\n+\n+#[test]\n+fn escaping() {\n+    /*!\n+     * Test that we correctly compute whether a type has escaping\n+     * regions or not.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors([]), |env| {\n+        // Situation:\n+        // Theta = [A -> &'a foo]\n+\n+        assert!(!ty::type_has_escaping_regions(env.t_nil()));\n+\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        assert!(!ty::type_has_escaping_regions(t_rptr_free1));\n+\n+        let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n+        assert!(ty::type_has_escaping_regions(t_rptr_bound1));\n+\n+        let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+        assert!(ty::type_has_escaping_regions(t_rptr_bound2));\n+\n+        // t_fn = fn(A)\n+        let t_param = env.t_param(subst::TypeSpace, 0);\n+        assert!(!ty::type_has_escaping_regions(t_param));\n+        let t_fn = env.t_fn([t_param], env.t_nil());\n+        assert!(!ty::type_has_escaping_regions(t_fn));\n+\n+        // t_fn = |&int|+'a\n+        let t_fn = env.t_closure([t_rptr_bound1], env.t_nil(), env.re_free(0, 1));\n+        assert!(!ty::type_has_escaping_regions(t_fn));\n+\n+        // t_fn = |&int|+'a (where &int has depth 2)\n+        let t_fn = env.t_closure([t_rptr_bound2], env.t_nil(), env.re_free(0, 1));\n+        assert!(ty::type_has_escaping_regions(t_fn));\n+\n+        // t_fn = |&int|+&int\n+        let t_fn = env.t_closure([t_rptr_bound1], env.t_nil(),\n+                                 env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1)));\n+        assert!(ty::type_has_escaping_regions(t_fn));\n+    })\n+}\n+\n+#[test]\n+fn subst_region_renumber_region() {\n+    /*!\n+     * Test applying a substitution where the value being substituted\n+     * for an early-bound region is a late-bound region.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors([]), |env| {\n+        let re_bound1 = env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n+\n+        // type t_source<'a> = fn(&'a int)\n+        let t_source = {\n+            let re_early = env.re_early_bound(subst::TypeSpace, 0, \"'a\");\n+            env.t_fn([env.t_rptr(re_early)], env.t_nil())\n+        };\n+\n+        let substs = subst::Substs::new_type(vec![], vec![re_bound1]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+\n+        // t_expected = fn(&'a int)\n+        //\n+        // but not that the Debruijn index is different in the different cases.\n+        let t_expected = {\n+            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+            env.t_fn([t_rptr_bound2], env.t_nil())\n+        };\n+\n+        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n+               t_source.repr(env.infcx.tcx),\n+               substs.repr(env.infcx.tcx),\n+               t_substituted.repr(env.infcx.tcx),\n+               t_expected.repr(env.infcx.tcx));\n+\n+        assert_eq!(t_substituted, t_expected);\n+    })\n+}\n+"}, {"sha": "8e3ae6ee3599f819bca0e1564283008c3b723489", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -269,7 +269,6 @@ pub fn trans_unboxing_shim(bcx: Block,\n     let self_type = fty.sig.inputs[0];\n     let boxed_self_type = ty::mk_uniq(tcx, self_type);\n     let boxed_function_type = ty::FnSig {\n-        binder_id: fty.sig.binder_id,\n         inputs: fty.sig.inputs.iter().enumerate().map(|(i, typ)| {\n             if i == 0 {\n                 boxed_self_type\n@@ -294,7 +293,6 @@ pub fn trans_unboxing_shim(bcx: Block,\n             // RustCall so the untupled arguments can be passed\n             // through verbatim.  This is kind of ugly.\n             let fake_ty = ty::FnSig {\n-                binder_id: fty.sig.binder_id,\n                 inputs: type_of::untuple_arguments_if_necessary(ccx,\n                                                                 fty.sig.inputs.as_slice(),\n                                                                 fty.abi),"}, {"sha": "a2510cbfa2774ecee2a3265a95bbd3d38186b123", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab0c588ff3adb8e9bf4209b59e08f90fe281903/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=4ab0c588ff3adb8e9bf4209b59e08f90fe281903", "patch": "@@ -609,9 +609,6 @@ pub fn get_vtable(bcx: Block,\n                             fn_style: closure_info.closure_type.fn_style,\n                             abi: Rust,\n                             sig: ty::FnSig {\n-                                binder_id: closure_info.closure_type\n-                                                       .sig\n-                                                       .binder_id,\n                                 inputs: new_inputs,\n                                 output: new_output,\n                                 variadic: false,"}]}