{"sha": "d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "node_id": "C_kwDOAAsO6NoAKGQ5NTZjOGI4MTZjMWJjYzM4MDUzZDZkZmQ3OWUzNGNkMTJiMGY0YjE", "commit": {"author": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-02-28T18:52:36Z"}, "committer": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-02-28T18:52:36Z"}, "message": "5 - Make more use of let_chains", "tree": {"sha": "f8c5405c113a130f818ac590898bd1fdce7093ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c5405c113a130f818ac590898bd1fdce7093ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "html_url": "https://github.com/rust-lang/rust/commit/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/comments", "author": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48132caac241b4a278d58e1d791c6d31f7439ad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/48132caac241b4a278d58e1d791c6d31f7439ad6", "html_url": "https://github.com/rust-lang/rust/commit/48132caac241b4a278d58e1d791c6d31f7439ad6"}], "stats": {"total": 131, "additions": 63, "deletions": 68}, "files": [{"sha": "6c296b59092772adad223accabb903e2c075a038", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "patch": "@@ -1113,22 +1113,20 @@ impl CheckAttrVisitor<'_> {\n     /// Warns against some misuses of `#[must_use]`\n     fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, _target: Target) -> bool {\n         let node = self.tcx.hir().get(hir_id);\n-        if let Some(fn_node) = node.fn_kind() {\n-            if let rustc_hir::IsAsync::Async = fn_node.asyncness() {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\n-                        \"`must_use` attribute on `async` functions \\\n-                              applies to the anonymous `Future` returned by the \\\n-                              function, not the value within\",\n-                    )\n-                    .span_label(\n-                        span,\n-                        \"this attribute does nothing, the `Future`s \\\n-                                returned by async functions are already `must_use`\",\n-                    )\n-                    .emit();\n-                });\n-            }\n+        if let Some(kind) = node.fn_kind() && let rustc_hir::IsAsync::Async = kind.asyncness() {\n+            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                lint.build(\n+                    \"`must_use` attribute on `async` functions \\\n+                    applies to the anonymous `Future` returned by the \\\n+                    function, not the value within\",\n+                )\n+                .span_label(\n+                    span,\n+                    \"this attribute does nothing, the `Future`s \\\n+                    returned by async functions are already `must_use`\",\n+                )\n+                .emit();\n+            });\n         }\n \n         // For now, its always valid"}, {"sha": "e438b521a952b8ccc8b38aac9a1e7b61b2a51891", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "patch": "@@ -683,34 +683,33 @@ impl<'tcx> DeadVisitor<'tcx> {\n                 let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n                 let mut err = lint.build(&format!(\"{} is never {}: `{}`\", descr, participle, name));\n                 let hir = self.tcx.hir();\n-                if let Some(encl_scope) = hir.get_enclosing_scope(id) {\n-                    if let Some(encl_def_id) = hir.opt_local_def_id(encl_scope) {\n-                        if let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id) {\n-                            let traits_str = ign_traits\n-                                .iter()\n-                                .map(|(trait_id, _)| format!(\"`{}`\", self.tcx.item_name(*trait_id)))\n-                                .collect::<Vec<_>>()\n-                                .join(\" and \");\n-                            let plural_s = pluralize!(ign_traits.len());\n-                            let article = if ign_traits.len() > 1 { \"\" } else { \"a \" };\n-                            let is_are = if ign_traits.len() > 1 { \"these are\" } else { \"this is\" };\n-                            let msg = format!(\n-                                \"`{}` has {}derived impl{} for the trait{} {}, but {} \\\n-                                 intentionally ignored during dead code analysis\",\n-                                self.tcx.item_name(encl_def_id.to_def_id()),\n-                                article,\n-                                plural_s,\n-                                plural_s,\n-                                traits_str,\n-                                is_are\n-                            );\n-                            let multispan = ign_traits\n-                                .iter()\n-                                .map(|(_, impl_id)| self.tcx.def_span(*impl_id))\n-                                .collect::<Vec<_>>();\n-                            err.span_note(multispan, &msg);\n-                        }\n-                    }\n+                if let Some(encl_scope) = hir.get_enclosing_scope(id)\n+                    && let Some(encl_def_id) = hir.opt_local_def_id(encl_scope)\n+                    && let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id)\n+                {\n+                    let traits_str = ign_traits\n+                        .iter()\n+                        .map(|(trait_id, _)| format!(\"`{}`\", self.tcx.item_name(*trait_id)))\n+                        .collect::<Vec<_>>()\n+                        .join(\" and \");\n+                    let plural_s = pluralize!(ign_traits.len());\n+                    let article = if ign_traits.len() > 1 { \"\" } else { \"a \" };\n+                    let is_are = if ign_traits.len() > 1 { \"these are\" } else { \"this is\" };\n+                    let msg = format!(\n+                        \"`{}` has {}derived impl{} for the trait{} {}, but {} \\\n+                        intentionally ignored during dead code analysis\",\n+                        self.tcx.item_name(encl_def_id.to_def_id()),\n+                        article,\n+                        plural_s,\n+                        plural_s,\n+                        traits_str,\n+                        is_are\n+                    );\n+                    let multispan = ign_traits\n+                        .iter()\n+                        .map(|(_, impl_id)| self.tcx.def_span(*impl_id))\n+                        .collect::<Vec<_>>();\n+                    err.span_note(multispan, &msg);\n                 }\n                 err.emit();\n             });"}, {"sha": "71d49d8b7ea9ca442179f0c7f0a6c47d88c1fabf", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "patch": "@@ -4,16 +4,17 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(iter_intersperse)]\n #![feature(let_else)]\n+#![feature(let_chains)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(nll)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_middle;"}, {"sha": "ea99a90e937c39a9a292bd1d08c85900e79a2ed3", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "patch": "@@ -332,12 +332,11 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         let def_id = local_def_id.to_def_id();\n \n         // Don't run unused pass for #[derive()]\n-        if let Some(parent) = self.tcx.parent(def_id) {\n-            if let DefKind::Impl = self.tcx.def_kind(parent.expect_local()) {\n-                if self.tcx.has_attr(parent, sym::automatically_derived) {\n-                    return;\n-                }\n-            }\n+        if let Some(parent) = self.tcx.parent(def_id)\n+            && let DefKind::Impl = self.tcx.def_kind(parent.expect_local())\n+            && self.tcx.has_attr(parent, sym::automatically_derived)\n+        {\n+            return;\n         }\n \n         // Don't run unused pass for #[naked]"}, {"sha": "b520e5d04eab98650b09844bc56e0df77bb4302e", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=d956c8b816c1bcc38053d6dfd79e34cd12b0f4b1", "patch": "@@ -94,24 +94,22 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n             _ => None,\n         };\n \n-        if let Some(res) = res {\n-            if let Some(def_id) = res.opt_def_id().and_then(|def_id| def_id.as_local()) {\n-                if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n-                    self.worklist.push(def_id);\n-                } else {\n-                    match res {\n-                        // If this path leads to a constant, then we need to\n-                        // recurse into the constant to continue finding\n-                        // items that are reachable.\n-                        Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n-                            self.worklist.push(def_id);\n-                        }\n+        if let Some(res) = res && let Some(def_id) = res.opt_def_id().and_then(|el| el.as_local()) {\n+            if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n+                self.worklist.push(def_id);\n+            } else {\n+                match res {\n+                    // If this path leads to a constant, then we need to\n+                    // recurse into the constant to continue finding\n+                    // items that are reachable.\n+                    Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n+                        self.worklist.push(def_id);\n+                    }\n \n-                        // If this wasn't a static, then the destination is\n-                        // surely reachable.\n-                        _ => {\n-                            self.reachable_symbols.insert(def_id);\n-                        }\n+                    // If this wasn't a static, then the destination is\n+                    // surely reachable.\n+                    _ => {\n+                        self.reachable_symbols.insert(def_id);\n                     }\n                 }\n             }"}]}