{"sha": "043c19c69c0beac3696cb82d44476ba4298a6b07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0M2MxOWM2OWMwYmVhYzM2OTZjYjgyZDQ0NDc2YmE0Mjk4YTZiMDc=", "commit": {"author": {"name": "Baoshan", "email": "pangbw@gmail.com", "date": "2019-08-29T16:29:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-29T16:29:23Z"}, "message": "Merge branch 'master' into bpang-runtest", "tree": {"sha": "1813e5dd1e4efd5806f401968b4ed34b8c9c76ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1813e5dd1e4efd5806f401968b4ed34b8c9c76ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/043c19c69c0beac3696cb82d44476ba4298a6b07", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdZ/1jCRBK7hj4Ov3rIwAAdHIIAB3gYm9gZYTl1Cx6aJc7f1dG\nXvFgl99lLPtImZIKr+//4j7rEQNCuiAmODxxpDpIolRNvBRFiJHKeD5EAOqD8S3H\nwZZ81EE3QkqVR2oR6tzBIpCCTxupwnj2UgKcLTnprUp1wri65744hoOvq/58Y7R0\nPQ+cBWJKTyXAqKb//dtLOsItzNveAP2ltR+BWNlc1a/SyX1uDw0kLiy0unC15dBa\nbm5LXYoC3oeGFU/s6YUb1RReOlYAIieKS+pLkwjhqz4ql+pdDXZq+SqLI8OwMupX\nenacjzqI0FKjP18EEtjdf/zvqX9AdlPb/zI0fBTe5ZdB7BmZeiVYKNlw8VcjFkk=\n=g9Dx\n-----END PGP SIGNATURE-----\n", "payload": "tree 1813e5dd1e4efd5806f401968b4ed34b8c9c76ac\nparent cae6d66d9989857e321e0963142b08b1517dc723\nparent 76f17219c71973fd4a58f2f8020eec4d8f5dcd11\nauthor Baoshan <pangbw@gmail.com> 1567096163 -0700\ncommitter GitHub <noreply@github.com> 1567096163 -0700\n\nMerge branch 'master' into bpang-runtest"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/043c19c69c0beac3696cb82d44476ba4298a6b07", "html_url": "https://github.com/rust-lang/rust/commit/043c19c69c0beac3696cb82d44476ba4298a6b07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/043c19c69c0beac3696cb82d44476ba4298a6b07/comments", "author": {"login": "BaoshanPang", "id": 3380860, "node_id": "MDQ6VXNlcjMzODA4NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3380860?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BaoshanPang", "html_url": "https://github.com/BaoshanPang", "followers_url": "https://api.github.com/users/BaoshanPang/followers", "following_url": "https://api.github.com/users/BaoshanPang/following{/other_user}", "gists_url": "https://api.github.com/users/BaoshanPang/gists{/gist_id}", "starred_url": "https://api.github.com/users/BaoshanPang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BaoshanPang/subscriptions", "organizations_url": "https://api.github.com/users/BaoshanPang/orgs", "repos_url": "https://api.github.com/users/BaoshanPang/repos", "events_url": "https://api.github.com/users/BaoshanPang/events{/privacy}", "received_events_url": "https://api.github.com/users/BaoshanPang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae6d66d9989857e321e0963142b08b1517dc723", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae6d66d9989857e321e0963142b08b1517dc723", "html_url": "https://github.com/rust-lang/rust/commit/cae6d66d9989857e321e0963142b08b1517dc723"}, {"sha": "76f17219c71973fd4a58f2f8020eec4d8f5dcd11", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f17219c71973fd4a58f2f8020eec4d8f5dcd11", "html_url": "https://github.com/rust-lang/rust/commit/76f17219c71973fd4a58f2f8020eec4d8f5dcd11"}], "stats": {"total": 20285, "additions": 12580, "deletions": 7705}, "files": [{"sha": "a7de7ce85593c140267bd3bafa3812859d8f259f", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -8,7 +8,7 @@\n src/etc/installer/gfx/* binary\n *.woff binary\n src/vendor/** -text\n-Cargo.lock -merge linguist-generated=false\n+Cargo.lock linguist-generated=false\n \n # Older git versions try to fix line endings on images, this prevents it.\n *.png binary"}, {"sha": "660f2ba237008f0d42ff1b7d637786edcfe58d42", "filename": "Cargo.lock", "status": "modified", "additions": 1928, "deletions": 1910, "changes": 3838, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=043c19c69c0beac3696cb82d44476ba4298a6b07"}, {"sha": "724bc36ecc6fb7fd2bb6b9783416528c7554b9ae", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -144,7 +144,7 @@ then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```batch\n-> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n+> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n > python x.py build\n ```\n "}, {"sha": "f26f6e6c888eda387ced2872b2e6eb3dc9074f75", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -22,7 +22,7 @@ Language\n - [You can now use `_` as an identifier for consts.][61347] e.g. You can write\n   `const _: u32 = 5;`.\n - [You can now use `#[repr(align(X)]` on enums.][61229]\n-- [The  `?`/_\"Kleene\"_ macro operator is now available in the\n+- [The  `?` Kleene macro operator is now available in the\n   2015 edition.][60932]\n \n Compiler"}, {"sha": "a3ec4f2044cbd720fe469e89d744d0294a6f42cd", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -141,10 +141,10 @@\n # library and facade crates.\n #compiler-docs = false\n \n-# Indicate whether submodules are managed and updated automatically.\n+# Indicate whether git submodules are managed and updated automatically.\n #submodules = true\n \n-# Update submodules only when the checked out commit in the submodules differs\n+# Update git submodules only when the checked out commit in the submodules differs\n # from what is committed in the main rustc repo.\n #fast-submodules = true\n "}, {"sha": "ce92ce026967117016ab27620dafaad86770e207", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -37,26 +37,14 @@ fn main() {\n             let mut new = None;\n             if let Some(current_as_str) = args[i].to_str() {\n                 if (&*args[i - 1] == \"-C\" && current_as_str.starts_with(\"metadata\")) ||\n-                   current_as_str.starts_with(\"-Cmetadata\") {\n+                    current_as_str.starts_with(\"-Cmetadata\") {\n                     new = Some(format!(\"{}-{}\", current_as_str, s));\n                 }\n             }\n             if let Some(new) = new { args[i] = new.into(); }\n         }\n     }\n \n-    // Drop `--error-format json` because despite our desire for json messages\n-    // from Cargo we don't want any from rustc itself.\n-    if let Some(n) = args.iter().position(|n| n == \"--error-format\") {\n-        args.remove(n);\n-        args.remove(n);\n-    }\n-\n-    if let Some(s) = env::var_os(\"RUSTC_ERROR_FORMAT\") {\n-        args.push(\"--error-format\".into());\n-        args.push(s);\n-    }\n-\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n     let target = args.windows(2)\n@@ -101,7 +89,7 @@ fn main() {\n     if let Some(crate_name) = crate_name {\n         if let Some(target) = env::var_os(\"RUSTC_TIME\") {\n             if target == \"all\" ||\n-               target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n+                target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n             {\n                 cmd.arg(\"-Ztime\");\n             }\n@@ -110,8 +98,17 @@ fn main() {\n \n     // Non-zero stages must all be treated uniformly to avoid problems when attempting to uplift\n     // compiler libraries and such from stage 1 to 2.\n+    //\n+    // FIXME: the fact that core here is excluded is due to core_arch from our stdarch submodule\n+    // being broken on the beta compiler with bootstrap passed, so this is a temporary workaround\n+    // (we've just snapped, so there are no cfg(bootstrap) related annotations in core).\n     if stage == \"0\" {\n-        cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+        if crate_name != Some(\"core\") {\n+            cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+        } else {\n+            // NOTE(eddyb) see FIXME above, except now we need annotations again in core.\n+            cmd.arg(\"--cfg\").arg(\"boostrap_stdarch_ignore_this\");\n+        }\n     }\n \n     // Print backtrace in case of ICE\n@@ -132,10 +129,7 @@ fn main() {\n         cmd.arg(\"-Dwarnings\");\n         cmd.arg(\"-Drust_2018_idioms\");\n         cmd.arg(\"-Dunused_lifetimes\");\n-        // cfg(not(bootstrap)): Remove this during the next stage 0 compiler update.\n-        // `-Drustc::internal` is a new feature and `rustc_version` mis-reports the `stage`.\n-        let cfg_not_bootstrap = stage != \"0\" && crate_name != Some(\"rustc_version\");\n-        if cfg_not_bootstrap && use_internal_lints(crate_name) {\n+        if use_internal_lints(crate_name) {\n             cmd.arg(\"-Zunstable-options\");\n             cmd.arg(\"-Drustc::internal\");\n         }\n@@ -287,10 +281,6 @@ fn main() {\n                 cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n             }\n         }\n-\n-        if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n-            cmd.arg(\"--remap-path-prefix\").arg(&map);\n-        }\n     } else {\n         // Override linker if necessary.\n         if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n@@ -307,6 +297,10 @@ fn main() {\n         }\n     }\n \n+    if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n+        cmd.arg(\"--remap-path-prefix\").arg(&map);\n+    }\n+\n     // Force all crates compiled by this compiler to (a) be unstable and (b)\n     // allow the `rustc_private` feature to link to other unstable crates\n     // also in the sysroot. We also do this for host crates, since those"}, {"sha": "955809e80747b5a1ff5bd32951ca3d4c3de328e7", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 41, "deletions": 81, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -145,7 +145,7 @@ impl StepDescription {\n             only_hosts: S::ONLY_HOSTS,\n             should_run: S::should_run,\n             make_run: S::make_run,\n-            name: unsafe { ::std::intrinsics::type_name::<S>() },\n+            name: std::any::type_name::<S>(),\n         }\n     }\n \n@@ -618,13 +618,7 @@ impl<'a> Builder<'a> {\n             }\n \n             fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n-                let compiler = self.compiler;\n-                let config = &builder.build.config;\n-                let lib = if compiler.stage >= 1 && config.libdir_relative().is_some() {\n-                    builder.build.config.libdir_relative().unwrap()\n-                } else {\n-                    Path::new(\"lib\")\n-                };\n+                let lib = builder.sysroot_libdir_relative(self.compiler);\n                 let sysroot = builder\n                     .sysroot(self.compiler)\n                     .join(lib)\n@@ -678,6 +672,18 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n+    /// Returns the compiler's relative libdir where the standard library and other artifacts are\n+    /// found for a compiler's sysroot.\n+    ///\n+    /// For example this returns `lib` on Unix and Windows.\n+    pub fn sysroot_libdir_relative(&self, compiler: Compiler) -> &Path {\n+        match self.config.libdir_relative() {\n+            Some(relative_libdir) if compiler.stage >= 1\n+                => relative_libdir,\n+            _ => Path::new(\"lib\")\n+        }\n+    }\n+\n     /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic\n     /// library lookup path.\n     pub fn add_rustc_lib_path(&self, compiler: Compiler, cmd: &mut Command) {\n@@ -754,76 +760,20 @@ impl<'a> Builder<'a> {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n \n-        // command specific path, we call clear_if_dirty with this\n-        let mut my_out = match cmd {\n-            \"build\" => self.cargo_out(compiler, mode, target),\n-\n-            // This is the intended out directory for crate documentation.\n-            \"doc\" | \"rustdoc\" =>  self.crate_doc_out(target),\n-\n-            _ => self.stage_out(compiler, mode),\n-        };\n-\n-        // This is for the original compiler, but if we're forced to use stage 1, then\n-        // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n-        // we copy the libs forward.\n-        let cmp = self.compiler_for(compiler.stage, compiler.host, target);\n-\n-        let libstd_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::libstd_stamp(self, cmp, target),\n-            _ => compile::libstd_stamp(self, cmp, target),\n-        };\n-\n-        let libtest_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::libtest_stamp(self, cmp, target),\n-            _ => compile::libtest_stamp(self, cmp, target),\n-        };\n-\n-        let librustc_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::librustc_stamp(self, cmp, target),\n-            _ => compile::librustc_stamp(self, cmp, target),\n-        };\n+        // Codegen backends are not yet tracked by -Zbinary-dep-depinfo,\n+        // so we need to explicitly clear out if they've been updated.\n+        for backend in self.codegen_backends(compiler) {\n+            self.clear_if_dirty(&out_dir, &backend);\n+        }\n \n         if cmd == \"doc\" || cmd == \"rustdoc\" {\n-            if mode == Mode::Rustc || mode == Mode::ToolRustc || mode == Mode::Codegen {\n+            let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n-                my_out = self.compiler_doc_out(target);\n-            }\n+                Mode::Rustc | Mode::ToolRustc | Mode::Codegen => self.compiler_doc_out(target),\n+                _ => self.crate_doc_out(target),\n+            };\n             let rustdoc = self.rustdoc(compiler);\n             self.clear_if_dirty(&my_out, &rustdoc);\n-        } else if cmd != \"test\" {\n-            match mode {\n-                Mode::Std => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    for backend in self.codegen_backends(compiler) {\n-                        self.clear_if_dirty(&my_out, &backend);\n-                    }\n-                },\n-                Mode::Test => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::Rustc => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::Codegen => {\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-                Mode::ToolBootstrap => { },\n-                Mode::ToolStd => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::ToolTest => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::ToolRustc => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-            }\n         }\n \n         cargo\n@@ -861,6 +811,19 @@ impl<'a> Builder<'a> {\n             },\n         }\n \n+        // This tells Cargo (and in turn, rustc) to output more complete\n+        // dependency information.  Most importantly for rustbuild, this\n+        // includes sysroot artifacts, like libstd, which means that we don't\n+        // need to track those in rustbuild (an error prone process!). This\n+        // feature is currently unstable as there may be some bugs and such, but\n+        // it represents a big improvement in rustbuild's reliability on\n+        // rebuilds, so we're using it here.\n+        //\n+        // For some additional context, see #63470 (the PR originally adding\n+        // this), as well as #63012 which is the tracking issue for this\n+        // feature on the rustc side.\n+        cargo.arg(\"-Zbinary-dep-depinfo\");\n+\n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n         // Remove make-related flags to ensure Cargo can correctly set things up\n         cargo.env_remove(\"MAKEFLAGS\");\n@@ -902,12 +865,12 @@ impl<'a> Builder<'a> {\n             stage = compiler.stage;\n         }\n \n-        let mut extra_args = env::var(&format!(\"RUSTFLAGS_STAGE_{}\", stage)).unwrap_or_default();\n+        let mut extra_args = String::new();\n         if stage != 0 {\n-            let s = env::var(\"RUSTFLAGS_STAGE_NOT_0\").unwrap_or_default();\n-            if !extra_args.is_empty() {\n-                extra_args.push_str(\" \");\n-            }\n+            let s = env::var(\"RUSTFLAGS_NOT_BOOTSTRAP\").unwrap_or_default();\n+            extra_args.push_str(&s);\n+        } else {\n+            let s = env::var(\"RUSTFLAGS_BOOTSTRAP\").unwrap_or_default();\n             extra_args.push_str(&s);\n         }\n \n@@ -980,9 +943,6 @@ impl<'a> Builder<'a> {\n         if let Some(target_linker) = self.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n-        if let Some(ref error_format) = self.config.rustc_error_format {\n-            cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n-        }\n         if !([\"build\", \"check\", \"clippy\", \"fix\", \"rustc\"].contains(&cmd)) && want_rustdoc {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler));\n         }"}, {"sha": "caa4843da4d369a1230c5be822be02329a889475", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.38.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.39.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "6e6fea6b831a7507f3835fa21c3032d6f9459b71", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -245,7 +245,6 @@ impl Step for Rustdoc {\n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n         add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n-        builder.cargo(compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n "}, {"sha": "96987d081594f019bfe6350da04d338014777f25", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -15,7 +15,7 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio, exit};\n use std::str;\n \n-use build_helper::{output, mtime, t, up_to_date};\n+use build_helper::{output, t, up_to_date};\n use filetime::FileTime;\n use serde::Deserialize;\n use serde_json;\n@@ -274,8 +274,6 @@ impl Step for StdLink {\n             // for reason why the sanitizers are not built in stage0.\n             copy_apple_sanitizer_dylibs(builder, &builder.native_dir(target), \"osx\", &libdir);\n         }\n-\n-        builder.cargo(target_compiler, Mode::ToolStd, target, \"clean\");\n     }\n }\n \n@@ -480,8 +478,6 @@ impl Step for TestLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &libtest_stamp(builder, compiler, target)\n         );\n-\n-        builder.cargo(target_compiler, Mode::ToolTest, target, \"clean\");\n     }\n }\n \n@@ -639,7 +635,6 @@ impl Step for RustcLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &librustc_stamp(builder, compiler, target)\n         );\n-        builder.cargo(target_compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n \n@@ -795,6 +790,9 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n             if builder.config.llvm_use_libcxx {\n                 cargo.env(\"LLVM_USE_LIBCXX\", \"1\");\n             }\n+            if builder.config.llvm_optimize && !builder.config.llvm_release_debuginfo {\n+                cargo.env(\"LLVM_NDEBUG\", \"1\");\n+            }\n         }\n         _ => panic!(\"unknown backend: {}\", backend),\n     }\n@@ -1116,10 +1114,6 @@ pub fn run_cargo(builder: &Builder<'_>,\n                 },\n                 ..\n             } => (filenames, crate_types),\n-            CargoMessage::CompilerMessage { message } => {\n-                eprintln!(\"{}\", message.rendered);\n-                return;\n-            }\n             _ => return,\n         };\n         for filename in filenames {\n@@ -1206,41 +1200,13 @@ pub fn run_cargo(builder: &Builder<'_>,\n         deps.push((path_to_add.into(), false));\n     }\n \n-    // Now we want to update the contents of the stamp file, if necessary. First\n-    // we read off the previous contents along with its mtime. If our new\n-    // contents (the list of files to copy) is different or if any dep's mtime\n-    // is newer then we rewrite the stamp file.\n     deps.sort();\n-    let stamp_contents = fs::read(stamp);\n-    let stamp_mtime = mtime(&stamp);\n     let mut new_contents = Vec::new();\n-    let mut max = None;\n-    let mut max_path = None;\n     for (dep, proc_macro) in deps.iter() {\n-        let mtime = mtime(dep);\n-        if Some(mtime) > max {\n-            max = Some(mtime);\n-            max_path = Some(dep.clone());\n-        }\n         new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n-    let max = max.unwrap();\n-    let max_path = max_path.unwrap();\n-    let contents_equal = stamp_contents\n-        .map(|contents| contents == new_contents)\n-        .unwrap_or_default();\n-    if contents_equal && max <= stamp_mtime {\n-        builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n-                stamp, max, stamp_mtime));\n-        return deps.into_iter().map(|(d, _)| d).collect()\n-    }\n-    if max > stamp_mtime {\n-        builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n-    } else {\n-        builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n-    }\n     t!(fs::write(&stamp, &new_contents));\n     deps.into_iter().map(|(d, _)| d).collect()\n }\n@@ -1256,8 +1222,12 @@ pub fn stream_cargo(\n     }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n-    cargo.arg(\"--message-format\").arg(\"json\")\n-         .stdout(Stdio::piped());\n+    let mut message_format = String::from(\"json-render-diagnostics\");\n+    if let Some(s) = &builder.config.rustc_error_format  {\n+        message_format.push_str(\",json-diagnostic-\");\n+        message_format.push_str(s);\n+    }\n+    cargo.arg(\"--message-format\").arg(message_format).stdout(Stdio::piped());\n \n     for arg in tail_args {\n         cargo.arg(arg);\n@@ -1310,12 +1280,4 @@ pub enum CargoMessage<'a> {\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,\n     },\n-    CompilerMessage {\n-        message: ClippyMessage<'a>\n-    }\n-}\n-\n-#[derive(Deserialize)]\n-pub struct ClippyMessage<'a> {\n-    rendered: Cow<'a, str>,\n }"}, {"sha": "213ceb194a8142f3e2ad6b8c6a6f2158efe2b2c4", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -469,7 +469,6 @@ impl Step for Rustc {\n         fn prepare_image(builder: &Builder<'_>, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n             let src = builder.sysroot(compiler);\n-            let libdir = builder.rustc_libdir(compiler);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n@@ -481,20 +480,26 @@ impl Step for Rustc {\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir_relative.to_str() != Some(\"bin\") {\n+                let libdir = builder.rustc_libdir(compiler);\n                 for entry in builder.read_dir(&libdir) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            builder.install(&entry.path(), &image.join(&libdir_relative), 0o644);\n+                            // Don't use custom libdir here because ^lib/ will be resolved again\n+                            // with installer\n+                            builder.install(&entry.path(), &image.join(\"lib\"), 0o644);\n                         }\n                     }\n                 }\n             }\n \n             // Copy over the codegen backends\n             let backends_src = builder.sysroot_codegen_backends(compiler);\n-            let backends_rel = backends_src.strip_prefix(&src).unwrap();\n-            let backends_dst = image.join(&backends_rel);\n+            let backends_rel = backends_src.strip_prefix(&src).unwrap()\n+                .strip_prefix(builder.sysroot_libdir_relative(compiler)).unwrap();\n+            // Don't use custom libdir here because ^lib/ will be resolved again with installer\n+            let backends_dst = image.join(\"lib\").join(&backends_rel);\n+\n             t!(fs::create_dir_all(&backends_dst));\n             builder.cp_r(&backends_src, &backends_dst);\n "}, {"sha": "e0a1f46078d32295977e3b6f7832de077d2d21c9", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -81,5 +81,14 @@ ci-subset-1:\n ci-subset-2:\n \t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n \n+TESTS_IN_MINGW_2 := \\\n+\tsrc/test/ui \\\n+\tsrc/test/compile-fail\n+\n+ci-mingw-subset-1:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2:%=--exclude %)\n+ci-mingw-subset-2:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2)\n+\n \n .PHONY: dist"}, {"sha": "bffe748f37cc16270661c756ffa9b0099bb61be7", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -202,10 +202,6 @@ pub fn check(build: &mut Build) {\n                         panic!(\"couldn't find libc.a in musl dir: {}\",\n                                root.join(\"lib\").display());\n                     }\n-                    if fs::metadata(root.join(\"lib/libunwind.a\")).is_err() {\n-                        panic!(\"couldn't find libunwind.a in musl dir: {}\",\n-                               root.join(\"lib\").display());\n-                    }\n                 }\n                 None => {\n                     panic!(\"when targeting MUSL either the rust.musl-root \\"}, {"sha": "77c9cda58b8e6d8312ed9a9c7c8fdb4f9d92d344", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -272,8 +272,8 @@ jobs:\n       i686-mingw-1:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-        SCRIPT: make ci-subset-1\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        SCRIPT: make ci-mingw-subset-1\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n         # FIXME(#59637)\n@@ -282,25 +282,25 @@ jobs:\n       i686-mingw-2:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-        SCRIPT: make ci-subset-2\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        SCRIPT: make ci-mingw-subset-2\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n       x86_64-mingw-1:\n         MSYS_BITS: 64\n-        SCRIPT: make ci-subset-1\n+        SCRIPT: make ci-mingw-subset-1\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       x86_64-mingw-2:\n         MSYS_BITS: 64\n-        SCRIPT: make ci-subset-2\n+        SCRIPT: make ci-mingw-subset-2\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n \n@@ -327,7 +327,7 @@ jobs:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n         SCRIPT: python x.py dist\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n         DIST_REQUIRE_ALL_TOOLS: 1\n@@ -336,7 +336,7 @@ jobs:\n         MSYS_BITS: 64\n         SCRIPT: python x.py dist\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n         DIST_REQUIRE_ALL_TOOLS: 1"}, {"sha": "14daf81b430755cda020c104ec9da8a8cc138f2c", "filename": "src/ci/azure-pipelines/steps/install-clang.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -36,7 +36,7 @@ steps:\n     set -e\n     mkdir -p citools\n     cd citools\n-    curl -f https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/LLVM-7.0.0-win64.tar.gz | tar xzf -\n+    curl -f https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/LLVM-7.0.0-win64.tar.gz | tar xzf -\n     echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --set llvm.clang-cl=`pwd`/clang-rust/bin/clang-cl.exe\"\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n   displayName: Install clang (Windows)"}, {"sha": "d4679c1c6733e50807df5f8c61dec675a15e031c", "filename": "src/ci/azure-pipelines/steps/install-sccache.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -2,14 +2,14 @@ steps:\n \n - bash: |\n     set -e\n-    curl -fo /usr/local/bin/sccache https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin\n+    curl -fo /usr/local/bin/sccache https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-apple-darwin\n     chmod +x /usr/local/bin/sccache\n   displayName: Install sccache (OSX)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n \n - script: |\n     md sccache\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n     echo ##vso[task.prependpath]%CD%\\sccache\n   displayName: Install sccache (Windows)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "9aaeb4b79d63410ff36f91d64185ca4f6c6e5c75", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -4,7 +4,7 @@ steps:\n # https://github.com/wixtoolset/wix3 originally\n - bash: |\n     set -e\n-    curl -O https://rust-lang-ci2.s3-us-west-1.amazonaws.com/rust-ci-mirror/wix311-binaries.zip\n+    curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/wix311-binaries.zip\n     echo \"##vso[task.setvariable variable=WIX]`pwd`/wix\"\n     mkdir -p wix/bin\n     cd wix/bin\n@@ -18,7 +18,7 @@ steps:\n # one is MSI installers and one is EXE, but they're not used so frequently at\n # this point anyway so perhaps it's a wash!\n - script: |\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-08-22-is.exe\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\"\n     is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n     echo ##vso[task.prependpath]C:\\Program Files (x86)\\Inno Setup 5\n   displayName: Install InnoSetup\n@@ -109,7 +109,7 @@ steps:\n # Note that this is originally from the github releases patch of Ninja\n - script: |\n     md ninja\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-03-15-ninja-win.zip\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\"\n     7z x -oninja 2017-03-15-ninja-win.zip\n     del 2017-03-15-ninja-win.zip\n     set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja"}, {"sha": "ac6b344a45e66a8b32433980992bb7b6de6943fa", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -199,7 +199,7 @@ steps:\n # Upload CPU usage statistics that we've been gathering this whole time. Always\n # execute this step in case we want to inspect failed builds, but don't let\n # errors here ever fail the build since this is just informational.\n-- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$SYSTEM_JOBNAME.csv\n+- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$CI_JOB_NAME.csv\n   env:\n     AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n   condition: variables['AWS_SECRET_ACCESS_KEY']"}, {"sha": "9493b33698708b08449d55d4b30ee3b54151c355", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -72,7 +72,7 @@ RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!\n # Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n-RUN curl -O https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/vexpress-v2p-ca15-tc1.dtb\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "29cfb5d96083ef6eabbe39e400d2a939bc60590c", "filename": "src/ci/docker/dist-various-1/install-mips-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mips-linux-musl\n # originally from\n # https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/\n # OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\"\n+URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n FILE=\"OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mips-linux-musl --strip-components=2\n "}, {"sha": "f04ee78157167104e53c37390677ae6dfa0af131", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -5,7 +5,7 @@\n set -ex\n \n # Originally from https://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-curl https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n   tar xJf -\n export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n "}, {"sha": "be8a6c93945e96f7d8c7323b4a917df15e3c8910", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -4,7 +4,7 @@ set -ex\n source shared.sh\n \n VERSION=1.0.2k\n-URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/openssl-$VERSION.tar.gz\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/openssl-$VERSION.tar.gz\n \n curl $URL | tar xzf -\n "}, {"sha": "797f674b954f2e54c272cb6b4b2a9bb3f512cc25", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -25,7 +25,7 @@ cd netbsd\n \n mkdir -p /x-tools/x86_64-unknown-netbsd/sysroot\n \n-URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/source/sets/*.tgz\n curl $URL/2018-03-01-netbsd-src.tgz | tar xzf -"}, {"sha": "c9e2961f6eb156ca8de88dd6ee51aff71bc8ff8f", "filename": "src/ci/docker/scripts/android-sdk-manager.py", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -23,8 +23,9 @@\n HOST_OS = \"linux\"\n \n # Mirroring options\n-MIRROR_BUCKET = \"rust-lang-ci2\"\n-MIRROR_BASE_DIR = \"rust-ci-mirror/android/\"\n+MIRROR_BUCKET = \"rust-lang-ci-mirrors\"\n+MIRROR_BUCKET_REGION = \"us-west-1\"\n+MIRROR_BASE_DIR = \"rustc/android/\"\n \n import argparse\n import hashlib\n@@ -144,7 +145,8 @@ def cli_install(args):\n     lockfile = Lockfile(args.lockfile)\n     for package in lockfile.packages.values():\n         # Download the file from the mirror into a temp file\n-        url = \"https://\" + MIRROR_BUCKET + \".s3.amazonaws.com/\" + MIRROR_BASE_DIR\n+        url = \"https://\" + MIRROR_BUCKET + \".s3-\" + MIRROR_BUCKET_REGION + \\\n+              \".amazonaws.com/\" + MIRROR_BASE_DIR\n         downloaded = package.download(url)\n         # Extract the file in a temporary directory\n         extract_dir = tempfile.mkdtemp()"}, {"sha": "70155e770a960281eb90668a7485b8a249889938", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -59,7 +59,7 @@ done\n \n # Originally downloaded from:\n # https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n-URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n curl \"$URL\" | tar xJf - -C \"$sysroot\" --wildcards \"${files_to_extract[@]}\"\n \n # Fix up absolute symlinks from the system image.  This can be removed"}, {"sha": "74ba2f0eadb25602f8718520f1fa08e0ed0e981f", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -54,29 +54,3 @@ if [ \"$REPLACE_CC\" = \"1\" ]; then\n         ln -s $TARGET-g++ /usr/local/bin/$exec\n     done\n fi\n-\n-export CC=$TARGET-gcc\n-export CXX=$TARGET-g++\n-\n-LLVM=70\n-\n-# may have been downloaded in a previous run\n-if [ ! -d libunwind-release_$LLVM ]; then\n-  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n-  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n-fi\n-\n-# fixme(mati865): Replace it with https://github.com/rust-lang/rust/pull/59089\n-mkdir libunwind-build\n-cd libunwind-build\n-cmake ../libunwind-release_$LLVM \\\n-          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n-          -DLIBUNWIND_ENABLE_SHARED=0 \\\n-          -DCMAKE_C_COMPILER=$CC \\\n-          -DCMAKE_CXX_COMPILER=$CXX \\\n-          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n-          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n-\n-hide_output make -j$(nproc)\n-cp lib/libunwind.a $OUTPUT/$TARGET/lib\n-cd - && rm -rf libunwind-build"}, {"sha": "d847c407aba679135ca14c7b56cf50b0ca3ed0b3", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -20,6 +20,8 @@ exit 1\n TAG=$1\n shift\n \n+# Ancient binutils versions don't understand debug symbols produced by more recent tools.\n+# Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n MUSL=musl-1.1.22\n@@ -38,27 +40,3 @@ else\n fi\n hide_output make install\n hide_output make clean\n-\n-cd ..\n-\n-LLVM=70\n-\n-# may have been downloaded in a previous run\n-if [ ! -d libunwind-release_$LLVM ]; then\n-  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n-  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n-fi\n-\n-mkdir libunwind-build\n-cd libunwind-build\n-cmake ../libunwind-release_$LLVM \\\n-          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n-          -DLIBUNWIND_ENABLE_SHARED=0 \\\n-          -DCMAKE_C_COMPILER=$CC \\\n-          -DCMAKE_CXX_COMPILER=$CXX \\\n-          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n-          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n-\n-hide_output make -j$(nproc)\n-cp lib/libunwind.a /musl-$TAG/lib\n-cd ../ && rm -rf libunwind-build"}, {"sha": "efeb0ed0d72d0f9461f17a4f701039e2f4dee1d7", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,6 +1,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n+  https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "69c8d2e3099ab9bdf70e8dc8894495fe011b6d68", "filename": "src/ci/install-awscli.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finstall-awscli.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -16,7 +16,7 @@\n set -euo pipefail\n IFS=$'\\n\\t'\n \n-MIRROR=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-07-27-awscli.tar\"\n+MIRROR=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-07-27-awscli.tar\"\n DEPS_DIR=\"/tmp/awscli-deps\"\n \n pip=\"pip\""}, {"sha": "457ba9717120710623411d44e7d8afdca1831882", "filename": "src/ci/run.sh", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -78,6 +78,21 @@ if [ \"$RUST_RELEASE_CHANNEL\" = \"nightly\" ] || [ \"$DIST_REQUIRE_ALL_TOOLS\" = \"\" ]\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-missing-tools\"\n fi\n \n+# Print the date from the local machine and the date from an external source to\n+# check for clock drifts. An HTTP URL is used instead of HTTPS since on Azure\n+# Pipelines it happened that the certificates were marked as expired.\n+datecheck() {\n+  echo \"== clock drift check ==\"\n+  echo -n \"  local time: \"\n+  date\n+  echo -n \"  network time: \"\n+  curl -fs --head http://detectportal.firefox.com/success.txt | grep ^Date: \\\n+      | sed 's/Date: //g' || true\n+  echo \"== end clock drift check ==\"\n+}\n+datecheck\n+trap datecheck EXIT\n+\n # We've had problems in the past of shell scripts leaking fds into the sccache\n # server (#48192) which causes Cargo to erroneously think that a build script\n # hasn't finished yet. Try to solve that problem by starting a very long-lived"}, {"sha": "dfd8e9db3c5c9cacb236c7d1cacc84791649920f", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -70,7 +70,7 @@ for details on how to format and write long error codes.\n   [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n   [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n   [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n-  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n+  [librustc_plugin_impl](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n   [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n * Explanations have full markdown support. Use it, especially to highlight\n code with backticks."}, {"sha": "8ebacb44d37cc2151f4883020e499d23f9bab0ef", "filename": "src/doc/unstable-book/src/language-features/or-patterns.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,36 @@\n+# `or_patterns`\n+\n+The tracking issue for this feature is: [#54883]\n+\n+[#54883]: https://github.com/rust-lang/rust/issues/54883\n+\n+------------------------\n+\n+The `or_pattern` language feature allows `|` to be arbitrarily nested within\n+a pattern, for example, `Some(A(0) | B(1 | 2))` becomes a valid pattern.\n+\n+## Examples\n+\n+```rust,ignore\n+#![feature(or_patterns)]\n+\n+pub enum Foo {\n+    Bar,\n+    Baz,\n+    Quux,\n+}\n+\n+pub fn example(maybe_foo: Option<Foo>) {\n+    match maybe_foo {\n+        Some(Foo::Bar | Foo::Baz) => {\n+            println!(\"The value contained `Bar` or `Baz`\");\n+        }\n+        Some(_) => {\n+            println!(\"The value did not contain `Bar` or `Baz`\");\n+        }\n+        None => {\n+            println!(\"The value was `None`\");\n+        }\n+    }\n+}\n+```"}, {"sha": "53e8393ec52e462a8a7d1bbcae839dbd91b4d3c1", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -18,7 +18,7 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n A plugin is a dynamic library crate with a designated *registrar* function that\n registers extensions with `rustc`. Other crates can load these extensions using\n the crate attribute `#![plugin(...)]`.  See the\n-`rustc_plugin` documentation for more about the\n+`rustc_driver::plugin` documentation for more about the\n mechanics of defining and loading a plugin.\n \n If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n@@ -54,13 +54,13 @@ that implements Roman numeral integer literals.\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc;\n-extern crate rustc_plugin;\n+extern crate rustc_driver;\n \n use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax_pos::Span;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<dyn MacResult + 'static> {\n@@ -180,11 +180,11 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n+extern crate rustc_driver;\n \n use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n                   EarlyLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ast;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");"}, {"sha": "c61e3183409f267fcf83a9565ece1b58efdd096f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -91,8 +91,10 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n+use core::slice;\n use core::task::{Context, Poll};\n \n+use crate::alloc::{self, Global, Alloc};\n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -121,6 +123,34 @@ impl<T> Box<T> {\n         box x\n     }\n \n+    /// Constructs a new box with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = unsafe {\n+            Global.alloc(layout)\n+                .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+        };\n+        Box(ptr.cast().into())\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -130,6 +160,111 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T> Box<[T]> {\n+    /// Constructs a new boxed slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n+        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let ptr = unsafe { alloc::alloc(layout) };\n+        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n+        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        Box(Unique::from(slice))\n+    }\n+}\n+\n+impl<T> Box<mem::MaybeUninit<T>> {\n+    /// Converts to `Box<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five: Box<u32> = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<T> {\n+        Box(Box::into_unique(self).cast())\n+    }\n+}\n+\n+impl<T> Box<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Box<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the values\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<[T]> {\n+        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+    }\n+}\n+\n impl<T: ?Sized> Box<T> {\n     /// Constructs a box from a raw pointer.\n     ///"}, {"sha": "3d04f30e7bde54bf2c8e832bcd4cedb40688fbb8", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1163,6 +1163,9 @@ impl<T> FusedIterator for Drain<'_, T> {}\n \n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n+    /// Converts a `Vec<T>` into a `BinaryHeap<T>`.\n+    ///\n+    /// This conversion happens in-place, and has `O(n)` time complexity.\n     fn from(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n         heap.rebuild();"}, {"sha": "0b5a271dbea956ef032d21c2aed12802b957faf0", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -106,8 +106,8 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: uninit_array![_; CAPACITY],\n-            vals: uninit_array![_; CAPACITY],\n+            keys: [MaybeUninit::UNINIT; CAPACITY],\n+            vals: [MaybeUninit::UNINIT; CAPACITY],\n             parent: ptr::null(),\n             parent_idx: MaybeUninit::uninit(),\n             len: 0\n@@ -159,7 +159,7 @@ impl<K, V> InternalNode<K, V> {\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n-            edges: uninit_array![_; 2*B],\n+            edges: [MaybeUninit::UNINIT; 2*B]\n         }\n     }\n }"}, {"sha": "f1f22fe48c58ab0c4343a82dbd7ecfd26708c9c3", "filename": "src/liballoc/collections/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -41,32 +41,35 @@ pub use linked_list::LinkedList;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;\n \n-use crate::alloc::{AllocErr, LayoutErr};\n+use crate::alloc::{Layout, LayoutErr};\n \n-/// Augments `AllocErr` with a CapacityOverflow variant.\n+/// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub enum CollectionAllocErr {\n+pub enum TryReserveError {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n-    /// Error due to the allocator (see the `AllocErr` type's docs).\n-    AllocErr,\n-}\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<AllocErr> for CollectionAllocErr {\n-    #[inline]\n-    fn from(AllocErr: AllocErr) -> Self {\n-        CollectionAllocErr::AllocErr\n-    }\n+    /// The memory allocator returned an error\n+    AllocError {\n+        /// The layout of allocation request that failed\n+        layout: Layout,\n+\n+        #[doc(hidden)]\n+        #[unstable(feature = \"container_error_extra\", issue = \"0\", reason = \"\\\n+            Enable exposing the allocator\u2019s custom error value \\\n+            if an associated type is added in the future: \\\n+            https://github.com/rust-lang/wg-allocators/issues/23\")]\n+        non_exhaustive: (),\n+    },\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<LayoutErr> for CollectionAllocErr {\n+impl From<LayoutErr> for TryReserveError {\n     #[inline]\n     fn from(_: LayoutErr) -> Self {\n-        CollectionAllocErr::CapacityOverflow\n+        TryReserveError::CapacityOverflow\n     }\n }\n "}, {"sha": "7315963cc8b1dd6db5128d0a7c3ab8d6c04f2a8a", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -18,7 +18,7 @@ use core::ptr::{self, NonNull};\n use core::slice;\n use core::hash::{Hash, Hasher};\n \n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n@@ -576,10 +576,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -595,7 +595,7 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.try_reserve(additional)\n     }\n \n@@ -614,10 +614,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -633,12 +633,12 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n         let new_cap = used_cap.checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+            .ok_or(TryReserveError::CapacityOverflow)?;\n \n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n@@ -1199,6 +1199,31 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n+    /// it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// assert_eq!(buf.pop_back(), None);\n+    /// buf.push_back(1);\n+    /// buf.push_back(3);\n+    /// assert_eq!(buf.pop_back(), Some(3));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        if self.is_empty() {\n+            None\n+        } else {\n+            self.head = self.wrap_sub(self.head, 1);\n+            let head = self.head;\n+            unsafe { Some(self.buffer_read(head)) }\n+        }\n+    }\n+\n     /// Prepends an element to the `VecDeque`.\n     ///\n     /// # Examples\n@@ -1243,38 +1268,13 @@ impl<T> VecDeque<T> {\n         unsafe { self.buffer_write(head, value) }\n     }\n \n-    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n-    /// it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.pop_back(), None);\n-    /// buf.push_back(1);\n-    /// buf.push_back(3);\n-    /// assert_eq!(buf.pop_back(), Some(3));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pop_back(&mut self) -> Option<T> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            self.head = self.wrap_sub(self.head, 1);\n-            let head = self.head;\n-            unsafe { Some(self.buffer_read(head)) }\n-        }\n-    }\n-\n     #[inline]\n     fn is_contiguous(&self) -> bool {\n         self.tail <= self.head\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n-    /// last element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it,\n+    /// replacing it with the first element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1288,28 +1288,28 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_back(0), None);\n+    /// assert_eq!(buf.swap_remove_front(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n-    /// assert_eq!(buf, [3, 2]);\n+    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n+    /// assert_eq!(buf, [2, 1]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length - 1 {\n-            self.swap(index, length - 1);\n+        if length > 0 && index < length && index != 0 {\n+            self.swap(index, 0);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_back()\n+        self.pop_front()\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it,\n-    /// replacing it with the first element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n+    /// last element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1323,24 +1323,24 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_front(0), None);\n+    /// assert_eq!(buf.swap_remove_back(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n-    /// assert_eq!(buf, [2, 1]);\n+    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n+    /// assert_eq!(buf, [3, 2]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length && index != 0 {\n-            self.swap(index, 0);\n+        if length > 0 && index < length - 1 {\n+            self.swap(index, length - 1);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_front()\n+        self.pop_back()\n     }\n \n     /// Inserts an element at `index` within the `VecDeque`, shifting all elements with indices"}, {"sha": "4a48945adc37a4bf313a00fe38cd06fce4296d0f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -69,7 +69,7 @@\n #![warn(missing_debug_implementations)]\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n-#![cfg_attr(not(bootstrap), allow(incomplete_features))]\n+#![allow(incomplete_features)]\n \n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n@@ -84,9 +84,10 @@\n #![feature(coerce_unsized)]\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n-#![cfg_attr(not(bootstrap), feature(const_in_array_repeat_expressions))]\n+#![feature(const_in_array_repeat_expressions)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n+#![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n@@ -118,7 +119,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n #![feature(mem_take)]"}, {"sha": "0b5e186d4c77b17c5ae683437df783fea53bd320", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -98,5 +98,5 @@ macro_rules! vec {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::fmt::format(::core::format_args!($($arg)*)))\n }"}, {"sha": "bc8a38f6b3aad530a9a0eb95d826f1696cd9d8e5", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -7,8 +7,8 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n-use crate::collections::CollectionAllocErr::{self, *};\n+use crate::alloc::{Alloc, Layout, Global, AllocErr, handle_alloc_error};\n+use crate::collections::TryReserveError::{self, *};\n use crate::boxed::Box;\n \n #[cfg(test)]\n@@ -385,7 +385,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-           -> Result<(), CollectionAllocErr> {\n+           -> Result<(), TryReserveError> {\n \n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n     }\n@@ -413,7 +413,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -422,7 +422,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n     fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<usize, CollectionAllocErr> {\n+        -> Result<usize, TryReserveError> {\n \n         // Nothing we can really do about these checks :(\n         let required_cap = used_capacity.checked_add(needed_extra_capacity)\n@@ -435,7 +435,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<(), CollectionAllocErr> {\n+        -> Result<(), TryReserveError> {\n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n     }\n \n@@ -494,7 +494,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n         }\n     }\n@@ -640,10 +640,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n         needed_extra_capacity: usize,\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n-    ) -> Result<(), CollectionAllocErr> {\n+    ) -> Result<(), TryReserveError> {\n         unsafe {\n-            use crate::alloc::AllocErr;\n-\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -672,12 +670,16 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => self.a.alloc(new_layout),\n             };\n \n-            match (&res, fallibility) {\n+            let ptr = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                _ => {}\n-            }\n+                (Err(AllocErr), Fallible) => return Err(TryReserveError::AllocError {\n+                    layout: new_layout,\n+                    non_exhaustive: (),\n+                }),\n+                (Ok(ptr), _) => ptr,\n+            };\n \n-            self.ptr = res?.cast().into();\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -737,7 +739,7 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // all 4GB in user-space. e.g., PAE or x32\n \n #[inline]\n-fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n+fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n     if mem::size_of::<usize>() < 8 && alloc_size > core::isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {"}, {"sha": "2b222caf13f3d48c3333aa35ff78a01e1ced57b1", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 181, "deletions": 5, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -327,6 +327,37 @@ impl<T> Rc<T> {\n         }))\n     }\n \n+    /// Constructs a new `Rc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -377,6 +408,118 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Rc<mem::MaybeUninit<T>> {\n+    /// Converts to `Rc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<T> {\n+        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Rc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Rc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<[T]> {\n+        Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n@@ -560,13 +703,46 @@ impl<T: ?Sized> Rc<T> {\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n             unsafe {\n-                Some(&mut this.ptr.as_mut().value)\n+                Some(Rc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Rc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut x = Rc::new(String::new());\n+    /// unsafe {\n+    ///     Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().value\n+    }\n+\n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     /// Returns `true` if the two `Rc`s point to the same value (not\n@@ -704,11 +880,11 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n     ) -> *mut RcBox<T> {\n@@ -737,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n         )\n@@ -768,7 +944,7 @@ impl<T: ?Sized> Rc<T> {\n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n         )"}, {"sha": "b65f191836e9dcc9548bac74f9894520f5df463a", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -56,7 +56,7 @@ use core::ptr;\n use core::str::{pattern::Pattern, lossy};\n \n use crate::borrow::{Cow, ToOwned};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use crate::vec::Vec;\n@@ -937,9 +937,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -953,7 +953,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.vec.try_reserve(additional)\n     }\n \n@@ -975,9 +975,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -991,7 +991,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.vec.try_reserve_exact(additional)\n     }\n "}, {"sha": "9ffc1673e5ab8e43954374a2f68a70a935c69baa", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 181, "deletions": 9, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -107,10 +107,6 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// // a, b, and foo are all Arcs that point to the same memory location\n /// ```\n ///\n-/// The [`Arc::clone(&from)`] syntax is the most idiomatic because it conveys more explicitly\n-/// the meaning of the code. In the example above, this syntax makes it easier to see that\n-/// this code is creating a new reference rather than copying the whole content of foo.\n-///\n /// ## `Deref` behavior\n ///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n@@ -311,6 +307,37 @@ impl<T> Arc<T> {\n         Self::from_inner(Box::into_raw_non_null(x))\n     }\n \n+    /// Constructs a new `Arc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -361,6 +388,118 @@ impl<T> Arc<T> {\n     }\n }\n \n+impl<T> Arc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Arc<mem::MaybeUninit<T>> {\n+    /// Converts to `Arc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<T> {\n+        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Arc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Arc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<[T]> {\n+        Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n@@ -593,11 +732,11 @@ impl<T: ?Sized> Arc<T> {\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>\n     ) -> *mut ArcInner<T> {\n@@ -625,7 +764,7 @@ impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n         )\n@@ -656,7 +795,7 @@ impl<T: ?Sized> Arc<T> {\n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n         )\n@@ -945,13 +1084,46 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                Some(&mut this.ptr.as_mut().data)\n+                Some(Arc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Arc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Arc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut x = Arc::new(String::new());\n+    /// unsafe {\n+    ///     Arc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().data\n+    }\n+\n     /// Determine whether this is the unique reference (including weak refs) to\n     /// the underlying data.\n     ///"}, {"sha": "55edf56345b59a4cb270129610b0318a9f2163dd", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,5 @@\n use std::borrow::Cow;\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -566,11 +566,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -590,7 +590,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -629,10 +629,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -651,7 +651,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {"}, {"sha": "29a22aa0315b048199497108d04b2bb1eac04e46", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -2,7 +2,7 @@ use std::borrow::Cow;\n use std::mem::size_of;\n use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -1121,11 +1121,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1145,7 +1145,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1209,10 +1209,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1231,7 +1231,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1252,7 +1252,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d49b553fc0217a5161e9493220d25003b2221856", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,6 +1,6 @@\n use std::fmt::Debug;\n use std::collections::{VecDeque, vec_deque::Drain};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1188,7 +1188,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1211,7 +1211,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1256,7 +1256,7 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1275,7 +1275,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1296,7 +1296,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d2798955c46a97105cec55fa5e5f3b4de2def63b", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -70,7 +70,7 @@ use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n use crate::borrow::{ToOwned, Cow};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::raw_vec::RawVec;\n \n@@ -498,9 +498,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -516,7 +516,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.buf.try_reserve(self.len, additional)\n     }\n \n@@ -538,9 +538,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -556,7 +556,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.buf.try_reserve_exact(self.len, additional)\n     }\n "}, {"sha": "e8a0a88f12a7e30604ff92702c2d9f0476ad9985", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -470,10 +470,5 @@ impl TypeId {\n #[stable(feature = \"type_name\", since = \"1.38.0\")]\n #[rustc_const_unstable(feature = \"const_type_name\")]\n pub const fn type_name<T: ?Sized>() -> &'static str {\n-    #[cfg(bootstrap)]\n-    unsafe {\n-        intrinsics::type_name::<T>()\n-    }\n-    #[cfg(not(bootstrap))]\n     intrinsics::type_name::<T>()\n }"}, {"sha": "4087333e2cf6dc39f530508663edf84af1b8d75a", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -14,6 +14,7 @@\n use crate::fmt;\n use crate::ops::Range;\n use crate::iter::FusedIterator;\n+use crate::str::from_utf8_unchecked;\n \n /// An iterator over the escaped version of a byte.\n ///\n@@ -22,6 +23,7 @@ use crate::iter::FusedIterator;\n ///\n /// [`escape_default`]: fn.escape_default.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n pub struct EscapeDefault {\n     range: Range<usize>,\n     data: [u8; 4],\n@@ -130,6 +132,13 @@ impl ExactSizeIterator for EscapeDefault {}\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDefault {}\n \n+#[stable(feature = \"ascii_escape_display\", since = \"1.39.0\")]\n+impl fmt::Display for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(unsafe { from_utf8_unchecked(&self.data[self.range.clone()]) })\n+    }\n+}\n+\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "e91bf53c5b418c40a2237350581b3db16966477b", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -553,12 +553,7 @@ impl char {\n     /// `XID_Start` is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to `ID_Start` but modified for closure under `NFKx`.\n-    #[cfg_attr(bootstrap,\n-               unstable(feature = \"rustc_private\",\n-                        reason = \"mainly needed for compiler internals\",\n-                        issue = \"27812\"))]\n-    #[cfg_attr(not(bootstrap),\n-               unstable(feature = \"unicode_internals\", issue = \"0\"))]\n+    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n     pub fn is_xid_start(self) -> bool {\n         derived_property::XID_Start(self)\n     }\n@@ -569,12 +564,7 @@ impl char {\n     /// `XID_Continue` is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to `ID_Continue` but modified for closure under NFKx.\n-    #[cfg_attr(bootstrap,\n-               unstable(feature = \"rustc_private\",\n-                        reason = \"mainly needed for compiler internals\",\n-                        issue = \"27812\"))]\n-    #[cfg_attr(not(bootstrap),\n-               unstable(feature = \"unicode_internals\", issue = \"0\"))]\n+    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n     #[inline]\n     pub fn is_xid_continue(self) -> bool {\n         derived_property::XID_Continue(self)"}, {"sha": "ec70d396e966d586fcdb1ff2893de24943f85353", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -134,9 +134,8 @@ pub trait Clone : Sized {\n }\n \n /// Derive macro generating an impl of the trait `Clone`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n pub macro Clone($item:item) { /* compiler built-in */ }"}, {"sha": "cb9feb074dd70d58d51c1b95da226ce662ea16eb", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -201,9 +201,8 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n }\n \n /// Derive macro generating an impl of the trait `PartialEq`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro PartialEq($item:item) { /* compiler built-in */ }\n@@ -265,9 +264,8 @@ pub trait Eq: PartialEq<Self> {\n }\n \n /// Derive macro generating an impl of the trait `Eq`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_eq)]\n pub macro Eq($item:item) { /* compiler built-in */ }\n@@ -617,9 +615,8 @@ pub trait Ord: Eq + PartialOrd<Self> {\n }\n \n /// Derive macro generating an impl of the trait `Ord`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro Ord($item:item) { /* compiler built-in */ }\n@@ -867,9 +864,8 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n }\n \n /// Derive macro generating an impl of the trait `PartialOrd`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro PartialOrd($item:item) { /* compiler built-in */ }"}, {"sha": "66acc5165fc5b9ad9b2fa3714225a664da3c71cd", "filename": "src/libcore/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -116,9 +116,8 @@ pub trait Default: Sized {\n }\n \n /// Derive macro generating an impl of the trait `Default`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro Default($item:item) { /* compiler built-in */ }"}, {"sha": "15ce2277fa00d9188aad74dc7043f72faa149a3e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -98,7 +98,7 @@ pub struct DebugStruct<'a, 'b: 'a> {\n     has_fields: bool,\n }\n \n-pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n+pub(super) fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n                                 name: &str)\n                                 -> DebugStruct<'a, 'b> {\n     let result = fmt.write_str(name);\n@@ -251,7 +251,10 @@ pub struct DebugTuple<'a, 'b: 'a> {\n     empty_name: bool,\n }\n \n-pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> {\n+pub(super) fn debug_tuple_new<'a, 'b>(\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    name: &str,\n+) -> DebugTuple<'a, 'b> {\n     let result = fmt.write_str(name);\n     DebugTuple {\n         fmt,\n@@ -418,7 +421,7 @@ pub struct DebugSet<'a, 'b: 'a> {\n     inner: DebugInner<'a, 'b>,\n }\n \n-pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n+pub(super) fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n     let result = fmt.write_str(\"{\");\n     DebugSet {\n         inner: DebugInner {\n@@ -555,7 +558,7 @@ pub struct DebugList<'a, 'b: 'a> {\n     inner: DebugInner<'a, 'b>,\n }\n \n-pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n+pub(super) fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n     let result = fmt.write_str(\"[\");\n     DebugList {\n         inner: DebugInner {\n@@ -697,7 +700,7 @@ pub struct DebugMap<'a, 'b: 'a> {\n     state: PadAdapterState,\n }\n \n-pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n+pub(super) fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n     let result = fmt.write_str(\"{\");\n     DebugMap {\n         fmt,"}, {"sha": "bd31d25dd034b2063c33b665e9e3d63e50e159cd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -546,16 +546,14 @@ pub trait Debug {\n }\n \n // Separate module to reexport the macro `Debug` from prelude without the trait `Debug`.\n-#[cfg(not(bootstrap))]\n pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Debug`.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro Debug($item:item) { /* compiler built-in */ }\n }\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n pub use macros::Debug;"}, {"sha": "bf3daa32840d85cb598ee4e0d1ec6ad34be98e1a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -199,16 +199,14 @@ pub trait Hash {\n }\n \n // Separate module to reexport the macro `Hash` from prelude without the trait `Hash`.\n-#[cfg(not(bootstrap))]\n pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Hash`.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro Hash($item:item) { /* compiler built-in */ }\n }\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n pub use macros::Hash;\n@@ -553,8 +551,6 @@ impl<H> PartialEq for BuildHasherDefault<H> {\n #[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\n impl<H> Eq for BuildHasherDefault<H> {}\n \n-//////////////////////////////////////////////////////////////////////////////\n-\n mod impls {\n     use crate::mem;\n     use crate::slice;"}, {"sha": "d145f2212f93a639e2c4ab50dff24b5b6b64ef57", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1293,18 +1293,40 @@ extern \"rust-intrinsic\" {\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n+    /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_add` method. For example,\n+    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_add<T>(a: T, b: T) -> T;\n+    /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_sub` method. For example,\n+    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_sub<T>(a: T, b: T) -> T;\n+    /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_mul` method. For example,\n+    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_mul<T>(a: T, b: T) -> T;\n+\n     /// Computes `a + b`, while saturating at numeric bounds.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,"}, {"sha": "c9612596b1ba0e8c523ecba69b1cbf7271f6a784", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -173,17 +173,23 @@ impl<A, B> Iterator for Chain<A, B> where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n+        match self.state {\n+            ChainState::Both => {\n+                let (a_lower, a_upper) = self.a.size_hint();\n+                let (b_lower, b_upper) = self.b.size_hint();\n \n-        let lower = a_lower.saturating_add(b_lower);\n+                let lower = a_lower.saturating_add(b_lower);\n \n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(y),\n-            _ => None\n-        };\n+                let upper = match (a_upper, b_upper) {\n+                    (Some(x), Some(y)) => x.checked_add(y),\n+                    _ => None\n+                };\n \n-        (lower, upper)\n+                (lower, upper)\n+            }\n+            ChainState::Front => self.a.size_hint(),\n+            ChainState::Back => self.b.size_hint(),\n+        }\n     }\n }\n \n@@ -207,6 +213,29 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n         }\n     }\n \n+    #[inline]\n+    fn nth_back(&mut self, mut n: usize) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                for x in self.b.by_ref().rev() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Front;\n+                }\n+            }\n+            ChainState::Front => {}\n+        }\n+        if let ChainState::Front = self.state {\n+            self.a.nth_back(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n         Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {"}, {"sha": "a45173f614ded742bec4edbb59566bc065f6d569", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -72,8 +72,7 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n where\n     F: FnMut(I::Item) -> U,\n-    U: IntoIterator,\n-    U::IntoIter: DoubleEndedIterator,\n+    U: IntoIterator<IntoIter: DoubleEndedIterator>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n@@ -107,10 +106,7 @@ impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n /// [`Iterator`]: trait.Iterator.html\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-pub struct Flatten<I: Iterator>\n-where\n-    I::Item: IntoIterator,\n-{\n+pub struct Flatten<I: Iterator<Item: IntoIterator>> {\n     inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n }\n \n@@ -229,16 +225,16 @@ where\n                 if let elt@Some(_) = inner.next() { return elt }\n             }\n             match self.iter.next() {\n-                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                None => return self.backiter.as_mut()?.next(),\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), U::size_hint);\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), U::size_hint);\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n@@ -250,20 +246,25 @@ where\n     fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            frontiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_fold(acc, &mut *fold);\n+                *frontiter = Some(mid);\n+                r\n+            }\n+        }\n+\n         if let Some(ref mut front) = self.frontiter {\n             init = front.try_fold(init, &mut fold)?;\n         }\n         self.frontiter = None;\n \n-        {\n-            let frontiter = &mut self.frontiter;\n-            init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_fold(acc, &mut fold);\n-                *frontiter = Some(mid);\n-                r\n-            })?;\n-        }\n+        init = self.iter.try_fold(init, flatten(&mut self.frontiter, &mut fold))?;\n         self.frontiter = None;\n \n         if let Some(ref mut back) = self.backiter {\n@@ -275,13 +276,20 @@ where\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: Iterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.fold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n+            .fold(init, flatten(fold))\n     }\n }\n \n@@ -297,7 +305,7 @@ where\n                 if let elt@Some(_) = inner.next_back() { return elt }\n             }\n             match self.iter.next_back() {\n-                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                None => return self.frontiter.as_mut()?.next_back(),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n         }\n@@ -307,22 +315,29 @@ where\n     fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_rfold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            backiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a where\n+            T::IntoIter: DoubleEndedIterator,\n         {\n-            let backiter = &mut self.backiter;\n-            init = self.iter.try_rfold(init, |acc, x| {\n+            move |acc, x| {\n                 let mut mid = x.into_iter();\n-                let r = mid.try_rfold(acc, &mut fold);\n+                let r = mid.try_rfold(acc, &mut *fold);\n                 *backiter = Some(mid);\n                 r\n-            })?;\n+            }\n+        }\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n         }\n         self.backiter = None;\n \n+        init = self.iter.try_rfold(init, flatten(&mut self.backiter, &mut fold))?;\n+        self.backiter = None;\n+\n         if let Some(ref mut front) = self.frontiter {\n             init = front.try_rfold(init, &mut fold)?;\n         }\n@@ -332,12 +347,19 @@ where\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: DoubleEndedIterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.rfold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+            .rfold(init, flatten(fold))\n     }\n }"}, {"sha": "a63434abd6c9fc172532d5a27f92c3f0cba96c30", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 361, "deletions": 205, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,6 +1,6 @@\n use crate::cmp;\n use crate::fmt;\n-use crate::ops::Try;\n+use crate::ops::{Add, AddAssign, Try};\n use crate::usize;\n use crate::intrinsics;\n \n@@ -143,6 +143,18 @@ impl<I> Copied<I> {\n     }\n }\n \n+fn copy_fold<T: Copy, Acc>(\n+    mut f: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, &T) -> Acc {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+fn copy_try_fold<T: Copy, Acc, R>(\n+    mut f: impl FnMut(Acc, T) -> R,\n+) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n impl<'a, I, T: 'a> Iterator for Copied<I>\n     where I: Iterator<Item=&'a T>, T: Copy\n@@ -157,16 +169,16 @@ impl<'a, I, T: 'a> Iterator for Copied<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n+        self.it.try_fold(init, copy_try_fold(f))\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.fold(init, move |acc, &elt| f(acc, elt))\n+        self.it.fold(init, copy_fold(f))\n     }\n }\n \n@@ -178,16 +190,16 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n         self.it.next_back().copied()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n+        self.it.try_rfold(init, copy_try_fold(f))\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n+        self.it.rfold(init, copy_fold(f))\n     }\n }\n \n@@ -248,6 +260,12 @@ impl<I> Cloned<I> {\n     }\n }\n \n+fn clone_try_fold<T: Clone, Acc, R>(\n+    mut f: impl FnMut(Acc, T) -> R,\n+) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, elt| f(acc, elt.clone())\n+}\n+\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> Iterator for Cloned<I>\n     where I: Iterator<Item=&'a T>, T: Clone\n@@ -262,16 +280,16 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.try_fold(init, clone_try_fold(f))\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.map(T::clone).fold(init, f)\n     }\n }\n \n@@ -283,16 +301,16 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n         self.it.next_back().cloned()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.try_rfold(init, clone_try_fold(f))\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.map(T::clone).rfold(init, f)\n     }\n }\n \n@@ -387,6 +405,36 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n             _ => (usize::MAX, None)\n         }\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // fully iterate the current iterator. this is necessary because\n+        // `self.iter` may be empty even when `self.orig` isn't\n+        acc = self.iter.try_fold(acc, &mut f)?;\n+        self.iter = self.orig.clone();\n+\n+        // complete a full cycle, keeping track of whether the cycled\n+        // iterator is empty or not. we need to return early in case\n+        // of an empty iterator to prevent an infinite loop\n+        let mut is_empty = true;\n+        acc = self.iter.try_fold(acc, |acc, x| {\n+            is_empty = false;\n+            f(acc, x)\n+        })?;\n+\n+        if is_empty {\n+            return Try::from_ok(acc);\n+        }\n+\n+        loop {\n+            self.iter = self.orig.clone();\n+            acc = self.iter.try_fold(acc, &mut f)?;\n+        }\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -430,14 +478,24 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let inner_hint = self.iter.size_hint();\n+        #[inline]\n+        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n+        }\n+\n+        #[inline]\n+        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| n / (step + 1)\n+        }\n+\n+        let (low, high) = self.iter.size_hint();\n \n         if self.first_take {\n-            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n-            (f(inner_hint.0), inner_hint.1.map(f))\n+            let f = first_size(self.step);\n+            (f(low), high.map(f))\n         } else {\n-            let f = |n| n / (self.step+1);\n-            (f(inner_hint.0), inner_hint.1.map(f))\n+            let f = other_size(self.step);\n+            (f(low), high.map(f))\n         }\n     }\n \n@@ -594,6 +652,20 @@ impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n     }\n }\n \n+fn map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+fn map_try_fold<'a, T, B, Acc, R>(\n+    f: &'a mut impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     type Item = B;\n@@ -608,18 +680,16 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n         self.iter.size_hint()\n     }\n \n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n         Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n     }\n \n-    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.fold(init, map_fold(self.f, g))\n     }\n }\n \n@@ -632,18 +702,16 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n         self.iter.next_back().map(&mut self.f)\n     }\n \n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n         Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n     }\n \n-    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.rfold(init, map_fold(self.f, g))\n     }\n }\n \n@@ -710,13 +778,27 @@ impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n     }\n }\n \n+fn filter_fold<T, Acc>(\n+    mut predicate: impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}\n+\n+fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n+    predicate: &'a mut impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { R::from_ok(acc) }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n     type Item = I::Item;\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        self.try_for_each(Err).err()\n+        self.iter.find(&mut self.predicate)\n     }\n \n     #[inline]\n@@ -738,32 +820,26 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n     // leaving more budget for LLVM optimizations.\n     #[inline]\n     fn count(self) -> usize {\n-        let mut predicate = self.predicate;\n-        self.iter.map(|x| predicate(&x) as usize).sum()\n+        #[inline]\n+        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n+            move |x| predicate(&x) as usize\n+        }\n+\n+        self.iter.map(to_usize(self.predicate)).sum()\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n+        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut predicate = self.predicate;\n-        self.iter.fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n+        self.iter.fold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n@@ -773,31 +849,21 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<I::Item> {\n-        self.try_rfold((), |_, x| Err(x)).err()\n+        self.iter.rfind(&mut self.predicate)\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n+        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut predicate = self.predicate;\n-        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n+        self.iter.rfold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n@@ -834,6 +900,26 @@ impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n     }\n }\n \n+fn filter_map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => acc,\n+    }\n+}\n+\n+fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n+    f: &'a mut impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => R::from_ok(acc),\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     where F: FnMut(I::Item) -> Option<B>,\n@@ -842,7 +928,7 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.try_for_each(Err).err()\n+        self.iter.find_map(&mut self.f)\n     }\n \n     #[inline]\n@@ -852,25 +938,17 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n+        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n+        self.iter.fold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n@@ -880,29 +958,31 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n-        self.try_rfold((), |_, x| Err(x)).err()\n+        #[inline]\n+        fn find<T, B>(\n+            f: &mut impl FnMut(T) -> Option<B>\n+        ) -> impl FnMut((), T) -> LoopState<(), B> + '_ {\n+            move |(), x| match f(x) {\n+                Some(x) => LoopState::Break(x),\n+                None => LoopState::Continue(()),\n+            }\n+        }\n+\n+        self.iter.try_rfold((), find(&mut self.f)).break_value()\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n+        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n+        self.iter.rfold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n@@ -944,14 +1024,12 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     ///\n     /// Might panic if the index of the element overflows a `usize`.\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next().map(|a| {\n-            let ret = (self.count, a);\n-            // Possible undefined overflow.\n-            self.count += 1;\n-            ret\n-        })\n+        let a = self.iter.next()?;\n+        let i = self.count;\n+        // Possible undefined overflow.\n+        AddAssign::add_assign(&mut self.count, 1);\n+        Some((i, a))\n     }\n \n     #[inline]\n@@ -960,13 +1038,12 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        self.iter.nth(n).map(|a| {\n-            let i = self.count + n;\n-            self.count = i + 1;\n-            (i, a)\n-        })\n+        let a = self.iter.nth(n)?;\n+        // Possible undefined overflow.\n+        let i = Add::add(self.count, n);\n+        self.count = Add::add(i, 1);\n+        Some((i, a))\n     }\n \n     #[inline]\n@@ -975,29 +1052,43 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let count = &mut self.count;\n-        self.iter.try_fold(init, move |acc, item| {\n-            let acc = fold(acc, (*count, item));\n-            *count += 1;\n-            acc\n-        })\n+        #[inline]\n+        fn enumerate<'a, T, Acc, R>(\n+            count: &'a mut usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, item| {\n+                let acc = fold(acc, (*count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut count = self.count;\n-        self.iter.fold(init, move |acc, item| {\n-            let acc = fold(acc, (count, item));\n-            count += 1;\n-            acc\n-        })\n+        #[inline]\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                let acc = fold(acc, (count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(&mut count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.fold(init, enumerate(self.count, fold))\n     }\n }\n \n@@ -1007,48 +1098,60 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next_back().map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n+        let a = self.iter.next_back()?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.nth_back(n).map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n+        let a = self.iter.nth_back(n)?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n+        fn enumerate<T, Acc, R>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n+        ) -> impl FnMut(Acc, T) -> R {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, enumerate(count, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.rfold(init, enumerate(count, fold))\n     }\n }\n \n@@ -1162,7 +1265,10 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         };\n         let (lo, hi) = self.iter.size_hint();\n         let lo = lo.saturating_add(peek_len);\n-        let hi = hi.and_then(|x| x.checked_add(peek_len));\n+        let hi = match hi {\n+            Some(x) => x.checked_add(peek_len),\n+            None => None,\n+        };\n         (lo, hi)\n     }\n \n@@ -1321,16 +1427,23 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n+        fn check<'a, T>(\n+            flag: &'a mut bool,\n+            pred: &'a mut impl FnMut(&T) -> bool,\n+        ) -> impl FnMut(&T) -> bool + 'a {\n+            move |x| {\n+                if *flag || !pred(x) {\n+                    *flag = true;\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+\n         let flag = &mut self.flag;\n         let pred = &mut self.predicate;\n-        self.iter.find(move |x| {\n-            if *flag || !pred(x) {\n-                *flag = true;\n-                true\n-            } else {\n-                false\n-            }\n-        })\n+        self.iter.find(check(flag, pred))\n     }\n \n     #[inline]\n@@ -1412,14 +1525,13 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n         if self.flag {\n             None\n         } else {\n-            self.iter.next().and_then(|x| {\n-                if (self.predicate)(&x) {\n-                    Some(x)\n-                } else {\n-                    self.flag = true;\n-                    None\n-                }\n-            })\n+            let x = self.iter.next()?;\n+            if (self.predicate)(&x) {\n+                Some(x)\n+            } else {\n+                self.flag = true;\n+                None\n+            }\n         }\n     }\n \n@@ -1434,22 +1546,30 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if self.flag {\n-            Try::from_ok(init)\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, move |acc, x|{\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(&T) -> bool,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n                 if p(&x) {\n                     LoopState::from_try(fold(acc, x))\n                 } else {\n                     *flag = true;\n                     LoopState::Break(Try::from_ok(acc))\n                 }\n-            }).into_try()\n+            }\n+        }\n+\n+        if self.flag {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n         }\n     }\n }\n@@ -1534,7 +1654,10 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = lower.saturating_sub(self.n);\n-        let upper = upper.map(|x| x.saturating_sub(self.n));\n+        let upper = match upper {\n+            Some(x) => Some(x.saturating_sub(self.n)),\n+            None => None,\n+        };\n \n         (lower, upper)\n     }\n@@ -1595,19 +1718,26 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n         }\n     }\n \n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let mut n = self.len();\n-        if n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            self.iter.try_rfold(init, move |acc, x| {\n+        fn check<T, Acc, R: Try<Ok = Acc>>(\n+            mut n: usize,\n+            mut fold: impl FnMut(Acc, T) -> R,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> {\n+            move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n                 if n == 0 { LoopState::Break(r) }\n                 else { LoopState::from_try(r) }\n-            }).into_try()\n+            }\n+        }\n+\n+        let n = self.len();\n+        if n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            self.iter.try_rfold(init, check(n, fold)).into_try()\n         }\n     }\n }\n@@ -1682,19 +1812,26 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if self.n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, move |acc, x| {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            n: &'a mut usize,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n                 if *n == 0 { LoopState::Break(r) }\n                 else { LoopState::from_try(r) }\n-            }).into_try()\n+            }\n+        }\n+\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, check(n, fold)).into_try()\n         }\n     }\n }\n@@ -1793,7 +1930,8 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n+        let a = self.iter.next()?;\n+        (self.f)(&mut self.state, a)\n     }\n \n     #[inline]\n@@ -1803,17 +1941,25 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n+        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n+            state: &'a mut St,\n+            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n+                match f(state, x) {\n+                    None => LoopState::Break(Try::from_ok(acc)),\n+                    Some(x) => LoopState::from_try(fold(acc, x)),\n+                }\n+            }\n+        }\n+\n         let state = &mut self.state;\n         let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, x| {\n-            match f(state, x) {\n-                None => LoopState::Break(Try::from_ok(acc)),\n-                Some(x) => LoopState::from_try(fold(acc, x)),\n-            }\n-        }).into_try()\n+        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n     }\n }\n \n@@ -2104,6 +2250,20 @@ impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n     }\n }\n \n+fn inspect_fold<T, Acc>(\n+    mut f: impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| { f(&item); fold(acc, item) }\n+}\n+\n+fn inspect_try_fold<'a, T, Acc, R>(\n+    f: &'a mut impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| { f(&item); fold(acc, item) }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     type Item = I::Item;\n@@ -2120,19 +2280,17 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.fold(init, inspect_fold(self.f, fold))\n     }\n }\n \n@@ -2147,19 +2305,17 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.rfold(init, inspect_fold(self.f, fold))\n     }\n }\n "}, {"sha": "430ceacdd9fab674aad4b958263f1326c2c0b099", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -94,11 +94,9 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n     #[inline]\n     default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        self.a.next().and_then(|x| {\n-            self.b.next().and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n+        let x = self.a.next()?;\n+        let y = self.b.next()?;\n+        Some((x, y))\n     }\n \n     #[inline]"}, {"sha": "183176005ede9605ba289c018d6adbe18f6d69c5", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -394,7 +394,8 @@ impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        self.gen.take().map(|f| f())\n+        let f = self.gen.take()?;\n+        Some(f())\n     }\n \n     #[inline]\n@@ -608,10 +609,9 @@ impl<T, F> Iterator for Successors<T, F>\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        self.next.take().map(|item| {\n-            self.next = (self.succ)(&item);\n-            item\n-        })\n+        let item = self.next.take()?;\n+        self.next = (self.succ)(&item);\n+        Some(item)\n     }\n \n     #[inline]"}, {"sha": "818f03303298f7b250d50486ca144b629f0a9954", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -85,28 +85,28 @@ macro_rules! float_sum_product {\n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Sum for $a {\n             fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Product for $a {\n             fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Sum<&'a $a> for $a {\n             fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + *b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Product<&'a $a> for $a {\n             fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * *b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n     )*)"}, {"sha": "006b243ca42aa8c328060987edbf9c90013c2ff4", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -69,7 +69,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Returns the `n`th element from the end of the iterator.\n     ///\n     /// This is essentially the reversed version of [`nth`]. Although like most indexing\n-    /// operations, the count starts from zero, so `nth_back(0)` returns the first value fro\n+    /// operations, the count starts from zero, so `nth_back(0)` returns the first value from\n     /// the end, `nth_back(1)` the second, and so on.\n     ///\n     /// Note that all elements between the end and the returned element will be\n@@ -219,12 +219,17 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n+    fn rfold<B, F>(mut self, accum: B, f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(accum, ok(f)).unwrap()\n     }\n \n     /// Searches for an element of an iterator from the back that satisfies a predicate.\n@@ -271,15 +276,21 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n-    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        self.try_rfold((), move |(), x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(&T) -> bool,\n+        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+            move |(), x| {\n+                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_rfold((), check(predicate)).break_value()\n     }\n }\n "}, {"sha": "d644787d2c462678e9af0b4ad494d34dc170730c", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 177, "deletions": 72, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,5 @@\n use crate::cmp::Ordering;\n-use crate::ops::Try;\n+use crate::ops::{Add, Try};\n \n use super::super::LoopState;\n use super::super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n@@ -234,11 +234,15 @@ pub trait Iterator {\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize where Self: Sized {\n-        // Might overflow.\n-        self.fold(0, |cnt, _| cnt + 1)\n+        #[inline]\n+        fn add1<T>(count: usize, _: T) -> usize {\n+            // Might overflow.\n+            Add::add(count, 1)\n+        }\n+\n+        self.fold(0, add1)\n     }\n \n     /// Consumes the iterator, returning the last element.\n@@ -263,7 +267,12 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(self) -> Option<Self::Item> where Self: Sized {\n-        self.fold(None, |_, x| Some(x))\n+        #[inline]\n+        fn some<T>(_: Option<T>, x: T) -> Option<T> {\n+            Some(x)\n+        }\n+\n+        self.fold(None, some)\n     }\n \n     /// Returns the `n`th element of the iterator.\n@@ -596,10 +605,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]\n-    fn for_each<F>(self, mut f: F) where\n+    fn for_each<F>(self, f: F) where\n         Self: Sized, F: FnMut(Self::Item),\n     {\n-        self.fold((), move |(), item| f(item));\n+        #[inline]\n+        fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {\n+            move |(), item| f(item)\n+        }\n+\n+        self.fold((), call(f));\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element\n@@ -1490,21 +1504,30 @@ pub trait Iterator {\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn partition<B, F>(self, mut f: F) -> (B, B) where\n+    fn partition<B, F>(self, f: F) -> (B, B) where\n         Self: Sized,\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n     {\n+        #[inline]\n+        fn extend<'a, T, B: Extend<T>>(\n+            mut f: impl FnMut(&T) -> bool + 'a,\n+            left: &'a mut B,\n+            right: &'a mut B,\n+        ) -> impl FnMut(T) + 'a {\n+            move |x| {\n+                if f(&x) {\n+                    left.extend(Some(x));\n+                } else {\n+                    right.extend(Some(x));\n+                }\n+            }\n+        }\n+\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n \n-        self.for_each(|x| {\n-            if f(&x) {\n-                left.extend(Some(x))\n-            } else {\n-                right.extend(Some(x))\n-            }\n-        });\n+        self.for_each(extend(f, &mut left, &mut right));\n \n         (left, right)\n     }\n@@ -1702,10 +1725,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n+    fn try_for_each<F, R>(&mut self, f: F) -> R where\n         Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n     {\n-        self.try_fold((), move |(), x| f(x))\n+        #[inline]\n+        fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {\n+            move |(), x| f(x)\n+        }\n+\n+        self.try_fold((), call(f))\n     }\n \n     /// An iterator method that applies a function, producing a single, final value.\n@@ -1777,10 +1805,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(mut self, init: B, f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_fold(init, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(f)).unwrap()\n     }\n \n     /// Tests if every element of the iterator matches a predicate.\n@@ -1822,13 +1855,18 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(&mut self, mut f: F) -> bool where\n+    fn all<F>(&mut self, f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Continue(()) }\n-            else { LoopState::Break(()) }\n-        }) == LoopState::Continue(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Continue(()) }\n+                else { LoopState::Break(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -1870,14 +1908,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn any<F>(&mut self, mut f: F) -> bool where\n+    fn any<F>(&mut self, f: F) -> bool where\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Break(()) }\n-            else { LoopState::Continue(()) }\n-        }) == LoopState::Break(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Break(()) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -1924,14 +1967,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        self.try_for_each(move |x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> LoopState<(), T> {\n+            move |x| {\n+                if predicate(&x) { LoopState::Break(x) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(predicate)).break_value()\n     }\n \n     /// Applies function to the elements of iterator and returns\n@@ -1951,16 +1999,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_find_map\", since = \"1.30.0\")]\n-    fn find_map<B, F>(&mut self, mut f: F) -> Option<B> where\n+    fn find_map<B, F>(&mut self, f: F) -> Option<B> where\n         Self: Sized,\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n-        self.try_for_each(move |x| {\n-            match f(x) {\n+        #[inline]\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut(T) -> LoopState<(), B> {\n+            move |x| match f(x) {\n                 Some(x) => LoopState::Break(x),\n                 None => LoopState::Continue(()),\n             }\n-        }).break_value()\n+        }\n+\n+        self.try_for_each(check(f)).break_value()\n     }\n \n     /// Searches for an element in an iterator, returning its index.\n@@ -2018,17 +2069,23 @@ pub trait Iterator {\n     ///\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn position<P>(&mut self, predicate: P) -> Option<usize> where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n-        // The addition might panic on overflow\n-        self.try_fold(0, move |i, x| {\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i + 1) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            // The addition might panic on overflow\n+            move |i, x| {\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(Add::add(i, 1)) }\n+            }\n+        }\n+\n+        self.try_fold(0, check(predicate)).break_value()\n     }\n \n     /// Searches for an element in an iterator from the right, returning its\n@@ -2071,18 +2128,25 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: Sized + ExactSizeIterator + DoubleEndedIterator\n     {\n         // No need for an overflow check here, because `ExactSizeIterator`\n         // implies that the number of elements fits into a `usize`.\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            move |i, x| {\n+                let i = i - 1;\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(i) }\n+            }\n+        }\n+\n         let n = self.len();\n-        self.try_rfold(n, move |i, x| {\n-            let i = i - 1;\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i) }\n-        }).break_value()\n+        self.try_rfold(n, check(predicate)).break_value()\n     }\n \n     /// Returns the maximum element of an iterator.\n@@ -2151,11 +2215,22 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p <= y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2174,11 +2249,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]\n-    fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn max_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) != Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2195,12 +2275,24 @@ pub trait Iterator {\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p > y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2219,11 +2311,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]\n-    fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn min_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) == Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n \n@@ -2284,13 +2381,20 @@ pub trait Iterator {\n         FromB: Default + Extend<B>,\n         Self: Sized + Iterator<Item=(A, B)>,\n     {\n+        fn extend<'a, A, B>(\n+            ts: &'a mut impl Extend<A>,\n+            us: &'a mut impl Extend<B>,\n+        ) -> impl FnMut((A, B)) + 'a {\n+            move |(t, u)| {\n+                ts.extend(Some(t));\n+                us.extend(Some(u));\n+            }\n+        }\n+\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        self.for_each(|(t, u)| {\n-            ts.extend(Some(t));\n-            us.extend(Some(u));\n-        });\n+        self.for_each(extend(&mut ts, &mut us));\n \n         (ts, us)\n     }\n@@ -2617,7 +2721,7 @@ pub trait Iterator {\n         Self: Sized,\n         Self::Item: PartialOrd,\n     {\n-        self.is_sorted_by(|a, b| a.partial_cmp(b))\n+        self.is_sorted_by(PartialOrd::partial_cmp)\n     }\n \n     /// Checks if the elements of this iterator are sorted using the given comparator function.\n@@ -2639,10 +2743,7 @@ pub trait Iterator {\n         };\n \n         while let Some(curr) = self.next() {\n-            if compare(&last, &curr)\n-                .map(|o| o == Ordering::Greater)\n-                .unwrap_or(true)\n-            {\n+            if let Some(Ordering::Greater) | None = compare(&last, &curr) {\n                 return false;\n             }\n             last = curr;\n@@ -2687,17 +2788,21 @@ pub trait Iterator {\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+fn select_fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n     where\n         I: Iterator,\n         F: FnMut(&I::Item, &I::Item) -> bool,\n {\n+    #[inline]\n+    fn select<T>(mut f: impl FnMut(&T, &T) -> bool) -> impl FnMut(T, T) -> T {\n+        move |sel, x| if f(&sel, &x) { x } else { sel }\n+    }\n+\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n-    it.next().map(|first| {\n-        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n-    })\n+    let first = it.next()?;\n+    Some(it.fold(first, select(f)))\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c168d5c8a2eac9e58752c2cb6d4ddedd08bc2ec6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -63,7 +63,7 @@\n #![warn(missing_debug_implementations)]\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n-#![cfg_attr(not(bootstrap), allow(incomplete_features))]\n+#![allow(incomplete_features)]\n \n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n@@ -129,7 +129,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_slice)]\n #![feature(external_doc)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]"}, {"sha": "6c88a766a2f10eb39eb7c5096b81bd2e78e1f936", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 16, "deletions": 58, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -2,21 +2,21 @@\n ///\n /// For details, see `std::macros`.\n #[macro_export]\n-#[allow_internal_unstable(core_panic, __rust_unstable_column)]\n+#[allow_internal_unstable(core_panic)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n     ($msg:expr) => ({\n-        $crate::panicking::panic(&($msg, file!(), line!(), __rust_unstable_column!()))\n+        $crate::panicking::panic(&($msg, $crate::file!(), $crate::line!(), $crate::column!()))\n     });\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)+),\n-                                     &(file!(), line!(), __rust_unstable_column!()))\n+        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+),\n+                                     &($crate::file!(), $crate::line!(), $crate::column!()))\n     });\n }\n \n@@ -70,7 +70,7 @@ macro_rules! assert_eq {\n                     panic!(r#\"assertion failed: `(left == right)`\n   left: `{:?}`,\n  right: `{:?}`: {}\"#, &*left_val, &*right_val,\n-                           format_args!($($arg)+))\n+                           $crate::format_args!($($arg)+))\n                 }\n             }\n         }\n@@ -127,7 +127,7 @@ macro_rules! assert_ne {\n                     panic!(r#\"assertion failed: `(left != right)`\n   left: `{:?}`,\n  right: `{:?}`: {}\"#, &*left_val, &*right_val,\n-                           format_args!($($arg)+))\n+                           $crate::format_args!($($arg)+))\n                 }\n             }\n         }\n@@ -181,7 +181,7 @@ macro_rules! assert_ne {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert!($($arg)*); })\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert!($($arg)*); })\n }\n \n /// Asserts that two expressions are equal to each other.\n@@ -208,7 +208,7 @@ macro_rules! debug_assert {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! debug_assert_eq {\n-    ($($arg:tt)*) => (if cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n }\n \n /// Asserts that two expressions are not equal to each other.\n@@ -235,7 +235,7 @@ macro_rules! debug_assert_eq {\n #[macro_export]\n #[stable(feature = \"assert_ne\", since = \"1.13.0\")]\n macro_rules! debug_assert_ne {\n-    ($($arg:tt)*) => (if cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n }\n \n /// Unwraps a result or propagates its error.\n@@ -386,7 +386,7 @@ macro_rules! r#try {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt(format_args!($($arg)*)))\n+    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt($crate::format_args!($($arg)*)))\n }\n \n /// Write formatted data into a buffer, with a newline appended.\n@@ -446,7 +446,7 @@ macro_rules! writeln {\n         $crate::writeln!($dst)\n     );\n     ($dst:expr, $($arg:tt)*) => (\n-        $dst.write_fmt(format_args_nl!($($arg)*))\n+        $dst.write_fmt($crate::format_args_nl!($($arg)*))\n     );\n }\n \n@@ -515,7 +515,7 @@ macro_rules! unreachable {\n         $crate::unreachable!($msg)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n-        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+        panic!($crate::concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n     });\n }\n \n@@ -573,7 +573,7 @@ macro_rules! unreachable {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"));\n-    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)+)));\n+    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n }\n \n /// Indicates unfinished code.\n@@ -632,49 +632,14 @@ macro_rules! unimplemented {\n #[unstable(feature = \"todo_macro\", issue = \"59277\")]\n macro_rules! todo {\n     () => (panic!(\"not yet implemented\"));\n-    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)+)));\n-}\n-\n-/// Creates an array of [`MaybeUninit`].\n-///\n-/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n-/// It exists solely because bootstrap does not yet support const array-init expressions.\n-///\n-/// [`MaybeUninit`]: mem/union.MaybeUninit.html\n-// FIXME: Remove both versions of this macro once bootstrap is 1.38.\n-#[macro_export]\n-#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n-#[cfg(bootstrap)]\n-macro_rules! uninit_array {\n-    // This `assume_init` is safe because an array of `MaybeUninit` does not\n-    // require initialization.\n-    ($t:ty; $size:expr) => (unsafe {\n-        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninit().assume_init()\n-    });\n-}\n-\n-/// Creates an array of [`MaybeUninit`].\n-///\n-/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n-/// It exists solely because bootstrap does not yet support const array-init expressions.\n-///\n-/// [`MaybeUninit`]: mem/union.MaybeUninit.html\n-// FIXME: Just inline this version of the macro once bootstrap is 1.38.\n-#[macro_export]\n-#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n-#[cfg(not(bootstrap))]\n-macro_rules! uninit_array {\n-    ($t:ty; $size:expr) => (\n-        [MaybeUninit::<$t>::UNINIT; $size]\n-    );\n+    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n }\n \n /// Definitions of built-in macros.\n ///\n /// Most of the macro properties (stability, visibility, etc.) are taken from the source code here,\n /// with exception of expansion functions transforming macro inputs into outputs,\n /// those functions are provided by the compiler.\n-#[cfg(not(bootstrap))]\n pub(crate) mod builtin {\n \n     /// Causes compilation to fail with the given error message when encountered.\n@@ -962,13 +927,6 @@ pub(crate) mod builtin {\n     #[macro_export]\n     macro_rules! column { () => { /* compiler built-in */ } }\n \n-    /// Same as `column`, but less likely to be shadowed.\n-    #[unstable(feature = \"__rust_unstable_column\", issue = \"0\",\n-               reason = \"internal implementation detail of the `panic` macro\")]\n-    #[rustc_builtin_macro]\n-    #[macro_export]\n-    macro_rules! __rust_unstable_column { () => { /* compiler built-in */ } }\n-\n     /// Expands to the file name in which it was invoked.\n     ///\n     /// With [`line!`] and [`column!`], these macros provide debugging information for\n@@ -1305,14 +1263,14 @@ pub(crate) mod builtin {\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n     pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro RustcEncodable($item:item) { /* compiler built-in */ }"}, {"sha": "89af2528c052a2dea2b2e8834ccca0c9bc191714", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -289,9 +289,8 @@ pub trait Copy : Clone {\n }\n \n /// Derive macro generating an impl of the trait `Copy`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n pub macro Copy($item:item) { /* compiler built-in */ }"}, {"sha": "9e9e901c76d3ff0d02213e27f5677873c6eabe02", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -213,7 +213,7 @@ use crate::mem::ManuallyDrop;\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n // Lang item so we can wrap other types in it. This is useful for generators.\n-#[cfg_attr(not(bootstrap), lang = \"maybe_uninit\")]\n+#[lang = \"maybe_uninit\"]\n #[derive(Copy)]\n #[repr(transparent)]\n pub union MaybeUninit<T> {\n@@ -312,7 +312,7 @@ impl<T> MaybeUninit<T> {\n     /// without dropping it, so be careful not to use this twice unless you want to\n     /// skip running the destructor. For your convenience, this also returns a mutable\n     /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n@@ -502,7 +502,7 @@ impl<T> MaybeUninit<T> {\n     /// // We now created two copies of the same vector, leading to a double-free when\n     /// // they both get dropped!\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n@@ -516,7 +516,7 @@ impl<T> MaybeUninit<T> {\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n         &*self.value\n@@ -532,21 +532,21 @@ impl<T> MaybeUninit<T> {\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut *self.value\n     }\n \n     /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n     /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T"}, {"sha": "87ec05a243d3619c468ae2615772eb00f3f1d07d", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -453,7 +453,7 @@ pub const fn needs_drop<T>() -> bool {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(bootstrap, allow(deprecated_in_future))]\n+#[allow(deprecated_in_future)]\n #[allow(deprecated)]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n@@ -481,7 +481,7 @@ pub unsafe fn zeroed<T>() -> T {\n #[inline]\n #[rustc_deprecated(since = \"1.39.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(bootstrap, allow(deprecated_in_future))]\n+#[allow(deprecated_in_future)]\n #[allow(deprecated)]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();"}, {"sha": "b46e06f8d8ada93b5c8089cef11cfa14dac22e71", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1112,7 +1112,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_add(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_add(self, rhs)\n+                }\n             }\n         }\n \n@@ -1135,7 +1141,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_sub(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_sub(self, rhs)\n+                }\n             }\n         }\n \n@@ -1157,7 +1169,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_mul(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_mul(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_mul(self, rhs)\n+                }\n             }\n         }\n \n@@ -3031,7 +3049,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_add(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_add(self, rhs)\n+                }\n             }\n         }\n \n@@ -3053,7 +3077,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_sub(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_sub(self, rhs)\n+                }\n             }\n         }\n \n@@ -3076,7 +3106,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n         #[inline]\n         pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-            intrinsics::overflowing_mul(self, rhs)\n+            #[cfg(boostrap_stdarch_ignore_this)] {\n+                intrinsics::overflowing_mul(self, rhs)\n+            }\n+\n+            #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                intrinsics::wrapping_mul(self, rhs)\n+            }\n         }\n \n         doc_comment! {"}, {"sha": "7cc279a9ef2ecb83ce3ac3916b6f0b9273617861", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -46,20 +46,16 @@ pub use crate::option::Option::{self, Some, None};\n pub use crate::result::Result::{self, Ok, Err};\n \n // Re-exported built-in macros\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::fmt::macros::Debug;\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::hash::macros::Hash;\n \n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::{\n-    __rust_unstable_column,\n     asm,\n     assert,\n     cfg,\n@@ -83,7 +79,6 @@ pub use crate::{\n     trace_macros,\n };\n \n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(no_inline)]"}, {"sha": "3521dd799795672ab379af6cc25dab307f8ee91e", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -122,6 +122,14 @@ impl<T: ?Sized> Unique<T> {\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n         &mut *self.as_ptr()\n     }\n+\n+    /// Casts to a pointer of another type.\n+    #[inline]\n+    pub const fn cast<U>(self) -> Unique<U> {\n+        unsafe {\n+            Unique::new_unchecked(self.as_ptr() as *mut U)\n+        }\n+    }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]"}, {"sha": "bfbbb15c8d488a232bb7be0ea2cb2eebb5cbbba8", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -4637,6 +4637,22 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n             Some(tail)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = start + self.chunk_size;\n+            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (head, nth_back) = temp.split_at_mut(start);\n+            self.v = head;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]"}, {"sha": "fec17c4d1a4df7b111a5ab90b38cd6a956945868", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -81,6 +81,34 @@ impl<T, E> Poll<Result<T, E>> {\n     }\n }\n \n+impl<T, E> Poll<Option<Result<T, E>>> {\n+    /// Changes the success value of this `Poll` with the closure provided.\n+    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n+    pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n+        where F: FnOnce(T) -> U\n+    {\n+        match self {\n+            Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(f(t)))),\n+            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(e))),\n+            Poll::Ready(None) => Poll::Ready(None),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+\n+    /// Changes the error value of this `Poll` with the closure provided.\n+    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n+    pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n+        where F: FnOnce(E) -> U\n+    {\n+        match self {\n+            Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(t))),\n+            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(f(e)))),\n+            Poll::Ready(None) => Poll::Ready(None),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T> From<T> for Poll<T> {\n     fn from(t: T) -> Poll<T> {"}, {"sha": "3a4f76852a0d7c384daeae71a76593942df01af4", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -103,6 +103,22 @@ fn test_iterator_chain_nth() {\n     assert_eq!(it.next(), None);\n }\n \n+#[test]\n+fn test_iterator_chain_nth_back() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    for (i, x) in expected.iter().rev().enumerate() {\n+        assert_eq!(Some(x), xs.iter().chain(&ys).nth_back(i));\n+    }\n+    assert_eq!(zs.iter().chain(&xs).nth_back(0), Some(&5));\n+\n+    let mut it = xs.iter().chain(&zs);\n+    assert_eq!(it.nth_back(5), Some(&0));\n+    assert_eq!(it.next(), None);\n+}\n+\n #[test]\n fn test_iterator_chain_last() {\n     let xs = [0, 1, 2, 3, 4, 5];\n@@ -136,6 +152,54 @@ fn test_iterator_chain_find() {\n     assert_eq!(iter.next(), None);\n }\n \n+#[test]\n+fn test_iterator_chain_size_hint() {\n+    struct Iter {\n+        is_empty: bool,\n+    }\n+\n+    impl Iterator for Iter {\n+        type Item = ();\n+\n+        // alternates between `None` and `Some(())`\n+        fn next(&mut self) -> Option<Self::Item> {\n+            if self.is_empty {\n+                self.is_empty = false;\n+                None\n+            } else {\n+                self.is_empty = true;\n+                Some(())\n+            }\n+        }\n+\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            if self.is_empty {\n+                (0, Some(0))\n+            } else {\n+                (1, Some(1))\n+            }\n+        }\n+    }\n+\n+    impl DoubleEndedIterator for Iter {\n+        fn next_back(&mut self) -> Option<Self::Item> {\n+            self.next()\n+        }\n+    }\n+\n+    // this chains an iterator of length 0 with an iterator of length 1,\n+    // so after calling `.next()` once, the iterator is empty and the\n+    // state is `ChainState::Back`. `.size_hint()` should now disregard\n+    // the size hint of the left iterator\n+    let mut iter = Iter { is_empty: true }.chain(once(()));\n+    assert_eq!(iter.next(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+\n+    let mut iter = once(()).chain(Iter { is_empty: true });\n+    assert_eq!(iter.next_back(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+}\n+\n #[test]\n fn test_zip_nth() {\n     let xs = [0, 1, 2, 4, 5];\n@@ -1136,6 +1200,18 @@ fn test_cycle() {\n     assert_eq!(empty::<i32>().cycle().fold(0, |acc, x| acc + x), 0);\n \n     assert_eq!(once(1).cycle().skip(1).take(4).fold(0, |acc, x| acc + x), 4);\n+\n+    assert_eq!((0..10).cycle().take(5).sum::<i32>(), 10);\n+    assert_eq!((0..10).cycle().take(15).sum::<i32>(), 55);\n+    assert_eq!((0..10).cycle().take(25).sum::<i32>(), 100);\n+\n+    let mut iter = (0..10).cycle();\n+    iter.nth(14);\n+    assert_eq!(iter.take(8).sum::<i32>(), 38);\n+\n+    let mut iter = (0..10).cycle();\n+    iter.nth(9);\n+    assert_eq!(iter.take(3).sum::<i32>(), 3);\n }\n \n #[test]"}, {"sha": "6609bc3135ae0bfbc64ef0e8684a00b1590b4992", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -374,6 +374,25 @@ fn test_chunks_exact_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_exact_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks_exact_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks_exact_mut(3);\n+    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c3 = v3.chunks_exact_mut(10);\n+    assert_eq!(c3.nth_back(0), None);\n+}\n+\n #[test]\n fn test_chunks_exact_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];"}, {"sha": "5c543165bc2b19da1a271b65aa7331da77300b00", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -468,6 +468,14 @@ pub enum ProcMacro {\n }\n \n impl ProcMacro {\n+    pub fn name(&self) -> &'static str {\n+        match self {\n+            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n+            ProcMacro::Attr { name, .. } => name,\n+            ProcMacro::Bang { name, ..} => name\n+        }\n+    }\n+\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],"}, {"sha": "0dad2dda837b53f236a86499a3fa97db7af725cb", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -136,10 +136,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             PatKind::Struct(_, ref subpats, _) => {\n-                let pats_exit = self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n+                let pats_exit = self.pats_all(subpats.iter().map(|f| &f.pat), pred);\n                 self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n+            PatKind::Or(ref pats) => {\n+                let branches: Vec<_> = pats.iter().map(|p| self.pat(p, pred)).collect();\n+                self.add_ast_node(pat.hir_id.local_id, &branches)\n+            }\n+\n             PatKind::Slice(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);"}, {"sha": "a200a058f4f99bbd7a7e30e06a81c82fba8a4593", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -2088,7 +2088,6 @@ generator can be constructed.\n Erroneous code example:\n \n ```edition2018,compile-fail,E0698\n-#![feature(async_await)]\n async fn bar<T>() -> () {}\n \n async fn foo() {\n@@ -2101,7 +2100,6 @@ To fix this you must bind `T` to a concrete type such as `String`\n so that a generator can then be constructed:\n \n ```edition2018\n-#![feature(async_await)]\n async fn bar<T>() -> () {}\n \n async fn foo() {"}, {"sha": "eae956c978a8e08823b46cc2c1b98c1b8e769175", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -336,7 +336,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n fn is_c_like_enum(item: &hir::Item) -> bool {\n     if let hir::ItemKind::Enum(ref def, _) = item.node {\n         for variant in &def.variants {\n-            match variant.node.data {\n+            match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }\n                 _ => { return false; }\n             }"}, {"sha": "c91ad7858d0bb742e6870fded4f8f11dd2a2f850", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,4 @@\n use crate::ty::{self, TyCtxt};\n-use crate::hir::map::definitions::FIRST_FREE_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt;\n use std::u32;\n@@ -102,31 +101,6 @@ newtype_index! {\n     }\n }\n \n-impl DefIndex {\n-    // Proc macros from a proc-macro crate have a kind of virtual DefIndex. This\n-    // function maps the index of the macro within the crate (which is also the\n-    // index of the macro in the CrateMetadata::proc_macros array) to the\n-    // corresponding DefIndex.\n-    pub fn from_proc_macro_index(proc_macro_index: usize) -> DefIndex {\n-        // DefIndex for proc macros start from FIRST_FREE_DEF_INDEX,\n-        // because the first FIRST_FREE_DEF_INDEX indexes are reserved\n-        // for internal use.\n-        let def_index = DefIndex::from(\n-            proc_macro_index.checked_add(FIRST_FREE_DEF_INDEX)\n-                .expect(\"integer overflow adding `proc_macro_index`\"));\n-        assert!(def_index != CRATE_DEF_INDEX);\n-        def_index\n-    }\n-\n-    // This function is the reverse of from_proc_macro_index() above.\n-    pub fn to_proc_macro_index(self: DefIndex) -> usize {\n-        self.index().checked_sub(FIRST_FREE_DEF_INDEX)\n-            .unwrap_or_else(|| {\n-                bug!(\"using local index {:?} as proc-macro index\", self)\n-            })\n-    }\n-}\n-\n impl rustc_serialize::UseSpecializedEncodable for DefIndex {}\n impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n "}, {"sha": "fa274f831b7950267332d6440b6c8cc86567ce96", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -433,6 +433,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         LifetimeName::Static |\n         LifetimeName::Error |\n         LifetimeName::Implicit |\n+        LifetimeName::ImplicitObjectLifetimeDefault |\n         LifetimeName::Underscore => {}\n     }\n }\n@@ -577,15 +578,15 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics,\n                                         parent_item_id: HirId) {\n-    visitor.visit_ident(variant.node.ident);\n-    visitor.visit_id(variant.node.id);\n-    visitor.visit_variant_data(&variant.node.data,\n-                               variant.node.ident.name,\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_id(variant.id);\n+    visitor.visit_variant_data(&variant.data,\n+                               variant.ident.name,\n                                generics,\n                                parent_item_id,\n                                variant.span);\n-    walk_list!(visitor, visit_anon_const, &variant.node.disr_expr);\n-    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n@@ -704,11 +705,12 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Struct(ref qpath, ref fields, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n             for field in fields {\n-                visitor.visit_id(field.node.hir_id);\n-                visitor.visit_ident(field.node.ident);\n-                visitor.visit_pat(&field.node.pat)\n+                visitor.visit_id(field.hir_id);\n+                visitor.visit_ident(field.ident);\n+                visitor.visit_pat(&field.pat)\n             }\n         }\n+        PatKind::Or(ref pats) => walk_list!(visitor, visit_pat, pats),\n         PatKind::Tuple(ref tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }"}, {"sha": "7ec321061372782c16a3330fb026d1a71339ca7d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 201, "deletions": 172, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -67,12 +67,12 @@ use syntax::errors;\n use syntax::ext::base::SpecialDerives;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n-use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n+use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -136,7 +136,10 @@ pub struct LoweringContext<'a> {\n     /// When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n     /// against this list to see if it is already in-scope, or if a definition\n     /// needs to be created for it.\n-    in_scope_lifetimes: Vec<Ident>,\n+    ///\n+    /// We always store a `modern()` version of the param-name in this\n+    /// vector.\n+    in_scope_lifetimes: Vec<ParamName>,\n \n     current_module: NodeId,\n \n@@ -319,7 +322,7 @@ enum ParenthesizedGenericArgs {\n /// `resolve_lifetime` module. Often we \"fallthrough\" to that code by generating\n /// an \"elided\" or \"underscore\" lifetime name. In the future, we probably want to move\n /// everything into HIR lowering.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n enum AnonymousLifetimeMode {\n     /// For **Modern** cases, create a new anonymous region parameter\n     /// and reference that.\n@@ -337,49 +340,6 @@ enum AnonymousLifetimeMode {\n \n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n     PassThrough,\n-\n-    /// Used in the return types of `async fn` where there exists\n-    /// exactly one argument-position elided lifetime.\n-    ///\n-    /// In `async fn`, we lower the arguments types using the `CreateParameter`\n-    /// mode, meaning that non-`dyn` elided lifetimes are assigned a fresh name.\n-    /// If any corresponding elided lifetimes appear in the output, we need to\n-    /// replace them with references to the fresh name assigned to the corresponding\n-    /// elided lifetime in the arguments.\n-    ///\n-    /// For **Modern cases**, replace the anonymous parameter with a\n-    /// reference to a specific freshly-named lifetime that was\n-    /// introduced in argument\n-    ///\n-    /// For **Dyn Bound** cases, pass responsibility to\n-    /// `resole_lifetime` code.\n-    Replace(LtReplacement),\n-}\n-\n-/// The type of elided lifetime replacement to perform on `async fn` return types.\n-#[derive(Copy, Clone)]\n-enum LtReplacement {\n-    /// Fresh name introduced by the single non-dyn elided lifetime\n-    /// in the arguments of the async fn.\n-    Some(ParamName),\n-\n-    /// There is no single non-dyn elided lifetime because no lifetimes\n-    /// appeared in the arguments.\n-    NoLifetimes,\n-\n-    /// There is no single non-dyn elided lifetime because multiple\n-    /// lifetimes appeared in the arguments.\n-    MultipleLifetimes,\n-}\n-\n-/// Calculates the `LtReplacement` to use for elided lifetimes in the return\n-/// type based on the fresh elided lifetimes introduced in argument position.\n-fn get_elided_lt_replacement(arg_position_lifetimes: &[(Span, ParamName)]) -> LtReplacement {\n-    match arg_position_lifetimes {\n-        [] => LtReplacement::NoLifetimes,\n-        [(_span, param)] => LtReplacement::Some(*param),\n-        _ => LtReplacement::MultipleLifetimes,\n-    }\n }\n \n struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n@@ -744,10 +704,9 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.fresh_expansion(ExpnId::root(), ExpnInfo {\n-            def_site: span,\n+        span.fresh_expansion(ExpnData {\n             allow_internal_unstable,\n-            ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n+            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n         })\n     }\n \n@@ -756,10 +715,16 @@ impl<'a> LoweringContext<'a> {\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         op: impl FnOnce(&mut Self) -> R,\n     ) -> R {\n+        debug!(\n+            \"with_anonymous_lifetime_mode(anonymous_lifetime_mode={:?})\",\n+            anonymous_lifetime_mode,\n+        );\n         let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n         self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n         let result = op(self);\n         self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n+        debug!(\"with_anonymous_lifetime_mode: restoring anonymous_lifetime_mode={:?}\",\n+               old_anonymous_lifetime_mode);\n         result\n     }\n \n@@ -865,7 +830,7 @@ impl<'a> LoweringContext<'a> {\n             return;\n         }\n \n-        if self.in_scope_lifetimes.contains(&ident.modern()) {\n+        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.modern())) {\n             return;\n         }\n \n@@ -899,7 +864,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some(param.ident.modern()),\n+            GenericParamKind::Lifetime { .. } => Some(ParamName::Plain(param.ident.modern())),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -1074,13 +1039,14 @@ impl<'a> LoweringContext<'a> {\n     /// ```\n     ///\n     /// returns a `hir::TypeBinding` representing `Item`.\n-    fn lower_assoc_ty_constraint(&mut self,\n-                                 c: &AssocTyConstraint,\n-                                 itctx: ImplTraitContext<'_>)\n-                                 -> hir::TypeBinding {\n-        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", c, itctx);\n+    fn lower_assoc_ty_constraint(\n+        &mut self,\n+        constraint: &AssocTyConstraint,\n+        itctx: ImplTraitContext<'_>,\n+    ) -> hir::TypeBinding {\n+        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n-        let kind = match c.kind {\n+        let kind = match constraint.kind {\n             AssocTyConstraintKind::Equality { ref ty } => hir::TypeBindingKind::Equality {\n                 ty: self.lower_ty(ty, itctx)\n             },\n@@ -1135,15 +1101,15 @@ impl<'a> LoweringContext<'a> {\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n                         ExpnId::root(),\n-                        DUMMY_SP\n+                        constraint.span,\n                     );\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let ty = this.lower_ty(\n                             &Ty {\n                                 id: this.sess.next_node_id(),\n                                 node: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n-                                span: DUMMY_SP,\n+                                span: constraint.span,\n                             },\n                             itctx,\n                         );\n@@ -1165,10 +1131,10 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::TypeBinding {\n-            hir_id: self.lower_node_id(c.id),\n-            ident: c.ident,\n+            hir_id: self.lower_node_id(constraint.id),\n+            ident: constraint.ident,\n             kind,\n-            span: c.span,\n+            span: constraint.span,\n         }\n     }\n \n@@ -1264,7 +1230,7 @@ impl<'a> LoweringContext<'a> {\n                     P(hir::Path {\n                         res,\n                         segments: hir_vec![hir::PathSegment::from_ident(\n-                            Ident::with_empty_ctxt(kw::SelfUpper)\n+                            Ident::with_dummy_span(kw::SelfUpper)\n                         )],\n                         span: t.span,\n                     }),\n@@ -1396,6 +1362,13 @@ impl<'a> LoweringContext<'a> {\n         opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext<'_>) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n+        debug!(\n+            \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n+            fn_def_id,\n+            opaque_ty_node_id,\n+            span,\n+        );\n+\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1423,6 +1396,14 @@ impl<'a> LoweringContext<'a> {\n             &hir_bounds,\n         );\n \n+        debug!(\n+            \"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,\n+        );\n+\n+        debug!(\n+            \"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,\n+        );\n+\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n@@ -1438,7 +1419,7 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::OpaqueTyOrigin::FnReturn,\n             };\n \n-            trace!(\"exist ty from impl trait def-index: {:#?}\", opaque_ty_def_index);\n+            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n             let opaque_ty_id = lctx.generate_opaque_type(\n                 opaque_ty_node_id,\n                 opaque_ty_item,\n@@ -1486,6 +1467,13 @@ impl<'a> LoweringContext<'a> {\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n+        debug!(\n+            \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n+             parent_index={:?}, \\\n+             bounds={:#?})\",\n+            opaque_ty_id, parent_index, bounds,\n+        );\n+\n         // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n@@ -1573,6 +1561,11 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     }\n                     hir::LifetimeName::Param(_) => lifetime.name,\n+\n+                    // Refers to some other lifetime that is \"in\n+                    // scope\" within the type.\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n+\n                     hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n                 };\n \n@@ -1598,7 +1591,7 @@ impl<'a> LoweringContext<'a> {\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => (\n-                            hir::ParamName::Plain(Ident::with_empty_ctxt(kw::UnderscoreLifetime)),\n+                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n                             hir::LifetimeParamKind::Elided,\n                         ),\n                         hir::LifetimeName::Param(param_name) => (\n@@ -1953,8 +1946,7 @@ impl<'a> LoweringContext<'a> {\n                         err.emit();\n                     }\n                     AnonymousLifetimeMode::PassThrough |\n-                    AnonymousLifetimeMode::ReportError |\n-                    AnonymousLifetimeMode::Replace(_) => {\n+                    AnonymousLifetimeMode::ReportError => {\n                         self.sess.buffer_lint_with_diagnostic(\n                             ELIDED_LIFETIMES_IN_PATHS,\n                             CRATE_NODE_ID,\n@@ -2043,7 +2035,7 @@ impl<'a> LoweringContext<'a> {\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n                                 hir_id: this.next_id(),\n-                                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                                 kind: hir::TypeBindingKind::Equality {\n                                     ty: output\n                                         .as_ref()\n@@ -2141,7 +2133,6 @@ impl<'a> LoweringContext<'a> {\n \n         // Remember how many lifetimes were already around so that we can\n         // only look at the lifetime parameters introduced by the arguments.\n-        let lifetime_count_before_args = self.lifetimes_to_define.len();\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n             decl.inputs\n                 .iter()\n@@ -2156,16 +2147,10 @@ impl<'a> LoweringContext<'a> {\n         });\n \n         let output = if let Some(ret_id) = make_ret_async {\n-            // Calculate the `LtReplacement` to use for any return-position elided\n-            // lifetimes based on the elided lifetime parameters introduced in the args.\n-            let lt_replacement = get_elided_lt_replacement(\n-                &self.lifetimes_to_define[lifetime_count_before_args..]\n-            );\n             self.lower_async_fn_ret_ty(\n                 &decl.output,\n                 in_band_ty_params.expect(\"`make_ret_async` but no `fn_def_id`\").0,\n                 ret_id,\n-                lt_replacement,\n             )\n         } else {\n             match decl.output {\n@@ -2230,8 +2215,15 @@ impl<'a> LoweringContext<'a> {\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n-        elided_lt_replacement: LtReplacement,\n     ) -> hir::FunctionRetTy {\n+        debug!(\n+            \"lower_async_fn_ret_ty(\\\n+             output={:?}, \\\n+             fn_def_id={:?}, \\\n+             opaque_ty_node_id={:?})\",\n+            output, fn_def_id, opaque_ty_node_id,\n+        );\n+\n         let span = output.span();\n \n         let opaque_ty_span = self.mark_span_with_reason(\n@@ -2248,16 +2240,74 @@ impl<'a> LoweringContext<'a> {\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n+        // When we create the opaque type for this async fn, it is going to have\n+        // to capture all the lifetimes involved in the signature (including in the\n+        // return type). This is done by introducing lifetime parameters for:\n+        //\n+        // - all the explicitly declared lifetimes from the impl and function itself;\n+        // - all the elided lifetimes in the fn arguments;\n+        // - all the elided lifetimes in the return type.\n+        //\n+        // So for example in this snippet:\n+        //\n+        // ```rust\n+        // impl<'a> Foo<'a> {\n+        //   async fn bar<'b>(&self, x: &'b Vec<f64>, y: &str) -> &u32 {\n+        //   //               ^ '0                       ^ '1     ^ '2\n+        //   // elided lifetimes used below\n+        //   }\n+        // }\n+        // ```\n+        //\n+        // we would create an opaque type like:\n+        //\n+        // ```\n+        // type Bar<'a, 'b, '0, '1, '2> = impl Future<Output = &'2 u32>;\n+        // ```\n+        //\n+        // and we would then desugar `bar` to the equivalent of:\n+        //\n+        // ```rust\n+        // impl<'a> Foo<'a> {\n+        //   fn bar<'b, '0, '1>(&'0 self, x: &'b Vec<f64>, y: &'1 str) -> Bar<'a, 'b, '0, '1, '_>\n+        // }\n+        // ```\n+        //\n+        // Note that the final parameter to `Bar` is `'_`, not `'2` --\n+        // this is because the elided lifetimes from the return type\n+        // should be figured out using the ordinary elision rules, and\n+        // this desugaring achieves that.\n+        //\n+        // The variable `input_lifetimes_count` tracks the number of\n+        // lifetime parameters to the opaque type *not counting* those\n+        // lifetimes elided in the return type. This includes those\n+        // that are explicitly declared (`in_scope_lifetimes`) and\n+        // those elided lifetimes we found in the arguments (current\n+        // content of `lifetimes_to_define`). Next, we will process\n+        // the return type, which will cause `lifetimes_to_define` to\n+        // grow.\n+        let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n+\n         let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+            // We have to be careful to get elision right here. The\n+            // idea is that we create a lifetime parameter for each\n+            // lifetime in the return type.  So, given a return type\n+            // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n+            // Future<Output = &'1 [ &'2 u32 ]>`.\n+            //\n+            // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n+            // hence the elision takes place at the fn site.\n             let future_bound = this.with_anonymous_lifetime_mode(\n-                AnonymousLifetimeMode::Replace(elided_lt_replacement),\n+                AnonymousLifetimeMode::CreateParameter,\n                 |this| this.lower_async_fn_output_type_to_future_bound(\n                     output,\n                     fn_def_id,\n                     span,\n                 ),\n             );\n \n+            debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n+\n             // Calculate all the lifetimes that should be captured\n             // by the opaque type. This should include all in-scope\n             // lifetime parameters, including those defined in-band.\n@@ -2267,10 +2317,14 @@ impl<'a> LoweringContext<'a> {\n             let lifetime_params: Vec<(Span, ParamName)> =\n                 this.in_scope_lifetimes\n                     .iter().cloned()\n-                    .map(|ident| (ident.span, ParamName::Plain(ident)))\n+                    .map(|name| (name.ident().span, name))\n                     .chain(this.lifetimes_to_define.iter().cloned())\n                     .collect();\n \n+            debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", this.in_scope_lifetimes);\n+            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n+            debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n+\n             let generic_params =\n                 lifetime_params\n                     .iter().cloned()\n@@ -2304,19 +2358,52 @@ impl<'a> LoweringContext<'a> {\n             (opaque_ty_id, lifetime_params)\n         });\n \n-        let generic_args =\n-            lifetime_params\n-                .iter().cloned()\n-                .map(|(span, hir_name)| {\n-                    GenericArg::Lifetime(hir::Lifetime {\n-                        hir_id: self.next_id(),\n-                        span,\n-                        name: hir::LifetimeName::Param(hir_name),\n-                    })\n+        // As documented above on the variable\n+        // `input_lifetimes_count`, we need to create the lifetime\n+        // arguments to our opaque type. Continuing with our example,\n+        // we're creating the type arguments for the return type:\n+        //\n+        // ```\n+        // Bar<'a, 'b, '0, '1, '_>\n+        // ```\n+        //\n+        // For the \"input\" lifetime parameters, we wish to create\n+        // references to the parameters themselves, including the\n+        // \"implicit\" ones created from parameter types (`'a`, `'b`,\n+        // '`0`, `'1`).\n+        //\n+        // For the \"output\" lifetime parameters, we just want to\n+        // generate `'_`.\n+        let mut generic_args: Vec<_> =\n+            lifetime_params[..input_lifetimes_count]\n+            .iter()\n+            .map(|&(span, hir_name)| {\n+                // Input lifetime like `'a` or `'1`:\n+                GenericArg::Lifetime(hir::Lifetime {\n+                    hir_id: self.next_id(),\n+                    span,\n+                    name: hir::LifetimeName::Param(hir_name),\n                 })\n-                .collect();\n+            })\n+            .collect();\n+        generic_args.extend(\n+            lifetime_params[input_lifetimes_count..]\n+            .iter()\n+            .map(|&(span, _)| {\n+                // Output lifetime like `'_`.\n+                GenericArg::Lifetime(hir::Lifetime {\n+                    hir_id: self.next_id(),\n+                    span,\n+                    name: hir::LifetimeName::Implicit,\n+                })\n+            })\n+        );\n \n-        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        // Create the `Foo<...>` refernece itself. Note that the `type\n+        // Foo = impl Trait` is, internally, created as a child of the\n+        // async fn, so the *type parameters* are inherited.  It's\n+        // only the lifetime parameters that we must supply.\n+        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args.into());\n \n         hir::FunctionRetTy::Return(P(hir::Ty {\n             node: opaque_ty_ref,\n@@ -2350,7 +2437,7 @@ impl<'a> LoweringContext<'a> {\n         let future_params = P(hir::GenericArgs {\n             args: hir_vec![],\n             bindings: hir_vec![hir::TypeBinding {\n-                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 kind: hir::TypeBindingKind::Equality {\n                     ty: output_ty,\n                 },\n@@ -2412,11 +2499,6 @@ impl<'a> LoweringContext<'a> {\n                     }\n \n                     AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n-\n-                    AnonymousLifetimeMode::Replace(replacement) => {\n-                        let hir_id = self.lower_node_id(l.id);\n-                        self.replace_elided_lifetime(hir_id, span, replacement)\n-                    }\n                 },\n             ident => {\n                 self.maybe_collect_in_band_lifetime(ident);\n@@ -2439,39 +2521,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    /// Replace a return-position elided lifetime with the elided lifetime\n-    /// from the arguments.\n-    fn replace_elided_lifetime(\n-        &mut self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-        replacement: LtReplacement,\n-    ) -> hir::Lifetime {\n-        let multiple_or_none = match replacement {\n-            LtReplacement::Some(name) => {\n-                return hir::Lifetime {\n-                    hir_id,\n-                    span,\n-                    name: hir::LifetimeName::Param(name),\n-                };\n-            }\n-            LtReplacement::MultipleLifetimes => \"multiple\",\n-            LtReplacement::NoLifetimes => \"none\",\n-        };\n-\n-        let mut err = crate::middle::resolve_lifetime::report_missing_lifetime_specifiers(\n-            self.sess,\n-            span,\n-            1,\n-        );\n-        err.note(&format!(\n-            \"return-position elided lifetimes require exactly one \\\n-             input-position elided lifetime, found {}.\", multiple_or_none));\n-        err.emit();\n-\n-        hir::Lifetime { hir_id, span, name: hir::LifetimeName::Error }\n-    }\n-\n     fn lower_generic_params(\n         &mut self,\n         params: &[GenericParam],\n@@ -2507,6 +2556,12 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit\n                         | hir::LifetimeName::Underscore\n                         | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                        span_bug!(\n+                            param.ident.span,\n+                            \"object-lifetime-default should not occur here\",\n+                        );\n+                    }\n                     hir::LifetimeName::Error => ParamName::Error,\n                 };\n \n@@ -2519,15 +2574,6 @@ impl<'a> LoweringContext<'a> {\n                 (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n-                // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-                // Instead, use `gensym(\"Self\")` to create a distinct name that looks the same.\n-                let ident = if param.ident.name == kw::SelfUpper {\n-                    param.ident.gensym()\n-                } else {\n-                    param.ident\n-                };\n-\n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n                     let params = self.lower_param_bounds(add_bounds, itctx.reborrow()).into_iter();\n@@ -2546,7 +2592,7 @@ impl<'a> LoweringContext<'a> {\n                                           .next(),\n                 };\n \n-                (hir::ParamName::Plain(ident), kind)\n+                (hir::ParamName::Plain(param.ident), kind)\n             }\n             GenericParamKind::Const { ref ty } => {\n                 (hir::ParamName::Plain(param.ident), hir::GenericParamKind::Const {\n@@ -2664,6 +2710,9 @@ impl<'a> LoweringContext<'a> {\n                 let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                 hir::PatKind::TupleStruct(qpath, pats, ddpos)\n             }\n+            PatKind::Or(ref pats) => {\n+                hir::PatKind::Or(pats.iter().map(|x| self.lower_pat(x)).collect())\n+            }\n             PatKind::Path(ref qself, ref path) => {\n                 let qpath = self.lower_qpath(\n                     p.id,\n@@ -2685,16 +2734,12 @@ impl<'a> LoweringContext<'a> {\n \n                 let fs = fields\n                     .iter()\n-                    .map(|f| {\n-                        Spanned {\n-                            span: f.span,\n-                            node: hir::FieldPat {\n-                                hir_id: self.next_id(),\n-                                ident: f.node.ident,\n-                                pat: self.lower_pat(&f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n+                    .map(|f| hir::FieldPat {\n+                        hir_id: self.next_id(),\n+                        ident: f.ident,\n+                        pat: self.lower_pat(&f.pat),\n+                        is_shorthand: f.is_shorthand,\n+                        span: f.span,\n                     })\n                     .collect();\n                 hir::PatKind::Struct(qpath, fs, etc)\n@@ -3174,10 +3219,6 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n \n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n-\n-            AnonymousLifetimeMode::Replace(replacement) => {\n-                self.new_replacement_lifetime(replacement, span)\n-            }\n         }\n     }\n \n@@ -3231,10 +3272,6 @@ impl<'a> LoweringContext<'a> {\n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n \n-            AnonymousLifetimeMode::Replace(replacement) => {\n-                self.new_replacement_lifetime(replacement, span)\n-            }\n-\n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n         }\n     }\n@@ -3266,23 +3303,15 @@ impl<'a> LoweringContext<'a> {\n \n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => {}\n-\n-            // We don't need to do any replacement here as this lifetime\n-            // doesn't refer to an elided lifetime elsewhere in the function\n-            // signature.\n-            AnonymousLifetimeMode::Replace(_) => {}\n         }\n \n-        self.new_implicit_lifetime(span)\n-    }\n-\n-    fn new_replacement_lifetime(\n-        &mut self,\n-        replacement: LtReplacement,\n-        span: Span,\n-    ) -> hir::Lifetime {\n-        let hir_id = self.next_id();\n-        self.replace_elided_lifetime(hir_id, span, replacement)\n+        let r = hir::Lifetime {\n+            hir_id: self.next_id(),\n+            span,\n+            name: hir::LifetimeName::ImplicitObjectLifetimeDefault,\n+        };\n+        debug!(\"elided_dyn_bound: r={:?}\", r);\n+        r\n     }\n \n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {"}, {"sha": "ff0c44a23874bfa96bd824625fc1e162583416de", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -552,7 +552,7 @@ impl LoweringContext<'_> {\n \n         // let mut pinned = <expr>;\n         let expr = P(self.lower_expr(expr));\n-        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n+        let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n@@ -593,7 +593,7 @@ impl LoweringContext<'_> {\n         let loop_node_id = self.sess.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n-            let x_ident = Ident::with_empty_ctxt(sym::result);\n+            let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n             let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n             let ready_pat = self.pat_std_enum(\n@@ -677,6 +677,7 @@ impl LoweringContext<'_> {\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n         self.with_new_scopes(|this| {\n+            let prev = this.current_item;\n             this.current_item = Some(fn_decl_span);\n             let mut generator_kind = None;\n             let body_id = this.lower_fn_body(decl, |this| {\n@@ -690,8 +691,10 @@ impl LoweringContext<'_> {\n                 generator_kind,\n                 movability,\n             );\n+            let capture_clause = this.lower_capture_clause(capture_clause);\n+            this.current_item = prev;\n             hir::ExprKind::Closure(\n-                this.lower_capture_clause(capture_clause),\n+                capture_clause,\n                 fn_decl,\n                 body_id,\n                 fn_decl_span,\n@@ -981,7 +984,6 @@ impl LoweringContext<'_> {\n             volatile: asm.volatile,\n             alignstack: asm.alignstack,\n             dialect: asm.dialect,\n-            ctxt: asm.ctxt,\n         };\n \n         let outputs = asm.outputs\n@@ -1067,9 +1069,9 @@ impl LoweringContext<'_> {\n         );\n         head.span = desugared_span;\n \n-        let iter = Ident::with_empty_ctxt(sym::iter);\n+        let iter = Ident::with_dummy_span(sym::iter);\n \n-        let next_ident = Ident::with_empty_ctxt(sym::__next);\n+        let next_ident = Ident::with_dummy_span(sym::__next);\n         let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n             desugared_span,\n             next_ident,\n@@ -1078,7 +1080,7 @@ impl LoweringContext<'_> {\n \n         // `::std::option::Option::Some(val) => __next = val`\n         let pat_arm = {\n-            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n             let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n             let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n@@ -1244,7 +1246,7 @@ impl LoweringContext<'_> {\n \n         // `Ok(val) => #[allow(unreachable_code)] val,`\n         let ok_arm = {\n-            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n             let val_expr = P(self.expr_ident_with_attrs(\n                 span,\n@@ -1260,7 +1262,7 @@ impl LoweringContext<'_> {\n         // `Err(err) => #[allow(unreachable_code)]\n         //              return Try::from_error(From::from(err)),`\n         let err_arm = {\n-            let err_ident = Ident::with_empty_ctxt(sym::err);\n+            let err_ident = Ident::with_dummy_span(sym::err);\n             let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n             let from_expr = {\n                 let from_path = &[sym::convert, sym::From, sym::from];"}, {"sha": "4f9a9ed5673c7acc83d363e43d27943ecae58291", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -60,10 +60,12 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n         let mut item_hir_id = None;\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            if let Some(hir_item) = lctx.lower_item(item) {\n-                item_hir_id = Some(hir_item.hir_id);\n-                lctx.insert_item(hir_item);\n-            }\n+            lctx.without_in_scope_lifetime_defs(|lctx| {\n+                if let Some(hir_item) = lctx.lower_item(item) {\n+                    item_hir_id = Some(hir_item.hir_id);\n+                    lctx.insert_item(hir_item);\n+                }\n+            })\n         });\n \n         if let Some(hir_id) = item_hir_id {\n@@ -123,7 +125,7 @@ impl LoweringContext<'_> {\n             _ => &[],\n         };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.modern()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -134,6 +136,28 @@ impl LoweringContext<'_> {\n         res\n     }\n \n+    // Clears (and restores) the `in_scope_lifetimes` field. Used when\n+    // visiting nested items, which never inherit in-scope lifetimes\n+    // from their surrounding environment.\n+    fn without_in_scope_lifetime_defs<T>(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> T,\n+    ) -> T {\n+        let old_in_scope_lifetimes = std::mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+\n+        // this vector is only used when walking over impl headers,\n+        // input types, and the like, and should not be non-empty in\n+        // between items\n+        assert!(self.lifetimes_to_define.is_empty());\n+\n+        let res = f(self);\n+\n+        assert!(self.in_scope_lifetimes.is_empty());\n+        self.in_scope_lifetimes = old_in_scope_lifetimes;\n+\n+        res\n+    }\n+\n     pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n         hir::Mod {\n             inner: m.inner,\n@@ -726,21 +750,16 @@ impl LoweringContext<'_> {\n     }\n \n     fn lower_global_asm(&mut self, ga: &GlobalAsm) -> P<hir::GlobalAsm> {\n-        P(hir::GlobalAsm {\n-            asm: ga.asm,\n-            ctxt: ga.ctxt,\n-        })\n+        P(hir::GlobalAsm { asm: ga.asm })\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n-        Spanned {\n-            node: hir::VariantKind {\n-                ident: v.node.ident,\n-                id: self.lower_node_id(v.node.id),\n-                attrs: self.lower_attrs(&v.node.attrs),\n-                data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n-            },\n+        hir::Variant {\n+            attrs: self.lower_attrs(&v.attrs),\n+            data: self.lower_variant_data(&v.data),\n+            disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n+            id: self.lower_node_id(v.id),\n+            ident: v.ident,\n             span: v.span,\n         }\n     }"}, {"sha": "effe2c0cc6a76f1dde4be58fa7b145fbc3fdad90", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -544,11 +544,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n-        self.insert(v.span, v.node.id, Node::Variant(v));\n-        self.with_parent(v.node.id, |this| {\n+        self.insert(v.span, v.id, Node::Variant(v));\n+        self.with_parent(v.id, |this| {\n             // Register the constructor of this variant.\n-            if let Some(ctor_hir_id) = v.node.data.ctor_hir_id() {\n-                this.insert(v.span, ctor_hir_id, Node::Ctor(&v.node.data));\n+            if let Some(ctor_hir_id) = v.data.ctor_hir_id() {\n+                this.insert(v.span, ctor_hir_id, Node::Ctor(&v.data));\n             }\n             intravisit::walk_variant(this, v, g, item_id);\n         });"}, {"sha": "d725afa40521253843e70072e0abf35324f22f9b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -74,7 +74,7 @@ impl<'a> DefCollector<'a> {\n         })\n     }\n \n-    fn visit_macro_invoc(&mut self, id: NodeId) {\n+    pub fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }\n@@ -155,11 +155,11 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-        let def = self.create_def(v.node.id,\n-                                  DefPathData::TypeNs(v.node.ident.as_interned_str()),\n+        let def = self.create_def(v.id,\n+                                  DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n         self.with_parent(def, |this| {\n-            if let Some(ctor_hir_id) = v.node.data.ctor_id() {\n+            if let Some(ctor_hir_id) = v.data.ctor_id() {\n                 this.create_def(ctor_hir_id, DefPathData::Ctor, v.span);\n             }\n             visit::walk_variant(this, v, g, item_id)"}, {"sha": "6dc3c7038f5696c625ae4601e4eb9a634d0ba40e", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -411,10 +411,6 @@ impl Definitions {\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    ///\n-    /// After the initial definitions are created the first `FIRST_FREE_DEF_INDEX` indexes\n-    /// are taken, so the \"user\" indexes will be allocated starting with `FIRST_FREE_DEF_INDEX`\n-    /// in ascending order.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n                            crate_disambiguator: CrateDisambiguator)\n@@ -589,19 +585,6 @@ impl DefPathData {\n     }\n }\n \n-/// Evaluates to the number of tokens passed to it.\n-///\n-/// Logarithmic counting: every one or two recursive expansions, the number of\n-/// tokens to count is divided by two, instead of being reduced by one.\n-/// Therefore, the recursion depth is the binary logarithm of the number of\n-/// tokens to count, and the expanded tree is likewise very small.\n-macro_rules! count {\n-    ()                     => (0usize);\n-    ($one:tt)              => (1usize);\n-    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n-    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n-}\n-\n // We define the GlobalMetaDataKind enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n // the corresponding DefIndices in the DefTable.\n@@ -614,8 +597,6 @@ macro_rules! define_global_metadata_kind {\n             $($variant),*\n         }\n \n-        pub const FIRST_FREE_DEF_INDEX: usize = 1 + count!($($variant)*);\n-\n         impl GlobalMetaDataKind {\n             fn allocate_def_indices(definitions: &mut Definitions) {\n                 $({"}, {"sha": "7292428ec378c62be57090a7e2d7e2532d80e265", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -649,12 +649,34 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn is_const_scope(&self, hir_id: HirId) -> bool {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(Item { node: ItemKind::Const(_, _), .. }) => true,\n-            Node::Item(Item { node: ItemKind::Fn(_, header, _, _), .. }) => header.is_const(),\n+    /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n+    /// Used exclusively for diagnostics, to avoid suggestion function calls.\n+    pub fn is_const_context(&self, hir_id: HirId) -> bool {\n+        let parent_id = self.get_parent_item(hir_id);\n+        match self.get(parent_id) {\n+            Node::Item(&Item {\n+                node: ItemKind::Const(..),\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                node: TraitItemKind::Const(..),\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                node: ImplItemKind::Const(..),\n+                ..\n+            })\n+            | Node::AnonConst(_)\n+            | Node::Item(&Item {\n+                node: ItemKind::Static(..),\n+                ..\n+            }) => true,\n+            Node::Item(&Item {\n+                node: ItemKind::Fn(_, header, ..),\n+                ..\n+            }) => header.constness == Constness::Const,\n             _ => false,\n-        }, |_| false).map(|id| id != CRATE_HIR_ID).unwrap_or(false)\n+        }\n     }\n \n     /// If there is some error when walking the parents (e.g., a node does not\n@@ -885,7 +907,7 @@ impl<'hir> Map<'hir> {\n                     _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n                 }\n             }\n-            Some(Node::Variant(variant)) => &variant.node.data,\n+            Some(Node::Variant(variant)) => &variant.data,\n             Some(Node::Ctor(data)) => data,\n             _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n         }\n@@ -918,7 +940,7 @@ impl<'hir> Map<'hir> {\n             Node::ForeignItem(fi) => fi.ident.name,\n             Node::ImplItem(ii) => ii.ident.name,\n             Node::TraitItem(ti) => ti.ident.name,\n-            Node::Variant(v) => v.node.ident.name,\n+            Node::Variant(v) => v.ident.name,\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n@@ -939,7 +961,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n             Some(Node::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(Node::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n-            Some(Node::Variant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(Node::Variant(ref v)) => Some(&v.attrs[..]),\n             Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n             Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n@@ -1133,7 +1155,7 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n \n impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for VariantKind { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Variant { fn name(&self) -> Name { self.ident.name } }\n impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n@@ -1310,7 +1332,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         }\n         Some(Node::Variant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n-                    variant.node.ident,\n+                    variant.ident,\n                     path_str(), id_str)\n         }\n         Some(Node::Field(ref field)) => {"}, {"sha": "983048188527fd12f9e34aeaaa9050982ac88cc0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -23,7 +23,6 @@ use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n-use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n@@ -202,7 +201,7 @@ impl ParamName {\n         match *self {\n             ParamName::Plain(ident) => ident,\n             ParamName::Fresh(_) |\n-            ParamName::Error => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n+            ParamName::Error => Ident::with_dummy_span(kw::UnderscoreLifetime),\n         }\n     }\n \n@@ -222,6 +221,19 @@ pub enum LifetimeName {\n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n \n+    /// Implicit lifetime in a context like `dyn Foo`. This is\n+    /// distinguished from implicit lifetimes elsewhere because the\n+    /// lifetime that they default to must appear elsewhere within the\n+    /// enclosing type.  This means that, in an `impl Trait` context, we\n+    /// don't have to create a parameter for them. That is, `impl\n+    /// Trait<Item = &u32>` expands to an opaque type like `type\n+    /// Foo<'a> = impl Trait<Item = &'a u32>`, but `impl Trait<item =\n+    /// dyn Bar>` expands to `type Foo = impl Trait<Item = dyn Bar +\n+    /// 'static>`. The latter uses `ImplicitObjectLifetimeDefault` so\n+    /// that surrounding code knows not to create a lifetime\n+    /// parameter.\n+    ImplicitObjectLifetimeDefault,\n+\n     /// Indicates an error during lowering (usually `'_` in wrong place)\n     /// that was already reported.\n     Error,\n@@ -236,16 +248,20 @@ pub enum LifetimeName {\n impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            LifetimeName::Implicit | LifetimeName::Error => Ident::invalid(),\n-            LifetimeName::Underscore => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n-            LifetimeName::Static => Ident::with_empty_ctxt(kw::StaticLifetime),\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+                | LifetimeName::Implicit\n+                | LifetimeName::Error => Ident::invalid(),\n+            LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n+            LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(param_name) => param_name.ident(),\n         }\n     }\n \n     pub fn is_elided(&self) -> bool {\n         match self {\n-            LifetimeName::Implicit | LifetimeName::Underscore => true,\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+            | LifetimeName::Implicit\n+            | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as\n             // *not* elided -- but this is because, as far as the code\n@@ -877,11 +893,12 @@ impl Pat {\n         match self.node {\n             PatKind::Binding(.., Some(ref p)) => p.walk_(it),\n             PatKind::Struct(_, ref fields, _) => {\n-                fields.iter().all(|field| field.node.pat.walk_(it))\n+                fields.iter().all(|field| field.pat.walk_(it))\n             }\n             PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk_(it))\n             }\n+            PatKind::Or(ref pats) => pats.iter().all(|p| p.walk_(it)),\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n                 s.walk_(it)\n             }\n@@ -923,6 +940,7 @@ pub struct FieldPat {\n     /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n+    pub span: Span,\n }\n \n /// Explicit binding annotations given in the HIR for a binding. Note\n@@ -968,13 +986,17 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n+    Struct(QPath, HirVec<FieldPat>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n     TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n+    /// An or-pattern `A | B | C`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or(HirVec<P<Pat>>),\n+\n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n \n@@ -1541,7 +1563,7 @@ pub enum ExprKind {\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`.\n+    /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<GeneratorMovability>`.\n@@ -2003,8 +2025,6 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    #[stable_hasher(ignore)] // This is used for error reporting\n-    pub ctxt: SyntaxContext,\n }\n \n /// Represents an argument in a function header.\n@@ -2183,8 +2203,6 @@ pub struct ForeignMod {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n-    #[stable_hasher(ignore)] // This is used for error reporting\n-    pub ctxt: SyntaxContext,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2193,7 +2211,7 @@ pub struct EnumDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct VariantKind {\n+pub struct Variant {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2205,10 +2223,10 @@ pub struct VariantKind {\n     pub data: VariantData,\n     /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n+    /// Span\n+    pub span: Span\n }\n \n-pub type Variant = Spanned<VariantKind>;\n-\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`."}, {"sha": "632a13f9183b2c7c7f3b0feb172497cfd54f6972", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -737,7 +737,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.node.attrs);\n+            self.print_outer_attributes(&v.attrs);\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n@@ -829,8 +829,8 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &hir::Variant) {\n         self.head(\"\");\n         let generics = hir::Generics::empty();\n-        self.print_struct(&v.node.data, &generics, v.node.ident.name, v.span, false);\n-        if let Some(ref d) = v.node.disr_expr {\n+        self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n+        if let Some(ref d) = v.disr_expr {\n             self.s.space();\n             self.word_space(\"=\");\n             self.print_anon_const(d);\n@@ -1457,7 +1457,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) {\n-        self.print_ident(ast::Ident::with_empty_ctxt(name))\n+        self.print_ident(ast::Ident::with_dummy_span(name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) {\n@@ -1670,14 +1670,14 @@ impl<'a> State<'a> {\n                                    &fields[..],\n                                    |s, f| {\n                                        s.cbox(INDENT_UNIT);\n-                                       if !f.node.is_shorthand {\n-                                           s.print_ident(f.node.ident);\n+                                       if !f.is_shorthand {\n+                                           s.print_ident(f.ident);\n                                            s.word_nbsp(\":\");\n                                        }\n-                                       s.print_pat(&f.node.pat);\n+                                       s.print_pat(&f.pat);\n                                        s.end()\n                                    },\n-                                   |f| f.node.pat.span);\n+                                   |f| f.pat.span);\n                 if etc {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n@@ -1687,6 +1687,9 @@ impl<'a> State<'a> {\n                 self.s.space();\n                 self.s.word(\"}\");\n             }\n+            PatKind::Or(ref pats) => {\n+                self.strsep(\"|\", true, Inconsistent, &pats[..], |s, p| s.print_pat(&p));\n+            }\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen();\n                 if let Some(ddpos) = ddpos {"}, {"sha": "e77faea1e4c5855989ae6bf152c21b0af25510a3", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -350,7 +350,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         let line_col_len = col | line | len;\n         std_hash::Hash::hash(&line_col_len, hasher);\n \n-        if span.ctxt == SyntaxContext::empty() {\n+        if span.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(hcx, hasher);\n@@ -370,7 +370,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n                 }\n \n                 let mut hasher = StableHasher::new();\n-                expn_id.expn_info().hash_stable(hcx, &mut hasher);\n+                expn_id.expn_data().hash_stable(hcx, &mut hasher);\n                 let sub_hash: Fingerprint = hasher.finish();\n                 let sub_hash = sub_hash.to_smaller_hash();\n                 cache.borrow_mut().insert(expn_id, sub_hash);"}, {"sha": "60b338010b0db8a729117a2a1365968aad45c16b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -153,8 +153,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::FieldPat);\n-\n impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n impl_stable_hash_for!(struct hir::Stmt {\n@@ -187,8 +185,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n \n impl_stable_hash_for_spanned!(usize);\n \n-impl_stable_hash_for_spanned!(ast::Ident);\n-\n impl_stable_hash_for!(struct ast::Ident {\n     name,\n     span,\n@@ -304,7 +300,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::VariantKind);\n+impl_stable_hash_for_spanned!(hir::Variant);\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {"}, {"sha": "7003f71c8baa06ae1e02e8f3946b9d4d141d6e80", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -397,9 +397,10 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n     Opaque,\n });\n \n-impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n-    call_site,\n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     kind,\n+    parent -> _,\n+    call_site,\n     def_site,\n     default_transparency,\n     allow_internal_unstable,"}, {"sha": "84687b8cab5c0b9160103167a97ab4a149c7efe6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1329,15 +1329,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(did);\n                     // Account for the case where `did` corresponds to `Self`, which doesn't have\n                     // the expected type argument.\n-                    if !param.is_self() {\n+                    if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n                         hir.as_local_hir_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "3267505708b8100dfcee4e45cf7fc2423828e423", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 161, "deletions": 51, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,13 +1,13 @@\n use crate::hir::def::Namespace;\n-use crate::hir::{self, Local, Pat, Body, HirId};\n+use crate::hir::{self, Body, FunctionRetTy, Expr, ExprKind, HirId, Local, Pat};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n \n struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -16,9 +16,26 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_local_pattern: Option<&'tcx Pat>,\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n+    found_closure: Option<&'tcx ExprKind>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        target_ty: Ty<'tcx>,\n+        hir_map: &'a hir::map::Map<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            target_ty,\n+            hir_map,\n+            found_local_pattern: None,\n+            found_arg_pattern: None,\n+            found_ty: None,\n+            found_closure: None,\n+        }\n+    }\n+\n     fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_type_opt(hir_id)\n@@ -72,6 +89,60 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_body(self, body);\n     }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n+            &expr.node,\n+            self.node_matches_type(expr.hir_id),\n+        ) {\n+            self.found_closure = Some(&expr.node);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// Suggest giving an appropriate return type to a closure expression.\n+fn closure_return_type_suggestion(\n+    span: Span,\n+    err: &mut DiagnosticBuilder<'_>,\n+    output: &FunctionRetTy,\n+    body: &Body,\n+    name: &str,\n+    ret: &str,\n+) {\n+    let (arrow, post) = match output {\n+        FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+        _ => (\"\", \"\"),\n+    };\n+    let suggestion = match body.value.node {\n+        ExprKind::Block(..) => {\n+            vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n+        }\n+        _ => {\n+            vec![\n+                (output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n+                (body.value.span.shrink_to_hi(), \" }\".to_string()),\n+            ]\n+        }\n+    };\n+    err.multipart_suggestion(\n+        \"give this closure an explicit return type without `_` placeholders\",\n+        suggestion,\n+        Applicability::HasPlaceholders,\n+    );\n+    err.span_label(span, InferCtxt::missing_type_msg(&name));\n+}\n+\n+/// Given a closure signature, return a `String` containing a list of all its argument types.\n+fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n+    fn_sig.inputs()\n+        .skip_binder()\n+        .iter()\n+        .next()\n+        .map(|args| args.tuple_fields()\n+            .map(|arg| arg.to_string())\n+            .collect::<Vec<_>>().join(\", \"))\n+        .unwrap_or_default()\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -106,16 +177,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n-        let mut err_span = span;\n-\n-        let mut local_visitor = FindLocalByTypeVisitor {\n-            infcx: &self,\n-            target_ty: ty,\n-            hir_map: &self.tcx.hir(),\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-            found_ty: None,\n-        };\n+        let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -136,6 +198,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n+        let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n+            pattern.span\n+        } else {\n+            span\n+        };\n+\n+        let is_named_and_not_impl_trait = |ty: Ty<'_>| {\n+            &ty.to_string() != \"_\" &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n+        };\n+\n+        let ty_msg = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let args = closure_args(&fn_sig);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+                format!(\" for the closure `fn({}) -> {}`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) => {\n+                let ty = ty_to_string(ty);\n+                format!(\" for `{}`\", ty)\n+            }\n+            _ => String::new(),\n+        };\n \n         // When `name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n@@ -150,27 +237,58 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n         //   |         the type parameter `E` is specified\n         // ```\n-        let (ty_msg, suffix) = match &local_visitor.found_ty {\n-            Some(ty) if &ty.to_string() != \"_\" && name == \"_\" => {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            err_span,\n+            E0282,\n+            \"type annotations needed{}\",\n+            ty_msg,\n+        );\n+\n+        let suffix = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+\n+                if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n+                    if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n+                        closure_return_type_suggestion(\n+                            span,\n+                            &mut err,\n+                            &decl.output,\n+                            &body,\n+                            &name,\n+                            &ret,\n+                        );\n+                        // We don't want to give the other suggestions when the problem is the\n+                        // closure return type.\n+                        return err;\n+                    }\n+                }\n+\n+                // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n+                let args = closure_args(&fn_sig);\n+                // This suggestion is incomplete, as the user will get further type inference\n+                // errors due to the `_` placeholders and the introduction of `Box`, but it does\n+                // nudge them in the right direction.\n+                format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\"the explicit type `{}`, with the type parameters specified\", ty))\n+                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if &ty.to_string() != \"_\" && ty.to_string() != name => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\n-                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n+                format!(\n+                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n                     ty,\n                     name,\n-                 ))\n+                )\n             }\n-            _ => (String::new(), \"a type\".to_owned()),\n+            _ => \"a type\".to_string(),\n         };\n-        let mut labels = vec![(span, InferCtxt::missing_type_msg(&name))];\n \n         if let Some(pattern) = local_visitor.found_arg_pattern {\n-            err_span = pattern.span;\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:\n@@ -187,39 +305,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             //          ^ consider giving this closure parameter the type `[_; 0]`\n             //            with the type parameter `_` specified\n             // ```\n-            labels.clear();\n-            labels.push((\n+            err.span_label(\n                 pattern.span,\n                 format!(\"consider giving this closure parameter {}\", suffix),\n-            ));\n+            );\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            if let Some(simple_ident) = pattern.simple_ident() {\n+            let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n-                    None => labels.push((\n-                        pattern.span,\n-                        format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    )),\n-                    Some(DesugaringKind::ForLoop) => labels.push((\n-                        pattern.span,\n-                        \"the element type for this iterator is not specified\".to_owned(),\n-                    )),\n-                    _ => {}\n+                    None => {\n+                        format!(\"consider giving `{}` {}\", simple_ident, suffix)\n+                    }\n+                    Some(DesugaringKind::ForLoop) => {\n+                        \"the element type for this iterator is not specified\".to_string()\n+                    }\n+                    _ => format!(\"this needs {}\", suffix),\n                 }\n             } else {\n-                labels.push((pattern.span, format!(\"consider giving this pattern {}\", suffix)));\n-            }\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            err_span,\n-            E0282,\n-            \"type annotations needed{}\",\n-            ty_msg,\n-        );\n-\n-        for (target_span, label_message) in labels {\n-            err.span_label(target_span, label_message);\n+                format!(\"consider giving this pattern {}\", suffix)\n+            };\n+            err.span_label(pattern.span, msg);\n+        }\n+        if !err.span.span_labels().iter().any(|span_label| {\n+                span_label.label.is_some() && span_label.span == span\n+            }) && local_visitor.found_arg_pattern.is_none()\n+        { // Avoid multiple labels pointing at `span`.\n+            err.span_label(span, InferCtxt::missing_type_msg(&name));\n         }\n \n         err"}, {"sha": "c9fd3392a962d2df8e4f22b663576f51ac3348d2", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -127,8 +127,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n         debug!(\n             \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n-             param_env={:?})\",\n-            value, parent_def_id, body_id, param_env,\n+             param_env={:?}, value_span={:?})\",\n+            value, parent_def_id, body_id, param_env, value_span,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -1108,9 +1108,11 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n+            debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n+        debug!(\"fold_opaque_ty {:?} {:?}\", self.value_span, span);\n         let ty_var = infcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n "}, {"sha": "6801fa8d8dbe5b0099ebc53e04fd73ec3ba4406d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1060,7 +1060,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n             lint_callback!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             lint_callback!(cx, check_variant_post, v, g);\n@@ -1236,7 +1236,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(item_id, &v.node.attrs, |cx| {\n+        self.with_lint_attrs(item_id, &v.attrs, |cx| {\n             run_early_pass!(cx, check_variant, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n             run_early_pass!(cx, check_variant_post, v, g);\n@@ -1345,7 +1345,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         // part of `walk_mac`, and (b) we should be calling\n         // `visit_path`, *but* that would require a `NodeId`, and I\n         // want to get #53686 fixed quickly. -nmatsakis\n-        ast_visit::walk_path(self, &mac.node.path);\n+        ast_visit::walk_path(self, &mac.path);\n \n         run_early_pass!(self, check_mac, mac);\n     }\n@@ -1355,7 +1355,7 @@ struct LateLintPassObjects<'a> {\n     lints: &'a mut [LateLintPassObject],\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::lint_pass_impl_without_macro))]\n+#[allow(rustc::lint_pass_impl_without_macro)]\n impl LintPass for LateLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()\n@@ -1525,7 +1525,7 @@ struct EarlyLintPassObjects<'a> {\n     lints: &'a mut [EarlyLintPassObject],\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::lint_pass_impl_without_macro))]\n+#[allow(rustc::lint_pass_impl_without_macro)]\n impl LintPass for EarlyLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()"}, {"sha": "be73b305e2c50bd56d68f1c8b2cf9a1143e0556c", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -9,7 +9,6 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Ident, Item, ItemKind};\n use syntax::symbol::{sym, Symbol};\n-use syntax_pos::ExpnInfo;\n \n declare_tool_lint! {\n     pub rustc::DEFAULT_HASH_TYPES,\n@@ -23,7 +22,7 @@ pub struct DefaultHashTypes {\n \n impl DefaultHashTypes {\n     // we are allowed to use `HashMap` and `HashSet` as identifiers for implementing the lint itself\n-    #[cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n+    #[allow(rustc::default_hash_types)]\n     pub fn new() -> Self {\n         let mut map = FxHashMap::default();\n         map.insert(sym::HashMap, sym::FxHashMap);\n@@ -108,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                             .help(\"try using `Ty` instead\")\n                             .emit();\n                         } else {\n-                            if ty.span.ctxt().outer_expn_info().is_some() {\n+                            if ty.span.from_expansion() {\n                                 return;\n                             }\n                             if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n@@ -228,30 +227,20 @@ impl EarlyLintPass for LintPassImpl {\n         if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n-                    match &lint_pass.path.span.ctxt().outer_expn_info() {\n-                        Some(info) if is_lint_pass_expansion(info) => {}\n-                        _ => {\n-                            cx.struct_span_lint(\n-                                LINT_PASS_IMPL_WITHOUT_MACRO,\n-                                lint_pass.path.span,\n-                                \"implementing `LintPass` by hand\",\n-                            )\n-                            .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n-                            .emit();\n-                        }\n+                    let expn_data = lint_pass.path.span.ctxt().outer_expn_data();\n+                    let call_site = expn_data.call_site;\n+                    if expn_data.kind.descr() != sym::impl_lint_pass &&\n+                       call_site.ctxt().outer_expn_data().kind.descr() != sym::declare_lint_pass {\n+                        cx.struct_span_lint(\n+                            LINT_PASS_IMPL_WITHOUT_MACRO,\n+                            lint_pass.path.span,\n+                            \"implementing `LintPass` by hand\",\n+                        )\n+                        .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                        .emit();\n                     }\n                 }\n             }\n         }\n     }\n }\n-\n-fn is_lint_pass_expansion(expn_info: &ExpnInfo) -> bool {\n-    if expn_info.kind.descr() == sym::impl_lint_pass {\n-        true\n-    } else if let Some(info) = expn_info.call_site.ctxt().outer_expn_info() {\n-        info.kind.descr() == sym::declare_lint_pass\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "2b58627cdea563544c5d24a958ea88dd74a0aa28", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -846,7 +846,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.id, &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.id, &v.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }\n@@ -885,21 +885,16 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// This is used to test whether a lint should not even begin to figure out whether it should\n /// be reported on the current node.\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let info = match span.ctxt().outer_expn_info() {\n-        Some(info) => info,\n-        // no ExpnInfo means this span doesn't come from a macro\n-        None => return false,\n-    };\n-\n-    match info.kind {\n+    let expn_data = span.ctxt().outer_expn_data();\n+    match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n         ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n-            if info.def_site.is_dummy() {\n+            if expn_data.def_site.is_dummy() {\n                 // dummy span for the def_site means it's an external macro\n                 return true;\n             }\n-            match sess.source_map().span_to_snippet(info.def_site) {\n+            match sess.source_map().span_to_snippet(expn_data.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n                 // no snippet = external macro or compiler-builtin expansion\n                 Err(_) => true,\n@@ -911,10 +906,8 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n \n /// Returns whether `span` originates in a derive macro's expansion\n pub fn in_derive_expansion(span: Span) -> bool {\n-    if let Some(info) = span.ctxt().outer_expn_info() {\n-        if let ExpnKind::Macro(MacroKind::Derive, _) = info.kind {\n-            return true;\n-        }\n+    if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n+        return true;\n     }\n     false\n }"}, {"sha": "de84fcd7160dffd729e8a27f0cb0307006e21ad3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -178,8 +178,7 @@ pub trait MetadataLoader {\n                           -> Result<MetadataRef, String>;\n }\n \n-/// A store of Rust crates, through with their metadata\n-/// can be accessed.\n+/// A store of Rust crates, through which their metadata can be accessed.\n ///\n /// Note that this trait should probably not be expanding today. All new\n /// functionality should be driven through queries instead!"}, {"sha": "8ce8bb52566c6118a7b7adcf281300ba63200589", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -17,8 +17,7 @@ use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::fx::FxHashMap;\n \n-use syntax::{ast, source_map};\n-use syntax::attr;\n+use syntax::{ast, attr};\n use syntax::symbol::sym;\n use syntax_pos;\n \n@@ -119,17 +118,16 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res,\n-                                  pats: &[source_map::Spanned<hir::FieldPat>]) {\n+    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res, pats: &[hir::FieldPat]) {\n         let variant = match self.tables.node_type(lhs.hir_id).sty {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n-            if let PatKind::Wild = pat.node.pat.node {\n+            if let PatKind::Wild = pat.pat.node {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.node.hir_id, self.tables);\n+            let index = self.tcx.field_index(pat.hir_id, self.tables);\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -366,12 +364,12 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n                 if allow_dead_code {\n-                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.id));\n                 }\n \n                 for variant in &enum_def.variants {\n-                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n-                        self.struct_constructors.insert(ctor_hir_id, variant.node.id);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n+                        self.struct_constructors.insert(ctor_hir_id, variant.id);\n                     }\n                 }\n             }\n@@ -497,7 +495,7 @@ impl DeadVisitor<'tcx> {\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n     }\n \n-    fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n+    fn should_warn_about_variant(&mut self, variant: &hir::Variant) -> bool {\n         !self.symbol_is_live(variant.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.id,\n@@ -596,8 +594,8 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                      variant: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n-        if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.id, variant.span, variant.node.ident.name,\n+        if self.should_warn_about_variant(&variant) {\n+            self.warn_dead_code(variant.id, variant.span, variant.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);"}, {"sha": "9c9e8c0bca3b8f10a2e9d55a02a02686f98ccc05", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -418,8 +418,8 @@ fn add_from_pat<'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n             }\n             Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    if field.node.is_shorthand {\n-                        shorthand_field_ids.insert(field.node.pat.hir_id);\n+                    if field.is_shorthand {\n+                        shorthand_field_ids.insert(field.pat.hir_id);\n                     }\n                 }\n             }"}, {"sha": "73ca981bbe868513cebb0039080d23097c323509", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1282,11 +1282,17 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 };\n \n                 for fp in field_pats {\n-                    let field_ty = self.pat_ty_adjusted(&fp.node.pat)?; // see (*2)\n-                    let f_index = self.tcx.field_index(fp.node.hir_id, self.tables);\n+                    let field_ty = self.pat_ty_adjusted(&fp.pat)?; // see (*2)\n+                    let f_index = self.tcx.field_index(fp.hir_id, self.tables);\n                     let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n-                                                           fp.node.ident, field_ty));\n-                    self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n+                                                           fp.ident, field_ty));\n+                    self.cat_pattern_(cmt_field, &fp.pat, op)?;\n+                }\n+            }\n+\n+            PatKind::Or(ref pats) => {\n+                for pat in pats {\n+                    self.cat_pattern_(cmt.clone(), &pat, op)?;\n                 }\n             }\n "}, {"sha": "c2bcd46216324b24c0f0992ec36494b5d829b0d4", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -33,6 +33,9 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n     }\n \n     match item.node {\n+        hir::ItemKind::Fn(_, header, ..) if header.is_const() => {\n+            return true;\n+        }\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n@@ -52,6 +55,11 @@ fn method_might_be_inlined(\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n+    if let hir::ImplItemKind::Method(method_sig, _) = &impl_item.node {\n+        if method_sig.header.is_const() {\n+            return true\n+        }\n+    }\n     if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src) {\n         match tcx.hir().find(impl_hir_id) {\n             Some(Node::Item(item)) =>"}, {"sha": "3d100d2fbf8331c007bd82e0fd86e4f4cff22b68", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1207,7 +1207,7 @@ fn resolve_local<'tcx>(\n             PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n-                field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))\n+                field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n             }\n \n             PatKind::Slice(ref pats1, ref pats2, ref pats3) => {"}, {"sha": "f5b0af61693be6eba33db255fedb9b9a45f9065c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -5,6 +5,8 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n+// ignore-tidy-filelength\n+\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n@@ -556,6 +558,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n+        debug!(\"visit_ty: ty.node={:?}\", ty.node);\n         match ty.node {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n@@ -585,11 +588,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                debug!(\"visit_ty: TraitObject(bounds={:?}, lifetime={:?})\", bounds, lifetime);\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n                 match lifetime.name {\n                     LifetimeName::Implicit => {\n+                        // For types like `dyn Foo`, we should\n+                        // generate a special form of elided.\n+                        span_bug!(\n+                            ty.span,\n+                            \"object-lifetime-default expected, not implict\",\n+                        );\n+                    }\n+                    LifetimeName::ImplicitObjectLifetimeDefault => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n                         // rules. So e.g., `Box<dyn Debug>` becomes\n@@ -897,6 +909,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"visit_lifetime(lifetime_ref={:?})\", lifetime_ref);\n         if lifetime_ref.is_elided() {\n             self.resolve_elided_lifetimes(vec![lifetime_ref]);\n             return;\n@@ -1911,6 +1924,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n+        debug!(\n+            \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n+            res,\n+            depth,\n+            generic_args,\n+        );\n+\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n@@ -1964,6 +1984,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             _ => None,\n         };\n \n+        debug!(\"visit_segment_args: type_def_id={:?}\", type_def_id);\n+\n+        // Compute a vector of defaults, one for each type parameter,\n+        // per the rules given in RFCs 599 and 1156. Example:\n+        //\n+        // ```rust\n+        // struct Foo<'a, T: 'a, U> { }\n+        // ```\n+        //\n+        // If you have `Foo<'x, dyn Bar, dyn Baz>`, we want to default\n+        // `dyn Bar` to `dyn Bar + 'x` (because of the `T: 'a` bound)\n+        // and `dyn Baz` to `dyn Baz + 'static` (because there is no\n+        // such bound).\n+        //\n+        // Therefore, we would compute `object_lifetime_defaults` to a\n+        // vector like `['x, 'static]`. Note that the vector only\n+        // includes type parameters.\n         let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n             let in_body = {\n                 let mut scope = self.scope;\n@@ -2003,6 +2040,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             .collect()\n                     })\n             };\n+            debug!(\"visit_segment_args: unsubst={:?}\", unsubst);\n             unsubst\n                 .iter()\n                 .map(|set| match *set {\n@@ -2023,6 +2061,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 .collect()\n         });\n \n+        debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n+\n         let mut i = 0;\n         for arg in &generic_args.args {\n             match arg {\n@@ -2045,8 +2085,49 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n+        // Hack: when resolving the type `XX` in binding like `dyn\n+        // Foo<'b, Item = XX>`, the current object-lifetime default\n+        // would be to examine the trait `Foo` to check whether it has\n+        // a lifetime bound declared on `Item`. e.g., if `Foo` is\n+        // declared like so, then the default object lifetime bound in\n+        // `XX` should be `'b`:\n+        //\n+        // ```rust\n+        // trait Foo<'a> {\n+        //   type Item: 'a;\n+        // }\n+        // ```\n+        //\n+        // but if we just have `type Item;`, then it would be\n+        // `'static`. However, we don't get all of this logic correct.\n+        //\n+        // Instead, we do something hacky: if there are no lifetime parameters\n+        // to the trait, then we simply use a default object lifetime\n+        // bound of `'static`, because there is no other possibility. On the other hand,\n+        // if there ARE lifetime parameters, then we require the user to give an\n+        // explicit bound for now.\n+        //\n+        // This is intended to leave room for us to implement the\n+        // correct behavior in the future.\n+        let has_lifetime_parameter = generic_args\n+            .args\n+            .iter()\n+            .any(|arg| match arg {\n+                GenericArg::Lifetime(_) => true,\n+                _ => false,\n+            });\n+\n+        // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n         for b in &generic_args.bindings {\n-            self.visit_assoc_type_binding(b);\n+            let scope = Scope::ObjectLifetimeDefault {\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(Region::Static)\n+                },\n+                s: self.scope,\n+            };\n+            self.with(scope, |_, this| this.visit_assoc_type_binding(b));\n         }\n     }\n \n@@ -2347,6 +2428,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_elided_lifetimes(&mut self, lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n+        debug!(\"resolve_elided_lifetimes(lifetime_refs={:?})\", lifetime_refs);\n+\n         if lifetime_refs.is_empty() {\n             return;\n         }\n@@ -2539,6 +2622,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let lifetime = loop {\n@@ -2638,6 +2722,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n+                        hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                            self.tcx.sess.delay_span_bug(\n+                                lt.span,\n+                                \"lowering generated `ImplicitObjectLifetimeDefault` \\\n+                                 outside of an object type\",\n+                            )\n+                        }\n                         hir::LifetimeName::Error => {\n                             // No need to do anything, error already reported.\n                         }"}, {"sha": "d02259bf3010b48bd002bbc38555424878b79195", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -290,10 +290,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.annotate(var.node.id, &var.node.attrs, var.span, AnnotationKind::Required,\n+        self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required,\n             |v| {\n-                if let Some(ctor_hir_id) = var.node.data.ctor_hir_id() {\n-                    v.annotate(ctor_hir_id, &var.node.attrs, var.span, AnnotationKind::Required,\n+                if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n+                    v.annotate(ctor_hir_id, &var.attrs, var.span, AnnotationKind::Required,\n                                |_| {});\n                 }\n \n@@ -372,7 +372,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.check_missing_stability(var.node.id, var.span, \"variant\");\n+        self.check_missing_stability(var.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n "}, {"sha": "84b4cd914563e6574a28d2d94392833d75dfb3be", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -306,7 +306,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///\n     /// zsts can't be read out of two reasons:\n     /// * byteorder cannot work with zero element buffers\n-    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n+    /// * in order to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n     ///   being valid for ZSTs\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand."}, {"sha": "b55e6bc54bc5ff25b0576695a41c82ac3afed240", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -189,8 +189,11 @@ impl<'tcx, Tag> Pointer<Tag> {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }\n \n+    /// Test if the pointer is \"inbounds\" of an allocation of the given size.\n+    /// A pointer is \"inbounds\" even if its offset is equal to the size; this is\n+    /// a \"one-past-the-end\" pointer.\n     #[inline(always)]\n-    pub fn check_in_alloc(\n+    pub fn check_inbounds_alloc(\n         self,\n         allocation_size: Size,\n         msg: CheckInAllocMsg,"}, {"sha": "3da5a65c37932d154d755115770bce84db91a32a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -530,7 +530,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::ZERO)),\n         }\n     }\n "}, {"sha": "11701a66377442f60f640bf1e01556df179c7ebd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -2197,7 +2197,6 @@ impl<'tcx> Operand<'tcx> {\n         let ty = tcx.type_of(def_id).subst(tcx, substs);\n         Operand::Constant(box Constant {\n             span,\n-            ty,\n             user_ty: None,\n             literal: ty::Const::zero_sized(tcx, ty),\n         })\n@@ -2476,7 +2475,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n-    pub ty: Ty<'tcx>,\n \n     /// Optional user-given type: for something like\n     /// `collect::<Vec<_>>`, this would be present and would\n@@ -3385,12 +3383,11 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {\n             span: self.span.clone(),\n-            ty: self.ty.fold_with(folder),\n             user_ty: self.user_ty.fold_with(folder),\n             literal: self.literal.fold_with(folder),\n         }\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor) || self.literal.visit_with(visitor)\n+        self.literal.visit_with(visitor)\n     }\n }"}, {"sha": "e9f7636ba85ae72b92bd730e0cfd51c1d9c22058", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -252,7 +252,7 @@ impl<'tcx> Operand<'tcx> {\n         match self {\n             &Operand::Copy(ref l) |\n             &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n-            &Operand::Constant(ref c) => c.ty,\n+            &Operand::Constant(ref c) => c.literal.ty,\n         }\n     }\n }"}, {"sha": "2d16e7bcc83716aae59408ad7eb39434aec7e84b", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -782,13 +782,11 @@ macro_rules! make_mir_visitor {\n                               location: Location) {\n                 let Constant {\n                     span,\n-                    ty,\n                     user_ty,\n                     literal,\n                 } = constant;\n \n                 self.visit_span(span);\n-                self.visit_ty(ty, TyContext::Location(location));\n                 drop(user_ty); // no visit method for this\n                 self.visit_const(literal, location);\n             }"}, {"sha": "8e3b910e0da3a89a0b8c8c56baa192f4adbc4d63", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -395,7 +395,7 @@ top_level_options!(\n         output_types: OutputTypes [TRACKED],\n         search_paths: Vec<SearchPath> [UNTRACKED],\n         libs: Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> [TRACKED],\n-        maybe_sysroot: Option<PathBuf> [TRACKED],\n+        maybe_sysroot: Option<PathBuf> [UNTRACKED],\n \n         target_triple: TargetTriple [TRACKED],\n "}, {"sha": "ba92e851141a655cd929964c0a9d8b29096f39b8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -36,7 +36,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnKind};\n+use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -61,9 +61,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // We want to ignore desugarings here: spans are equivalent even\n             // if one is the result of a desugaring and the other is not.\n             let mut span = error.obligation.cause.span;\n-            if let Some(ExpnInfo { kind: ExpnKind::Desugaring(_), def_site, .. })\n-                    = span.ctxt().outer_expn_info() {\n-                span = def_site;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n             }\n \n             error_map.entry(span).or_default().push("}, {"sha": "c1de4939c1d9154a567b4ea8c12342968f8d28b8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -248,10 +248,10 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     /// This is always inlined, despite its size, because it has a single\n     /// callsite and it is called *very* frequently.\n     #[inline(always)]\n-    fn process_obligation(&mut self,\n-                          pending_obligation: &mut Self::Obligation)\n-                          -> ProcessResult<Self::Obligation, Self::Error>\n-    {\n+    fn process_obligation(\n+        &mut self,\n+        pending_obligation: &mut Self::Obligation,\n+    ) -> ProcessResult<Self::Obligation, Self::Error> {\n         // if we were stalled on some unresolved variables, first check\n         // whether any of them have been resolved; if not, don't bother\n         // doing more work yet\n@@ -277,7 +277,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n \n-        debug!(\"process_obligation: obligation = {:?}\", obligation);\n+        debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref data) => {\n@@ -425,10 +425,13 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n-                match ty::wf::obligations(self.selcx.infcx(),\n-                                          obligation.param_env,\n-                                          obligation.cause.body_id,\n-                                          ty, obligation.cause.span) {\n+                match ty::wf::obligations(\n+                    self.selcx.infcx(),\n+                    obligation.param_env,\n+                    obligation.cause.body_id,\n+                    ty,\n+                    obligation.cause.span,\n+                ) {\n                     None => {\n                         pending_obligation.stalled_on = vec![ty];\n                         ProcessResult::Unchanged"}, {"sha": "7ea7bf0257cf7d56344833ef458d638c51dbeea7", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -91,6 +91,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n                                             -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n             .filter(|&def_id| self.predicates_reference_self(def_id, true))\n             .map(|_| ObjectSafetyViolation::SupertraitSelf)\n@@ -106,16 +107,33 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_safety_violations(self, trait_def_id: DefId)\n                                     -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"object_safety_violations: {:?}\", trait_def_id);\n \n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n     }\n \n-    fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation>\n-    {\n+    /// We say a method is *vtable safe* if it can be invoked on a trait\n+    /// object.  Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n+    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n+        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n+        // Any method that has a `Self : Sized` requisite can't be called.\n+        if self.generics_require_sized_self(method.def_id) {\n+            return false;\n+        }\n+\n+        match self.virtual_call_violation_for_method(trait_def_id, method) {\n+            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n+            Some(_) => false,\n+        }\n+    }\n+\n+    fn object_safety_violations_for_trait(self, trait_def_id: DefId) -> Vec<ObjectSafetyViolation> {\n         // Check methods for violations.\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Method)\n@@ -163,14 +181,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn predicates_reference_self(\n         self,\n         trait_def_id: DefId,\n-        supertraits_only: bool) -> bool\n-    {\n+        supertraits_only: bool,\n+    ) -> bool {\n         let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n         let predicates = if supertraits_only {\n             self.super_predicates_of(trait_def_id)\n         } else {\n             self.predicates_of(trait_def_id)\n         };\n+        let self_ty = self.types.self_param;\n+        let has_self_ty = |t: Ty<'tcx>| t.walk().any(|t| t == self_ty);\n         predicates\n             .predicates\n             .iter()\n@@ -179,7 +199,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n+                        data.skip_binder().input_types().skip(1).any(has_self_ty)\n                     }\n                     ty::Predicate::Projection(ref data) => {\n                         // And similarly for projections. This should be redundant with\n@@ -199,7 +219,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .trait_ref(self)\n                             .input_types()\n                             .skip(1)\n-                            .any(|t| t.has_self_ty())\n+                            .any(has_self_ty)\n                     }\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n@@ -229,11 +249,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| match predicate {\n-                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    trait_pred.skip_binder().self_ty().is_self()\n+                ty::Predicate::Trait(ref trait_pred) => {\n+                    trait_pred.def_id() == sized_def_id\n+                        && trait_pred.skip_binder().self_ty().is_param(0)\n                 }\n                 ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n                 ty::Predicate::Subtype(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::WellFormed(..) |\n@@ -248,11 +268,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-    fn object_safety_violation_for_method(self,\n-                                          trait_def_id: DefId,\n-                                          method: &ty::AssocItem)\n-                                          -> Option<MethodViolationCode>\n-    {\n+    fn object_safety_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n         // Any method that has a `Self : Sized` requisite is otherwise\n         // exempt from the regulations.\n@@ -263,36 +283,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.virtual_call_violation_for_method(trait_def_id, method)\n     }\n \n-    /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n-    pub fn is_vtable_safe_method(self,\n-                                 trait_def_id: DefId,\n-                                 method: &ty::AssocItem)\n-                                 -> bool\n-    {\n-        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return false;\n-        }\n-\n-        match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n-            Some(_) => false,\n-        }\n-    }\n-\n     /// Returns `Some(_)` if this method cannot be called on a trait\n     /// object; this does not necessarily imply that the enclosing trait\n     /// is not object safe, because the method might have a where clause\n     /// `Self:Sized`.\n-    fn virtual_call_violation_for_method(self,\n-                                         trait_def_id: DefId,\n-                                         method: &ty::AssocItem)\n-                                         -> Option<MethodViolationCode>\n-    {\n+    fn virtual_call_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         // The method's first parameter must be named `self`\n         if !method.method_has_self_argument {\n             return Some(MethodViolationCode::StaticMethod);\n@@ -323,7 +322,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`\n                 // may apply it's custom visiting.\n-                .visit_tys_shallow(|t| self.contains_illegal_self_type_reference(trait_def_id, t)) {\n+                .visit_tys_shallow(|t| {\n+                    self.contains_illegal_self_type_reference(trait_def_id, t)\n+                }) {\n             let span = self.def_span(method.def_id);\n             return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n         }\n@@ -337,7 +338,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n         // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n-        if receiver_ty != self.mk_self_type() {\n+        if receiver_ty != self.types.self_param {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n@@ -404,7 +405,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n     /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n-        self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n+        self,\n+        receiver_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        method_def_id: DefId,\n     ) -> Ty<'tcx> {\n         debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n         let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n@@ -555,7 +559,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             // Self: Unsize<U>\n             let unsize_predicate = ty::TraitRef {\n                 def_id: unsize_did,\n-                substs: self.mk_substs_trait(self.mk_self_type(), &[unsized_self_ty.into()]),\n+                substs: self.mk_substs_trait(self.types.self_param, &[unsized_self_ty.into()]),\n             }.to_predicate();\n \n             // U: Trait<Arg1, ..., ArgN>\n@@ -608,11 +612,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    fn contains_illegal_self_type_reference(self,\n-                                            trait_def_id: DefId,\n-                                            ty: Ty<'tcx>)\n-                                            -> bool\n-    {\n+    fn contains_illegal_self_type_reference(\n+        self,\n+        trait_def_id: DefId,\n+        ty: Ty<'tcx>,\n+     ) -> bool {\n         // This is somewhat subtle. In general, we want to forbid\n         // references to `Self` in the argument and return types,\n         // since the value of `Self` is erased. However, there is one\n@@ -654,10 +658,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n         let mut error = false;\n+        let self_ty = self.types.self_param;\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n-                ty::Param(ref param_ty) => {\n-                    if param_ty.is_self() {\n+                ty::Param(_) => {\n+                    if ty == self_ty {\n                         error = true;\n                     }\n "}, {"sha": "72df45df92314247f82063c386da1010c980301e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1417,7 +1417,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n                 projection_ty: ty::ProjectionTy::from_ref_and_name(\n                     tcx,\n                     trait_ref,\n-                    Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                    Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 ),\n                 ty: ret_type\n             }"}, {"sha": "1ddc6780aca890dadf3a07c0b77620aa1c663f84", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -27,7 +27,7 @@ pub trait EncodableWithShorthand: Clone + Eq + Hash {\n     fn variant(&self) -> &Self::Variant;\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n@@ -160,7 +160,7 @@ where\n     Ok(decoder.map_encoded_cnum_to_current(cnum))\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n #[inline]\n pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n where"}, {"sha": "e72efdb057ab10f08d3d1a59ea229c28880750d8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -130,7 +130,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n \n     /// Intern a type\n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self,\n         st: TyKind<'tcx>\n@@ -173,6 +173,7 @@ pub struct CommonTypes<'tcx> {\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n+    pub self_param: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n \n     /// Dummy type used for the `Self` of a `TraitRef` created for converting\n@@ -915,6 +916,10 @@ impl<'tcx> CommonTypes<'tcx> {\n             u128: mk(Uint(ast::UintTy::U128)),\n             f32: mk(Float(ast::FloatTy::F32)),\n             f64: mk(Float(ast::FloatTy::F64)),\n+            self_param: mk(ty::Param(ty::ParamTy {\n+                index: 0,\n+                name: kw::SelfUpper.as_interned_str(),\n+            })),\n \n             trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n         }\n@@ -2076,7 +2081,7 @@ impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     }\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n         &self.0.sty\n@@ -2291,7 +2296,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(converted_sig)\n     }\n \n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n     pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n         self.interners.intern_ty(st)\n@@ -2566,10 +2571,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    #[inline]\n-    pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, kw::SelfUpper.as_interned_str())\n-    }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {\n         match param.kind {"}, {"sha": "d6d17a67e01e95ef54529bfdd4eddd790321a612", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -239,13 +239,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n-            ty::Param(ref p) => {\n-                if p.is_self() {\n-                    \"Self\".into()\n-                } else {\n-                    \"type parameter\".into()\n-                }\n-            }\n+            ty::Param(_) => \"type parameter\".into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n             ty::Error => \"type error\".into(),\n         }"}, {"sha": "b2d74f963b0b3db24c494d7505ce3b773ae5edd3", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::subst::{SubstsRef, UnpackedKind};\n-use crate::ty::{self, Ty, TypeFlags, TypeFoldable, InferConst};\n+use crate::ty::{self, Ty, TypeFlags, InferConst};\n use crate::mir::interpret::ConstValue;\n \n #[derive(Debug)]\n@@ -18,7 +18,7 @@ impl FlagComputation {\n         }\n     }\n \n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     pub fn for_sty(st: &ty::TyKind<'_>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_sty(st);\n@@ -62,7 +62,7 @@ impl FlagComputation {\n         } // otherwise, this binder captures nothing\n     }\n \n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     fn add_sty(&mut self, st: &ty::TyKind<'_>) {\n         match st {\n             &ty::Bool |\n@@ -86,13 +86,9 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n-            &ty::Param(ref p) => {\n+            &ty::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                if p.is_self() {\n-                    self.add_flags(TypeFlags::HAS_SELF);\n-                } else {\n-                    self.add_flags(TypeFlags::HAS_PARAMS);\n-                }\n+                self.add_flags(TypeFlags::HAS_PARAMS);\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n@@ -143,11 +139,6 @@ impl FlagComputation {\n             }\n \n             &ty::Projection(ref data) => {\n-                // currently we can't normalize projections that\n-                // include bound regions, so track those separately.\n-                if !data.has_escaping_bound_vars() {\n-                    self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION);\n-                }\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n@@ -243,7 +234,7 @@ impl FlagComputation {\n         match c.val {\n             ConstValue::Unevaluated(_, substs) => {\n                 self.add_substs(substs);\n-                self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n             },\n             ConstValue::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);"}, {"sha": "4b30412b41954e98355d645fa988dfd3dbaacac2", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -85,9 +85,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_param_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PARAMS)\n     }\n-    fn has_self_ty(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_SELF)\n-    }\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }"}, {"sha": "c71e1ea4e585989d763de4195328aab4fadc272a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -298,8 +298,9 @@ impl<'tcx> Instance<'tcx> {\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n-        let is_vtable_shim =\n-            fn_sig.inputs().skip_binder().len() > 0 && fn_sig.input(0).skip_binder().is_self();\n+        let is_vtable_shim = fn_sig.inputs().skip_binder().len() > 0\n+            && fn_sig.input(0).skip_binder().is_param(0)\n+            && tcx.generics_of(def_id).has_self;\n         if is_vtable_shim {\n             debug!(\" => associated item with unsizeable self: Self\");\n             Some(Instance {"}, {"sha": "8febcfd0754c9e2fefef2474da0b0c3a412c89c3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1601,7 +1601,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // resulting from the final codegen session.\n         if\n             layout.ty.has_param_types() ||\n-            layout.ty.has_self_ty() ||\n             !self.param_env.caller_bounds.is_empty()\n         {\n             return;\n@@ -1767,7 +1766,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types() || tail.has_self_ty());\n+                        debug_assert!(tail.has_param_types());\n                         Ok(SizeSkeleton::Pointer {\n                             non_zero,\n                             tail: tcx.erase_regions(&tail)"}, {"sha": "0b81f193df4098c737b51c3ff8c6a5c986662f6d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -414,61 +414,53 @@ pub struct CReaderCacheKey {\n bitflags! {\n     pub struct TypeFlags: u32 {\n         const HAS_PARAMS         = 1 << 0;\n-        const HAS_SELF           = 1 << 1;\n-        const HAS_TY_INFER       = 1 << 2;\n-        const HAS_RE_INFER       = 1 << 3;\n-        const HAS_RE_PLACEHOLDER = 1 << 4;\n+        const HAS_TY_INFER       = 1 << 1;\n+        const HAS_RE_INFER       = 1 << 2;\n+        const HAS_RE_PLACEHOLDER = 1 << 3;\n \n         /// Does this have any `ReEarlyBound` regions? Used to\n         /// determine whether substitition is required, since those\n         /// represent regions that are bound in a `ty::Generics` and\n         /// hence may be substituted.\n-        const HAS_RE_EARLY_BOUND = 1 << 5;\n+        const HAS_RE_EARLY_BOUND = 1 << 4;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS   = 1 << 6;\n+        const HAS_FREE_REGIONS   = 1 << 5;\n \n         /// Is an error type reachable?\n-        const HAS_TY_ERR         = 1 << 7;\n-        const HAS_PROJECTION     = 1 << 8;\n+        const HAS_TY_ERR         = 1 << 6;\n+        const HAS_PROJECTION     = 1 << 7;\n \n         // FIXME: Rename this to the actual property since it's used for generators too\n-        const HAS_TY_CLOSURE     = 1 << 9;\n+        const HAS_TY_CLOSURE     = 1 << 8;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n+        const HAS_FREE_LOCAL_NAMES    = 1 << 9;\n \n         /// Present if the type belongs in a local type context.\n         /// Only set for Infer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX  = 1 << 11;\n-\n-        // Is there a projection that does not involve a bound region?\n-        // Currently we can't normalize projections w/ bound regions.\n-        const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n+        const KEEP_IN_LOCAL_TCX  = 1 << 10;\n \n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND = 1 << 13;\n+        const HAS_RE_LATE_BOUND = 1 << 11;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 14;\n+        const HAS_TY_PLACEHOLDER = 1 << 12;\n \n-        const HAS_CT_INFER = 1 << 15;\n-        const HAS_CT_PLACEHOLDER = 1 << 16;\n+        const HAS_CT_INFER = 1 << 13;\n+        const HAS_CT_PLACEHOLDER = 1 << 14;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n-                                   TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n \n         /// Flags representing the nominal content of a type,\n         /// computed by FlagsComputation. If you add a new nominal\n         /// flag, it should be added here too.\n         const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n-                                  TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n-                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_RE_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_RE_EARLY_BOUND.bits |\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n@@ -479,11 +471,12 @@ bitflags! {\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n                                   TypeFlags::HAS_TY_PLACEHOLDER.bits |\n+                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_CT_PLACEHOLDER.bits;\n     }\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n pub struct TyS<'tcx> {\n     pub sty: TyKind<'tcx>,\n     pub flags: TypeFlags,\n@@ -1734,7 +1727,6 @@ impl<'tcx> ParamEnv<'tcx> {\n                 if value.has_placeholders()\n                     || value.needs_infer()\n                     || value.has_param_types()\n-                    || value.has_self_ty()\n                 {\n                     ParamEnvAnd {\n                         param_env: self,"}, {"sha": "8bf01970eb592f13464fd43efc6a3f8c6e788ee1", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -23,16 +23,16 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnInfo};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-const TAG_NO_EXPANSION_INFO: u8 = 0;\n-const TAG_EXPANSION_INFO_SHORTHAND: u8 = 1;\n-const TAG_EXPANSION_INFO_INLINE: u8 = 2;\n+const TAG_NO_EXPN_DATA: u8 = 0;\n+const TAG_EXPN_DATA_SHORTHAND: u8 = 1;\n+const TAG_EXPN_DATA_INLINE: u8 = 2;\n \n const TAG_VALID_SPAN: u8 = 0;\n const TAG_INVALID_SPAN: u8 = 1;\n@@ -58,7 +58,7 @@ pub struct OnDiskCache<'sess> {\n \n     // These two fields caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n-    synthetic_expansion_infos: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n     // `serialized_data`.\n@@ -135,7 +135,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n         }\n     }\n@@ -151,7 +151,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: Default::default(),\n             prev_diagnostics_index: Default::default(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n         }\n     }\n@@ -185,7 +185,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 encoder,\n                 type_shorthands: Default::default(),\n                 predicate_shorthands: Default::default(),\n-                expn_info_shorthands: Default::default(),\n+                expn_data_shorthands: Default::default(),\n                 interpret_allocs: Default::default(),\n                 interpret_allocs_inverse: Vec::new(),\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n@@ -383,7 +383,7 @@ impl<'sess> OnDiskCache<'sess> {\n             cnum_map: self.cnum_map.get(),\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_expansion_infos: &self.synthetic_expansion_infos,\n+            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n@@ -440,7 +440,7 @@ struct CacheDecoder<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n     cnum_map: &'a IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, StableSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n@@ -586,37 +586,37 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n-        let expn_info_tag = u8::decode(self)?;\n+        let expn_data_tag = u8::decode(self)?;\n \n-        // FIXME(mw): This method does not restore `InternalExpnData::parent` or\n+        // FIXME(mw): This method does not restore `ExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n-        let location = || Span::new(lo, hi, SyntaxContext::empty());\n-        let recover_from_expn_info = |this: &Self, expn_info, pos| {\n-            let span = location().fresh_expansion(ExpnId::root(), expn_info);\n-            this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n+        let location = || Span::with_root_ctxt(lo, hi);\n+        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n+            let span = location().fresh_expansion(expn_data);\n+            this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n-        Ok(match expn_info_tag {\n-            TAG_NO_EXPANSION_INFO => {\n+        Ok(match expn_data_tag {\n+            TAG_NO_EXPN_DATA => {\n                 location()\n             }\n-            TAG_EXPANSION_INFO_INLINE => {\n-                let expn_info = Decodable::decode(self)?;\n-                recover_from_expn_info(\n-                    self, expn_info, AbsoluteBytePos::new(self.opaque.position())\n+            TAG_EXPN_DATA_INLINE => {\n+                let expn_data = Decodable::decode(self)?;\n+                recover_from_expn_data(\n+                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n-            TAG_EXPANSION_INFO_SHORTHAND => {\n+            TAG_EXPN_DATA_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                let cached_ctxt = self.synthetic_expansion_infos.borrow().get(&pos).cloned();\n+                let cached_ctxt = self.synthetic_syntax_contexts.borrow().get(&pos).cloned();\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_info =\n-                        self.with_position(pos.to_usize(), |this| ExpnInfo::decode(this))?;\n-                    recover_from_expn_info(self, expn_info, pos)\n+                    let expn_data =\n+                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, pos)\n                 }\n             }\n             _ => {\n@@ -725,7 +725,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    expn_info_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n+    expn_data_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n@@ -816,22 +816,18 @@ where\n         col_lo.encode(self)?;\n         len.encode(self)?;\n \n-        if span_data.ctxt == SyntaxContext::empty() {\n-            TAG_NO_EXPANSION_INFO.encode(self)\n+        if span_data.ctxt == SyntaxContext::root() {\n+            TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_info) = span_data.ctxt.outer_expn_with_info();\n-            if let Some(expn_info) = expn_info {\n-                if let Some(pos) = self.expn_info_shorthands.get(&expn_id).cloned() {\n-                    TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n-                    pos.encode(self)\n-                } else {\n-                    TAG_EXPANSION_INFO_INLINE.encode(self)?;\n-                    let pos = AbsoluteBytePos::new(self.position());\n-                    self.expn_info_shorthands.insert(expn_id, pos);\n-                    expn_info.encode(self)\n-                }\n+            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n+                TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n+                pos.encode(self)\n             } else {\n-                TAG_NO_EXPANSION_INFO.encode(self)\n+                TAG_EXPN_DATA_INLINE.encode(self)?;\n+                let pos = AbsoluteBytePos::new(self.position());\n+                self.expn_data_shorthands.insert(expn_id, pos);\n+                expn_data.encode(self)\n             }\n         }\n     }"}, {"sha": "2b173068b38e4a610e32c546d502a9c6d3c0a5ad", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,6 +1,6 @@\n //! This module contains `TyKind` and its major components.\n \n-#![cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#![allow(rustc::usage_of_ty_tykind)]\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n@@ -1141,13 +1141,6 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n-\n-    pub fn is_self(&self) -> bool {\n-        // FIXME(#50125): Ignoring `Self` with `index != 0` might lead to weird behavior elsewhere,\n-        // but this should only be possible when using `-Z continue-parse-after-error` like\n-        // `compile-fail/issue-36638.rs`.\n-        self.name.as_symbol() == kw::SelfUpper && self.index == 0\n-    }\n }\n \n #[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable,\n@@ -1789,14 +1782,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_self(&self) -> bool {\n-        match self.sty {\n-            Param(ref p) => p.is_self(),\n-            _ => false,\n-        }\n-    }\n-\n     #[inline]\n     pub fn is_slice(&self) -> bool {\n         match self.sty {\n@@ -2068,6 +2053,9 @@ impl<'tcx> TyS<'tcx> {\n             Error => {  // ignore errors (#54954)\n                 ty::Binder::dummy(FnSig::fake())\n             }\n+            Closure(..) => bug!(\n+                \"to get the signature of a closure, use `closure_sig()` not `fn_sig()`\",\n+            ),\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }"}, {"sha": "b68ee2cb44d4bcb9cf02a5bab742f596bff1cdcf", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -6,9 +6,9 @@ use crate::value::Value;\n \n use rustc::hir;\n use rustc_codegen_ssa::traits::*;\n-\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n+use syntax_pos::Span;\n \n use std::ffi::{CStr, CString};\n use libc::{c_uint, c_char};\n@@ -19,7 +19,8 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self,\n         ia: &hir::InlineAsm,\n         outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n-        mut inputs: Vec<&'ll Value>\n+        mut inputs: Vec<&'ll Value>,\n+        span: Span,\n     ) -> bool {\n         let mut ext_constraints = vec![];\n         let mut output_types = vec![];\n@@ -102,7 +103,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             let kind = llvm::LLVMGetMDKindIDInContext(self.llcx,\n                 key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-            let val: &'ll Value = self.const_i32(ia.ctxt.outer_expn().as_u32() as i32);\n+            let val: &'ll Value = self.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n \n             llvm::LLVMSetMetadata(r, kind,\n                 llvm::LLVMMDNodeInContext(self.llcx, &val, 1));"}, {"sha": "19f18088579b33172594c31e835da33a7443702b", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -333,15 +333,21 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         assert_eq!(alloc.align, layout.align.abi);\n-        let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, alloc.align, None);\n-\n-        let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-            self.const_bitcast(base_addr, self.type_i8p()),\n-            &self.const_usize(offset.bytes()),\n-            1,\n-        )};\n-        let llval = self.const_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n+        let llty = self.type_ptr_to(layout.llvm_type(self));\n+        let llval = if layout.size == Size::ZERO {\n+            let llval = self.const_usize(alloc.align.bytes());\n+            unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n+        } else {\n+            let init = const_alloc_to_llvm(self, alloc);\n+            let base_addr = self.static_addr_of(init, alloc.align, None);\n+\n+            let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                self.const_bitcast(base_addr, self.type_i8p()),\n+                &self.const_usize(offset.bytes()),\n+                1,\n+            )};\n+            self.const_bitcast(llval, llty)\n+        };\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n "}, {"sha": "9483ffca448e3daec91450dee6055194490874a4", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -328,7 +328,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             },\n             \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n             \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n-            \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+            \"mul_with_overflow\" | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n             \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" |\n             \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" | \"exact_div\" |\n             \"rotate_left\" | \"rotate_right\" | \"saturating_add\" | \"saturating_sub\" => {\n@@ -398,9 +398,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n                                 return;\n                             },\n-                            \"overflowing_add\" => self.add(args[0].immediate(), args[1].immediate()),\n-                            \"overflowing_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n-                            \"overflowing_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_add\" => self.add(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n                             \"exact_div\" =>\n                                 if signed {\n                                     self.exactsdiv(args[0].immediate(), args[1].immediate())"}, {"sha": "8603d61fb5453f83cf70e0ba9dc10eb33b358978", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -32,6 +32,7 @@ use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio, ExitStatus};\n use std::str;\n use std::env;\n+use std::ffi::OsString;\n \n pub use rustc_codegen_utils::link::*;\n \n@@ -158,6 +159,36 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n         }\n     };\n \n+    // UWP apps have API restrictions enforced during Store submissions.\n+    // To comply with the Windows App Certification Kit,\n+    // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n+    let t = &sess.target.target;\n+    if flavor == LinkerFlavor::Msvc && t.target_vendor == \"uwp\" {\n+        if let Some(ref tool) = msvc_tool {\n+            let original_path = tool.path();\n+            if let Some(ref root_lib_path) = original_path.ancestors().skip(4).next() {\n+                let arch = match t.arch.as_str() {\n+                    \"x86_64\" => Some(\"x64\".to_string()),\n+                    \"x86\" => Some(\"x86\".to_string()),\n+                    \"aarch64\" => Some(\"arm64\".to_string()),\n+                    _ => None,\n+                };\n+                if let Some(ref a) = arch {\n+                    let mut arg = OsString::from(\"/LIBPATH:\");\n+                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a.to_string()));\n+                    cmd.arg(&arg);\n+                }\n+                else {\n+                    warn!(\"arch is not supported\");\n+                }\n+            } else {\n+                warn!(\"MSVC root path lib location not found\");\n+            }\n+        } else {\n+            warn!(\"link.exe not found\");\n+        }\n+    }\n+\n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n     let mut new_path = sess.host_filesearch(PathKind::All)\n@@ -1027,6 +1058,7 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+\n     for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         cmd.add_object(obj);\n     }"}, {"sha": "eec098426239c4550301a065bc5e3ad0d41aac7b", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1775,10 +1775,7 @@ impl SharedEmitterMain {\n                     }\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    match ExpnId::from_u32(cookie).expn_info() {\n-                        Some(ei) => sess.span_err(ei.call_site, &msg),\n-                        None     => sess.err(&msg),\n-                    }\n+                    sess.span_err(ExpnId::from_u32(cookie).expn_data().call_site, &msg)\n                 }\n                 Ok(SharedEmitterMessage::AbortIfErrors) => {\n                     sess.abort_if_errors();"}, {"sha": "e63f1b91dd7d51d48d38b53ae615232d3487b6df", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -221,7 +221,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(ref c),\n                 ref args, ..\n-            } => match c.ty.sty {\n+            } => match c.literal.ty.sty {\n                 ty::FnDef(did, _) => Some((did, args)),\n                 _ => None,\n             },"}, {"sha": "dbce5ce4896a718f72e6ac17fd630262b807712a", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -651,7 +651,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             let (llval, ty) = self.simd_shuffle_indices(\n                                 &bx,\n                                 constant.span,\n-                                constant.ty,\n+                                constant.literal.ty,\n                                 c,\n                             );\n                             return OperandRef {"}, {"sha": "32bcdebc1c46787f963ac9bd67d3c38a9b912275", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -8,7 +8,7 @@ use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n \n-use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n+use syntax_pos::{DUMMY_SP, BytePos, Span};\n use syntax::symbol::kw;\n \n use std::iter;\n@@ -120,7 +120,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n-        if source_info.span.ctxt() == NO_EXPANSION ||\n+        if !source_info.span.from_expansion() ||\n            self.cx.sess().opts.debugging_opts.debug_macros {\n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n             (scope, source_info.span)"}, {"sha": "254b73da44261bd349b5f639e7c32fec6854c800", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -466,7 +466,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let ty = self.monomorphize(&constant.ty);\n                 self.eval_mir_constant(constant)\n                     .map(|c| OperandRef::from_const(bx, c))\n                     .unwrap_or_else(|err| {\n@@ -481,6 +480,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // the above error (or silence it under some conditions) will not cause UB\n                         bx.abort();\n                         // We've errored, so we don't have to produce working code.\n+                        let ty = self.monomorphize(&constant.literal.ty);\n                         let layout = bx.cx().layout_of(ty);\n                         bx.load_operand(PlaceRef::new_sized(\n                             bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout))),"}, {"sha": "3617f3afaae4148a37224672b6b9374f35e7ec00", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -89,7 +89,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 });\n \n                 if input_vals.len() == asm.inputs.len() {\n-                    let res = bx.codegen_inline_asm(&asm.asm, outputs, input_vals);\n+                    let res = bx.codegen_inline_asm(\n+                        &asm.asm,\n+                        outputs,\n+                        input_vals,\n+                        statement.source_info.span,\n+                    );\n                     if !res {\n                         span_err!(bx.sess(), statement.source_info.span, E0668,\n                                   \"malformed inline assembly\");"}, {"sha": "c9e1ed86e97e0ff37159fc8c746be8bc3e837950", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,6 +1,7 @@\n use super::BackendTypes;\n use crate::mir::place::PlaceRef;\n use rustc::hir::{GlobalAsm, InlineAsm};\n+use syntax_pos::Span;\n \n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n     /// Take an inline assembly expression and splat it out via LLVM\n@@ -9,6 +10,7 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n         ia: &InlineAsm,\n         outputs: Vec<PlaceRef<'tcx, Self::Value>>,\n         inputs: Vec<Self::Value>,\n+        span: Span,\n     ) -> bool;\n }\n "}, {"sha": "89b50c5daccaeac6d1b81184e1fa94c03b50d8a1", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -13,7 +13,7 @@ test = false\n flate2 = \"1.0\"\n log = \"0.4\"\n punycode = \"0.4.0\"\n-rustc-demangle = \"0.1.15\"\n+rustc-demangle = \"0.1.16\"\n \n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "8d6a1d757e014977420ea636bcf74b73b9e2a139", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -198,10 +198,14 @@ impl SymbolMangler<'tcx> {\n \n         let lifetimes = regions.into_iter().map(|br| {\n             match br {\n-                ty::BrAnon(i) => i + 1,\n+                ty::BrAnon(i) => {\n+                    // FIXME(eddyb) for some reason, `anonymize_late_bound_regions` starts at `1`.\n+                    assert_ne!(i, 0);\n+                    i - 1\n+                },\n                 _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n             }\n-        }).max().unwrap_or(0);\n+        }).max().map_or(0, |max| max + 1);\n \n         self.push_opt_integer_62(\"G\", lifetimes as u64);\n         lifetime_depths.end += lifetimes;\n@@ -297,6 +301,10 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             // Late-bound lifetimes use indices starting at 1,\n             // see `BinderLevel` for more details.\n             ty::ReLateBound(debruijn, ty::BrAnon(i)) => {\n+                // FIXME(eddyb) for some reason, `anonymize_late_bound_regions` starts at `1`.\n+                assert_ne!(i, 0);\n+                let i = i - 1;\n+\n                 let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n                 let depth = binder.lifetime_depths.start + i;\n "}, {"sha": "f7593501959c78c4b8e2bd132fe52b58dda8ab25", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -27,7 +27,7 @@\n \n #![cfg_attr(unix, feature(libc))]\n \n-#![cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n+#![allow(rustc::default_hash_types)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "b030517e28ec271587ce4f2d915dfed8c3082866", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -20,6 +20,8 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_plugin = { path = \"../librustc_plugin/deprecated\" } # To get this in the sysroot\n+rustc_plugin_impl = { path = \"../librustc_plugin\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_interface = { path = \"../librustc_interface\" }"}, {"sha": "b19ea513b7575d0ceb369030894e49ce81c8b044", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -22,6 +22,8 @@ extern crate libc;\n #[macro_use]\n extern crate log;\n \n+pub extern crate rustc_plugin_impl as plugin;\n+\n use pretty::{PpMode, UserIdentifiedItem};\n \n //use rustc_resolve as resolve;\n@@ -678,7 +680,7 @@ impl RustcDefaultCalls {\n \n                     let mut cfgs = sess.parse_sess.config.iter().filter_map(|&(name, ref value)| {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            path: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n+                            path: ast::Path::from_ident(ast::Ident::with_dummy_span(name)),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "255af3122e70cb1430cc1ebf0d32c2886876bfa5", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -148,7 +148,7 @@ impl<'a>  DiagnosticConverter<'a> {\n     /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n     fn annotation_type_for_level(level: Level) -> AnnotationType {\n         match level {\n-            Level::Bug | Level::Fatal | Level::PhaseFatal | Level::Error => AnnotationType::Error,\n+            Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n             Level::Warning => AnnotationType::Warning,\n             Level::Note => AnnotationType::Note,\n             Level::Help => AnnotationType::Help,"}, {"sha": "3f1b91256c46811c5d3e7653155395ff80c966ef", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -94,7 +94,6 @@ impl Diagnostic {\n         match self.level {\n             Level::Bug |\n             Level::Fatal |\n-            Level::PhaseFatal |\n             Level::Error |\n             Level::FailureNote => {\n                 true\n@@ -120,6 +119,9 @@ impl Diagnostic {\n     }\n \n     /// Adds a span/label to be included in the resulting snippet.\n+    /// This label will be shown together with the original span/label used when creating the\n+    /// diagnostic, *not* a span added by one of the `span_*` methods.\n+    ///\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n     /// all, and you just supplied a `Span` to create the diagnostic,\n@@ -196,6 +198,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Prints the span with a note above it.\n     pub fn span_note<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n@@ -209,6 +212,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Prints the span with a warn above it.\n     pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n@@ -222,6 +226,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Prints the span with some help above it.\n     pub fn span_help<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)"}, {"sha": "4018a667bf26497ac9e88c4850538dae7558fe03", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -43,8 +43,7 @@ use syntax_pos::{BytePos,\n                  SourceFile,\n                  FileName,\n                  MultiSpan,\n-                 Span,\n-                 NO_EXPANSION};\n+                 Span};\n \n /// Indicates the confidence in the correctness of a suggestion.\n ///\n@@ -189,7 +188,7 @@ impl CodeSuggestion {\n             // Find the bounding span.\n             let lo = substitution.parts.iter().map(|part| part.span.lo()).min().unwrap();\n             let hi = substitution.parts.iter().map(|part| part.span.hi()).min().unwrap();\n-            let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n+            let bounding_span = Span::with_root_ctxt(lo, hi);\n             let lines = cm.span_to_lines(bounding_span).unwrap();\n             assert!(!lines.lines.is_empty());\n \n@@ -787,9 +786,6 @@ impl Handler {\n pub enum Level {\n     Bug,\n     Fatal,\n-    // An error which while not immediately fatal, should stop the compiler\n-    // progressing beyond the current phase.\n-    PhaseFatal,\n     Error,\n     Warning,\n     Note,\n@@ -808,7 +804,7 @@ impl Level {\n     fn color(self) -> ColorSpec {\n         let mut spec = ColorSpec::new();\n         match self {\n-            Bug | Fatal | PhaseFatal | Error => {\n+            Bug | Fatal | Error => {\n                 spec.set_fg(Some(Color::Red))\n                     .set_intense(true);\n             }\n@@ -833,7 +829,7 @@ impl Level {\n     pub fn to_str(self) -> &'static str {\n         match self {\n             Bug => \"error: internal compiler error\",\n-            Fatal | PhaseFatal | Error => \"error\",\n+            Fatal | Error => \"error\",\n             Warning => \"warning\",\n             Note => \"note\",\n             Help => \"help\","}, {"sha": "16b377d5bccea240fcc991c63f182d00add2758e", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -30,7 +30,7 @@ rustc_passes = { path = \"../librustc_passes\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_plugin = { path = \"../librustc_plugin\" }\n+rustc_plugin = { path = \"../librustc_plugin\", package = \"rustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\""}, {"sha": "41b47befaf1412241a088087a166e6f0036f82f3", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 14, "deletions": 164, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -23,9 +23,6 @@ pub enum TokenKind {\n     Lifetime { starts_with_number: bool },\n     Semi,\n     Comma,\n-    DotDotDot,\n-    DotDotEq,\n-    DotDot,\n     Dot,\n     OpenParen,\n     CloseParen,\n@@ -37,41 +34,19 @@ pub enum TokenKind {\n     Pound,\n     Tilde,\n     Question,\n-    ColonColon,\n     Colon,\n     Dollar,\n-    EqEq,\n     Eq,\n-    FatArrow,\n-    Ne,\n     Not,\n-    Le,\n-    LArrow,\n     Lt,\n-    ShlEq,\n-    Shl,\n-    Ge,\n     Gt,\n-    ShrEq,\n-    Shr,\n-    RArrow,\n     Minus,\n-    MinusEq,\n     And,\n-    AndAnd,\n-    AndEq,\n     Or,\n-    OrOr,\n-    OrEq,\n-    PlusEq,\n     Plus,\n-    StarEq,\n     Star,\n-    SlashEq,\n     Slash,\n-    CaretEq,\n     Caret,\n-    PercentEq,\n     Percent,\n     Unknown,\n }\n@@ -135,13 +110,7 @@ impl Cursor<'_> {\n             '/' => match self.nth_char(0) {\n                 '/' => self.line_comment(),\n                 '*' => self.block_comment(),\n-                _ => {\n-                    if self.eat_assign() {\n-                        SlashEq\n-                    } else {\n-                        Slash\n-                    }\n-                }\n+                _ => Slash,\n             },\n             c if character_properties::is_whitespace(c) => self.whitespace(),\n             'r' => match (self.nth_char(0), self.nth_char(1)) {\n@@ -199,22 +168,7 @@ impl Cursor<'_> {\n             }\n             ';' => Semi,\n             ',' => Comma,\n-            '.' => {\n-                if self.nth_char(0) == '.' {\n-                    self.bump();\n-                    if self.nth_char(0) == '.' {\n-                        self.bump();\n-                        DotDotDot\n-                    } else if self.nth_char(0) == '=' {\n-                        self.bump();\n-                        DotDotEq\n-                    } else {\n-                        DotDot\n-                    }\n-                } else {\n-                    Dot\n-                }\n-            }\n+            '.' => Dot,\n             '(' => OpenParen,\n             ')' => CloseParen,\n             '{' => OpenBrace,\n@@ -225,112 +179,19 @@ impl Cursor<'_> {\n             '#' => Pound,\n             '~' => Tilde,\n             '?' => Question,\n-            ':' => {\n-                if self.nth_char(0) == ':' {\n-                    self.bump();\n-                    ColonColon\n-                } else {\n-                    Colon\n-                }\n-            }\n+            ':' => Colon,\n             '$' => Dollar,\n-            '=' => {\n-                if self.nth_char(0) == '=' {\n-                    self.bump();\n-                    EqEq\n-                } else if self.nth_char(0) == '>' {\n-                    self.bump();\n-                    FatArrow\n-                } else {\n-                    Eq\n-                }\n-            }\n-            '!' => {\n-                if self.nth_char(0) == '=' {\n-                    self.bump();\n-                    Ne\n-                } else {\n-                    Not\n-                }\n-            }\n-            '<' => match self.nth_char(0) {\n-                '=' => {\n-                    self.bump();\n-                    Le\n-                }\n-                '<' => {\n-                    self.bump();\n-                    if self.eat_assign() { ShlEq } else { Shl }\n-                }\n-                '-' => {\n-                    self.bump();\n-                    LArrow\n-                }\n-                _ => Lt,\n-            },\n-            '>' => match self.nth_char(0) {\n-                '=' => {\n-                    self.bump();\n-                    Ge\n-                }\n-                '>' => {\n-                    self.bump();\n-                    if self.eat_assign() { ShrEq } else { Shr }\n-                }\n-                _ => Gt,\n-            },\n-            '-' => {\n-                if self.nth_char(0) == '>' {\n-                    self.bump();\n-                    RArrow\n-                } else {\n-                    if self.eat_assign() { MinusEq } else { Minus }\n-                }\n-            }\n-            '&' => {\n-                if self.nth_char(0) == '&' {\n-                    self.bump();\n-                    AndAnd\n-                } else {\n-                    if self.eat_assign() { AndEq } else { And }\n-                }\n-            }\n-            '|' => {\n-                if self.nth_char(0) == '|' {\n-                    self.bump();\n-                    OrOr\n-                } else {\n-                    if self.eat_assign() { OrEq } else { Or }\n-                }\n-            }\n-            '+' => {\n-                if self.eat_assign() {\n-                    PlusEq\n-                } else {\n-                    Plus\n-                }\n-            }\n-            '*' => {\n-                if self.eat_assign() {\n-                    StarEq\n-                } else {\n-                    Star\n-                }\n-            }\n-            '^' => {\n-                if self.eat_assign() {\n-                    CaretEq\n-                } else {\n-                    Caret\n-                }\n-            }\n-            '%' => {\n-                if self.eat_assign() {\n-                    PercentEq\n-                } else {\n-                    Percent\n-                }\n-            }\n+            '=' => Eq,\n+            '!' => Not,\n+            '<' => Lt,\n+            '>' => Gt,\n+            '-' => Minus,\n+            '&' => And,\n+            '|' => Or,\n+            '+' => Plus,\n+            '*' => Star,\n+            '^' => Caret,\n+            '%' => Percent,\n             '\\'' => self.lifetime_or_char(),\n             '\"' => {\n                 let terminated = self.double_quoted_string();\n@@ -352,7 +213,6 @@ impl Cursor<'_> {\n         loop {\n             match self.nth_char(0) {\n                 '\\n' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 _ => {\n                     self.bump();\n@@ -525,7 +385,6 @@ impl Cursor<'_> {\n             match self.nth_char(0) {\n                 '/' if !first => break,\n                 '\\n' if self.nth_char(1) != '\\'' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 '\\'' => {\n                     self.bump();\n@@ -645,15 +504,6 @@ impl Cursor<'_> {\n             self.bump();\n         }\n     }\n-\n-    fn eat_assign(&mut self) -> bool {\n-        if self.nth_char(0) == '=' {\n-            self.bump();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n }\n \n pub mod character_properties {"}, {"sha": "c709b7526082f6a3c18ba057cbed48a0bb4a0e11", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -128,11 +128,7 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     if first_char != '\\\\' {\n         return match first_char {\n             '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n-                EscapeError::EscapeOnlyChar\n-            } else {\n-                EscapeError::BareCarriageReturn\n-            }),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n             '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n             '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n             _ => {\n@@ -244,27 +240,15 @@ where\n \n         let unescaped_char = match first_char {\n             '\\\\' => {\n-                let (second_char, third_char) = {\n-                    let mut chars = chars.clone();\n-                    (chars.next(), chars.next())\n-                };\n-                match (second_char, third_char) {\n-                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n+                let second_char = chars.clone().next();\n+                match second_char {\n+                    Some('\\n') => {\n                         skip_ascii_whitespace(&mut chars);\n                         continue;\n                     }\n                     _ => scan_escape(first_char, &mut chars, mode),\n                 }\n             }\n-            '\\r' => {\n-                let second_char = chars.clone().next();\n-                if second_char == Some('\\n') {\n-                    chars.next();\n-                    Ok('\\n')\n-                } else {\n-                    scan_escape(first_char, &mut chars, mode)\n-                }\n-            }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             _ => scan_escape(first_char, &mut chars, mode),\n@@ -298,15 +282,11 @@ where\n     while let Some(curr) = chars.next() {\n         let start = initial_len - chars.as_str().len() - curr.len_utf8();\n \n-        let result = match (curr, chars.clone().next()) {\n-            ('\\r', Some('\\n')) => {\n-                chars.next();\n-                Ok('\\n')\n-            },\n-            ('\\r', _) => Err(EscapeError::BareCarriageReturnInRawString),\n-            (c, _) if mode.is_bytes() && !c.is_ascii() =>\n+        let result = match curr {\n+            '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n+            c if mode.is_bytes() && !c.is_ascii() =>\n                 Err(EscapeError::NonAsciiCharInByteString),\n-            (c, _) => Ok(c),\n+            c => Ok(c),\n         };\n         let end = initial_len - chars.as_str().len();\n "}, {"sha": "e7b1ff6479d88dc4f60888bbd8ccf62fe5e9ff94", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -11,7 +11,6 @@ fn test_unescape_char_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -31,6 +30,7 @@ fn test_unescape_char_bad() {\n     check(r\"\\v\", EscapeError::InvalidEscape);\n     check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n     check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+    check(\"\\\\\\r\", EscapeError::InvalidEscape);\n \n     check(r\"\\x\", EscapeError::TooShortHexEscape);\n     check(r\"\\x0\", EscapeError::TooShortHexEscape);\n@@ -116,10 +116,9 @@ fn test_unescape_str_good() {\n \n     check(\"foo\", \"foo\");\n     check(\"\", \"\");\n-    check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+    check(\" \\t\\n\", \" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", \"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", \"hello world\");\n     check(\"thread's\", \"thread's\")\n }\n \n@@ -134,7 +133,6 @@ fn test_unescape_byte_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -238,10 +236,9 @@ fn test_unescape_byte_str_good() {\n \n     check(\"foo\", b\"foo\");\n     check(\"\", b\"\");\n-    check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+    check(\" \\t\\n\", b\" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", b\"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n     check(\"thread's\", b\"thread's\")\n }\n \n@@ -253,7 +250,6 @@ fn test_unescape_raw_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n }\n@@ -266,7 +262,6 @@ fn test_unescape_raw_byte_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n     check("}, {"sha": "ce7681c974a5dcf73d1bd6bdcda0a75f8ba2e46d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 121, "deletions": 53, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -42,7 +42,7 @@ use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n use syntax::feature_gate::{self, AttributeGate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n-use syntax_pos::{BytePos, Span, SyntaxContext};\n+use syntax_pos::{BytePos, Span};\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n@@ -78,7 +78,7 @@ impl EarlyLintPass for WhileTrue {\n         if let ast::ExprKind::While(cond, ..) = &e.node {\n             if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n-                    if lit.span.ctxt() == SyntaxContext::empty() {\n+                    if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.sess.source_map().def_span(e.span);\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, msg)\n@@ -164,18 +164,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                                    .expect(\"struct pattern type is not an ADT\")\n                                    .variant_of_res(cx.tables.qpath_res(qpath, pat.hir_id));\n             for fieldpat in field_pats {\n-                if fieldpat.node.is_shorthand {\n+                if fieldpat.is_shorthand {\n                     continue;\n                 }\n-                if fieldpat.span.ctxt().outer_expn_info().is_some() {\n+                if fieldpat.span.from_expansion() {\n                     // Don't lint if this is a macro expansion: macro authors\n                     // shouldn't have to worry about this kind of style issue\n                     // (Issue #49588)\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.pat.node {\n                     if cx.tcx.find_field_index(ident, &variant) ==\n-                       Some(cx.tcx.field_index(fieldpat.node.hir_id, cx.tables)) {\n+                       Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));\n@@ -484,8 +484,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n-                                      Some(v.node.id),\n-                                      &v.node.attrs,\n+                                      Some(v.id),\n+                                      &v.attrs,\n                                       v.span,\n                                       \"a variant\");\n     }\n@@ -1012,7 +1012,7 @@ impl UnreachablePub {\n         let mut applicability = Applicability::MachineApplicable;\n         match vis.node {\n             hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n-                if span.ctxt().outer_expn_info().is_some() {\n+                if span.from_expansion() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n                 let def_span = cx.tcx.sess.source_map().def_span(span);\n@@ -1493,7 +1493,7 @@ impl EarlyLintPass for KeywordIdents {\n         self.check_tokens(cx, mac_def.stream());\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n-        self.check_tokens(cx, mac.node.tts.clone().into());\n+        self.check_tokens(cx, mac.tts.clone().into());\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);\n@@ -1876,25 +1876,101 @@ declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n \n-        const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n-        const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+        #[derive(Debug, Copy, Clone, PartialEq)]\n+        enum InitKind { Zeroed, Uninit };\n \n         /// Information about why a type cannot be initialized this way.\n         /// Contains an error message and optionally a span to point at.\n         type InitError = (String, Option<Span>);\n \n+        /// Test if this constant is all-0.\n+        fn is_zero(expr: &hir::Expr) -> bool {\n+            use hir::ExprKind::*;\n+            use syntax::ast::LitKind::*;\n+            match &expr.node {\n+                Lit(lit) =>\n+                    if let Int(i, _) = lit.node {\n+                        i == 0\n+                    } else {\n+                        false\n+                    },\n+                Tup(tup) =>\n+                    tup.iter().all(is_zero),\n+                _ =>\n+                    false\n+            }\n+        }\n+\n+        /// Determine if this expression is a \"dangerous initialization\".\n+        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n+            const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n+            const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+            // `transmute` is inside an anonymous module (the `extern` block?);\n+            // `Invalid` represents the empty string and matches that.\n+            const TRANSMUTE_PATH: &[Symbol] =\n+                &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n+\n+            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.node {\n+                if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+                    let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+\n+                    if cx.match_def_path(def_id, ZEROED_PATH) {\n+                        return Some(InitKind::Zeroed);\n+                    }\n+                    if cx.match_def_path(def_id, UININIT_PATH) {\n+                        return Some(InitKind::Uninit);\n+                    }\n+                    if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n+                        if is_zero(&args[0]) {\n+                            return Some(InitKind::Zeroed);\n+                        }\n+                    }\n+                    // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n+                    // `MaybeUninit::uninit().assume_init()`.\n+                }\n+            }\n+\n+            None\n+        }\n+\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n-        fn ty_find_init_error<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<InitError> {\n+        fn ty_find_init_error<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            ty: Ty<'tcx>,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n             use rustc::ty::TyKind::*;\n             match ty.sty {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((format!(\"References must be non-null\"), None)),\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n                 FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n                 Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n-                // Recurse for some compound types.\n+                // Primitive types with other constraints.\n+                Bool if init == InitKind::Uninit =>\n+                    Some((format!(\"Booleans must be `true` or `false`\"), None)),\n+                Char if init == InitKind::Uninit =>\n+                    Some((format!(\"Characters must be a valid unicode codepoint\"), None)),\n+                // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n+                    // First check f this ADT has a layout attribute (like `NonNull` and friends).\n+                    use std::ops::Bound;\n+                    match tcx.layout_scalar_valid_range(adt_def.did) {\n+                        // We exploit here that `layout_scalar_valid_range` will never\n+                        // return `Bound::Excluded`.  (And we have tests checking that we\n+                        // handle the attribute correctly.)\n+                        (Bound::Included(lo), _) if lo > 0 =>\n+                            return Some((format!(\"{} must be non-null\", ty), None)),\n+                        (Bound::Included(_), _) | (_, Bound::Included(_))\n+                        if init == InitKind::Uninit =>\n+                            return Some((\n+                                format!(\"{} must be initialized inside its custom valid range\", ty),\n+                                None,\n+                            )),\n+                        _ => {}\n+                    }\n+                    // Now, recurse.\n                     match adt_def.variants.len() {\n                         0 => Some((format!(\"0-variant enums have no valid value\"), None)),\n                         1 => {\n@@ -1905,6 +1981,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 ty_find_init_error(\n                                     tcx,\n                                     field.ty(tcx, substs),\n+                                    init,\n                                 ).map(|(mut msg, span)| if span.is_none() {\n                                     // Point to this field, should be helpful for figuring\n                                     // out where the source of the error is.\n@@ -1918,57 +1995,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 })\n                             })\n                         }\n+                        // Multi-variant enums are tricky: if all but one variant are\n+                        // uninhabited, we might actually do layout like for a single-variant\n+                        // enum, and then even leaving them uninitialized could be okay.\n                         _ => None, // Conservative fallback for multi-variant enum.\n                     }\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field))\n+                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field, init))\n                 }\n-                // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n-                // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n-                //        `char`, and any multivariant enum.\n                 // Conservative fallback.\n                 _ => None,\n             }\n         }\n \n-        if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n-            if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if cx.match_def_path(def_id, &ZEROED_PATH) ||\n-                        cx.match_def_path(def_id, &UININIT_PATH)\n-                    {\n-                        // This conjures an instance of a type out of nothing,\n-                        // using zeroed or uninitialized memory.\n-                        // We are extremely conservative with what we warn about.\n-                        let conjured_ty = cx.tables.expr_ty(expr);\n-                        if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n-                            let mut err = cx.struct_span_lint(\n-                                INVALID_VALUE,\n-                                expr.span,\n-                                &format!(\n-                                    \"the type `{}` does not permit {}\",\n-                                    conjured_ty,\n-                                    if cx.match_def_path(def_id, &ZEROED_PATH) {\n-                                        \"zero-initialization\"\n-                                    } else {\n-                                        \"being left uninitialized\"\n-                                    }\n-                                ),\n-                            );\n-                            err.span_label(expr.span,\n-                                \"this code causes undefined behavior when executed\");\n-                            err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n-                            if let Some(span) = span {\n-                                err.span_note(span, &msg);\n-                            } else {\n-                                err.note(&msg);\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n+        if let Some(init) = is_dangerous_init(cx, expr) {\n+            // This conjures an instance of a type out of nothing,\n+            // using zeroed or uninitialized memory.\n+            // We are extremely conservative with what we warn about.\n+            let conjured_ty = cx.tables.expr_ty(expr);\n+            if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n+                let mut err = cx.struct_span_lint(\n+                    INVALID_VALUE,\n+                    expr.span,\n+                    &format!(\n+                        \"the type `{}` does not permit {}\",\n+                        conjured_ty,\n+                        match init {\n+                            InitKind::Zeroed => \"zero-initialization\",\n+                            InitKind::Uninit => \"being left uninitialized\",\n+                        },\n+                    ),\n+                );\n+                err.span_label(expr.span,\n+                    \"this code causes undefined behavior when executed\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                if let Some(span) = span {\n+                    err.span_note(span, &msg);\n+                } else {\n+                    err.note(&msg);\n                 }\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "27833161ef23d7b6cf4020828ac08f41042b94e8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -3,7 +3,7 @@\n //! This currently only contains the definitions and implementations\n //! of most of the lints that `rustc` supports directly, it does not\n //! contain the infrastructure for defining/registering lints. That is\n-//! available in `rustc::lint` and `rustc_plugin` respectively.\n+//! available in `rustc::lint` and `rustc_driver::plugin` respectively.\n //!\n //! ## Note\n //!\n@@ -24,6 +24,7 @@ extern crate rustc;\n \n mod error_codes;\n mod nonstandard_style;\n+mod redundant_semicolon;\n pub mod builtin;\n mod types;\n mod unused;\n@@ -55,6 +56,7 @@ use session::Session;\n use lint::LintId;\n use lint::FutureIncompatibleInfo;\n \n+use redundant_semicolon::*;\n use nonstandard_style::*;\n use builtin::*;\n use types::*;\n@@ -98,6 +100,7 @@ macro_rules! early_lint_passes {\n             WhileTrue: WhileTrue,\n             NonAsciiIdents: NonAsciiIdents,\n             IncompleteFeatures: IncompleteFeatures,\n+            RedundantSemicolon: RedundantSemicolon,\n         ]);\n     )\n }"}, {"sha": "acd17f766323419cfe0c8efe6c514d91d62138df", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -147,7 +147,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n     }\n \n     fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_case(cx, \"variant\", &v.node.ident);\n+        self.check_case(cx, \"variant\", &v.ident);\n     }\n \n     fn check_generic_param(&mut self, cx: &EarlyContext<'_>, param: &ast::GenericParam) {"}, {"sha": "7c9df3578b59cd22a168821e94261d6eb8003bb1", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,52 @@\n+use crate::lint::{EarlyLintPass, LintPass, EarlyContext, LintArray, LintContext};\n+use syntax::ast::{Stmt, StmtKind, ExprKind};\n+use syntax::errors::Applicability;\n+\n+declare_lint! {\n+    pub REDUNDANT_SEMICOLON,\n+    Warn,\n+    \"detects unnecessary trailing semicolons\"\n+}\n+\n+declare_lint_pass!(RedundantSemicolon => [REDUNDANT_SEMICOLON]);\n+\n+impl EarlyLintPass for RedundantSemicolon {\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n+        if let StmtKind::Semi(expr) = &stmt.node {\n+            if let ExprKind::Tup(ref v) = &expr.node {\n+                if v.is_empty() {\n+                    // Strings of excess semicolons are encoded as empty tuple expressions\n+                    // during the parsing stage, so we check for empty tuple expressions\n+                    // which span only semicolons\n+                    if let Ok(source_str) = cx.sess().source_map().span_to_snippet(stmt.span) {\n+                        if source_str.chars().all(|c| c == ';') {\n+                            let multiple = (stmt.span.hi() - stmt.span.lo()).0 > 1;\n+                            let msg = if multiple {\n+                                \"unnecessary trailing semicolons\"\n+                            } else {\n+                                \"unnecessary trailing semicolon\"\n+                            };\n+                            let mut err = cx.struct_span_lint(\n+                                REDUNDANT_SEMICOLON,\n+                                stmt.span,\n+                                &msg\n+                            );\n+                            let suggest_msg = if multiple {\n+                                \"remove these semicolons\"\n+                            } else {\n+                                \"remove this semicolon\"\n+                            };\n+                            err.span_suggestion(\n+                                stmt.span,\n+                                &suggest_msg,\n+                                String::new(),\n+                                Applicability::MaybeIncorrect\n+                            );\n+                            err.emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "217e10ab24f552696be203b2c7a45789cdd341e2", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -976,7 +976,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\",\n-                           variant.node.ident,\n+                           variant.ident,\n                            bytes);\n                     bytes\n                 })"}, {"sha": "90e467713968bd07fdfc31f47ec2239453deebaa", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -517,9 +517,8 @@ impl EarlyLintPass for UnusedParens {\n                 // trigger in situations that macro authors shouldn't have to care about, e.g.,\n                 // when a parenthesized token tree matched in one macro expansion is matched as\n                 // an expression in another and used as a fn/method argument (Issue #47775)\n-                if e.span.ctxt().outer_expn_info()\n-                    .map_or(false, |info| info.call_site.ctxt().outer_expn_info().is_some()) {\n-                        return;\n+                if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n+                    return;\n                 }\n                 let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {"}, {"sha": "40ddd6516429068d293ada9328b3ca24b76f5a83", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -151,6 +151,10 @@ fn main() {\n         cfg.define(\"LLVM_RUSTLLVM\", None);\n     }\n \n+    if env::var_os(\"LLVM_NDEBUG\").is_some() {\n+        cfg.define(\"NDEBUG\", None);\n+    }\n+\n     build_helper::rerun_if_changed_anything_in_dir(Path::new(\"../rustllvm\"));\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n@@ -250,8 +254,11 @@ fn main() {\n     let llvm_use_libcxx = env::var_os(\"LLVM_USE_LIBCXX\");\n \n     let stdcppname = if target.contains(\"openbsd\") {\n-        // llvm-config on OpenBSD doesn't mention stdlib=libc++\n-        \"c++\"\n+        if target.contains(\"sparc64\") {\n+            \"estdc++\"\n+        } else {\n+            \"c++\"\n+        }\n     } else if target.contains(\"freebsd\") {\n         \"c++\"\n     } else if target.contains(\"darwin\") {"}, {"sha": "3d3a020ef0c8e71b60ea893c07bcf0819e09af6d", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,5 @@\n #![feature(proc_macro_hygiene)]\n-#![cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n+#![allow(rustc::default_hash_types)]\n \n #![recursion_limit=\"128\"]\n "}, {"sha": "af41b6a4c857f092101cac0c8286eaeda6e7e136", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 64, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -2,8 +2,7 @@\n \n use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::decoder::proc_macro_def_path_table;\n-use crate::schema::CrateRoot;\n+use crate::schema::{CrateRoot};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n@@ -26,11 +25,11 @@ use std::{cmp, fs};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n@@ -230,24 +229,13 @@ impl<'a> CrateLoader<'a> {\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n-        let proc_macros = crate_root.proc_macro_decls_static.map(|_| {\n+        let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n             if self.sess.opts.debugging_opts.dual_proc_macros {\n-                let host_lib = host_lib.unwrap();\n-                self.load_derive_macros(\n-                    &host_lib.metadata.get_root(),\n-                    host_lib.dylib.map(|p| p.0),\n-                    span\n-                )\n+                let host_lib = host_lib.as_ref().unwrap();\n+                self.dlsym_proc_macros(host_lib.dylib.as_ref().map(|p| p.0.clone()),\n+                                       &host_lib.metadata.get_root(), span)\n             } else {\n-                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n-            }\n-        });\n-\n-        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            if let Some(proc_macros) = &proc_macros {\n-                proc_macro_def_path_table(&crate_root, proc_macros)\n-            } else {\n-                crate_root.def_path_table.decode((&metadata, self.sess))\n+                self.dlsym_proc_macros(dylib.clone().map(|p| p.0), &crate_root, span)\n             }\n         });\n \n@@ -260,13 +248,16 @@ impl<'a> CrateLoader<'a> {\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n \n+        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n+            crate_root.def_path_table.decode((&metadata, self.sess))\n+        });\n+\n         let cmeta = cstore::CrateMetadata {\n             name: crate_root.name,\n             imported_name: ident,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,\n-            proc_macros,\n             root: crate_root,\n             blob: metadata,\n             cnum_map,\n@@ -280,7 +271,10 @@ impl<'a> CrateLoader<'a> {\n                 rlib,\n                 rmeta,\n             },\n-            private_dep\n+            private_dep,\n+            span,\n+            host_lib,\n+            raw_proc_macros\n         };\n \n         let cmeta = Lrc::new(cmeta);\n@@ -389,7 +383,7 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.proc_macro_decls_static.is_some() {\n+                if data.root.proc_macro_data.is_some() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n                 data.dep_kind.with_lock(|data_dep_kind| {\n@@ -482,7 +476,7 @@ impl<'a> CrateLoader<'a> {\n                           dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n-        if crate_root.proc_macro_decls_static.is_some() {\n+        if crate_root.proc_macro_data.is_some() {\n             return cstore::CrateNumMap::new();\n         }\n \n@@ -574,19 +568,13 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    /// Loads custom derive macros.\n-    ///\n-    /// Note that this is intentionally similar to how we load plugins today,\n-    /// but also intentionally separate. Plugins are likely always going to be\n-    /// implemented as dynamic libraries, but we have a possible future where\n-    /// custom derive (and other macro-1.1 style features) are implemented via\n-    /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, root: &CrateRoot<'_>, dylib: Option<PathBuf>, span: Span)\n-                          -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n-        use std::{env, mem};\n+    fn dlsym_proc_macros(&self,\n+                         dylib: Option<PathBuf>,\n+                         root: &CrateRoot<'_>,\n+                         span: Span\n+    ) -> &'static [ProcMacro] {\n+        use std::env;\n         use crate::dynamic_lib::DynamicLibrary;\n-        use proc_macro::bridge::client::ProcMacro;\n-        use syntax::ext::proc_macro::{BangProcMacro, AttrProcMacro, ProcMacroDerive};\n \n         let path = match dylib {\n             Some(dylib) => dylib,\n@@ -608,38 +596,11 @@ impl<'a> CrateLoader<'a> {\n             *(sym as *const &[ProcMacro])\n         };\n \n-        let extensions = decls.iter().map(|&decl| {\n-            let (name, kind, helper_attrs) = match decl {\n-                ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let helper_attrs =\n-                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (\n-                        trait_name,\n-                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                            client, attrs: helper_attrs.clone()\n-                        })),\n-                        helper_attrs,\n-                    )\n-                }\n-                ProcMacro::Attr { name, client } => (\n-                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n-                ),\n-                ProcMacro::Bang { name, client } => (\n-                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n-                )\n-            };\n-\n-            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            }))\n-        }).collect();\n-\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n-        mem::forget(lib);\n+        std::mem::forget(lib);\n \n-        extensions\n+        decls\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate"}, {"sha": "efc77699313e054ba278dd70eaa0f45a8157b2ee", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -28,6 +28,9 @@ pub use crate::cstore_impl::{provide, provide_extern};\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub use rustc_data_structures::sync::MetadataRef;\n+use crate::creader::Library;\n+use syntax_pos::Span;\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct MetadataBlob(pub MetadataRef);\n \n@@ -65,28 +68,36 @@ pub struct CrateMetadata {\n     pub alloc_decoding_state: AllocDecodingState,\n \n     // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    // lifetime is only used behind `Lazy` / `LazySeq`, and therefore\n-    // acts like an universal (`for<'tcx>`), that is paired up with\n-    // whichever `TyCtxt` is being used to decode those values.\n+    // lifetime is only used behind `Lazy`, and therefore acts like an\n+    // universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    // is being used to decode those values.\n     pub root: schema::CrateRoot<'static>,\n \n-    /// For each public item in this crate, we encode a key. When the\n+    /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n     pub def_path_table: Lrc<DefPathTable>,\n \n-    pub trait_impls: FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>,\n+    pub trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n \n     pub dep_kind: Lock<DepKind>,\n     pub source: CrateSource,\n \n-    pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n-\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n-    pub private_dep: bool\n+    pub private_dep: bool,\n+\n+    pub host_lib: Option<Library>,\n+    pub span: Span,\n+\n+    pub raw_proc_macros: Option<&'static [ProcMacro]>,\n+}\n+\n+pub struct FullProcMacro {\n+    pub name: ast::Name,\n+    pub ext: Lrc<SyntaxExtension>\n }\n \n pub struct CStore {"}, {"sha": "a66da32fa4d7560ef79d4931cb35438ae8c077dd", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -35,7 +35,7 @@ use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n-use syntax_pos::{Span, NO_EXPANSION, FileName};\n+use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n macro_rules! provide {\n@@ -426,8 +426,8 @@ impl cstore::CStore {\n \n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n-        if let Some(ref proc_macros) = data.proc_macros {\n-            return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n+        if data.is_proc_macro_crate() {\n+            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n             let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n@@ -439,11 +439,12 @@ impl cstore::CStore {\n         }\n \n         let def = data.get_macro(id.index);\n-        let macro_full_name = data.def_path(id.index).to_string_friendly(|_| data.imported_name);\n+        let macro_full_name = data.def_path(id.index)\n+            .to_string_friendly(|_| data.imported_name);\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n-        let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);\n+        let local_span = Span::with_root_ctxt(source_file.start_pos, source_file.end_pos);\n         let (body, mut errors) = source_file_to_stream(&sess.parse_sess, source_file, None);\n         emit_unclosed_delims(&mut errors, &sess.diagnostic());\n "}, {"sha": "da96728d2dec9c316a671b76805024dfc8a7d7b2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 144, "deletions": 91, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,16 +1,15 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n use crate::schema::*;\n \n use rustc_data_structures::sync::{Lrc, ReadGuard};\n-use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n+use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n@@ -30,10 +29,11 @@ use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n-use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n+use syntax::ext::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, symbol::{InternedString}};\n use log::debug;\n+use proc_macro::bridge::client::ProcMacro;\n+use syntax::ext::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n \n pub struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n@@ -134,14 +134,14 @@ impl<'a, 'tcx, T: Decodable> Lazy<T> {\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> LazySeq<T> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n-    ) -> impl Iterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n+    ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n+        (0..self.meta).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n }\n \n@@ -154,18 +154,22 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n-    fn read_lazy_distance(&mut self, min_size: usize) -> Result<usize, <Self as Decoder>::Error> {\n+    fn read_lazy_with_meta<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        meta: T::Meta,\n+    ) -> Result<Lazy<T>, <Self as Decoder>::Error> {\n+        let min_size = T::min_size(meta);\n         let distance = self.read_usize()?;\n         let position = match self.lazy_state {\n-            LazyState::NoNode => bug!(\"read_lazy_distance: outside of a metadata node\"),\n+            LazyState::NoNode => bug!(\"read_lazy_with_meta: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n                 assert!(distance + min_size <= start);\n                 start - distance - min_size\n             }\n             LazyState::Previous(last_min_end) => last_min_end + distance,\n         };\n         self.lazy_state = LazyState::Previous(position + min_size);\n-        Ok(position)\n+        Ok(Lazy::from_position_and_meta(position, meta))\n     }\n }\n \n@@ -230,19 +234,18 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n-        Ok(Lazy::with_position(self.read_lazy_distance(Lazy::<T>::min_size())?))\n+        self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<LazySeq<T>, Self::Error> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n-        let position = if len == 0 {\n-            0\n+        if len == 0 {\n+            Ok(Lazy::empty())\n         } else {\n-            self.read_lazy_distance(LazySeq::<T>::min_size(len))?\n-        };\n-        Ok(LazySeq::with_position_and_length(position, len))\n+            self.read_lazy_with_meta(len)\n+        }\n     }\n }\n \n@@ -344,7 +347,15 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let hi = (hi + source_file.translated_source_file.start_pos)\n                  - source_file.original_start_pos;\n \n-        Ok(Span::new(lo, hi, NO_EXPANSION))\n+        Ok(Span::with_root_ctxt(lo, hi))\n+    }\n+}\n+\n+impl SpecializedDecoder<Ident> for DecodeContext<'_, '_> {\n+    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n+        // FIXME(jseyfried): intercrate hygiene\n+\n+        Ok(Ident::with_dummy_span(Symbol::decode(self)?))\n     }\n }\n \n@@ -370,7 +381,7 @@ impl<'tcx> MetadataBlob {\n     }\n \n     pub fn get_rustc_version(&self) -> String {\n-        Lazy::with_position(METADATA_HEADER.len() + 4).decode(self)\n+        Lazy::<String>::from_position(METADATA_HEADER.len() + 4).decode(self)\n     }\n \n     pub fn get_root(&self) -> CrateRoot<'tcx> {\n@@ -379,7 +390,7 @@ impl<'tcx> MetadataBlob {\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n                    ((slice[offset + 2] as u32) << 8) |\n                    ((slice[offset + 3] as u32) << 0)) as usize;\n-        Lazy::with_position(pos).decode(self)\n+        Lazy::<CrateRoot<'tcx>>::from_position(pos).decode(self)\n     }\n \n     pub fn list_crate_metadata(&self,\n@@ -434,46 +445,16 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n-/// Creates the \"fake\" DefPathTable for a given proc macro crate.\n-///\n-/// The DefPathTable is as follows:\n-///\n-/// CRATE_ROOT (DefIndex 0:0)\n-///  |- GlobalMetaDataKind data (DefIndex 1:0 .. DefIndex 1:N)\n-///  |- proc macro #0 (DefIndex 1:N)\n-///  |- proc macro #1 (DefIndex 1:N+1)\n-///  \\- ...\n-crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n-                                   proc_macros: &[(ast::Name, Lrc<SyntaxExtension>)])\n-                                   -> DefPathTable\n-{\n-    let mut definitions = Definitions::default();\n-\n-    let name = crate_root.name.as_str();\n-    let disambiguator = crate_root.disambiguator;\n-    debug!(\"creating proc macro def path table for {:?}/{:?}\", name, disambiguator);\n-    let crate_root = definitions.create_root_def(&name, disambiguator);\n-    for (index, (name, _)) in proc_macros.iter().enumerate() {\n-        let def_index = definitions.create_def_with_parent(\n-            crate_root,\n-            ast::DUMMY_NODE_ID,\n-            DefPathData::MacroNs(name.as_interned_str()),\n-            ExpnId::root(),\n-            DUMMY_SP);\n-        debug!(\"definition for {:?} is {:?}\", name, def_index);\n-        assert_eq!(def_index, DefIndex::from_proc_macro_index(index));\n-    }\n-\n-    definitions.def_path_table().clone()\n-}\n-\n impl<'a, 'tcx> CrateMetadata {\n+    pub fn is_proc_macro_crate(&self) -> bool {\n+        self.root.proc_macro_decls_static.is_some()\n+    }\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.proc_macros.is_some() && id != CRATE_DEF_INDEX\n+        self.is_proc_macro_crate() &&\n+            self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        assert!(!self.is_proc_macro(item_id));\n         self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n@@ -496,29 +477,89 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n+        // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n+        // with items in 'raw_proc_macros'\n+        let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n+        &self.raw_proc_macros.unwrap()[pos]\n+    }\n+\n     pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n-        self.def_key(item_index)\n-            .disambiguated_data\n-            .data\n-            .get_opt_name()\n-            .expect(\"no name in item_name\")\n-            .as_symbol()\n+        if !self.is_proc_macro(item_index) {\n+            self.def_key(item_index)\n+                .disambiguated_data\n+                .data\n+                .get_opt_name()\n+                .expect(\"no name in item_name\")\n+                .as_symbol()\n+        } else {\n+            Symbol::intern(self.raw_proc_macro(item_index).name())\n+        }\n     }\n \n     pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n             Some(DefKind::Macro(\n-                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+                macro_kind(self.raw_proc_macro(index))\n             ))\n         }\n     }\n \n     pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        match self.is_proc_macro(index) {\n-            true => DUMMY_SP,\n-            false => self.entry(index).span.decode((self, sess)),\n+        self.entry(index).span.decode((self, sess))\n+    }\n+\n+\n+    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n+        if sess.opts.debugging_opts.dual_proc_macros {\n+            let host_lib = self.host_lib.as_ref().unwrap();\n+            self.load_proc_macro(\n+                &host_lib.metadata.get_root(),\n+                id,\n+                sess\n+            )\n+        } else {\n+            self.load_proc_macro(&self.root, id, sess)\n+        }\n+    }\n+\n+    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n+                        id: DefIndex,\n+                        sess: &Session)\n+                        -> FullProcMacro {\n+\n+        let raw_macro = self.raw_proc_macro(id);\n+        let (name, kind, helper_attrs) = match *raw_macro {\n+            ProcMacro::CustomDerive { trait_name, attributes, client } => {\n+                let helper_attrs =\n+                    attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                (\n+                    trait_name,\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                        client, attrs: helper_attrs.clone()\n+                    })),\n+                    helper_attrs,\n+                )\n+            }\n+            ProcMacro::Attr { name, client } => (\n+                name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+            ),\n+            ProcMacro::Bang { name, client } => (\n+                name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+            )\n+        };\n+\n+        let span = self.get_span(id, sess);\n+\n+        FullProcMacro {\n+            name: Symbol::intern(name),\n+            ext: Lrc::new(SyntaxExtension {\n+                span,\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            })\n         }\n     }\n \n@@ -569,15 +610,15 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::VariantDef::new(\n             tcx,\n-            Ident::with_empty_ctxt(self.item_name(index)),\n+            Ident::with_dummy_span(self.item_name(index)),\n             variant_did,\n             ctor_did,\n             data.discr,\n             item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    ident: Ident::with_empty_ctxt(self.item_name(index)),\n+                    ident: Ident::with_dummy_span(self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n@@ -715,7 +756,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over the language items in the given crate.\n     pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n         } else {\n@@ -730,18 +771,18 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n-        if let Some(ref proc_macros) = self.proc_macros {\n+        if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n             /* If we are loading as a proc macro, we want to return the view of this crate\n-             * as a proc macro crate, not as a Rust crate. See `proc_macro_def_path_table`\n-             * for the DefPathTable we are corresponding to.\n+             * as a proc macro crate.\n              */\n             if id == CRATE_DEF_INDEX {\n-                for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n+                for def_index in proc_macros_ids {\n+                    let raw_macro = self.raw_proc_macro(def_index);\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.macro_kind()),\n-                        self.local_def_id(DefIndex::from_proc_macro_index(id)),\n+                        DefKind::Macro(macro_kind(raw_macro)),\n+                        self.local_def_id(def_index),\n                     );\n-                    let ident = Ident::with_empty_ctxt(name);\n+                    let ident = Ident::from_str(raw_macro.name());\n                     callback(def::Export {\n                         ident: ident,\n                         res: res,\n@@ -783,7 +824,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n+                                    ident: Ident::with_dummy_span(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                 });\n@@ -952,11 +993,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        if self.is_proc_macro(node_id) {\n-            return Lrc::new([]);\n-        }\n \n+    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1014,7 +1052,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[]\n         }\n@@ -1058,7 +1096,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n \n     pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n         } else {\n@@ -1067,7 +1105,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n         } else {\n@@ -1090,7 +1128,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n         } else {\n@@ -1105,7 +1143,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n-            _ => LazySeq::empty(),\n+            _ => Lazy::empty(),\n         };\n         arg_names.decode(self).collect()\n     }\n@@ -1114,7 +1152,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n             vec![]\n@@ -1183,13 +1221,18 @@ impl<'a, 'tcx> CrateMetadata {\n \n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.def_path_table.def_key(index)\n+        let mut key = self.def_path_table.def_key(index);\n+        if self.is_proc_macro(index) {\n+            let name = self.raw_proc_macro(index).name();\n+            key.disambiguated_data.data = DefPathData::MacroNs(InternedString::intern(name));\n+        }\n+        key\n     }\n \n     // Returns the path leading to the thing with this `id`.\n     pub fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n-        DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n+        DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n@@ -1302,3 +1345,13 @@ impl<'a, 'tcx> CrateMetadata {\n         self.source_map_import_info.borrow()\n     }\n }\n+\n+// Cannot be implemented on 'ProcMacro', as libproc_macro\n+// does not depend on libsyntax\n+fn macro_kind(raw: &ProcMacro) -> MacroKind {\n+    match raw {\n+        ProcMacro::CustomDerive { .. } => MacroKind::Derive,\n+        ProcMacro::Attr { .. } => MacroKind::Attr,\n+        ProcMacro::Bang { .. } => MacroKind::Bang\n+    }\n+}"}, {"sha": "df3320c64a96085263713355780a129d6775b417", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 228, "deletions": 194, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -30,8 +30,9 @@ use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::{kw, sym, Ident};\n use syntax_pos::{self, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -97,17 +98,17 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n \n impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n-        self.emit_lazy_distance(lazy.position, Lazy::<T>::min_size())\n+        self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, seq: &LazySeq<T>) -> Result<(), Self::Error> {\n-        self.emit_usize(seq.len)?;\n-        if seq.len == 0 {\n+impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+    fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n+        self.emit_usize(lazy.meta)?;\n+        if lazy.meta == 0 {\n             return Ok(());\n         }\n-        self.emit_lazy_distance(seq.position, LazySeq::<T>::min_size(seq.len))\n+        self.emit_lazy_distance(*lazy)\n     }\n }\n \n@@ -173,6 +174,13 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n     }\n }\n \n+impl SpecializedEncoder<Ident> for EncodeContext<'tcx> {\n+    fn specialized_encode(&mut self, ident: &Ident) -> Result<(), Self::Error> {\n+        // FIXME(jseyfried): intercrate hygiene\n+        ident.name.encode(self)\n+    }\n+}\n+\n impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -231,21 +239,38 @@ impl<'tcx> TyEncoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> EncodeContext<'tcx> {\n-    fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n-        assert_eq!(self.lazy_state, LazyState::NoNode);\n-        let pos = self.position();\n-        self.lazy_state = LazyState::NodeStart(pos);\n-        let r = f(self, pos);\n-        self.lazy_state = LazyState::NoNode;\n-        r\n+/// Helper trait to allow overloading `EncodeContext::lazy` for iterators.\n+trait EncodeContentsForLazy<T: ?Sized + LazyMeta> {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) -> T::Meta;\n+}\n+\n+impl<T: Encodable> EncodeContentsForLazy<T> for &T {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) {\n+        self.encode(ecx).unwrap()\n     }\n+}\n \n-    fn emit_lazy_distance(&mut self,\n-                          position: usize,\n-                          min_size: usize)\n-                          -> Result<(), <Self as Encoder>::Error> {\n-        let min_end = position + min_size;\n+impl<T: Encodable> EncodeContentsForLazy<T> for T {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) {\n+        self.encode(ecx).unwrap()\n+    }\n+}\n+\n+impl<I, T> EncodeContentsForLazy<[T]> for I\n+    where I: IntoIterator,\n+          I::Item: EncodeContentsForLazy<T>,\n+{\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) -> usize {\n+        self.into_iter().map(|value| value.encode_contents_for_lazy(ecx)).count()\n+    }\n+}\n+\n+impl<'tcx> EncodeContext<'tcx> {\n+    fn emit_lazy_distance<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        lazy: Lazy<T>,\n+    ) -> Result<(), <Self as Encoder>::Error> {\n+        let min_end = lazy.position + T::min_size(lazy.meta);\n         let distance = match self.lazy_state {\n             LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n@@ -254,48 +279,31 @@ impl<'tcx> EncodeContext<'tcx> {\n             }\n             LazyState::Previous(last_min_end) => {\n                 assert!(\n-                    last_min_end <= position,\n+                    last_min_end <= lazy.position,\n                     \"make sure that the calls to `lazy*` \\\n                     are in the same order as the metadata fields\",\n                 );\n-                position - last_min_end\n+                lazy.position - last_min_end\n             }\n         };\n         self.lazy_state = LazyState::Previous(min_end);\n         self.emit_usize(distance)\n     }\n \n-    pub fn lazy<T: Encodable>(&mut self, value: &T) -> Lazy<T> {\n-        self.emit_node(|ecx, pos| {\n-            value.encode(ecx).unwrap();\n-\n-            assert!(pos + Lazy::<T>::min_size() <= ecx.position());\n-            Lazy::with_position(pos)\n-        })\n-    }\n-\n-    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = T>,\n-              T: Encodable\n-    {\n-        self.emit_node(|ecx, pos| {\n-            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+    fn lazy<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        value: impl EncodeContentsForLazy<T>,\n+    ) -> Lazy<T> {\n+        let pos = self.position();\n \n-            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n-            LazySeq::with_position_and_length(pos, len)\n-        })\n-    }\n+        assert_eq!(self.lazy_state, LazyState::NoNode);\n+        self.lazy_state = LazyState::NodeStart(pos);\n+        let meta = value.encode_contents_for_lazy(self);\n+        self.lazy_state = LazyState::NoNode;\n \n-    pub fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = &'b T>,\n-              T: 'b + Encodable\n-    {\n-        self.emit_node(|ecx, pos| {\n-            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+        assert!(pos + <T>::min_size(meta) <= self.position());\n \n-            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n-            LazySeq::with_position_and_length(pos, len)\n-        })\n+        Lazy::from_position_and_meta(pos, meta)\n     }\n \n     /// Emit the data for a `DefId` to the metadata. The function to\n@@ -312,7 +320,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         assert!(id.is_local());\n \n         let entry = op(self, data);\n-        let entry = self.lazy(&entry);\n+        let entry = self.lazy(entry);\n         self.entries_index.record(id, entry);\n     }\n \n@@ -333,7 +341,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         self.lazy(definitions.def_path_table())\n     }\n \n-    fn encode_source_map(&mut self) -> LazySeq<syntax_pos::SourceFile> {\n+    fn encode_source_map(&mut self) -> Lazy<[syntax_pos::SourceFile]> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -372,10 +380,12 @@ impl<'tcx> EncodeContext<'tcx> {\n             })\n             .collect::<Vec<_>>();\n \n-        self.lazy_seq_ref(adapted.iter().map(|rc| &**rc))\n+        self.lazy(adapted.iter().map(|rc| &**rc))\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+\n         let mut i = self.position();\n \n         let crate_deps = self.encode_crate_deps();\n@@ -453,20 +463,26 @@ impl<'tcx> EncodeContext<'tcx> {\n                 }\n                 n = new_n;\n             }\n-            self.lazy_seq(interpret_alloc_index)\n+            self.lazy(interpret_alloc_index)\n         };\n \n+\n         i = self.position();\n         let entries_index = self.entries_index.write_index(&mut self.opaque);\n         let entries_index_bytes = self.position() - i;\n \n+        // Encode the proc macro data\n+        i = self.position();\n+        let proc_macro_data = self.encode_proc_macros();\n+        let proc_macro_data_bytes = self.position() - i;\n+\n+\n         let attrs = tcx.hir().krate_attrs();\n-        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n-        let root = self.lazy(&CrateRoot {\n+        let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n             triple: tcx.sess.opts.target_triple.clone(),\n@@ -484,6 +500,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             } else {\n                 None\n             },\n+            proc_macro_data,\n             proc_macro_stability: if is_proc_macro {\n                 tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| stab.clone())\n             } else {\n@@ -532,6 +549,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"   entries index bytes: {}\", entries_index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n@@ -543,17 +561,17 @@ impl<'tcx> EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+    fn encode_variances_of(&mut self, def_id: DefId) -> Lazy<[ty::Variance]> {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.variances_of(def_id)[..])\n+        self.lazy(&tcx.variances_of(def_id)[..])\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let ty = tcx.type_of(def_id);\n         debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n-        self.lazy(&ty)\n+        self.lazy(ty)\n     }\n \n     fn encode_enum_variant_info(\n@@ -582,23 +600,23 @@ impl EncodeContext<'tcx> {\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         Entry {\n-            kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            kind: EntryKind::Variant(self.lazy(data)),\n+            visibility: self.lazy(ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: self.lazy_seq(variant.fields.iter().map(|f| {\n+            children: self.lazy(variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n                 f.did.index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -623,7 +641,7 @@ impl EncodeContext<'tcx> {\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n+                Some(self.lazy(tcx.fn_sig(def_id)))\n             } else {\n                 None\n             }\n@@ -639,20 +657,20 @@ impl EncodeContext<'tcx> {\n         }\n \n         Entry {\n-            kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: self.lazy(&ctor_vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            kind: EntryKind::Variant(self.lazy(data)),\n+            visibility: self.lazy(ctor_vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -672,25 +690,25 @@ impl EncodeContext<'tcx> {\n \n         let data = ModData {\n             reexports: match tcx.module_exports(def_id) {\n-                Some(exports) => self.lazy_seq_ref(exports),\n-                _ => LazySeq::empty(),\n+                Some(exports) => self.lazy(exports),\n+                _ => Lazy::empty(),\n             },\n         };\n \n         Entry {\n-            kind: EntryKind::Mod(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(vis, id, tcx)),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            kind: EntryKind::Mod(self.lazy(data)),\n+            visibility: self.lazy(ty::Visibility::from_hir(vis, id, tcx)),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(attrs),\n-            children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n+            children: self.lazy(md.item_ids.iter().map(|item_id| {\n                 tcx.hir().local_def_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: None,\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -715,16 +733,16 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind: EntryKind::Field,\n-            visibility: self.lazy(&field.vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            visibility: self.lazy(field.vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n             predicates_defined_on: None,\n@@ -744,7 +762,7 @@ impl EncodeContext<'tcx> {\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n+                Some(self.lazy(tcx.fn_sig(def_id)))\n             } else {\n                 None\n             }\n@@ -770,20 +788,20 @@ impl EncodeContext<'tcx> {\n         let repr_options = get_repr_options(tcx, adt_def_id);\n \n         Entry {\n-            kind: EntryKind::Struct(self.lazy(&data), repr_options),\n-            visibility: self.lazy(&ctor_vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            kind: EntryKind::Struct(self.lazy(data), repr_options),\n+            visibility: self.lazy(ctor_vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -802,13 +820,13 @@ impl EncodeContext<'tcx> {\n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.predicates_of(def_id))\n+        self.lazy(&*tcx.predicates_of(def_id))\n     }\n \n     fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.predicates_defined_on(def_id))\n+        self.lazy(&*tcx.predicates_defined_on(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -839,7 +857,7 @@ impl EncodeContext<'tcx> {\n \n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n-                let rendered_const = self.lazy(&RenderedConst(rendered));\n+                let rendered_const = self.lazy(RenderedConst(rendered));\n \n                 EntryKind::AssocConst(container, const_qualif, rendered_const)\n             }\n@@ -856,12 +874,12 @@ impl EncodeContext<'tcx> {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n                         arg_names,\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(&MethodData {\n+                EntryKind::Method(self.lazy(MethodData {\n                     fn_data,\n                     container,\n                     has_self: trait_item.method_has_self_argument,\n@@ -873,10 +891,10 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&trait_item.vis),\n-            span: self.lazy(&ast_item.span),\n+            visibility: self.lazy(trait_item.vis),\n+            span: self.lazy(ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n@@ -894,11 +912,11 @@ impl EncodeContext<'tcx> {\n                 }\n                 ty::AssocKind::OpaqueTy => unreachable!(),\n             },\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if trait_item.kind == ty::AssocKind::Method {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -952,12 +970,12 @@ impl EncodeContext<'tcx> {\n                     FnData {\n                         constness: sig.header.constness,\n                         arg_names: self.encode_fn_arg_names_for_body(body),\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(&MethodData {\n+                EntryKind::Method(self.lazy(MethodData {\n                     fn_data,\n                     container,\n                     has_self: impl_item.method_has_self_argument,\n@@ -985,19 +1003,19 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&impl_item.vis),\n-            span: self.lazy(&ast_item.span),\n+            visibility: self.lazy(impl_item.vis),\n+            span: self.lazy(ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if impl_item.kind == ty::AssocKind::Method {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -1008,10 +1026,10 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n-                                    -> LazySeq<ast::Name> {\n+                                    -> Lazy<[ast::Name]> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n-            self.lazy_seq(body.arguments.iter().map(|arg| {\n+            self.lazy(body.arguments.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n@@ -1020,28 +1038,28 @@ impl EncodeContext<'tcx> {\n         })\n     }\n \n-    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> LazySeq<ast::Name> {\n-        self.lazy_seq(param_names.iter().map(|ident| ident.name))\n+    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n+        self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n     fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Body<'tcx>>> {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n             let mir = self.tcx.optimized_mir(def_id);\n-            Some(self.lazy(&mir))\n+            Some(self.lazy(mir))\n         } else {\n             None\n         }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n-    fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if implementations.is_empty() {\n-            LazySeq::empty()\n+            Lazy::empty()\n         } else {\n-            self.lazy_seq(implementations.iter().map(|&def_id| {\n+            self.lazy(implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }))\n@@ -1055,7 +1073,7 @@ impl EncodeContext<'tcx> {\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n-        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n+        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(depr))\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n@@ -1084,10 +1102,10 @@ impl EncodeContext<'tcx> {\n                 let data = FnData {\n                     constness: header.constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n-                    sig: self.lazy(&tcx.fn_sig(def_id)),\n+                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n-                EntryKind::Fn(self.lazy(&data))\n+                EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n@@ -1108,7 +1126,7 @@ impl EncodeContext<'tcx> {\n \n                 let repr_options = get_repr_options(tcx, def_id);\n \n-                EntryKind::Struct(self.lazy(&VariantData {\n+                EntryKind::Struct(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n@@ -1119,7 +1137,7 @@ impl EncodeContext<'tcx> {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n                 let repr_options = get_repr_options(tcx, def_id);\n \n-                EntryKind::Union(self.lazy(&VariantData {\n+                EntryKind::Union(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n@@ -1156,10 +1174,10 @@ impl EncodeContext<'tcx> {\n                     defaultness,\n                     parent_impl: parent,\n                     coerce_unsized_info,\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n+                    trait_ref: trait_ref.map(|trait_ref| self.lazy(trait_ref)),\n                 };\n \n-                EntryKind::Impl(self.lazy(&data))\n+                EntryKind::Impl(self.lazy(data))\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = tcx.trait_def(def_id);\n@@ -1168,57 +1186,57 @@ impl EncodeContext<'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_auto_impl: tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n-                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n \n-                EntryKind::Trait(self.lazy(&data))\n+                EntryKind::Trait(self.lazy(data))\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 let data = TraitAliasData {\n-                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n \n-                EntryKind::TraitAlias(self.lazy(&data))\n+                EntryKind::TraitAlias(self.lazy(data))\n             }\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n-            span: self.lazy(&item.span),\n+            visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n+            span: self.lazy(item.span),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n-                    self.lazy_seq(fm.items\n+                    self.lazy(fm.items\n                         .iter()\n                         .map(|foreign_item| tcx.hir().local_def_id(\n                             foreign_item.hir_id).index))\n                 }\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n-                    self.lazy_seq(def.variants.iter().map(|v| {\n+                    self.lazy(def.variants.iter().map(|v| {\n                         assert!(v.def_id.is_local());\n                         v.def_id.index\n                     }))\n                 }\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) => {\n                     let def = self.tcx.adt_def(def_id);\n-                    self.lazy_seq(def.non_enum_variant().fields.iter().map(|f| {\n+                    self.lazy(def.non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n                     }))\n                 }\n                 hir::ItemKind::Impl(..) |\n                 hir::ItemKind::Trait(..) => {\n-                    self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n+                    self.lazy(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n                     }))\n                 }\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -1241,7 +1259,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             generics: match item.node {\n                 hir::ItemKind::Static(..) |\n@@ -1314,20 +1332,20 @@ impl EncodeContext<'tcx> {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         Entry {\n-            kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n+            kind: EntryKind::MacroDef(self.lazy(MacroDef {\n                 body: pprust::tokens_to_string(macro_def.body.clone()),\n                 legacy: macro_def.legacy,\n             })),\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&macro_def.span),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(macro_def.span),\n             attributes: self.encode_attributes(&macro_def.attrs),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             ty: None,\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1344,15 +1362,15 @@ impl EncodeContext<'tcx> {\n         let tcx = self.tcx;\n         Entry {\n             kind: entry_kind,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n             ty: if encode_type { Some(self.encode_item_type(def_id)) } else { None },\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1389,30 +1407,30 @@ impl EncodeContext<'tcx> {\n                 let data = GeneratorData {\n                     layout: layout.clone(),\n                 };\n-                EntryKind::Generator(self.lazy(&data))\n+                EntryKind::Generator(self.lazy(data))\n             }\n \n             ty::Closure(def_id, substs) => {\n                 let sig = substs.closure_sig(def_id, self.tcx);\n-                let data = ClosureData { sig: self.lazy(&sig) };\n-                EntryKind::Closure(self.lazy(&data))\n+                let data = ClosureData { sig: self.lazy(sig) };\n+                EntryKind::Closure(self.lazy(data))\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\")\n         };\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1431,16 +1449,16 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind: EntryKind::Const(self.const_qualif(mir, body_id), const_data),\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n             predicates_defined_on: None,\n@@ -1449,21 +1467,37 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n-        self.lazy_seq_ref(attrs)\n+    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> Lazy<[ast::Attribute]> {\n+        self.lazy(attrs)\n     }\n \n-    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n+    fn encode_native_libraries(&mut self) -> Lazy<[NativeLibrary]> {\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n-        self.lazy_seq(used_libraries.iter().cloned())\n+        self.lazy(used_libraries.iter().cloned())\n     }\n \n-    fn encode_foreign_modules(&mut self) -> LazySeq<ForeignModule> {\n+    fn encode_foreign_modules(&mut self) -> Lazy<[ForeignModule]> {\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n-        self.lazy_seq(foreign_modules.iter().cloned())\n+        self.lazy(foreign_modules.iter().cloned())\n+    }\n+\n+    fn encode_proc_macros(&mut self) -> Option<Lazy<[DefIndex]>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        if is_proc_macro {\n+            let tcx = self.tcx;\n+            Some(self.lazy(tcx.hir().krate().items.values().filter_map(|item| {\n+                if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n+                    Some(item.hir_id.owner)\n+                } else {\n+                    None\n+                }\n+            })))\n+        } else {\n+            None\n+        }\n     }\n \n-    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n+    fn encode_crate_deps(&mut self) -> Lazy<[CrateDep]> {\n         let crates = self.tcx.crates();\n \n         let mut deps = crates\n@@ -1494,20 +1528,20 @@ impl EncodeContext<'tcx> {\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        self.lazy_seq_ref(deps.iter().map(|&(_, ref dep)| dep))\n+        self.lazy(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lib_features(&mut self) -> LazySeq<(ast::Name, Option<ast::Name>)> {\n+    fn encode_lib_features(&mut self) -> Lazy<[(ast::Name, Option<ast::Name>)]> {\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n-        self.lazy_seq(lib_features.to_vec())\n+        self.lazy(lib_features.to_vec())\n     }\n \n-    fn encode_lang_items(&mut self) -> LazySeq<(DefIndex, usize)> {\n+    fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n-        self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n+        self.lazy(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n                     return Some((def_id.index, i));\n@@ -1517,13 +1551,13 @@ impl EncodeContext<'tcx> {\n         }))\n     }\n \n-    fn encode_lang_items_missing(&mut self) -> LazySeq<lang_items::LangItem> {\n+    fn encode_lang_items_missing(&mut self) -> Lazy<[lang_items::LangItem]> {\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.lang_items().missing)\n+        self.lazy(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n+    fn encode_impls(&mut self) -> Lazy<[TraitImpls]> {\n         debug!(\"EncodeContext::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n@@ -1549,12 +1583,12 @@ impl EncodeContext<'tcx> {\n \n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy_seq_ref(&impls),\n+                    impls: self.lazy(&impls),\n                 }\n             })\n             .collect();\n \n-        self.lazy_seq_ref(&all_impls)\n+        self.lazy(&all_impls)\n     }\n \n     // Encodes all symbols exported from this crate into the metadata.\n@@ -1565,12 +1599,12 @@ impl EncodeContext<'tcx> {\n     // definition (as that's not defined in this crate).\n     fn encode_exported_symbols(&mut self,\n                                exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportLevel)])\n-                               -> LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n+                               -> Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]> {\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n \n-        self.lazy_seq(exported_symbols\n+        self.lazy(exported_symbols\n             .iter()\n             .filter(|&&(ref exported_symbol, _)| {\n                 match *exported_symbol {\n@@ -1583,10 +1617,10 @@ impl EncodeContext<'tcx> {\n             .cloned())\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n+    fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n             Some(arr) => {\n-                self.lazy_seq(arr.iter().map(|slot| {\n+                self.lazy(arr.iter().map(|slot| {\n                     match *slot {\n                         Linkage::NotLinked |\n                         Linkage::IncludedFromDylib => None,\n@@ -1596,7 +1630,7 @@ impl EncodeContext<'tcx> {\n                     }\n                 }))\n             }\n-            None => LazySeq::empty(),\n+            None => Lazy::empty(),\n         }\n     }\n \n@@ -1612,9 +1646,9 @@ impl EncodeContext<'tcx> {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n                     arg_names: self.encode_fn_arg_names(names),\n-                    sig: self.lazy(&tcx.fn_sig(def_id)),\n+                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n-                EntryKind::ForeignFn(self.lazy(&data))\n+                EntryKind::ForeignFn(self.lazy(data))\n             }\n             hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n             hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n@@ -1623,18 +1657,18 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n-            span: self.lazy(&nitem.span),\n+            visibility: self.lazy(ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n+            span: self.lazy(nitem.span),\n             attributes: self.encode_attributes(&nitem.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: match nitem.node {\n                 hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -1676,7 +1710,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n                      id: hir::HirId) {\n         intravisit::walk_variant(self, v, g, id);\n \n-        if let Some(ref discr) = v.node.disr_expr {\n+        if let Some(ref discr) = v.disr_expr {\n             let def_id = self.tcx.hir().local_def_id(discr.hir_id);\n             self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n         }"}, {"sha": "6f248f22cf2527502e3b60bbd39c9ea38788f810", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -108,34 +108,34 @@ impl Index<'tcx> {\n         position.write_to_bytes_at(positions, array_index)\n     }\n \n-    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Self> {\n+    pub fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n         buf.emit_raw_bytes(&(self.positions.len() as u32 / 4).to_le_bytes());\n         // ... then the values.\n         buf.emit_raw_bytes(&self.positions);\n-        LazySeq::with_position_and_length(pos as usize, self.positions.len() / 4 + 1)\n+        Lazy::from_position_and_meta(pos as usize, self.positions.len() / 4 + 1)\n     }\n }\n \n-impl LazySeq<Index<'tcx>> {\n+impl Lazy<[Index<'tcx>]> {\n     /// Given the metadata, extract out the offset of a particular\n     /// DefIndex (if any).\n     #[inline(never)]\n     pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         let bytes = &bytes[self.position..];\n         debug!(\"Index::lookup: index={:?} len={:?}\",\n                def_index,\n-               self.len);\n+               self.meta);\n \n         let position = u32::read_from_bytes_at(bytes, 1 + def_index.index());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n         } else {\n             debug!(\"Index::lookup: position={:?}\", position);\n-            Some(Lazy::with_position(position as usize))\n+            Some(Lazy::from_position(position as usize))\n         }\n     }\n }"}, {"sha": "ceba7cf0fe031c94324f06469b8d6edb33739f0c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -716,7 +716,9 @@ impl<'a> Context<'a> {\n \n         let root = metadata.get_root();\n         if let Some(is_proc_macro) = self.is_proc_macro {\n-            if root.proc_macro_decls_static.is_some() != is_proc_macro {\n+            if root.proc_macro_data.is_some() != is_proc_macro {\n+                info!(\"Rejecting via proc macro: expected {} got {}\",\n+                      is_proc_macro, root.proc_macro_data.is_some());\n                 return None;\n             }\n         }"}, {"sha": "f37877b437e157582b7e5d0938ad91a1844d96e5", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 81, "deletions": 74, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -41,6 +41,33 @@ pub const METADATA_VERSION: u8 = 4;\n pub const METADATA_HEADER: &[u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n+/// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n+/// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n+pub trait LazyMeta {\n+    type Meta: Copy + 'static;\n+\n+    /// Returns the minimum encoded size.\n+    // FIXME(eddyb) Give better estimates for certain types.\n+    fn min_size(meta: Self::Meta) -> usize;\n+}\n+\n+impl<T> LazyMeta for T {\n+    type Meta = ();\n+\n+    fn min_size(_: ()) -> usize {\n+        assert_ne!(std::mem::size_of::<T>(), 0);\n+        1\n+    }\n+}\n+\n+impl<T> LazyMeta for [T] {\n+    type Meta = usize;\n+\n+    fn min_size(len: usize) -> usize {\n+        len * T::min_size(())\n+    }\n+}\n+\n /// A value of type T referred to by its absolute position\n /// in the metadata, and which can be decoded lazily.\n ///\n@@ -56,40 +83,8 @@ pub const METADATA_HEADER: &[u8; 12] =\n /// Distances start at 1, as 0-byte nodes are invalid.\n /// Also invalid are nodes being referred in a different\n /// order than they were encoded in.\n-#[must_use]\n-pub struct Lazy<T> {\n-    pub position: usize,\n-    _marker: PhantomData<T>,\n-}\n-\n-impl<T> Lazy<T> {\n-    pub fn with_position(position: usize) -> Lazy<T> {\n-        Lazy {\n-            position,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Returns the minimum encoded size of a value of type `T`.\n-    // FIXME(eddyb) Give better estimates for certain types.\n-    pub fn min_size() -> usize {\n-        1\n-    }\n-}\n-\n-impl<T> Copy for Lazy<T> {}\n-impl<T> Clone for Lazy<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-impl<T> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n-impl<T> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n-\n-/// A sequence of type T referred to by its absolute position\n-/// in the metadata and length, and which can be decoded lazily.\n-/// The sequence is a single node for the purposes of `Lazy`.\n+///\n+/// # Sequences (`Lazy<[T]>`)\n ///\n /// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n /// position, not at the position, which means that the length\n@@ -100,54 +95,62 @@ impl<T> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n /// the minimal distance the length of the sequence, i.e.\n /// it's assumed there's no 0-byte element in the sequence.\n #[must_use]\n-pub struct LazySeq<T> {\n-    pub len: usize,\n+// FIXME(#59875) the `Meta` parameter only exists to dodge\n+// invariance wrt `T` (coming from the `meta: T::Meta` field).\n+pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+    where T: ?Sized + LazyMeta<Meta = Meta>,\n+          Meta: 'static + Copy,\n+{\n     pub position: usize,\n+    pub meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n-impl<T> LazySeq<T> {\n-    pub fn empty() -> LazySeq<T> {\n-        LazySeq::with_position_and_length(0, 0)\n-    }\n-\n-    pub fn with_position_and_length(position: usize, len: usize) -> LazySeq<T> {\n-        LazySeq {\n-            len,\n+impl<T: ?Sized + LazyMeta> Lazy<T> {\n+    pub fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n+        Lazy {\n             position,\n+            meta,\n             _marker: PhantomData,\n         }\n     }\n+}\n \n-    /// Returns the minimum encoded size of `length` values of type `T`.\n-    pub fn min_size(length: usize) -> usize {\n-        length\n+impl<T> Lazy<T> {\n+    pub fn from_position(position: usize) -> Lazy<T> {\n+        Lazy::from_position_and_meta(position, ())\n     }\n }\n \n-impl<T> Copy for LazySeq<T> {}\n-impl<T> Clone for LazySeq<T> {\n+impl<T> Lazy<[T]> {\n+    pub fn empty() -> Lazy<[T]> {\n+        Lazy::from_position_and_meta(0, 0)\n+    }\n+}\n+\n+impl<T: ?Sized + LazyMeta> Copy for Lazy<T> {}\n+impl<T: ?Sized + LazyMeta> Clone for Lazy<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T> rustc_serialize::UseSpecializedEncodable for LazySeq<T> {}\n-impl<T> rustc_serialize::UseSpecializedDecodable for LazySeq<T> {}\n+impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n+impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n \n-/// Encoding / decoding state for `Lazy` and `LazySeq`.\n+/// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n-    /// Inside a metadata node, and before any `Lazy` or `LazySeq`.\n+    /// Inside a metadata node, and before any `Lazy`.\n     /// The position is that of the node itself.\n     NodeStart(usize),\n \n-    /// Inside a metadata node, with a previous `Lazy` or `LazySeq`.\n+    /// Inside a metadata node, with a previous `Lazy`.\n     /// The position is a conservative estimate of where that\n-    /// previous `Lazy` / `LazySeq` would end (see their comments).\n+    /// previous `Lazy` would end (see their comments).\n     Previous(usize),\n }\n \n@@ -167,20 +170,24 @@ pub struct CrateRoot<'tcx> {\n     pub proc_macro_decls_static: Option<DefIndex>,\n     pub proc_macro_stability: Option<attr::Stability>,\n \n-    pub crate_deps: LazySeq<CrateDep>,\n-    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n-    pub lib_features: LazySeq<(Symbol, Option<Symbol>)>,\n-    pub lang_items: LazySeq<(DefIndex, usize)>,\n-    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n-    pub native_libraries: LazySeq<NativeLibrary>,\n-    pub foreign_modules: LazySeq<ForeignModule>,\n-    pub source_map: LazySeq<syntax_pos::SourceFile>,\n+    pub crate_deps: Lazy<[CrateDep]>,\n+    pub dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n+    pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n+    pub lang_items: Lazy<[(DefIndex, usize)]>,\n+    pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    pub native_libraries: Lazy<[NativeLibrary]>,\n+    pub foreign_modules: Lazy<[ForeignModule]>,\n+    pub source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)>,\n-    pub interpret_alloc_index: LazySeq<u32>,\n+    pub impls: Lazy<[TraitImpls]>,\n+    pub exported_symbols: Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]>,\n+    pub interpret_alloc_index: Lazy<[u32]>,\n+\n+    pub entries_index: Lazy<[index::Index<'tcx>]>,\n \n-    pub entries_index: LazySeq<index::Index<'tcx>>,\n+    /// The DefIndex's of any proc macros delcared by\n+    /// this crate\n+    pub proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n@@ -203,22 +210,22 @@ pub struct CrateDep {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n-    pub impls: LazySeq<DefIndex>,\n+    pub impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: Lazy<ty::Visibility>,\n     pub span: Lazy<Span>,\n-    pub attributes: LazySeq<ast::Attribute>,\n-    pub children: LazySeq<DefIndex>,\n+    pub attributes: Lazy<[ast::Attribute]>,\n+    pub children: Lazy<[DefIndex]>,\n     pub stability: Option<Lazy<attr::Stability>>,\n     pub deprecation: Option<Lazy<attr::Deprecation>>,\n \n     pub ty: Option<Lazy<Ty<'tcx>>>,\n-    pub inherent_impls: LazySeq<DefIndex>,\n-    pub variances: LazySeq<ty::Variance>,\n+    pub inherent_impls: Lazy<[DefIndex]>,\n+    pub variances: Lazy<[ty::Variance]>,\n     pub generics: Option<Lazy<ty::Generics>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n     pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n@@ -274,7 +281,7 @@ pub struct RenderedConst(pub String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n-    pub reexports: LazySeq<def::Export<hir::HirId>>,\n+    pub reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -286,7 +293,7 @@ pub struct MacroDef {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n-    pub arg_names: LazySeq<ast::Name>,\n+    pub arg_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n "}, {"sha": "247783c420e251d6d32b79835fba3e1dbb303379", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1190,7 +1190,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let suggestion = match tcx.sess.source_map().span_to_snippet(args_span) {\n-            Ok(string) => format!(\"move {}\", string),\n+            Ok(mut string) => {\n+                if string.starts_with(\"async \") {\n+                    string.insert_str(6, \"move \");\n+                } else if string.starts_with(\"async|\") {\n+                    string.insert_str(5, \" move\");\n+                } else {\n+                    string.insert_str(0, \"move \");\n+                };\n+                string\n+            },\n             Err(_) => \"move |<args>| <body>\".to_string()\n         };\n "}, {"sha": "ca68b9e31b6b91337e4fa2b555d7c53f0de24f12", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -578,7 +578,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             }\n \n-            hir::LifetimeName::Implicit => {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "9ff0c6ca6a546b6566e036c3f736d703a7e0560d", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -272,12 +272,11 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        self.sanitize_constant(constant, location);\n-        self.sanitize_type(constant, constant.ty);\n+        self.sanitize_type(constant, constant.literal.ty);\n \n         if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n-                constant.ty,\n+                constant.literal.ty,\n                 ty::Variance::Invariant,\n                 &UserTypeProjection { base: annotation_index, projs: vec![], },\n                 location.to_locations(),\n@@ -289,7 +288,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     constant,\n                     \"bad constant user type {:?} vs {:?}: {:?}\",\n                     annotation,\n-                    constant.ty,\n+                    constant.literal.ty,\n                     terr,\n                 );\n             }\n@@ -299,7 +298,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     location.to_locations(),\n                     ConstraintCategory::Boring,\n                     self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                        constant.ty, def_id, UserSubsts { substs, user_self_ty: None },\n+                        constant.literal.ty, def_id, UserSubsts { substs, user_self_ty: None },\n                     )),\n                 ) {\n                     span_mirbug!(\n@@ -403,41 +402,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Checks that the constant's `ty` field matches up with what would be\n-    /// expected from its literal. Unevaluated constants and well-formed\n-    /// constraints are checked by `visit_constant`.\n-    fn sanitize_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n-        debug!(\n-            \"sanitize_constant(constant={:?}, location={:?})\",\n-            constant, location\n-        );\n-\n-        let literal = constant.literal;\n-\n-        if let ConstValue::Unevaluated(..) = literal.val {\n-            return;\n-        }\n-\n-        debug!(\"sanitize_constant: expected_ty={:?}\", literal.ty);\n-\n-        if let Err(terr) = self.cx.eq_types(\n-            literal.ty,\n-            constant.ty,\n-            location.to_locations(),\n-            ConstraintCategory::Boring,\n-        ) {\n-            span_mirbug!(\n-                self,\n-                constant,\n-                \"constant {:?} should have type {:?} but has {:?} ({:?})\",\n-                constant,\n-                literal.ty,\n-                constant.ty,\n-                terr,\n-            );\n-        }\n-    }\n-\n     /// Checks that the types internal to the `place` match up with\n     /// what would be expected.\n     fn sanitize_place("}, {"sha": "39bdc871d83c6deed23df26d770f9dd5eed88716", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -38,9 +38,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         inferred_ty: ty,\n                     })\n                 });\n+                assert_eq!(literal.ty, ty);\n                 Constant {\n                     span,\n-                    ty,\n                     user_ty,\n                     literal,\n                 }"}, {"sha": "1a186fa932ddb116e8a40556fbfc18999a6b0d3e", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -591,7 +591,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let n = (!0u128) >> (128 - bits);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n \n-        self.literal_operand(span, ty, literal)\n+        self.literal_operand(span, literal)\n     }\n \n     // Helper to get the minimum value of the appropriate type\n@@ -602,6 +602,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let n = 1 << (bits - 1);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n \n-        self.literal_operand(span, ty, literal)\n+        self.literal_operand(span, literal)\n     }\n }"}, {"sha": "889861b85674861b2d4caf181d900c081494da0a", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -114,7 +114,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     destination,\n                     Constant {\n                         span: expr_span,\n-                        ty: this.hir.bool_ty(),\n                         user_ty: None,\n                         literal: this.hir.true_literal(),\n                     },\n@@ -126,7 +125,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     destination,\n                     Constant {\n                         span: expr_span,\n-                        ty: this.hir.bool_ty(),\n                         user_ty: None,\n                         literal: this.hir.false_literal(),\n                     },"}, {"sha": "94323b15b696fb3ba91aa1460317ea2eddec56b1", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -657,6 +657,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n+            PatternKind::Or { ref pats } => {\n+                for pat in pats {\n+                    self.visit_bindings(&pat, pattern_user_ty.clone(), f);\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "8d049b53988a9197f78c2e4aedd4f839f7a079e9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Range(PatternRange { lo, hi, ty, end }) => {\n-                let (range, bias) = match ty.sty {\n+            PatternKind::Range(PatternRange { lo, hi, end }) => {\n+                let (range, bias) = match lo.ty.sty {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }\n@@ -195,6 +195,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }\n+\n+            PatternKind::Or { .. } => {\n+                Err(match_pair)\n+            }\n         }\n     }\n }"}, {"sha": "ec85daccd476eb49efa6a7c729dcea23c0a5ad17", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -63,7 +63,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatternKind::Range(range) => {\n-                assert!(range.ty == match_pair.pattern.ty);\n+                assert_eq!(range.lo.ty, match_pair.pattern.ty);\n+                assert_eq!(range.hi.ty, match_pair.pattern.ty);\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range(range),\n@@ -86,6 +87,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n+            PatternKind::Or { .. } |\n             PatternKind::Binding { .. } |\n             PatternKind::Leaf { .. } |\n             PatternKind::Deref { .. } => {\n@@ -129,6 +131,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatternKind::Slice { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n+            PatternKind::Or { .. } |\n             PatternKind::Binding { .. } |\n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Leaf { .. } |\n@@ -270,22 +273,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                 } else {\n                     if let [success, fail] = *make_target_blocks(self) {\n+                        assert_eq!(value.ty, ty);\n+                        let expect = self.literal_operand(test.span, value);\n                         let val = Operand::Copy(place.clone());\n-                        let expect = self.literal_operand(test.span, ty, value);\n                         self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                     } else {\n                         bug!(\"`TestKind::Eq` should have two target blocks\");\n                     }\n                 }\n             }\n \n-            TestKind::Range(PatternRange { ref lo, ref hi, ty, ref end }) => {\n+            TestKind::Range(PatternRange { ref lo, ref hi, ref end }) => {\n                 let lower_bound_success = self.cfg.start_new_block();\n                 let target_blocks = make_target_blocks(self);\n \n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n-                let lo = self.literal_operand(test.span, ty, lo);\n-                let hi = self.literal_operand(test.span, ty, hi);\n+                let lo = self.literal_operand(test.span, lo);\n+                let hi = self.literal_operand(test.span, hi);\n                 let val = Operand::Copy(place.clone());\n \n                 if let [success, fail] = *target_blocks {\n@@ -387,7 +391,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         use rustc::middle::lang_items::EqTraitLangItem;\n \n-        let mut expect = self.literal_operand(source_info.span, value.ty, value);\n+        let mut expect = self.literal_operand(source_info.span, value);\n         let mut val = Operand::Copy(place.clone());\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n@@ -440,7 +444,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem);\n-        let (mty, method) = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n+        let method = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n \n         let bool_ty = self.hir.bool_ty();\n         let eq_result = self.temp(bool_ty, source_info.span);\n@@ -449,7 +453,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(block, source_info, TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n                 span: source_info.span,\n-                ty: mty,\n \n                 // FIXME(#54571): This constant comes from user input (a\n                 // constant in a pattern).  Are there forms where users can add\n@@ -656,8 +659,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     let tcx = self.hir.tcx();\n \n-                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.hir.param_env, test.ty)?;\n-                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.hir.param_env, test.ty)?;\n+                    let test_ty = test.lo.ty;\n+                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.hir.param_env, test_ty)?;\n+                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.hir.param_env, test_ty)?;\n \n                     match (test.end, pat.end, lo, hi) {\n                         // pat < test\n@@ -774,8 +778,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let tcx = self.hir.tcx();\n \n-        let a = compare_const_vals(tcx, range.lo, value, self.hir.param_env, range.ty)?;\n-        let b = compare_const_vals(tcx, value, range.hi, self.hir.param_env, range.ty)?;\n+        let a = compare_const_vals(tcx, range.lo, value, self.hir.param_env, range.lo.ty)?;\n+        let b = compare_const_vals(tcx, value, range.hi, self.hir.param_env, range.lo.ty)?;\n \n         match (b, range.end) {\n             (Less, _) |"}, {"sha": "d038310dd4454cadd4cbe432befcd97c791f2fc9", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -26,12 +26,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// without any user type annotation.\n     pub fn literal_operand(&mut self,\n                            span: Span,\n-                           ty: Ty<'tcx>,\n                            literal: &'tcx ty::Const<'tcx>)\n                            -> Operand<'tcx> {\n         let constant = box Constant {\n             span,\n-            ty,\n             user_ty: None,\n             literal,\n         };\n@@ -47,7 +45,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty));\n \n-        self.literal_operand(span, ty, literal)\n+        self.literal_operand(span, literal)\n     }\n \n     pub fn push_usize(&mut self,\n@@ -61,7 +59,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block, source_info, &temp,\n             Constant {\n                 span: source_info.span,\n-                ty: self.hir.usize_ty(),\n                 user_ty: None,\n                 literal: self.hir.usize_literal(value),\n             });"}, {"sha": "76ee76a74562bf6e6efd19a84892108bd8d098e5", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -11,9 +11,8 @@ use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, subst::Subst};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n-use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -415,7 +414,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         Err(\n             ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n         )\n@@ -540,6 +539,12 @@ pub fn error_to_const_error<'mir, 'tcx>(\n     ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n }\n \n+pub fn note_on_undefined_behavior_error() -> &'static str {\n+    \"The rules on what exactly is undefined behavior aren't clear, \\\n+    so this check might be overzealous. Please open an issue on the rust compiler \\\n+    repository if you believe it should not be considered undefined behavior\"\n+}\n+\n fn validate_and_turn_into_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: RawConst<'tcx>,\n@@ -579,10 +584,7 @@ fn validate_and_turn_into_const<'tcx>(\n         let err = error_to_const_error(&ecx, error);\n         match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n             Ok(mut diag) => {\n-                diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n-                    so this check might be overzealous. Please open an issue on the rust compiler \\\n-                    repository if you believe it should not be considered undefined behavior\",\n-                );\n+                diag.note(note_on_undefined_behavior_error());\n                 diag.emit();\n                 ErrorHandled::Reported\n             }"}, {"sha": "a33d7207ed4e1453d2917f966b7f59e278b63dad", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -927,7 +927,7 @@ fn convert_path_expr<'a, 'tcx>(\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const(ty::Const {\n                     val: ConstValue::Unevaluated(def_id, substs),\n-                    ty: cx.tcx.type_of(def_id),\n+                    ty: cx.tables().node_type(expr.hir_id),\n                 }),\n                 user_ty,\n             }"}, {"sha": "740dc2011cab1cddd65cea770aac1f777b53e540", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -170,13 +170,13 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n                         method_name: Symbol,\n                         self_ty: Ty<'tcx>,\n                         params: &[Kind<'tcx>])\n-                        -> (Ty<'tcx>, &'tcx ty::Const<'tcx>) {\n+                        -> &'tcx ty::Const<'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssocKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, ty::Const::zero_sized(self.tcx, method_ty));\n+                return ty::Const::zero_sized(self.tcx, method_ty);\n             }\n         }\n "}, {"sha": "222750e602df92f5ff30b37c5230b3c94086e105", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -609,7 +609,6 @@ impl<'tcx> Witness<'tcx> {\n                         ConstantRange(lo, hi, ty, end) => PatternKind::Range(PatternRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                            ty,\n                             end,\n                         }),\n                         _ => PatternKind::Wild,\n@@ -880,10 +879,10 @@ impl<'tcx> IntRange<'tcx> {\n         let range = loop {\n             match pat.kind {\n                 box PatternKind::Constant { value } => break ConstantValue(value),\n-                box PatternKind::Range(PatternRange { lo, hi, ty, end }) => break ConstantRange(\n-                    lo.eval_bits(tcx, param_env, ty),\n-                    hi.eval_bits(tcx, param_env, ty),\n-                    ty,\n+                box PatternKind::Range(PatternRange { lo, hi, end }) => break ConstantRange(\n+                    lo.eval_bits(tcx, param_env, lo.ty),\n+                    hi.eval_bits(tcx, param_env, hi.ty),\n+                    lo.ty,\n                     end,\n                 ),\n                 box PatternKind::AscribeUserType { ref subpattern, .. } => {\n@@ -1339,11 +1338,11 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n-        PatternKind::Range(PatternRange { lo, hi, ty, end }) =>\n+        PatternKind::Range(PatternRange { lo, hi, end }) =>\n             Some(vec![ConstantRange(\n-                lo.eval_bits(cx.tcx, cx.param_env, ty),\n-                hi.eval_bits(cx.tcx, cx.param_env, ty),\n-                ty,\n+                lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+                hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+                lo.ty,\n                 end,\n             )]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n@@ -1360,6 +1359,9 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                 Some(vec![Slice(pat_len)])\n             }\n         }\n+        PatternKind::Or { .. } => {\n+            bug!(\"support for or-patterns has not been fully implemented yet.\");\n+        }\n     }\n }\n \n@@ -1656,7 +1658,7 @@ fn constructor_covered_by_range<'tcx>(\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n         box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatternKind::Range(PatternRange { lo, hi, end, ty }) => (lo, hi, end, ty),\n+        box PatternKind::Range(PatternRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n@@ -1885,6 +1887,10 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     \"unexpected ctor {:?} for slice pat\", constructor)\n             }\n         }\n+\n+        PatternKind::Or { .. } => {\n+            bug!(\"support for or-patterns has not been fully implemented yet.\");\n+        }\n     };\n     debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n "}, {"sha": "6caccfddfa422f6724180e8199b5d1824edae489", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -175,18 +175,35 @@ pub enum PatternKind<'tcx> {\n         slice: Option<Pattern<'tcx>>,\n         suffix: Vec<Pattern<'tcx>>,\n     },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pattern<'tcx>>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct PatternRange<'tcx> {\n     pub lo: &'tcx ty::Const<'tcx>,\n     pub hi: &'tcx ty::Const<'tcx>,\n-    pub ty: Ty<'tcx>,\n     pub end: RangeEnd,\n }\n \n impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Printing lists is a chore.\n+        let mut first = true;\n+        let mut start_or_continue = |s| {\n+            if first {\n+                first = false;\n+                \"\"\n+            } else {\n+                s\n+            }\n+        };\n+        let mut start_or_comma = || start_or_continue(\", \");\n+\n         match *self.kind {\n             PatternKind::Wild => write!(f, \"_\"),\n             PatternKind::AscribeUserType { ref subpattern, .. } =>\n@@ -225,9 +242,6 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     }\n                 };\n \n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n-\n                 if let Some(variant) = variant {\n                     write!(f, \"{}\", variant.ident)?;\n \n@@ -242,12 +256,12 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                                 continue;\n                             }\n                             let name = variant.fields[p.field.index()].ident;\n-                            write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n+                            write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n                             printed += 1;\n                         }\n \n                         if printed < variant.fields.len() {\n-                            write!(f, \"{}..\", start_or_continue())?;\n+                            write!(f, \"{}..\", start_or_comma())?;\n                         }\n \n                         return write!(f, \" }}\");\n@@ -258,7 +272,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 if num_fields != 0 || variant.is_none() {\n                     write!(f, \"(\")?;\n                     for i in 0..num_fields {\n-                        write!(f, \"{}\", start_or_continue())?;\n+                        write!(f, \"{}\", start_or_comma())?;\n \n                         // Common case: the field is where we expect it.\n                         if let Some(p) = subpatterns.get(i) {\n@@ -296,7 +310,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Constant { value } => {\n                 write!(f, \"{}\", value)\n             }\n-            PatternKind::Range(PatternRange { lo, hi, ty: _, end }) => {\n+            PatternKind::Range(PatternRange { lo, hi, end }) => {\n                 write!(f, \"{}\", lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n@@ -306,25 +320,29 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n                 write!(f, \"[\")?;\n                 for p in prefix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 if let Some(ref slice) = *slice {\n-                    write!(f, \"{}\", start_or_continue())?;\n+                    write!(f, \"{}\", start_or_comma())?;\n                     match *slice.kind {\n                         PatternKind::Wild => {}\n                         _ => write!(f, \"{}\", slice)?\n                     }\n                     write!(f, \"..\")?;\n                 }\n                 for p in suffix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 write!(f, \"]\")\n             }\n+            PatternKind::Or { ref pats } => {\n+                for pat in pats {\n+                    write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n+                }\n+                Ok(())\n+            }\n         }\n     }\n }\n@@ -442,6 +460,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n                 let mut kind = match (lo, hi) {\n                     (PatternKind::Constant { value: lo }, PatternKind::Constant { value: hi }) => {\n+                        assert_eq!(lo.ty, ty);\n+                        assert_eq!(hi.ty, ty);\n                         let cmp = compare_const_vals(\n                             self.tcx,\n                             lo,\n@@ -451,7 +471,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n-                                PatternKind::Range(PatternRange { lo, hi, ty, end }),\n+                                PatternKind::Range(PatternRange { lo, hi, end }),\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n                                     self.tcx.sess,\n@@ -465,7 +485,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 PatternKind::Constant { value: lo }\n                             }\n                             (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range(PatternRange { lo, hi, ty, end })\n+                                PatternKind::Range(PatternRange { lo, hi, end })\n                             }\n                             (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n@@ -645,15 +665,21 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     fields.iter()\n                           .map(|field| {\n                               FieldPattern {\n-                                  field: Field::new(self.tcx.field_index(field.node.hir_id,\n+                                  field: Field::new(self.tcx.field_index(field.hir_id,\n                                                                          self.tables)),\n-                                  pattern: self.lower_pattern(&field.node.pat),\n+                                  pattern: self.lower_pattern(&field.pat),\n                               }\n                           })\n                           .collect();\n \n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n+\n+            PatKind::Or(ref pats) => {\n+                PatternKind::Or {\n+                    pats: pats.iter().map(|p| self.lower_pattern(p)).collect(),\n+                }\n+            }\n         };\n \n         Pattern {\n@@ -1416,17 +1442,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             } => PatternKind::Constant {\n                 value,\n             },\n-            PatternKind::Range(PatternRange {\n-                lo,\n-                hi,\n-                ty,\n-                end,\n-            }) => PatternKind::Range(PatternRange {\n-                lo,\n-                hi,\n-                ty: ty.fold_with(folder),\n-                end,\n-            }),\n+            PatternKind::Range(range) => PatternKind::Range(range),\n             PatternKind::Slice {\n                 ref prefix,\n                 ref slice,\n@@ -1445,6 +1461,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n                 slice: slice.fold_with(folder),\n                 suffix: suffix.fold_with(folder)\n             },\n+            PatternKind::Or { ref pats } => PatternKind::Or { pats: pats.fold_with(folder) },\n         }\n     }\n }"}, {"sha": "210647ac1e9a3de60307d4490cdd7a26c2000812", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, TypeAndMut};\n+use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n use syntax::ast::FloatTy;\n@@ -36,15 +36,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n                             bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n-                        let instance = ty::Instance::resolve(\n-                            *self.tcx,\n-                            self.param_env,\n-                            def_id,\n-                            substs,\n-                        ).ok_or_else(|| err_inval!(TooGeneric))?;\n+                        let instance = self.resolve(def_id, substs)?;\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n@@ -67,7 +67,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::Closure(def_id, substs) => {\n-                        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,\n                             def_id,"}, {"sha": "6f48396cdd7cfeca0af170637f00b6ccb23d3d5d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 29, "deletions": 60, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -9,7 +9,7 @@ use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n-use rustc::ty::subst::{Subst, SubstsRef};\n+use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -291,41 +291,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n     }\n \n-    pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n-        &self,\n-        substs: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.tcx.subst_and_normalize_erasing_regions(\n-                frame.instance.substs,\n-                self.param_env,\n-                &substs,\n-            )),\n-            None => if substs.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(substs)\n-            },\n-        }\n-    }\n-\n-    pub(super) fn resolve(\n-        &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n-        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n-        trace!(\"param_env: {:#?}\", self.param_env);\n-        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n-        trace!(\"substs: {:#?}\", substs);\n-        ty::Instance::resolve(\n-            *self.tcx,\n-            self.param_env,\n-            def_id,\n-            substs,\n-        ).ok_or_else(|| err_inval!(TooGeneric).into())\n-    }\n-\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n@@ -349,34 +314,34 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// Call this on things you got out of the MIR (so it is as generic as the current\n+    /// stack frame), to bring it into the proper environment for this interpreter.\n+    pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n-        t: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n-            None => if t.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(t)\n-            },\n-        }\n+        value: T,\n+    ) -> T {\n+        self.tcx.subst_and_normalize_erasing_regions(\n+            self.frame().instance.substs,\n+            self.param_env,\n+            &value,\n+        )\n     }\n \n-    fn monomorphize_with_substs<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n+    pub(super) fn resolve(\n         &self,\n-        t: T,\n+        def_id: DefId,\n         substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, T> {\n-        // miri doesn't care about lifetimes, and will choke on some crazy ones\n-        // let's simply get rid of them\n-        let substituted = t.subst(*self.tcx, substs);\n-\n-        if substituted.needs_subst() {\n-            throw_inval!(TooGeneric)\n-        }\n-\n-        Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n+    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n+        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n+        trace!(\"param_env: {:#?}\", self.param_env);\n+        trace!(\"substs: {:#?}\", substs);\n+        ty::Instance::resolve(\n+            *self.tcx,\n+            self.param_env,\n+            def_id,\n+            substs,\n+        ).ok_or_else(|| err_inval!(TooGeneric).into())\n     }\n \n     pub fn layout_of_local(\n@@ -391,7 +356,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs)?;\n+                    let local_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                        frame.instance.substs,\n+                        self.param_env,\n+                        &local_ty,\n+                    );\n                     self.layout_of(local_ty)\n                 })?;\n                 if let Some(state) = frame.locals.get(local) {"}, {"sha": "32ba70a81c99792cedd200c305dff2d8623e42ec", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -296,11 +296,7 @@ pub fn intern_const_alloc_recursive(\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n                 match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n                     Ok(mut diag) => {\n-                        diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n-                            so this check might be overzealous. Please open an issue on the rust \\\n-                            compiler repository if you believe it should not be considered \\\n-                            undefined behavior\",\n-                        );\n+                        diag.note(crate::const_eval::note_on_undefined_behavior_error());\n                         diag.emit();\n                     }\n                     Err(ErrorHandled::TooGeneric) |"}, {"sha": "4c86c53256e9b67ca7a3d41fc9040a3d9cf84a35", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -110,18 +110,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.write_scalar(out_val, dest)?;\n             }\n-            | \"overflowing_add\"\n-            | \"overflowing_sub\"\n-            | \"overflowing_mul\"\n+            | \"wrapping_add\"\n+            | \"wrapping_sub\"\n+            | \"wrapping_mul\"\n             | \"add_with_overflow\"\n             | \"sub_with_overflow\"\n             | \"mul_with_overflow\" => {\n                 let lhs = self.read_immediate(args[0])?;\n                 let rhs = self.read_immediate(args[1])?;\n                 let (bin_op, ignore_overflow) = match intrinsic_name {\n-                    \"overflowing_add\" => (BinOp::Add, true),\n-                    \"overflowing_sub\" => (BinOp::Sub, true),\n-                    \"overflowing_mul\" => (BinOp::Mul, true),\n+                    \"wrapping_add\" => (BinOp::Add, true),\n+                    \"wrapping_sub\" => (BinOp::Sub, true),\n+                    \"wrapping_mul\" => (BinOp::Mul, true),\n                     \"add_with_overflow\" => (BinOp::Add, false),\n                     \"sub_with_overflow\" => (BinOp::Sub, false),\n                     \"mul_with_overflow\" => (BinOp::Mul, false),\n@@ -137,7 +137,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let is_add = intrinsic_name == \"saturating_add\";\n-                let (val, overflowed) = self.binary_op(if is_add {\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(if is_add {\n                     BinOp::Add\n                 } else {\n                     BinOp::Sub\n@@ -184,7 +184,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"unchecked_shr\" => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n-                let (val, overflowed) = self.binary_op(bin_op, l, r)?;\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = r.to_scalar()?.to_bits(layout.size)?;"}, {"sha": "bb74a50156e564f6c4470aab31412ffa0437adba", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -7,7 +7,7 @@ use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n \n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n@@ -176,7 +176,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n+    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool, Ty<'tcx>)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc("}, {"sha": "87d36dabb04721b36508d673e9828f1164e4eaf4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -297,7 +297,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// and `align`. On success, returns `None` for zero-sized accesses (where\n     /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n     /// Crucially, if the input is a `Pointer`, we will test it for liveness\n-    /// *even of* the size is 0.\n+    /// *even if* the size is 0.\n     ///\n     /// Everyone accessing memory based on a `Scalar` should use this method to get the\n     /// `Pointer` they need. And even if you already have a `Pointer`, call this method\n@@ -368,7 +368,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n-                end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n+                end_ptr.check_inbounds_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n@@ -400,7 +400,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> bool {\n         let (size, _align) = self.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n             .expect(\"alloc info with MaybeDead cannot fail\");\n-        ptr.check_in_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n+        ptr.check_inbounds_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n     }\n }\n "}, {"sha": "7a545e8ad6f792abbee4190061bf46eed0ac56fd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -108,7 +108,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag=()> {\n-    pub imm: Immediate<Tag>,\n+    pub(crate) imm: Immediate<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -155,7 +155,7 @@ impl<Tag> Operand<Tag> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct OpTy<'tcx, Tag=()> {\n-    op: Operand<Tag>,\n+    op: Operand<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -187,13 +187,22 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n-{\n+impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n         ImmTy { imm: val.into(), layout }\n     }\n \n+    #[inline]\n+    pub fn from_uint(i: impl Into<u128>, layout: TyLayout<'tcx>) -> Self {\n+        Self::from_scalar(Scalar::from_uint(i, layout.size), layout)\n+    }\n+\n+    #[inline]\n+    pub fn from_int(i: impl Into<i128>, layout: TyLayout<'tcx>) -> Self {\n+        Self::from_scalar(Scalar::from_int(i, layout.size), layout)\n+    }\n+\n     #[inline]\n     pub fn to_bits(self) -> InterpResult<'tcx, u128> {\n         self.to_scalar()?.to_bits(self.layout.size)\n@@ -246,7 +255,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let ptr = match self.check_mplace_access(mplace, None)? {\n+        let ptr = match self.check_mplace_access(mplace, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Scalar::zst().into(),\n@@ -511,7 +522,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => self.eval_const_to_op(constant.literal, layout)?,\n+            Constant(ref constant) => {\n+                let val = self.subst_from_frame_and_normalize_erasing_regions(constant.literal);\n+                self.eval_const_to_op(val, layout)?\n+            }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -529,6 +543,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     // Used when the miri-engine runs into a constant and for extracting information from constants\n     // in patterns via the `const_eval` module\n+    /// The `val` and `layout` are assumed to already be in our interpreter\n+    /// \"universe\" (param_env).\n     crate fn eval_const_to_op(\n         &self,\n         val: &'tcx ty::Const<'tcx>,\n@@ -541,7 +557,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         match val.val {\n             ConstValue::Param(_) =>\n-                // FIXME(oli-obk): try to monomorphize\n                 throw_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n@@ -554,7 +569,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // Other cases need layout.\n         let layout = from_known_layout(layout, || {\n-            self.layout_of(self.monomorphize(val.ty)?)\n+            self.layout_of(val.ty)\n         })?;\n         let op = match val.val {\n             ConstValue::ByRef { alloc, offset } => {"}, {"sha": "470cc9346ee21407593440891d21eecdbef0a108", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 74, "deletions": 49, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout};\n+use rustc::ty::{self, Ty, layout::{TyLayout, LayoutOf}};\n use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{InterpResult, Scalar};\n@@ -17,7 +17,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, overflowed) = self.binary_op(op, left, right)?;\n+        let (val, overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        debug_assert_eq!(\n+            self.tcx.intern_tup(&[ty, self.tcx.types.bool]),\n+            dest.layout.ty,\n+            \"type mismatch for result of {:?}\", op,\n+        );\n         let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_immediate(val, dest)\n     }\n@@ -31,7 +36,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op(op, left, right)?;\n+        let (val, _overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        assert_eq!(ty, dest.layout.ty, \"type mismatch for result of {:?}\", op);\n         self.write_scalar(val, dest)\n     }\n }\n@@ -42,7 +48,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -54,15 +60,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ge => l >= r,\n             _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false);\n+        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n     }\n \n     fn binary_bool_op(\n         &self,\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -77,32 +83,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             BitXor => l ^ r,\n             _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false);\n+        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n     }\n \n     fn binary_float_op<F: Float + Into<Scalar<M::PointerTag>>>(\n         &self,\n         bin_op: mir::BinOp,\n+        ty: Ty<'tcx>,\n         l: F,\n         r: F,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n-        let val = match bin_op {\n-            Eq => Scalar::from_bool(l == r),\n-            Ne => Scalar::from_bool(l != r),\n-            Lt => Scalar::from_bool(l < r),\n-            Le => Scalar::from_bool(l <= r),\n-            Gt => Scalar::from_bool(l > r),\n-            Ge => Scalar::from_bool(l >= r),\n-            Add => (l + r).value.into(),\n-            Sub => (l - r).value.into(),\n-            Mul => (l * r).value.into(),\n-            Div => (l / r).value.into(),\n-            Rem => (l % r).value.into(),\n+        let (val, ty) = match bin_op {\n+            Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n+            Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n+            Lt => (Scalar::from_bool(l < r), self.tcx.types.bool),\n+            Le => (Scalar::from_bool(l <= r), self.tcx.types.bool),\n+            Gt => (Scalar::from_bool(l > r), self.tcx.types.bool),\n+            Ge => (Scalar::from_bool(l >= r), self.tcx.types.bool),\n+            Add => ((l + r).value.into(), ty),\n+            Sub => ((l - r).value.into(), ty),\n+            Mul => ((l * r).value.into(), ty),\n+            Div => ((l / r).value.into(), ty),\n+            Rem => ((l % r).value.into(), ty),\n             _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n         };\n-        return (val, false);\n+        return (val, false, ty);\n     }\n \n     fn binary_int_op(\n@@ -113,7 +120,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         left_layout: TyLayout<'tcx>,\n         r: u128,\n         right_layout: TyLayout<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         use rustc::mir::BinOp::*;\n \n         // Shift ops can have an RHS with a different numeric type.\n@@ -142,7 +149,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);\n-            return Ok((Scalar::from_uint(truncated, size), oflo));\n+            return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n         }\n \n         // For the remaining ops, the types must be the same on both sides\n@@ -167,7 +174,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(op) = op {\n                 let l = self.sign_extend(l, left_layout) as i128;\n                 let r = self.sign_extend(r, right_layout) as i128;\n-                return Ok((Scalar::from_bool(op(&l, &r)), false));\n+                return Ok((Scalar::from_bool(op(&l, &r)), false, self.tcx.types.bool));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n                 Div if r == 0 => throw_panic!(DivisionByZero),\n@@ -187,7 +194,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::from_uint(l, size), true));\n+                            return Ok((Scalar::from_uint(l, size), true, left_layout.ty));\n                         }\n                     },\n                     _ => {},\n@@ -202,25 +209,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // this may be out-of-bounds for the result type, so we have to truncate ourselves\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo));\n+                return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n             }\n         }\n \n         let size = left_layout.size;\n \n-        // only ints left\n-        let val = match bin_op {\n-            Eq => Scalar::from_bool(l == r),\n-            Ne => Scalar::from_bool(l != r),\n+        let (val, ty) = match bin_op {\n+            Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n+            Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n \n-            Lt => Scalar::from_bool(l < r),\n-            Le => Scalar::from_bool(l <= r),\n-            Gt => Scalar::from_bool(l > r),\n-            Ge => Scalar::from_bool(l >= r),\n+            Lt => (Scalar::from_bool(l < r), self.tcx.types.bool),\n+            Le => (Scalar::from_bool(l <= r), self.tcx.types.bool),\n+            Gt => (Scalar::from_bool(l > r), self.tcx.types.bool),\n+            Ge => (Scalar::from_bool(l >= r), self.tcx.types.bool),\n \n-            BitOr => Scalar::from_uint(l | r, size),\n-            BitAnd => Scalar::from_uint(l & r, size),\n-            BitXor => Scalar::from_uint(l ^ r, size),\n+            BitOr => (Scalar::from_uint(l | r, size), left_layout.ty),\n+            BitAnd => (Scalar::from_uint(l & r, size), left_layout.ty),\n+            BitXor => (Scalar::from_uint(l ^ r, size), left_layout.ty),\n \n             Add | Sub | Mul | Rem | Div => {\n                 debug_assert!(!left_layout.abi.is_signed());\n@@ -236,7 +242,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo || truncated != result));\n+                return Ok((\n+                    Scalar::from_uint(truncated, size),\n+                    oflo || truncated != result,\n+                    left_layout.ty,\n+                ));\n             }\n \n             _ => {\n@@ -250,17 +260,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n-        Ok((val, false))\n+        Ok((val, false, ty))\n     }\n \n-    /// Returns the result of the specified operation and whether it overflowed.\n-    #[inline]\n-    pub fn binary_op(\n+    /// Returns the result of the specified operation, whether it overflowed, and\n+    /// the result type.\n+    pub fn overflowing_binary_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n@@ -279,11 +289,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ty::Float(fty) => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n+                let ty = left.layout.ty;\n                 let left = left.to_scalar()?;\n                 let right = right.to_scalar()?;\n                 Ok(match fty {\n-                    FloatTy::F32 => self.binary_float_op(bin_op, left.to_f32()?, right.to_f32()?),\n-                    FloatTy::F64 => self.binary_float_op(bin_op, left.to_f64()?, right.to_f64()?),\n+                    FloatTy::F32 =>\n+                        self.binary_float_op(bin_op, ty, left.to_f32()?, right.to_f32()?),\n+                    FloatTy::F64 =>\n+                        self.binary_float_op(bin_op, ty, left.to_f64()?, right.to_f64()?),\n                 })\n             }\n             _ if left.layout.ty.is_integral() => {\n@@ -312,11 +325,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Typed version of `checked_binary_op`, returning an `ImmTy`. Also ignores overflows.\n+    #[inline]\n+    pub fn binary_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: ImmTy<'tcx, M::PointerTag>,\n+        right: ImmTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        let (val, _overflow, ty) = self.overflowing_binary_op(bin_op, left, right)?;\n+        Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n+    }\n+\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n         val: ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n \n         let layout = val.layout;\n@@ -330,15 +355,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Not => !val,\n                     _ => bug!(\"Invalid bool op {:?}\", un_op)\n                 };\n-                Ok(Scalar::from_bool(res))\n+                Ok(ImmTy::from_scalar(Scalar::from_bool(res), self.layout_of(self.tcx.types.bool)?))\n             }\n             ty::Float(fty) => {\n                 let res = match (un_op, fty) {\n                     (Neg, FloatTy::F32) => Scalar::from_f32(-val.to_f32()?),\n                     (Neg, FloatTy::F64) => Scalar::from_f64(-val.to_f64()?),\n                     _ => bug!(\"Invalid float op {:?}\", un_op)\n                 };\n-                Ok(res)\n+                Ok(ImmTy::from_scalar(res, layout))\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());\n@@ -351,7 +376,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 // res needs tuncating\n-                Ok(Scalar::from_uint(self.truncate(res, layout), layout.size))\n+                Ok(ImmTy::from_uint(self.truncate(res, layout), layout))\n             }\n         }\n     }"}, {"sha": "85f9cbd37589ab2260f0d66211e44d5539759128", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -45,7 +45,7 @@ pub enum Place<Tag=(), Id=AllocId> {\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag=()> {\n-    place: Place<Tag>,\n+    place: Place<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -277,6 +277,10 @@ where\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    ///\n+    /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n+    /// want to ever use the place for memory access!\n+    /// Generally prefer `deref_operand`.\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n@@ -304,7 +308,8 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        self.ref_to_mplace(val)\n+        let place = self.ref_to_mplace(val)?;\n+        self.mplace_access_checked(place)\n     }\n \n     /// Check if the given place is good for memory access with the given\n@@ -327,6 +332,23 @@ where\n         self.memory.check_ptr_access(place.ptr, size, place.align)\n     }\n \n+    /// Return the \"access-checked\" version of this `MPlace`, where for non-ZST\n+    /// this is definitely a `Pointer`.\n+    pub fn mplace_access_checked(\n+        &self,\n+        mut place: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let (size, align) = self.size_and_align_of_mplace(place)?\n+            .unwrap_or((place.layout.size, place.layout.align.abi));\n+        assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n+        place.mplace.align = align; // maximally strict checking\n+        // When dereferencing a pointer, it must be non-NULL, aligned, and live.\n+        if let Some(ptr) = self.check_mplace_access(place, Some(size))? {\n+            place.mplace.ptr = ptr.into();\n+        }\n+        Ok(place)\n+    }\n+\n     /// Force `place.ptr` to a `Pointer`.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n     pub fn force_mplace_ptr(\n@@ -618,8 +640,11 @@ where\n                         // their layout on return.\n                         PlaceTy {\n                             place: *return_place,\n-                            layout: self\n-                                .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n+                            layout: self.layout_of(\n+                                self.subst_from_frame_and_normalize_erasing_regions(\n+                                    self.frame().body.return_ty()\n+                                )\n+                            )?,\n                         }\n                     }\n                     None => throw_unsup!(InvalidNullPointerUsage),\n@@ -750,7 +775,9 @@ where\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n-        let ptr = match self.check_mplace_access(dest, None)? {\n+        let ptr = match self.check_mplace_access(dest, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n         };\n@@ -853,8 +880,10 @@ where\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        let src = self.check_mplace_access(src, Some(size))?;\n-        let dest = self.check_mplace_access(dest, Some(size))?;\n+        let src = self.check_mplace_access(src, Some(size))\n+            .expect(\"places should be checked on creation\");\n+        let dest = self.check_mplace_access(dest, Some(size))\n+            .expect(\"places should be checked on creation\");\n         let (src_ptr, dest_ptr) = match (src, dest) {\n             (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n             (None, None) => return Ok(()), // zero-sized copy"}, {"sha": "ca4da451a1f2d58f9f57879c683073b107fcb980", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -177,7 +177,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n                 let val = self.unary_op(un_op, val)?;\n-                self.write_scalar(val, dest)?;\n+                assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n+                self.write_immediate(*val, dest)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n@@ -240,16 +241,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?;\n-                self.write_immediate(val.to_ref(), dest)?;\n+                let place = self.force_allocation(src)?;\n+                if place.layout.size.bytes() > 0 {\n+                    // definitely not a ZST\n+                    assert!(place.ptr.is_ptr(), \"non-ZST places should be normalized to `Pointer`\");\n+                }\n+                self.write_immediate(place.to_ref(), dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {\n                 M::box_alloc(self, dest)?;\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(ty)?;\n+                let ty = self.subst_from_frame_and_normalize_erasing_regions(ty);\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");"}, {"sha": "5de297923ce7bfa4e7060328939acd040d3123c6", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -7,7 +7,7 @@ use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    InterpResult, PointerArithmetic, Scalar,\n+    InterpResult, PointerArithmetic,\n     InterpCx, Machine, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n@@ -50,11 +50,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op, to also support pointer values\n-                    let const_int = Scalar::from_uint(const_int, discr.layout.size);\n-                    let (res, _) = self.binary_op(mir::BinOp::Eq,\n+                    let res = self.overflowing_binary_op(mir::BinOp::Eq,\n                         discr,\n-                        ImmTy::from_scalar(const_int, discr.layout),\n-                    )?;\n+                        ImmTy::from_uint(const_int, discr.layout),\n+                    )?.0;\n                     if res.to_bool()? {\n                         target_block = targets[index];\n                         break;"}, {"sha": "a2fc75739ffa0ae34ffe672fb06c6c395a483fbf", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, Instance};\n+use rustc::ty::{self, Ty, Instance, TypeFoldable};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic,};\n \n@@ -20,6 +20,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n+        // All vtables must be monomorphic, bail out otherwise.\n+        if ty.needs_subst() || poly_trait_ref.needs_subst() {\n+            throw_inval!(TooGeneric);\n+        }\n+\n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n             // This means we guarantee that there are no duplicate vtables, we will\n             // always use the same vtable for the same (Type, Trait) combination.\n@@ -77,7 +82,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n-                let substs = self.subst_and_normalize_erasing_regions(substs)?;\n                 let instance = ty::Instance::resolve_for_vtable(\n                     *self.tcx,\n                     self.param_env,"}, {"sha": "3e02f6c3725fdba6e48f359b88de5daea397a73c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -445,7 +445,6 @@ impl CloneShimBuilder<'tcx> {\n         let func_ty = tcx.mk_fn_def(self.def_id, substs);\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n-            ty: func_ty,\n             user_ty: None,\n             literal: ty::Const::zero_sized(tcx, func_ty),\n         });\n@@ -505,7 +504,6 @@ impl CloneShimBuilder<'tcx> {\n     fn make_usize(&self, value: u64) -> Box<Constant<'tcx>> {\n         box Constant {\n             span: self.span,\n-            ty: self.tcx.types.usize,\n             user_ty: None,\n             literal: ty::Const::from_usize(self.tcx, value),\n         }\n@@ -710,7 +708,7 @@ fn build_call_shim<'tcx>(\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n-            assert!(arg_ty.is_self());\n+            debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n             Operand::Move(rcvr_l.deref())\n@@ -745,7 +743,6 @@ fn build_call_shim<'tcx>(\n             let ty = tcx.type_of(def_id);\n             (Operand::Constant(box Constant {\n                 span,\n-                ty,\n                 user_ty: None,\n                 literal: ty::Const::zero_sized(tcx, ty),\n              }),"}, {"sha": "524a19e3434f3c8f3f8b0ace4862113517db23b1", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -42,9 +42,8 @@ fn is_stable(\n     }\n }\n \n-/// Determine whether this type may have a reference in it, recursing below compound types but\n-/// not below references.\n-fn may_have_reference<'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n+/// Determine whether this type may be a reference (or box), and thus needs retagging.\n+fn may_be_reference<'tcx>(ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n@@ -55,15 +54,12 @@ fn may_have_reference<'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n         // References\n         ty::Ref(..) => true,\n         ty::Adt(..) if ty.is_box() => true,\n-        // Compound types\n-        ty::Array(ty, ..) | ty::Slice(ty) =>\n-            may_have_reference(ty, tcx),\n-        ty::Tuple(tys) =>\n-            tys.iter().any(|ty| may_have_reference(ty.expect_ty(), tcx)),\n-        ty::Adt(adt, substs) =>\n-            adt.variants.iter().any(|v| v.fields.iter().any(|f|\n-                may_have_reference(f.ty(tcx, substs), tcx)\n-            )),\n+        // Compound types are not references\n+        ty::Array(..) |\n+        ty::Slice(..) |\n+        ty::Tuple(..) |\n+        ty::Adt(..) =>\n+            false,\n         // Conservative fallback\n         _ => true,\n     }\n@@ -80,7 +76,7 @@ impl MirPass for AddRetag {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n             is_stable(place.as_ref())\n-                && may_have_reference(place.ty(&*local_decls, tcx).ty, tcx)\n+                && may_be_reference(place.ty(&*local_decls, tcx).ty)\n         };\n \n         // PART 1"}, {"sha": "98d8ca58ee1647d671f0baf1305f71cf17153167", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::layout::{\n-    LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout, Size,\n+    LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n use crate::interpret::{\n@@ -396,30 +396,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 if let ty::Slice(_) = mplace.layout.ty.sty {\n                     let len = mplace.meta.unwrap().to_usize(&self.ecx).unwrap();\n \n-                    Some(ImmTy {\n-                        imm: Immediate::Scalar(\n-                            Scalar::from_uint(\n-                                len,\n-                                Size::from_bits(\n-                                    self.tcx.sess.target.usize_ty.bit_width().unwrap() as u64\n-                                )\n-                            ).into(),\n-                        ),\n-                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into())\n+                    Some(ImmTy::from_uint(\n+                        len,\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ).into())\n                 } else {\n                     trace!(\"not slice: {:?}\", mplace.layout.ty.sty);\n                     None\n                 }\n             },\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n-                    ImmTy {\n-                        imm: Immediate::Scalar(\n-                            Scalar::from_uint(n, self.tcx.data_layout.pointer_size).into()\n-                        ),\n-                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into()\n+                    ImmTy::from_uint(\n+                        n,\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ).into()\n                 ))\n             }\n             Rvalue::UnaryOp(op, ref arg) => {\n@@ -452,11 +443,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // Now run the actual operation.\n                     this.ecx.unary_op(op, prim)\n                 })?;\n-                let res = ImmTy {\n-                    imm: Immediate::Scalar(val.into()),\n-                    layout: place_layout,\n-                };\n-                Some(res.into())\n+                Some(val.into())\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -510,8 +497,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     this.ecx.read_immediate(left)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n-                let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, r)\n+                let (val, overflow, _ty) = self.use_ecx(source_info, |this| {\n+                    this.ecx.overflowing_binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Immediate::ScalarPair(\n@@ -539,7 +526,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Operand::Constant(Box::new(\n             Constant {\n                 span,\n-                ty,\n                 user_ty: None,\n                 literal: self.tcx.mk_const(*ty::Const::from_scalar(\n                     self.tcx,"}, {"sha": "4480d1e0a05b85ce882bc1dc27171552739a5cc2", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -527,7 +527,6 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n-            ty: self.tcx.types.bool,\n             user_ty: None,\n             literal: ty::Const::from_bool(self.tcx, val),\n         })))"}, {"sha": "f6941880240316ad55507409437844938fb52828", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -975,7 +975,6 @@ fn insert_panic_block<'tcx>(\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n             span: body.span,\n-            ty: tcx.types.bool,\n             user_ty: None,\n             literal: ty::Const::from_bool(tcx, false),\n         }),"}, {"sha": "bc7bd39be488e35684356634eb789a289607f23c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -328,7 +328,7 @@ impl Inliner<'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::FnDef(def_id, _) = f.ty.sty {\n+                    if let ty::FnDef(def_id, _) = f.literal.ty.sty {\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {"}, {"sha": "b2d063a1f4e10392291c04ca0f3d3dbaa7f47954", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -97,8 +97,7 @@ impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n             let place_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n             if let ty::Array(_, len) = place_ty.sty {\n                 let span = self.body.source_info(location).span;\n-                let ty = self.tcx.types.usize;\n-                let constant = Constant { span, ty, literal: len, user_ty: None };\n+                let constant = Constant { span, literal: len, user_ty: None };\n                 self.optimizations.arrays_lengths.insert(location, constant);\n             }\n         }"}, {"sha": "649cccc36c346e88c9542912250db9762bdd9c02", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -249,7 +249,7 @@ trait Qualif {\n                 if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n                     // Don't peek inside trait associated constants.\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n-                        Self::in_any_value_of_ty(cx, constant.ty).unwrap_or(false)\n+                        Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n                     } else {\n                         let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n@@ -258,7 +258,7 @@ trait Qualif {\n                         // Just in case the type is more specific than\n                         // the definition, e.g., impl associated const\n                         // with type parameters, take it into account.\n-                        qualif && Self::mask_for_ty(cx, constant.ty)\n+                        qualif && Self::mask_for_ty(cx, constant.literal.ty)\n                     }\n                 } else {\n                     false\n@@ -537,9 +537,9 @@ impl Qualif for IsNotPromotable {\n                             | \"cttz_nonzero\"\n                             | \"ctlz\"\n                             | \"ctlz_nonzero\"\n-                            | \"overflowing_add\"\n-                            | \"overflowing_sub\"\n-                            | \"overflowing_mul\"\n+                            | \"wrapping_add\"\n+                            | \"wrapping_sub\"\n+                            | \"wrapping_mul\"\n                             | \"unchecked_shl\"\n                             | \"unchecked_shr\"\n                             | \"rotate_left\""}, {"sha": "334d0cee9fbe7412a7e401c9e8afbf963c151f61", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -379,9 +379,9 @@ fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n         | \"add_with_overflow\" // ~> .overflowing_add\n         | \"sub_with_overflow\" // ~> .overflowing_sub\n         | \"mul_with_overflow\" // ~> .overflowing_mul\n-        | \"overflowing_add\" // ~> .wrapping_add\n-        | \"overflowing_sub\" // ~> .wrapping_sub\n-        | \"overflowing_mul\" // ~> .wrapping_mul\n+        | \"wrapping_add\" // ~> .wrapping_add\n+        | \"wrapping_sub\" // ~> .wrapping_sub\n+        | \"wrapping_mul\" // ~> .wrapping_mul\n         | \"saturating_add\" // ~> .saturating_add\n         | \"saturating_sub\" // ~> .saturating_sub\n         | \"unchecked_shl\" // ~> .wrapping_shl"}, {"sha": "598de3a77e61c22ce6745325bc62b45b5aba46b9", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -224,7 +224,7 @@ fn is_rustc_peek<'a, 'tcx>(\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n             if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::FnDef(def_id, _) = func.ty.sty {\n+                if let ty::FnDef(def_id, _) = func.literal.ty.sty {\n                     let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic && name == sym::rustc_peek {"}, {"sha": "c5561a1ae0d1548215fc2d803078f95bbeb689fc", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -970,7 +970,6 @@ where\n     fn constant_usize(&self, val: u16) -> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n-            ty: self.tcx().types.usize,\n             user_ty: None,\n             literal: ty::Const::from_usize(self.tcx(), val.into()),\n         })"}, {"sha": "ac2701971dfd55e369228d51ea08812c3f0b54e0", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -397,10 +397,9 @@ impl ExtraComments<'tcx> {\n impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        let Constant { span, ty, user_ty, literal } = constant;\n+        let Constant { span, user_ty, literal } = constant;\n         self.push(\"mir::Constant\");\n         self.push(&format!(\"+ span: {:?}\", span));\n-        self.push(&format!(\"+ ty: {:?}\", ty));\n         if let Some(user_ty) = user_ty {\n             self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n         }"}, {"sha": "bd46ca4779a430fb56bc5a9bbfae1e9499bfa275", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -602,7 +602,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }\n                 }\n@@ -824,7 +824,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             |this| visit::walk_enum_def(this, enum_definition, generics, item_id))\n     }\n \n-    fn visit_mac(&mut self, mac: &Spanned<Mac_>) {\n+    fn visit_mac(&mut self, mac: &Mac) {\n         // when a new macro kind is added but the author forgets to set it up for expansion\n         // because that's the only part that won't cause a compiler error\n         self.session.diagnostic()"}, {"sha": "1547e607b9c61a2842471530b9025d72e2195023", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::TyCtxt;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Node, Destination};\n+use rustc::hir::{self, Node, Destination, GeneratorMovability};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use errors::Applicability;\n@@ -17,6 +17,7 @@ enum Context {\n     Normal,\n     Loop(hir::LoopSource),\n     Closure,\n+    AsyncClosure,\n     LabeledBlock,\n     AnonConst,\n }\n@@ -57,9 +58,14 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n-            hir::ExprKind::Closure(_, ref function_decl, b, _, _) => {\n+            hir::ExprKind::Closure(_, ref function_decl, b, _, movability) => {\n+                let cx = if let Some(GeneratorMovability::Static) = movability {\n+                    AsyncClosure\n+                } else {\n+                    Closure\n+                };\n                 self.visit_fn_decl(&function_decl);\n-                self.with_context(Closure, |v| v.visit_nested_body(b));\n+                self.with_context(cx, |v| v.visit_nested_body(b));\n             }\n             hir::ExprKind::Block(ref b, Some(_label)) => {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n@@ -171,6 +177,11 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n                 .span_label(span, \"cannot break inside of a closure\")\n                 .emit();\n             }\n+            AsyncClosure => {\n+                struct_span_err!(self.sess, span, E0267, \"`{}` inside of an async block\", name)\n+                    .span_label(span, \"cannot break inside of an async block\")\n+                    .emit();\n+            }\n             Normal | AnonConst => {\n                 struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n                 .span_label(span, \"cannot break outside of a loop\")"}, {"sha": "84a743ed1ad7d0d11752f3237463a4106a401dcf", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,12 +1,12 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_plugin\"\n+name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n build = false\n edition = \"2018\"\n \n [lib]\n-name = \"rustc_plugin\"\n+name = \"rustc_plugin_impl\"\n path = \"lib.rs\"\n doctest = false\n "}, {"sha": "cc75f7b9ab20d1e8e20a20c3af6cd46539307554", "filename": "src/librustc_plugin/deprecated/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+build = false\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_plugin\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+rustc_plugin_impl = { path = \"..\" }"}, {"sha": "1d0afe84c25a89913ea844f143836a2e063a4903", "filename": "src/librustc_plugin/deprecated/lib.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,8 @@\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(staged_api)]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![rustc_deprecated(since = \"1.38.0\", reason = \"\\\n+    import this through `rustc_driver::plugin` instead to make TLS work correctly. \\\n+    See https://github.com/rust-lang/rust/issues/62717\")]\n+\n+pub use rustc_plugin_impl::*;"}, {"sha": "952bc9fff6a712dd436918856740606270066a18", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -16,12 +16,11 @@\n //! #![feature(plugin_registrar)]\n //! #![feature(rustc_private)]\n //!\n-//! extern crate rustc_plugin;\n //! extern crate rustc_driver;\n //! extern crate syntax;\n //! extern crate syntax_pos;\n //!\n-//! use rustc_plugin::Registry;\n+//! use rustc_driver::plugin::Registry;\n //! use syntax::ext::base::{ExtCtxt, MacResult};\n //! use syntax_pos::Span;\n //! use syntax::tokenstream::TokenTree;"}, {"sha": "bca77621e553ed304bce307b2e90ed9e5045bb73", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -687,11 +687,11 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    let variant_level = self.update(variant.node.id, item_level);\n-                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+                    let variant_level = self.update(variant.id, item_level);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n                         self.update(ctor_hir_id, item_level);\n                     }\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.update(field.hir_id, variant_level);\n                     }\n                 }\n@@ -810,9 +810,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    let variant_level = self.get(variant.node.id);\n+                    let variant_level = self.get(variant.id);\n                     if variant_level.is_some() {\n-                        for field in variant.node.data.fields() {\n+                        for field in variant.data.fields() {\n                             self.reach(field.hir_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n@@ -1075,8 +1075,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_res(res);\n                 for field in fields {\n-                    let use_ctxt = field.node.ident.span;\n-                    let index = self.tcx.field_index(field.node.hir_id, self.tables);\n+                    let use_ctxt = field.ident.span;\n+                    let index = self.tcx.field_index(field.hir_id, self.tables);\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                 }\n             }\n@@ -1647,7 +1647,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        if self.access_levels.is_reachable(v.node.id) {\n+        if self.access_levels.is_reachable(v.id) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n@@ -1898,7 +1898,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.check(field.hir_id, item_visibility).ty();\n                     }\n                 }"}, {"sha": "42428456b6eec39de4c2640a129c0428714a18c4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,9 +1,11 @@\n-//! Reduced graph building.\n+//! After we obtain a fresh AST fragment from a macro, code in this module helps to integrate\n+//! that fragment into the module structures that are already partially built.\n //!\n-//! Here we build the \"reduced graph\": the graph of the module tree without\n-//! any imports resolved.\n+//! Items from the fragment are placed into modules,\n+//! unexpanded macros in the fragment are visited and registered.\n+//! Imports are also considered items and placed into modules here, but not resolved yet.\n \n-use crate::macros::{InvocationData, LegacyBinding, LegacyScope};\n+use crate::macros::{LegacyBinding, LegacyScope};\n use crate::resolve_imports::ImportDirective;\n use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n@@ -14,6 +16,7 @@ use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n use rustc::bug;\n use rustc::hir::def::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::map::DefCollector;\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n@@ -30,6 +33,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::expand::AstFragment;\n use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n@@ -67,7 +71,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId) {\n     }\n }\n \n-pub(crate) struct IsMacroExport;\n+struct IsMacroExport;\n \n impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n@@ -84,7 +88,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport\n impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    pub fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+    crate fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n@@ -93,7 +97,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+    crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n         if def_id.krate == LOCAL_CRATE {\n             return self.module_map[&def_id]\n         }\n@@ -119,7 +123,7 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+    crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         let def_id = match self.macro_defs.get(&expn_id) {\n             Some(def_id) => *def_id,\n             None => return self.graph_root,\n@@ -141,7 +145,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return Some(ext.clone());\n         }\n@@ -156,23 +160,45 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n-        if module.populated.get() { return }\n-        let def_id = module.def_id().unwrap();\n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n+    crate fn build_reduced_graph(\n+        &mut self,\n+        fragment: &AstFragment,\n+        extra_placeholders: &[NodeId],\n+        parent_scope: ParentScope<'a>,\n+    ) -> LegacyScope<'a> {\n+        let mut def_collector = DefCollector::new(&mut self.definitions, parent_scope.expansion);\n+        fragment.visit_with(&mut def_collector);\n+        for placeholder in extra_placeholders {\n+            def_collector.visit_macro_invoc(*placeholder);\n+        }\n+\n+        let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n+        fragment.visit_with(&mut visitor);\n+        for placeholder in extra_placeholders {\n+            visitor.parent_scope.legacy = visitor.visit_invoc(*placeholder);\n+        }\n+\n+        visitor.parent_scope.legacy\n+    }\n+\n+    crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n+        let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n         for child in self.cstore.item_children_untracked(def_id, self.session) {\n             let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            BuildReducedGraphVisitor { parent_scope: self.dummy_parent_scope(), r: self }\n-                .build_reduced_graph_for_external_crate_res(module, child);\n+            BuildReducedGraphVisitor { r: self, parent_scope: ParentScope::module(module) }\n+                .build_reduced_graph_for_external_crate_res(child);\n         }\n-        module.populated.set(true)\n     }\n }\n \n-pub struct BuildReducedGraphVisitor<'a, 'b> {\n-    pub r: &'b mut Resolver<'a>,\n-    pub parent_scope: ParentScope<'a>,\n+struct BuildReducedGraphVisitor<'a, 'b> {\n+    r: &'b mut Resolver<'a>,\n+    parent_scope: ParentScope<'a>,\n+}\n+\n+impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self.r }\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n@@ -300,10 +326,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         root_id: NodeId,\n         vis: ty::Visibility,\n     ) {\n-        let parent_scope = &self.parent_scope;\n-        let current_module = parent_scope.module;\n+        let current_module = self.parent_scope.module;\n         let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n-            parent_scope: parent_scope.clone(),\n+            parent_scope: self.parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n             subclass,\n@@ -593,15 +618,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                self.r.populate_module_if_necessary(module);\n-\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n                 let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent_scope: self.parent_scope.clone(),\n+                    parent_scope: self.parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -706,7 +729,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n-                    self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n+                    self.build_reduced_graph_for_variant(variant, module, vis);\n                 }\n             }\n \n@@ -797,19 +820,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        parent: Module<'a>,\n-                                       vis: ty::Visibility,\n-                                       expn_id: ExpnId) {\n-        let ident = variant.node.ident;\n+                                       vis: ty::Visibility) {\n+        let expn_id = self.parent_scope.expansion;\n+        let ident = variant.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.r.definitions.local_def_id(variant.node.id);\n+        let def_id = self.r.definitions.local_def_id(variant.id);\n         let res = Res::Def(DefKind::Variant, def_id);\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, sym::non_exhaustive);\n+        let has_non_exhaustive = attr::contains_name(&variant.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n@@ -819,9 +842,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // value namespace, they are reserved for possible future use.\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n-        let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n+        let ctor_node_id = variant.data.ctor_id().unwrap_or(variant.id);\n         let ctor_def_id = self.r.definitions.local_def_id(ctor_node_id);\n-        let ctor_kind = CtorKind::from_ast(&variant.node.data);\n+        let ctor_kind = CtorKind::from_ast(&variant.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n         self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n     }\n@@ -861,91 +884,75 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(\n-        &mut self,\n-        parent: Module<'a>,\n-        child: Export<ast::NodeId>,\n-    ) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n+        let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n         // but metadata cannot encode gensyms currently, so we create it here.\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n+        // Record primary definitions.\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n-            | Res::Def(kind @ DefKind::Enum, def_id) => {\n+            | Res::Def(kind @ DefKind::Enum, def_id)\n+            | Res::Def(kind @ DefKind::Trait, def_id) => {\n                 let module = self.r.new_module(parent,\n                                              ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n                 self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Res::Def(DefKind::Variant, _)\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n             | Res::Def(DefKind::ForeignTy, _)\n             | Res::Def(DefKind::OpaqueTy, _)\n             | Res::Def(DefKind::TraitAlias, _)\n+            | Res::Def(DefKind::AssocTy, _)\n+            | Res::Def(DefKind::AssocOpaqueTy, _)\n             | Res::PrimTy(..)\n-            | Res::ToolMod => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-            }\n+            | Res::ToolMod =>\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion)),\n             Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::Method, _)\n             | Res::Def(DefKind::Static, _)\n             | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-            }\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-\n-                if let Some(struct_def_id) =\n-                        self.r.cstore.def_key(def_id).parent\n-                            .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n-                }\n-            }\n-            Res::Def(DefKind::Trait, def_id) => {\n-                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.r.new_module(parent,\n-                                             module_kind,\n-                                             parent.normal_ancestor_id,\n-                                             expansion,\n-                                             span);\n-                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n-\n-                for child in self.r.cstore.item_children_untracked(def_id, self.r.session) {\n-                    let res = child.res.map_id(|_| panic!(\"unexpected id\"));\n-                    let ns = if let Res::Def(DefKind::AssocTy, _) = res {\n-                        TypeNS\n-                    } else { ValueNS };\n-                    self.r.define(module, child.ident, ns,\n-                                (res, ty::Visibility::Public, DUMMY_SP, expansion));\n-\n-                    if self.r.cstore.associated_item_cloned_untracked(child.res.def_id())\n-                           .method_has_self_argument {\n-                        self.r.has_self.insert(res.def_id());\n-                    }\n-                }\n-                module.populated.set(true);\n-            }\n+            | Res::Def(DefKind::AssocConst, _)\n+            | Res::Def(DefKind::Ctor(..), _) =>\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::Macro(..), _)\n+            | Res::NonMacroAttr(..) =>\n+                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::TyParam, _) | Res::Def(DefKind::ConstParam, _)\n+            | Res::Local(..) | Res::SelfTy(..) | Res::SelfCtor(..) | Res::Err =>\n+                bug!(\"unexpected resolution: {:?}\", res)\n+        }\n+        // Record some extra data for better diagnostics.\n+        match res {\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-\n-                // Record field names for error reporting.\n                 let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n-            Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Method, def_id) => {\n+                if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                    self.r.has_self.insert(def_id);\n+                }\n+            }\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n+                let parent = self.r.cstore.def_key(def_id).parent;\n+                if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n+                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n+                }\n             }\n-            _ => bug!(\"unexpected resolution: {:?}\", res)\n+            _ => {}\n         }\n     }\n \n     fn legacy_import_macro(&mut self,\n-                           name: Name,\n+                           name: ast::Name,\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n@@ -997,7 +1004,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 |this: &Self, span| this.r.arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent_scope: this.parent_scope.clone(),\n+            parent_scope: this.parent_scope,\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             use_span_with_attributes: item.span_with_attributes(),\n@@ -1014,9 +1021,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         if let Some(span) = import_all {\n             let directive = macro_use_directive(self, span);\n             self.r.potentially_unused_imports.push(directive);\n-            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n-                let imported_binding = self.r.import(binding, directive);\n-                self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n+            module.for_each_child(self, |this, ident, ns, binding| if ns == MacroNS {\n+                let imported_binding = this.r.import(binding, directive);\n+                this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {\n@@ -1066,20 +1073,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> &'a InvocationData<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n-        let invocation_data = self.r.arenas.alloc_invocation_data(InvocationData {\n-            module: self.parent_scope.module,\n-            parent_legacy_scope: self.parent_scope.legacy,\n-            output_legacy_scope: Cell::new(None),\n-        });\n-        let old_invocation_data = self.r.invocations.insert(invoc_id, invocation_data);\n-        assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n+        let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n+        assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        invocation_data\n+        LegacyScope::Invocation(invoc_id)\n     }\n \n     fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n@@ -1180,7 +1182,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(item.id));\n+                self.parent_scope.legacy = self.visit_invoc(item.id);\n                 return\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n@@ -1199,7 +1201,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n+            self.parent_scope.legacy = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1267,9 +1269,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            self.parent_scope.module.builtin_attrs.borrow_mut().push((\n-                attr.path.segments[0].ident, self.parent_scope.clone()\n-            ));\n+            self.r.builtin_attrs.push((attr.path.segments[0].ident, self.parent_scope));\n         }\n         visit::walk_attribute(self, attr);\n     }"}, {"sha": "b79e0c2bd3b2672257f12aacd1cbc652b7a86fad", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -73,20 +73,23 @@ crate fn add_typo_suggestion(\n     false\n }\n \n-crate fn add_module_candidates(\n-    module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n-) {\n-    for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n-        if let Some(binding) = resolution.borrow().binding {\n-            let res = binding.res();\n-            if filter_fn(res) {\n-                names.push(TypoSuggestion::from_res(ident.name, res));\n+impl<'a> Resolver<'a> {\n+    crate fn add_module_candidates(\n+        &mut self,\n+        module: Module<'a>,\n+        names: &mut Vec<TypoSuggestion>,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) {\n+        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+            if let Some(binding) = resolution.borrow().binding {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                }\n             }\n         }\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     /// Combines an error with provided span and emits it.\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n@@ -166,12 +169,14 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n-                let mut err = struct_span_err!(self.session,\n-                                                span,\n-                                                E0403,\n-                                                \"the name `{}` is already used for a generic \\\n-                                                parameter in this list of generic parameters\",\n-                                                name);\n+                let mut err = struct_span_err!(\n+                    self.session,\n+                    span,\n+                    E0403,\n+                    \"the name `{}` is already used for a generic \\\n+                     parameter in this item's generic parameters\",\n+                    name,\n+                );\n                 err.span_label(span, \"already used\");\n                 err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n                 err\n@@ -376,9 +381,9 @@ impl<'a> Resolver<'a> {\n                 Scope::DeriveHelpers => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                     if filter_fn(res) {\n-                        for derive in &parent_scope.derives {\n+                        for derive in parent_scope.derives {\n                             let parent_scope =\n-                                &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                                &ParentScope { derives: &[], ..*parent_scope };\n                             if let Ok((Some(ext), _)) = this.resolve_macro_path(\n                                 derive, Some(MacroKind::Derive), parent_scope, false, false\n                             ) {\n@@ -402,10 +407,10 @@ impl<'a> Resolver<'a> {\n                 Scope::CrateRoot => {\n                     let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n-                    add_module_candidates(root_module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(root_module, &mut suggestions, filter_fn);\n                 }\n                 Scope::Module(module) => {\n-                    add_module_candidates(module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n@@ -453,9 +458,9 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => {\n                     if let Some(prelude) = this.prelude {\n                         let mut tmp_suggestions = Vec::new();\n-                        add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n+                        this.add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n                         suggestions.extend(tmp_suggestions.into_iter().filter(|s| {\n-                            use_prelude || this.is_builtin_macro(s.res.opt_def_id())\n+                            use_prelude || this.is_builtin_macro(s.res)\n                         }));\n                     }\n                 }\n@@ -509,11 +514,9 @@ impl<'a> Resolver<'a> {\n         while let Some((in_module,\n                         path_segments,\n                         in_module_is_extern)) = worklist.pop() {\n-            self.populate_module_if_necessary(in_module);\n-\n             // We have to visit module children in deterministic order to avoid\n             // instabilities in reported imports (#43552).\n-            in_module.for_each_child_stable(|ident, ns, name_binding| {\n+            in_module.for_each_child_stable(self, |this, ident, ns, name_binding| {\n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n                 // avoid non-importable candidates as well\n@@ -547,7 +550,7 @@ impl<'a> Resolver<'a> {\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             let did = match res {\n-                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n+                                Res::Def(DefKind::Ctor(..), did) => this.parent(did),\n                                 _ => res.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });\n@@ -595,7 +598,7 @@ impl<'a> Resolver<'a> {\n         where FilterFn: Fn(Res) -> bool\n     {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n+            lookup_ident, namespace, self.graph_root, Ident::with_dummy_span(kw::Crate), &filter_fn\n         );\n \n         if lookup_ident.span.rust_2018() {\n@@ -607,8 +610,6 @@ impl<'a> Resolver<'a> {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n                     });\n-                    self.populate_module_if_necessary(&crate_root);\n-\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident, namespace, crate_root, ident, &filter_fn));\n                 }\n@@ -805,7 +806,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///            at the root of the crate instead of the module where it is defined\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n-        &self,\n+        &mut self,\n         directive: &'b ImportDirective<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n@@ -826,7 +827,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return None;\n         }\n \n-        let resolutions = crate_module.resolutions.borrow();\n+        let resolutions = self.r.resolutions(crate_module).borrow();\n         let resolution = resolutions.get(&(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {"}, {"sha": "1faaf97e981c14fed761bb802019e1098eb264b4", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -526,15 +526,25 @@ Some type parameters have the same name.\n Erroneous code example:\n \n ```compile_fail,E0403\n-fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n-                            //        parameter in this type parameter list\n+fn f<T, T>(s: T, u: T) {} // error: the name `T` is already used for a generic\n+                          //        parameter in this item's generic parameters\n ```\n \n Please verify that none of the type parameters are misspelled, and rename any\n clashing parameters. Example:\n \n ```\n-fn foo<T, Y>(s: T, u: Y) {} // ok!\n+fn f<T, Y>(s: T, u: Y) {} // ok!\n+```\n+\n+Type parameters in an associated item also cannot shadow parameters from the\n+containing item:\n+\n+```compile_fail,E0403\n+trait Foo<T> {\n+    fn do_something(&self) -> T;\n+    fn do_something_else<T: Clone>(&self, bar: T);\n+}\n ```\n \"##,\n "}, {"sha": "e15d02a9f7ec7abcd69bc082aaf9a6ecd9b64a0b", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,3 +1,10 @@\n+//! \"Late resolution\" is the pass that resolves most of names in a crate beside imports and macros.\n+//! It runs when the crate is fully expanded and its module structure is fully built.\n+//! So it just walks through the crate and resolves all the expressions, types, etc.\n+//!\n+//! If you wonder why there's no `early.rs`, that's because it's split into three files -\n+//! `build_reduced_graph.rs`, `macros.rs` and `resolve_imports.rs`.\n+\n use GenericParameters::*;\n use RibKind::*;\n \n@@ -104,6 +111,24 @@ crate enum RibKind<'a> {\n     TyParamAsConstParamTy,\n }\n \n+impl RibKind<'_> {\n+    // Whether this rib kind contains generic parameters, as opposed to local\n+    // variables.\n+    crate fn contains_params(&self) -> bool {\n+        match self {\n+            NormalRibKind\n+            | FnItemRibKind\n+            | ConstantItemRibKind\n+            | ModuleRibKind(_)\n+            | MacroDefinition(_) => false,\n+            AssocItemRibKind\n+            | ItemRibKind\n+            | ForwardTyParamBanRibKind\n+            | TyParamAsConstParamTy => true,\n+        }\n+    }\n+}\n+\n /// A single local scope.\n ///\n /// A rib represents a scope names can live in. Note that these appear in many places, not just\n@@ -352,7 +377,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n             TyKind::ImplicitSelf => {\n-                let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n+                let self_ty = Ident::with_dummy_span(kw::SelfUpper);\n                 let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n@@ -442,7 +467,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 GenericParamKind::Type { ref default, .. } => {\n                     found_default |= default.is_some();\n                     if found_default {\n-                        Some((Ident::with_empty_ctxt(param.ident.name), Res::Err))\n+                        Some((Ident::with_dummy_span(param.ident.name), Res::Err))\n                     } else {\n                         None\n                     }\n@@ -459,7 +484,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     false\n                 }\n             })\n-            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Res::Err)));\n+            .map(|param| (Ident::with_dummy_span(param.ident.name), Res::Err)));\n \n         for param in &generics.params {\n             match param.kind {\n@@ -476,7 +501,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     }\n \n                     // Allow all following defaults to refer to this type parameter.\n-                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n+                    default_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n                     self.ribs[TypeNS].push(const_ty_param_ban_rib);\n@@ -501,8 +526,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n         // During late resolution we only track the module component of the parent scope,\n         // although it may be useful to track other components as well for diagnostics.\n-        let parent_scope = resolver.dummy_parent_scope();\n         let graph_root = resolver.graph_root;\n+        let parent_scope = ParentScope::module(graph_root);\n         LateResolutionVisitor {\n             r: resolver,\n             parent_scope,\n@@ -574,7 +599,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n-            self.r.finalize_current_module_macro_resolutions(module);\n             let ret = f(self);\n \n             self.parent_scope.module = orig_module;\n@@ -792,6 +816,19 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut function_value_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap::default();\n+                // We also can't shadow bindings from the parent item\n+                if let AssocItemRibKind = rib_kind {\n+                    let mut add_bindings_for_ns = |ns| {\n+                        let parent_rib = self.ribs[ns].iter()\n+                            .rfind(|rib| if let ItemRibKind = rib.kind { true } else { false })\n+                            .expect(\"associated item outside of an item\");\n+                        seen_bindings.extend(\n+                            parent_rib.bindings.iter().map(|(ident, _)| (*ident, ident.span)),\n+                        );\n+                    };\n+                    add_bindings_for_ns(ValueNS);\n+                    add_bindings_for_ns(TypeNS);\n+                }\n                 for param in &generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {}\n@@ -965,7 +1002,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -976,7 +1013,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     {\n         let self_res = Res::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -1227,7 +1264,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.parent_scope.module = anonymous_module;\n-            self.r.finalize_current_module_macro_resolutions(anonymous_module);\n         } else {\n             self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n@@ -1476,7 +1512,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n-                let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n+                let mut std_path = vec![Segment::from_ident(Ident::with_dummy_span(sym::std))];\n                 std_path.extend(path);\n                 if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n                     let cl = CrateLint::No;\n@@ -1507,7 +1543,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_empty_ctxt(kw::SelfUpper),\n+            Ident::with_dummy_span(kw::SelfUpper),\n             TypeNS,\n             None,\n             span,\n@@ -1924,7 +1960,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut traits = module.traits.borrow_mut();\n         if traits.is_none() {\n             let mut collected_traits = Vec::new();\n-            module.for_each_child(|name, ns, binding| {\n+            module.for_each_child(self.r, |_, name, ns, binding| {\n                 if ns != TypeNS { return }\n                 match binding.res() {\n                     Res::Def(DefKind::Trait, _) |\n@@ -1984,7 +2020,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n-        self.finalize_current_module_macro_resolutions(self.graph_root);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.unused_labels.iter() {"}, {"sha": "a822fa049ca1c5467175d881af0110230c7d1b4c", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,8 +1,7 @@\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n use crate::path_names_to_string;\n-use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n-use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::diagnostics::{add_typo_suggestion, ImportSuggestion, TypoSuggestion};\n use crate::late::{LateResolutionVisitor, RibKind};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -548,7 +547,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 // Items in scope\n                 if let RibKind::ModuleRibKind(module) = rib.kind {\n                     // Items from this module\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n \n                     if let ModuleKind::Block(..) = module.kind {\n                         // We can see through blocks\n@@ -577,7 +576,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {\n-                                add_module_candidates(prelude, &mut names, &filter_fn);\n+                                self.r.add_module_candidates(prelude, &mut names, &filter_fn);\n                             }\n                         }\n                         break;\n@@ -599,7 +598,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n                 }\n             }\n         }\n@@ -717,9 +716,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             // abort if the module is already found\n             if result.is_some() { break; }\n \n-            self.r.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n+            in_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 // abort if the module is already found or if name_binding is private external\n                 if result.is_some() || !name_binding.vis.is_visible_locally() {\n                     return\n@@ -750,10 +747,8 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n     fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n         self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.r.populate_module_if_necessary(enum_module);\n-\n             let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+            enum_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n                     segms.push(ast::PathSegment::from_ident(ident));"}, {"sha": "2dd0ad13c526d80b4d653db5df3e474b69a94d01", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 114, "deletions": 64, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,3 +1,12 @@\n+//! This crate is responsible for the part of name resolution that doesn't require type checker.\n+//!\n+//! Module structure of the crate is built here.\n+//! Paths in macros, imports, expressions, types, patterns are resolved here.\n+//! Label names are resolved here as well.\n+//!\n+//! Type-relative name resolution (methods, fields, associated items) happens in `librustc_typeck`.\n+//! Lifetime names are resolved in `librustc/middle/resolve_lifetime.rs`.\n+\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(crate_visibility_modifier)]\n@@ -54,7 +63,7 @@ use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use late::{PathSource, Rib, RibKind::*};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, LegacyScope};\n+use macros::{LegacyBinding, LegacyScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -122,12 +131,25 @@ enum ScopeSet {\n /// Serves as a starting point for the scope visitor.\n /// This struct is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n     expansion: ExpnId,\n     legacy: LegacyScope<'a>,\n-    derives: Vec<ast::Path>,\n+    derives: &'a [ast::Path],\n+}\n+\n+impl<'a> ParentScope<'a> {\n+    /// Creates a parent scope with the passed argument used as the module scope component,\n+    /// and other scope components set to default empty values.\n+    pub fn module(module: Module<'a>) -> ParentScope<'a> {\n+        ParentScope {\n+            module,\n+            expansion: ExpnId::root(),\n+            legacy: LegacyScope::Empty,\n+            derives: &[],\n+        }\n+    }\n }\n \n #[derive(Eq)]\n@@ -274,7 +296,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -284,7 +306,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         // don't insert between attributes and an item\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());\n@@ -409,6 +431,8 @@ impl ModuleKind {\n     }\n }\n \n+type Resolutions<'a> = RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>;\n+\n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n@@ -417,15 +441,14 @@ pub struct ModuleData<'a> {\n     // The def id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: DefId,\n \n-    resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    single_segment_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n-                                                   Option<&'a NameBinding<'a>>)>>,\n-    multi_segment_macro_resolutions: RefCell<Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n-                                                  Option<Res>)>>,\n-    builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n+    // Mapping between names and their (possibly in-progress) resolutions in this module.\n+    // Resolutions in modules from other crates are not populated until accessed.\n+    lazy_resolutions: Resolutions<'a>,\n+    // True if this is a module from other crate that needs to be populated on access.\n+    populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n-    unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n+    unexpanded_invocations: RefCell<FxHashSet<ExpnId>>,\n \n     no_implicit_prelude: bool,\n \n@@ -435,11 +458,6 @@ pub struct ModuleData<'a> {\n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n     traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n \n-    // Whether this module is populated. If not populated, any attempt to\n-    // access the children must be preceded with a\n-    // `populate_module_if_necessary` call.\n-    populated: Cell<bool>,\n-\n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n \n@@ -458,33 +476,34 @@ impl<'a> ModuleData<'a> {\n             parent,\n             kind,\n             normal_ancestor_id,\n-            resolutions: Default::default(),\n-            single_segment_macro_resolutions: RefCell::new(Vec::new()),\n-            multi_segment_macro_resolutions: RefCell::new(Vec::new()),\n-            builtin_attrs: RefCell::new(Vec::new()),\n-            unresolved_invocations: Default::default(),\n+            lazy_resolutions: Default::default(),\n+            populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n+            unexpanded_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),\n             traits: RefCell::new(None),\n-            populated: Cell::new(normal_ancestor_id.is_local()),\n             span,\n             expansion,\n         }\n     }\n \n-    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(ident, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+    fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        for (&(ident, ns), name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n-    fn for_each_child_stable<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        let resolutions = self.resolutions.borrow();\n+    fn for_each_child_stable<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        let resolutions = resolver.as_mut().resolutions(self).borrow();\n         let mut resolutions = resolutions.iter().collect::<Vec<_>>();\n         resolutions.sort_by_cached_key(|&(&(ident, ns), _)| (ident.as_str(), ns));\n         for &(&(ident, ns), &resolution) in resolutions.iter() {\n-            resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+            resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n@@ -807,7 +826,7 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n-    graph_root: Module<'a>,\n+    pub graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n     pub extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n@@ -896,15 +915,24 @@ pub struct Resolver<'a> {\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n+    /// Traces collected during macro resolution and validated when it's complete.\n+    single_segment_macro_resolutions: Vec<(Ident, MacroKind, ParentScope<'a>,\n+                                           Option<&'a NameBinding<'a>>)>,\n+    multi_segment_macro_resolutions: Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n+                                          Option<Res>)>,\n+    builtin_attrs: Vec<(Ident, ParentScope<'a>)>,\n     /// Some built-in derives mark items they are applied to so they are treated specially later.\n     /// Derive macros cannot modify the item themselves and have to store the markers in the global\n     /// context, so they attach the markers to derive container IDs using this resolver table.\n     /// FIXME: Find a way for `PartialEq` and `Eq` to emulate `#[structural_match]`\n     /// by marking the produced impls rather than the original items.\n     special_derives: FxHashMap<ExpnId, SpecialDerives>,\n-\n-    /// Maps the `ExpnId` of an expansion to its containing module or block.\n-    invocations: FxHashMap<ExpnId, &'a InvocationData<'a>>,\n+    /// Parent scopes in which the macros were invoked.\n+    /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n+    invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n+    /// Legacy scopes *produced* by expanding the macro invocations,\n+    /// include all the `macro_rules` items and other invocations generated by them.\n+    output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n@@ -927,8 +955,8 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n-    invocation_data: arena::TypedArena<InvocationData<'a>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n+    ast_paths: arena::TypedArena<ast::Path>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -952,13 +980,16 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n-    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)\n-                             -> &'a InvocationData<'a> {\n-        self.invocation_data.alloc(expansion_data)\n-    }\n     fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n         self.legacy_bindings.alloc(binding)\n     }\n+    fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n+        self.ast_paths.alloc_from_iter(paths.iter().cloned())\n+    }\n+}\n+\n+impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self }\n }\n \n impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n@@ -985,19 +1016,19 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         } else {\n             kw::Crate\n         };\n-        let segments = iter::once(Ident::with_empty_ctxt(root))\n+        let segments = iter::once(Ident::with_dummy_span(root))\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Ident::with_empty_ctxt)\n+                    .map(Ident::with_dummy_span)\n             ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n         let path = ast::Path {\n             span,\n             segments,\n         };\n \n-        let parent_scope = &self.dummy_parent_scope();\n+        let parent_scope = &ParentScope::module(self.graph_root);\n         let res = match self.resolve_ast_path(&path, ns, parent_scope) {\n             Ok(res) => res,\n             Err((span, error)) => {\n@@ -1060,18 +1091,17 @@ impl<'a> Resolver<'a> {\n                                        .collect();\n \n         if !attr::contains_name(&krate.attrs, sym::no_core) {\n-            extern_prelude.insert(Ident::with_empty_ctxt(sym::core), Default::default());\n+            extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n             if !attr::contains_name(&krate.attrs, sym::no_std) {\n-                extern_prelude.insert(Ident::with_empty_ctxt(sym::std), Default::default());\n+                extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n                 if session.rust_2018() {\n-                    extern_prelude.insert(Ident::with_empty_ctxt(sym::meta), Default::default());\n+                    extern_prelude.insert(Ident::with_dummy_span(sym::meta), Default::default());\n                 }\n             }\n         }\n \n-        let mut invocations = FxHashMap::default();\n-        invocations.insert(ExpnId::root(),\n-                           arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n+        let mut invocation_parent_scopes = FxHashMap::default();\n+        invocation_parent_scopes.insert(ExpnId::root(), ParentScope::module(graph_root));\n \n         let mut macro_defs = FxHashMap::default();\n         macro_defs.insert(ExpnId::root(), root_def_id);\n@@ -1143,14 +1173,18 @@ impl<'a> Resolver<'a> {\n             dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n-            invocations,\n+            invocation_parent_scopes,\n+            output_legacy_scopes: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: Default::default(),\n             unused_macros: Default::default(),\n             proc_macro_stubs: Default::default(),\n+            single_segment_macro_resolutions: Default::default(),\n+            multi_segment_macro_resolutions: Default::default(),\n+            builtin_attrs: Default::default(),\n             special_derives: Default::default(),\n             active_features:\n                 features.declared_lib_features.iter().map(|(feat, ..)| *feat)\n@@ -1182,9 +1216,8 @@ impl<'a> Resolver<'a> {\n         f(self, MacroNS);\n     }\n \n-    fn is_builtin_macro(&mut self, def_id: Option<DefId>) -> bool {\n-        def_id.and_then(|def_id| self.get_macro_by_def_id(def_id))\n-              .map_or(false, |ext| ext.is_builtin)\n+    fn is_builtin_macro(&mut self, res: Res) -> bool {\n+        self.get_macro(res).map_or(false, |ext| ext.is_builtin)\n     }\n \n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {\n@@ -1203,6 +1236,7 @@ impl<'a> Resolver<'a> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { r: self }.finalize_imports();\n+        self.finalize_macro_resolutions();\n \n         self.late_resolve_crate(krate);\n \n@@ -1223,6 +1257,20 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n+        if module.populate_on_access.get() {\n+            module.populate_on_access.set(false);\n+            self.build_reduced_graph_external(module);\n+        }\n+        &module.lazy_resolutions\n+    }\n+\n+    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+                  -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+               .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     fn record_use(&mut self, ident: Ident, ns: Namespace,\n                   used_binding: &'a NameBinding<'a>, is_lexical_scope: bool) {\n         if let Some((b2, kind)) = used_binding.ambiguity {\n@@ -1319,13 +1367,15 @@ impl<'a> Resolver<'a> {\n             ScopeSet::AbsolutePath(ns) => (ns, true),\n             ScopeSet::Macro(_) => (MacroNS, false),\n         };\n+        // Jump out of trait or enum modules, they do not act as scopes.\n+        let module = parent_scope.module.nearest_item_scope();\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(parent_scope.module),\n+            TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers,\n         };\n         let mut ident = ident.modern();\n-        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n+        let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n             let visit = match scope {\n@@ -1355,10 +1405,11 @@ impl<'a> Resolver<'a> {\n                     LegacyScope::Binding(binding) => Scope::MacroRules(\n                         binding.parent_legacy_scope\n                     ),\n-                    LegacyScope::Invocation(invoc) => Scope::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n+                    LegacyScope::Invocation(invoc_id) => Scope::MacroRules(\n+                        self.output_legacy_scopes.get(&invoc_id).cloned()\n+                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].legacy)\n                     ),\n-                    LegacyScope::Empty => Scope::Module(parent_scope.module),\n+                    LegacyScope::Empty => Scope::Module(module),\n                 }\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -1430,7 +1481,7 @@ impl<'a> Resolver<'a> {\n         }\n         let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n-            let empty_span = ident.span.with_ctxt(SyntaxContext::empty());\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n             (empty_span, empty_span)\n         } else if ns == TypeNS {\n             let modern_span = ident.span.modern();\n@@ -1448,7 +1499,7 @@ impl<'a> Resolver<'a> {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n             // Use the rib kind to determine whether we are resolving parameters\n             // (modern hygiene) or local variables (legacy hygiene).\n-            let rib_ident = if let AssocItemRibKind | ItemRibKind = ribs[i].kind {\n+            let rib_ident = if ribs[i].kind.contains_params() {\n                 modern_ident\n             } else {\n                 ident\n@@ -1501,7 +1552,7 @@ impl<'a> Resolver<'a> {\n                 self.hygienic_lexical_parent(module, &mut ident.span)\n             };\n             module = unwrap_or!(opt_module, break);\n-            let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+            let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n             let result = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n@@ -1637,7 +1688,7 @@ impl<'a> Resolver<'a> {\n             ModuleOrUniformRoot::Module(m) => {\n                 if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n@@ -2606,7 +2657,6 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                self.populate_module_if_necessary(&crate_root);\n                 Some((crate_root, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                     .to_name_binding(self.arenas))\n             }\n@@ -2624,7 +2674,7 @@ impl<'a> Resolver<'a> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n-                segments: iter::once(Ident::with_empty_ctxt(kw::PathRoot))\n+                segments: iter::once(Ident::with_dummy_span(kw::PathRoot))\n                     .chain({\n                         path_str.split(\"::\").skip(1).map(Ident::from_str)\n                     })\n@@ -2645,7 +2695,7 @@ impl<'a> Resolver<'a> {\n             let def_id = self.definitions.local_def_id(module_id);\n             self.module_map.get(&def_id).copied().unwrap_or(self.graph_root)\n         });\n-        let parent_scope = &ParentScope { module, ..self.dummy_parent_scope() };\n+        let parent_scope = &ParentScope::module(module);\n         let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n         Ok((path, res))\n     }\n@@ -2713,7 +2763,7 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n     fn collect_mod(names: &mut Vec<Ident>, module: Module<'_>) {\n         if let ModuleKind::Def(.., name) = module.kind {\n             if let Some(parent) = module.parent {\n-                names.push(Ident::with_empty_ctxt(name));\n+                names.push(Ident::with_dummy_span(name));\n                 collect_mod(names, parent);\n             }\n         } else {"}, {"sha": "01ad67252a387886f630a7e01ed12f14ad33bd15", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 54, "deletions": 107, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,56 +1,32 @@\n+//! A bunch of methods and structures more or less related to resolving macros and\n+//! interface provided by `Resolver` to macro expander.\n+\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n-use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n+use crate::{ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n-use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n-use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, ExpnId, ExpnInfo, ExpnKind};\n+use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::cell::Cell;\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n-type Res = def::Res<ast::NodeId>;\n-\n-// FIXME: Merge this with `ParentScope`.\n-#[derive(Clone, Debug)]\n-pub struct InvocationData<'a> {\n-    /// The module in which the macro was invoked.\n-    crate module: Module<'a>,\n-    /// The legacy scope in which the macro was invoked.\n-    /// The invocation path is resolved in this scope.\n-    crate parent_legacy_scope: LegacyScope<'a>,\n-    /// The legacy scope *produced* by expanding this macro invocation,\n-    /// includes all the macro_rules items, other invocations, etc generated by it.\n-    /// `None` if the macro is not expanded yet.\n-    crate output_legacy_scope: Cell<Option<LegacyScope<'a>>>,\n-}\n-\n-impl<'a> InvocationData<'a> {\n-    pub fn root(graph_root: Module<'a>) -> Self {\n-        InvocationData {\n-            module: graph_root,\n-            parent_legacy_scope: LegacyScope::Empty,\n-            output_legacy_scope: Cell::new(None),\n-        }\n-    }\n-}\n+type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n@@ -75,7 +51,7 @@ pub enum LegacyScope<'a> {\n     Binding(&'a LegacyBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n-    Invocation(&'a InvocationData<'a>),\n+    Invocation(ExpnId),\n }\n \n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n@@ -115,22 +91,17 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n-    fn next_node_id(&mut self) -> ast::NodeId {\n+    fn next_node_id(&mut self) -> NodeId {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n-        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::default(\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n+        let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n-        ));\n-        let expn_id = span.ctxt().outer_expn();\n+        )));\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n+        self.invocation_parent_scopes.insert(expn_id, ParentScope::module(module));\n         self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n-        self.invocations.insert(expn_id, self.arenas.alloc_invocation_data(InvocationData {\n-            module,\n-            parent_legacy_scope: LegacyScope::Empty,\n-            output_legacy_scope: Cell::new(None),\n-        }));\n         expn_id\n     }\n \n@@ -144,29 +115,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]) {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n-\n-        let invocation = self.invocations[&expn_id];\n-        invocation.module.unresolved_invocations.borrow_mut().remove(&expn_id);\n-        invocation.module.unresolved_invocations.borrow_mut().extend(derives);\n-        let parent_def = self.definitions.invocation_parent(expn_id);\n-        for &derive_invoc_id in derives {\n-            self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n-        }\n-        self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n-        let mut visitor = BuildReducedGraphVisitor {\n-            r: self,\n-            parent_scope: ParentScope {\n-                module: invocation.module,\n-                expansion: expn_id,\n-                legacy: invocation.parent_legacy_scope,\n-                derives: Vec::new(),\n-            },\n-        };\n-        fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(Some(visitor.parent_scope.legacy));\n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n+    fn visit_ast_fragment_with_placeholders(\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, extra_placeholders: &[NodeId]\n+    ) {\n+        // Integrate the new AST fragment into all the definition and module structures.\n+        // We are inside the `expansion` now, but other parent scope components are still the same.\n+        let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n+        let output_legacy_scope =\n+            self.build_reduced_graph(fragment, extra_placeholders, parent_scope);\n+        self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n+\n+        parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -182,24 +142,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n-        let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n+        let parent_scope = self.invocation_parent_scopes[&invoc_id];\n+        let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, derives.clone(), after_derive),\n+                (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.node.path, MacroKind::Bang, Vec::new(), false),\n+                (&mac.path, MacroKind::Bang, &[][..], false),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, Vec::new(), false),\n+                (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n                 // Block expansion of derives in the container until we know whether one of them\n                 // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n                 // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n                 // will automatically knows about itself.\n                 let mut result = Ok(None);\n                 if derives.len() > 1 {\n-                    let parent_scope = &self.invoc_parent_scope(invoc_id, Vec::new());\n                     for path in derives {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      parent_scope, true, force) {\n+                                                      &parent_scope, true, force) {\n                             Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n                                 self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n                                 return Ok(None);\n@@ -213,11 +173,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         };\n \n-        let parent_scope = &self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        // Derives are not included when `invocations` are collected, so we have to add them here.\n+        let parent_scope = &ParentScope { derives, ..parent_scope };\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.id.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n+        invoc.expansion_data.id.set_expn_data(\n+            ext.expn_data(parent_scope.expansion, span, fast_print_path(path))\n+        );\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n@@ -251,20 +214,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn dummy_parent_scope(&self) -> ParentScope<'a> {\n-        self.invoc_parent_scope(ExpnId::root(), Vec::new())\n-    }\n-\n-    fn invoc_parent_scope(&self, invoc_id: ExpnId, derives: Vec<ast::Path>) -> ParentScope<'a> {\n-        let invoc = self.invocations[&invoc_id];\n-        ParentScope {\n-            module: invoc.module.nearest_item_scope(),\n-            expansion: invoc_id.parent(),\n-            legacy: invoc.parent_legacy_scope,\n-            derives,\n-        }\n-    }\n-\n     /// Resolve macro path with error reporting and recovery.\n     fn smart_resolve_macro_path(\n         &mut self,\n@@ -346,8 +295,7 @@ impl<'a> Resolver<'a> {\n \n         // Possibly apply the macro helper hack\n         if kind == Some(MacroKind::Bang) && path.len() == 1 &&\n-           path[0].ident.span.ctxt().outer_expn_info()\n-               .map_or(false, |info| info.local_inner_macros) {\n+           path[0].ident.span.ctxt().outer_expn_data().local_inner_macros {\n             let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n             path.insert(0, Segment::from_ident(root));\n         }\n@@ -367,8 +315,8 @@ impl<'a> Resolver<'a> {\n \n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n-                parent_scope.module.multi_segment_macro_resolutions.borrow_mut()\n-                    .push((path, path_span, kind, parent_scope.clone(), res.ok()));\n+                self.multi_segment_macro_resolutions\n+                    .push((path, path_span, kind, *parent_scope, res.ok()));\n             }\n \n             self.prohibit_imported_non_macro_attrs(None, res.ok(), path_span);\n@@ -384,8 +332,8 @@ impl<'a> Resolver<'a> {\n \n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n-                parent_scope.module.single_segment_macro_resolutions.borrow_mut()\n-                    .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n+                self.single_segment_macro_resolutions\n+                    .push((path[0].ident, kind, *parent_scope, binding.ok()));\n             }\n \n             let res = binding.map(|binding| binding.res());\n@@ -454,8 +402,8 @@ impl<'a> Resolver<'a> {\n             let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n-                    for derive in &parent_scope.derives {\n-                        let parent_scope = &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                    for derive in parent_scope.derives {\n+                        let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n                         match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n                                                       parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n@@ -475,8 +423,9 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                         Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n-                    LegacyScope::Invocation(invoc) if invoc.output_legacy_scope.get().is_none() =>\n-                        Err(Determinacy::Undetermined),\n+                    LegacyScope::Invocation(invoc_id)\n+                        if !this.output_legacy_scopes.contains_key(&invoc_id) =>\n+                            Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n                 Scope::CrateRoot => {\n@@ -500,7 +449,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+                    let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                     let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n@@ -531,7 +480,7 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n                     Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     ))\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n@@ -554,7 +503,7 @@ impl<'a> Resolver<'a> {\n                 Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n                     Some(binding) => Ok((binding, Flags::PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     )),\n                 }\n                 Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {\n@@ -575,7 +524,7 @@ impl<'a> Resolver<'a> {\n                             false,\n                             path_span,\n                         ) {\n-                            if use_prelude || this.is_builtin_macro(binding.res().opt_def_id()) {\n+                            if use_prelude || this.is_builtin_macro(binding.res()) {\n                                 result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                             }\n                         }\n@@ -694,7 +643,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn finalize_current_module_macro_resolutions(&mut self, module: Module<'a>) {\n+    crate fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self, path: &[Segment], span, kind: MacroKind,\n                                  initial_res: Option<Res>, res: Res| {\n             if let Some(initial_res) = initial_res {\n@@ -730,8 +679,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let macro_resolutions =\n-            mem::take(&mut *module.multi_segment_macro_resolutions.borrow_mut());\n+        let macro_resolutions = mem::take(&mut self.multi_segment_macro_resolutions);\n         for (mut path, path_span, kind, parent_scope, initial_res) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n@@ -758,8 +706,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let macro_resolutions =\n-            mem::take(&mut *module.single_segment_macro_resolutions.borrow_mut());\n+        let macro_resolutions = mem::take(&mut self.single_segment_macro_resolutions);\n         for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n             match self.early_resolve_ident_in_lexical_scope(ident, ScopeSet::Macro(kind),\n                                                             &parent_scope, true, true, ident.span) {\n@@ -784,7 +731,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let builtin_attrs = mem::take(&mut *module.builtin_attrs.borrow_mut());\n+        let builtin_attrs = mem::take(&mut self.builtin_attrs);\n         for (ident, parent_scope) in builtin_attrs {\n             let _ = self.early_resolve_ident_in_lexical_scope(\n                 ident, ScopeSet::Macro(MacroKind::Attr), &parent_scope, true, true, ident.span"}, {"sha": "fd222a132a3f8589c53df38bff1849c8edb759e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,13 +1,14 @@\n+//! A bunch of methods and structures more or less related to resolving imports.\n+\n use ImportDirectiveSubclass::*;\n \n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope, Weak};\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, ResolutionError, Segment};\n+use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n-use crate::ModuleKind;\n use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n@@ -35,7 +36,7 @@ use syntax_pos::{MultiSpan, Span};\n \n use log::*;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n@@ -159,12 +160,6 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n-                  -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n-               .or_insert_with(|| self.arenas.alloc_name_resolution())\n-    }\n-\n     crate fn resolve_ident_in_module_unadjusted(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n@@ -207,7 +202,7 @@ impl<'a> Resolver<'a> {\n                     Err((Determined, Weak::No))\n                 } else if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     Ok(binding)\n-                } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n                     Err((Undetermined, Weak::No))\n                 } else {\n@@ -240,8 +235,6 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        self.populate_module_if_necessary(module);\n-\n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n@@ -355,7 +348,7 @@ impl<'a> Resolver<'a> {\n         // progress, we have to ignore those potential unresolved invocations from other modules\n         // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n         // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unresolved_invocations.borrow().is_empty();\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n         if let Some(binding) = resolution.binding {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);\n@@ -394,7 +387,7 @@ impl<'a> Resolver<'a> {\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n                 Some(None) => {}\n@@ -848,7 +841,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         directive.vis.set(orig_vis);\n         let module = match path_res {\n             PathResult::Module(module) => {\n-                // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                // Consistency checks, analogous to `finalize_macro_resolutions`.\n                 if let Some(initial_module) = directive.imported_module.get() {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n                         span_bug!(directive.span, \"inconsistent resolution for an import\");\n@@ -973,7 +966,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             match binding {\n                 Ok(binding) => {\n-                    // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                    // Consistency checks, analogous to `finalize_macro_resolutions`.\n                     let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         if let Some(target_binding) = target_bindings[ns].get() {\n@@ -1025,7 +1018,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) => Some(module.resolutions.borrow()),\n+                    ModuleOrUniformRoot::Module(module) =>\n+                        Some(self.r.resolutions(module).borrow()),\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n@@ -1263,8 +1257,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        self.r.populate_module_if_necessary(module);\n-\n         if module.is_trait() {\n             self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n@@ -1280,8 +1272,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n@@ -1308,7 +1300,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n+        for (&(ident, ns), resolution) in self.r.resolutions(module).borrow().iter() {\n             let resolution = &mut *resolution.borrow_mut();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n@@ -1367,8 +1359,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n                             _ => bug!(\"module should exist\"),\n                         };\n-                        let resolutions = imported_module.parent.expect(\"parent should exist\")\n-                            .resolutions.borrow();\n+                        let parent_module = imported_module.parent.expect(\"parent should exist\");\n+                        let resolutions = self.r.resolutions(parent_module).borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n                         let enum_ident = directive.module_path[enum_path_segment_index].ident;\n "}, {"sha": "9068605b0753c4f09fc2ebfe2101d038a067d126", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -32,7 +32,7 @@ use syntax::print::pprust::{\n     ty_to_string\n };\n use syntax::ptr::P;\n-use syntax::source_map::{Spanned, DUMMY_SP, respan};\n+use syntax::source_map::{DUMMY_SP, respan};\n use syntax::walk_list;\n use syntax_pos::*;\n \n@@ -557,11 +557,11 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         for variant in &enum_definition.variants {\n-            let name = variant.node.ident.name.to_string();\n+            let name = variant.ident.name.to_string();\n             let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n-            let name_span = variant.node.ident.span;\n+            let name_span = variant.ident.span;\n \n-            match variant.node.data {\n+            match variant.data {\n                 ast::VariantData::Struct(ref fields, ..) => {\n                     let fields_str = fields\n                         .iter()\n@@ -574,7 +574,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n+                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -589,10 +589,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.node.attrs.clone(),\n+                                    variant.attrs.clone(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -612,7 +612,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     }\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n+                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -627,10 +627,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.node.attrs.clone(),\n+                                    variant.attrs.clone(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -640,8 +640,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n \n \n-            for field in variant.node.data.fields() {\n-                self.process_struct_field_def(field, variant.node.id);\n+            for field in variant.data.fields() {\n+                self.process_struct_field_def(field, variant.id);\n                 self.visit_ty(&field.ty);\n             }\n         }\n@@ -879,7 +879,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 };\n                 let variant = adt.variant_of_res(self.save_ctxt.get_path_res(p.id));\n \n-                for &Spanned { node: ref field, .. } in fields {\n+                for field in fields {\n                     if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n                         if !self.span.filter_generated(field.ident.span) {\n                             let span = self.span_from_span(field.ident.span);"}, {"sha": "0bbbbb8249c207c7b284e7d53dc4d4b41a340a40", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -277,7 +277,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n-                    .map(|v| v.node.ident.to_string())\n+                    .map(|v| v.ident.to_string())\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n                 let value = format!(\"{}::{{{}}}\", name, variants_str);\n@@ -291,7 +291,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     parent: None,\n                     children: def.variants\n                         .iter()\n-                        .map(|v| id_from_node_id(v.node.id, self))\n+                        .map(|v| id_from_node_id(v.id, self))\n                         .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n@@ -1156,7 +1156,7 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n fn generated_code(span: Span) -> bool {\n-    span.ctxt() != NO_EXPANSION || span.is_dummy()\n+    span.from_expansion() || span.is_dummy()\n }\n \n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore"}, {"sha": "b34506a4f1d371747b80dc2a48bd87786aa5b6ae", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -65,7 +65,7 @@ pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext<'_, '_>) -> O\n     if !scx.config.signatures {\n         return None;\n     }\n-    variant.node.make(0, None, scx).ok()\n+    variant.make(0, None, scx).ok()\n }\n \n pub fn method_signature(\n@@ -699,7 +699,7 @@ impl Sig for ast::StructField {\n }\n \n \n-impl Sig for ast::Variant_ {\n+impl Sig for ast::Variant {\n     fn make(&self, offset: usize, parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {"}, {"sha": "dafa866117681df8c2d2016a27a8b7587bad0355", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -114,26 +114,20 @@ impl TargetDataLayout {\n                 [p] if p.starts_with(\"P\") => {\n                     dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n                 }\n-                // FIXME: Ping cfg(bootstrap) -- Use `ref a @ ..` with new bootstrap compiler.\n-                [\"a\", ..] => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [\"a\", ref a @ ..] => {\n                     dl.aggregate_align = align(a, \"a\")?\n                 }\n-                [\"f32\", ..] => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [\"f32\", ref a @ ..] => {\n                     dl.f32_align = align(a, \"f32\")?\n                 }\n-                [\"f64\", ..] => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [\"f64\", ref a @ ..] => {\n                     dl.f64_align = align(a, \"f64\")?\n                 }\n-                [p @ \"p\", s, ..] | [p @ \"p0\", s, ..] => {\n-                    let a = &spec_parts[2..]; // FIXME inline into pattern.\n+                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n                 }\n-                [s, ..] if s.starts_with(\"i\") => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [s, ref a @ ..] if s.starts_with(\"i\") => {\n                     let bits = match s[1..].parse::<u64>() {\n                         Ok(bits) => bits,\n                         Err(_) => {\n@@ -157,8 +151,7 @@ impl TargetDataLayout {\n                         dl.i128_align = a;\n                     }\n                 }\n-                [s, ..] if s.starts_with(\"v\") => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [s, ref a @ ..] if s.starts_with(\"v\") => {\n                     let v_size = size(&s[1..], \"v\")?;\n                     let a = align(a, s)?;\n                     if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {"}, {"sha": "5d8b829f2ab711c9ee25ed7ab0ebe399de205946", "filename": "src/librustc_target/spec/aarch64_uwp_windows_msvc.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Faarch64_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Faarch64_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_uwp_windows_msvc.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult, PanicStrategy};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_msvc_base::opts();\n+    base.max_atomic_width = Some(64);\n+    base.has_elf_tls = true;\n+\n+    // FIXME: this shouldn't be panic=abort, it should be panic=unwind\n+    base.panic_strategy = PanicStrategy::Abort;\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:w-p:64:64-i32:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Msvc,\n+        options: base,\n+    })\n+}"}, {"sha": "6d3900c0b203f372fe64112322a29d73d7cca658", "filename": "src/librustc_target/spec/apple_ios_base.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -13,7 +13,8 @@ pub enum Arch {\n     Armv7s,\n     Arm64,\n     I386,\n-    X86_64\n+    X86_64,\n+    X86_64_macabi,\n }\n \n impl Arch {\n@@ -23,7 +24,8 @@ impl Arch {\n             Armv7s => \"armv7s\",\n             Arm64 => \"arm64\",\n             I386 => \"i386\",\n-            X86_64 => \"x86_64\"\n+            X86_64 => \"x86_64\",\n+            X86_64_macabi => \"x86_64\"\n         }\n     }\n }\n@@ -67,7 +69,8 @@ pub fn get_sdk_root(sdk_name: &str) -> Result<String, String> {\n fn build_pre_link_args(arch: Arch) -> Result<LinkArgs, String> {\n     let sdk_name = match arch {\n         Armv7 | Armv7s | Arm64 => \"iphoneos\",\n-        I386 | X86_64 => \"iphonesimulator\"\n+        I386 | X86_64 => \"iphonesimulator\",\n+        X86_64_macabi => \"macosx10.15\",\n     };\n \n     let arch_name = arch.to_string();\n@@ -93,6 +96,7 @@ fn target_cpu(arch: Arch) -> String {\n         Arm64 => \"cyclone\",\n         I386 => \"yonah\",\n         X86_64 => \"core2\",\n+        X86_64_macabi => \"core2\",\n     }.to_string()\n }\n "}, {"sha": "5e8e8c2a4149c6eb242bb254686dfe8f5b8106e7", "filename": "src/librustc_target/spec/i686_uwp_windows_msvc.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_msvc.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,22 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_msvc_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.has_elf_tls = true;\n+\n+    Ok(Target {\n+        llvm_target: \"i686-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Msvc,\n+        options: base,\n+    })\n+}"}, {"sha": "75f3efa49c4f04557da497a29b008dc21c79b411", "filename": "src/librustc_target/spec/mips64_unknown_linux_muslabi64.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_muslabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_muslabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_muslabi64.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,25 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+    base.cpu = \"mips64r2\".to_string();\n+    base.features = \"+mips64r2\".to_string();\n+    base.max_atomic_width = Some(64);\n+    Ok(Target {\n+        // LLVM doesn't recognize \"muslabi64\" yet.\n+        llvm_target: \"mips64-unknown-linux-musl\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "a6aad3ddd3d797e2766e6b11ec5f366c7e45053d", "filename": "src/librustc_target/spec/mips64el_unknown_linux_muslabi64.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,25 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+    base.cpu = \"mips64r2\".to_string();\n+    base.features = \"+mips64r2\".to_string();\n+    base.max_atomic_width = Some(64);\n+    Ok(Target {\n+        // LLVM doesn't recognize \"muslabi64\" yet.\n+        llvm_target: \"mips64el-unknown-linux-musl\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "539e28f7088e354188441f1ba88ef8c6e866f308", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -61,6 +61,7 @@ mod uefi_base;\n mod windows_base;\n mod windows_msvc_base;\n mod windows_uwp_base;\n+mod windows_uwp_msvc_base;\n mod thumb_base;\n mod l4re_base;\n mod fuchsia_base;\n@@ -371,6 +372,8 @@ supported_targets! {\n     (\"i586-unknown-linux-musl\", i586_unknown_linux_musl),\n     (\"mips-unknown-linux-musl\", mips_unknown_linux_musl),\n     (\"mipsel-unknown-linux-musl\", mipsel_unknown_linux_musl),\n+    (\"mips64-unknown-linux-muslabi64\", mips64_unknown_linux_muslabi64),\n+    (\"mips64el-unknown-linux-muslabi64\", mips64el_unknown_linux_muslabi64),\n     (\"hexagon-unknown-linux-musl\", hexagon_unknown_linux_musl),\n \n     (\"mips-unknown-linux-uclibc\", mips_unknown_linux_uclibc),\n@@ -395,6 +398,7 @@ supported_targets! {\n \n     (\"aarch64-unknown-openbsd\", aarch64_unknown_openbsd),\n     (\"i686-unknown-openbsd\", i686_unknown_openbsd),\n+    (\"sparc64-unknown-openbsd\", sparc64_unknown_openbsd),\n     (\"x86_64-unknown-openbsd\", x86_64_unknown_openbsd),\n \n     (\"aarch64-unknown-netbsd\", aarch64_unknown_netbsd),\n@@ -425,6 +429,7 @@ supported_targets! {\n     (\"aarch64-apple-ios\", aarch64_apple_ios),\n     (\"armv7-apple-ios\", armv7_apple_ios),\n     (\"armv7s-apple-ios\", armv7s_apple_ios),\n+    (\"x86_64-apple-ios-macabi\", x86_64_apple_ios_macabi),\n \n     (\"armebv7r-none-eabi\", armebv7r_none_eabi),\n     (\"armebv7r-none-eabihf\", armebv7r_none_eabihf),\n@@ -442,8 +447,11 @@ supported_targets! {\n     (\"x86_64-uwp-windows-gnu\", x86_64_uwp_windows_gnu),\n \n     (\"aarch64-pc-windows-msvc\", aarch64_pc_windows_msvc),\n+    (\"aarch64-uwp-windows-msvc\", aarch64_uwp_windows_msvc),\n     (\"x86_64-pc-windows-msvc\", x86_64_pc_windows_msvc),\n+    (\"x86_64-uwp-windows-msvc\", x86_64_uwp_windows_msvc),\n     (\"i686-pc-windows-msvc\", i686_pc_windows_msvc),\n+    (\"i686-uwp-windows-msvc\", i686_uwp_windows_msvc),\n     (\"i586-pc-windows-msvc\", i586_pc_windows_msvc),\n     (\"thumbv7a-pc-windows-msvc\", thumbv7a_pc_windows_msvc),\n "}, {"sha": "229e0621e0dc1cef92bc52cf3e2ca415685d3d20", "filename": "src/librustc_target/spec/sparc64_unknown_openbsd.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_openbsd.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,22 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::openbsd_base::opts();\n+    base.cpu = \"v9\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"sparc64-unknown-openbsd\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64-S128\".to_string(),\n+        arch: \"sparc64\".to_string(),\n+        target_os: \"openbsd\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "1121916e68f5130b675a5d3badb63b84ccdd3566", "filename": "src/librustc_target/spec/windows_uwp_msvc_base.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_msvc_base.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,33 @@\n+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut args = LinkArgs::new();\n+    args.insert(LinkerFlavor::Msvc,\n+                vec![\"/NOLOGO\".to_string(),\n+                     \"/NXCOMPAT\".to_string(),\n+                     \"/APPCONTAINER\".to_string(),\n+                     \"mincore.lib\".to_string()]);\n+\n+    TargetOptions {\n+        function_sections: true,\n+        dynamic_linking: true,\n+        executables: true,\n+        dll_prefix: String::new(),\n+        dll_suffix: \".dll\".to_string(),\n+        exe_suffix: \".exe\".to_string(),\n+        staticlib_prefix: String::new(),\n+        staticlib_suffix: \".lib\".to_string(),\n+        target_family: Some(\"windows\".to_string()),\n+        is_like_windows: true,\n+        is_like_msvc: true,\n+        pre_link_args: args,\n+        crt_static_allows_dylibs: true,\n+        crt_static_respected: true,\n+        abi_return_struct_as_int: true,\n+        emit_debug_gdb_scripts: false,\n+        requires_uwtable: true,\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "2ce77282e90222ce27903e167cab919e513a059f", "filename": "src/librustc_target/spec/x86_64_apple_ios_macabi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_ios_macabi.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,23 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use super::apple_ios_base::{opts, Arch};\n+\n+pub fn target() -> TargetResult {\n+    let base = opts(Arch::X86_64_macabi)?;\n+    Ok(Target {\n+        llvm_target: \"x86_64-apple-ios13.0-macabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"ios\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: \"apple\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            max_atomic_width: Some(64),\n+            stack_probes: true,\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "40dd52c159151f5c4484fedd6dfa5dfe244b6112", "filename": "src/librustc_target/spec/x86_64_uwp_windows_msvc.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_msvc.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -0,0 +1,22 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_msvc_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.has_elf_tls = true;\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Msvc,\n+        options: base,\n+    })\n+}"}, {"sha": "9e52eae88ef45fbdf411a0ad5794b59dad58f42e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -635,8 +635,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default {\n-                    if tcx.at(span).type_of(param.def_id).has_self_ty() {\n+                if is_object && has_default && has_self {\n+                    let self_param = tcx.types.self_param;\n+                    if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n                         // There is no suitable inference default for a type parameter\n                         // that references self, in an object type.\n                         return true;\n@@ -2030,7 +2031,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-                tcx.mk_self_type()\n+                tcx.types.self_param\n             }\n             Res::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type)."}, {"sha": "fc25eb44cbd888888c1b01b47622e16472754230", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -12,7 +12,6 @@ use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n use syntax::ast;\n-use syntax::source_map::Spanned;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n use syntax_pos::hygiene::DesugaringKind;\n@@ -54,6 +53,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_non_ref_pat = match pat.node {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n+            PatKind::Or(_) |\n             PatKind::Tuple(..) |\n             PatKind::Box(_) |\n             PatKind::Range(..) |\n@@ -310,6 +310,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n             }\n+            PatKind::Or(ref pats) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                for pat in pats {\n+                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n+                }\n+                expected_ty\n+            }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n                 if ddpos.is_some() {\n@@ -1036,7 +1043,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         &self,\n         pat: &'tcx hir::Pat,\n         qpath: &hir::QPath,\n-        fields: &'tcx [Spanned<hir::FieldPat>],\n+        fields: &'tcx [hir::FieldPat],\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n@@ -1048,7 +1055,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat_walk(&field.node.pat, self.tcx.types.err, def_bm, discrim_span);\n+                self.check_pat_walk(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n             }\n             return self.tcx.types.err;\n         };\n@@ -1206,7 +1213,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         pat_id: hir::HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n-        fields: &'tcx [Spanned<hir::FieldPat>],\n+        fields: &'tcx [hir::FieldPat],\n         etc: bool,\n         def_bm: ty::BindingMode,\n     ) -> bool {\n@@ -1231,7 +1238,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n-        for &Spanned { node: ref field, span } in fields {\n+        for field in fields {\n+            let span = field.span;\n             let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {"}, {"sha": "8e187b7e05b51ab0e10a0b7729be4ce1b947cd57", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -518,7 +518,7 @@ fn compare_self_type<'tcx>(\n     let self_string = |method: &ty::AssocItem| {\n         let untransformed_self_ty = match method.container {\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n-            ty::TraitContainer(_) => tcx.mk_self_type()\n+            ty::TraitContainer(_) => tcx.types.self_param\n         };\n         let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n         let param_env = ty::ParamEnv::reveal_all();"}, {"sha": "de5ba8bc8eb42418d181cfebfd457809460b99e1", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -127,6 +127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n+        self.suggest_boxing_when_appropriate(&mut err, expr, expected, expr_ty);\n         self.suggest_missing_await(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n@@ -346,9 +347,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sp,\n         );\n \n-        // Check the `expn_info()` to see if this is a macro; if so, it's hard to\n-        // extract the text and make a good suggestion, so don't bother.\n-        let is_macro = sp.ctxt().outer_expn_info().is_some();\n+        // If the span is from a macro, then it's hard to extract the text\n+        // and make a good suggestion, so don't bother.\n+        let is_macro = sp.from_expansion();\n \n         match (&expr.node, &expected.sty, &checked_ty.sty) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n@@ -548,11 +549,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_scope(expr.hir_id) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n             // Shouldn't suggest `.into()` on `const`s.\n             // FIXME(estebank): modify once we decide to suggest `as` casts\n             return false;\n         }\n+        if !self.tcx.sess.source_map().span_to_filename(expr.span).is_real() {\n+            // Ignore if span is from within a macro.\n+            return false;\n+        }\n \n         // If casting this expression to a given numeric type would be appropriate in case of a type\n         // mismatch."}, {"sha": "d139cd4264c86f707c9f5cfddcf53f7bd518a30e", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 168, "deletions": 101, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -24,6 +24,7 @@ use syntax::source_map::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n use rustc::hir;\n use rustc::hir::{ExprKind, QPath};\n+use rustc::hir::def_id::DefId;\n use rustc::hir::def::{CtorKind, Res, DefKind};\n use rustc::hir::ptr::P;\n use rustc::infer;\n@@ -1336,116 +1337,182 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         autoderef.unambiguous_final_ty(self);\n \n         if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().def_path_str(did);\n-            let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n-                                           \"field `{}` of struct `{}` is private\",\n-                                           field, struct_path);\n-            // Also check if an accessible method exists, which is often what is meant.\n-            if self.method_exists(field, expr_t, expr.hir_id, false)\n-                && !self.expr_in_place(expr.hir_id)\n-            {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    &format!(\"a method `{}` also exists, call it with parentheses\", field),\n-                    field,\n-                    expr_t,\n-                    expr.hir_id,\n-                );\n-            }\n-            err.emit();\n-            field_ty\n-        } else if field.name == kw::Invalid {\n-            self.tcx().types.err\n+            self.ban_private_field_access(expr, expr_t, field, did);\n+            return field_ty;\n+        }\n+\n+        if field.name == kw::Invalid {\n         } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n-            let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n-                               \"attempted to take value of method `{}` on type `{}`\",\n-                               field, expr_t);\n-\n-            if !self.expr_in_place(expr.hir_id) {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    \"use parentheses to call the method\",\n-                    field,\n-                    expr_t,\n-                    expr.hir_id\n-                );\n-            } else {\n-                err.help(\"methods are immutable and cannot be assigned to\");\n+            self.ban_take_value_of_method(expr, expr_t, field);\n+        } else if !expr_t.is_primitive_ty() {\n+            let mut err = self.no_such_field_err(field.span, field, expr_t);\n+\n+            match expr_t.sty {\n+                ty::Adt(def, _) if !def.is_enum() => {\n+                    self.suggest_fields_on_recordish(&mut err, def, field);\n+                }\n+                ty::Array(_, len) => {\n+                    self.maybe_suggest_array_indexing(&mut err, expr, base, field, len);\n+                }\n+                ty::RawPtr(..) => {\n+                    self.suggest_first_deref_field(&mut err, expr, base, field);\n+                }\n+                _ => {}\n+            }\n+\n+            if field.name == kw::Await {\n+                // We know by construction that `<expr>.await` is either on Rust 2015\n+                // or results in `ExprKind::Await`. Suggest switching the edition to 2018.\n+                err.note(\"to `.await` a `Future`, switch to Rust 2018\");\n+                err.help(\"set `edition = \\\"2018\\\"` in `Cargo.toml`\");\n+                err.note(\"for more on editions, read https://doc.rust-lang.org/edition-guide\");\n             }\n \n             err.emit();\n-            self.tcx().types.err\n         } else {\n-            if !expr_t.is_primitive_ty() {\n-                let mut err = self.no_such_field_err(field.span, field, expr_t);\n-\n-                match expr_t.sty {\n-                    ty::Adt(def, _) if !def.is_enum() => {\n-                        if let Some(suggested_field_name) =\n-                            Self::suggest_field_name(def.non_enum_variant(),\n-                                                     &field.as_str(), vec![]) {\n-                                err.span_suggestion(\n-                                    field.span,\n-                                    \"a field with a similar name exists\",\n-                                    suggested_field_name.to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(field.span, \"unknown field\");\n-                                let struct_variant_def = def.non_enum_variant();\n-                                let field_names = self.available_field_names(struct_variant_def);\n-                                if !field_names.is_empty() {\n-                                    err.note(&format!(\"available fields are: {}\",\n-                                                      self.name_series_display(field_names)));\n-                                }\n-                            };\n-                    }\n-                    ty::Array(_, len) => {\n-                        if let (Some(len), Ok(user_index)) = (\n-                            len.try_eval_usize(self.tcx, self.param_env),\n-                            field.as_str().parse::<u64>()\n-                        ) {\n-                            let base = self.tcx.sess.source_map()\n-                                .span_to_snippet(base.span)\n-                                .unwrap_or_else(|_|\n-                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                            let help = \"instead of using tuple indexing, use array indexing\";\n-                            let suggestion = format!(\"{}[{}]\", base, field);\n-                            let applicability = if len < user_index {\n-                                Applicability::MachineApplicable\n-                            } else {\n-                                Applicability::MaybeIncorrect\n-                            };\n-                            err.span_suggestion(\n-                                expr.span, help, suggestion, applicability\n-                            );\n-                        }\n-                    }\n-                    ty::RawPtr(..) => {\n-                        let base = self.tcx.sess.source_map()\n-                            .span_to_snippet(base.span)\n-                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-                        let suggestion = format!(\"(*{}).{}\", base, field);\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &msg,\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {}\n-                }\n-                err\n+            type_error_struct!(\n+                self.tcx().sess,\n+                field.span,\n+                expr_t,\n+                E0610,\n+                \"`{}` is a primitive type and therefore doesn't have fields\",\n+                expr_t\n+            )\n+            .emit();\n+        }\n+\n+        self.tcx().types.err\n+    }\n+\n+    fn ban_private_field_access(\n+        &self,\n+        expr: &hir::Expr,\n+        expr_t: Ty<'tcx>,\n+        field: ast::Ident,\n+        base_did: DefId,\n+    ) {\n+        let struct_path = self.tcx().def_path_str(base_did);\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            expr.span,\n+            E0616,\n+            \"field `{}` of struct `{}` is private\",\n+            field,\n+            struct_path\n+        );\n+        // Also check if an accessible method exists, which is often what is meant.\n+        if self.method_exists(field, expr_t, expr.hir_id, false)\n+            && !self.expr_in_place(expr.hir_id)\n+        {\n+            self.suggest_method_call(\n+                &mut err,\n+                &format!(\"a method `{}` also exists, call it with parentheses\", field),\n+                field,\n+                expr_t,\n+                expr.hir_id,\n+            );\n+        }\n+        err.emit();\n+    }\n+\n+    fn ban_take_value_of_method(&self, expr: &hir::Expr, expr_t: Ty<'tcx>, field: ast::Ident) {\n+        let mut err = type_error_struct!(\n+            self.tcx().sess,\n+            field.span,\n+            expr_t,\n+            E0615,\n+            \"attempted to take value of method `{}` on type `{}`\",\n+            field,\n+            expr_t\n+        );\n+\n+        if !self.expr_in_place(expr.hir_id) {\n+            self.suggest_method_call(\n+                &mut err,\n+                \"use parentheses to call the method\",\n+                field,\n+                expr_t,\n+                expr.hir_id\n+            );\n+        } else {\n+            err.help(\"methods are immutable and cannot be assigned to\");\n+        }\n+\n+        err.emit();\n+    }\n+\n+    fn suggest_fields_on_recordish(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def: &'tcx ty::AdtDef,\n+        field: ast::Ident,\n+    ) {\n+        if let Some(suggested_field_name) =\n+            Self::suggest_field_name(def.non_enum_variant(), &field.as_str(), vec![])\n+        {\n+            err.span_suggestion(\n+                field.span,\n+                \"a field with a similar name exists\",\n+                suggested_field_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(field.span, \"unknown field\");\n+            let struct_variant_def = def.non_enum_variant();\n+            let field_names = self.available_field_names(struct_variant_def);\n+            if !field_names.is_empty() {\n+                err.note(&format!(\"available fields are: {}\",\n+                                    self.name_series_display(field_names)));\n+            }\n+        }\n+    }\n+\n+    fn maybe_suggest_array_indexing(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        base: &hir::Expr,\n+        field: ast::Ident,\n+        len: &ty::Const<'tcx>,\n+    ) {\n+        if let (Some(len), Ok(user_index)) = (\n+            len.try_eval_usize(self.tcx, self.param_env),\n+            field.as_str().parse::<u64>()\n+        ) {\n+            let base = self.tcx.sess.source_map()\n+                .span_to_snippet(base.span)\n+                .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+            let help = \"instead of using tuple indexing, use array indexing\";\n+            let suggestion = format!(\"{}[{}]\", base, field);\n+            let applicability = if len < user_index {\n+                Applicability::MachineApplicable\n             } else {\n-                type_error_struct!(self.tcx().sess, field.span, expr_t, E0610,\n-                                   \"`{}` is a primitive type and therefore doesn't have fields\",\n-                                   expr_t)\n-            }.emit();\n-            self.tcx().types.err\n+                Applicability::MaybeIncorrect\n+            };\n+            err.span_suggestion(expr.span, help, suggestion, applicability);\n         }\n     }\n \n+    fn suggest_first_deref_field(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        base: &hir::Expr,\n+        field: ast::Ident,\n+    ) {\n+        let base = self.tcx.sess.source_map()\n+            .span_to_snippet(base.span)\n+            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n+        let suggestion = format!(\"(*{}).{}\", base, field);\n+        err.span_suggestion(\n+            expr.span,\n+            &msg,\n+            suggestion,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS<'_>)\n         -> DiagnosticBuilder<'_> {\n         type_error_struct!(self.tcx().sess, span, expr_t, E0609,"}, {"sha": "dfbf8bcd0f60fcdf26d583f381480ea469b3cc02", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -67,7 +67,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n     match intrinsic {\n         \"size_of\" | \"min_align_of\" | \"needs_drop\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n-        \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+        \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n         \"saturating_add\" | \"saturating_sub\" |\n         \"rotate_left\" | \"rotate_right\" |\n         \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\" |\n@@ -314,7 +314,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![param(0), param(0)], param(0)),\n             \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n-            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n+            \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n             \"saturating_add\" | \"saturating_sub\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}, {"sha": "53024d97c3b134eb04581257bb55cddab50950b9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -985,7 +985,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude\n                     // import or other generated ones.\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -995,7 +995,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                 hir::ItemKind::ExternCrate(_) => {}\n                 // ...but do place them before the first other item.\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         // Don't insert between attributes and an item.\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());"}, {"sha": "9c7ac83e82e9712d10de1bc31b0930a5788cebc7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 126, "deletions": 12, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1325,12 +1325,94 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def_id);\n }\n \n+/// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n+/// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n-    origin: &hir::OpaqueTyOrigin\n+    origin: &hir::OpaqueTyOrigin,\n+) {\n+    check_opaque_for_inheriting_lifetimes(tcx, def_id, span);\n+    check_opaque_for_cycles(tcx, def_id, substs, span, origin);\n+}\n+\n+/// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n+/// in \"inheriting lifetimes\".\n+fn check_opaque_for_inheriting_lifetimes(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    span: Span,\n+) {\n+    let item = tcx.hir().expect_item(\n+        tcx.hir().as_local_hir_id(def_id).expect(\"opaque type is not local\"));\n+    debug!(\"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n+           def_id, span, item);\n+\n+    #[derive(Debug)]\n+    struct ProhibitOpaqueVisitor<'tcx> {\n+        opaque_identity_ty: Ty<'tcx>,\n+        generics: &'tcx ty::Generics,\n+    };\n+\n+    impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n+            if t == self.opaque_identity_ty { false } else { t.super_visit_with(self) }\n+        }\n+\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n+            if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n+                return *index < self.generics.parent_count as u32;\n+            }\n+\n+            r.super_visit_with(self)\n+        }\n+    }\n+\n+    let prohibit_opaque = match item.node {\n+        ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::AsyncFn, .. }) |\n+        ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn, .. }) => {\n+            let mut visitor = ProhibitOpaqueVisitor {\n+                opaque_identity_ty: tcx.mk_opaque(\n+                    def_id, InternalSubsts::identity_for_item(tcx, def_id)),\n+                generics: tcx.generics_of(def_id),\n+            };\n+            debug!(\"check_opaque_for_inheriting_lifetimes: visitor={:?}\", visitor);\n+\n+            tcx.predicates_of(def_id).predicates.iter().any(\n+                |(predicate, _)| predicate.visit_with(&mut visitor))\n+        },\n+        _ => false,\n+    };\n+\n+    debug!(\"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}\", prohibit_opaque);\n+    if prohibit_opaque {\n+        let is_async = match item.node {\n+            ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n+                hir::OpaqueTyOrigin::AsyncFn => true,\n+                _ => false,\n+            },\n+            _ => unreachable!(),\n+        };\n+\n+        tcx.sess.span_err(span, &format!(\n+            \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n+             a parent scope\",\n+            if is_async { \"async fn\" } else { \"impl Trait\" },\n+        ));\n+    }\n+}\n+\n+/// Checks that an opaque type does not contain cycles.\n+fn check_opaque_for_cycles<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+    span: Span,\n+    origin: &hir::OpaqueTyOrigin,\n ) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n         if let hir::OpaqueTyOrigin::AsyncFn = origin {\n@@ -1834,9 +1916,7 @@ fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, d\n     );\n     let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n     err.span_label(sp, &msg);\n-    if let &[.., ref end] = &variant_spans[..] {\n-        // FIXME: Ping cfg(bootstrap) -- Use `ref start @ ..` with new bootstrap compiler.\n-        let start = &variant_spans[..variant_spans.len() - 1];\n+    if let &[ref start @ .., ref end] = &variant_spans[..] {\n         for variant_span in start {\n             err.span_label(*variant_span, \"\");\n         }\n@@ -1968,19 +2048,19 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n     }\n \n     for v in vs {\n-        if let Some(ref e) = v.node.disr_expr {\n+        if let Some(ref e) = v.disr_expr {\n             tcx.typeck_tables_of(tcx.hir().local_def_id(e.hir_id));\n         }\n     }\n \n     if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n         let is_unit =\n-            |var: &hir::Variant| match var.node.data {\n+            |var: &hir::Variant| match var.data {\n                 hir::VariantData::Unit(..) => true,\n                 _ => false\n             };\n \n-        let has_disr = |var: &hir::Variant| var.node.disr_expr.is_some();\n+        let has_disr = |var: &hir::Variant| var.disr_expr.is_some();\n         let has_non_units = vs.iter().any(|var| !is_unit(var));\n         let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n         let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n@@ -1999,11 +2079,11 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n-            let i_span = match variant_i.node.disr_expr {\n+            let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => tcx.hir().span(variant_i_hir_id)\n             };\n-            let span = match v.node.disr_expr {\n+            let span = match v.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => v.span\n             };\n@@ -2863,7 +2943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n             (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n         };\n-        (tr, ast::Ident::with_empty_ctxt(name))\n+        (tr, ast::Ident::with_dummy_span(name))\n     }\n \n     fn try_overloaded_place_op(&self,\n@@ -3820,6 +3900,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err, &fn_decl, expected, found, can_suggest);\n         }\n         self.suggest_ref_or_into(err, expression, expected, found);\n+        self.suggest_boxing_when_appropriate(err, expression, expected, found);\n         pointing_at_return_type\n     }\n \n@@ -3980,6 +4061,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n+    /// in the heap by calling `Box::new()`.\n+    fn suggest_boxing_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return;\n+        }\n+        if !expected.is_box() || found.is_box() {\n+            return;\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(boxed_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            err.span_suggestion(\n+                expr.span,\n+                \"store this in the heap by calling `Box::new`\",\n+                format!(\"Box::new({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\"for more on the distinction between the stack and the \\\n+                        heap, read https://doc.rust-lang.org/book/ch15-01-box.html, \\\n+                        https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n+                        https://doc.rust-lang.org/std/boxed/index.html\");\n+        }\n+    }\n+\n+\n     /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n     ///\n     /// ```\n@@ -4081,8 +4197,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// A possible error is to forget to add `.await` when using futures:\n     ///\n     /// ```\n-    /// #![feature(async_await)]\n-    ///\n     /// async fn make_u32() -> u32 {\n     ///     22\n     /// }"}, {"sha": "9c6ea7d30ccf980830c33f22f9815c02cbd5a521", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -191,7 +191,7 @@ fn check_associated_item(\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n+            ty::TraitContainer(_) => (vec![], fcx.tcx.types.self_param),\n             ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n                                           fcx.tcx.type_of(def_id))\n         };\n@@ -203,7 +203,6 @@ fn check_associated_item(\n                 fcx.register_wf_obligation(ty, span, code.clone());\n             }\n             ty::AssocKind::Method => {\n-                reject_shadowing_parameters(fcx.tcx, item.def_id);\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n                 let sig = fcx.normalize_associated_types_in(span, &sig);\n                 check_fn_or_method(tcx, fcx, span, sig,\n@@ -998,34 +997,6 @@ fn report_bivariance(tcx: TyCtxt<'_>, span: Span, param_name: ast::Name) {\n     err.emit();\n }\n \n-fn reject_shadowing_parameters(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let generics = tcx.generics_of(def_id);\n-    let parent = tcx.generics_of(generics.parent.unwrap());\n-    let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n-        GenericParamDefKind::Lifetime => None,\n-        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n-            Some((param.name, param.def_id))\n-        }\n-    }).collect();\n-\n-    for method_param in &generics.params {\n-        // Shadowing is checked in `resolve_lifetime`.\n-        if let GenericParamDefKind::Lifetime = method_param.kind {\n-            continue\n-        }\n-        if impl_params.contains_key(&method_param.name) {\n-            // Tighten up the span to focus on only the shadowing type.\n-            let type_span = tcx.def_span(method_param.def_id);\n-\n-            // The expectation here is that the original trait declaration is\n-            // local so it should be okay to just unwrap everything.\n-            let trait_def_id = impl_params[&method_param.name];\n-            let trait_decl_span = tcx.def_span(trait_def_id);\n-            error_194(tcx, type_span, trait_decl_span, &method_param.name.as_str()[..]);\n-        }\n-    }\n-}\n-\n /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n /// aren't true.\n fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n@@ -1119,7 +1090,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n         enum_def.variants.iter()\n-            .map(|variant| self.non_enum_variant(&variant.node.data))\n+            .map(|variant| self.non_enum_variant(&variant.data))\n             .collect()\n     }\n \n@@ -1152,12 +1123,3 @@ fn error_392(\n     err.span_label(span, \"unused parameter\");\n     err\n }\n-\n-fn error_194(tcx: TyCtxt<'_>, span: Span, trait_decl_span: Span, name: &str) {\n-    struct_span_err!(tcx.sess, span, E0194,\n-                     \"type parameter `{}` shadows another type parameter of the same name\",\n-                     name)\n-        .span_label(span, \"shadows another type parameter\")\n-        .span_label(trait_decl_span, format!(\"first `{}` declared here\", name))\n-        .emit();\n-}"}, {"sha": "a88e32eb34dcd51011beaca14c1275b3879d80f6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -283,7 +283,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    self.visit_field_id(field.node.hir_id);\n+                    self.visit_field_id(field.hir_id);\n                 }\n             }\n             _ => {}"}, {"sha": "312a598af02bf20962c6a67e6abe8f725afec00f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -35,7 +35,6 @@ use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n-use syntax::source_map::Spanned;\n use syntax::feature_gate;\n use syntax::symbol::{InternedString, kw, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -520,7 +519,11 @@ fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants: &[hir::Variant]) {\n+fn convert_enum_variant_types<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    variants: &[hir::Variant]\n+) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n@@ -530,7 +533,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n     for variant in variants {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.node.disr_expr {\n+            if let Some(ref e) = variant.disr_expr {\n                 let expr_did = tcx.hir().local_def_id(e.hir_id);\n                 def.eval_explicit_discr(tcx, expr_did)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n@@ -546,14 +549,14 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n                     format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n                 ).note(&format!(\n                     \"explicitly set `{} = {}` if that is desired outcome\",\n-                    variant.node.ident, wrapped_discr\n+                    variant.ident, wrapped_discr\n                 ))\n                 .emit();\n                 None\n             }.unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.node.data.fields() {\n+        for f in variant.data.fields() {\n             let def_id = tcx.hir().local_def_id(f.hir_id);\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n@@ -562,7 +565,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n             convert_variant_ctor(tcx, ctor_hir_id);\n         }\n     }\n@@ -641,20 +644,20 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n             let variants = def.variants\n                 .iter()\n                 .map(|v| {\n-                    let variant_did = Some(tcx.hir().local_def_id(v.node.id));\n-                    let ctor_did = v.node.data.ctor_hir_id()\n+                    let variant_did = Some(tcx.hir().local_def_id(v.id));\n+                    let ctor_did = v.data.ctor_hir_id()\n                         .map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n-                    let discr = if let Some(ref e) = v.node.disr_expr {\n+                    let discr = if let Some(ref e) = v.disr_expr {\n                         distance_from_explicit = 0;\n                         ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id))\n                     } else {\n                         ty::VariantDiscr::Relative(distance_from_explicit)\n                     };\n                     distance_from_explicit += 1;\n \n-                    convert_variant(tcx, variant_did, ctor_did, v.node.ident, discr,\n-                                    &v.node.data, AdtKind::Enum, def_id)\n+                    convert_variant(tcx, variant_did, ctor_did, v.ident, discr,\n+                                    &v.data, AdtKind::Enum, def_id)\n                 })\n                 .collect();\n \n@@ -713,7 +716,7 @@ fn super_predicates_of(\n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n     // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-    let self_param_ty = tcx.mk_self_type();\n+    let self_param_ty = tcx.types.self_param;\n     let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No,\n         item.span);\n \n@@ -897,6 +900,20 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id(parent_id))\n         }\n+        // FIXME(#43408) enable this in all cases when we get lazy normalization.\n+        Node::AnonConst(&anon_const) => {\n+            // HACK(eddyb) this provides the correct generics when the workaround\n+            // for a const parameter `AnonConst` is being used elsewhere, as then\n+            // there won't be the kind of cyclic dependency blocking #43408.\n+            let expr = &tcx.hir().body(anon_const.body).value;\n+            let icx = ItemCtxt::new(tcx, def_id);\n+            if AstConv::const_param_def_id(&icx, expr).is_some() {\n+                let parent_id = tcx.hir().get_parent_item(hir_id);\n+                Some(tcx.hir().local_def_id(parent_id))\n+            } else {\n+                None\n+            }\n+        }\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n@@ -1011,13 +1028,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         synthetic,\n                         ..\n                     } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\"\n-                            );\n-                        }\n-\n                         if !allow_defaults && default.is_some() {\n                             if !tcx.features().default_type_parameter_fallback {\n                                 tcx.lint_hir(\n@@ -1041,13 +1051,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         }\n                     }\n                     GenericParamKind::Const { .. } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\",\n-                            );\n-                        }\n-\n                         ty::GenericParamDefKind::Const\n                     }\n                     _ => return None,\n@@ -1314,10 +1317,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        Node::Ctor(&ref def) | Node::Variant(&Spanned {\n-            node: hir::VariantKind { data: ref def, .. },\n-            ..\n-        }) => match *def {\n+        Node::Ctor(&ref def) | Node::Variant(\n+            hir::Variant { data: ref def, .. }\n+        ) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n                 tcx.type_of(tcx.hir().get_parent_did(hir_id))\n             }\n@@ -1363,12 +1365,8 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     tcx.types.usize\n                 }\n \n-                Node::Variant(&Spanned {\n-                    node:\n-                        VariantKind {\n-                            disr_expr: Some(ref e),\n-                            ..\n-                        },\n+                Node::Variant(Variant {\n+                    disr_expr: Some(ref e),\n                     ..\n                 }) if e.hir_id == hir_id =>\n                 {\n@@ -1569,7 +1567,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                     &format!(\n                                         \"defining opaque type use restricts opaque \\\n                                          type by using the generic parameter `{}` twice\",\n-                                        p.name\n+                                        p,\n                                     ),\n                                 );\n                                 return;\n@@ -1809,10 +1807,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        Ctor(data) | Variant(Spanned {\n-            node: hir::VariantKind { data, ..  },\n-            ..\n-        }) if data.ctor_hir_id().is_some() => {\n+        Ctor(data) | Variant(\n+            hir::Variant { data, ..  }\n+        ) if data.ctor_hir_id().is_some() => {\n             let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id));\n             let inputs = data.fields()\n                 .iter()"}, {"sha": "b52183d4b1b56de2e6aaec4ea4d2ddc93e218560", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1718,22 +1718,6 @@ Since we know for certain that `Wrapper<u32>` implements `Clone`, there's no\n reason to also specify it in a `where` clause.\n \"##,\n \n-E0194: r##\"\n-A type parameter was declared which shadows an existing one. An example of this\n-error:\n-\n-```compile_fail,E0194\n-trait Foo<T> {\n-    fn do_something(&self) -> T;\n-    fn do_something_else<T: Clone>(&self, bar: T);\n-}\n-```\n-\n-In this example, the trait `Foo` and the trait method `do_something_else` both\n-define a type parameter `T`. This is not allowed: if the method wishes to\n-define a type parameter, it must use a different name for it.\n-\"##,\n-\n E0195: r##\"\n Your method's lifetime parameters do not match the trait declaration.\n Erroneous code example:\n@@ -4767,7 +4751,6 @@ E0733: r##\"\n Recursion in an `async fn` requires boxing. For example, this will not compile:\n \n ```edition2018,compile_fail,E0733\n-#![feature(async_await)]\n async fn foo(n: usize) {\n     if n > 0 {\n         foo(n - 1).await;\n@@ -4779,12 +4762,11 @@ To achieve async recursion, the `async fn` needs to be desugared\n such that the `Future` is explicit in the return type:\n \n ```edition2018,compile_fail,E0720\n-# #![feature(async_await)]\n use std::future::Future;\n-fn foo_desugered(n: usize) -> impl Future<Output = ()> {\n+fn foo_desugared(n: usize) -> impl Future<Output = ()> {\n     async move {\n         if n > 0 {\n-            foo_desugered(n - 1).await;\n+            foo_desugared(n - 1).await;\n         }\n     }\n }\n@@ -4793,7 +4775,6 @@ fn foo_desugered(n: usize) -> impl Future<Output = ()> {\n Finally, the future is wrapped in a pinned box:\n \n ```edition2018\n-# #![feature(async_await)]\n use std::future::Future;\n use std::pin::Pin;\n fn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\n@@ -4837,6 +4818,7 @@ register_diagnostics! {\n //  E0188, // can not cast an immutable reference to a mutable pointer\n //  E0189, // deprecated: can only cast a boxed pointer to a boxed object\n //  E0190, // deprecated: can only cast a &-pointer to an &-object\n+//  E0194, // merged into E0403\n //  E0196, // cannot determine a type for this closure\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported"}, {"sha": "644d723ded5d96e60a3369ea7fb4d6aff0ac114a", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -3,7 +3,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::TypeFoldable;\n use rustc::util::nodemap::FxHashMap;\n \n use super::explicit::ExplicitPredicatesMap;\n@@ -178,11 +177,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // let _: () = substs.region_at(0);\n                 check_explicit_predicates(\n                     tcx,\n-                    &def.did,\n+                    def.did,\n                     substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -208,11 +207,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                         .substs;\n                     check_explicit_predicates(\n                         tcx,\n-                        &ex_trait_ref.skip_binder().def_id,\n+                        ex_trait_ref.skip_binder().def_id,\n                         substs,\n                         required_predicates,\n                         explicit_map,\n-                        IgnoreSelfTy(true),\n+                        Some(tcx.types.self_param),\n                     );\n                 }\n             }\n@@ -223,11 +222,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    &tcx.associated_item(obj.item_def_id).container.id(),\n+                    tcx.associated_item(obj.item_def_id).container.id(),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -236,9 +235,6 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     }\n }\n \n-#[derive(Debug)]\n-pub struct IgnoreSelfTy(bool);\n-\n /// We also have to check the explicit predicates\n /// declared on the type.\n ///\n@@ -256,25 +252,25 @@ pub struct IgnoreSelfTy(bool);\n /// applying the substitution as above.\n pub fn check_explicit_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: &DefId,\n+    def_id: DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n-    ignore_self_ty: IgnoreSelfTy,\n+    ignored_self_ty: Option<Ty<'tcx>>,\n ) {\n     debug!(\n         \"check_explicit_predicates(def_id={:?}, \\\n          substs={:?}, \\\n          explicit_map={:?}, \\\n          required_predicates={:?}, \\\n-         ignore_self_ty={:?})\",\n+         ignored_self_ty={:?})\",\n         def_id,\n         substs,\n         explicit_map,\n         required_predicates,\n-        ignore_self_ty,\n+        ignored_self_ty,\n     );\n-    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, *def_id);\n+    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n     for outlives_predicate in explicit_predicates.iter() {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n@@ -313,9 +309,9 @@ pub fn check_explicit_predicates<'tcx>(\n         // = X` binding from the object type (there must be such a\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n-        if ignore_self_ty.0 {\n+        if let Some(self_ty) = ignored_self_ty {\n             if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.has_self_ty() {\n+                if ty.walk().any(|ty| ty == self_ty) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}, {"sha": "7ed9d6606f646fed672be8e8ae60e0d6d3937f92", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -82,8 +82,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 self.visit_node_helper(item.hir_id);\n \n                 for variant in &enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.visit_node_helper(variant.node.data.ctor_hir_id().unwrap());\n+                    if let hir::VariantData::Tuple(..) = variant.data {\n+                        self.visit_node_helper(variant.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "e10837e52ad0407e76cb82405fea59d8963bd7ce", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -145,8 +145,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                 self.add_inferreds_for_item(item.hir_id);\n \n                 for variant in &enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.add_inferreds_for_item(variant.node.data.ctor_hir_id().unwrap());\n+                    if let hir::VariantData::Tuple(..) = variant.data {\n+                        self.add_inferreds_for_item(variant.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "ec5d86b2c611da4076610301e4ee3c9f7b0512a9", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -3,7 +3,6 @@ use super::*;\n use syntax_pos::DUMMY_SP;\n use syntax::ast::*;\n use syntax::attr;\n-use syntax::source_map::dummy_spanned;\n use syntax::symbol::Symbol;\n use syntax::with_default_globals;\n \n@@ -181,7 +180,8 @@ fn test_parse_ok() {\n \n         let mi = attr::mk_name_value_item_str(\n             Ident::from_str(\"all\"),\n-            dummy_spanned(Symbol::intern(\"done\"))\n+            Symbol::intern(\"done\"),\n+            DUMMY_SP,\n         );\n         assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n "}, {"sha": "9b4803ce41e290718ebb9ef7a609b4cccf5a7564", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -29,7 +29,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n-use syntax::source_map::{dummy_spanned, Spanned};\n+use syntax::source_map::DUMMY_SP;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n@@ -930,8 +930,8 @@ impl Attributes {\n             if attr.check_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n                     let meta = attr::mk_name_value_item_str(\n-                        Ident::with_empty_ctxt(sym::target_feature),\n-                        dummy_spanned(feat));\n+                        Ident::with_dummy_span(sym::target_feature), feat, DUMMY_SP\n+                    );\n                     if let Ok(feat_cfg) = Cfg::parse(&meta) {\n                         cfg &= feat_cfg;\n                     }\n@@ -2303,7 +2303,7 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(def_id) => {\n                             cx.tcx.type_of(def_id)\n                         }\n-                        ty::TraitContainer(_) => cx.tcx.mk_self_type()\n+                        ty::TraitContainer(_) => cx.tcx.types.self_param,\n                     };\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n@@ -4102,12 +4102,14 @@ fn name_from_pat(p: &hir::Pat) -> String {\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n-                fields.iter().map(|&Spanned { node: ref fp, .. }|\n-                                  format!(\"{}: {}\", fp.ident, name_from_pat(&*fp.pat)))\n+                fields.iter().map(|fp| format!(\"{}: {}\", fp.ident, name_from_pat(&fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ..\" } else { \"\" }\n             )\n         }\n+        PatKind::Or(ref pats) => {\n+            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n+        }\n         PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n         PatKind::Box(ref p) => name_from_pat(&**p),"}, {"sha": "3801c42307fc6f00099bfb01217c258dfa809dda", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -149,9 +149,11 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId,\n         return true\n     }\n     let predicates = cx.tcx.super_predicates_of(child);\n+    debug_assert!(cx.tcx.generics_of(child).has_self);\n+    let self_ty = cx.tcx.types.self_param;\n     predicates.predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n-            if pred.skip_binder().trait_ref.self_ty().is_self() {\n+            if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                 Some(pred.def_id())\n             } else {\n                 None"}, {"sha": "c73c46472d804aeeb0fbf1c2e03dc343ab4ca8fa", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint as lint;\n use rustc::ty;\n+use rustc_resolve::ParentScope;\n use syntax;\n use syntax::ast::{self, Ident};\n use syntax::ext::base::SyntaxExtensionKind;\n@@ -431,7 +432,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     let path = ast::Path::from_ident(Ident::from_str(path_str));\n     cx.enter_resolver(|resolver| {\n         if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path, None, &resolver.dummy_parent_scope(), false, false\n+            &path, None, &ParentScope::module(resolver.graph_root), false, false\n         ) {\n             if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));"}, {"sha": "83a8d3fc109994d008510c0538b670133b0dd72c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -951,7 +951,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n                      v: &'hir hir::Variant,\n                      g: &'hir hir::Generics,\n                      item_id: hir::HirId) {\n-        self.visit_testable(v.node.ident.to_string(), &v.node.attrs, |this| {\n+        self.visit_testable(v.ident.to_string(), &v.attrs, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }"}, {"sha": "903ed3aae147016e8173e54a798296fa2c639ebc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -130,10 +130,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         Enum {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n-                name: v.node.ident.name,\n-                id: v.node.id,\n-                attrs: &v.node.attrs,\n-                def: &v.node.data,\n+                name: v.ident.name,\n+                id: v.id,\n+                attrs: &v.attrs,\n+                def: &v.data,\n                 whence: v.span,\n             }).collect(),\n             vis: &it.vis,"}, {"sha": "bb77a5bdea493e1eb2d820e6fe5824981dbca4a6", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -23,10 +23,10 @@ libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.16\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n-hashbrown = { version = \"0.4.0\", features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace]\n-version = \"0.3.34\"\n+version = \"0.3.35\"\n default-features = false # don't use coresymbolication on OSX\n features = [\n   \"rustc-dep-of-std\", # enable build support for integrating into libstd"}, {"sha": "a0538986a22421b4fc0cc1cac02738b006f036ef", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -6,7 +6,7 @@ use hashbrown::hash_map as base;\n \n use crate::borrow::Borrow;\n use crate::cell::Cell;\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::fmt::{self, Debug};\n #[allow(deprecated)]\n use crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\n@@ -588,7 +588,7 @@ where\n     /// ```\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.base\n             .try_reserve(additional)\n             .map_err(map_collection_alloc_err)\n@@ -2542,10 +2542,13 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n }\n \n #[inline]\n-fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> CollectionAllocErr {\n+fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> TryReserveError {\n     match err {\n-        hashbrown::CollectionAllocErr::CapacityOverflow => CollectionAllocErr::CapacityOverflow,\n-        hashbrown::CollectionAllocErr::AllocErr => CollectionAllocErr::AllocErr,\n+        hashbrown::CollectionAllocErr::CapacityOverflow => TryReserveError::CapacityOverflow,\n+        hashbrown::CollectionAllocErr::AllocErr { layout } => TryReserveError::AllocError {\n+            layout,\n+            non_exhaustive: (),\n+        },\n     }\n }\n \n@@ -2605,7 +2608,7 @@ mod test_map {\n     use super::RandomState;\n     use crate::cell::RefCell;\n     use rand::{thread_rng, Rng};\n-    use realstd::collections::CollectionAllocErr::*;\n+    use realstd::collections::TryReserveError::*;\n     use realstd::usize;\n \n     // https://github.com/rust-lang/rust/issues/62301\n@@ -3405,7 +3408,7 @@ mod test_map {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n \n-        if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n+        if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n         } else {\n             panic!(\"usize::MAX / 8 should trigger an OOM!\")\n         }"}, {"sha": "26db651ef8911d8194532f0f71a4a870586f3373", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow::Borrow;\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{Hash, BuildHasher};\n use crate::iter::{Chain, FromIterator, FusedIterator};\n@@ -383,7 +383,7 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.map.try_reserve(additional)\n     }\n "}, {"sha": "f5957466be841009683e087023f5527bd8951e3a", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -427,7 +427,7 @@ pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub use alloc_crate::collections::CollectionAllocErr;\n+pub use alloc_crate::collections::TryReserveError;\n \n mod hash;\n "}, {"sha": "5060f368229bb848821664e8fe48baadc9a227fe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -353,20 +353,25 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    read_to_end_with_reservation(r, buf, 32)\n+    read_to_end_with_reservation(r, buf, |_| 32)\n }\n \n-fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n-                                                  buf: &mut Vec<u8>,\n-                                                  reservation_size: usize) -> Result<usize>\n+fn read_to_end_with_reservation<R, F>(\n+    r: &mut R,\n+    buf: &mut Vec<u8>,\n+    mut reservation_size: F,\n+) -> Result<usize>\n+where\n+    R: Read + ?Sized,\n+    F: FnMut(&R) -> usize,\n {\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf: buf };\n     let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n-                g.buf.reserve(reservation_size);\n+                g.buf.reserve(reservation_size(r));\n                 let capacity = g.buf.capacity();\n                 g.buf.set_len(capacity);\n                 r.initializer().initialize(&mut g.buf[g.len..]);\n@@ -2253,9 +2258,10 @@ impl<T: Read> Read for Take<T> {\n     }\n \n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        let reservation_size = cmp::min(self.limit, 32) as usize;\n-\n-        read_to_end_with_reservation(self, buf, reservation_size)\n+        // Pass in a reservation_size closure that respects the current value\n+        // of limit for each read. If we hit the read limit, this prevents the\n+        // final zero-byte read from allocating again.\n+        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n     }\n }\n \n@@ -2378,6 +2384,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n \n #[cfg(test)]\n mod tests {\n+    use crate::cmp;\n     use crate::io::prelude::*;\n     use super::{Cursor, SeekFrom, repeat};\n     use crate::io::{self, IoSlice, IoSliceMut};\n@@ -2651,6 +2658,49 @@ mod tests {\n         Ok(())\n     }\n \n+    // A simple example reader which uses the default implementation of\n+    // read_to_end.\n+    struct ExampleSliceReader<'a> {\n+        slice: &'a [u8],\n+    }\n+\n+    impl<'a> Read for ExampleSliceReader<'a> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let len = cmp::min(self.slice.len(), buf.len());\n+            buf[..len].copy_from_slice(&self.slice[..len]);\n+            self.slice = &self.slice[len..];\n+            Ok(len)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_to_end_capacity() -> io::Result<()> {\n+        let input = &b\"foo\"[..];\n+\n+        // read_to_end() generally needs to over-allocate, both for efficiency\n+        // and so that it can distinguish EOF. Assert that this is the case\n+        // with this simple ExampleSliceReader struct, which uses the default\n+        // implementation of read_to_end. Even though vec1 is allocated with\n+        // exactly enough capacity for the read, read_to_end will allocate more\n+        // space here.\n+        let mut vec1 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n+        assert_eq!(vec1.len(), input.len());\n+        assert!(vec1.capacity() > input.len(), \"allocated more\");\n+\n+        // However, std::io::Take includes an implementation of read_to_end\n+        // that will not allocate when the limit has already been reached. In\n+        // this case, vec2 never grows.\n+        let mut vec2 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }\n+            .take(input.len() as u64)\n+            .read_to_end(&mut vec2)?;\n+        assert_eq!(vec2.len(), input.len());\n+        assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n+\n+        Ok(())\n+    }\n+\n     #[test]\n     fn io_slice_mut_advance() {\n         let mut buf1 = [1; 8];"}, {"sha": "85a9dea09ed0d7500433340a5352a1bbc0cd1dcf", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -984,7 +984,6 @@ mod where_keyword { }\n \n // 2018 Edition keywords\n \n-#[unstable(feature = \"async_await\", issue = \"50547\")]\n #[doc(keyword = \"async\")]\n //\n /// Return a [`Future`] instead of blocking the current thread.\n@@ -995,7 +994,6 @@ mod where_keyword { }\n /// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n mod async_keyword { }\n \n-#[unstable(feature = \"async_await\", issue = \"50547\")]\n #[doc(keyword = \"await\")]\n //\n /// Suspend execution until the result of a [`Future`] is ready."}, {"sha": "c3882bacf87eb0bcdbadcc9eb6a144772cac95a6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -228,7 +228,6 @@\n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n // NB: the following list is sorted to minimize merge conflicts.\n-#![cfg_attr(not(bootstrap), feature(__rust_unstable_column))]\n #![feature(alloc_error_handler)]\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]\n@@ -251,6 +250,7 @@\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n #![feature(const_raw_ptr_deref)]\n+#![feature(container_error_extra)]\n #![feature(core_intrinsics)]\n #![feature(custom_test_frameworks)]\n #![feature(doc_alias)]\n@@ -513,7 +513,7 @@ pub use std_detect::detect;\n \n // Re-export macros defined in libcore.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated_in_future)]\n+#[allow(deprecated, deprecated_in_future)]\n pub use core::{\n     // Stable\n     assert_eq,\n@@ -531,7 +531,6 @@ pub use core::{\n };\n \n // Re-export built-in macros defined through libcore.\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use core::{\n     // Stable\n@@ -551,7 +550,6 @@ pub use core::{\n     option_env,\n     stringify,\n     // Unstable\n-    __rust_unstable_column,\n     asm,\n     concat_idents,\n     format_args_nl,"}, {"sha": "cbeaf20b13adc923fc5a913e378fdb76a56a316b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -53,20 +53,20 @@\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable(__rust_unstable_column, libstd_sys_internals)]\n+#[allow_internal_unstable(libstd_sys_internals)]\n macro_rules! panic {\n     () => ({\n         $crate::panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        $crate::rt::begin_panic($msg, &(file!(), line!(), __rust_unstable_column!()))\n+        $crate::rt::begin_panic($msg, &($crate::file!(), $crate::line!(), $crate::column!()))\n     });\n     ($msg:expr,) => ({\n         $crate::panic!($msg)\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_panic_fmt(&format_args!($fmt, $($arg)+),\n-                                    &(file!(), line!(), __rust_unstable_column!()))\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+),\n+                                    &($crate::file!(), $crate::line!(), $crate::column!()))\n     });\n }\n \n@@ -113,7 +113,7 @@ macro_rules! panic {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! print {\n-    ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n+    ($($arg:tt)*) => ($crate::io::_print($crate::format_args!($($arg)*)));\n }\n \n /// Prints to the standard output, with a newline.\n@@ -147,7 +147,7 @@ macro_rules! print {\n macro_rules! println {\n     () => ($crate::print!(\"\\n\"));\n     ($($arg:tt)*) => ({\n-        $crate::io::_print(format_args_nl!($($arg)*));\n+        $crate::io::_print($crate::format_args_nl!($($arg)*));\n     })\n }\n \n@@ -176,7 +176,7 @@ macro_rules! println {\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! eprint {\n-    ($($arg:tt)*) => ($crate::io::_eprint(format_args!($($arg)*)));\n+    ($($arg:tt)*) => ($crate::io::_eprint($crate::format_args!($($arg)*)));\n }\n \n /// Prints to the standard error, with a newline.\n@@ -206,7 +206,7 @@ macro_rules! eprint {\n macro_rules! eprintln {\n     () => ($crate::eprint!(\"\\n\"));\n     ($($arg:tt)*) => ({\n-        $crate::io::_eprint(format_args_nl!($($arg)*));\n+        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n     })\n }\n \n@@ -337,15 +337,15 @@ macro_rules! eprintln {\n #[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\n macro_rules! dbg {\n     () => {\n-        $crate::eprintln!(\"[{}:{}]\", file!(), line!());\n+        $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n     };\n     ($val:expr) => {\n         // Use of `match` here is intentional because it affects the lifetimes\n         // of temporaries - https://stackoverflow.com/a/48732525/1063961\n         match $val {\n             tmp => {\n                 $crate::eprintln!(\"[{}:{}] {} = {:#?}\",\n-                    file!(), line!(), stringify!($val), &tmp);\n+                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &tmp);\n                 tmp\n             }\n         }"}, {"sha": "d8b6fb6da93951533e1126ec87e8a17bd3df86a7", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1597,7 +1597,8 @@ mod tests {\n \n     // FIXME: re-enabled openbsd tests once their socket timeout code\n     //        no longer has rounding errors.\n-    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n+    // VxWorks ignores SO_SNDTIMEO.\n+    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     #[test]\n     fn timeouts() {"}, {"sha": "a5e7cd992f2272d226ef606c489b02f34183fac0", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1026,7 +1026,8 @@ mod tests {\n \n     // FIXME: re-enabled openbsd/netbsd tests once their socket timeout code\n     //        no longer has rounding errors.\n-    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n+    // VxWorks ignores SO_SNDTIMEO.\n+    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n     #[test]\n     fn timeouts() {\n         let addr = next_test_ip4();"}, {"sha": "611a1709c8d91c688fc5014ecad786eec9c5baea", "filename": "src/libstd/os/raw/mod.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -8,8 +8,7 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n-#[cfg_attr(bootstrap, doc(include = \"os/raw/char.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"char.md\"))]\n+#[doc(include = \"char.md\")]\n #[cfg(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                        target_arch = \"arm\",\n                                        target_arch = \"hexagon\",\n@@ -33,8 +32,7 @@\n                                          target_arch = \"powerpc\")),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/char.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"char.md\"))]\n+#[doc(include = \"char.md\")]\n #[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                            target_arch = \"arm\",\n                                            target_arch = \"hexagon\",\n@@ -58,51 +56,37 @@\n                                              target_arch = \"powerpc\")),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/schar.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"schar.md\"))]\n+#[doc(include = \"schar.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/uchar.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"uchar.md\"))]\n+#[doc(include = \"uchar.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/short.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"short.md\"))]\n+#[doc(include = \"short.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_short = i16;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ushort.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ushort.md\"))]\n+#[doc(include = \"ushort.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ushort = u16;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/int.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"int.md\"))]\n+#[doc(include = \"int.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_int = i32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/uint.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"uint.md\"))]\n+#[doc(include = \"uint.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uint = u32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/long.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"long.md\"))]\n+#[doc(include = \"long.md\")]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ulong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ulong.md\"))]\n+#[doc(include = \"ulong.md\")]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/long.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"long.md\"))]\n+#[doc(include = \"long.md\")]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ulong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ulong.md\"))]\n+#[doc(include = \"ulong.md\")]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/longlong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"longlong.md\"))]\n+#[doc(include = \"longlong.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_longlong = i64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ulonglong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ulonglong.md\"))]\n+#[doc(include = \"ulonglong.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulonglong = u64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/float.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"float.md\"))]\n+#[doc(include = \"float.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_float = f32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/double.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"double.md\"))]\n+#[doc(include = \"double.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_double = f64;\n \n #[stable(feature = \"raw_os\", since = \"1.1.0\")]"}, {"sha": "3e4cf91127fc5b87ad1d99594260f1f3c327466e", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -7,10 +7,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Re-exported core operators\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::marker::Copy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::marker::{Send, Sized, Sync, Unpin};\n@@ -24,21 +20,9 @@ pub use crate::ops::{Drop, Fn, FnMut, FnOnce};\n pub use crate::mem::drop;\n \n // Re-exported types and traits\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::clone::Clone;\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::convert::{AsRef, AsMut, Into, From};\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::default::Default;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::iter::{Iterator, Extend, IntoIterator};\n@@ -53,11 +37,9 @@ pub use crate::option::Option::{self, Some, None};\n pub use crate::result::Result::{self, Ok, Err};\n \n // Re-exported built-in macros\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use core::prelude::v1::{\n-    __rust_unstable_column,\n     asm,\n     assert,\n     cfg,\n@@ -83,7 +65,6 @@ pub use core::prelude::v1::{\n \n // FIXME: Attribute and derive macros are not documented because for them rustdoc generates\n // dead links which fail link checker testing.\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(hidden)]"}, {"sha": "fd6e46fd61dc581d7c331de0aecba4c16a6ece5f", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -163,7 +163,6 @@ pub use self::condvar::{Condvar, WaitTimeoutResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::mutex::{Mutex, MutexGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(bootstrap, allow(deprecated_in_future))]\n #[allow(deprecated)]\n pub use self::once::{Once, OnceState, ONCE_INIT};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "38db4dd51657a10a864d4ab85e4ed3a9e63988d9", "filename": "src/libstd/sys/cloudabi/abi/cloudabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -115,6 +115,7 @@\n \n #![no_std]\n #![allow(non_camel_case_types)]\n+#![allow(deprecated)] // FIXME: using `mem::uninitialized()`\n \n include!(\"bitflags.rs\");\n "}, {"sha": "2fb10cc370add607dade6387b5008fae03fc310f", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,3 @@\n-#![allow(deprecated_in_future)] // mem::uninitialized; becomes `deprecated` when nightly is 1.39\n-\n use crate::io::ErrorKind;\n use crate::mem;\n "}, {"sha": "0e30d3a1c6cf124989c40c642db5cece663622d6", "filename": "src/libstd/sys/cloudabi/mutex.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -104,10 +104,11 @@ impl ReentrantMutex {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n+            let event = event.assume_init();\n             assert_eq!(event.error, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n         }\n     }"}, {"sha": "73499d65a067fa46e637facecd3997444be33c79", "filename": "src/libstd/sys/cloudabi/rwlock.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,5 +1,6 @@\n use crate::cell::UnsafeCell;\n use crate::mem;\n+use crate::mem::MaybeUninit;\n use crate::sync::atomic::{AtomicU32, Ordering};\n use crate::sys::cloudabi::abi;\n \n@@ -73,10 +74,11 @@ impl RWLock {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire read lock\");\n+            let event = event.assume_init();\n             assert_eq!(\n                 event.error,\n                 abi::errno::SUCCESS,\n@@ -182,10 +184,11 @@ impl RWLock {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire write lock\");\n+            let event = event.assume_init();\n             assert_eq!(\n                 event.error,\n                 abi::errno::SUCCESS,"}, {"sha": "240b6ea9e57f8ede0d75755e1eca01a6d7b7737b", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -72,10 +72,11 @@ impl Thread {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = mem::MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = mem::MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS);\n+            let event = event.assume_init();\n             assert_eq!(event.error, abi::errno::SUCCESS);\n         }\n     }"}, {"sha": "21fca23a8fe9ea98aa4077dcda4e40aa2e3c59a5", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -20,6 +20,30 @@ cfg_if::cfg_if! {\n     }\n }\n \n+// Android with api less than 21 define sig* functions inline, so it is not\n+// available for dynamic link. Implementing sigemptyset and sigaddset allow us\n+// to support older Android version (independent of libc version).\n+// The following implementations are based on https://git.io/vSkNf\n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"android\")] {\n+        pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n+            set.write_bytes(0u8, 1);\n+            return 0;\n+        }\n+        #[allow(dead_code)]\n+        pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n+            use crate::{slice, mem};\n+\n+            let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n+            let bit = (signum - 1) as usize;\n+            raw[bit / 8] |= 1 << (bit % 8);\n+            return 0;\n+        }\n+    } else {\n+        pub use libc::{sigemptyset, sigaddset};\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n@@ -429,36 +453,6 @@ mod tests {\n         }\n     }\n \n-    // Android with api less than 21 define sig* functions inline, so it is not\n-    // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n-    // to support older Android version (independent of libc version).\n-    // The following implementations are based on https://git.io/vSkNf\n-\n-    #[cfg(not(target_os = \"android\"))]\n-    extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n-        fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n-\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n-        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n-        set.write_bytes(0u8, 1);\n-        return 0;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        use crate::slice;\n-\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n-        let bit = (signum - 1) as usize;\n-        raw[bit / 8] |= 1 << (bit % 8);\n-        return 0;\n-    }\n-\n     // See #14232 for more information, but it appears that signal delivery to a\n     // newly spawned process may just be raced in the macOS, so to prevent this\n     // test from being flaky we ignore it on macOS."}, {"sha": "a9711c71b7aa36503480f97152227ae9ce6967e5", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -214,14 +214,7 @@ impl Command {\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n             let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            if cfg!(target_os = \"android\") {\n-                // Implementing sigemptyset allow us to support older Android\n-                // versions. See the comment about Android and sig* functions in\n-                // process_common.rs\n-                set.as_mut_ptr().write_bytes(0u8, 1);\n-            } else {\n-                cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n-            }\n+            cvt(sigemptyset(set.as_mut_ptr()))?;\n             cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(),\n                                          ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n@@ -363,10 +356,10 @@ impl Command {\n             }\n \n             let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n+            cvt(sigemptyset(set.as_mut_ptr()))?;\n             cvt(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(),\n                                                  set.as_ptr()))?;\n-            cvt(libc::sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n+            cvt(sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n             cvt(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(),\n                                                     set.as_ptr()))?;\n "}, {"sha": "ba797354a7380f30935297b4dcf3110571e51f6d", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -155,7 +155,7 @@ impl Command {\n         _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n     ) {\n         // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n-        unimplemented!();;\n+        unimplemented!();\n     }\n \n     pub fn stdin(&mut self, stdin: Stdio) {"}, {"sha": "b1f9d9766f7055ff17079704420d8782c98a24cb", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -714,7 +714,7 @@ if #[cfg(target_vendor = \"uwp\")] {\n     pub struct FILE_STANDARD_INFO {\n         pub AllocationSize: LARGE_INTEGER,\n         pub EndOfFile: LARGE_INTEGER,\n-        pub NumberOfLink: DWORD,\n+        pub NumberOfLinks: DWORD,\n         pub DeletePending: BOOLEAN,\n         pub Directory: BOOLEAN,\n     }"}, {"sha": "204f6af5fc1a0432788922315838da2deb70b86e", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -357,7 +357,7 @@ impl File {\n                                                 size as c::DWORD))?;\n             attr.file_size = info.AllocationSize as u64;\n             attr.number_of_links = Some(info.NumberOfLinks);\n-            if attr.is_reparse_point() {\n+            if attr.file_type().is_reparse_point() {\n                 let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n                     attr.reparse_tag = buf.ReparseTag;"}, {"sha": "50e428ea0cca6ce1702303a1453033182e5a6922", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -5,7 +5,7 @@ pub use UnsafeSource::*;\n pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n-use crate::ext::hygiene::{ExpnId, SyntaxContext};\n+use crate::ext::hygiene::ExpnId;\n use crate::parse::token::{self, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n@@ -571,10 +571,11 @@ impl Pat {\n \n         match &self.node {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n-            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.node.pat.walk(it)),\n-            PatKind::TupleStruct(_, s) | PatKind::Tuple(s) | PatKind::Slice(s) => {\n-                s.iter().all(|p| p.walk(it))\n-            }\n+            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk(it)),\n+            PatKind::TupleStruct(_, s)\n+            | PatKind::Tuple(s)\n+            | PatKind::Slice(s)\n+            | PatKind::Or(s) => s.iter().all(|p| p.walk(it)),\n             PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n             PatKind::Wild\n             | PatKind::Rest\n@@ -608,6 +609,8 @@ pub struct FieldPat {\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n@@ -641,11 +644,15 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, Vec<Spanned<FieldPat>>, /* recovered */ bool),\n+    Struct(Path, Vec<FieldPat>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n     TupleStruct(Path, Vec<P<Pat>>),\n \n+    /// An or-pattern `A | B | C`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or(Vec<P<Pat>>),\n+\n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n     /// or associated constants. Qualified path patterns `<A>::B::C`/`<A as Trait>::B::C` can\n@@ -925,6 +932,7 @@ pub struct Arm {\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n     pub span: Span,\n+    pub id: NodeId,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -934,10 +942,9 @@ pub struct Field {\n     pub span: Span,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n+    pub id: NodeId,\n }\n \n-pub type SpannedIdent = Spanned<Ident>;\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n@@ -1284,19 +1291,18 @@ pub enum Movability {\n     Movable,\n }\n \n-pub type Mac = Spanned<Mac_>;\n-\n /// Represents a macro invocation. The `Path` indicates which macro\n /// is being invoked, and the vector of token-trees contains the source\n /// of the macro invocation.\n ///\n /// N.B., the additional ident for a `macro_rules`-style macro is actually\n /// stored in the enclosing item.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Mac_ {\n+pub struct Mac {\n     pub path: Path,\n     pub delim: MacDelimiter,\n     pub tts: TokenStream,\n+    pub span: Span,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n@@ -1307,7 +1313,7 @@ pub enum MacDelimiter {\n     Brace,\n }\n \n-impl Mac_ {\n+impl Mac {\n     pub fn stream(&self) -> TokenStream {\n         self.tts.clone()\n     }\n@@ -1781,7 +1787,6 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    pub ctxt: SyntaxContext,\n }\n \n /// An argument in a function header.\n@@ -2029,7 +2034,6 @@ pub struct ForeignMod {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n-    pub ctxt: SyntaxContext,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2038,7 +2042,7 @@ pub struct EnumDef {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Variant_ {\n+pub struct Variant {\n     /// Name of the variant.\n     pub ident: Ident,\n     /// Attributes of the variant.\n@@ -2049,10 +2053,10 @@ pub struct Variant_ {\n     pub data: VariantData,\n     /// Explicit discriminant, e.g., `Foo = 1`.\n     pub disr_expr: Option<AnonConst>,\n+    /// Span\n+    pub span: Span,\n }\n \n-pub type Variant = Spanned<Variant_>;\n-\n /// Part of `use` item to the right of its prefix.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum UseTreeKind {"}, {"sha": "bcf03b5237a8d1a33c73b0ee66b5ea2caa702d6e", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -13,7 +13,7 @@ use crate::ast::{AttrId, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n-use crate::source_map::{BytePos, Spanned, dummy_spanned};\n+use crate::source_map::{BytePos, Spanned, DUMMY_SP};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n@@ -327,8 +327,10 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                Ident::with_empty_ctxt(sym::doc),\n-                dummy_spanned(Symbol::intern(&strip_doc_comment_decoration(&comment.as_str()))));\n+                Ident::with_dummy_span(sym::doc),\n+                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())),\n+                DUMMY_SP,\n+            );\n             f(&Attribute {\n                 id: self.id,\n                 style: self.style,\n@@ -345,9 +347,9 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n-    let lit_kind = LitKind::Str(value.node, ast::StrStyle::Cooked);\n-    mk_name_value_item(ident, lit_kind, value.span)\n+pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n+    let lit_kind = LitKind::Str(str, ast::StrStyle::Cooked);\n+    mk_name_value_item(ident, lit_kind, str_span)\n }\n \n pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n@@ -410,7 +412,7 @@ pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id: mk_attr_id(),\n         style,\n-        path: Path::from_ident(Ident::with_empty_ctxt(sym::doc).with_span_pos(span)),\n+        path: Path::from_ident(Ident::with_dummy_span(sym::doc).with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n@@ -712,7 +714,7 @@ macro_rules! derive_has_attrs {\n \n derive_has_attrs! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant_, ast::Arg\n+    ast::Field, ast::FieldPat, ast::Variant, ast::Arg\n }\n \n pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {"}, {"sha": "7eeea4e7bdfe191d92ea850bce252ac62cbbd69f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -260,7 +260,7 @@ impl<'a> StripUnconfigured<'a> {\n             ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n                 variants.flat_map_in_place(|variant| self.configure(variant));\n                 for variant in variants {\n-                    self.configure_variant_data(&mut variant.node.data);\n+                    self.configure_variant_data(&mut variant.data);\n                 }\n             }\n             _ => {}"}, {"sha": "9618b5acfb0f18d8b72d8e07b385a265398507c9", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -172,7 +172,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         });\n \n-    let static_ = ecx.lifetime(span, Ident::with_empty_ctxt(kw::StaticLifetime));\n+    let static_ = ecx.lifetime(span, Ident::with_dummy_span(kw::StaticLifetime));\n     let ty_str = ecx.ty_rptr(\n         span,\n         ecx.ty_ident(span, ecx.ident_of(\"str\")),"}, {"sha": "b0a4a6af9839c4fd91e6f33541b241c3f313593c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 39, "deletions": 66, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,6 +1,6 @@\n-use crate::ast::{self, Attribute, Name, PatKind};\n+use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n-use crate::source_map::{SourceMap, Spanned, respan};\n+use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n@@ -15,7 +15,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -405,7 +405,6 @@ impl MacResult for MacEager {\n /// after hitting errors.\n #[derive(Copy, Clone)]\n pub struct DummyResult {\n-    expr_only: bool,\n     is_error: bool,\n     span: Span,\n }\n@@ -416,21 +415,12 @@ impl DummyResult {\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n     pub fn any(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: false, is_error: true, span })\n+        Box::new(DummyResult { is_error: true, span })\n     }\n \n     /// Same as `any`, but must be a valid fragment, not error.\n     pub fn any_valid(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: false, is_error: false, span })\n-    }\n-\n-    /// Creates a default MacResult that can only be an expression.\n-    ///\n-    /// Use this for macros that must expand to an expression, so even\n-    /// if an error is encountered internally, the user will receive\n-    /// an error that they also used it in the wrong place.\n-    pub fn expr(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: true, is_error: true, span })\n+        Box::new(DummyResult { is_error: false, span })\n     }\n \n     /// A plain dummy expression.\n@@ -472,36 +462,19 @@ impl MacResult for DummyResult {\n     }\n \n     fn make_items(self: Box<DummyResult>) -> Option<SmallVec<[P<ast::Item>; 1]>> {\n-        // this code needs a comment... why not always just return the Some() ?\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::ImplItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::TraitItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_foreign_items(self: Box<Self>) -> Option<SmallVec<[ast::ForeignItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVec<[ast::Stmt; 1]>> {\n@@ -667,10 +640,11 @@ impl SyntaxExtension {\n         SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n     }\n \n-    pub fn expn_info(&self, call_site: Span, descr: Symbol) -> ExpnInfo {\n-        ExpnInfo {\n-            call_site,\n+    pub fn expn_data(&self, parent: ExpnId, call_site: Span, descr: Symbol) -> ExpnData {\n+        ExpnData {\n             kind: ExpnKind::Macro(self.macro_kind(), descr),\n+            parent,\n+            call_site,\n             def_site: self.span,\n             default_transparency: self.default_transparency,\n             allow_internal_unstable: self.allow_internal_unstable.clone(),\n@@ -697,13 +671,13 @@ bitflags::bitflags! {\n }\n \n pub trait Resolver {\n-    fn next_node_id(&mut self) -> ast::NodeId;\n+    fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]);\n+                                            extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n     fn resolve_imports(&mut self);\n@@ -734,7 +708,7 @@ pub struct ExpansionData {\n \n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n-/// -> expn_info` of their expansion context stored into their span.\n+/// -> expn_data` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n@@ -783,13 +757,10 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        match self.current_expansion.id.expn_info() {\n-            Some(expn_info) => expn_info.call_site,\n-            None => DUMMY_SP,\n-        }\n+        self.current_expansion.id.expn_data().call_site\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::empty().apply_mark(self.current_expansion.id)\n+        SyntaxContext::root().apply_mark(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n@@ -799,17 +770,13 @@ impl<'a> ExtCtxt<'a> {\n         let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            if ctxt.outer_expn_info().map_or(None, |info| {\n-                if info.kind.descr() == sym::include {\n-                    // Stop going up the backtrace once include! is encountered\n-                    return None;\n-                }\n-                ctxt = info.call_site.ctxt();\n-                last_macro = Some(info.call_site);\n-                Some(())\n-            }).is_none() {\n-                break\n+            let expn_data = ctxt.outer_expn_data();\n+            // Stop going up the backtrace once include! is encountered\n+            if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n+                break;\n             }\n+            ctxt = expn_data.call_site.ctxt();\n+            last_macro = Some(expn_data.call_site);\n         }\n         last_macro\n     }\n@@ -899,7 +866,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n         let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n-            .chain(components.iter().map(|&s| Ident::with_empty_ctxt(s)))\n+            .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {\n@@ -943,15 +910,17 @@ pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt<'_>,\n     mut expr: P<ast::Expr>,\n     err_msg: &str,\n-) -> Result<Spanned<(Symbol, ast::StrStyle)>, Option<DiagnosticBuilder<'a>>> {\n+) -> Result<(Symbol, ast::StrStyle, Span), Option<DiagnosticBuilder<'a>>> {\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n     expr.span = expr.span.apply_mark(cx.current_expansion.id);\n \n-    // we want to be able to handle e.g., `concat!(\"foo\", \"bar\")`\n-    cx.expander().visit_expr(&mut expr);\n+    // Perform eager expansion on the expression.\n+    // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n+    let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n+\n     Err(match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(s, style) => return Ok(respan(expr.span, (s, style))),\n+            ast::LitKind::Str(s, style) => return Ok((s, style, expr.span)),\n             ast::LitKind::Err(_) => None,\n             _ => Some(cx.struct_span_err(l.span, err_msg))\n         },\n@@ -965,7 +934,7 @@ pub fn expr_to_string(cx: &mut ExtCtxt<'_>, expr: P<ast::Expr>, err_msg: &str)\n     expr_to_spanned_string(cx, expr, err_msg)\n         .map_err(|err| err.map(|mut err| err.emit()))\n         .ok()\n-        .map(|s| s.node)\n+        .map(|(symbol, style, _)| (symbol, style))\n }\n \n /// Non-fatally assert that `tts` is empty. Note that this function\n@@ -1013,8 +982,12 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>,\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        let mut expr = panictry!(p.parse_expr());\n-        cx.expander().visit_expr(&mut expr);\n+        let expr = panictry!(p.parse_expr());\n+\n+        // Perform eager expansion on the expression.\n+        // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n+        let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n+\n         es.push(expr);\n         if p.eat(&token::Comma) {\n             continue;"}, {"sha": "e2ac4d573a1e0adde3c0892dd2d48557948727e9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -340,7 +340,7 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     pub fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, Ident::with_empty_ctxt(kw::SelfLower))\n+        self.expr_ident(span, Ident::with_dummy_span(kw::SelfLower))\n     }\n \n     pub fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n@@ -403,6 +403,7 @@ impl<'a> ExtCtxt<'a> {\n             span,\n             is_shorthand: false,\n             attrs: ThinVec::new(),\n+            id: ast::DUMMY_NODE_ID,\n         }\n     }\n     pub fn expr_struct(\n@@ -574,7 +575,7 @@ impl<'a> ExtCtxt<'a> {\n         self.pat(span, PatKind::TupleStruct(path, subpats))\n     }\n     pub fn pat_struct(&self, span: Span, path: ast::Path,\n-                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n+                      field_pats: Vec<ast::FieldPat>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Struct(path, field_pats, false))\n     }\n     pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n@@ -612,6 +613,7 @@ impl<'a> ExtCtxt<'a> {\n             guard: None,\n             body: expr,\n             span,\n+            id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n@@ -781,14 +783,14 @@ impl<'a> ExtCtxt<'a> {\n             ast::VariantData::Tuple(fields, ast::DUMMY_NODE_ID)\n         };\n \n-        respan(span,\n-               ast::Variant_ {\n-                   ident,\n-                   id: ast::DUMMY_NODE_ID,\n-                   attrs: Vec::new(),\n-                   data: vdata,\n-                   disr_expr: None,\n-               })\n+        ast::Variant {\n+            attrs: Vec::new(),\n+            data: vdata,\n+            disr_expr: None,\n+            id: ast::DUMMY_NODE_ID,\n+            ident,\n+            span,\n+        }\n     }\n \n     pub fn item_enum_poly(&self, span: Span, name: Ident,"}, {"sha": "c1d52c9745529125ddcfed00d900d8bd5d65731c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,11 +1,11 @@\n use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n use crate::attr::{self, HasAttrs};\n-use crate::source_map::{dummy_spanned, respan};\n+use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::proc_macro::collect_derives;\n-use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n@@ -25,7 +25,6 @@ use syntax_pos::{Span, DUMMY_SP, FileName};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use std::fs;\n use std::io::ErrorKind;\n use std::{iter, mem};\n use std::ops::DerefMut;\n@@ -116,18 +115,6 @@ macro_rules! ast_fragments {\n             }\n         }\n \n-        impl<'a, 'b> MutVisitor for MacroExpander<'a, 'b> {\n-            fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-                self.expand_fragment(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n-            }\n-            $($(fn $mut_visit_ast(&mut self, ast: &mut $AstTy) {\n-                visit_clobber(ast, |ast| self.expand_fragment(AstFragment::$Kind(ast)).$make_ast());\n-            })?)*\n-            $($(fn $flat_map_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n-                self.expand_fragment(AstFragment::$Kind(smallvec![ast_elt])).$make_ast()\n-            })?)*\n-        }\n-\n         impl<'a> MacResult for crate::ext::tt::macro_rules::ParserAnyMacro<'a> {\n             $(fn $make_ast(self: Box<crate::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n                            -> Option<$AstTy> {\n@@ -265,7 +252,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             tokens: None,\n         })]);\n \n-        match self.expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n+        match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n             Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n@@ -285,8 +272,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate\n     }\n \n-    // Fully expand all macro invocations in this AST fragment.\n-    fn expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n+    // Recursively expand all macro invocations in this AST fragment.\n+    pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         self.cx.current_expansion.depth = 0;\n \n@@ -304,7 +291,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Unresolved macros produce dummy outputs as a recovery measure.\n         invocations.reverse();\n         let mut expanded_fragments = Vec::new();\n-        let mut derives: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n+        let mut all_derive_placeholders: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n@@ -360,13 +347,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                 let mut item = self.fully_configure(item);\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derives = derives.entry(invoc.expansion_data.id).or_default();\n+                let derive_placeholders =\n+                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n \n-                derives.reserve(traits.len());\n+                derive_placeholders.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n-                    let expn_id = ExpnId::fresh(self.cx.current_expansion.id, None);\n-                    derives.push(expn_id);\n+                    let expn_id = ExpnId::fresh(None);\n+                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive { path, item: item.clone() },\n                         fragment_kind: invoc.fragment_kind,\n@@ -378,7 +366,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 let fragment = invoc.fragment_kind\n                     .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derives)\n+                self.collect_invocations(fragment, derive_placeholders)\n             } else {\n                 unreachable!()\n             };\n@@ -397,10 +385,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n-            for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n-                let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_expn_id(mark),\n-                                         expanded_fragment, derives);\n+            for (expn_id, expanded_fragment) in expanded_fragments.into_iter().rev() {\n+                let derive_placeholders =\n+                    all_derive_placeholders.remove(&expn_id).unwrap_or_else(Vec::new);\n+                placeholder_expander.add(NodeId::placeholder_from_expn_id(expn_id),\n+                                         expanded_fragment, derive_placeholders);\n             }\n         }\n         fragment_with_placeholders.mut_visit_with(&mut placeholder_expander);\n@@ -417,7 +406,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[ExpnId])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, extra_placeholders: &[NodeId])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n@@ -436,9 +425,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             collector.invocations\n         };\n \n+        // FIXME: Merge `extra_placeholders` into the `fragment` as regular placeholders.\n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.id, &fragment, derives);\n+                self.cx.current_expansion.id, &fragment, extra_placeholders);\n         }\n \n         (fragment, invocations)\n@@ -487,11 +477,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let info = self.cx.current_expansion.id.expn_info().unwrap();\n+            let expn_data = self.cx.current_expansion.id.expn_data();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n-            let mut err = self.cx.struct_span_err(info.call_site,\n+            let mut err = self.cx.struct_span_err(expn_data.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         info.kind.descr()));\n+                         expn_data.kind.descr()));\n             err.help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                 suggested_limit));\n@@ -504,22 +494,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    let tok_result = expander.expand(self.cx, span, mac.stream());\n                     let result =\n-                        self.parse_ast_fragment(tok_result, fragment_kind, &mac.node.path, span);\n+                        self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n                     result\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n-                    self.cx.current_expansion.prior_type_ascription =\n-                        mac.node.prior_type_ascription;\n-                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n+                    let tok_result = expander.expand(self.cx, span, mac.stream());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n                         let msg = format!(\"non-{kind} macro in {kind} position: {path}\",\n-                                          kind = fragment_kind.name(), path = mac.node.path);\n+                                          kind = fragment_kind.name(), path = mac.path);\n                         self.cx.span_err(span, &msg);\n                         self.cx.trace_macros_diag();\n                         fragment_kind.dummy(span)\n@@ -772,7 +761,7 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n             // Avoid emitting backtrace info twice.\n-            let def_site_span = self.token.span.with_ctxt(SyntaxContext::empty());\n+            let def_site_span = self.token.span.with_ctxt(SyntaxContext::root());\n             let mut err = self.diagnostic().struct_span_err(def_site_span, &msg);\n             err.span_label(span, \"caused by the macro expansion here\");\n             let msg = format!(\n@@ -809,17 +798,20 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        // Expansion info for all the collected invocations is set upon their resolution,\n+        // Expansion data for all the collected invocations is set upon their resolution,\n         // with exception of the derive container case which is not resolved and can get\n-        // its expansion info immediately.\n-        let expn_info = match &kind {\n-            InvocationKind::DeriveContainer { item, .. } => Some(ExpnInfo::default(\n-                ExpnKind::Macro(MacroKind::Attr, sym::derive),\n-                item.span(), self.cx.parse_sess.edition,\n-            )),\n+        // its expansion data immediately.\n+        let expn_data = match &kind {\n+            InvocationKind::DeriveContainer { item, .. } => Some(ExpnData {\n+                parent: self.cx.current_expansion.id,\n+                ..ExpnData::default(\n+                    ExpnKind::Macro(MacroKind::Attr, sym::derive),\n+                    item.span(), self.cx.parse_sess.edition,\n+                )\n+            }),\n             _ => None,\n         };\n-        let expn_id = ExpnId::fresh(self.cx.current_expansion.id, expn_info);\n+        let expn_id = ExpnId::fresh(expn_data);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,\n@@ -1251,30 +1243,30 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     }\n \n                     let filename = self.cx.resolve_path(&*file.as_str(), it.span());\n-                    match fs::read_to_string(&filename) {\n-                        Ok(src) => {\n-                            let src_interned = Symbol::intern(&src);\n-\n-                            // Add this input file to the code map to make it available as\n-                            // dependency information\n-                            self.cx.source_map().new_source_file(filename.into(), src);\n+                    match self.cx.source_map().load_file(&filename) {\n+                        Ok(source_file) => {\n+                            let src = source_file.src.as_ref()\n+                                .expect(\"freshly loaded file should have a source\");\n+                            let src_interned = Symbol::intern(src.as_str());\n \n                             let include_info = vec![\n                                 ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n-                                        Ident::with_empty_ctxt(sym::file),\n-                                        dummy_spanned(file),\n+                                        Ident::with_dummy_span(sym::file),\n+                                        file,\n+                                        DUMMY_SP,\n                                     ),\n                                 ),\n                                 ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n-                                        Ident::with_empty_ctxt(sym::contents),\n-                                        dummy_spanned(src_interned),\n+                                        Ident::with_dummy_span(sym::contents),\n+                                        src_interned,\n+                                        DUMMY_SP,\n                                     ),\n                                 ),\n                             ];\n \n-                            let include_ident = Ident::with_empty_ctxt(sym::include);\n+                            let include_ident = Ident::with_dummy_span(sym::include);\n                             let item = attr::mk_list_item(include_ident, include_info);\n                             items.push(ast::NestedMetaItem::MetaItem(item));\n                         }\n@@ -1336,7 +1328,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 }\n             }\n \n-            let meta = attr::mk_list_item(Ident::with_empty_ctxt(sym::doc), items);\n+            let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = attr::Attribute {\n                 span: at.span,\n                 id: at.id,"}, {"sha": "d800cfedcfb4b27796b7a01f34ba3081479f0a2e", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -2,7 +2,6 @@ use crate::ast::{self, NodeId};\n use crate::source_map::{DUMMY_SP, dummy_spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::ExpnId;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n@@ -14,12 +13,13 @@ use rustc_data_structures::fx::FxHashMap;\n \n pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     fn mac_placeholder() -> ast::Mac {\n-        dummy_spanned(ast::Mac_ {\n+        ast::Mac {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n             tts: TokenStream::empty().into(),\n             delim: ast::MacDelimiter::Brace,\n+            span: DUMMY_SP,\n             prior_type_ascription: None,\n-        })\n+        }\n     }\n \n     let ident = ast::Ident::invalid();\n@@ -85,11 +85,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<ExpnId>) {\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, placeholders: Vec<NodeId>) {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n-            for derive in derives {\n-                match self.remove(NodeId::placeholder_from_expn_id(derive)) {\n+            for placeholder in placeholders {\n+                match self.remove(placeholder) {\n                     AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}, {"sha": "1619fa6994198efb139dcd6d3c9981b3ce7be439", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -362,10 +362,10 @@ pub(crate) struct Rustc<'a> {\n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_info().unwrap().call_site;\n+        let location = cx.current_expansion.id.expn_data().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n-                SyntaxContext::empty()\n+                SyntaxContext::root()\n                     .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n             )\n         };\n@@ -677,7 +677,7 @@ impl server::Span for Rustc<'_> {\n         self.sess.source_map().lookup_char_pos(span.lo()).file\n     }\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n-        span.ctxt().outer_expn_info().map(|i| i.call_site)\n+        span.parent()\n     }\n     fn source(&mut self, span: Self::Span) -> Self::Span {\n         span.source_callsite()"}, {"sha": "bce0b07db1c233b3f84bd207eb78dadf83bbc05c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 18, "deletions": 48, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -30,7 +30,6 @@ use crate::tokenstream::TokenTree;\n \n use errors::{Applicability, DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use log::debug;\n@@ -462,9 +461,6 @@ declare_features! (\n     // Allows using `#[doc(keyword = \"...\")]`.\n     (active, doc_keyword, \"1.28.0\", Some(51315), None),\n \n-    // Allows async and await syntax.\n-    (active, async_await, \"1.28.0\", Some(50547), None),\n-\n     // Allows reinterpretation of the bits of a value of one type as another type during const eval.\n     (active, const_transmute, \"1.29.0\", Some(53605), None),\n \n@@ -560,6 +556,9 @@ declare_features! (\n     // Allows `impl Trait` to be used inside type aliases (RFC 2515).\n     (active, type_alias_impl_trait, \"1.38.0\", Some(63063), None),\n \n+    // Allows the use of or-patterns, e.g. `0 | 1`.\n+    (active, or_patterns, \"1.38.0\", Some(54883), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -572,6 +571,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::impl_trait_in_bindings,\n     sym::generic_associated_types,\n     sym::const_generics,\n+    sym::or_patterns,\n     sym::let_chains,\n ];\n \n@@ -854,6 +854,8 @@ declare_features! (\n     (accepted, repr_align_enum, \"1.37.0\", Some(57996), None),\n     // Allows `const _: TYPE = VALUE`.\n     (accepted, underscore_const_names, \"1.37.0\", Some(54912), None),\n+    // Allows free and inherent `async fn`s, `async` blocks, and `<expr>.await` expressions.\n+    (accepted, async_await, \"1.38.0\", Some(50547), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features\n@@ -1956,7 +1958,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n             ast::ItemKind::Enum(ast::EnumDef{ref variants, ..}, ..) => {\n                 for variant in variants {\n-                    match (&variant.node.data, &variant.node.disr_expr) {\n+                    match (&variant.data, &variant.disr_expr) {\n                         (ast::VariantData::Unit(..), _) => {},\n                         (_, Some(disr_expr)) =>\n                             gate_feature_post!(\n@@ -2088,11 +2090,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                        \"type ascription is experimental\");\n                 }\n             }\n-            ast::ExprKind::Yield(..) => {\n-                gate_feature_post!(&self, generators,\n-                                  e.span,\n-                                  \"yield syntax is experimental\");\n-            }\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n@@ -2102,12 +2099,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                     \"labels on blocks are unstable\");\n                 }\n             }\n-            ast::ExprKind::Async(..) => {\n-                gate_feature_post!(&self, async_await, e.span, \"async blocks are unstable\");\n-            }\n-            ast::ExprKind::Await(_) => {\n-                gate_feature_post!(&self, async_await, e.span, \"async/await is unstable\");\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e)\n@@ -2156,11 +2147,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 span: Span,\n                 _node_id: NodeId) {\n         if let Some(header) = fn_kind.header() {\n-            // Check for const fn and async fn declarations.\n-            if header.asyncness.node.is_async() {\n-                gate_feature_post!(&self, async_await, span, \"async fn is unstable\");\n-            }\n-\n             // Stability of const fn methods are covered in\n             // `visit_trait_item` and `visit_impl_item` below; this is\n             // because default methods don't pass through this point.\n@@ -2200,9 +2186,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 if block.is_none() {\n                     self.check_abi(sig.header.abi, ti.span);\n                 }\n-                if sig.header.asyncness.node.is_async() {\n-                    gate_feature_post!(&self, async_await, ti.span, \"async fn is unstable\");\n-                }\n                 if sig.decl.c_variadic {\n                     gate_feature_post!(&self, c_variadic, ti.span,\n                                        \"C-variadic functions are unstable\");\n@@ -2427,10 +2410,6 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     features\n }\n \n-fn for_each_in_lock<T>(vec: &Lock<Vec<T>>, f: impl Fn(&T)) {\n-    vec.borrow().iter().for_each(f);\n-}\n-\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,\n@@ -2443,26 +2422,17 @@ pub fn check_crate(krate: &ast::Crate,\n         plugin_attributes,\n     };\n \n-    for_each_in_lock(&sess.param_attr_spans, |span| gate_feature!(\n-        &ctx,\n-        param_attrs,\n-        *span,\n-        \"attributes on function parameters are unstable\"\n-    ));\n-\n-    for_each_in_lock(&sess.let_chains_spans, |span| gate_feature!(\n-        &ctx,\n-        let_chains,\n-        *span,\n-        \"`let` expressions in this position are experimental\"\n-    ));\n-\n-    for_each_in_lock(&sess.async_closure_spans, |span| gate_feature!(\n-        &ctx,\n-        async_closure,\n-        *span,\n-        \"async closures are unstable\"\n-    ));\n+    macro_rules! gate_all {\n+        ($spans:ident, $gate:ident, $msg:literal) => {\n+            for span in &*sess.$spans.borrow() { gate_feature!(&ctx, $gate, *span, $msg); }\n+        }\n+    }\n+\n+    gate_all!(param_attr_spans, param_attrs, \"attributes on function parameters are unstable\");\n+    gate_all!(let_chains_spans, let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(async_closure_spans, async_closure, \"async closures are unstable\");\n+    gate_all!(yield_spans, generators, \"yield syntax is experimental\");\n+    gate_all!(or_pattern_spans, or_patterns, \"or-patterns syntax is experimental\");\n \n     let visitor = &mut PostExpansionVisitor {\n         context: &ctx,"}, {"sha": "9785f8e2de0980e2f4e5ebe9e3f95226d33da5c9", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -383,10 +383,11 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n }\n \n pub fn noop_visit_arm<T: MutVisitor>(\n-    Arm { attrs, pats, guard, body, span }: &mut Arm,\n+    Arm { attrs, pats, guard, body, span, id }: &mut Arm,\n     vis: &mut T,\n ) {\n     visit_attrs(attrs, vis);\n+    vis.visit_id(id);\n     visit_vec(pats, |pat| vis.visit_pat(pat));\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n     vis.visit_expr(body);\n@@ -455,7 +456,7 @@ pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis:\n }\n \n pub fn noop_visit_variant<T: MutVisitor>(variant: &mut Variant, vis: &mut T) {\n-    let Spanned { node: Variant_ { ident, attrs, id, data, disr_expr }, span } = variant;\n+    let Variant { ident, attrs, id, data, disr_expr, span } = variant;\n     vis.visit_ident(ident);\n     visit_attrs(attrs, vis);\n     vis.visit_id(id);\n@@ -532,8 +533,8 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_mac<T: MutVisitor>(Spanned { node, span }: &mut Mac, vis: &mut T) {\n-    let Mac_ { path, delim: _, tts, .. } = node;\n+pub fn noop_visit_mac<T: MutVisitor>(mac: &mut Mac, vis: &mut T) {\n+    let Mac { path, delim: _, tts, span, prior_type_ascription: _ } = mac;\n     vis.visit_path(path);\n     vis.visit_tts(tts);\n     vis.visit_span(span);\n@@ -808,9 +809,10 @@ pub fn noop_visit_struct_field<T: MutVisitor>(f: &mut StructField, visitor: &mut\n }\n \n pub fn noop_visit_field<T: MutVisitor>(f: &mut Field, vis: &mut T) {\n-    let Field { ident, expr, span, is_shorthand: _, attrs } = f;\n+    let Field { ident, expr, span, is_shorthand: _, attrs, id } = f;\n     vis.visit_ident(ident);\n     vis.visit_expr(expr);\n+    vis.visit_id(id);\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n }\n@@ -1040,22 +1042,24 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         }\n         PatKind::Struct(path, fields, _etc) => {\n             vis.visit_path(path);\n-            for Spanned { node: FieldPat { ident, pat, is_shorthand: _, attrs }, span } in fields {\n+            for FieldPat { ident, pat, is_shorthand: _, attrs, id, span } in fields {\n                 vis.visit_ident(ident);\n+                vis.visit_id(id);\n                 vis.visit_pat(pat);\n                 visit_thin_attrs(attrs, vis);\n                 vis.visit_span(span);\n             };\n         }\n-        PatKind::Tuple(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Box(inner) => vis.visit_pat(inner),\n         PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n         PatKind::Range(e1, e2, Spanned { span: _, node: _ }) => {\n             vis.visit_expr(e1);\n             vis.visit_expr(e2);\n             vis.visit_span(span);\n         }\n-        PatKind::Slice(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n+        PatKind::Tuple(elems)\n+        | PatKind::Slice(elems)\n+        | PatKind::Or(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::Mac(mac) => vis.visit_mac(mac),\n     }\n@@ -1179,7 +1183,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n         }\n         ExprKind::InlineAsm(asm) => {\n             let InlineAsm { asm: _, asm_str_style: _, outputs, inputs, clobbers: _, volatile: _,\n-                            alignstack: _, dialect: _, ctxt: _ } = asm.deref_mut();\n+                            alignstack: _, dialect: _ } = asm.deref_mut();\n             for out in outputs {\n                 let InlineAsmOutput { constraint: _, expr, is_rw: _, is_indirect: _ } = out;\n                 vis.visit_expr(expr);"}, {"sha": "1fbf28fb83016059d76952556e0510db3ad4feee", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -8,7 +8,6 @@ use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, Token\n use crate::parse::token::{self, TokenKind};\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::source_map::Spanned;\n use crate::symbol::{kw, sym};\n use crate::ThinVec;\n use crate::util::parser::AssocOp;\n@@ -592,18 +591,18 @@ impl<'a> Parser<'a> {\n \n     crate fn maybe_report_invalid_custom_discriminants(\n         sess: &ParseSess,\n-        variants: &[Spanned<ast::Variant_>],\n+        variants: &[ast::Variant],\n     ) {\n-        let has_fields = variants.iter().any(|variant| match variant.node.data {\n+        let has_fields = variants.iter().any(|variant| match variant.data {\n             VariantData::Tuple(..) | VariantData::Struct(..) => true,\n             VariantData::Unit(..) => false,\n         });\n \n-        let discriminant_spans = variants.iter().filter(|variant| match variant.node.data {\n+        let discriminant_spans = variants.iter().filter(|variant| match variant.data {\n             VariantData::Tuple(..) | VariantData::Struct(..) => false,\n             VariantData::Unit(..) => true,\n         })\n-        .filter_map(|variant| variant.node.disr_expr.as_ref().map(|c| c.value.span))\n+        .filter_map(|variant| variant.disr_expr.as_ref().map(|c| c.value.span))\n         .collect::<Vec<_>>();\n \n         if !discriminant_spans.is_empty() && has_fields {\n@@ -618,7 +617,7 @@ impl<'a> Parser<'a> {\n                 err.span_label(sp, \"disallowed custom discriminant\");\n             }\n             for variant in variants.iter() {\n-                match &variant.node.data {\n+                match &variant.data {\n                     VariantData::Struct(..) => {\n                         err.span_label(\n                             variant.span,"}, {"sha": "66add869359d800f030ddf5308351f3b794fb87c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 17, "deletions": 93, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -4,13 +4,11 @@ use crate::symbol::{sym, Symbol};\n use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n use errors::{FatalError, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos, Pos, Span};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n-use std::borrow::Cow;\n use std::char;\n-use std::iter;\n use std::convert::TryInto;\n use rustc_data_structures::sync::Lrc;\n use log::debug;\n@@ -84,7 +82,7 @@ impl<'a> StringReader<'a> {\n \n \n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n-        self.override_span.unwrap_or_else(|| Span::new(lo, hi, NO_EXPANSION))\n+        self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }\n \n     /// Returns the next token, including trivia like whitespace or comments.\n@@ -181,18 +179,7 @@ impl<'a> StringReader<'a> {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n                 let tok = if is_doc_comment(string) {\n-                    let mut idx = 0;\n-                    loop {\n-                        idx = match string[idx..].find('\\r') {\n-                            None => break,\n-                            Some(it) => idx + it + 1\n-                        };\n-                        if string[idx..].chars().next() != Some('\\n') {\n-                            self.err_span_(start + BytePos(idx as u32 - 1),\n-                                            start + BytePos(idx as u32),\n-                                            \"bare CR not allowed in doc-comment\");\n-                        }\n-                    }\n+                    self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n@@ -217,15 +204,10 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let tok = if is_doc_comment {\n-                    let has_cr = string.contains('\\r');\n-                    let string = if has_cr {\n-                        self.translate_crlf(start,\n-                                            string,\n-                                            \"bare CR not allowed in block doc-comment\")\n-                    } else {\n-                        string.into()\n-                    };\n-                    token::DocComment(Symbol::intern(&string[..]))\n+                    self.forbid_bare_cr(start,\n+                                        string,\n+                                        \"bare CR not allowed in block doc-comment\");\n+                    token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n                 };\n@@ -291,9 +273,6 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::TokenKind::Semi => token::Semi,\n             rustc_lexer::TokenKind::Comma => token::Comma,\n-            rustc_lexer::TokenKind::DotDotDot => token::DotDotDot,\n-            rustc_lexer::TokenKind::DotDotEq => token::DotDotEq,\n-            rustc_lexer::TokenKind::DotDot => token::DotDot,\n             rustc_lexer::TokenKind::Dot => token::Dot,\n             rustc_lexer::TokenKind::OpenParen => token::OpenDelim(token::Paren),\n             rustc_lexer::TokenKind::CloseParen => token::CloseDelim(token::Paren),\n@@ -305,42 +284,20 @@ impl<'a> StringReader<'a> {\n             rustc_lexer::TokenKind::Pound => token::Pound,\n             rustc_lexer::TokenKind::Tilde => token::Tilde,\n             rustc_lexer::TokenKind::Question => token::Question,\n-            rustc_lexer::TokenKind::ColonColon => token::ModSep,\n             rustc_lexer::TokenKind::Colon => token::Colon,\n             rustc_lexer::TokenKind::Dollar => token::Dollar,\n-            rustc_lexer::TokenKind::EqEq => token::EqEq,\n             rustc_lexer::TokenKind::Eq => token::Eq,\n-            rustc_lexer::TokenKind::FatArrow => token::FatArrow,\n-            rustc_lexer::TokenKind::Ne => token::Ne,\n             rustc_lexer::TokenKind::Not => token::Not,\n-            rustc_lexer::TokenKind::Le => token::Le,\n-            rustc_lexer::TokenKind::LArrow => token::LArrow,\n             rustc_lexer::TokenKind::Lt => token::Lt,\n-            rustc_lexer::TokenKind::ShlEq => token::BinOpEq(token::Shl),\n-            rustc_lexer::TokenKind::Shl => token::BinOp(token::Shl),\n-            rustc_lexer::TokenKind::Ge => token::Ge,\n             rustc_lexer::TokenKind::Gt => token::Gt,\n-            rustc_lexer::TokenKind::ShrEq => token::BinOpEq(token::Shr),\n-            rustc_lexer::TokenKind::Shr => token::BinOp(token::Shr),\n-            rustc_lexer::TokenKind::RArrow => token::RArrow,\n             rustc_lexer::TokenKind::Minus => token::BinOp(token::Minus),\n-            rustc_lexer::TokenKind::MinusEq => token::BinOpEq(token::Minus),\n             rustc_lexer::TokenKind::And => token::BinOp(token::And),\n-            rustc_lexer::TokenKind::AndEq => token::BinOpEq(token::And),\n-            rustc_lexer::TokenKind::AndAnd => token::AndAnd,\n             rustc_lexer::TokenKind::Or => token::BinOp(token::Or),\n-            rustc_lexer::TokenKind::OrEq => token::BinOpEq(token::Or),\n-            rustc_lexer::TokenKind::OrOr => token::OrOr,\n             rustc_lexer::TokenKind::Plus => token::BinOp(token::Plus),\n-            rustc_lexer::TokenKind::PlusEq => token::BinOpEq(token::Plus),\n             rustc_lexer::TokenKind::Star => token::BinOp(token::Star),\n-            rustc_lexer::TokenKind::StarEq => token::BinOpEq(token::Star),\n             rustc_lexer::TokenKind::Slash => token::BinOp(token::Slash),\n-            rustc_lexer::TokenKind::SlashEq => token::BinOpEq(token::Slash),\n             rustc_lexer::TokenKind::Caret => token::BinOp(token::Caret),\n-            rustc_lexer::TokenKind::CaretEq => token::BinOpEq(token::Caret),\n             rustc_lexer::TokenKind::Percent => token::BinOp(token::Percent),\n-            rustc_lexer::TokenKind::PercentEq => token::BinOpEq(token::Percent),\n \n             rustc_lexer::TokenKind::Unknown => {\n                 let c = self.str_from(start).chars().next().unwrap();\n@@ -516,49 +473,16 @@ impl<'a> StringReader<'a> {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n-    /// Converts CRLF to LF in the given string, raising an error on bare CR.\n-    fn translate_crlf<'b>(&self, start: BytePos, s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n-        let mut chars = s.char_indices().peekable();\n-        while let Some((i, ch)) = chars.next() {\n-            if ch == '\\r' {\n-                if let Some((lf_idx, '\\n')) = chars.peek() {\n-                    return translate_crlf_(self, start, s, *lf_idx, chars, errmsg).into();\n-                }\n-                let pos = start + BytePos(i as u32);\n-                let end_pos = start + BytePos((i + ch.len_utf8()) as u32);\n-                self.err_span_(pos, end_pos, errmsg);\n-            }\n-        }\n-        return s.into();\n-\n-        fn translate_crlf_(rdr: &StringReader<'_>,\n-                           start: BytePos,\n-                           s: &str,\n-                           mut j: usize,\n-                           mut chars: iter::Peekable<impl Iterator<Item = (usize, char)>>,\n-                           errmsg: &str)\n-                           -> String {\n-            let mut buf = String::with_capacity(s.len());\n-            // Skip first CR\n-            buf.push_str(&s[.. j - 1]);\n-            while let Some((i, ch)) = chars.next() {\n-                if ch == '\\r' {\n-                    if j < i {\n-                        buf.push_str(&s[j..i]);\n-                    }\n-                    let next = i + ch.len_utf8();\n-                    j = next;\n-                    if chars.peek().map(|(_, ch)| *ch) != Some('\\n') {\n-                        let pos = start + BytePos(i as u32);\n-                        let end_pos = start + BytePos(next as u32);\n-                        rdr.err_span_(pos, end_pos, errmsg);\n-                    }\n-                }\n-            }\n-            if j < s.len() {\n-                buf.push_str(&s[j..]);\n-            }\n-            buf\n+    fn forbid_bare_cr(&self, start: BytePos, s: &str, errmsg: &str) {\n+        let mut idx = 0;\n+        loop {\n+            idx = match s[idx..].find('\\r') {\n+                None => break,\n+                Some(it) => idx + it + 1\n+            };\n+            self.err_span_(start + BytePos(idx as u32 - 1),\n+                           start + BytePos(idx as u32),\n+                           errmsg);\n         }\n     }\n "}, {"sha": "a915aa42fd15ab2da80ed65d109b697f50c2e204", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -1,41 +1,17 @@\n use super::*;\n \n-use crate::ast::CrateConfig;\n use crate::symbol::Symbol;\n use crate::source_map::{SourceMap, FilePathMapping};\n-use crate::feature_gate::UnstableFeatures;\n use crate::parse::token;\n-use crate::diagnostics::plugin::ErrorMap;\n use crate::with_default_globals;\n use std::io;\n use std::path::PathBuf;\n-use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_data_structures::sync::{Lock, Once};\n+use errors::{Handler, emitter::EmitterWriter};\n+use syntax_pos::{BytePos, Span};\n \n fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n-    let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n-                                                        Some(sm.clone()),\n-                                                        false,\n-                                                        false,\n-                                                        false);\n-    ParseSess {\n-        span_diagnostic: errors::Handler::with_emitter(true, None, Box::new(emitter)),\n-        unstable_features: UnstableFeatures::from_environment(),\n-        config: CrateConfig::default(),\n-        included_mod_stack: Lock::new(Vec::new()),\n-        source_map: sm,\n-        missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n-        raw_identifier_spans: Lock::new(Vec::new()),\n-        registered_diagnostics: Lock::new(ErrorMap::new()),\n-        buffered_lints: Lock::new(vec![]),\n-        edition: Edition::from_session(),\n-        ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-        param_attr_spans: Lock::new(Vec::new()),\n-        let_chains_spans: Lock::new(Vec::new()),\n-        async_closure_spans: Lock::new(Vec::new()),\n-        injected_crate_name: Once::new(),\n-    }\n+    let emitter = EmitterWriter::new(Box::new(io::sink()), Some(sm.clone()), false, false, false);\n+    ParseSess::with_span_handler(Handler::with_emitter(true, None, Box::new(emitter)), sm)\n }\n \n // open a string reader for the given string\n@@ -61,7 +37,7 @@ fn t1() {\n         let tok1 = string_reader.next_token();\n         let tok2 = Token::new(\n             mk_ident(\"fn\"),\n-            Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(21), BytePos(23)),\n         );\n         assert_eq!(tok1.kind, tok2.kind);\n         assert_eq!(tok1.span, tok2.span);\n@@ -71,7 +47,7 @@ fn t1() {\n         assert_eq!(string_reader.pos.clone(), BytePos(28));\n         let tok4 = Token::new(\n             mk_ident(\"main\"),\n-            Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(24), BytePos(28)),\n         );\n         assert_eq!(tok3.kind, tok4.kind);\n         assert_eq!(tok3.span, tok4.span);\n@@ -99,42 +75,50 @@ fn mk_lit(kind: token::LitKind, symbol: &str, suffix: Option<&str>) -> TokenKind\n }\n \n #[test]\n-fn doublecolonparsing() {\n+fn doublecolon_parsing() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")],\n+        );\n     })\n }\n \n #[test]\n-fn dcparsing_2() {\n+fn doublecolon_parsing_2() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a::b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a::b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Colon, token::Colon, mk_ident(\"b\")],\n+        );\n     })\n }\n \n #[test]\n-fn dcparsing_3() {\n+fn doublecolon_parsing_3() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a ::b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a ::b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Whitespace, token::Colon, token::Colon, mk_ident(\"b\")],\n+        );\n     })\n }\n \n #[test]\n-fn dcparsing_4() {\n+fn doublecolon_parsing_4() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a:: b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a:: b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Colon, token::Colon, token::Whitespace, mk_ident(\"b\")],\n+        );\n     })\n }\n "}, {"sha": "e5ba7e45309dda964ca6e42699720070e00a49b6", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -39,29 +39,29 @@ struct TokenTreesReader<'a> {\n impl<'a> TokenTreesReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`.\n     fn parse_all_token_trees(&mut self) -> PResult<'a, TokenStream> {\n-        let mut tts = Vec::new();\n+        let mut buf = TokenStreamBuilder::default();\n \n         self.real_token();\n         while self.token != token::Eof {\n-            tts.push(self.parse_token_tree()?);\n+            buf.push(self.parse_token_tree()?);\n         }\n \n-        Ok(TokenStream::new(tts))\n+        Ok(buf.into_token_stream())\n     }\n \n     // Parse a stream of tokens into a list of `TokenTree`s, up to a `CloseDelim`.\n     fn parse_token_trees_until_close_delim(&mut self) -> TokenStream {\n-        let mut tts = vec![];\n+        let mut buf = TokenStreamBuilder::default();\n         loop {\n             if let token::CloseDelim(..) = self.token.kind {\n-                return TokenStream::new(tts);\n+                return buf.into_token_stream();\n             }\n \n             match self.parse_token_tree() {\n-                Ok(tree) => tts.push(tree),\n+                Ok(tree) => buf.push(tree),\n                 Err(mut e) => {\n                     e.emit();\n-                    return TokenStream::new(tts);\n+                    return buf.into_token_stream();\n                 }\n             }\n         }\n@@ -223,8 +223,32 @@ impl<'a> TokenTreesReader<'a> {\n                 _ => {\n                     self.token = token;\n                     return;\n-                },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct TokenStreamBuilder {\n+    buf: Vec<TreeAndJoint>,\n+}\n+\n+impl TokenStreamBuilder {\n+    fn push(&mut self, (tree, joint): TreeAndJoint) {\n+        if let Some((TokenTree::Token(prev_token), Joint)) = self.buf.last() {\n+            if let TokenTree::Token(token) = &tree {\n+                if let Some(glued) = prev_token.glue(token) {\n+                    self.buf.pop();\n+                    self.buf.push((TokenTree::Token(glued), joint));\n+                    return;\n+                }\n             }\n         }\n+        self.buf.push((tree, joint))\n+    }\n+\n+    fn into_token_stream(self) -> TokenStream {\n+        TokenStream::new(self.buf)\n     }\n }"}, {"sha": "525b4215affb180c710009c4d2c8ac1383628c90", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -3,7 +3,7 @@\n \n use super::StringReader;\n use errors::{Applicability, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION, symbol::kw};\n+use syntax_pos::{BytePos, Pos, Span, symbol::kw};\n use crate::parse::token;\n \n #[rustfmt::skip] // for line breaks\n@@ -343,7 +343,7 @@ crate fn check_for_substitution<'a>(\n         None => return None,\n     };\n \n-    let span = Span::new(pos, pos + Pos::from_usize(ch.len_utf8()), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8()));\n \n     let (ascii_name, token) = match ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) {\n         Some((_ascii_char, ascii_name, token)) => (ascii_name, token),\n@@ -362,10 +362,9 @@ crate fn check_for_substitution<'a>(\n             ascii_char, ascii_name\n         );\n         err.span_suggestion(\n-            Span::new(\n+            Span::with_root_ctxt(\n                 pos,\n                 pos + Pos::from_usize('\u201c'.len_utf8() + s.len() + '\u201d'.len_utf8()),\n-                NO_EXPANSION,\n             ),\n             &msg,\n             format!(\"\\\"{}\\\"\", s),"}, {"sha": "b1f3612a839a2cb41bbe106053a9187257ef7ae6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -16,6 +16,7 @@ use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic,\n use rustc_data_structures::sync::{Lrc, Lock, Once};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use syntax_pos::edition::Edition;\n+use syntax_pos::hygiene::ExpnId;\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use std::borrow::Cow;\n@@ -62,7 +63,11 @@ pub struct ParseSess {\n     pub let_chains_spans: Lock<Vec<Span>>,\n     // Places where `async || ..` exprs were used and should be feature gated.\n     pub async_closure_spans: Lock<Vec<Span>>,\n+    // Places where `yield e?` exprs were used and should be feature gated.\n+    pub yield_spans: Lock<Vec<Span>>,\n     pub injected_crate_name: Once<Symbol>,\n+    // Places where or-patterns e.g. `Some(Foo | Bar)` were used and should be feature gated.\n+    pub or_pattern_spans: Lock<Vec<Span>>,\n }\n \n impl ParseSess {\n@@ -86,12 +91,14 @@ impl ParseSess {\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n-            edition: Edition::from_session(),\n+            edition: ExpnId::root().expn_data().edition,\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),\n             async_closure_spans: Lock::new(Vec::new()),\n+            yield_spans: Lock::new(Vec::new()),\n             injected_crate_name: Once::new(),\n+            or_pattern_spans: Lock::new(Vec::new()),\n         }\n     }\n "}, {"sha": "89725d8b3395c8ab5dde64f80a705a0bac695c6c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043c19c69c0beac3696cb82d44476ba4298a6b07/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=043c19c69c0beac3696cb82d44476ba4298a6b07", "patch": "@@ -13,7 +13,6 @@ mod generics;\n use crate::ast::{self, AttrStyle, Attribute, Arg, BindingMode, StrStyle, SelfKind};\n use crate::ast::{FnDecl, Ident, IsAsync, MacDelimiter, Mutability, TyKind};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n-use crate::ext::hygiene::SyntaxContext;\n use crate::source_map::{self, respan};\n use crate::parse::{SeqSep, literal, token};\n use crate::parse::lexer::UnmatchedBrace;\n@@ -1101,7 +1100,7 @@ impl<'a> Parser<'a> {\n \n     crate fn process_potential_macro_variable(&mut self) {\n         self.token = match self.token.kind {\n-            token::Dollar if self.token.span.ctxt() != SyntaxContext::empty() &&\n+            token::Dollar if self.token.span.from_expansion() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n                 let name = match self.token.kind {\n@@ -1236,7 +1235,7 @@ impl<'a> Parser<'a> {\n \n         let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n-        if c_variadic && args.is_empty() {\n+        if c_variadic && args.len() <= 1 {\n             self.span_err(sp,\n                           \"C-variadic function must be declared with at least one named argument\");\n         }"}]}