{"sha": "332f2894ede0e30149d04030eefd87030569d013", "node_id": "C_kwDOAAsO6NoAKDMzMmYyODk0ZWRlMGUzMDE0OWQwNDAzMGVlZmQ4NzAzMDU2OWQwMTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T06:57:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T06:57:41Z"}, "message": "Auto merge of #2246 - dtolnay-contrib:rustfmt1, r=oli-obk\n\nFormat tests with rustfmt (51-100 of 300)\n\nExtracted from #2097.\n\nLike #2244, this is intended to be \"easy\" cases which don't involve comments in the vicinity.", "tree": {"sha": "d70dad8c59052d4337b931738f770944468ff4c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d70dad8c59052d4337b931738f770944468ff4c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/332f2894ede0e30149d04030eefd87030569d013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/332f2894ede0e30149d04030eefd87030569d013", "html_url": "https://github.com/rust-lang/rust/commit/332f2894ede0e30149d04030eefd87030569d013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/332f2894ede0e30149d04030eefd87030569d013/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "html_url": "https://github.com/rust-lang/rust/commit/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af"}, {"sha": "8efc049a9f0ad4b0bd95fa479ef6ec4b8d440b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8efc049a9f0ad4b0bd95fa479ef6ec4b8d440b4b", "html_url": "https://github.com/rust-lang/rust/commit/8efc049a9f0ad4b0bd95fa479ef6ec4b8d440b4b"}], "stats": {"total": 927, "additions": 547, "deletions": 380}, "files": [{"sha": "5794b7f5427628407ff4822049e9a6b78c6a4f9f", "filename": "tests/pass/align.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Falign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Falign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Falign.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -2,17 +2,19 @@\n fn manual_alignment() {\n     let x = &mut [0u8; 3];\n     let base_addr = x as *mut _ as usize;\n-    let base_addr_aligned = if base_addr % 2 == 0 { base_addr } else { base_addr+1 };\n+    let base_addr_aligned = if base_addr % 2 == 0 { base_addr } else { base_addr + 1 };\n     let u16_ptr = base_addr_aligned as *mut u16;\n-    unsafe { *u16_ptr = 2; }\n+    unsafe {\n+        *u16_ptr = 2;\n+    }\n }\n \n /// Test standard library `align_to`.\n fn align_to() {\n     const LEN: usize = 128;\n     let buf = &[0u8; LEN];\n     let (l, m, r) = unsafe { buf.align_to::<i32>() };\n-    assert!(m.len()*4 >= LEN-4);\n+    assert!(m.len() * 4 >= LEN - 4);\n     assert!(l.len() + r.len() <= 4);\n }\n "}, {"sha": "b57a23ab83682a6f052a624ac0634bdd60756eee", "filename": "tests/pass/align_offset_symbolic.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Falign_offset_symbolic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Falign_offset_symbolic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Falign_offset_symbolic.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -36,31 +36,33 @@ fn test_align_to() {\n     {\n         let (l, m, r) = unsafe { s[1..].align_to::<u32>() };\n         assert_eq!(l.len(), 3);\n-        assert_eq!(m.len(), N-1);\n+        assert_eq!(m.len(), N - 1);\n         assert_eq!(r.len(), 0);\n         assert_eq!(raw.wrapping_offset(4), m.as_ptr() as *const u8);\n     }\n \n     {\n-        let (l, m, r) = unsafe { s[..4*N - 1].align_to::<u32>() };\n+        let (l, m, r) = unsafe { s[..4 * N - 1].align_to::<u32>() };\n         assert_eq!(l.len(), 0);\n-        assert_eq!(m.len(), N-1);\n+        assert_eq!(m.len(), N - 1);\n         assert_eq!(r.len(), 3);\n         assert_eq!(raw, m.as_ptr() as *const u8);\n     }\n \n     {\n-        let (l, m, r) = unsafe { s[1..4*N - 1].align_to::<u32>() };\n+        let (l, m, r) = unsafe { s[1..4 * N - 1].align_to::<u32>() };\n         assert_eq!(l.len(), 3);\n-        assert_eq!(m.len(), N-2);\n+        assert_eq!(m.len(), N - 2);\n         assert_eq!(r.len(), 3);\n         assert_eq!(raw.wrapping_offset(4), m.as_ptr() as *const u8);\n     }\n \n     {\n-        #[repr(align(8))] struct Align8(u64);\n+        #[repr(align(8))]\n+        struct Align8(u64);\n+\n         let (l, m, r) = unsafe { s.align_to::<Align8>() }; // requested alignment higher than allocation alignment\n-        assert_eq!(l.len(), 4*N);\n+        assert_eq!(l.len(), 4 * N);\n         assert_eq!(r.len(), 0);\n         assert_eq!(m.len(), 0);\n     }"}, {"sha": "32fd47d8c5813061d9e509bb751ad744ab499ddd", "filename": "tests/pass/backtrace/backtrace-api-v0.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v0.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,14 +1,28 @@\n // normalize-stderr-test: \"::<.*>\" -> \"\"\n \n-#[inline(never)] fn func_a() -> Box<[*mut ()]> { func_b::<u8>() }\n-#[inline(never)] fn func_b<T>() -> Box<[*mut ()]> { func_c() }\n+#[inline(never)]\n+fn func_a() -> Box<[*mut ()]> {\n+    func_b::<u8>()\n+}\n+#[inline(never)]\n+fn func_b<T>() -> Box<[*mut ()]> {\n+    func_c()\n+}\n \n macro_rules! invoke_func_d {\n-    () => { func_d() }\n+    () => {\n+        func_d()\n+    };\n }\n \n-#[inline(never)] fn func_c() -> Box<[*mut ()]> { invoke_func_d!() }\n-#[inline(never)] fn func_d() -> Box<[*mut ()]> { unsafe { miri_get_backtrace(0) } }\n+#[inline(never)]\n+fn func_c() -> Box<[*mut ()]> {\n+    invoke_func_d!()\n+}\n+#[inline(never)]\n+fn func_d() -> Box<[*mut ()]> {\n+    unsafe { miri_get_backtrace(0) }\n+}\n \n fn main() {\n     let mut seen_main = false;\n@@ -51,4 +65,3 @@ struct MiriFrame {\n     colno: u32,\n     fn_ptr: *mut (),\n }\n-"}, {"sha": "2fe31dd0e6bae68833da5d9b03785ab92953c171", "filename": "tests/pass/backtrace/backtrace-api-v0.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v0.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v0.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v0.stdout?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,5 +1,5 @@\n-$DIR/backtrace-api-v0.rs:11:59 (func_d)\n-$DIR/backtrace-api-v0.rs:10:50 (func_c)\n-$DIR/backtrace-api-v0.rs:4:53 (func_b)\n-$DIR/backtrace-api-v0.rs:3:50 (func_a)\n-$DIR/backtrace-api-v0.rs:15:18 (main)\n+$DIR/backtrace-api-v0.rs:24:14 (func_d)\n+$DIR/backtrace-api-v0.rs:20:5 (func_c)\n+$DIR/backtrace-api-v0.rs:9:5 (func_b)\n+$DIR/backtrace-api-v0.rs:5:5 (func_a)\n+$DIR/backtrace-api-v0.rs:29:18 (main)"}, {"sha": "c24a5f3e81250a3d7dd8da7c3a4965f368d7067b", "filename": "tests/pass/backtrace/backtrace-api-v1.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v1.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,14 +1,33 @@\n // normalize-stderr-test: \"::<.*>\" -> \"\"\n \n-#[inline(never)] fn func_a() -> Box<[*mut ()]> { func_b::<u8>() }\n-#[inline(never)] fn func_b<T>() -> Box<[*mut ()]> { func_c() }\n+#[inline(never)]\n+fn func_a() -> Box<[*mut ()]> {\n+    func_b::<u8>()\n+}\n+#[inline(never)]\n+fn func_b<T>() -> Box<[*mut ()]> {\n+    func_c()\n+}\n \n macro_rules! invoke_func_d {\n-    () => { func_d() }\n+    () => {\n+        func_d()\n+    };\n }\n \n-#[inline(never)] fn func_c() -> Box<[*mut ()]> { invoke_func_d!() }\n-#[inline(never)] fn func_d() -> Box<[*mut ()]> { unsafe { let count = miri_backtrace_size(0); let mut buf = vec![std::ptr::null_mut(); count]; miri_get_backtrace(1, buf.as_mut_ptr()); buf.into() } }\n+#[inline(never)]\n+fn func_c() -> Box<[*mut ()]> {\n+    invoke_func_d!()\n+}\n+#[inline(never)]\n+fn func_d() -> Box<[*mut ()]> {\n+    unsafe {\n+        let count = miri_backtrace_size(0);\n+        let mut buf = vec![std::ptr::null_mut(); count];\n+        miri_get_backtrace(1, buf.as_mut_ptr());\n+        buf.into()\n+    }\n+}\n \n fn main() {\n     let mut seen_main = false;"}, {"sha": "0d2ae3b516a8733b6767cd3c1b0649c4d2702297", "filename": "tests/pass/backtrace/backtrace-api-v1.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v1.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v1.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbacktrace%2Fbacktrace-api-v1.stdout?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,5 +1,5 @@\n-$DIR/backtrace-api-v1.rs:11:144 (func_d)\n-$DIR/backtrace-api-v1.rs:10:50 (func_c)\n-$DIR/backtrace-api-v1.rs:4:53 (func_b)\n-$DIR/backtrace-api-v1.rs:3:50 (func_a)\n-$DIR/backtrace-api-v1.rs:15:18 (main)\n+$DIR/backtrace-api-v1.rs:27:9 (func_d)\n+$DIR/backtrace-api-v1.rs:20:5 (func_c)\n+$DIR/backtrace-api-v1.rs:9:5 (func_b)\n+$DIR/backtrace-api-v1.rs:5:5 (func_a)\n+$DIR/backtrace-api-v1.rs:34:18 (main)"}, {"sha": "5de7cdd6a54d00f59037796a7230a47a0a0bdd5e", "filename": "tests/pass/backtrace/backtrace-std.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbacktrace%2Fbacktrace-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbacktrace%2Fbacktrace-std.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -4,15 +4,29 @@\n \n use std::backtrace::Backtrace;\n \n-#[inline(never)] fn func_a() -> Backtrace { func_b::<u8>() }\n-#[inline(never)] fn func_b<T>() -> Backtrace { func_c() }\n+#[inline(never)]\n+fn func_a() -> Backtrace {\n+    func_b::<u8>()\n+}\n+#[inline(never)]\n+fn func_b<T>() -> Backtrace {\n+    func_c()\n+}\n \n macro_rules! invoke_func_d {\n-    () => { func_d() }\n+    () => {\n+        func_d()\n+    };\n }\n \n-#[inline(never)] fn func_c() -> Backtrace { invoke_func_d!() }\n-#[inline(never)] fn func_d() -> Backtrace { Backtrace::capture() }\n+#[inline(never)]\n+fn func_c() -> Backtrace {\n+    invoke_func_d!()\n+}\n+#[inline(never)]\n+fn func_d() -> Backtrace {\n+    Backtrace::capture()\n+}\n \n fn main() {\n     eprint!(\"{}\", func_a());"}, {"sha": "278038d8ad321839fdaf46cbe9875bd06560d499", "filename": "tests/pass/binary-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbinary-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbinary-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbinary-heap.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -26,7 +26,7 @@ fn drain() {\n     for x in heap.drain() {\n         sum += x;\n     }\n-    assert_eq!(sum, 127*128/2);\n+    assert_eq!(sum, 127 * 128 / 2);\n \n     assert!(heap.is_empty());\n }"}, {"sha": "0988d7ccc4c6e2b5bed6af91db673dc6d1077252", "filename": "tests/pass/binops.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbinops.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -56,21 +56,18 @@ struct P {\n }\n \n fn p(x: isize, y: isize) -> P {\n-    P {\n-        x: x,\n-        y: y\n-    }\n+    P { x: x, y: y }\n }\n \n fn test_class() {\n-  let q = p(1, 2);\n-  let mut r = p(1, 2);\n+    let q = p(1, 2);\n+    let mut r = p(1, 2);\n \n-  assert_eq!(q, r);\n-  r.y = 17;\n-  assert!((r.y != q.y));\n-  assert_eq!(r.y, 17);\n-  assert!((q != r));\n+    assert_eq!(q, r);\n+    r.y = 17;\n+    assert!((r.y != q.y));\n+    assert_eq!(r.y, 17);\n+    assert!((q != r));\n }\n \n pub fn main() {"}, {"sha": "c2ecc3707179f36c7b6755783d61b9117c4f6fb9", "filename": "tests/pass/box.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbox.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -6,30 +6,34 @@ fn main() {\n     boxed_pair_to_vec();\n }\n \n-fn into_raw() { unsafe {\n-    let b = Box::new(4i32);\n-    let r = Box::into_raw(b);\n-\n-    // \"lose the tag\"\n-    let r2 = ((r as usize)+0) as *mut i32;\n-    *(&mut *r2) = 7;\n-\n-    // Use original ptr again\n-    *(&mut *r) = 17;\n-    drop(Box::from_raw(r));\n-}}\n+fn into_raw() {\n+    unsafe {\n+        let b = Box::new(4i32);\n+        let r = Box::into_raw(b);\n+\n+        // \"lose the tag\"\n+        let r2 = ((r as usize) + 0) as *mut i32;\n+        *(&mut *r2) = 7;\n+\n+        // Use original ptr again\n+        *(&mut *r) = 17;\n+        drop(Box::from_raw(r));\n+    }\n+}\n \n-fn into_unique() { unsafe {\n-    let b = Box::new(4i32);\n-    let u = Box::into_unique(b).0;\n+fn into_unique() {\n+    unsafe {\n+        let b = Box::new(4i32);\n+        let u = Box::into_unique(b).0;\n \n-    // \"lose the tag\"\n-    let r = ((u.as_ptr() as usize)+0) as *mut i32;\n-    *(&mut *r) = 7;\n+        // \"lose the tag\"\n+        let r = ((u.as_ptr() as usize) + 0) as *mut i32;\n+        *(&mut *r) = 7;\n \n-    // Use original ptr again.\n-    drop(Box::from_raw(u.as_ptr()));\n-}}\n+        // Use original ptr again.\n+        drop(Box::from_raw(u.as_ptr()));\n+    }\n+}\n \n fn boxed_pair_to_vec() {\n     #[repr(C)]\n@@ -44,15 +48,10 @@ fn boxed_pair_to_vec() {\n     fn reinterstruct(box_pair: Box<PairFoo>) -> Vec<Foo> {\n         let ref_pair = Box::leak(box_pair) as *mut PairFoo;\n         let ptr_foo = unsafe { &mut (*ref_pair).fst as *mut Foo };\n-        unsafe {\n-            Vec::from_raw_parts(ptr_foo, 2, 2)\n-        }\n+        unsafe { Vec::from_raw_parts(ptr_foo, 2, 2) }\n     }\n \n-    let pair_foo = Box::new(PairFoo {\n-        fst: Foo(42),\n-        snd: Foo(1337),\n-    });\n+    let pair_foo = Box::new(PairFoo { fst: Foo(42), snd: Foo(1337) });\n     println!(\"pair_foo = {:?}\", pair_foo);\n     for (n, foo) in reinterstruct(pair_foo).into_iter().enumerate() {\n         println!(\"foo #{} = {:?}\", n, foo);"}, {"sha": "014d1d3acab7fb4fc2a218ef84b08ca49bde4948", "filename": "tests/pass/calls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcalls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcalls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fcalls.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -7,17 +7,15 @@ fn call() -> i32 {\n \n fn factorial_recursive() -> i64 {\n     fn fact(n: i64) -> i64 {\n-        if n == 0 {\n-            1\n-        } else {\n-            n * fact(n - 1)\n-        }\n+        if n == 0 { 1 } else { n * fact(n - 1) }\n     }\n     fact(10)\n }\n \n fn call_generic() -> (i16, bool) {\n-    fn id<T>(t: T) -> T { t }\n+    fn id<T>(t: T) -> T {\n+        t\n+    }\n     (id(42), id(true))\n }\n \n@@ -26,7 +24,9 @@ fn cross_crate_fn_call() -> i64 {\n     if 1i32.is_positive() { 1 } else { 0 }\n }\n \n-const fn foo(i: i64) -> i64 { *&i + 1 }\n+const fn foo(i: i64) -> i64 {\n+    *&i + 1\n+}\n \n fn const_fn_call() -> i64 {\n     let x = 5 + foo(5);"}, {"sha": "d76c23633da1bc200159cd6b31cd63a0c34869df", "filename": "tests/pass/cast-rfc0401-vtable-kinds.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fcast-rfc0401-vtable-kinds.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -2,44 +2,52 @@\n // whose vtable have the same kind (both lengths, or both trait pointers).\n \n trait Foo<T> {\n-    fn foo(&self, _: T) -> u32 { 42 }\n+    fn foo(&self, _: T) -> u32 {\n+        42\n+    }\n }\n \n trait Bar {\n-    fn bar(&self) { println!(\"Bar!\"); }\n+    fn bar(&self) {\n+        println!(\"Bar!\");\n+    }\n }\n \n impl<T> Foo<T> for () {}\n-impl Foo<u32> for u32 { fn foo(&self, _: u32) -> u32 { self+43 } }\n+impl Foo<u32> for u32 {\n+    fn foo(&self, _: u32) -> u32 {\n+        self + 43\n+    }\n+}\n impl Bar for () {}\n \n-unsafe fn round_trip_and_call<'a>(t: *const (dyn Foo<u32>+'a)) -> u32 {\n-    let foo_e : *const dyn Foo<u16> = t as *const _;\n+unsafe fn round_trip_and_call<'a>(t: *const (dyn Foo<u32> + 'a)) -> u32 {\n+    let foo_e: *const dyn Foo<u16> = t as *const _;\n     let r_1 = foo_e as *mut dyn Foo<u32>;\n \n     (&*r_1).foo(0)\n }\n \n #[repr(C)]\n-struct FooS<T:?Sized>(T);\n+struct FooS<T: ?Sized>(T);\n #[repr(C)]\n-struct BarS<T:?Sized>(T);\n+struct BarS<T: ?Sized>(T);\n \n-fn foo_to_bar<T:?Sized>(u: *const FooS<T>) -> *const BarS<T> {\n+fn foo_to_bar<T: ?Sized>(u: *const FooS<T>) -> *const BarS<T> {\n     u as *const BarS<T>\n }\n \n fn main() {\n     let x = 4u32;\n-    let y : &dyn Foo<u32> = &x;\n+    let y: &dyn Foo<u32> = &x;\n     let fl = unsafe { round_trip_and_call(y as *const dyn Foo<u32>) };\n-    assert_eq!(fl, (43+4));\n+    assert_eq!(fl, (43 + 4));\n \n-    let s = FooS([0,1,2]);\n+    let s = FooS([0, 1, 2]);\n     let u: &FooS<[u32]> = &s;\n     let u: *const FooS<[u32]> = u;\n-    let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n-    let z : &BarS<[u32]> = unsafe{&*bar_ref};\n-    assert_eq!(&z.0, &[0,1,2]);\n+    let bar_ref: *const BarS<[u32]> = foo_to_bar(u);\n+    let z: &BarS<[u32]> = unsafe { &*bar_ref };\n+    assert_eq!(&z.0, &[0, 1, 2]);\n     // If validation fails here, that's likely because an immutable suspension is recovered mutably.\n }"}, {"sha": "8954048f4262c61692514792200345bd87ca09e8", "filename": "tests/pass/cast_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fcast_fn_ptr.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,9 +1,7 @@\n fn main() {\n     fn f(_: *const u8) {}\n \n-    let g = unsafe {\n-        std::mem::transmute::<fn(*const u8), fn(*const i32)>(f)\n-    };\n+    let g = unsafe { std::mem::transmute::<fn(*const u8), fn(*const i32)>(f) };\n \n     g(&42 as *const _);\n }"}, {"sha": "4ede23e68ce253eeab844e4397a10e0f51662760", "filename": "tests/pass/catch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fcatch.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -2,6 +2,6 @@ use std::panic::{catch_unwind, AssertUnwindSafe};\n \n fn main() {\n     let mut i = 3;\n-    let _val = catch_unwind(AssertUnwindSafe(|| {i -= 2;} ));\n+    let _val = catch_unwind(AssertUnwindSafe(|| i -= 2));\n     println!(\"{}\", i);\n }"}, {"sha": "9f9454b4c71c564469fe78d1e2bfd9d957ea0a23", "filename": "tests/pass/closure-drop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fclosure-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fclosure-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fclosure-drop.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -17,9 +17,10 @@ fn main() {\n         // this closure never by val uses its captures\n         // so it's basically a fn(&self)\n         // the shim used to not drop the `x`\n-        let x = move || { let _val = x; };\n+        let x = move || {\n+            let _val = x;\n+        };\n         f(x);\n     }\n     assert!(ran_drop);\n }\n-"}, {"sha": "1c90a15f8c5ca278ac0f13b7db0c4fe435a96609", "filename": "tests/pass/closure-field-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fclosure-field-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fclosure-field-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fclosure-field-ty.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -3,7 +3,7 @@ fn main() {\n     let mut y = 0;\n     {\n         let mut box_maybe_closure = Box::new(None);\n-        *box_maybe_closure = Some(|| { y += 1; });\n+        *box_maybe_closure = Some(|| y += 1);\n         (box_maybe_closure.unwrap())();\n     }\n     assert_eq!(y, 1);"}, {"sha": "40aedbcaf4545366d76b42edf579baeaa4d29a96", "filename": "tests/pass/closures.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fclosures.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -22,7 +22,9 @@ fn crazy_closure() -> (i32, i32, i32) {\n }\n \n fn closure_arg_adjustment_problem() -> i64 {\n-    fn once<F: FnOnce(i64)>(f: F) { f(2); }\n+    fn once<F: FnOnce(i64)>(f: F) {\n+        f(2);\n+    }\n     let mut y = 1;\n     {\n         let f = |x| y += x;\n@@ -32,7 +34,9 @@ fn closure_arg_adjustment_problem() -> i64 {\n }\n \n fn fn_once_closure_with_multiple_args() -> i64 {\n-    fn once<F: FnOnce(i64, i64) -> i64>(f: F) -> i64 { f(2, 3) }\n+    fn once<F: FnOnce(i64, i64) -> i64>(f: F) -> i64 {\n+        f(2, 3)\n+    }\n     let y = 1;\n     {\n         let f = |x, z| x + y + z;\n@@ -50,7 +54,8 @@ fn box_dyn() {\n     let mut i = 5;\n     {\n         let mut x: Box<dyn FnMut()> = Box::new(|| i *= 2);\n-        x(); x();\n+        x();\n+        x();\n     }\n     assert_eq!(i, 20);\n }\n@@ -88,7 +93,9 @@ fn fn_item_with_multiple_args_as_closure_trait_object() {\n \n fn fn_ptr_as_closure_trait_object() {\n     fn foo() {}\n-    fn bar(u: u32) { assert_eq!(u, 42); }\n+    fn bar(u: u32) {\n+        assert_eq!(u, 42);\n+    }\n     fn baa(u: u32, f: f32) {\n         assert_eq!(u, 42);\n         assert_eq!(f, 3.141);\n@@ -101,13 +108,18 @@ fn fn_ptr_as_closure_trait_object() {\n     f(42, 3.141);\n }\n \n-\n fn main() {\n     assert_eq!(simple(), 12);\n     assert_eq!(crazy_closure(), (84, 10, 10));\n     assert_eq!(closure_arg_adjustment_problem(), 3);\n     assert_eq!(fn_once_closure_with_multiple_args(), 6);\n-    assert_eq!(boxed_fn_once(Box::new({let x = 13; move || x})), 13);\n+    assert_eq!(\n+        boxed_fn_once(Box::new({\n+            let x = 13;\n+            move || x\n+        })),\n+        13,\n+    );\n \n     box_dyn();\n     fn_item_as_closure_trait_object();"}, {"sha": "fde120db027b16a68d2f1c65365f293f128c9f09", "filename": "tests/pass/coerce_non_capture_closure_to_fn_ptr.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcoerce_non_capture_closure_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcoerce_non_capture_closure_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fcoerce_non_capture_closure_to_fn_ptr.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,11 +1,19 @@\n-static FOO: fn() = || { assert_ne!(42, 43) };\n-static BAR: fn(i32, i32) = |a, b| { assert_ne!(a, b) };\n+static FOO: fn() = || assert_ne!(42, 43);\n+static BAR: fn(i32, i32) = |a, b| assert_ne!(a, b);\n \n // use to first make the closure FnOnce() before making it fn()\n-fn force_once0<R, F: FnOnce() -> R>(f: F) -> F { f }\n-fn force_once1<T, R, F: FnOnce(T) -> R>(f: F) -> F { f }\n-fn force_mut0<R, F: FnMut() -> R>(f: F) -> F { f }\n-fn force_mut1<T, R, F: FnMut(T) -> R>(f: F) -> F { f }\n+fn force_once0<R, F: FnOnce() -> R>(f: F) -> F {\n+    f\n+}\n+fn force_once1<T, R, F: FnOnce(T) -> R>(f: F) -> F {\n+    f\n+}\n+fn force_mut0<R, F: FnMut() -> R>(f: F) -> F {\n+    f\n+}\n+fn force_mut1<T, R, F: FnMut(T) -> R>(f: F) -> F {\n+    f\n+}\n \n fn main() {\n     FOO();\n@@ -15,11 +23,11 @@ fn main() {\n     let boo: &dyn Fn(i32, i32) = &BAR;\n     boo(48, 49);\n \n-    let f: fn() = ||{};\n+    let f: fn() = || {};\n     f();\n-    let f = force_once0(||{}) as fn();\n+    let f = force_once0(|| {}) as fn();\n     f();\n-    let f = force_mut0(||{}) as fn();\n+    let f = force_mut0(|| {}) as fn();\n     f();\n \n     let g: fn(i32) = |i| assert_eq!(i, 2);"}, {"sha": "db0d2ffd44bcf845f85348cbfd1f02902a8906bc", "filename": "tests/pass/coercions.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcoercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fcoercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fcoercions.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,30 +1,32 @@\n #![feature(coerce_unsized, unsize)]\n \n-use std::ops::CoerceUnsized;\n use std::marker::Unsize;\n+use std::ops::CoerceUnsized;\n \n-fn identity_coercion(x: &(dyn Fn(u32)->u32 + Send)) -> &dyn Fn(u32)->u32 {\n+fn identity_coercion(x: &(dyn Fn(u32) -> u32 + Send)) -> &dyn Fn(u32) -> u32 {\n     x\n }\n-fn fn_coercions(f: &fn(u32) -> u32) ->\n-    (unsafe fn(u32) -> u32,\n-     &(dyn Fn(u32) -> u32 + Send))\n-{\n+fn fn_coercions(f: &fn(u32) -> u32) -> (unsafe fn(u32) -> u32, &(dyn Fn(u32) -> u32 + Send)) {\n     (*f, f)\n }\n \n-fn simple_array_coercion(x: &[u8; 3]) -> &[u8] { x }\n+fn simple_array_coercion(x: &[u8; 3]) -> &[u8] {\n+    x\n+}\n \n-fn square(a: u32) -> u32 { a * a }\n+fn square(a: u32) -> u32 {\n+    a * a\n+}\n \n-#[derive(PartialEq,Eq)]\n-struct PtrWrapper<'a, T: 'a+?Sized>(u32, u32, (), &'a T);\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n-    CoerceUnsized<PtrWrapper<'a, U>> for PtrWrapper<'a, T> {}\n+#[derive(PartialEq, Eq)]\n+struct PtrWrapper<'a, T: 'a + ?Sized>(u32, u32, (), &'a T);\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PtrWrapper<'a, U>> for PtrWrapper<'a, T> {}\n \n-struct TrivPtrWrapper<'a, T: 'a+?Sized>(&'a T);\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n-    CoerceUnsized<TrivPtrWrapper<'a, U>> for TrivPtrWrapper<'a, T> {}\n+struct TrivPtrWrapper<'a, T: 'a + ?Sized>(&'a T);\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<TrivPtrWrapper<'a, U>>\n+    for TrivPtrWrapper<'a, T>\n+{\n+}\n \n fn coerce_ptr_wrapper(p: PtrWrapper<[u8; 3]>) -> PtrWrapper<[u8]> {\n     p\n@@ -34,40 +36,41 @@ fn coerce_triv_ptr_wrapper(p: TrivPtrWrapper<[u8; 3]>) -> TrivPtrWrapper<[u8]> {\n     p\n }\n \n-fn coerce_fat_ptr_wrapper(p: PtrWrapper<dyn Fn(u32) -> u32 + Send>)\n-                          -> PtrWrapper<dyn Fn(u32) -> u32> {\n+fn coerce_fat_ptr_wrapper(\n+    p: PtrWrapper<dyn Fn(u32) -> u32 + Send>,\n+) -> PtrWrapper<dyn Fn(u32) -> u32> {\n     p\n }\n \n-fn coerce_ptr_wrapper_poly<'a, T, Trait: ?Sized>(p: PtrWrapper<'a, T>)\n-                                                 -> PtrWrapper<'a, Trait>\n-    where PtrWrapper<'a, T>: CoerceUnsized<PtrWrapper<'a, Trait>>\n+fn coerce_ptr_wrapper_poly<'a, T, Trait: ?Sized>(p: PtrWrapper<'a, T>) -> PtrWrapper<'a, Trait>\n+where\n+    PtrWrapper<'a, T>: CoerceUnsized<PtrWrapper<'a, Trait>>,\n {\n     p\n }\n \n fn main() {\n-    let a = [0,1,2];\n-    let square_local : fn(u32) -> u32 = square;\n-    let (f,g) = fn_coercions(&square_local);\n+    let a = [0, 1, 2];\n+    let square_local: fn(u32) -> u32 = square;\n+    let (f, g) = fn_coercions(&square_local);\n     // cannot use `square as *const ()` because we can't know whether the compiler duplicates\n     // functions, so two function pointers are only equal if they result from the same function\n     // to function pointer cast\n-    assert_eq!(f as *const (), square_local as *const());\n+    assert_eq!(f as *const (), square_local as *const ());\n     assert_eq!(g(4), 16);\n     assert_eq!(identity_coercion(g)(5), 25);\n \n     assert_eq!(simple_array_coercion(&a), &a);\n-    let w = coerce_ptr_wrapper(PtrWrapper(2,3,(),&a));\n-    assert!(w == PtrWrapper(2,3,(),&a) as PtrWrapper<[u8]>);\n+    let w = coerce_ptr_wrapper(PtrWrapper(2, 3, (), &a));\n+    assert!(w == PtrWrapper(2, 3, (), &a) as PtrWrapper<[u8]>);\n \n     let w = coerce_triv_ptr_wrapper(TrivPtrWrapper(&a));\n     assert_eq!(&w.0, &a);\n \n-    let z = coerce_fat_ptr_wrapper(PtrWrapper(2,3,(),&square_local));\n+    let z = coerce_fat_ptr_wrapper(PtrWrapper(2, 3, (), &square_local));\n     assert_eq!((z.3)(6), 36);\n \n     let z: PtrWrapper<dyn Fn(u32) -> u32> =\n-        coerce_ptr_wrapper_poly(PtrWrapper(2,3,(),&square_local));\n+        coerce_ptr_wrapper_poly(PtrWrapper(2, 3, (), &square_local));\n     assert_eq!((z.3)(6), 36);\n }"}, {"sha": "003b9e9ca9f4645e02675d5fa2592494e47e8ba6", "filename": "tests/pass/concurrency/concurrent_caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,7 +1,7 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n \n-use std::thread::spawn;\n use std::panic::Location;\n+use std::thread::spawn;\n \n fn initialize() {\n     let _ignore = initialize_inner();"}, {"sha": "071f5bbcdf394b10e0f6042cf652f6a914dd1f59", "filename": "tests/pass/concurrency/data_race.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdata_race.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,8 +1,7 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n // compile-flags: -Zmiri-disable-weak-memory-emulation\n \n-\n-use std::sync::atomic::{AtomicUsize, fence, Ordering};\n+use std::sync::atomic::{fence, AtomicUsize, Ordering};\n use std::thread::spawn;\n \n #[derive(Copy, Clone)]\n@@ -18,9 +17,10 @@ fn test_fence_sync() {\n     let ptr = &mut var as *mut u32;\n     let evil_ptr = EvilSend(ptr);\n \n-\n     let j1 = spawn(move || {\n-        unsafe { *evil_ptr.0 = 1; }\n+        unsafe {\n+            *evil_ptr.0 = 1;\n+        }\n         fence(Ordering::Release);\n         SYNC.store(1, Ordering::Relaxed)\n     });\n@@ -38,16 +38,15 @@ fn test_fence_sync() {\n     j2.join().unwrap();\n }\n \n-\n fn test_multiple_reads() {\n     let mut var = 42u32;\n     let ptr = &mut var as *mut u32;\n     let evil_ptr = EvilSend(ptr);\n \n-    let j1 = spawn(move || unsafe {*evil_ptr.0});\n-    let j2 = spawn(move || unsafe {*evil_ptr.0});\n-    let j3 = spawn(move || unsafe {*evil_ptr.0});\n-    let j4 = spawn(move || unsafe {*evil_ptr.0});\n+    let j1 = spawn(move || unsafe { *evil_ptr.0 });\n+    let j2 = spawn(move || unsafe { *evil_ptr.0 });\n+    let j3 = spawn(move || unsafe { *evil_ptr.0 });\n+    let j4 = spawn(move || unsafe { *evil_ptr.0 });\n \n     assert_eq!(j1.join().unwrap(), 42);\n     assert_eq!(j2.join().unwrap(), 42);\n@@ -75,13 +74,7 @@ pub fn test_rmw_no_block() {\n             }\n         });\n \n-        let j3 = spawn(move || {\n-            if SYNC.load(Ordering::Acquire) == 2 {\n-                *c.0\n-            } else {\n-                0\n-            }\n-        });\n+        let j3 = spawn(move || if SYNC.load(Ordering::Acquire) == 2 { *c.0 } else { 0 });\n \n         j1.join().unwrap();\n         j2.join().unwrap();\n@@ -101,16 +94,10 @@ pub fn test_simple_release() {\n             SYNC.store(1, Ordering::Release);\n         });\n \n-        let j2 = spawn(move || {\n-            if SYNC.load(Ordering::Acquire) == 1 {\n-                *c.0\n-            } else {\n-                0\n-            }\n-        });\n+        let j2 = spawn(move || if SYNC.load(Ordering::Acquire) == 1 { *c.0 } else { 0 });\n \n         j1.join().unwrap();\n-        assert_eq!(j2.join().unwrap(),1);\n+        assert_eq!(j2.join().unwrap(), 1);\n     }\n }\n "}, {"sha": "48c1f3d9fb52c66839c11f948d5b2b52831df080", "filename": "tests/pass/concurrency/simple.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsimple.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -42,31 +42,25 @@ fn create_move_in() {\n }\n \n fn create_move_out() {\n-    let result = thread::spawn(|| {\n-        String::from(\"Hello!\")\n-    })\n-    .join()\n-    .unwrap();\n+    let result = thread::spawn(|| String::from(\"Hello!\")).join().unwrap();\n     assert_eq!(result.len(), 6);\n }\n \n fn panic() {\n-    let result = thread::spawn(|| {\n-        panic!(\"Hello!\")\n-    })\n-    .join()\n-    .unwrap_err();\n+    let result = thread::spawn(|| panic!(\"Hello!\")).join().unwrap_err();\n     let msg = result.downcast_ref::<&'static str>().unwrap();\n     assert_eq!(*msg, \"Hello!\");\n }\n \n fn panic_named() {\n-    thread::Builder::new().name(\"childthread\".to_string()).spawn(move || {\n-        panic!(\"Hello, world!\");\n-    })\n-    .unwrap()\n-    .join()\n-    .unwrap_err();\n+    thread::Builder::new()\n+        .name(\"childthread\".to_string())\n+        .spawn(move || {\n+            panic!(\"Hello, world!\");\n+        })\n+        .unwrap()\n+        .join()\n+        .unwrap_err();\n }\n \n fn main() {"}, {"sha": "e11f0789bb5db37e3a8f9bf4040b34254421e2c6", "filename": "tests/pass/concurrency/spin_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,6 +1,6 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-use std::thread;\n use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::thread;\n \n static FLAG: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "99a5410c95dfd0acaddccc8ea676678403d9d1cc", "filename": "tests/pass/concurrency/spin_loops_nopreempt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -2,10 +2,10 @@\n // This specifically tests behavior *without* preemption.\n // compile-flags: -Zmiri-preemption-rate=0\n \n-use std::thread;\n+use std::cell::Cell;\n use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n use std::sync::mpsc;\n-use std::cell::Cell;\n+use std::thread;\n \n /// When a thread yields, Miri's scheduler used to pick the thread with the lowest ID\n /// that can run. IDs are assigned in thread creation order."}, {"sha": "5663e1c1426c9053be79853448c77a2e686b9ef0", "filename": "tests/pass/concurrency/sync_singlethread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fsync_singlethread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Fsync_singlethread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync_singlethread.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,6 +1,6 @@\n-use std::sync::{Mutex, TryLockError};\n-use std::sync::atomic;\n use std::hint;\n+use std::sync::atomic;\n+use std::sync::{Mutex, TryLockError};\n \n fn main() {\n     test_mutex_stdlib();"}, {"sha": "fe46406c283c3db9afe793ae50be661e67107e6d", "filename": "tests/pass/concurrency/tls_lib_drop.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -9,7 +9,9 @@ struct TestCell {\n \n impl Drop for TestCell {\n     fn drop(&mut self) {\n-        for _ in 0..10 { thread::yield_now(); }\n+        for _ in 0..10 {\n+            thread::yield_now();\n+        }\n         println!(\"Dropping: {} (should be before 'Continue main 1').\", *self.value.borrow())\n     }\n }\n@@ -43,7 +45,9 @@ struct JoinCell {\n \n impl Drop for JoinCell {\n     fn drop(&mut self) {\n-        for _ in 0..10 { thread::yield_now(); }\n+        for _ in 0..10 {\n+            thread::yield_now();\n+        }\n         let join_handle = self.value.borrow_mut().take().unwrap();\n         println!(\"Joining: {} (should be before 'Continue main 2').\", join_handle.join().unwrap());\n     }\n@@ -118,9 +122,10 @@ fn join_orders_after_tls_destructors() {\n                             match sync_state {\n                                 THREAD2_LAUNCHED | THREAD1_WAITING => thread::yield_now(),\n                                 MAIN_THREAD_RENDEZVOUS => break,\n-                                THREAD2_JOINED => panic!(\n-                                    \"Thread 1 still running after thread 2 joined on thread 1\"\n-                                ),\n+                                THREAD2_JOINED =>\n+                                    panic!(\n+                                        \"Thread 1 still running after thread 2 joined on thread 1\"\n+                                    ),\n                                 v => unreachable!(\"sync state: {}\", v),\n                             }\n                             sync_state = SYNC_STATE.load(Ordering::SeqCst);"}, {"sha": "4d69449821cd28bfb490e76a8197ee28f937684f", "filename": "tests/pass/concurrency/tls_pthread_drop_order.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -7,13 +7,13 @@ use std::mem;\n \n pub type Key = libc::pthread_key_t;\n \n-static mut RECORD : usize = 0;\n-static mut KEYS : [Key; 2] = [0; 2];\n-static mut GLOBALS : [u64; 2] = [1, 0];\n+static mut RECORD: usize = 0;\n+static mut KEYS: [Key; 2] = [0; 2];\n+static mut GLOBALS: [u64; 2] = [1, 0];\n \n-static mut CANNARY : *mut u64 = 0 as *mut _; // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n+static mut CANNARY: *mut u64 = 0 as *mut _; // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n \n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n     assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n     key\n@@ -26,18 +26,19 @@ pub unsafe fn set(key: Key, value: *mut u8) {\n \n pub fn record(r: usize) {\n     assert!(r < 10);\n-    unsafe { RECORD = RECORD*10 + r };\n+    unsafe { RECORD = RECORD * 10 + r };\n }\n \n-unsafe extern fn dtor(ptr: *mut u64) {\n+unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n     assert!(CANNARY != 0 as *mut _); // make sure we do not get run too often\n     let val = *ptr;\n \n-    let which_key = GLOBALS.iter().position(|global| global as *const _ == ptr).expect(\"Should find my global\");\n+    let which_key =\n+        GLOBALS.iter().position(|global| global as *const _ == ptr).expect(\"Should find my global\");\n     record(which_key);\n \n     if val > 0 {\n-        *ptr = val-1;\n+        *ptr = val - 1;\n         set(KEYS[which_key], ptr as *mut _);\n     }\n \n@@ -57,7 +58,7 @@ fn main() {\n \n         // Initialize the keys we use to check destructor ordering\n         for (key, global) in KEYS.iter_mut().zip(GLOBALS.iter_mut()) {\n-            *key = create(Some(mem::transmute(dtor as unsafe extern fn(*mut u64))));\n+            *key = create(Some(mem::transmute(dtor as unsafe extern \"C\" fn(*mut u64))));\n             set(*key, global as *mut _ as *mut u8);\n         }\n "}, {"sha": "7f0782fe32247e4b89daee3457930c91b6398079", "filename": "tests/pass/const-vec-of-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconst-vec-of-fns.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -5,7 +5,7 @@\n  * should be read as a null or otherwise wrong pointer and crash.\n  */\n \n-fn f() { }\n+fn f() {}\n static mut CLOSURES: &'static mut [fn()] = &mut [f as fn(), f as fn()];\n \n pub fn main() {"}, {"sha": "9805ce0ace3f051774189042de42fbf277001042", "filename": "tests/pass/drop_empty_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_empty_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_empty_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdrop_empty_slice.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -2,6 +2,6 @@\n \n fn main() {\n     // With the nested Vec, this is calling Offset(Unique::empty(), 0) on drop.\n-    let args : Vec<Vec<i32>> = Vec::new();\n+    let args: Vec<Vec<i32>> = Vec::new();\n     let _val = box args;\n }"}, {"sha": "ae1ef036267e2ffb81fce94c05db2782f3cf0134", "filename": "tests/pass/drop_on_array_elements.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_on_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_on_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdrop_on_array_elements.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -5,7 +5,9 @@ static mut DROP_COUNT: usize = 0;\n impl Drop for Bar {\n     fn drop(&mut self) {\n         assert_eq!(self.0 as usize, unsafe { DROP_COUNT }); // tests whether we are called at a valid address\n-        unsafe { DROP_COUNT += 1; }\n+        unsafe {\n+            DROP_COUNT += 1;\n+        }\n     }\n }\n \n@@ -16,7 +18,7 @@ fn main() {\n     assert_eq!(unsafe { DROP_COUNT }, 4);\n \n     // check empty case\n-    let b : [Bar; 0] = [];\n+    let b: [Bar; 0] = [];\n     drop(b);\n     assert_eq!(unsafe { DROP_COUNT }, 4);\n }"}, {"sha": "40025cd07f7e0b116070d3ad959811f94887ae4b", "filename": "tests/pass/drop_on_fat_ptr_array_elements.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_on_fat_ptr_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_on_fat_ptr_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdrop_on_fat_ptr_array_elements.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -8,7 +8,9 @@ static mut DROP_COUNT: usize = 0;\n \n impl Drop for Bar {\n     fn drop(&mut self) {\n-        unsafe { DROP_COUNT += 1; }\n+        unsafe {\n+            DROP_COUNT += 1;\n+        }\n     }\n }\n "}, {"sha": "babe098e4e6f5d48b8b9759d5229cc6ed258e4ce", "filename": "tests/pass/drop_on_zst_array_elements.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_on_zst_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_on_zst_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdrop_on_zst_array_elements.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -4,7 +4,9 @@ static mut DROP_COUNT: usize = 0;\n \n impl Drop for Bar {\n     fn drop(&mut self) {\n-        unsafe { DROP_COUNT += 1; }\n+        unsafe {\n+            DROP_COUNT += 1;\n+        }\n     }\n }\n \n@@ -15,7 +17,7 @@ fn main() {\n     assert_eq!(unsafe { DROP_COUNT }, 4);\n \n     // check empty case\n-    let b : [Bar; 0] = [];\n+    let b: [Bar; 0] = [];\n     drop(b);\n     assert_eq!(unsafe { DROP_COUNT }, 4);\n }"}, {"sha": "8cdeb57d02f7985a6854595bc4a1aa1fa6782beb", "filename": "tests/pass/drop_through_owned_slice.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_through_owned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_through_owned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdrop_through_owned_slice.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -4,7 +4,9 @@ static mut DROP_COUNT: usize = 0;\n \n impl Drop for Bar {\n     fn drop(&mut self) {\n-        unsafe { DROP_COUNT += 1; }\n+        unsafe {\n+            DROP_COUNT += 1;\n+        }\n     }\n }\n "}, {"sha": "8d22ca9ceb4ab055acf7ab8fb0e7e5e00cfce97e", "filename": "tests/pass/drop_through_trait_object.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_through_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_through_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdrop_through_trait_object.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -6,7 +6,9 @@ static mut DROP_CALLED: bool = false;\n \n impl Drop for Bar {\n     fn drop(&mut self) {\n-        unsafe { DROP_CALLED = true; }\n+        unsafe {\n+            DROP_CALLED = true;\n+        }\n     }\n }\n "}, {"sha": "7806c0252d270452b1a7d96dfe51933c1ab14086", "filename": "tests/pass/drop_through_trait_object_rc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_through_trait_object_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdrop_through_trait_object_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdrop_through_trait_object_rc.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -6,7 +6,9 @@ static mut DROP_CALLED: bool = false;\n \n impl Drop for Bar {\n     fn drop(&mut self) {\n-        unsafe { DROP_CALLED = true; }\n+        unsafe {\n+            DROP_CALLED = true;\n+        }\n     }\n }\n "}, {"sha": "4d1db03643f79d1a3f1d15e892f06215d7ccd8b7", "filename": "tests/pass/dst-field-align.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdst-field-align.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,67 +1,66 @@\n #[allow(dead_code)]\n struct Foo<T: ?Sized> {\n     a: u16,\n-    b: T\n+    b: T,\n }\n \n trait Bar {\n     fn get(&self) -> usize;\n }\n \n impl Bar for usize {\n-    fn get(&self) -> usize { *self }\n+    fn get(&self) -> usize {\n+        *self\n+    }\n }\n \n struct Baz<T: ?Sized> {\n-    a: T\n+    a: T,\n }\n \n #[allow(dead_code)]\n struct HasDrop<T: ?Sized> {\n     ptr: Box<usize>,\n-    data: T\n+    data: T,\n }\n \n fn main() {\n     // Test that zero-offset works properly\n-    let b : Baz<usize> = Baz { a: 7 };\n+    let b: Baz<usize> = Baz { a: 7 };\n     assert_eq!(b.a.get(), 7);\n-    let b : &Baz<dyn Bar> = &b;\n+    let b: &Baz<dyn Bar> = &b;\n     assert_eq!(b.a.get(), 7);\n \n     // Test that the field is aligned properly\n-    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    let f: Foo<usize> = Foo { a: 0, b: 11 };\n     assert_eq!(f.b.get(), 11);\n-    let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n+    let ptr1: *const u8 = &f.b as *const _ as *const u8;\n \n-    let f : &Foo<dyn Bar> = &f;\n-    let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n+    let f: &Foo<dyn Bar> = &f;\n+    let ptr2: *const u8 = &f.b as *const _ as *const u8;\n     assert_eq!(f.b.get(), 11);\n \n     // The pointers should be the same\n     assert_eq!(ptr1, ptr2);\n \n     // Test that nested DSTs work properly\n-    let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n+    let f: Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 } };\n     assert_eq!(f.b.b.get(), 17);\n-    let f : &Foo<Foo<dyn Bar>> = &f;\n+    let f: &Foo<Foo<dyn Bar>> = &f;\n     assert_eq!(f.b.b.get(), 17);\n \n     // Test that get the pointer via destructuring works\n \n-    let f : Foo<usize> = Foo { a: 0, b: 11 };\n-    let f : &Foo<dyn Bar> = &f;\n+    let f: Foo<usize> = Foo { a: 0, b: 11 };\n+    let f: &Foo<dyn Bar> = &f;\n     let &Foo { a: _, b: ref bar } = f;\n     assert_eq!(bar.get(), 11);\n \n     // Make sure that drop flags don't screw things up\n \n-    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n-        ptr: Box::new(0),\n-        data: Baz { a: [1,2,3,4] }\n-    };\n-    assert_eq!([1,2,3,4], d.data.a);\n+    let d: HasDrop<Baz<[i32; 4]>> = HasDrop { ptr: Box::new(0), data: Baz { a: [1, 2, 3, 4] } };\n+    assert_eq!([1, 2, 3, 4], d.data.a);\n \n-    let d : &HasDrop<Baz<[i32]>> = &d;\n-    assert_eq!(&[1,2,3,4], &d.data.a);\n+    let d: &HasDrop<Baz<[i32]>> = &d;\n+    assert_eq!(&[1, 2, 3, 4], &d.data.a);\n }"}, {"sha": "fe7335c0c65647a61783aeeff92cb46a870a9c20", "filename": "tests/pass/dst-irrefutable-bind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-irrefutable-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-irrefutable-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdst-irrefutable-bind.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,14 +1,14 @@\n struct Test<T: ?Sized>(T);\n \n fn main() {\n-    let x = Test([1,2,3]);\n-    let x : &Test<[i32]> = &x;\n+    let x = Test([1, 2, 3]);\n+    let x: &Test<[i32]> = &x;\n \n-    let & ref _y = x;\n+    let &ref _y = x;\n \n     // Make sure binding to a fat pointer behind a reference\n     // still works\n-    let slice = &[1,2,3];\n+    let slice = &[1, 2, 3];\n     let x = Test(&slice);\n     let Test(&_slice) = x;\n }"}, {"sha": "f26191a1d59989c0ca5a4c0146d84e4527172a03", "filename": "tests/pass/dst-raw.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdst-raw.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,12 +1,11 @@\n // Test DST raw pointers\n \n-\n trait Trait {\n     fn foo(&self) -> isize;\n }\n \n struct A {\n-    f: isize\n+    f: isize,\n }\n impl Trait for A {\n     fn foo(&self) -> isize {\n@@ -15,24 +14,20 @@ impl Trait for A {\n }\n \n struct Foo<T: ?Sized> {\n-    f: T\n+    f: T,\n }\n \n pub fn main() {\n     // raw trait object\n     let x = A { f: 42 };\n     let z: *const dyn Trait = &x;\n-    let r = unsafe {\n-        (&*z).foo()\n-    };\n+    let r = unsafe { (&*z).foo() };\n     assert_eq!(r, 42);\n \n     // raw DST struct\n-    let p = Foo {f: A { f: 42 }};\n+    let p = Foo { f: A { f: 42 } };\n     let o: *const Foo<dyn Trait> = &p;\n-    let r = unsafe {\n-        (&*o).f.foo()\n-    };\n+    let r = unsafe { (&*o).f.foo() };\n     assert_eq!(r, 42);\n \n     // raw slice\n@@ -54,7 +49,7 @@ pub fn main() {\n     }\n \n     // raw DST struct with slice\n-    let c: *const Foo<[_]> = &Foo {f: [1, 2, 3]};\n+    let c: *const Foo<[_]> = &Foo { f: [1, 2, 3] };\n     unsafe {\n         let b = (&*c).f[0];\n         assert_eq!(b, 1);\n@@ -65,16 +60,12 @@ pub fn main() {\n     // all of the above with *mut\n     let mut x = A { f: 42 };\n     let z: *mut dyn Trait = &mut x;\n-    let r = unsafe {\n-        (&*z).foo()\n-    };\n+    let r = unsafe { (&*z).foo() };\n     assert_eq!(r, 42);\n \n-    let mut p = Foo {f: A { f: 42 }};\n+    let mut p = Foo { f: A { f: 42 } };\n     let o: *mut Foo<dyn Trait> = &mut p;\n-    let r = unsafe {\n-        (&*o).f.foo()\n-    };\n+    let r = unsafe { (&*o).f.foo() };\n     assert_eq!(r, 42);\n \n     let a: *mut [_] = &mut [1, 2, 3];\n@@ -93,7 +84,7 @@ pub fn main() {\n         assert_eq!(len, 3);\n     }\n \n-    let c: *mut Foo<[_]> = &mut Foo {f: [1, 2, 3]};\n+    let c: *mut Foo<[_]> = &mut Foo { f: [1, 2, 3] };\n     unsafe {\n         let b = (&*c).f[0];\n         assert_eq!(b, 1);"}, {"sha": "4b25fbb06300608115295f781d671781de73ce78", "filename": "tests/pass/dst-struct-sole.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdst-struct-sole.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,8 +1,7 @@\n // As dst-struct.rs, but the unsized field is the only field in the struct.\n \n-\n struct Fat<T: ?Sized> {\n-    ptr: T\n+    ptr: T,\n }\n \n // x is a fat pointer\n@@ -13,7 +12,7 @@ fn foo(x: &Fat<[isize]>) {\n     assert_eq!(x.ptr[1], 2);\n }\n \n-fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+fn foo2<T: ToBar>(x: &Fat<[T]>) {\n     let y = &x.ptr;\n     let bar = Bar;\n     assert_eq!(x.ptr.len(), 3);"}, {"sha": "7191068eb2c404e479ed5cd86fc0f0cdf8e0d88a", "filename": "tests/pass/dst-struct.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdst-struct.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -3,7 +3,7 @@\n struct Fat<T: ?Sized> {\n     f1: isize,\n     f2: &'static str,\n-    ptr: T\n+    ptr: T,\n }\n \n // x is a fat pointer\n@@ -16,7 +16,7 @@ fn foo(x: &Fat<[isize]>) {\n     assert_eq!(x.f2, \"some str\");\n }\n \n-fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+fn foo2<T: ToBar>(x: &Fat<[T]>) {\n     let y = &x.ptr;\n     let bar = Bar;\n     assert_eq!(x.ptr.len(), 3);\n@@ -37,7 +37,6 @@ fn foo3(x: &Fat<Fat<[isize]>>) {\n     assert_eq!(x.ptr.ptr[1], 2);\n }\n \n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n struct Bar;\n \n@@ -53,9 +52,9 @@ impl ToBar for Bar {\n \n pub fn main() {\n     // With a vec of ints.\n-    let f1 : Fat<[isize; 3]> = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    let f1: Fat<[isize; 3]> = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n     foo(&f1);\n-    let f2 : &Fat<[isize; 3]> = &f1;\n+    let f2: &Fat<[isize; 3]> = &f1;\n     foo(f2);\n     let f3: &Fat<[isize]> = f2;\n     foo(f3);\n@@ -91,7 +90,7 @@ pub fn main() {\n     assert!(f5.ptr.is_empty());\n \n     // Deeply nested.\n-    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3] } };\n     foo3(&f1);\n     let f2 = &f1;\n     foo3(f2);\n@@ -100,7 +99,7 @@ pub fn main() {\n     let f4: &Fat<Fat<[isize]>> = &f1;\n     foo3(f4);\n     let f5: &Fat<Fat<[isize]>> =\n-        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3] } };\n     foo3(f5);\n \n     // Box.\n@@ -110,14 +109,14 @@ pub fn main() {\n     assert_eq!((*f2)[1], 2);\n \n     // Nested Box.\n-    let f1 : Box<Fat<[isize; 3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    let f1: Box<Fat<[isize; 3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n     foo(&*f1);\n-    let f2 : Box<Fat<[isize]>> = f1;\n+    let f2: Box<Fat<[isize]>> = f1;\n     foo(&*f2);\n \n-    let f3 : Box<Fat<[isize]>> =\n+    let f3: Box<Fat<[isize]>> =\n         Box::<Fat<[_; 3]>>::new(Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] });\n     foo(&*f3);\n-    let f4 : Box<Fat<[isize]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    let f4: Box<Fat<[isize]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n     foo(&*f4);\n }"}, {"sha": "256c72add9220a7afc8ac5add134287ea66b130a", "filename": "tests/pass/dyn-arbitrary-self.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdyn-arbitrary-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdyn-arbitrary-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdyn-arbitrary-self.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -19,11 +19,7 @@ fn pin_box_dyn() {\n }\n \n fn stdlib_pointers() {\n-    use std::{\n-        rc::Rc,\n-        sync::Arc,\n-        pin::Pin,\n-    };\n+    use std::{pin::Pin, rc::Rc, sync::Arc};\n \n     trait Trait {\n         fn by_rc(self: Rc<Self>) -> i64;\n@@ -63,8 +59,8 @@ fn stdlib_pointers() {\n \n fn pointers_and_wrappers() {\n     use std::{\n-        ops::{Deref, CoerceUnsized, DispatchFromDyn},\n         marker::Unsize,\n+        ops::{CoerceUnsized, Deref, DispatchFromDyn},\n     };\n \n     struct Ptr<T: ?Sized>(Box<T>);\n@@ -93,7 +89,6 @@ fn pointers_and_wrappers() {\n     impl<T: CoerceUnsized<U>, U> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n     impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T> {}\n \n-\n     trait Trait {\n         // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n         // without unsized_locals), but wrappers arond `Self` currently are not.\n@@ -126,7 +121,6 @@ fn pointers_and_wrappers() {\n     assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n }\n \n-\n fn main() {\n     pin_box_dyn();\n     stdlib_pointers();"}, {"sha": "00667757b0488e409231ea5f7fce085516a704de", "filename": "tests/pass/dyn-traits.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdyn-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fdyn-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fdyn-traits.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -39,25 +39,30 @@ fn ref_box_dyn() {\n     y.box_method();\n }\n \n-\n fn box_box_trait() {\n     struct DroppableStruct;\n \n     static mut DROPPED: bool = false;\n \n     impl Drop for DroppableStruct {\n         fn drop(&mut self) {\n-            unsafe { DROPPED = true; }\n+            unsafe {\n+                DROPPED = true;\n+            }\n         }\n     }\n \n-    trait MyTrait { fn dummy(&self) { } }\n+    trait MyTrait {\n+        fn dummy(&self) {}\n+    }\n     impl MyTrait for Box<DroppableStruct> {}\n \n-    struct Whatever { w: Box<dyn MyTrait+'static> }\n+    struct Whatever {\n+        w: Box<dyn MyTrait + 'static>,\n+    }\n \n-    impl  Whatever {\n-        fn new(w: Box<dyn MyTrait+'static>) -> Whatever {\n+    impl Whatever {\n+        fn new(w: Box<dyn MyTrait + 'static>) -> Whatever {\n             Whatever { w: w }\n         }\n     }"}, {"sha": "8385cc5d880c65903059d92b270eb5d8b317b892", "filename": "tests/pass/enum-nullable-const-null-with-fields.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fenum-nullable-const-null-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fenum-nullable-const-null-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fenum-nullable-const-null-with-fields.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,4 +1,3 @@\n-\n use std::result::Result;\n use std::result::Result::Ok;\n "}, {"sha": "d2dc06525475ef517c02db42336555d7e6cb7d74", "filename": "tests/pass/enums.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fenums.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -2,24 +2,21 @@ enum MyEnum {\n     MyEmptyVariant,\n     MyNewtypeVariant(i32),\n     MyTupleVariant(i32, i32),\n-    MyStructVariant {\n-        my_first_field: i32,\n-        my_second_field: i32,\n-    }\n+    MyStructVariant { my_first_field: i32, my_second_field: i32 },\n }\n \n fn test(me: MyEnum) {\n     match me {\n-        MyEnum::MyEmptyVariant => {},\n+        MyEnum::MyEmptyVariant => {}\n         MyEnum::MyNewtypeVariant(ref val) => assert_eq!(val, &42),\n         MyEnum::MyTupleVariant(ref a, ref b) => {\n             assert_eq!(a, &43);\n             assert_eq!(b, &44);\n-        },\n+        }\n         MyEnum::MyStructVariant { ref my_first_field, ref my_second_field } => {\n             assert_eq!(my_first_field, &45);\n             assert_eq!(my_second_field, &46);\n-        },\n+        }\n     }\n }\n \n@@ -41,7 +38,7 @@ fn discriminant_overflow() {\n \n     let x = Foo::B;\n     match x {\n-        Foo::B => {},\n+        Foo::B => {}\n         _ => panic!(),\n     }\n }\n@@ -126,10 +123,7 @@ fn main() {\n     test(MyEnum::MyEmptyVariant);\n     test(MyEnum::MyNewtypeVariant(42));\n     test(MyEnum::MyTupleVariant(43, 44));\n-    test(MyEnum::MyStructVariant{\n-        my_first_field: 45,\n-        my_second_field: 46,\n-    });\n+    test(MyEnum::MyStructVariant { my_first_field: 45, my_second_field: 46 });\n \n     discriminant_overflow();\n     more_discriminant_overflow();"}, {"sha": "aa4c65ea8928a0cdc0ecd39ab84c2f19a4da6b97", "filename": "tests/pass/extern_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fextern_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fextern_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fextern_types.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,6 +1,6 @@\n #![feature(extern_types)]\n \n-extern {\n+extern \"C\" {\n     type Foo;\n }\n "}, {"sha": "8317156a218dd80994ce6d095f0af9ef266406e4", "filename": "tests/pass/fat_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ffat_ptr.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -3,7 +3,7 @@\n struct Wrapper<T: ?Sized>(u32, T);\n \n struct FatPtrContainer<'a> {\n-    ptr: &'a [u8]\n+    ptr: &'a [u8],\n }\n \n fn fat_ptr_project(a: &Wrapper<[u8]>) -> &[u8] {\n@@ -36,14 +36,14 @@ fn fat_ptr_constant() -> &'static str {\n }\n \n fn main() {\n-    let a = Wrapper(4, [7,6,5]);\n+    let a = Wrapper(4, [7, 6, 5]);\n \n     let p = fat_ptr_project(&a);\n     let p = fat_ptr_simple(p);\n     let p = fat_ptr_via_local(p);\n     let p = fat_ptr_from_struct(fat_ptr_to_struct(p));\n \n-    let mut target : &[u8] = &[42];\n+    let mut target: &[u8] = &[42];\n     fat_ptr_store_to(p, &mut target);\n     assert_eq!(target, &a.1);\n "}, {"sha": "48dd99441ebff50106bab664537ec367dcc65b70", "filename": "tests/pass/float.rs", "status": "modified", "additions": 147, "deletions": 52, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ffloat.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -26,76 +26,126 @@ trait FloatToInt<Int>: Copy {\n }\n \n impl FloatToInt<i8> for f32 {\n-    fn cast(self) -> i8 { self as _ }\n-    unsafe fn cast_unchecked(self) -> i8 { self.to_int_unchecked() }\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<i32> for f32 {\n-    fn cast(self) -> i32 { self as _ }\n-    unsafe fn cast_unchecked(self) -> i32 { self.to_int_unchecked() }\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<u32> for f32 {\n-    fn cast(self) -> u32 { self as _ }\n-    unsafe fn cast_unchecked(self) -> u32 { self.to_int_unchecked() }\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<i64> for f32 {\n-    fn cast(self) -> i64 { self as _ }\n-    unsafe fn cast_unchecked(self) -> i64 { self.to_int_unchecked() }\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<u64> for f32 {\n-    fn cast(self) -> u64 { self as _ }\n-    unsafe fn cast_unchecked(self) -> u64 { self.to_int_unchecked() }\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n }\n \n impl FloatToInt<i8> for f64 {\n-    fn cast(self) -> i8 { self as _ }\n-    unsafe fn cast_unchecked(self) -> i8 { self.to_int_unchecked() }\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<i32> for f64 {\n-    fn cast(self) -> i32 { self as _ }\n-    unsafe fn cast_unchecked(self) -> i32 { self.to_int_unchecked() }\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<u32> for f64 {\n-    fn cast(self) -> u32 { self as _ }\n-    unsafe fn cast_unchecked(self) -> u32 { self.to_int_unchecked() }\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<i64> for f64 {\n-    fn cast(self) -> i64 { self as _ }\n-    unsafe fn cast_unchecked(self) -> i64 { self.to_int_unchecked() }\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<u64> for f64 {\n-    fn cast(self) -> u64 { self as _ }\n-    unsafe fn cast_unchecked(self) -> u64 { self.to_int_unchecked() }\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<i128> for f64 {\n-    fn cast(self) -> i128 { self as _ }\n-    unsafe fn cast_unchecked(self) -> i128 { self.to_int_unchecked() }\n+    fn cast(self) -> i128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i128 {\n+        self.to_int_unchecked()\n+    }\n }\n impl FloatToInt<u128> for f64 {\n-    fn cast(self) -> u128 { self as _ }\n-    unsafe fn cast_unchecked(self) -> u128 { self.to_int_unchecked() }\n+    fn cast(self) -> u128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u128 {\n+        self.to_int_unchecked()\n+    }\n }\n \n /// Test this cast both via `as` and via `approx_unchecked` (i.e., it must not saturate).\n #[track_caller]\n #[inline(never)]\n fn test_both_cast<F, I>(x: F, y: I)\n-    where F: FloatToInt<I>, I: PartialEq + Debug\n+where\n+    F: FloatToInt<I>,\n+    I: PartialEq + Debug,\n {\n     assert_eq!(x.cast(), y);\n     assert_eq!(unsafe { x.cast_unchecked() }, y);\n }\n \n fn basic() {\n     // basic arithmetic\n-    assert_eq(6.0_f32*6.0_f32, 36.0_f32);\n-    assert_eq(6.0_f64*6.0_f64, 36.0_f64);\n-    assert_eq(-{5.0_f32}, -5.0_f32);\n-    assert_eq(-{5.0_f64}, -5.0_f64);\n+    assert_eq(6.0_f32 * 6.0_f32, 36.0_f32);\n+    assert_eq(6.0_f64 * 6.0_f64, 36.0_f64);\n+    assert_eq(-{ 5.0_f32 }, -5.0_f32);\n+    assert_eq(-{ 5.0_f64 }, -5.0_f64);\n     // infinities, NaN\n-    assert!((5.0_f32/0.0).is_infinite());\n-    assert_ne!({5.0_f32/0.0}, {-5.0_f32/0.0});\n-    assert!((5.0_f64/0.0).is_infinite());\n-    assert_ne!({5.0_f64/0.0}, {5.0_f64/-0.0});\n+    assert!((5.0_f32 / 0.0).is_infinite());\n+    assert_ne!({ 5.0_f32 / 0.0 }, { -5.0_f32 / 0.0 });\n+    assert!((5.0_f64 / 0.0).is_infinite());\n+    assert_ne!({ 5.0_f64 / 0.0 }, { 5.0_f64 / -0.0 });\n     assert!((-5.0_f32).sqrt().is_nan());\n     assert!((-5.0_f64).sqrt().is_nan());\n     assert_ne!(f32::NAN, f32::NAN);\n@@ -161,9 +211,9 @@ fn casts() {\n     test_both_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n     test_both_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n     test_both_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n-    test_both_cast::<f32, u32>((u32::MAX-128) as f32, u32::MAX-255); // rounding loss\n+    test_both_cast::<f32, u32>((u32::MAX - 128) as f32, u32::MAX - 255); // rounding loss\n     // unrepresentable casts\n-    assert_eq::<u32>((u32::MAX-127) as f32 as u32, u32::MAX); // rounds up and then becomes unrepresentable\n+    assert_eq::<u32>((u32::MAX - 127) as f32 as u32, u32::MAX); // rounds up and then becomes unrepresentable\n     assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n     assert_eq::<u32>(-5.0f32 as u32, 0);\n     assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n@@ -187,7 +237,10 @@ fn casts() {\n     test_both_cast::<f64, i32>(0.0, 0);\n     test_both_cast::<f64, i32>(-0.0, 0);\n     test_both_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n-    test_both_cast::<f64, i32>(/*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a), -1);\n+    test_both_cast::<f64, i32>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n     test_both_cast::<f64, i32>(1.9, 1);\n     test_both_cast::<f64, i32>(-1.9, -1);\n     test_both_cast::<f64, i32>(1e8, 100_000_000);\n@@ -201,9 +254,15 @@ fn casts() {\n     test_both_cast::<f64, i64>(0.0, 0);\n     test_both_cast::<f64, i64>(-0.0, 0);\n     test_both_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n-    test_both_cast::<f64, i64>(/*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001), 0);\n+    test_both_cast::<f64, i64>(\n+        /*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001),\n+        0,\n+    );\n     test_both_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n-    test_both_cast::<f64, i64>(/*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a), -1);\n+    test_both_cast::<f64, i64>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n     test_both_cast::<f64, i64>(5.0, 5);\n     test_both_cast::<f64, i64>(5.9, 5);\n     test_both_cast::<f64, i64>(-5.0, -5);\n@@ -228,11 +287,11 @@ fn casts() {\n     test_both_cast::<f64, u64>(-0.99999999999, 0);\n     test_both_cast::<f64, u64>(5.0, 5);\n     test_both_cast::<f64, u64>(1e16, 10000000000000000);\n-    test_both_cast::<f64, u64>((u64::MAX-1024) as f64, u64::MAX-2047); // rounding loss\n+    test_both_cast::<f64, u64>((u64::MAX - 1024) as f64, u64::MAX - 2047); // rounding loss\n     test_both_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n     // unrepresentable casts\n     assert_eq::<u64>(-5.0f64 as u64, 0);\n-    assert_eq::<u64>((u64::MAX-1023) as f64 as u64, u64::MAX); // rounds up and then becomes unrepresentable\n+    assert_eq::<u64>((u64::MAX - 1023) as f64 as u64, u64::MAX); // rounds up and then becomes unrepresentable\n     assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n     assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n     assert_eq::<u64>(f64::MIN as u64, 0);\n@@ -258,10 +317,22 @@ fn casts() {\n     assert_eq::<f32>((-16777217i32) as f32, -16777216.0);\n     assert_eq::<f32>(16777219i32 as f32, 16777220.0);\n     assert_eq::<f32>((-16777219i32) as f32, -16777220.0);\n-    assert_eq::<f32>(0x7fffff4000000001i64 as f32, /*0x1.fffffep+62*/ f32::from_bits(0x5effffff));\n-    assert_eq::<f32>(0x8000004000000001u64 as i64 as f32, /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff));\n-    assert_eq::<f32>(0x0020000020000001i64 as f32, /*0x1.000002p+53*/ f32::from_bits(0x5a000001));\n-    assert_eq::<f32>(0xffdfffffdfffffffu64 as i64 as f32, /*-0x1.000002p+53*/ f32::from_bits(0xda000001));\n+    assert_eq::<f32>(\n+        0x7fffff4000000001i64 as f32,\n+        /*0x1.fffffep+62*/ f32::from_bits(0x5effffff),\n+    );\n+    assert_eq::<f32>(\n+        0x8000004000000001u64 as i64 as f32,\n+        /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff),\n+    );\n+    assert_eq::<f32>(\n+        0x0020000020000001i64 as f32,\n+        /*0x1.000002p+53*/ f32::from_bits(0x5a000001),\n+    );\n+    assert_eq::<f32>(\n+        0xffdfffffdfffffffu64 as i64 as f32,\n+        /*-0x1.000002p+53*/ f32::from_bits(0xda000001),\n+    );\n     assert_eq::<f32>(i128::MIN as f32, -170141183460469231731687303715884105728.0f32);\n     assert_eq::<f32>(u128::MAX as f32, f32::INFINITY); // saturation\n \n@@ -284,12 +355,30 @@ fn casts() {\n     assert_eq::<u64>((0.0f32 as f64).to_bits(), 0.0f64.to_bits());\n     assert_eq::<u64>(((-0.0f32) as f64).to_bits(), (-0.0f64).to_bits());\n     assert_eq::<f64>(5.0f32 as f64, 5.0f64);\n-    assert_eq::<f64>(/*0x1p-149*/ f32::from_bits(0x1) as f64, /*0x1p-149*/ f64::from_bits(0x36a0000000000000));\n-    assert_eq::<f64>(/*-0x1p-149*/ f32::from_bits(0x80000001) as f64, /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000));\n-    assert_eq::<f64>(/*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64, /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000));\n-    assert_eq::<f64>(/*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64, /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000));\n-    assert_eq::<f64>(/*0x1p-119*/ f32::from_bits(0x4000000) as f64, /*0x1p-119*/ f64::from_bits(0x3880000000000000));\n-    assert_eq::<f64>(/*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64, 6.6382536710104395e+37);\n+    assert_eq::<f64>(\n+        /*0x1p-149*/ f32::from_bits(0x1) as f64,\n+        /*0x1p-149*/ f64::from_bits(0x36a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1p-149*/ f32::from_bits(0x80000001) as f64,\n+        /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64,\n+        /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64,\n+        /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1p-119*/ f32::from_bits(0x4000000) as f64,\n+        /*0x1p-119*/ f64::from_bits(0x3880000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64,\n+        6.6382536710104395e+37,\n+    );\n     assert_eq::<f64>(f32::INFINITY as f64, f64::INFINITY);\n     assert_eq::<f64>(f32::NEG_INFINITY as f64, f64::NEG_INFINITY);\n \n@@ -299,8 +388,14 @@ fn casts() {\n     assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n     assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n     assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n-    assert_eq::<f32>(/*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32, /*0x1p-149*/ f32::from_bits(0x800000));\n-    assert_eq::<f32>(/*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32, /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728));\n+    assert_eq::<f32>(\n+        /*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32,\n+        /*0x1p-149*/ f32::from_bits(0x800000),\n+    );\n+    assert_eq::<f32>(\n+        /*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32,\n+        /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728),\n+    );\n     assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n     assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n     assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);"}, {"sha": "52d985667df2db43df9eaf3fcf2dd4aa19902271", "filename": "tests/pass/float_fast_math.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffloat_fast_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffloat_fast_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ffloat_fast_math.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -1,6 +1,6 @@\n #![feature(core_intrinsics)]\n \n-use std::intrinsics::{fadd_fast, fsub_fast, fmul_fast, fdiv_fast, frem_fast};\n+use std::intrinsics::{fadd_fast, fdiv_fast, fmul_fast, frem_fast, fsub_fast};\n \n #[inline(never)]\n pub fn test_operations_f64(a: f64, b: f64) {"}, {"sha": "391b182fda03c8c44f89f7dc3103245adecf1600", "filename": "tests/pass/foreign-fn-linkname.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fforeign-fn-linkname.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -7,7 +7,7 @@ use std::ffi::CString;\n \n mod mlibc {\n     use libc::{c_char, size_t};\n-    extern {\n+    extern \"C\" {\n         #[link_name = \"strlen\"]\n         pub fn my_strlen(str: *const c_char) -> size_t;\n     }\n@@ -16,9 +16,7 @@ mod mlibc {\n fn strlen(str: String) -> usize {\n     // C string is terminated with a zero\n     let s = CString::new(str).unwrap();\n-    unsafe {\n-        mlibc::my_strlen(s.as_ptr()) as usize\n-    }\n+    unsafe { mlibc::my_strlen(s.as_ptr()) as usize }\n }\n \n pub fn main() {"}, {"sha": "6753145e92b296caa001180fe54ccfbf6cf407ef", "filename": "tests/pass/fs_with_isolation.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffs_with_isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffs_with_isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ffs_with_isolation.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -7,9 +7,9 @@\n extern crate libc;\n \n use std::ffi::CString;\n-use std::os::unix;\n use std::fs::{self, File};\n use std::io::{Error, ErrorKind};\n+use std::os::unix;\n \n fn main() {\n     // test `open`\n@@ -25,7 +25,10 @@ fn main() {\n     assert_eq!(fs::remove_file(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n \n     // test `symlink`\n-    assert_eq!(unix::fs::symlink(\"foo.txt\", \"foo_link.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    assert_eq!(\n+        unix::fs::symlink(\"foo.txt\", \"foo_link.txt\").unwrap_err().kind(),\n+        ErrorKind::PermissionDenied\n+    );\n \n     // test `readlink`\n     let symlink_c_str = CString::new(\"foo.txt\").unwrap();"}, {"sha": "27aee9c883588e54259984b090c5a9fe2f17181a", "filename": "tests/pass/function_calls/exported_symbol.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffunction_calls%2Fexported_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffunction_calls%2Fexported_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ffunction_calls%2Fexported_symbol.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -24,7 +24,6 @@ impl AssocFn {\n     }\n }\n \n-\n fn main() {\n     // Repeat calls to make sure the `Instance` cache is not broken.\n     for _ in 0..3 {\n@@ -69,9 +68,8 @@ fn main() {\n             }\n \n             unsafe {\n-                let transmute = |f| {\n-                    std::mem::transmute::<unsafe extern \"C\" fn() -> i32, unsafe fn() -> i32>(f)\n-                };\n+                let transmute =\n+                    |f| std::mem::transmute::<unsafe extern \"C\" fn() -> i32, unsafe fn() -> i32>(f);\n                 assert_eq!(transmute(bar)(), -2);\n                 assert_eq!(transmute(baz)(), -3);\n                 assert_eq!(transmute(qux)(), -4);"}, {"sha": "b66826e3fcdfbfb565d047753b24ecf6ec29026a", "filename": "tests/pass/function_pointers.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332f2894ede0e30149d04030eefd87030569d013/tests%2Fpass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ffunction_pointers.rs?ref=332f2894ede0e30149d04030eefd87030569d013", "patch": "@@ -16,7 +16,7 @@ fn f<T: Answer>() -> T {\n }\n \n fn g(i: i32) -> i32 {\n-    i*42\n+    i * 42\n }\n \n fn h(i: i32, j: i32) -> i32 {\n@@ -31,17 +31,35 @@ fn call_fn_ptr() -> i32 {\n     return_fn_ptr(f)()\n }\n \n-fn indirect<F: Fn() -> i32>(f: F) -> i32 { f() }\n-fn indirect_mut<F: FnMut() -> i32>(mut f: F) -> i32 { f() }\n-fn indirect_once<F: FnOnce() -> i32>(f: F) -> i32 { f() }\n+fn indirect<F: Fn() -> i32>(f: F) -> i32 {\n+    f()\n+}\n+fn indirect_mut<F: FnMut() -> i32>(mut f: F) -> i32 {\n+    f()\n+}\n+fn indirect_once<F: FnOnce() -> i32>(f: F) -> i32 {\n+    f()\n+}\n \n-fn indirect2<F: Fn(i32) -> i32>(f: F) -> i32 { f(10) }\n-fn indirect_mut2<F: FnMut(i32) -> i32>(mut f: F) -> i32 { f(10) }\n-fn indirect_once2<F: FnOnce(i32) -> i32>(f: F) -> i32 { f(10) }\n+fn indirect2<F: Fn(i32) -> i32>(f: F) -> i32 {\n+    f(10)\n+}\n+fn indirect_mut2<F: FnMut(i32) -> i32>(mut f: F) -> i32 {\n+    f(10)\n+}\n+fn indirect_once2<F: FnOnce(i32) -> i32>(f: F) -> i32 {\n+    f(10)\n+}\n \n-fn indirect3<F: Fn(i32, i32) -> i32>(f: F) -> i32 { f(10, 3) }\n-fn indirect_mut3<F: FnMut(i32, i32) -> i32>(mut f: F) -> i32 { f(10, 3) }\n-fn indirect_once3<F: FnOnce(i32, i32) -> i32>(f: F) -> i32 { f(10, 3) }\n+fn indirect3<F: Fn(i32, i32) -> i32>(f: F) -> i32 {\n+    f(10, 3)\n+}\n+fn indirect_mut3<F: FnMut(i32, i32) -> i32>(mut f: F) -> i32 {\n+    f(10, 3)\n+}\n+fn indirect_once3<F: FnOnce(i32, i32) -> i32>(f: F) -> i32 {\n+    f(10, 3)\n+}\n \n fn main() {\n     assert_eq!(call_fn_ptr(), 42);"}]}