{"sha": "f9ef7e2835b757129b9171c54a6ce948a4a210be", "node_id": "C_kwDOAAsO6NoAKGY5ZWY3ZTI4MzViNzU3MTI5YjkxNzFjNTRhNmNlOTQ4YTRhMjEwYmU", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-09-20T17:40:31Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-09-21T04:17:59Z"}, "message": "code refactoring smart_resolve_report_errors", "tree": {"sha": "a6c277ec8dbb48784bf90dae8bc5a4a8cb87cd52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6c277ec8dbb48784bf90dae8bc5a4a8cb87cd52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9ef7e2835b757129b9171c54a6ce948a4a210be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ef7e2835b757129b9171c54a6ce948a4a210be", "html_url": "https://github.com/rust-lang/rust/commit/f9ef7e2835b757129b9171c54a6ce948a4a210be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9ef7e2835b757129b9171c54a6ce948a4a210be/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11bb80a92b4f46fa7dfa9148d0bdfc185a7621bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/11bb80a92b4f46fa7dfa9148d0bdfc185a7621bd", "html_url": "https://github.com/rust-lang/rust/commit/11bb80a92b4f46fa7dfa9148d0bdfc185a7621bd"}], "stats": {"total": 434, "additions": 261, "deletions": 173}, "files": [{"sha": "ac1153602572f265daa26b7ca98a1cdcc9443791", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 261, "deletions": 173, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef7e2835b757129b9171c54a6ce948a4a210be/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef7e2835b757129b9171c54a6ce948a4a210be/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=f9ef7e2835b757129b9171c54a6ce948a4a210be", "patch": "@@ -130,6 +130,15 @@ pub(super) enum LifetimeElisionCandidate {\n     Missing(MissingLifetime),\n }\n \n+struct BaseError<'a> {\n+    msg: String,\n+    fallback_label: String,\n+    span: Span,\n+    span_label: Option<(Span, &'a str)>,\n+    could_be_expr: bool,\n+    suggestion: Option<(Span, &'a str, String)>,\n+}\n+\n impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n@@ -138,35 +147,18 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    /// Handles error reporting for `smart_resolve_path_fragment` function.\n-    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n-    pub(crate) fn smart_resolve_report_errors(\n+    fn make_base_error(\n         &mut self,\n         path: &[Segment],\n         span: Span,\n         source: PathSource<'_>,\n         res: Option<Res>,\n-    ) -> (DiagnosticBuilder<'a, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n-        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-        let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n-\n-        debug!(?res, ?source);\n-\n+    ) -> BaseError<'static> {\n         // Make the base error.\n-        struct BaseError<'a> {\n-            msg: String,\n-            fallback_label: String,\n-            span: Span,\n-            span_label: Option<(Span, &'a str)>,\n-            could_be_expr: bool,\n-            suggestion: Option<(Span, &'a str, String)>,\n-        }\n         let mut expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n-        let base_error = if let Some(res) = res {\n+        if let Some(res) = res {\n             BaseError {\n                 msg: format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n                 fallback_label: format!(\"not a {expected}\"),\n@@ -277,53 +269,92 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 could_be_expr: false,\n                 suggestion,\n             }\n-        };\n+        }\n+    }\n \n+    /// Handles error reporting for `smart_resolve_path_fragment` function.\n+    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    pub(crate) fn smart_resolve_report_errors(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: PathSource<'_>,\n+        res: Option<Res>,\n+    ) -> (DiagnosticBuilder<'a, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n+        debug!(?res, ?source);\n+        let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());\n         let mut err =\n             self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n \n         self.suggest_swapping_misplaced_self_ty_and_trait(&mut err, source, res, base_error.span);\n \n-        if let Some((span, label)) = base_error.span_label {\n+        if let Some((span, label)) = base_error.span_label.clone() {\n             err.span_label(span, label);\n         }\n \n-        if let Some(sugg) = base_error.suggestion {\n-            err.span_suggestion_verbose(sugg.0, sugg.1, sugg.2, Applicability::MaybeIncorrect);\n+        if let Some(ref sugg) = base_error.suggestion {\n+            err.span_suggestion_verbose(sugg.0, sugg.1, &sugg.2, Applicability::MaybeIncorrect);\n         }\n \n-        if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n-            err.multipart_suggestion(\n-                \"you might have meant to write a `struct` literal\",\n-                vec![\n-                    (span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n-                    (span.shrink_to_hi(), \"}\".to_string()),\n-                ],\n-                Applicability::HasPlaceholders,\n-            );\n+        self.suggest_bare_struct_literal(&mut err);\n+        self.suggest_pattern_match_with_let(&mut err, source, span);\n+\n+        self.suggest_self_or_self_ref(&mut err, path, span);\n+        self.detect_assoct_type_constraint_meant_as_path(&mut err, &base_error);\n+        if self.suggest_self_ty_or_self_value(&mut err, source, path, span) {\n+            return (err, Vec::new());\n         }\n-        match (source, self.diagnostic_metadata.in_if_condition) {\n-            (\n-                PathSource::Expr(_),\n-                Some(Expr { span: expr_span, kind: ExprKind::Assign(lhs, _, _), .. }),\n-            ) => {\n-                // Icky heuristic so we don't suggest:\n-                // `if (i + 2) = 2` => `if let (i + 2) = 2` (approximately pattern)\n-                // `if 2 = i` => `if let 2 = i` (lhs needs to contain error span)\n-                if lhs.is_approximately_pattern() && lhs.span.contains(span) {\n-                    err.span_suggestion_verbose(\n-                        expr_span.shrink_to_lo(),\n-                        \"you might have meant to use pattern matching\",\n-                        \"let \",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+\n+        let (found, candidates) =\n+            self.try_lookup_name_with_relex_fashion(&mut err, source, path, span, res, &base_error);\n+        if found {\n+            return (err, candidates);\n+        }\n+\n+        self.suggest_type_ascription(&mut err, source, path, res, span, &base_error);\n+        self.add_err_code_cases(&mut err, source, path, span);\n+\n+        (err, candidates)\n+    }\n+\n+    fn detect_assoct_type_constraint_meant_as_path(\n+        &self,\n+        err: &mut Diagnostic,\n+        base_error: &BaseError<'static>,\n+    ) {\n+        let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n+        let TyKind::Path(_, path) = &ty.kind else { return; };\n+        for segment in &path.segments {\n+            let Some(params) = &segment.args else { continue; };\n+            let ast::GenericArgs::AngleBracketed(ref params) = params.deref() else { continue; };\n+            for param in &params.args {\n+                let ast::AngleBracketedArg::Constraint(constraint) = param else { continue; };\n+                let ast::AssocConstraintKind::Bound { bounds } = &constraint.kind else {\n+                    continue;\n+                };\n+                for bound in bounds {\n+                    let ast::GenericBound::Trait(trait_ref, ast::TraitBoundModifier::None)\n+                        = bound else\n+                    {\n+                        continue;\n+                    };\n+                    if base_error.span == trait_ref.span {\n+                        err.span_suggestion_verbose(\n+                            constraint.ident.span.between(trait_ref.span),\n+                            \"you might have meant to write a path instead of an associated type bound\",\n+                            \"::\",\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 }\n             }\n-            _ => {}\n         }\n+    }\n \n+    fn suggest_self_or_self_ref(&mut self, err: &mut Diagnostic, path: &[Segment], span: Span) {\n         let is_assoc_fn = self.self_type_is_available();\n+        let item_str = path.last().unwrap().ident;\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n         if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n@@ -358,96 +389,25 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n             }\n         }\n+    }\n \n-        self.detect_assoct_type_constraint_meant_as_path(base_error.span, &mut err);\n-\n-        // Emit special messages for unresolved `Self` and `self`.\n-        if is_self_type(path, ns) {\n-            err.code(rustc_errors::error_code!(E0411));\n-            err.span_label(\n-                span,\n-                \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n-            );\n-            if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`Self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n-            }\n-            return (err, Vec::new());\n-        }\n-        if is_self_value(path, ns) {\n-            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n-\n-            err.code(rustc_errors::error_code!(E0424));\n-            err.span_label(span, match source {\n-                PathSource::Pat => \"`self` value is a keyword and may not be bound to variables or shadowed\",\n-                _ => \"`self` value is a keyword only available in methods with a `self` parameter\",\n-            });\n-            if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n-                // The current function has a `self' parameter, but we were unable to resolve\n-                // a reference to `self`. This can only happen if the `self` identifier we\n-                // are resolving came from a different hygiene context.\n-                if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n-                    err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n-                } else {\n-                    let doesnt = if is_assoc_fn {\n-                        let (span, sugg) = fn_kind\n-                            .decl()\n-                            .inputs\n-                            .get(0)\n-                            .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n-                            .unwrap_or_else(|| {\n-                                // Try to look for the \"(\" after the function name, if possible.\n-                                // This avoids placing the suggestion into the visibility specifier.\n-                                let span = fn_kind\n-                                    .ident()\n-                                    .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n-                                (\n-                                    self.r\n-                                        .session\n-                                        .source_map()\n-                                        .span_through_char(span, '(')\n-                                        .shrink_to_hi(),\n-                                    \"&self\",\n-                                )\n-                            });\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            \"add a `self` receiver parameter to make the associated `fn` a method\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        \"doesn't\"\n-                    } else {\n-                        \"can't\"\n-                    };\n-                    if let Some(ident) = fn_kind.ident() {\n-                        err.span_label(\n-                            ident.span,\n-                            &format!(\"this function {} have a `self` parameter\", doesnt),\n-                        );\n-                    }\n-                }\n-            } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n-            }\n-            return (err, Vec::new());\n-        }\n-\n+    fn try_lookup_name_with_relex_fashion(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+        res: Option<Res>,\n+        base_error: &BaseError<'static>,\n+    ) -> (bool, Vec<ImportSuggestion>) {\n         // Try to lookup name in more relaxed fashion for better error reporting.\n         let ident = path.last().unwrap().ident;\n+        let is_expected = &|res| source.is_expected(res);\n+        let ns = source.namespace();\n+        let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n+        let path_str = Segment::names_to_string(path);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+\n         let mut candidates = self\n             .r\n             .lookup_import_candidates(ident, ns, &self.parent_scope, is_expected)\n@@ -494,7 +454,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     {\n                         // Already reported this issue on the lhs of the type ascription.\n                         err.delay_as_bug();\n-                        return (err, candidates);\n+                        return (true, candidates);\n                     }\n                 }\n \n@@ -522,8 +482,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 );\n             }\n         }\n+\n         // Try Levenshtein algorithm.\n-        let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected);\n+        let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n         if path.len() == 1 && self.self_type_is_available() {\n             if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n                 let self_is_available = self.self_value_is_available(path[0].ident.span);\n@@ -560,8 +521,8 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         );\n                     }\n                 }\n-                self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n-                return (err, candidates);\n+                self.r.add_typo_suggestion(err, typo_sugg, ident_span);\n+                return (true, candidates);\n             }\n \n             // If the first argument in call is `self` suggest calling a method.\n@@ -579,29 +540,40 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     format!(\"self.{path_str}({args_snippet})\"),\n                     Applicability::MachineApplicable,\n                 );\n-                return (err, candidates);\n+                return (true, candidates);\n             }\n         }\n \n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n             if self.smart_resolve_context_dependent_help(\n-                &mut err,\n+                err,\n                 span,\n                 source,\n                 res,\n                 &path_str,\n                 &base_error.fallback_label,\n             ) {\n                 // We do this to avoid losing a secondary span when we override the main error span.\n-                self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n-                return (err, candidates);\n+                self.r.add_typo_suggestion(err, typo_sugg, ident_span);\n+                return (true, candidates);\n             }\n         }\n+        return (false, candidates);\n+    }\n \n+    fn suggest_type_ascription(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        res: Option<Res>,\n+        span: Span,\n+        base_error: &BaseError<'static>,\n+    ) {\n         let is_macro =\n             base_error.span.from_expansion() && base_error.span.desugaring_kind().is_none();\n-        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n+        if !self.type_ascription_suggestion(err, base_error.span) {\n             let mut fallback = false;\n             if let (\n                 PathSource::Trait(AliasPossibility::Maybe),\n@@ -663,9 +635,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n             }\n \n-            fallback |= self.restrict_assoc_type_in_where_clause(span, &mut err);\n+            let is_expected = &|res| source.is_expected(res);\n+            let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+            fallback |= self.restrict_assoc_type_in_where_clause(span, err);\n \n-            if !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span) {\n+            let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n+            if !self.r.add_typo_suggestion(err, typo_sugg, ident_span) {\n                 fallback = true;\n                 match self.diagnostic_metadata.current_let_binding {\n                     Some((pat_sp, Some(ty_sp), None))\n@@ -683,17 +658,27 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n                 // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n                 let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n-                self.r.add_typo_suggestion(&mut err, suggestion, ident_span);\n+                self.r.add_typo_suggestion(err, suggestion, ident_span);\n             }\n             if fallback {\n                 // Fallback label.\n-                err.span_label(base_error.span, base_error.fallback_label);\n+                err.span_label(base_error.span, &base_error.fallback_label);\n             }\n         }\n+    }\n+\n+    fn add_err_code_cases(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) {\n         if let Some(err_code) = &err.code {\n             if err_code == &rustc_errors::error_code!(E0425) {\n                 for label_rib in &self.label_ribs {\n                     for (label_ident, node_id) in &label_rib.bindings {\n+                        let ident = path.last().unwrap().ident;\n                         if format!(\"'{}\", ident) == label_ident.to_string() {\n                             err.span_label(label_ident.span, \"a label with a similar name exists\");\n                             if let PathSource::Expr(Some(Expr {\n@@ -724,38 +709,106 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n             }\n         }\n-\n-        (err, candidates)\n     }\n \n-    fn detect_assoct_type_constraint_meant_as_path(&self, base_span: Span, err: &mut Diagnostic) {\n-        let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n-        let TyKind::Path(_, path) = &ty.kind else { return; };\n-        for segment in &path.segments {\n-            let Some(params) = &segment.args else { continue; };\n-            let ast::GenericArgs::AngleBracketed(ref params) = params.deref() else { continue; };\n-            for param in &params.args {\n-                let ast::AngleBracketedArg::Constraint(constraint) = param else { continue; };\n-                let ast::AssocConstraintKind::Bound { bounds } = &constraint.kind else {\n-                    continue;\n-                };\n-                for bound in bounds {\n-                    let ast::GenericBound::Trait(trait_ref, ast::TraitBoundModifier::None)\n-                        = bound else\n-                    {\n-                        continue;\n-                    };\n-                    if base_span == trait_ref.span {\n+    /// Emit special messages for unresolved `Self` and `self`.\n+    fn suggest_self_ty_or_self_value(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) -> bool {\n+        if is_self_type(path, source.namespace()) {\n+            err.code(rustc_errors::error_code!(E0411));\n+            err.span_label(\n+                span,\n+                \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n+            );\n+            if let Some(item_kind) = self.diagnostic_metadata.current_item {\n+                err.span_label(\n+                    item_kind.ident.span,\n+                    format!(\n+                        \"`Self` not allowed in {} {}\",\n+                        item_kind.kind.article(),\n+                        item_kind.kind.descr()\n+                    ),\n+                );\n+            }\n+            return true;\n+        }\n+\n+        if is_self_value(path, source.namespace()) {\n+            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+            err.code(rustc_errors::error_code!(E0424));\n+            err.span_label(\n+            span,\n+            match source {\n+                PathSource::Pat => {\n+                    \"`self` value is a keyword and may not be bound to variables or shadowed\"\n+                }\n+                _ => \"`self` value is a keyword only available in methods with a `self` parameter\",\n+            },\n+            );\n+            let is_assoc_fn = self.self_type_is_available();\n+            if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n+                // The current function has a `self' parameter, but we were unable to resolve\n+                // a reference to `self`. This can only happen if the `self` identifier we\n+                // are resolving came from a different hygiene context.\n+                if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n+                    err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n+                } else {\n+                    let doesnt = if is_assoc_fn {\n+                        let (span, sugg) = fn_kind\n+                            .decl()\n+                            .inputs\n+                            .get(0)\n+                            .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n+                            .unwrap_or_else(|| {\n+                                // Try to look for the \"(\" after the function name, if possible.\n+                                // This avoids placing the suggestion into the visibility specifier.\n+                                let span = fn_kind\n+                                    .ident()\n+                                    .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n+                                (\n+                                    self.r\n+                                        .session\n+                                        .source_map()\n+                                        .span_through_char(span, '(')\n+                                        .shrink_to_hi(),\n+                                    \"&self\",\n+                                )\n+                            });\n                         err.span_suggestion_verbose(\n-                            constraint.ident.span.between(trait_ref.span),\n-                            \"you might have meant to write a path instead of an associated type bound\",\n-                            \"::\",\n-                            Applicability::MachineApplicable,\n+                            span,\n+                            \"add a `self` receiver parameter to make the associated `fn` a method\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        \"doesn't\"\n+                    } else {\n+                        \"can't\"\n+                    };\n+                    if let Some(ident) = fn_kind.ident() {\n+                        err.span_label(\n+                            ident.span,\n+                            &format!(\"this function {} have a `self` parameter\", doesnt),\n                         );\n                     }\n                 }\n+            } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n+                err.span_label(\n+                    item_kind.ident.span,\n+                    format!(\n+                        \"`self` not allowed in {} {}\",\n+                        item_kind.kind.article(),\n+                        item_kind.kind.descr()\n+                    ),\n+                );\n             }\n+            return true;\n         }\n+        false\n     }\n \n     fn suggest_swapping_misplaced_self_ty_and_trait(\n@@ -787,6 +840,41 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n+    fn suggest_bare_struct_literal(&mut self, err: &mut Diagnostic) {\n+        if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n+            err.multipart_suggestion(\n+                \"you might have meant to write a `struct` literal\",\n+                vec![\n+                    (span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n+                    (span.shrink_to_hi(), \"}\".to_string()),\n+                ],\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n+    }\n+\n+    fn suggest_pattern_match_with_let(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        span: Span,\n+    ) {\n+        if let PathSource::Expr(_) = source &&\n+        let Some(Expr { span: expr_span, kind: ExprKind::Assign(lhs, _, _), .. } ) = self.diagnostic_metadata.in_if_condition {\n+            // Icky heuristic so we don't suggest:\n+            // `if (i + 2) = 2` => `if let (i + 2) = 2` (approximately pattern)\n+            // `if 2 = i` => `if let 2 = i` (lhs needs to contain error span)\n+            if lhs.is_approximately_pattern() && lhs.span.contains(span) {\n+                err.span_suggestion_verbose(\n+                    expr_span.shrink_to_lo(),\n+                    \"you might have meant to use pattern matching\",\n+                    \"let \",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+\n     fn get_single_associated_item(\n         &mut self,\n         path: &[Segment],"}]}