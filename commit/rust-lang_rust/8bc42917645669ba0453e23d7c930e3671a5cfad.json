{"sha": "8bc42917645669ba0453e23d7c930e3671a5cfad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYzQyOTE3NjQ1NjY5YmEwNDUzZTIzZDdjOTMwZTM2NzFhNWNmYWQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-10T21:43:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-10T21:50:01Z"}, "message": "Some edits to introductory material in docs.", "tree": {"sha": "704210633c886da630c97793c30c06c66164cd55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/704210633c886da630c97793c30c06c66164cd55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bc42917645669ba0453e23d7c930e3671a5cfad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc42917645669ba0453e23d7c930e3671a5cfad", "html_url": "https://github.com/rust-lang/rust/commit/8bc42917645669ba0453e23d7c930e3671a5cfad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bc42917645669ba0453e23d7c930e3671a5cfad/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5c8c851966e98778a03f5539431832ee8d452b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c8c851966e98778a03f5539431832ee8d452b5", "html_url": "https://github.com/rust-lang/rust/commit/f5c8c851966e98778a03f5539431832ee8d452b5"}], "stats": {"total": 68, "additions": 28, "deletions": 40}, "files": [{"sha": "76e8a0da4a57fe85d2902b60f4b234e40ed239ae", "filename": "doc/rust.texi", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8bc42917645669ba0453e23d7c930e3671a5cfad/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/8bc42917645669ba0453e23d7c930e3671a5cfad/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=8bc42917645669ba0453e23d7c930e3671a5cfad", "patch": "@@ -19,7 +19,7 @@ Version: @gitversion\n \n Copyright 2006-2010 Graydon Hoare\n \n-Copyright 2009-2010 Mozilla Foundation\n+Copyright 2009-2011 Mozilla Foundation\n \n See accompanying LICENSE.txt for terms.\n \n@@ -192,12 +192,12 @@ subsumed into the more general facility of disjoint union types. A program\n must explicitly model its use of such types.\n \n @sp 1\n-@item Lightweight tasks with no shared mutable state\n+@item Lightweight tasks with no shared values\n \n Like many @emph{actor} languages, Rust provides an isolation (and concurrency)\n model based on lightweight tasks scheduled by the language runtime. These\n-tasks are very inexpensive and statically unable to mutate one another's local\n-memory. Breaking the rule of task isolation is only possible by calling\n+tasks are very inexpensive and statically unable to manipulate one another's\n+local memory. Breaking the rule of task isolation is only possible by calling\n external (C/C++) code.\n \n Inter-task communication is typed, asynchronous and simplex, based on passing\n@@ -247,10 +247,11 @@ roles.\n @item Static control over memory allocation, packing and aliasing.\n \n Many values in Rust are allocated @emph{within} their containing stack-frame\n-or parent structure. Numbers, records, tuples and tags are all allocated this\n+or parent structure. Numbers, records and tags are all allocated this\n way. To allocate such values in the heap, they must be explicitly\n @emph{boxed}. A @dfn{box} is a pointer to a heap allocation that holds another\n-value, its @emph{content}.\n+value, its @emph{content}. Boxes may be either shared or unique, depending\n+on which sort of storage management is desired.\n \n Boxing and unboxing in Rust is explicit, though in many cases (arithmetic\n operations, name-component dereferencing) Rust will automatically ``reach\n@@ -273,42 +274,29 @@ still guaranteeing that every use of a slot occurs after it has been\n initialized.\n \n @sp 1\n-@item Static control over mutability and garbage collection.\n+@item Immutable data by default\n \n-Types in Rust are classified into @emph{layers}. There is a layer of immutable\n-values, a layer of state values, and a layer of GC values. By default, all\n-types are immutable.\n+All types in Rust are immutable by default. A field within a type must be\n+declared as @code{mutable} in order to be modified.\n \n-If a field within a type is declared as @code{mutable}, then the type is part\n-of the @code{state} layer and must be declared as such. Any type directly\n-marked as @code{state} @emph{or indirectly referring to} a state type is also\n-a state type.\n-\n-If a field within a type is potentially cyclic (this is a narrow, but\n-well-defined condition involving mutable recursive types) then it is part of\n-the @code{gc} layer and must be declared as such.\n-\n-This classification of data types in Rust interacts with the memory allocation,\n-transmission and destruction rules. In particular:\n-\n-@itemize\n-@item Only immutable values can be sent over channels.\n-@item Only non-GC objects can have destructor functions.\n-@end itemize\n-\n-Garbage collection, when present, operates per-task and does not interrupt\n-other tasks while running. It is limited to types that need it and can be\n-statically avoided altogether by limiting the types in a program to the state\n-and immutable layers.\n-\n-Non-GC values are reference-counted and have a deterministic destruction\n-order: top-down, immediately upon release of the last live reference.\n-\n-State values can refer to non-state values, but not vice-versa; likewise GC\n-values can refer to non-GC values but not vice-versa. Rust therefore\n-encourages the programmer to write in a style that consists primarily of\n-immutable types, but also permits limited, local (per-task) mutability,\n-and provides local (per-task) GC only when required.\n+@sp 1\n+@item Move semantics and unique pointers\n+\n+Rust differentiates copying values from moving them, and permits moving and\n+swapping values explicitly rather than copying. Moving can be more efficient and,\n+crucially, represents an indivisible transfer of ownership of a value from its\n+source to its destination.\n+\n+In addition, pointer types in Rust come in several varieties. One important\n+type of pointer related to move semantics is the @emph{unique} pointer,\n+denoted @code{~}, which is statically guaranteed to be the only pointer\n+pointing to its referent at any given time.\n+\n+Combining move-semantics and unique pointers, Rust permits a very lightweight\n+form of inter-task communication: values are sent between tasks by moving, and\n+only types composed of unique pointers can be sent. This statically ensures\n+there can never be sharing of data between tasks, while keeping the costs of\n+transferring data between tasks as cheap as moving a pointer.\n \n @sp 1\n @item Stack-based iterators"}]}