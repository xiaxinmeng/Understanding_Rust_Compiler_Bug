{"sha": "c24c6388848634a4fb6e22e6b6b51b246eda96cb", "node_id": "C_kwDOAAsO6NoAKGMyNGM2Mzg4ODQ4NjM0YTRmYjZlMjJlNmI2YjUxYjI0NmVkYTk2Y2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T01:59:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T01:59:38Z"}, "message": "Auto merge of #2346 - LegNeato:mkstemp, r=RalfJung\n\nAdd `mkstemp` shim for unix", "tree": {"sha": "ba42c4e70e85e4d1f14ae3b181c173a205d5dc3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba42c4e70e85e4d1f14ae3b181c173a205d5dc3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c24c6388848634a4fb6e22e6b6b51b246eda96cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c24c6388848634a4fb6e22e6b6b51b246eda96cb", "html_url": "https://github.com/rust-lang/rust/commit/c24c6388848634a4fb6e22e6b6b51b246eda96cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c24c6388848634a4fb6e22e6b6b51b246eda96cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f4612a29e345a59f64e31bdcb16f57396b77c99", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4612a29e345a59f64e31bdcb16f57396b77c99", "html_url": "https://github.com/rust-lang/rust/commit/9f4612a29e345a59f64e31bdcb16f57396b77c99"}, {"sha": "b29e7b8e4e4539eb1d916cf14123595858b79185", "url": "https://api.github.com/repos/rust-lang/rust/commits/b29e7b8e4e4539eb1d916cf14123595858b79185", "html_url": "https://github.com/rust-lang/rust/commit/b29e7b8e4e4539eb1d916cf14123595858b79185"}], "stats": {"total": 213, "additions": 212, "deletions": 1}, "files": [{"sha": "83815cccb0c4d8560d1ae2fcccad09b24b9e0469", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c24c6388848634a4fb6e22e6b6b51b246eda96cb/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24c6388848634a4fb6e22e6b6b51b246eda96cb/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=c24c6388848634a4fb6e22e6b6b51b246eda96cb", "patch": "@@ -166,6 +166,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.realpath(path, resolved_path)?;\n                 this.write_pointer(result, dest)?;\n             }\n+            \"mkstemp\" => {\n+                let [template] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.mkstemp(template)?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n \n             // Time related shims\n             \"gettimeofday\" => {"}, {"sha": "9b00579d873b9462129c142e371825d5e15793a4", "filename": "src/shims/unix/fs.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c24c6388848634a4fb6e22e6b6b51b246eda96cb/src%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24c6388848634a4fb6e22e6b6b51b246eda96cb/src%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffs.rs?ref=c24c6388848634a4fb6e22e6b6b51b246eda96cb", "patch": "@@ -5,7 +5,7 @@ use std::fs::{\n     read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir,\n };\n use std::io::{self, ErrorKind, Read, Seek, SeekFrom, Write};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::time::SystemTime;\n \n use log::trace;\n@@ -14,6 +14,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::{self, layout::LayoutOf};\n use rustc_target::abi::{Align, Size};\n \n+use crate::shims::os_str::bytes_to_os_str;\n use crate::*;\n use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n@@ -1724,6 +1725,133 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n     }\n+    fn mkstemp(&mut self, template_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n+        use rand::seq::SliceRandom;\n+\n+        // POSIX defines the template string.\n+        const TEMPFILE_TEMPLATE_STR: &str = \"XXXXXX\";\n+\n+        let this = self.eval_context_mut();\n+        this.assert_target_os_is_unix(\"mkstemp\");\n+\n+        // POSIX defines the maximum number of attempts before failure.\n+        //\n+        // `mkstemp()` relies on `tmpnam()` which in turn relies on `TMP_MAX`.\n+        // POSIX says this about `TMP_MAX`:\n+        // * Minimum number of unique filenames generated by `tmpnam()`.\n+        // * Maximum number of times an application can call `tmpnam()` reliably.\n+        //   * The value of `TMP_MAX` is at least 25.\n+        //   * On XSI-conformant systems, the value of `TMP_MAX` is at least 10000.\n+        // See <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html>.\n+        let max_attempts = this.eval_libc(\"TMP_MAX\")?.to_u32()?;\n+\n+        // Get the raw bytes from the template -- as a byte slice, this is a string in the target\n+        // (and the target is unix, so a byte slice is the right representation).\n+        let template_ptr = this.read_pointer(template_op)?;\n+        let mut template = this.eval_context_ref().read_c_str(template_ptr)?.to_owned();\n+        let template_bytes = template.as_mut_slice();\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`mkstemp`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EACCES\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(-1);\n+        }\n+\n+        // Get the bytes of the suffix we expect in _target_ encoding.\n+        let suffix_bytes = TEMPFILE_TEMPLATE_STR.as_bytes();\n+\n+        // At this point we have one `&[u8]` that represents the template and one `&[u8]`\n+        // that represents the expected suffix.\n+\n+        // Now we figure out the index of the slice we expect to contain the suffix.\n+        let start_pos = template_bytes.len().saturating_sub(suffix_bytes.len());\n+        let end_pos = template_bytes.len();\n+        let last_six_char_bytes = &template_bytes[start_pos..end_pos];\n+\n+        // If we don't find the suffix, it is an error.\n+        if last_six_char_bytes != suffix_bytes {\n+            let einval = this.eval_libc(\"EINVAL\")?;\n+            this.set_last_error(einval)?;\n+            return Ok(-1);\n+        }\n+\n+        // At this point we know we have 6 ASCII 'X' characters as a suffix.\n+\n+        // From <https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/sysdeps/posix/tempname.c#L175>\n+        const SUBSTITUTIONS: &[char; 62] = &[\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\n+            'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n+            'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\n+            'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+        ];\n+\n+        // The file is opened with specific options, which Rust does not expose in a portable way.\n+        // So we use specific APIs depending on the host OS.\n+        let mut fopts = OpenOptions::new();\n+        fopts.read(true).write(true).create_new(true);\n+\n+        #[cfg(unix)]\n+        {\n+            use std::os::unix::fs::OpenOptionsExt;\n+            fopts.mode(0o600);\n+            // Do not allow others to read or modify this file.\n+            fopts.custom_flags(libc::O_EXCL);\n+        }\n+        #[cfg(windows)]\n+        {\n+            use std::os::windows::fs::OpenOptionsExt;\n+            // Do not allow others to read or modify this file.\n+            fopts.share_mode(0);\n+        }\n+\n+        // If the generated file already exists, we will try again `max_attempts` many times.\n+        for _ in 0..max_attempts {\n+            let rng = this.machine.rng.get_mut();\n+\n+            // Generate a random unique suffix.\n+            let unique_suffix = SUBSTITUTIONS.choose_multiple(rng, 6).collect::<String>();\n+\n+            // Replace the template string with the random string.\n+            template_bytes[start_pos..end_pos].copy_from_slice(unique_suffix.as_bytes());\n+\n+            // Write the modified template back to the passed in pointer to maintain POSIX semantics.\n+            this.write_bytes_ptr(template_ptr, template_bytes.iter().copied())?;\n+\n+            // To actually open the file, turn this into a host OsString.\n+            let p = bytes_to_os_str(template_bytes)?.to_os_string();\n+\n+            let possibly_unique = std::env::temp_dir().join::<PathBuf>(p.into());\n+\n+            let file = fopts.open(&possibly_unique);\n+\n+            match file {\n+                Ok(f) => {\n+                    let fh = &mut this.machine.file_handler;\n+                    let fd = fh.insert_fd(Box::new(FileHandle { file: f, writable: true }));\n+                    return Ok(fd);\n+                }\n+                Err(e) =>\n+                    match e.kind() {\n+                        // If the random file already exists, keep trying.\n+                        ErrorKind::AlreadyExists => continue,\n+                        // Any other errors are returned to the caller.\n+                        _ => {\n+                            // \"On error, -1 is returned, and errno is set to\n+                            // indicate the error\"\n+                            this.set_last_error_from_io_error(e.kind())?;\n+                            return Ok(-1);\n+                        }\n+                    },\n+            }\n+        }\n+\n+        // We ran out of attempts to create the file, return an error.\n+        let eexist = this.eval_libc(\"EEXIST\")?;\n+        this.set_last_error(eexist)?;\n+        Ok(-1)\n+    }\n }\n \n /// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch when"}, {"sha": "5be1fb394b9026dcd9e91ab6220dfc159d2482da", "filename": "tests/fail/fs/mkstemp_immutable_arg.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c24c6388848634a4fb6e22e6b6b51b246eda96cb/tests%2Ffail%2Ffs%2Fmkstemp_immutable_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24c6388848634a4fb6e22e6b6b51b246eda96cb/tests%2Ffail%2Ffs%2Fmkstemp_immutable_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffs%2Fmkstemp_immutable_arg.rs?ref=c24c6388848634a4fb6e22e6b6b51b246eda96cb", "patch": "@@ -0,0 +1,13 @@\n+//@ignore-target-windows: No libc on Windows\n+//@compile-flags: -Zmiri-disable-isolation\n+\n+#![feature(rustc_private)]\n+\n+fn main() {\n+    test_mkstemp_immutable_arg();\n+}\n+\n+fn test_mkstemp_immutable_arg() {\n+    let s: *mut libc::c_char = b\"fooXXXXXX\\0\" as *const _ as *mut _;\n+    let _fd = unsafe { libc::mkstemp(s) }; //~ ERROR: Undefined Behavior: writing to alloc1 which is read-only\n+}"}, {"sha": "0bd91f90a10f3b7e2259aaf40a19833ccfb63c5c", "filename": "tests/fail/fs/mkstemp_immutable_arg.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c24c6388848634a4fb6e22e6b6b51b246eda96cb/tests%2Ffail%2Ffs%2Fmkstemp_immutable_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c24c6388848634a4fb6e22e6b6b51b246eda96cb/tests%2Ffail%2Ffs%2Fmkstemp_immutable_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffs%2Fmkstemp_immutable_arg.stderr?ref=c24c6388848634a4fb6e22e6b6b51b246eda96cb", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: writing to ALLOC which is read-only\n+  --> $DIR/mkstemp_immutable_arg.rs:LL:CC\n+   |\n+LL |     let _fd = unsafe { libc::mkstemp(s) };\n+   |                        ^^^^^^^^^^^^^^^^ writing to ALLOC which is read-only\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: backtrace:\n+   = note: inside `test_mkstemp_immutable_arg` at $DIR/mkstemp_immutable_arg.rs:LL:CC\n+note: inside `main` at $DIR/mkstemp_immutable_arg.rs:LL:CC\n+  --> $DIR/mkstemp_immutable_arg.rs:LL:CC\n+   |\n+LL |     test_mkstemp_immutable_arg();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "468da0845a88ee9ffc7c40d555c8e55506b2eed0", "filename": "tests/pass/libc.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c24c6388848634a4fb6e22e6b6b51b246eda96cb/tests%2Fpass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24c6388848634a4fb6e22e6b6b51b246eda96cb/tests%2Fpass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.rs?ref=c24c6388848634a4fb6e22e6b6b51b246eda96cb", "patch": "@@ -407,11 +407,56 @@ fn test_isatty() {\n     }\n }\n \n+fn test_posix_mkstemp() {\n+    use std::ffi::CString;\n+    use std::ffi::OsStr;\n+    use std::os::unix::ffi::OsStrExt;\n+    use std::os::unix::io::FromRawFd;\n+    use std::path::Path;\n+\n+    let valid_template = \"fooXXXXXX\";\n+    // C needs to own this as `mkstemp(3)` says:\n+    // \"Since it will be modified, `template` must not be a string constant, but\n+    // should be declared as a character array.\"\n+    // There seems to be no `as_mut_ptr` on `CString` so we need to use `into_raw`.\n+    let ptr = CString::new(valid_template).unwrap().into_raw();\n+    let fd = unsafe { libc::mkstemp(ptr) };\n+    // Take ownership back in Rust to not leak memory.\n+    let slice = unsafe { CString::from_raw(ptr) };\n+    assert!(fd > 0);\n+    let osstr = OsStr::from_bytes(slice.to_bytes());\n+    let path: &Path = osstr.as_ref();\n+    let name = path.file_name().unwrap().to_string_lossy();\n+    assert!(name.ne(\"fooXXXXXX\"));\n+    assert!(name.starts_with(\"foo\"));\n+    assert_eq!(name.len(), 9);\n+    assert_eq!(\n+        name.chars().skip(3).filter(char::is_ascii_alphanumeric).collect::<Vec<char>>().len(),\n+        6\n+    );\n+    let file = unsafe { File::from_raw_fd(fd) };\n+    assert!(file.set_len(0).is_ok());\n+\n+    let invalid_templates = vec![\"foo\", \"barXX\", \"XXXXXXbaz\", \"whatXXXXXXever\", \"X\"];\n+    for t in invalid_templates {\n+        let ptr = CString::new(t).unwrap().into_raw();\n+        let fd = unsafe { libc::mkstemp(ptr) };\n+        let _ = unsafe { CString::from_raw(ptr) };\n+        // \"On error, -1 is returned, and errno is set to\n+        // indicate the error\"\n+        assert_eq!(fd, -1);\n+        let e = std::io::Error::last_os_error();\n+        assert_eq!(e.raw_os_error(), Some(libc::EINVAL));\n+        assert_eq!(e.kind(), std::io::ErrorKind::InvalidInput);\n+    }\n+}\n+\n fn main() {\n     #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n     test_posix_fadvise();\n \n     test_posix_gettimeofday();\n+    test_posix_mkstemp();\n \n     test_posix_realpath_alloc();\n     test_posix_realpath_noalloc();"}]}