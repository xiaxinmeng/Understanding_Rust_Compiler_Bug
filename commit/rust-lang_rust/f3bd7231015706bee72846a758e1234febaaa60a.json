{"sha": "f3bd7231015706bee72846a758e1234febaaa60a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYmQ3MjMxMDE1NzA2YmVlNzI4NDZhNzU4ZTEyMzRmZWJhYWE2MGE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-10T17:29:39Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-10T17:47:09Z"}, "message": "Fix intcast, use it where appropriate", "tree": {"sha": "9a3072e5e71a3f79a1f2fe0a986e446387626e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a3072e5e71a3f79a1f2fe0a986e446387626e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3bd7231015706bee72846a758e1234febaaa60a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3bd7231015706bee72846a758e1234febaaa60a", "html_url": "https://github.com/rust-lang/rust/commit/f3bd7231015706bee72846a758e1234febaaa60a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3bd7231015706bee72846a758e1234febaaa60a/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d1f36a482fed39ea5989bf971464622b8cba89e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d1f36a482fed39ea5989bf971464622b8cba89e", "html_url": "https://github.com/rust-lang/rust/commit/7d1f36a482fed39ea5989bf971464622b8cba89e"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "6a2fdc6aab69b14198cdf95cf6f59a1085617ba0", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f3bd7231015706bee72846a758e1234febaaa60a", "patch": "@@ -1310,7 +1310,6 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n                 let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n-\n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n \n@@ -1351,6 +1350,23 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }\n \n+                let typeck_ity = Integer::from_attr(dl, def.discr_ty);\n+                if typeck_ity < min_ity {\n+                    // It is a bug if Layout decided on a greater discriminant size than typeck for\n+                    // some reason at this point (based on values discriminant can take on). Mostly\n+                    // because this discriminant will be loaded, and then stored into variable of\n+                    // type calculated by typeck. Consider such case (a bug): typeck decided on\n+                    // byte-sized discriminant, but layout thinks we need a 16-bit to store all\n+                    // discriminant values. That would be a bug, because then, in trans, in order\n+                    // to store this 16-bit discriminant into 8-bit sized temporary some of the\n+                    // space necessary to represent would have to be discarded (or layout is wrong\n+                    // on thinking it needs 16 bits)\n+                    bug!(\"layout decided on a larger discriminant type ({:?}) than typeck ({:?})\",\n+                         min_ity, typeck_ity);\n+                    // However, it is fine to make discr type however large (as an optimisation)\n+                    // after this point \u2013 we\u2019ll just truncate the value we load in trans.\n+                }\n+\n                 // Check to see if we should use a different type for the\n                 // discriminant. We can safely use a type with the same size\n                 // as the alignment of the first field of each variant."}, {"sha": "8e2e072b584da43a2eedaf588cfc4eb570ac40bc", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=f3bd7231015706bee72846a758e1234febaaa60a", "patch": "@@ -1084,11 +1084,11 @@ extern \"C\" {\n                                 DestTy: TypeRef,\n                                 Name: *const c_char)\n                                 -> ValueRef;\n-    pub fn LLVMBuildIntCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n+    pub fn LLVMRustBuildIntCast(B: BuilderRef,\n+                                Val: ValueRef,\n+                                DestTy: TypeRef,\n+                                IsSized: bool)\n+                                -> ValueRef;\n     pub fn LLVMBuildFPCast(B: BuilderRef,\n                            Val: ValueRef,\n                            DestTy: TypeRef,"}, {"sha": "11d3fae823830318937767efd195601fa3f9643b", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=f3bd7231015706bee72846a758e1234febaaa60a", "patch": "@@ -318,7 +318,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n     };\n     match cast_to {\n         None => val,\n-        Some(llty) => if is_discr_signed(&l) { bcx.sext(val, llty) } else { bcx.zext(val, llty) }\n+        Some(llty) => bcx.intcast(val, llty, is_discr_signed(&l))\n     }\n }\n "}, {"sha": "41c0eaa52a77d1bc1a2f1d6cec13bc84a850a496", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f3bd7231015706bee72846a758e1234febaaa60a", "patch": "@@ -536,7 +536,7 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.int_type());\n+    let size = b.intcast(n_bytes, ccx.int_type(), false);\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);"}, {"sha": "f64e581c1773ee2a81e42a68c55f8526abb06c2b", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=f3bd7231015706bee72846a758e1234febaaa60a", "patch": "@@ -780,10 +780,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn intcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn intcast(&self, val: ValueRef, dest_ty: Type, is_signed: bool) -> ValueRef {\n         self.count_insn(\"intcast\");\n         unsafe {\n-            llvm::LLVMBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), is_signed)\n         }\n     }\n "}, {"sha": "38ee67796c6de2dcb03ae49def7ed147ae2756bd", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bd7231015706bee72846a758e1234febaaa60a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f3bd7231015706bee72846a758e1234febaaa60a", "patch": "@@ -286,17 +286,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                         let newval = match (r_t_in, r_t_out) {\n                             (CastTy::Int(_), CastTy::Int(_)) => {\n-                                let srcsz = ll_t_in.int_width();\n-                                let dstsz = ll_t_out.int_width();\n-                                if srcsz == dstsz {\n-                                    bcx.bitcast(llval, ll_t_out)\n-                                } else if srcsz > dstsz {\n-                                    bcx.trunc(llval, ll_t_out)\n-                                } else if signed {\n-                                    bcx.sext(llval, ll_t_out)\n-                                } else {\n-                                    bcx.zext(llval, ll_t_out)\n-                                }\n+                                bcx.intcast(llval, ll_t_out, signed)\n                             }\n                             (CastTy::Float, CastTy::Float) => {\n                                 let srcsz = ll_t_in.float_width();\n@@ -439,7 +429,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let discr_ty = rvalue.ty(&*self.mir, bcx.tcx()).unwrap();\n                 let discr_type = type_of::immediate_type_of(bcx.ccx, discr_ty);\n                 let discr = adt::trans_get_discr(&bcx, enum_ty, discr_lvalue.llval,\n-                                                 Some(discr_type), true);\n+                                                  discr_lvalue.alignment, Some(discr_type), true);\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n                     ty: discr_ty"}, {"sha": "c15a0c3d25a52a6f1b9b813af727d53379972655", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3bd7231015706bee72846a758e1234febaaa60a/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f3bd7231015706bee72846a758e1234febaaa60a/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f3bd7231015706bee72846a758e1234febaaa60a", "patch": "@@ -1308,6 +1308,12 @@ extern \"C\" LLVMRustVisibility LLVMRustGetVisibility(LLVMValueRef V) {\n   return toRust(LLVMGetVisibility(V));\n }\n \n+// Oh hey, a binding that makes sense for once? (because LLVM\u2019s own do not)\n+extern \"C\" LLVMValueRef LLVMRustBuildIntCast(LLVMBuilderRef B, LLVMValueRef Val,\n+                                             LLVMTypeRef DestTy, bool isSigned) {\n+  return wrap(unwrap(B)->CreateIntCast(unwrap(Val), unwrap(DestTy), isSigned, \"\"));\n+}\n+\n extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n                                       LLVMRustVisibility RustVisibility) {\n   LLVMSetVisibility(V, fromRust(RustVisibility));"}]}