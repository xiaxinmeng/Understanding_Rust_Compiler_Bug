{"sha": "ad14b684cc0a2aa9d9519786deec7475b78d4878", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMTRiNjg0Y2MwYTJhYTlkOTUxOTc4NmRlZWM3NDc1Yjc4ZDQ4Nzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T15:32:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T15:32:16Z"}, "message": "Auto merge of #1275 - JOE1994:move_string_helpers, r=RalfJung\n\nmove OsStr helpers to a separate file\n\nMoved OsStr read/write functions from `src/helpers.rs` to `src/shims/os_str.rs`, in order to keep `src/helpers.rs` from bloating too much.", "tree": {"sha": "fc57f12e586fe32044201a77547f7fdf5c15280f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc57f12e586fe32044201a77547f7fdf5c15280f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad14b684cc0a2aa9d9519786deec7475b78d4878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad14b684cc0a2aa9d9519786deec7475b78d4878", "html_url": "https://github.com/rust-lang/rust/commit/ad14b684cc0a2aa9d9519786deec7475b78d4878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad14b684cc0a2aa9d9519786deec7475b78d4878/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d3e2b65b99b2ffe3248a42ab76efb658b543a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d3e2b65b99b2ffe3248a42ab76efb658b543a64", "html_url": "https://github.com/rust-lang/rust/commit/3d3e2b65b99b2ffe3248a42ab76efb658b543a64"}, {"sha": "4a70ebc1f3e1d635a3ed6ec5d8e37e6618e5f05d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a70ebc1f3e1d635a3ed6ec5d8e37e6618e5f05d", "html_url": "https://github.com/rust-lang/rust/commit/4a70ebc1f3e1d635a3ed6ec5d8e37e6618e5f05d"}], "stats": {"total": 491, "additions": 251, "deletions": 240}, "files": [{"sha": "7634dfe2f87d8c74594f0338cf6dab5c907e4d3b", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 240, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=ad14b684cc0a2aa9d9519786deec7475b78d4878", "patch": "@@ -1,13 +1,5 @@\n-use std::ffi::{OsStr, OsString};\n-use std::path::{Path, PathBuf};\n-use std::{iter, mem};\n use std::convert::TryFrom;\n-use std::borrow::Cow;\n-\n-#[cfg(unix)]\n-use std::os::unix::ffi::{OsStrExt, OsStringExt};\n-#[cfg(windows)]\n-use std::os::windows::ffi::{OsStrExt, OsStringExt};\n+use std::mem;\n \n use rustc::mir;\n use rustc::ty::{\n@@ -463,237 +455,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n     }\n-\n-    /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n-    /// the Unix APIs usually handle.\n-    fn read_os_str_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n-    where\n-        'tcx: 'a,\n-        'mir: 'a,\n-    {\n-        #[cfg(unix)]\n-        fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n-            Ok(OsStr::from_bytes(bytes))\n-        }\n-        #[cfg(not(unix))]\n-        fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n-            let s = std::str::from_utf8(bytes)\n-                .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n-            Ok(OsStr::new(s))\n-        }\n-\n-        let this = self.eval_context_ref();\n-        let bytes = this.memory.read_c_str(scalar)?;\n-        bytes_to_os_str(bytes)\n-    }\n-\n-    /// Helper function to read an OsString from a 0x0000-terminated sequence of u16,\n-    /// which is what the Windows APIs usually handle.\n-    fn read_os_str_from_wide_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, OsString>\n-    where\n-        'tcx: 'a,\n-        'mir: 'a,\n-    {\n-        #[cfg(windows)]\n-        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n-            Ok(OsString::from_wide(&u16_vec[..]))\n-        }\n-        #[cfg(not(windows))]\n-        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n-            let s = String::from_utf16(&u16_vec[..])\n-                .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-16 string\", u16_vec))?;\n-            Ok(s.into())\n-        }\n-\n-        let u16_vec = self.eval_context_ref().memory.read_wide_str(scalar)?;\n-        u16vec_to_osstring(u16_vec)\n-    }\n-\n-    /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n-    /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n-    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n-    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n-    /// string length returned does not include the null terminator.\n-    fn write_os_str_to_c_str(\n-        &mut self,\n-        os_str: &OsStr,\n-        scalar: Scalar<Tag>,\n-        size: u64,\n-    ) -> InterpResult<'tcx, (bool, u64)> {\n-        #[cfg(unix)]\n-        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n-            Ok(os_str.as_bytes())\n-        }\n-        #[cfg(not(unix))]\n-        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n-            // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n-            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n-            // valid.\n-            os_str\n-                .to_str()\n-                .map(|s| s.as_bytes())\n-                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n-        }\n-\n-        let bytes = os_str_to_bytes(os_str)?;\n-        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n-        // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n-        let string_length = u64::try_from(bytes.len()).unwrap();\n-        if size <= string_length {\n-            return Ok((false, string_length));\n-        }\n-        self.eval_context_mut()\n-            .memory\n-            .write_bytes(scalar, bytes.iter().copied().chain(iter::once(0u8)))?;\n-        Ok((true, string_length))\n-    }\n-\n-    /// Helper function to write an OsStr as a 0x0000-terminated u16-sequence, which is what\n-    /// the Windows APIs usually handle. This function returns `Ok((false, length))` without trying\n-    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n-    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n-    /// string length returned does not include the null terminator.\n-    fn write_os_str_to_wide_str(\n-        &mut self,\n-        os_str: &OsStr,\n-        scalar: Scalar<Tag>,\n-        size: u64,\n-    ) -> InterpResult<'tcx, (bool, u64)> {\n-        #[cfg(windows)]\n-        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n-            Ok(os_str.encode_wide().collect())\n-        }\n-        #[cfg(not(windows))]\n-        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n-            // On non-Windows platforms the best we can do to transform Vec<u16> from/to OS strings is to do the\n-            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n-            // valid.\n-            os_str\n-                .to_str()\n-                .map(|s| s.encode_utf16().collect())\n-                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n-        }\n-\n-        let u16_vec = os_str_to_u16vec(os_str)?;\n-        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n-        // 0x0000 terminator to memory would cause an out-of-bounds access.\n-        let string_length = u64::try_from(u16_vec.len()).unwrap();\n-        if size <= string_length {\n-            return Ok((false, string_length));\n-        }\n-\n-        // Store the UTF-16 string.\n-        self.eval_context_mut()\n-            .memory\n-            .write_u16s(scalar, u16_vec.into_iter().chain(iter::once(0x0000)))?;\n-        Ok((true, string_length))\n-    }\n-\n-    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of bytes.\n-    fn alloc_os_str_as_c_str(\n-        &mut self,\n-        os_str: &OsStr,\n-        memkind: MemoryKind<MiriMemoryKind>,\n-    ) -> Pointer<Tag> {\n-        let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0` terminator.\n-        let this = self.eval_context_mut();\n-\n-        let arg_type = this.tcx.mk_array(this.tcx.types.u8, size);\n-        let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind);\n-        assert!(self.write_os_str_to_c_str(os_str, arg_place.ptr, size).unwrap().0);\n-        arg_place.ptr.assert_ptr()\n-    }\n-\n-    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of `u16`.\n-    fn alloc_os_str_as_wide_str(\n-        &mut self,\n-        os_str: &OsStr,\n-        memkind: MemoryKind<MiriMemoryKind>,\n-    ) -> Pointer<Tag> {\n-        let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0x0000` terminator.\n-        let this = self.eval_context_mut();\n-\n-        let arg_type = this.tcx.mk_array(this.tcx.types.u16, size);\n-        let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind);\n-        assert!(self.write_os_str_to_wide_str(os_str, arg_place.ptr, size).unwrap().0);\n-        arg_place.ptr.assert_ptr()\n-    }\n-\n-    /// Read a null-terminated sequence of bytes, and perform path separator conversion if needed.\n-    fn read_path_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, Cow<'a, Path>>\n-    where\n-        'tcx: 'a,\n-        'mir: 'a,\n-    {\n-        let this = self.eval_context_ref();\n-        let os_str = this.read_os_str_from_c_str(scalar)?;\n-\n-        #[cfg(windows)]\n-        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows-on-Windows, all fine.\n-            Cow::Borrowed(Path::new(os_str))\n-        } else {\n-            // Unix target, Windows host. Need to convert target '/' to host '\\'.\n-            let converted = os_str\n-                .encode_wide()\n-                .map(|wchar| if wchar == '/' as u16 { '\\\\' as u16 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(PathBuf::from(OsString::from_wide(&converted)))\n-        });\n-        #[cfg(unix)]\n-        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows target, Unix host. Need to convert target '\\' to host '/'.\n-            let converted = os_str\n-                .as_bytes()\n-                .iter()\n-                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(PathBuf::from(OsString::from_vec(converted)))\n-        } else {\n-            // Unix-on-Unix, all is fine.\n-            Cow::Borrowed(Path::new(os_str))\n-        });\n-    }\n-\n-    /// Write a Path to the machine memory, adjusting path separators if needed.\n-    fn write_path_to_c_str(\n-        &mut self,\n-        path: &Path,\n-        scalar: Scalar<Tag>,\n-        size: u64,\n-    ) -> InterpResult<'tcx, (bool, u64)> {\n-        let this = self.eval_context_mut();\n-\n-        #[cfg(windows)]\n-        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows-on-Windows, all fine.\n-            Cow::Borrowed(path.as_os_str())\n-        } else {\n-            // Unix target, Windows host. Need to convert host '\\\\' to target '/'.\n-            let converted = path\n-                .as_os_str()\n-                .encode_wide()\n-                .map(|wchar| if wchar == '\\\\' as u16 { '/' as u16 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(OsString::from_wide(&converted))\n-        };\n-        #[cfg(unix)]\n-        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows target, Unix host. Need to convert host '/' to target '\\'.\n-            let converted = path\n-                .as_os_str()\n-                .as_bytes()\n-                .iter()\n-                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(OsString::from_vec(converted))\n-        } else {\n-            // Unix-on-Unix, all is fine.\n-            Cow::Borrowed(path.as_os_str())\n-        };\n-\n-        this.write_os_str_to_c_str(&os_str, scalar, size)\n-    }\n }\n \n pub fn immty_from_int_checked<'tcx>("}, {"sha": "4fa78b7ec88ebe8ccf17530b499745de0808136e", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ad14b684cc0a2aa9d9519786deec7475b78d4878", "patch": "@@ -41,6 +41,7 @@ pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextExt;\n pub use crate::shims::fs::{DirHandler, EvalContextExt as FileEvalContextExt, FileHandler};\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n+pub use crate::shims::os_str::EvalContextExt as OsStrEvalContextExt;\n pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as PanicEvalContextExt};\n pub use crate::shims::time::EvalContextExt as TimeEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};"}, {"sha": "f950c80478349e22d2e33922a823b07a597b8346", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=ad14b684cc0a2aa9d9519786deec7475b78d4878", "patch": "@@ -3,6 +3,7 @@ pub mod env;\n pub mod foreign_items;\n pub mod fs;\n pub mod intrinsics;\n+pub mod os_str;\n pub mod panic;\n pub mod time;\n pub mod tls;"}, {"sha": "316d5b0014a7ebe744b31d24efb51f6b59f36c74", "filename": "src/shims/os_str.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad14b684cc0a2aa9d9519786deec7475b78d4878/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=ad14b684cc0a2aa9d9519786deec7475b78d4878", "patch": "@@ -0,0 +1,248 @@\n+use std::borrow::Cow;\n+use std::convert::TryFrom;\n+use std::ffi::{OsStr, OsString};\n+use std::iter;\n+use std::path::{Path, PathBuf};\n+\n+#[cfg(unix)]\n+use std::os::unix::ffi::{OsStrExt, OsStringExt};\n+#[cfg(windows)]\n+use std::os::windows::ffi::{OsStrExt, OsStringExt};\n+\n+use rustc::ty::layout::LayoutOf;\n+\n+use crate::*;\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n+    /// the Unix APIs usually handle.\n+    fn read_os_str_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        #[cfg(unix)]\n+        fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+            Ok(OsStr::from_bytes(bytes))\n+        }\n+        #[cfg(not(unix))]\n+        fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+            let s = std::str::from_utf8(bytes)\n+                .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n+            Ok(OsStr::new(s))\n+        }\n+\n+        let this = self.eval_context_ref();\n+        let bytes = this.memory.read_c_str(scalar)?;\n+        bytes_to_os_str(bytes)\n+    }\n+\n+    /// Helper function to read an OsString from a 0x0000-terminated sequence of u16,\n+    /// which is what the Windows APIs usually handle.\n+    fn read_os_str_from_wide_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, OsString>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        #[cfg(windows)]\n+        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+            Ok(OsString::from_wide(&u16_vec[..]))\n+        }\n+        #[cfg(not(windows))]\n+        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+            let s = String::from_utf16(&u16_vec[..])\n+                .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-16 string\", u16_vec))?;\n+            Ok(s.into())\n+        }\n+\n+        let u16_vec = self.eval_context_ref().memory.read_wide_str(scalar)?;\n+        u16vec_to_osstring(u16_vec)\n+    }\n+\n+    /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n+    /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does not include the null terminator.\n+    fn write_os_str_to_c_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        scalar: Scalar<Tag>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        #[cfg(unix)]\n+        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+            Ok(os_str.as_bytes())\n+        }\n+        #[cfg(not(unix))]\n+        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+            // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n+            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+            // valid.\n+            os_str\n+                .to_str()\n+                .map(|s| s.as_bytes())\n+                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+        }\n+\n+        let bytes = os_str_to_bytes(os_str)?;\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n+        // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n+        let string_length = u64::try_from(bytes.len()).unwrap();\n+        if size <= string_length {\n+            return Ok((false, string_length));\n+        }\n+        self.eval_context_mut()\n+            .memory\n+            .write_bytes(scalar, bytes.iter().copied().chain(iter::once(0u8)))?;\n+        Ok((true, string_length))\n+    }\n+\n+    /// Helper function to write an OsStr as a 0x0000-terminated u16-sequence, which is what\n+    /// the Windows APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does not include the null terminator.\n+    fn write_os_str_to_wide_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        scalar: Scalar<Tag>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        #[cfg(windows)]\n+        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n+            Ok(os_str.encode_wide().collect())\n+        }\n+        #[cfg(not(windows))]\n+        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n+            // On non-Windows platforms the best we can do to transform Vec<u16> from/to OS strings is to do the\n+            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+            // valid.\n+            os_str\n+                .to_str()\n+                .map(|s| s.encode_utf16().collect())\n+                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+        }\n+\n+        let u16_vec = os_str_to_u16vec(os_str)?;\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n+        // 0x0000 terminator to memory would cause an out-of-bounds access.\n+        let string_length = u64::try_from(u16_vec.len()).unwrap();\n+        if size <= string_length {\n+            return Ok((false, string_length));\n+        }\n+\n+        // Store the UTF-16 string.\n+        self.eval_context_mut()\n+            .memory\n+            .write_u16s(scalar, u16_vec.into_iter().chain(iter::once(0x0000)))?;\n+        Ok((true, string_length))\n+    }\n+\n+    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of bytes.\n+    fn alloc_os_str_as_c_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> Pointer<Tag> {\n+        let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0` terminator.\n+        let this = self.eval_context_mut();\n+\n+        let arg_type = this.tcx.mk_array(this.tcx.types.u8, size);\n+        let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind);\n+        assert!(self.write_os_str_to_c_str(os_str, arg_place.ptr, size).unwrap().0);\n+        arg_place.ptr.assert_ptr()\n+    }\n+\n+    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of `u16`.\n+    fn alloc_os_str_as_wide_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> Pointer<Tag> {\n+        let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0x0000` terminator.\n+        let this = self.eval_context_mut();\n+\n+        let arg_type = this.tcx.mk_array(this.tcx.types.u16, size);\n+        let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind);\n+        assert!(self.write_os_str_to_wide_str(os_str, arg_place.ptr, size).unwrap().0);\n+        arg_place.ptr.assert_ptr()\n+    }\n+\n+    /// Read a null-terminated sequence of bytes, and perform path separator conversion if needed.\n+    fn read_path_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, Cow<'a, Path>>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        let this = self.eval_context_ref();\n+        let os_str = this.read_os_str_from_c_str(scalar)?;\n+\n+        #[cfg(windows)]\n+        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows-on-Windows, all fine.\n+            Cow::Borrowed(Path::new(os_str))\n+        } else {\n+            // Unix target, Windows host. Need to convert target '/' to host '\\'.\n+            let converted = os_str\n+                .encode_wide()\n+                .map(|wchar| if wchar == '/' as u16 { '\\\\' as u16 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(PathBuf::from(OsString::from_wide(&converted)))\n+        });\n+        #[cfg(unix)]\n+        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows target, Unix host. Need to convert target '\\' to host '/'.\n+            let converted = os_str\n+                .as_bytes()\n+                .iter()\n+                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(PathBuf::from(OsString::from_vec(converted)))\n+        } else {\n+            // Unix-on-Unix, all is fine.\n+            Cow::Borrowed(Path::new(os_str))\n+        });\n+    }\n+\n+    /// Write a Path to the machine memory, adjusting path separators if needed.\n+    fn write_path_to_c_str(\n+        &mut self,\n+        path: &Path,\n+        scalar: Scalar<Tag>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        let this = self.eval_context_mut();\n+\n+        #[cfg(windows)]\n+        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows-on-Windows, all fine.\n+            Cow::Borrowed(path.as_os_str())\n+        } else {\n+            // Unix target, Windows host. Need to convert host '\\\\' to target '/'.\n+            let converted = path\n+                .as_os_str()\n+                .encode_wide()\n+                .map(|wchar| if wchar == '\\\\' as u16 { '/' as u16 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(OsString::from_wide(&converted))\n+        };\n+        #[cfg(unix)]\n+        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows target, Unix host. Need to convert host '/' to target '\\'.\n+            let converted = path\n+                .as_os_str()\n+                .as_bytes()\n+                .iter()\n+                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(OsString::from_vec(converted))\n+        } else {\n+            // Unix-on-Unix, all is fine.\n+            Cow::Borrowed(path.as_os_str())\n+        };\n+\n+        this.write_os_str_to_c_str(&os_str, scalar, size)\n+    }\n+}"}]}