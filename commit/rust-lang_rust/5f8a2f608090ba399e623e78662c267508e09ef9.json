{"sha": "5f8a2f608090ba399e623e78662c267508e09ef9", "node_id": "C_kwDOAAsO6NoAKDVmOGEyZjYwODA5MGJhMzk5ZTYyM2U3ODY2MmMyNjc1MDhlMDllZjk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-05-05T13:43:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-05T13:43:05Z"}, "message": "Rollup merge of #96673 - oli-obk:tait_impl_diagnostic, r=petrochenkov\n\nReport that opaque types are not allowed in impls even in the presence of other errors\n\nfixes  #96569\n\nbefore this PR those useful errors were hidden because either `unused parameter` or `only traits defined in the current crate can be implemented for arbitrary types` got emitted first.", "tree": {"sha": "d2759b3da5802446298f82f50f168ccc27dc153f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2759b3da5802446298f82f50f168ccc27dc153f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f8a2f608090ba399e623e78662c267508e09ef9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJic9RpCRBK7hj4Ov3rIwAAADUIALCGp62l6IarjK86+eMAXwaN\nsh10YrC6hkUp6vIiQC4DNOgYlg4dubEBz+odG0iaHIe6GPm/A5a0qxFO0efINnjj\n9hYSMEPNSm8ICH0qECsflQH5g/mf85BxY6T/oyh9WMeHDCA0t45yWCjj+J+sXWuT\n8RLpv5G/zJXYKl5Dtpa+kAqvGizci1o9gnImWoiOtdxAnqTdfhHXpdjpf336R4tJ\n9i6IrBim7Nc7DaAuz7c7dLXP57Jy0epyfBkFcyOoRf6EndVf865NLk2DqObOalIb\nlE3WUzzqPd5GDm1wJwjEUz1zxtcP6clr7c7yCCvdxK5oBtEHW1XFGjQim7U78oQ=\n=k5sQ\n-----END PGP SIGNATURE-----\n", "payload": "tree d2759b3da5802446298f82f50f168ccc27dc153f\nparent 9520641e2a4a82ca4111b196d19a0a5695832ca3\nparent efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1651758185 +0200\ncommitter GitHub <noreply@github.com> 1651758185 +0200\n\nRollup merge of #96673 - oli-obk:tait_impl_diagnostic, r=petrochenkov\n\nReport that opaque types are not allowed in impls even in the presence of other errors\n\nfixes  #96569\n\nbefore this PR those useful errors were hidden because either `unused parameter` or `only traits defined in the current crate can be implemented for arbitrary types` got emitted first.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f8a2f608090ba399e623e78662c267508e09ef9", "html_url": "https://github.com/rust-lang/rust/commit/5f8a2f608090ba399e623e78662c267508e09ef9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f8a2f608090ba399e623e78662c267508e09ef9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9520641e2a4a82ca4111b196d19a0a5695832ca3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9520641e2a4a82ca4111b196d19a0a5695832ca3", "html_url": "https://github.com/rust-lang/rust/commit/9520641e2a4a82ca4111b196d19a0a5695832ca3"}, {"sha": "efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9", "html_url": "https://github.com/rust-lang/rust/commit/efc6a6f1bd2a70d1eb278644128cb85b8ef7a3b9"}], "stats": {"total": 122, "additions": 64, "deletions": 58}, "files": [{"sha": "f57986a985cdea63face6a3d361ba95a0abd0663", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5f8a2f608090ba399e623e78662c267508e09ef9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f8a2f608090ba399e623e78662c267508e09ef9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=5f8a2f608090ba399e623e78662c267508e09ef9", "patch": "@@ -44,6 +44,59 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n     };\n     let sp = tcx.sess.source_map().guess_head_span(item.span);\n     let tr = impl_.of_trait.as_ref().unwrap();\n+\n+    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n+    // and #84660 where it would otherwise allow unsoundness.\n+    if trait_ref.has_opaque_types() {\n+        trace!(\"{:#?}\", item);\n+        // First we find the opaque type in question.\n+        for ty in trait_ref.substs {\n+            for ty in ty.walk() {\n+                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n+                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n+                trace!(?def_id);\n+\n+                // Then we search for mentions of the opaque type's type alias in the HIR\n+                struct SpanFinder<'tcx> {\n+                    sp: Span,\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n+                    #[instrument(level = \"trace\", skip(self, _id))]\n+                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n+                        // You can't mention an opaque type directly, so we look for type aliases\n+                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n+                            // And check if that type alias's type contains the opaque type we're looking for\n+                            for arg in self.tcx.type_of(def_id).walk() {\n+                                if let GenericArgKind::Type(ty) = arg.unpack() {\n+                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n+                                        if def_id == self.def_id {\n+                                            // Finally we update the span to the mention of the type alias\n+                                            self.sp = path.span;\n+                                            return;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        hir::intravisit::walk_path(self, path)\n+                    }\n+                }\n+\n+                let mut visitor = SpanFinder { sp, def_id, tcx };\n+                hir::intravisit::walk_item(&mut visitor, item);\n+                let reported = tcx\n+                    .sess\n+                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n+                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n+                    .emit();\n+                return Err(reported);\n+            }\n+        }\n+        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n+    }\n+\n     match traits::orphan_check(tcx, item.def_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error(\n@@ -143,58 +196,6 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n         }\n     }\n \n-    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n-    // and #84660 where it would otherwise allow unsoundness.\n-    if trait_ref.has_opaque_types() {\n-        trace!(\"{:#?}\", item);\n-        // First we find the opaque type in question.\n-        for ty in trait_ref.substs {\n-            for ty in ty.walk() {\n-                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n-                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n-                trace!(?def_id);\n-\n-                // Then we search for mentions of the opaque type's type alias in the HIR\n-                struct SpanFinder<'tcx> {\n-                    sp: Span,\n-                    def_id: DefId,\n-                    tcx: TyCtxt<'tcx>,\n-                }\n-                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n-                    #[instrument(level = \"trace\", skip(self, _id))]\n-                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n-                        // You can't mention an opaque type directly, so we look for type aliases\n-                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n-                            // And check if that type alias's type contains the opaque type we're looking for\n-                            for arg in self.tcx.type_of(def_id).walk() {\n-                                if let GenericArgKind::Type(ty) = arg.unpack() {\n-                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n-                                        if def_id == self.def_id {\n-                                            // Finally we update the span to the mention of the type alias\n-                                            self.sp = path.span;\n-                                            return;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        hir::intravisit::walk_path(self, path)\n-                    }\n-                }\n-\n-                let mut visitor = SpanFinder { sp, def_id, tcx };\n-                hir::intravisit::walk_item(&mut visitor, item);\n-                let reported = tcx\n-                    .sess\n-                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n-                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n-                    .emit();\n-                return Err(reported);\n-            }\n-        }\n-        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n-    }\n-\n     Ok(())\n }\n "}, {"sha": "6f764a952c02274041fa4ce12a26b3e65f843084", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f8a2f608090ba399e623e78662c267508e09ef9/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f8a2f608090ba399e623e78662c267508e09ef9/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=5f8a2f608090ba399e623e78662c267508e09ef9", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n+            ty::Projection(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::CONTINUE;\n             }"}, {"sha": "98ac215ad6cc53f6b7a280eb71df97f57e35cffd", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f8a2f608090ba399e623e78662c267508e09ef9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f8a2f608090ba399e623e78662c267508e09ef9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=5f8a2f608090ba399e623e78662c267508e09ef9", "patch": "@@ -12,6 +12,6 @@ fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n }\n \n impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-//~^ ERROR the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+//~^ ERROR cannot implement trait on type alias impl trait\n \n fn main() {}"}, {"sha": "3ce25d94f6e124b832d7d0e97a697f083b351831", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f8a2f608090ba399e623e78662c267508e09ef9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f8a2f608090ba399e623e78662c267508e09ef9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=5f8a2f608090ba399e623e78662c267508e09ef9", "patch": "@@ -1,9 +1,14 @@\n-error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n-  --> $DIR/coherence.rs:14:6\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/coherence.rs:14:41\n    |\n LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-   |      ^ unconstrained type parameter\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/coherence.rs:9:30\n+   |\n+LL | type AliasOfForeignType<T> = impl LocalTrait;\n+   |                              ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0207`."}]}