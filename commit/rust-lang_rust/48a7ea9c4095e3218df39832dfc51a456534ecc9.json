{"sha": "48a7ea9c4095e3218df39832dfc51a456534ecc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YTdlYTljNDA5NWUzMjE4ZGYzOTgzMmRmYzUxYTQ1NjUzNGVjYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-23T07:38:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-23T07:38:53Z"}, "message": "Auto merge of #47046 - Manishearth:intra-doc-links, r=eddyb,GuillaumeGomez,QuietMisdreavus,Manishearth\n\nImplement RFC 1946 - intra-rustdoc links\n\nhttps://github.com/rust-lang/rfcs/pull/1946 https://github.com/rust-lang/rust/issues/43466\n\nNote for reviewers: The plain line counts are a little inflated because of how the markdown link parsing was done. [Read the file diff with \"whitespace only\" changes removed](https://github.com/rust-lang/rust/pull/47046/files?w=1) to get a better view of what actually changed there.\n\nThis pulls the name/path resolution mechanisms out of the compiler and runs it on the markdown in a crate's docs, so that links can be made to `SomeStruct` directly rather than finding the folder path to `struct.SomeStruct.html`. Check the `src/test/rustdoc/intra-paths.rs` test in this PR for a demo. The change was... a little invasive, but unlocks a really powerful mechanism for writing documentation that doesn't care about where an item was written to on the hard disk.\n\nItems included:\n\n - [x] Make work with the hoedown renderer\n - [x] Handle relative paths\n - [x] Parse out the \"path ambiguities\" qualifiers (`[crate foo]`, `[struct Foo]`, `[foo()]`, `[static FOO]`, `[foo!]`, etc)\n - [x] Resolve foreign macros\n - [x] Resolve local macros\n - [x] Handle the use of inner/outer attributes giving different resolution scopes (handling for non-modules pushed to different PR)\n\nItems not included:\n\n - [ ] Make sure cross-crate inlining works (blocked on refactor described in https://github.com/rust-lang/rust/pull/47046#issuecomment-354824520)\n - [ ] Implied Shortcut Reference Links (where just doing `[::std::iter::Iterator][]` without a reference anchor will resolve using the reference name rather than the link target) (requires modifying the markdown parser - blocked on Hoedown/Pulldown switch and https://github.com/google/pulldown-cmark/issues/121)\n - [ ] Handle enum variants and UFCS methods (Enum variants link to the enum page, associated methods don't link at all)\n - [ ] Emit more warnings/errors when things fail to resolve (linking to a value-namespaced item without a qualifier will emit an error, otherwise the link is just treated as a url, not a rust path)\n - [ ] Give better spans for resolution errors (currently the span for the first doc comment is used)\n - [ ] Check for inner doc comments on things that aren't modules\n\nI'm making the PR, but it should be noted that most of the work was done by Misdreavus :smile:\n\n(Editor's note: This has become a lie, check that commit log, Manish did a ton of work after this PR was opened `>_>`)", "tree": {"sha": "f9b180716e6551ea716040850288b68bea67294f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9b180716e6551ea716040850288b68bea67294f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48a7ea9c4095e3218df39832dfc51a456534ecc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48a7ea9c4095e3218df39832dfc51a456534ecc9", "html_url": "https://github.com/rust-lang/rust/commit/48a7ea9c4095e3218df39832dfc51a456534ecc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48a7ea9c4095e3218df39832dfc51a456534ecc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47a8eb7c4e24b61a8a9ab4eaff60ef65291aaa56", "url": "https://api.github.com/repos/rust-lang/rust/commits/47a8eb7c4e24b61a8a9ab4eaff60ef65291aaa56", "html_url": "https://github.com/rust-lang/rust/commit/47a8eb7c4e24b61a8a9ab4eaff60ef65291aaa56"}, {"sha": "63811b66f676c1971b15452946bad35223b8c403", "url": "https://api.github.com/repos/rust-lang/rust/commits/63811b66f676c1971b15452946bad35223b8c403", "html_url": "https://github.com/rust-lang/rust/commit/63811b66f676c1971b15452946bad35223b8c403"}], "stats": {"total": 1259, "additions": 995, "deletions": 264}, "files": [{"sha": "a87f2747a57f513f57391851c5a09411287cb32c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -151,6 +151,11 @@ pub trait Resolver {\n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n+\n+    /// Given suffix [\"b\",\"c\",\"d\"], creates a HIR path for `[::crate_root]::b::c::d` and resolves\n+    /// it based on `is_value`.\n+    fn resolve_str_path(&mut self, span: Span, crate_root: Option<&str>,\n+                components: &[&str], is_value: bool) -> hir::Path;\n }\n \n #[derive(Clone, Copy, Debug)]\n@@ -3625,16 +3630,7 @@ impl<'a> LoweringContext<'a> {\n     /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n     /// The path is also resolved according to `is_value`.\n     fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n-        let mut path = hir::Path {\n-            span,\n-            def: Def::Err,\n-            segments: iter::once(keywords::CrateRoot.name()).chain({\n-                self.crate_root.into_iter().chain(components.iter().cloned()).map(Symbol::intern)\n-            }).map(hir::PathSegment::from_name).collect(),\n-        };\n-\n-        self.resolver.resolve_hir_path(&mut path, is_value);\n-        path\n+        self.resolver.resolve_str_path(span, self.crate_root, components, is_value)\n     }\n \n     fn signal_block_expr(&mut self,"}, {"sha": "b2897bd454839cf77ff1f8aaf8334dcd9b2601b7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -28,7 +28,7 @@ use rustc::util::common::{ErrorReported, time};\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental;\n-use rustc_resolve::{MakeGlobMap, Resolver};\n+use rustc_resolve::{MakeGlobMap, Resolver, ResolverArenas};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n use rustc_trans_utils::trans_crate::TransCrate;\n@@ -139,6 +139,7 @@ pub fn compile_input(trans: Box<TransCrate>,\n \n         let crate_name =\n             ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n+\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n             phase_2_configure_and_expand(\n                 sess,\n@@ -562,6 +563,12 @@ pub struct ExpansionResult {\n     pub hir_forest: hir_map::Forest,\n }\n \n+pub struct InnerExpansionResult<'a> {\n+    pub expanded_crate: ast::Crate,\n+    pub resolver: Resolver<'a>,\n+    pub hir_forest: hir_map::Forest,\n+}\n+\n /// Run the \"early phases\" of the compiler: initial `cfg` processing,\n /// loading compiler plugins (including those from `addl_plugins`),\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n@@ -578,6 +585,55 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n                                        make_glob_map: MakeGlobMap,\n                                        after_expand: F)\n                                        -> Result<ExpansionResult, CompileIncomplete>\n+    where F: FnOnce(&ast::Crate) -> CompileResult {\n+    // Currently, we ignore the name resolution data structures for the purposes of dependency\n+    // tracking. Instead we will run name resolution and include its output in the hash of each\n+    // item, much like we do for macro expansion. In other words, the hash reflects not just\n+    // its contents but the results of name resolution on those contents. Hopefully we'll push\n+    // this back at some point.\n+    let mut crate_loader = CrateLoader::new(sess, &cstore, &crate_name);\n+    let resolver_arenas = Resolver::arenas();\n+    let result = phase_2_configure_and_expand_inner(sess, cstore, krate, registry, crate_name,\n+                                                    addl_plugins, make_glob_map, &resolver_arenas,\n+                                                    &mut crate_loader, after_expand);\n+    match result {\n+        Ok(InnerExpansionResult {expanded_crate, resolver, hir_forest}) => {\n+            Ok(ExpansionResult {\n+                expanded_crate,\n+                defs: resolver.definitions,\n+                hir_forest,\n+                resolutions: Resolutions {\n+                    freevars: resolver.freevars,\n+                    export_map: resolver.export_map,\n+                    trait_map: resolver.trait_map,\n+                    maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n+                    maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n+                },\n+\n+                analysis: ty::CrateAnalysis {\n+                    access_levels: Rc::new(AccessLevels::default()),\n+                    name: crate_name.to_string(),\n+                    glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n+                },\n+            })\n+        }\n+        Err(x) => Err(x)\n+    }\n+}\n+\n+/// Same as phase_2_configure_and_expand, but doesn't let you keep the resolver\n+/// around\n+pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n+                                       cstore: &'a CStore,\n+                                       krate: ast::Crate,\n+                                       registry: Option<Registry>,\n+                                       crate_name: &str,\n+                                       addl_plugins: Option<Vec<String>>,\n+                                       make_glob_map: MakeGlobMap,\n+                                       resolver_arenas: &'a ResolverArenas<'a>,\n+                                       crate_loader: &'a mut CrateLoader,\n+                                       after_expand: F)\n+                                       -> Result<InnerExpansionResult<'a>, CompileIncomplete>\n     where F: FnOnce(&ast::Crate) -> CompileResult,\n {\n     let time_passes = sess.time_passes();\n@@ -666,19 +722,12 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         return Err(CompileIncomplete::Stopped);\n     }\n \n-    // Currently, we ignore the name resolution data structures for the purposes of dependency\n-    // tracking. Instead we will run name resolution and include its output in the hash of each\n-    // item, much like we do for macro expansion. In other words, the hash reflects not just\n-    // its contents but the results of name resolution on those contents. Hopefully we'll push\n-    // this back at some point.\n-    let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n-    let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess,\n                                      cstore,\n                                      &krate,\n                                      crate_name,\n                                      make_glob_map,\n-                                     &mut crate_loader,\n+                                     crate_loader,\n                                      &resolver_arenas);\n     resolver.whitelisted_legacy_custom_derives = whitelisted_legacy_custom_derives;\n     syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n@@ -855,21 +904,9 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         syntax::ext::hygiene::clear_markings();\n     }\n \n-    Ok(ExpansionResult {\n+    Ok(InnerExpansionResult {\n         expanded_crate: krate,\n-        defs: resolver.definitions,\n-        analysis: ty::CrateAnalysis {\n-            access_levels: Rc::new(AccessLevels::default()),\n-            name: crate_name.to_string(),\n-            glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n-        },\n-        resolutions: Resolutions {\n-            freevars: resolver.freevars,\n-            export_map: resolver.export_map,\n-            trait_map: resolver.trait_map,\n-            maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-            maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n-        },\n+        resolver,\n         hir_forest,\n     })\n }"}, {"sha": "55c7e5f392416b23be900a5ccd9bf6388b3929f2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -67,6 +67,7 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::collections::BTreeSet;\n use std::fmt;\n+use std::iter;\n use std::mem::replace;\n use std::rc::Rc;\n \n@@ -1320,6 +1321,7 @@ pub struct Resolver<'a> {\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Ident>,\n     global_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    pub all_macros: FxHashMap<Name, Def>,\n     lexical_macro_resolutions: Vec<(Ident, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n@@ -1407,6 +1409,71 @@ impl<'a, 'b: 'a> ty::DefIdTree for &'a Resolver<'b> {\n \n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n+        self.resolve_hir_path_cb(path, is_value,\n+                                 |resolver, span, error| resolve_error(resolver, span, error))\n+    }\n+\n+    fn resolve_str_path(&mut self, span: Span, crate_root: Option<&str>,\n+                        components: &[&str], is_value: bool) -> hir::Path {\n+        let mut path = hir::Path {\n+            span,\n+            def: Def::Err,\n+            segments: iter::once(keywords::CrateRoot.name()).chain({\n+                crate_root.into_iter().chain(components.iter().cloned()).map(Symbol::intern)\n+            }).map(hir::PathSegment::from_name).collect(),\n+        };\n+\n+        self.resolve_hir_path(&mut path, is_value);\n+        path\n+    }\n+\n+    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n+        self.def_map.get(&id).cloned()\n+    }\n+\n+    fn definitions(&mut self) -> &mut Definitions {\n+        &mut self.definitions\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    /// Rustdoc uses this to resolve things in a recoverable way. ResolutionError<'a>\n+    /// isn't something that can be returned because it can't be made to live that long,\n+    /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n+    /// just that an error occured.\n+    pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool)\n+        -> Result<hir::Path, ()> {\n+        use std::iter;\n+        let mut errored = false;\n+\n+        let mut path = if path_str.starts_with(\"::\") {\n+            hir::Path {\n+                span,\n+                def: Def::Err,\n+                segments: iter::once(keywords::CrateRoot.name()).chain({\n+                    path_str.split(\"::\").skip(1).map(Symbol::intern)\n+                }).map(hir::PathSegment::from_name).collect(),\n+            }\n+        } else {\n+            hir::Path {\n+                span,\n+                def: Def::Err,\n+                segments: path_str.split(\"::\").map(Symbol::intern)\n+                                  .map(hir::PathSegment::from_name).collect(),\n+            }\n+        };\n+        self.resolve_hir_path_cb(&mut path, is_value, |_, _, _| errored = true);\n+        if errored || path.def == Def::Err {\n+            Err(())\n+        } else {\n+            Ok(path)\n+        }\n+    }\n+\n+    /// resolve_hir_path, but takes a callback in case there was an error\n+    fn resolve_hir_path_cb<F>(&mut self, path: &mut hir::Path, is_value: bool, error_callback: F)\n+            where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n+        {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n         let path: Vec<SpannedIdent> = segments.iter()\n@@ -1418,24 +1485,16 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n                 *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span) {\n                 PathResult::Failed(span, msg, _) => {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                    error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 _ => {}\n             },\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n             }\n         }\n     }\n-\n-    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n-        self.def_map.get(&id).cloned()\n-    }\n-\n-    fn definitions(&mut self) -> &mut Definitions {\n-        &mut self.definitions\n-    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1538,6 +1597,7 @@ impl<'a> Resolver<'a> {\n             crate_loader,\n             macro_names: FxHashSet(),\n             global_macros: FxHashMap(),\n+            all_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n             macro_map: FxHashMap(),\n             macro_exports: Vec::new(),\n@@ -1833,8 +1893,8 @@ impl<'a> Resolver<'a> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope<F>(&mut self, id: NodeId, f: F)\n-        where F: FnOnce(&mut Resolver)\n+    pub fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut Resolver) -> T\n     {\n         let id = self.definitions.local_def_id(id);\n         let module = self.module_map.get(&id).cloned(); // clones a reference\n@@ -1845,13 +1905,14 @@ impl<'a> Resolver<'a> {\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n             self.finalize_current_module_macro_resolutions();\n-            f(self);\n+            let ret = f(self);\n \n             self.current_module = orig_module;\n             self.ribs[ValueNS].pop();\n             self.ribs[TypeNS].pop();\n+            ret\n         } else {\n-            f(self);\n+            f(self)\n         }\n     }\n "}, {"sha": "080ef3252a633098a5530f26471806421fce9532", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -409,7 +409,7 @@ impl<'a> Resolver<'a> {\n         def\n     }\n \n-    fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path,\n+    pub fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path,\n                                   kind: MacroKind, force: bool)\n                                   -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n@@ -755,8 +755,9 @@ impl<'a> Resolver<'a> {\n             *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n                 parent: Cell::new(*legacy_scope), ident: ident, def_id: def_id, span: item.span,\n             }));\n+            let def = Def::Macro(def_id, MacroKind::Bang);\n+            self.all_macros.insert(ident.name, def);\n             if attr::contains_name(&item.attrs, \"macro_export\") {\n-                let def = Def::Macro(def_id, MacroKind::Bang);\n                 self.macro_exports.push(Export {\n                     ident: ident.modern(),\n                     def: def,"}, {"sha": "e4e3cc2acd5efc7e84832ba9a0c7c0ac8d3af11a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -135,7 +135,11 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n             None\n         }\n     });\n-    let fqn = once(crate_name).chain(relative).collect();\n+    let fqn = if let clean::TypeKind::Macro = kind {\n+        vec![crate_name, relative.last().unwrap()]\n+    } else {\n+        once(crate_name).chain(relative).collect()\n+    };\n     cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n }\n "}, {"sha": "fb1d21d6527af87296a59bf4ce0b527aaa1f7422", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 283, "deletions": 4, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -20,9 +20,10 @@ pub use self::FunctionRetTy::*;\n pub use self::Visibility::*;\n \n use syntax::abi::Abi;\n-use syntax::ast;\n+use syntax::ast::{self, AttrStyle};\n use syntax::attr;\n use syntax::codemap::Spanned;\n+use syntax::feature_gate::UnstableFeatures;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n@@ -53,6 +54,7 @@ use core::DocContext;\n use doctree;\n use visit_ast;\n use html::item_type::ItemType;\n+use html::markdown::markdown_links;\n \n pub mod inline;\n pub mod cfg;\n@@ -124,7 +126,7 @@ pub struct Crate {\n     pub masked_crates: FxHashSet<CrateNum>,\n }\n \n-impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'rcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx, 'rcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n         use ::visit_lib::LibEmbargoVisitor;\n \n@@ -305,6 +307,11 @@ impl Item {\n     pub fn collapsed_doc_value(&self) -> Option<String> {\n         self.attrs.collapsed_doc_value()\n     }\n+\n+    pub fn links(&self) -> Vec<(String, String)> {\n+        self.attrs.links()\n+    }\n+\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n             StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n@@ -465,6 +472,23 @@ impl Clean<Item> for doctree::Module {\n             \"\".to_string()\n         };\n \n+        // maintain a stack of mod ids, for doc comment path resolution\n+        // but we also need to resolve the module's own docs based on whether its docs were written\n+        // inside or outside the module, so check for that\n+        let attrs = if self.attrs.iter()\n+                                 .filter(|a| a.check_name(\"doc\"))\n+                                 .next()\n+                                 .map_or(true, |a| a.style == AttrStyle::Inner) {\n+            // inner doc comment, use the module's own scope for resolution\n+            cx.mod_ids.borrow_mut().push(self.id);\n+            self.attrs.clean(cx)\n+        } else {\n+            // outer doc comment, use its parent's scope\n+            let attrs = self.attrs.clean(cx);\n+            cx.mod_ids.borrow_mut().push(self.id);\n+            attrs\n+        };\n+\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n@@ -481,6 +505,8 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n \n+        cx.mod_ids.borrow_mut().pop();\n+\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n@@ -498,7 +524,7 @@ impl Clean<Item> for doctree::Module {\n \n         Item {\n             name: Some(name),\n-            attrs: self.attrs.clean(cx),\n+            attrs,\n             source: whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n@@ -633,6 +659,7 @@ pub struct Attributes {\n     pub other_attrs: Vec<ast::Attribute>,\n     pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n+    pub links: Vec<(String, DefId)>,\n }\n \n impl Attributes {\n@@ -762,11 +789,13 @@ impl Attributes {\n                 Some(attr.clone())\n             })\n         }).collect();\n+\n         Attributes {\n             doc_strings,\n             other_attrs,\n             cfg: if cfg == Cfg::True { None } else { Some(Rc::new(cfg)) },\n             span: sp,\n+            links: vec![],\n         }\n     }\n \n@@ -785,6 +814,20 @@ impl Attributes {\n             None\n         }\n     }\n+\n+    /// Get links as a vector\n+    ///\n+    /// Cache must be populated before call\n+    pub fn links(&self) -> Vec<(String, String)> {\n+        use html::format::href;\n+        self.links.iter().filter_map(|&(ref s, did)| {\n+            if let Some((href, ..)) = href(did) {\n+                Some((s.clone(), href))\n+            } else {\n+                None\n+            }\n+        }).collect()\n+    }\n }\n \n impl AttributesExt for Attributes {\n@@ -793,9 +836,243 @@ impl AttributesExt for Attributes {\n     }\n }\n \n+/// Given a def, returns its name and disambiguator\n+/// for a value namespace\n+///\n+/// Returns None for things which cannot be ambiguous since\n+/// they exist in both namespaces (structs and modules)\n+fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n+    match def {\n+        // structs and mods exist in both namespaces. skip them\n+        Def::StructCtor(..) | Def::Mod(..) => None,\n+        Def::Variant(..) | Def::VariantCtor(..)\n+            => Some((\"variant\", format!(\"{}()\", path_str))),\n+        Def::Fn(..)\n+            => Some((\"function\", format!(\"{}()\", path_str))),\n+        Def::Method(..)\n+            => Some((\"method\", format!(\"{}()\", path_str))),\n+        Def::Const(..)\n+            => Some((\"const\", format!(\"const@{}\", path_str))),\n+        Def::Static(..)\n+            => Some((\"static\", format!(\"static@{}\", path_str))),\n+        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n+    }\n+}\n+\n+/// Given a def, returns its name, the article to be used, and a disambiguator\n+/// for the type namespace\n+fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n+    let (kind, article) = match def {\n+        // we can still have non-tuple structs\n+        Def::Struct(..) => (\"struct\", \"a\"),\n+        Def::Enum(..) => (\"enum\", \"an\"),\n+        Def::Trait(..) => (\"trait\", \"a\"),\n+        Def::Union(..) => (\"union\", \"a\"),\n+        _ => (\"type\", \"a\"),\n+    };\n+    (kind, article, format!(\"{}@{}\", kind, path_str))\n+}\n+\n+fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n+                   path_str: &str,\n+                   article1: &str, kind1: &str, disambig1: &str,\n+                   article2: &str, kind2: &str, disambig2: &str) {\n+    let sp = attrs.doc_strings.first()\n+                  .map_or(DUMMY_SP, |a| a.span());\n+    cx.sess()\n+      .struct_span_err(sp,\n+                       &format!(\"`{}` is both {} {} and {} {}\",\n+                                path_str, article1, kind1,\n+                                article2, kind2))\n+      .help(&format!(\"try `{}` if you want to select the {}, \\\n+                      or `{}` if you want to \\\n+                      select the {}\",\n+                      disambig1, kind1, disambig2,\n+                      kind2))\n+             .emit();\n+}\n+\n+/// Resolve a given string as a path, along with whether or not it is\n+/// in the value namespace\n+fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<hir::Path, ()> {\n+    // In case we're in a module, try to resolve the relative\n+    // path\n+    if let Some(id) = cx.mod_ids.borrow().last() {\n+        cx.resolver.borrow_mut()\n+                   .with_scope(*id, |resolver| {\n+                        resolver.resolve_str_path_error(DUMMY_SP,\n+                                                        &path_str, is_val)\n+                    })\n+    } else {\n+        // FIXME(Manishearth) this branch doesn't seem to ever be hit, really\n+        cx.resolver.borrow_mut()\n+                   .resolve_str_path_error(DUMMY_SP, &path_str, is_val)\n+    }\n+}\n+\n+/// Resolve a string as a macro\n+fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n+    use syntax::ext::base::MacroKind;\n+    use syntax::ext::hygiene::Mark;\n+    let segment = ast::PathSegment {\n+        identifier: ast::Ident::from_str(path_str),\n+        span: DUMMY_SP,\n+        parameters: None,\n+    };\n+    let path = ast::Path {\n+        span: DUMMY_SP,\n+        segments: vec![segment],\n+    };\n+\n+    let mut resolver = cx.resolver.borrow_mut();\n+    let mark = Mark::root();\n+    let res = resolver\n+        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n+    if let Ok(def) = res {\n+        Some(def)\n+    } else if let Some(def) = resolver.all_macros.get(&path_str.into()) {\n+        Some(*def)\n+    } else {\n+        None\n+    }\n+}\n+\n+enum PathKind {\n+    /// can be either value or type, not a macro\n+    Unknown,\n+    /// macro\n+    Macro,\n+    /// values, functions, consts, statics, everything in the value namespace\n+    Value,\n+    /// types, traits, everything in the type namespace\n+    Type\n+}\n+\n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext) -> Attributes {\n-        Attributes::from_ast(cx.sess().diagnostic(), self)\n+        let mut attrs = Attributes::from_ast(cx.sess().diagnostic(), self);\n+\n+        if UnstableFeatures::from_environment().is_nightly_build() {\n+            let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n+            for link in markdown_links(&dox, cx.render_type) {\n+                let def = {\n+                    let mut kind = PathKind::Unknown;\n+                    let path_str = if let Some(prefix) =\n+                        [\"struct@\", \"enum@\", \"type@\",\n+                         \"trait@\", \"union@\"].iter()\n+                                          .find(|p| link.starts_with(**p)) {\n+                        kind = PathKind::Type;\n+                        link.trim_left_matches(prefix)\n+                    } else if let Some(prefix) =\n+                        [\"const@\", \"static@\",\n+                         \"value@\", \"function@\", \"mod@\", \"fn@\", \"module@\"]\n+                            .iter().find(|p| link.starts_with(**p)) {\n+                        kind = PathKind::Value;\n+                        link.trim_left_matches(prefix)\n+                    } else if link.ends_with(\"()\") {\n+                        kind = PathKind::Value;\n+                        link.trim_right_matches(\"()\")\n+                    } else if link.starts_with(\"macro@\") {\n+                        kind = PathKind::Macro;\n+                        link.trim_left_matches(\"macro@\")\n+                    } else if link.ends_with('!') {\n+                        kind = PathKind::Macro;\n+                        link.trim_right_matches('!')\n+                    } else {\n+                        &link[..]\n+                    }.trim();\n+\n+                    // avoid resolving things (i.e. regular links) which aren't like paths\n+                    // FIXME(Manishearth) given that most links have slashes in them might be worth\n+                    // doing a check for slashes first\n+                    if path_str.contains(|ch: char| !(ch.is_alphanumeric() ||\n+                                                      ch == ':' || ch == '_')) {\n+                        continue;\n+                    }\n+\n+\n+                    match kind {\n+                        PathKind::Value => {\n+                            if let Ok(path) = resolve(cx, path_str, true) {\n+                                path.def\n+                            } else {\n+                                // this could just be a normal link or a broken link\n+                                // we could potentially check if something is\n+                                // \"intra-doc-link-like\" and warn in that case\n+                                continue;\n+                            }\n+                        }\n+                        PathKind::Type => {\n+                            if let Ok(path) = resolve(cx, path_str, false) {\n+                                path.def\n+                            } else {\n+                                // this could just be a normal link\n+                                continue;\n+                            }\n+                        }\n+                        PathKind::Unknown => {\n+                            // try everything!\n+                            if let Some(macro_def) = macro_resolve(cx, path_str) {\n+                                if let Ok(type_path) = resolve(cx, path_str, false) {\n+                                    let (type_kind, article, type_disambig)\n+                                        = type_ns_kind(type_path.def, path_str);\n+                                    ambiguity_error(cx, &attrs, path_str,\n+                                                    article, type_kind, &type_disambig,\n+                                                    \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n+                                    continue;\n+                                } else if let Ok(value_path) = resolve(cx, path_str, true) {\n+                                    let (value_kind, value_disambig)\n+                                        = value_ns_kind(value_path.def, path_str)\n+                                            .expect(\"struct and mod cases should have been \\\n+                                                     caught in previous branch\");\n+                                    ambiguity_error(cx, &attrs, path_str,\n+                                                    \"a\", value_kind, &value_disambig,\n+                                                    \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n+                                }\n+                                macro_def\n+                            } else if let Ok(type_path) = resolve(cx, path_str, false) {\n+                                // It is imperative we search for not-a-value first\n+                                // Otherwise we will find struct ctors for when we are looking\n+                                // for structs, and the link won't work.\n+                                // if there is something in both namespaces\n+                                if let Ok(value_path) = resolve(cx, path_str, true) {\n+                                    let kind = value_ns_kind(value_path.def, path_str);\n+                                    if let Some((value_kind, value_disambig)) = kind {\n+                                        let (type_kind, article, type_disambig)\n+                                            = type_ns_kind(type_path.def, path_str);\n+                                        ambiguity_error(cx, &attrs, path_str,\n+                                                        article, type_kind, &type_disambig,\n+                                                        \"a\", value_kind, &value_disambig);\n+                                        continue;\n+                                    }\n+                                }\n+                                type_path.def\n+                            } else if let Ok(value_path) = resolve(cx, path_str, true) {\n+                                value_path.def\n+                            } else {\n+                                // this could just be a normal link\n+                                continue;\n+                            }\n+                        }\n+                        PathKind::Macro => {\n+                            if let Some(def) = macro_resolve(cx, path_str) {\n+                                def\n+                            } else {\n+                                continue\n+                            }\n+                        }\n+                    }\n+                };\n+\n+\n+                let id = register_def(cx, def);\n+                attrs.links.push((link, id));\n+            }\n+\n+            cx.sess().abort_if_errors();\n+        }\n+\n+        attrs\n     }\n }\n \n@@ -1853,6 +2130,7 @@ pub enum TypeKind {\n     Variant,\n     Typedef,\n     Foreign,\n+    Macro,\n }\n \n pub trait GetDefId {\n@@ -3154,6 +3432,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::TyForeign(i) => (i, TypeKind::Foreign),\n         Def::Static(i, _) => (i, TypeKind::Static),\n         Def::Variant(i) => (cx.tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n+        Def::Macro(i, _) => (i, TypeKind::Macro),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id"}, {"sha": "5fe4794389ff5a7cfe59a9d4f44cceb84fdf50d5", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -20,8 +20,10 @@ use rustc::lint;\n use rustc::util::nodemap::FxHashMap;\n use rustc_trans;\n use rustc_resolve as resolve;\n+use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n+use syntax::ast::NodeId;\n use syntax::codemap;\n use syntax::feature_gate::UnstableFeatures;\n use errors;\n@@ -35,15 +37,19 @@ use std::path::PathBuf;\n use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n+use html::markdown::RenderType;\n use html::render::RenderInfo;\n \n pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n \n pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n-pub struct DocContext<'a, 'tcx: 'a> {\n+pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub resolver: &'a RefCell<resolve::Resolver<'rcx>>,\n+    /// The stack of module NodeIds up till this point\n+    pub mod_ids: RefCell<Vec<NodeId>>,\n     pub populated_all_crate_impls: Cell<bool>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -54,6 +60,8 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n     pub external_traits: RefCell<FxHashMap<DefId, clean::Trait>>,\n+    /// Which markdown renderer to use when extracting links.\n+    pub render_type: RenderType,\n \n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n@@ -64,7 +72,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n }\n \n-impl<'a, 'tcx> DocContext<'a, 'tcx> {\n+impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n     pub fn sess(&self) -> &session::Session {\n         &self.tcx.sess\n     }\n@@ -104,7 +112,8 @@ pub fn run_core(search_paths: SearchPaths,\n                 triple: Option<String>,\n                 maybe_sysroot: Option<PathBuf>,\n                 allow_warnings: bool,\n-                force_unstable_if_unmarked: bool) -> (clean::Crate, RenderInfo)\n+                force_unstable_if_unmarked: bool,\n+                render_type: RenderType) -> (clean::Crate, RenderInfo)\n {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -156,16 +165,40 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let name = ::rustc_trans_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n \n-    let driver::ExpansionResult { defs, analysis, resolutions, mut hir_forest, .. } = {\n-        let result = driver::phase_2_configure_and_expand(&sess,\n-                                                          &cstore,\n-                                                          krate,\n-                                                          None,\n-                                                          &name,\n-                                                          None,\n-                                                          resolve::MakeGlobMap::No,\n-                                                          |_| Ok(()));\n-        abort_on_err(result, &sess)\n+    let mut crate_loader = CrateLoader::new(&sess, &cstore, &name);\n+\n+    let resolver_arenas = resolve::Resolver::arenas();\n+    let result = driver::phase_2_configure_and_expand_inner(&sess,\n+                                                      &cstore,\n+                                                      krate,\n+                                                      None,\n+                                                      &name,\n+                                                      None,\n+                                                      resolve::MakeGlobMap::No,\n+                                                      &resolver_arenas,\n+                                                      &mut crate_loader,\n+                                                      |_| Ok(()));\n+    let driver::InnerExpansionResult {\n+        mut hir_forest,\n+        resolver,\n+        ..\n+    } = abort_on_err(result, &sess);\n+\n+    // We need to hold on to the complete resolver, so we clone everything\n+    // for the analysis passes to use. Suboptimal, but necessary in the\n+    // current architecture.\n+    let defs = resolver.definitions.clone();\n+    let resolutions = ty::Resolutions {\n+        freevars: resolver.freevars.clone(),\n+        export_map: resolver.export_map.clone(),\n+        trait_map: resolver.trait_map.clone(),\n+        maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n+        maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n+    };\n+    let analysis = ty::CrateAnalysis {\n+        access_levels: Rc::new(AccessLevels::default()),\n+        name: name.to_string(),\n+        glob_map: if resolver.make_glob_map { Some(resolver.glob_map.clone()) } else { None },\n     };\n \n     let arenas = AllArenas::new();\n@@ -176,6 +209,8 @@ pub fn run_core(search_paths: SearchPaths,\n                                                           &[],\n                                                           &sess);\n \n+    let resolver = RefCell::new(resolver);\n+\n     abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n                                                      control,\n                                                      &sess,\n@@ -203,12 +238,15 @@ pub fn run_core(search_paths: SearchPaths,\n \n         let ctxt = DocContext {\n             tcx,\n+            resolver: &resolver,\n             populated_all_crate_impls: Cell::new(false),\n             access_levels: RefCell::new(access_levels),\n             external_traits: Default::default(),\n             renderinfo: Default::default(),\n+            render_type,\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n+            mod_ids: Default::default(),\n         };\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n "}, {"sha": "f7d07af04ea989191b15ca5be29c1b8a029fbbc8", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -37,15 +37,15 @@ impl ExternalHtml {\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(md_before_content)\n-                    .map(|m_bc| (ih, format!(\"{}{}\", bc, Markdown(&m_bc, render))))\n+                    .map(|m_bc| (ih, format!(\"{}{}\", bc, Markdown(&m_bc, &[], render))))\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(after_content)\n                     .map(|ac| (ih, bc, ac))\n             )\n             .and_then(|(ih, bc, ac)|\n                 load_external_files(md_after_content)\n-                    .map(|m_ac| (ih, bc, format!(\"{}{}\", ac, Markdown(&m_ac, render))))\n+                    .map(|m_ac| (ih, bc, format!(\"{}{}\", ac, Markdown(&m_ac, &[], render))))\n             )\n             .map(|(ih, bc, ac)|\n                 ExternalHtml {"}, {"sha": "e9c6488c49c6cb0f9c90ea74b268fc95b136f28e", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -102,6 +102,7 @@ impl From<clean::TypeKind> for ItemType {\n             clean::TypeKind::Variant  => ItemType::Variant,\n             clean::TypeKind::Typedef  => ItemType::Typedef,\n             clean::TypeKind::Foreign  => ItemType::ForeignType,\n+            clean::TypeKind::Macro  => ItemType::Macro,\n         }\n     }\n }"}, {"sha": "dce0c4b001a0d94b86909027ca54a3fc0bc8b2f4", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 408, "deletions": 174, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -56,15 +56,16 @@ pub enum RenderType {\n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n-// The second parameter is whether we need a shorter version or not.\n-pub struct Markdown<'a>(pub &'a str, pub RenderType);\n+/// The second parameter is a list of link replacements\n+// The third parameter is whether we need a shorter version or not.\n+pub struct Markdown<'a>(pub &'a str, pub &'a [(String, String)], pub RenderType);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n-pub struct MarkdownSummaryLine<'a>(pub &'a str);\n+pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n /// Controls whether a line will be hidden or shown in HTML output.\n ///\n@@ -247,6 +248,39 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n     }\n }\n \n+/// Make headings links with anchor ids and build up TOC.\n+struct LinkReplacer<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    links: &'b [(String, String)]\n+}\n+\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, 'b, I> {\n+    fn new(iter: I, links: &'b [(String, String)]) -> Self {\n+        LinkReplacer {\n+            inner: iter,\n+            links\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I> {\n+    type Item = Event<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let event = self.inner.next();\n+        if let Some(Event::Start(Tag::Link(dest, text))) = event {\n+            if let Some(&(_, ref replace)) = self.links.into_iter().find(|link| &*link.0 == &*dest)\n+            {\n+                Some(Event::Start(Tag::Link(replace.to_owned().into(), text)))\n+            } else {\n+                Some(Event::Start(Tag::Link(dest, text)))\n+            }\n+        } else {\n+            event\n+        }\n+    }\n+}\n+\n /// Make headings links with anchor ids and build up TOC.\n struct HeadingLinks<'a, 'b, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n@@ -527,6 +561,8 @@ struct MyOpaque {\n                            *const hoedown_buffer, *const hoedown_renderer_data,\n                            libc::size_t),\n     toc_builder: Option<TocBuilder>,\n+    links_out: Option<Vec<String>>,\n+    links_replace: Vec<(String, String)>,\n }\n \n extern {\n@@ -555,186 +591,293 @@ impl hoedown_buffer {\n     }\n }\n \n-pub fn render(w: &mut fmt::Formatter,\n-              s: &str,\n-              print_toc: bool,\n-              html_flags: libc::c_uint) -> fmt::Result {\n-    extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n-                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n-        unsafe {\n-            if orig_text.is_null() { return }\n-\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n-            let text = (*orig_text).as_bytes();\n-            let origtext = str::from_utf8(text).unwrap();\n-            let origtext = origtext.trim_left();\n-            debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n-            let mut compile_fail = false;\n-            let mut ignore = false;\n-\n-            let rendered = if lang.is_null() || origtext.is_empty() {\n-                false\n+extern fn hoedown_block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n+                        lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n+                        line: libc::size_t) {\n+    unsafe {\n+        if orig_text.is_null() { return }\n+\n+        let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n+        let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n+        let text = (*orig_text).as_bytes();\n+        let origtext = str::from_utf8(text).unwrap();\n+        let origtext = origtext.trim_left();\n+        debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n+        let mut compile_fail = false;\n+        let mut ignore = false;\n+\n+        let rendered = if lang.is_null() || origtext.is_empty() {\n+            false\n+        } else {\n+            let rlang = (*lang).as_bytes();\n+            let rlang = str::from_utf8(rlang).unwrap();\n+            let parse_result = LangString::parse(rlang);\n+            compile_fail = parse_result.compile_fail;\n+            ignore = parse_result.ignore;\n+            if !parse_result.rust {\n+                (my_opaque.dfltblk)(ob, orig_text, lang,\n+                                    opaque as *const hoedown_renderer_data,\n+                                    line);\n+                true\n             } else {\n-                let rlang = (*lang).as_bytes();\n-                let rlang = str::from_utf8(rlang).unwrap();\n-                let parse_result = LangString::parse(rlang);\n-                compile_fail = parse_result.compile_fail;\n-                ignore = parse_result.ignore;\n-                if !parse_result.rust {\n-                    (my_opaque.dfltblk)(ob, orig_text, lang,\n-                                        opaque as *const hoedown_renderer_data,\n-                                        line);\n-                    true\n+                false\n+            }\n+        };\n+\n+        let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n+        let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+        if rendered { return }\n+        PLAYGROUND.with(|play| {\n+            // insert newline to clearly separate it from the\n+            // previous block so we can shorten the html output\n+            let mut s = String::from(\"\\n\");\n+            let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n+                if url.is_empty() {\n+                    return None;\n+                }\n+                let test = origtext.lines()\n+                    .map(|l| map_line(l).for_code())\n+                    .collect::<Vec<&str>>().join(\"\\n\");\n+                let krate = krate.as_ref().map(|s| &**s);\n+                let (test, _) = test::make_test(&test, krate, false,\n+                                                &Default::default());\n+                let channel = if test.contains(\"#![feature(\") {\n+                    \"&amp;version=nightly\"\n                 } else {\n-                    false\n+                    \"\"\n+                };\n+                // These characters don't need to be escaped in a URI.\n+                // FIXME: use a library function for percent encoding.\n+                fn dont_escape(c: u8) -> bool {\n+                    (b'a' <= c && c <= b'z') ||\n+                    (b'A' <= c && c <= b'Z') ||\n+                    (b'0' <= c && c <= b'9') ||\n+                    c == b'-' || c == b'_' || c == b'.' ||\n+                    c == b'~' || c == b'!' || c == b'\\'' ||\n+                    c == b'(' || c == b')' || c == b'*'\n                 }\n-            };\n-\n-            let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n-            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            if rendered { return }\n-            PLAYGROUND.with(|play| {\n-                // insert newline to clearly separate it from the\n-                // previous block so we can shorten the html output\n-                let mut s = String::from(\"\\n\");\n-                let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n-                    if url.is_empty() {\n-                        return None;\n-                    }\n-                    let test = origtext.lines()\n-                        .map(|l| map_line(l).for_code())\n-                        .collect::<Vec<&str>>().join(\"\\n\");\n-                    let krate = krate.as_ref().map(|s| &**s);\n-                    let (test, _) = test::make_test(&test, krate, false,\n-                                               &Default::default());\n-                    let channel = if test.contains(\"#![feature(\") {\n-                        \"&amp;version=nightly\"\n+                let mut test_escaped = String::new();\n+                for b in test.bytes() {\n+                    if dont_escape(b) {\n+                        test_escaped.push(char::from(b));\n                     } else {\n-                        \"\"\n-                    };\n-                    // These characters don't need to be escaped in a URI.\n-                    // FIXME: use a library function for percent encoding.\n-                    fn dont_escape(c: u8) -> bool {\n-                        (b'a' <= c && c <= b'z') ||\n-                        (b'A' <= c && c <= b'Z') ||\n-                        (b'0' <= c && c <= b'9') ||\n-                        c == b'-' || c == b'_' || c == b'.' ||\n-                        c == b'~' || c == b'!' || c == b'\\'' ||\n-                        c == b'(' || c == b')' || c == b'*'\n-                    }\n-                    let mut test_escaped = String::new();\n-                    for b in test.bytes() {\n-                        if dont_escape(b) {\n-                            test_escaped.push(char::from(b));\n-                        } else {\n-                            write!(test_escaped, \"%{:02X}\", b).unwrap();\n-                        }\n+                        write!(test_escaped, \"%{:02X}\", b).unwrap();\n                     }\n-                    Some(format!(\n-                        r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n-                        url, test_escaped, channel\n-                    ))\n-                });\n-                let tooltip = if ignore {\n-                    Some((\"This example is not tested\", \"ignore\"))\n-                } else if compile_fail {\n-                    Some((\"This example deliberately fails to compile\", \"compile_fail\"))\n-                } else {\n-                    None\n-                };\n-                s.push_str(&highlight::render_with_highlighting(\n-                               &text,\n-                               Some(&format!(\"rust-example-rendered{}\",\n-                                             if ignore { \" ignore\" }\n-                                             else if compile_fail { \" compile_fail\" }\n-                                             else { \"\" })),\n-                               None,\n-                               playground_button.as_ref().map(String::as_str),\n-                               tooltip));\n-                hoedown_buffer_put(ob, s.as_ptr(), s.len());\n-            })\n-        }\n+                }\n+                Some(format!(\n+                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n+                    url, test_escaped, channel\n+                ))\n+            });\n+            let tooltip = if ignore {\n+                Some((\"This example is not tested\", \"ignore\"))\n+            } else if compile_fail {\n+                Some((\"This example deliberately fails to compile\", \"compile_fail\"))\n+            } else {\n+                None\n+            };\n+            s.push_str(&highlight::render_with_highlighting(\n+                           &text,\n+                           Some(&format!(\"rust-example-rendered{}\",\n+                                         if ignore { \" ignore\" }\n+                                         else if compile_fail { \" compile_fail\" }\n+                                         else { \"\" })),\n+                           None,\n+                           playground_button.as_ref().map(String::as_str),\n+                           tooltip));\n+            hoedown_buffer_put(ob, s.as_ptr(), s.len());\n+        })\n     }\n+}\n \n-    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data,\n-                     _: libc::size_t) {\n-        // hoedown does this, we may as well too\n-        unsafe { hoedown_buffer_put(ob, \"\\n\".as_ptr(), 1); }\n+extern fn hoedown_header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n+                         level: libc::c_int, data: *const hoedown_renderer_data,\n+                         _: libc::size_t) {\n+    // hoedown does this, we may as well too\n+    unsafe { hoedown_buffer_put(ob, \"\\n\".as_ptr(), 1); }\n \n-        // Extract the text provided\n-        let s = if text.is_null() {\n-            \"\".to_owned()\n-        } else {\n-            let s = unsafe { (*text).as_bytes() };\n-            str::from_utf8(&s).unwrap().to_owned()\n-        };\n+    // Extract the text provided\n+    let s = if text.is_null() {\n+        \"\".to_owned()\n+    } else {\n+        let s = unsafe { (*text).as_bytes() };\n+        str::from_utf8(&s).unwrap().to_owned()\n+    };\n \n-        // Discard '<em>', '<code>' tags and some escaped characters,\n-        // transform the contents of the header into a hyphenated string\n-        // without non-alphanumeric characters other than '-' and '_'.\n-        //\n-        // This is a terrible hack working around how hoedown gives us rendered\n-        // html for text rather than the raw text.\n-        let mut id = s.clone();\n-        let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n-                            \"<strong>\", \"</strong>\",\n-                            \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n-        for sub in repl_sub {\n-            id = id.replace(sub, \"\");\n-        }\n-        let id = id.chars().filter_map(|c| {\n-            if c.is_alphanumeric() || c == '-' || c == '_' {\n-                if c.is_ascii() {\n-                    Some(c.to_ascii_lowercase())\n-                } else {\n-                    Some(c)\n-                }\n-            } else if c.is_whitespace() && c.is_ascii() {\n-                Some('-')\n+    // Discard '<em>', '<code>' tags and some escaped characters,\n+    // transform the contents of the header into a hyphenated string\n+    // without non-alphanumeric characters other than '-' and '_'.\n+    //\n+    // This is a terrible hack working around how hoedown gives us rendered\n+    // html for text rather than the raw text.\n+    let mut id = s.clone();\n+    let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n+                        \"<strong>\", \"</strong>\",\n+                        \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n+    for sub in repl_sub {\n+        id = id.replace(sub, \"\");\n+    }\n+    let id = id.chars().filter_map(|c| {\n+        if c.is_alphanumeric() || c == '-' || c == '_' {\n+            if c.is_ascii() {\n+                Some(c.to_ascii_lowercase())\n             } else {\n-                None\n+                Some(c)\n             }\n-        }).collect::<String>();\n+        } else if c.is_whitespace() && c.is_ascii() {\n+            Some('-')\n+        } else {\n+            None\n+        }\n+    }).collect::<String>();\n \n-        let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n-        let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n+    let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n+    let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n \n-        let id = derive_id(id);\n+    let id = derive_id(id);\n \n-        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n-            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n-        });\n+    let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+        format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n+    });\n+\n+    // Render the HTML\n+    let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n+                       <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n+                       s, lvl = level, id = id, sec = sec);\n \n-        // Render the HTML\n-        let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n-                           <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n-                           s, lvl = level, id = id, sec = sec);\n+    unsafe { hoedown_buffer_put(ob, text.as_ptr(), text.len()); }\n+}\n+\n+extern fn hoedown_codespan(\n+    ob: *mut hoedown_buffer,\n+    text: *const hoedown_buffer,\n+    _: *const hoedown_renderer_data,\n+    _: libc::size_t\n+) -> libc::c_int {\n+    let content = if text.is_null() {\n+        \"\".to_owned()\n+    } else {\n+        let bytes = unsafe { (*text).as_bytes() };\n+        let s = str::from_utf8(bytes).unwrap();\n+        collapse_whitespace(s)\n+    };\n \n-        unsafe { hoedown_buffer_put(ob, text.as_ptr(), text.len()); }\n+    let content = format!(\"<code>{}</code>\", Escape(&content));\n+    unsafe {\n+        hoedown_buffer_put(ob, content.as_ptr(), content.len());\n     }\n+    // Return anything except 0, which would mean \"also print the code span verbatim\".\n+    1\n+}\n \n-    extern fn codespan(\n+pub fn render(w: &mut fmt::Formatter,\n+              s: &str,\n+              links: &[(String, String)],\n+              print_toc: bool,\n+              html_flags: libc::c_uint) -> fmt::Result {\n+    // copied from pulldown-cmark (MIT license, Google)\n+    // https://github.com/google/pulldown-cmark\n+    // this is temporary till we remove the hoedown renderer\n+    static HREF_SAFE: [u8; 128] = [\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,\n+            0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,\n+        ];\n+\n+    static HEX_CHARS: &'static [u8] = b\"0123456789ABCDEF\";\n+\n+    fn escape_href(ob: &mut String, s: &str) {\n+        let mut mark = 0;\n+        for i in 0..s.len() {\n+            let c = s.as_bytes()[i];\n+            if c >= 0x80 || HREF_SAFE[c as usize] == 0 {\n+                // character needing escape\n+\n+                // write partial substring up to mark\n+                if mark < i {\n+                    ob.push_str(&s[mark..i]);\n+                }\n+                match c {\n+                    b'&' => {\n+                        ob.push_str(\"&amp;\");\n+                    },\n+                    b'\\'' => {\n+                        ob.push_str(\"&#x27;\");\n+                    },\n+                    _ => {\n+                        let mut buf = [0u8; 3];\n+                        buf[0] = b'%';\n+                        buf[1] = HEX_CHARS[((c as usize) >> 4) & 0xF];\n+                        buf[2] = HEX_CHARS[(c as usize) & 0xF];\n+                        ob.push_str(str::from_utf8(&buf).unwrap());\n+                    }\n+                }\n+                mark = i + 1;  // all escaped characters are ASCII\n+            }\n+        }\n+        ob.push_str(&s[mark..]);\n+    }\n+    // end code copied from pulldown-cmark\n+\n+    extern fn hoedown_link(\n         ob: *mut hoedown_buffer,\n-        text: *const hoedown_buffer,\n-        _: *const hoedown_renderer_data,\n-        _: libc::size_t\n+        content: *const hoedown_buffer,\n+        link: *const hoedown_buffer,\n+        title: *const hoedown_buffer,\n+        data: *const hoedown_renderer_data,\n+        _line: libc::size_t\n     ) -> libc::c_int {\n-        let content = if text.is_null() {\n-            \"\".to_owned()\n+        if link.is_null() {\n+            return 0;\n+        }\n+\n+        let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n+        let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n+\n+        let link = {\n+            let s = unsafe { (*link).as_bytes() };\n+            str::from_utf8(s).unwrap().to_owned()\n+        };\n+\n+        let link = if let Some(&(_, ref new_target)) = opaque.links_replace\n+                                                             .iter()\n+                                                             .find(|t| &*t.0 == &*link) {\n+            new_target.to_owned()\n         } else {\n-            let bytes = unsafe { (*text).as_bytes() };\n-            let s = str::from_utf8(bytes).unwrap();\n-            collapse_whitespace(s)\n+            link\n         };\n \n-        let content = format!(\"<code>{}</code>\", Escape(&content));\n-        unsafe {\n-            hoedown_buffer_put(ob, content.as_ptr(), content.len());\n-        }\n-        // Return anything except 0, which would mean \"also print the code span verbatim\".\n+        let content = unsafe {\n+            content.as_ref().map(|c| {\n+                let s = c.as_bytes();\n+                str::from_utf8(s).unwrap().to_owned()\n+            })\n+        };\n+\n+        let mut link_buf = String::new();\n+        escape_href(&mut link_buf, &link);\n+\n+        let title = unsafe {\n+            title.as_ref().map(|t| {\n+                let s = t.as_bytes();\n+                str::from_utf8(s).unwrap().to_owned()\n+            })\n+        };\n+\n+        let link_out = format!(\"<a href=\\\"{link}\\\"{title}>{content}</a>\",\n+                               link = link_buf,\n+                               title = title.map_or(String::new(),\n+                                                    |t| format!(\" title=\\\"{}\\\"\", t)),\n+                               content = content.unwrap_or(String::new()));\n+\n+        unsafe { hoedown_buffer_put(ob, link_out.as_ptr(), link_out.len()); }\n+\n+        //return \"anything but 0\" to show we've written the link in\n         1\n     }\n \n@@ -743,13 +886,16 @@ pub fn render(w: &mut fmt::Formatter,\n         let renderer = hoedown_html_renderer_new(html_flags, 0);\n         let mut opaque = MyOpaque {\n             dfltblk: (*renderer).blockcode.unwrap(),\n-            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n+            toc_builder: if print_toc {Some(TocBuilder::new())} else {None},\n+            links_out: None,\n+            links_replace: links.to_vec(),\n         };\n         (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n                 = &mut opaque as *mut _ as *mut libc::c_void;\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n-        (*renderer).codespan = Some(codespan);\n+        (*renderer).blockcode = Some(hoedown_block);\n+        (*renderer).header = Some(hoedown_header);\n+        (*renderer).codespan = Some(hoedown_codespan);\n+        (*renderer).link = Some(hoedown_link);\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n         hoedown_document_render(document, ob, s.as_ptr(),\n@@ -993,12 +1139,12 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md, render_type) = *self;\n+        let Markdown(md, links, render_type) = *self;\n \n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n         if render_type == RenderType::Hoedown {\n-            render(fmt, md, false, 0)\n+            render(fmt, md, links, false, 0)\n         } else {\n             let mut opts = Options::empty();\n             opts.insert(OPTION_ENABLE_TABLES);\n@@ -1009,7 +1155,11 @@ impl<'a> fmt::Display for Markdown<'a> {\n             let mut s = String::with_capacity(md.len() * 3 / 2);\n \n             html::push_html(&mut s,\n-                            Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+                            Footnotes::new(\n+                                CodeBlocks::new(\n+                                    LinkReplacer::new(\n+                                        HeadingLinks::new(p, None),\n+                                        links))));\n \n             fmt.write_str(&s)\n         }\n@@ -1021,7 +1171,7 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n         let MarkdownWithToc(md, render_type) = *self;\n \n         if render_type == RenderType::Hoedown {\n-            render(fmt, md, true, 0)\n+            render(fmt, md, &[], true, 0)\n         } else {\n             let mut opts = Options::empty();\n             opts.insert(OPTION_ENABLE_TABLES);\n@@ -1050,7 +1200,7 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n         if render_type == RenderType::Hoedown {\n-            render(fmt, md, false, HOEDOWN_HTML_ESCAPE)\n+            render(fmt, md, &[], false, HOEDOWN_HTML_ESCAPE)\n         } else {\n             let mut opts = Options::empty();\n             opts.insert(OPTION_ENABLE_TABLES);\n@@ -1076,15 +1226,15 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n \n impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownSummaryLine(md) = *self;\n+        let MarkdownSummaryLine(md, links) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n \n         let p = Parser::new(md);\n \n         let mut s = String::new();\n \n-        html::push_html(&mut s, SummaryLine::new(p));\n+        html::push_html(&mut s, LinkReplacer::new(SummaryLine::new(p), links));\n \n         fmt.write_str(&s)\n     }\n@@ -1140,6 +1290,90 @@ pub fn plain_summary_line(md: &str) -> String {\n     s\n }\n \n+pub fn markdown_links(md: &str, render_type: RenderType) -> Vec<String> {\n+    if md.is_empty() {\n+        return vec![];\n+    }\n+\n+    match render_type {\n+        RenderType::Hoedown => {\n+            extern fn hoedown_link(\n+                _ob: *mut hoedown_buffer,\n+                _content: *const hoedown_buffer,\n+                link: *const hoedown_buffer,\n+                _title: *const hoedown_buffer,\n+                data: *const hoedown_renderer_data,\n+                _line: libc::size_t\n+            ) -> libc::c_int {\n+                if link.is_null() {\n+                    return 0;\n+                }\n+\n+                let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n+                let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n+\n+                if let Some(ref mut links) = opaque.links_out {\n+                    let s = unsafe { (*link).as_bytes() };\n+                    let s = str::from_utf8(&s).unwrap().to_owned();\n+\n+                    debug!(\"found link: {}\", s);\n+\n+                    links.push(s);\n+                }\n+\n+                //returning 0 here means \"emit the span verbatim\", but we're not using the output\n+                //anyway so we don't really care\n+                0\n+            }\n+\n+            unsafe {\n+                let ob = hoedown_buffer_new(DEF_OUNIT);\n+                let renderer = hoedown_html_renderer_new(0, 0);\n+                let mut opaque = MyOpaque {\n+                    dfltblk: (*renderer).blockcode.unwrap(),\n+                    toc_builder: None,\n+                    links_out: Some(vec![]),\n+                    links_replace: vec![],\n+                };\n+                (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n+                        = &mut opaque as *mut _ as *mut libc::c_void;\n+                (*renderer).header = Some(hoedown_header);\n+                (*renderer).codespan = Some(hoedown_codespan);\n+                (*renderer).link = Some(hoedown_link);\n+\n+                let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n+                hoedown_document_render(document, ob, md.as_ptr(),\n+                                        md.len() as libc::size_t);\n+                hoedown_document_free(document);\n+\n+                hoedown_html_renderer_free(renderer);\n+                hoedown_buffer_free(ob);\n+\n+                opaque.links_out.unwrap()\n+            }\n+        }\n+        RenderType::Pulldown => {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+            let p = Parser::new_ext(md, opts);\n+\n+            let iter = Footnotes::new(HeadingLinks::new(p, None));\n+            let mut links = vec![];\n+\n+            for ev in iter {\n+                if let Event::Start(Tag::Link(dest, _)) = ev {\n+                    debug!(\"found link: {}\", dest);\n+                    links.push(dest.into_owned());\n+                }\n+            }\n+\n+            links\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::{LangString, Markdown, MarkdownHtml};\n@@ -1191,14 +1425,14 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown, RenderType::Pulldown));\n+        format!(\"{}\", Markdown(markdown, &[], RenderType::Pulldown));\n         reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, RenderType::Pulldown));\n+            let output = format!(\"{}\", Markdown(input, &[], RenderType::Pulldown));\n             assert_eq!(output, expect, \"original: {}\", input);\n             reset_ids(true);\n         }\n@@ -1220,7 +1454,7 @@ mod tests {\n     #[test]\n     fn test_header_ids_multiple_blocks() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, RenderType::Pulldown));\n+            let output = format!(\"{}\", Markdown(input, &[], RenderType::Pulldown));\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n "}, {"sha": "b58a59f12173c5850145de360b6433d6229eede9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -421,7 +421,7 @@ thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n thread_local!(pub static USED_ID_MAP: RefCell<FxHashMap<String, usize>> =\n                     RefCell::new(init_ids()));\n \n-pub fn render_text<F: FnMut(RenderType) -> String>(mut render: F) -> (String, String) {\n+pub fn render_text<T, F: FnMut(RenderType) -> T>(mut render: F) -> (T, T) {\n     // Save the state of USED_ID_MAP so it only gets updated once even\n     // though we're rendering twice.\n     let orig_used_id_map = USED_ID_MAP.with(|map| map.borrow().clone());\n@@ -1284,7 +1284,7 @@ impl DocFolder for Cache {\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n             clean::ConstantItem(..) | clean::StaticItem(..) |\n-            clean::UnionItem(..) | clean::ForeignTypeItem\n+            clean::UnionItem(..) | clean::ForeignTypeItem | clean::MacroItem(..)\n             if !self.stripped_mod => {\n                 // Re-exported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n@@ -1861,12 +1861,14 @@ fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Re\n /// rendering between Pulldown and Hoedown.\n fn render_markdown(w: &mut fmt::Formatter,\n                    md_text: &str,\n+                   links: Vec<(String, String)>,\n                    span: Span,\n                    render_type: RenderType,\n                    prefix: &str,\n                    scx: &SharedContext)\n                    -> fmt::Result {\n-    let (hoedown_output, pulldown_output) = render_text(|ty| format!(\"{}\", Markdown(md_text, ty)));\n+    let (hoedown_output, pulldown_output) =\n+        render_text(|ty| format!(\"{}\", Markdown(md_text, &links, ty)));\n     let mut differences = html_diff::get_differences(&pulldown_output, &hoedown_output);\n     differences.retain(|s| {\n         match *s {\n@@ -1898,7 +1900,13 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n         } else {\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n-        render_markdown(w, &markdown, item.source.clone(), cx.render_type, prefix, &cx.shared)?;\n+        render_markdown(w,\n+                        &markdown,\n+                        item.links(),\n+                        item.source.clone(),\n+                        cx.render_type,\n+                        prefix,\n+                        &cx.shared)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -1924,7 +1932,13 @@ fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n                  cx: &Context, prefix: &str) -> fmt::Result {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, &*s, item.source.clone(), cx.render_type, prefix, &cx.shared)?;\n+        render_markdown(w,\n+                        &*s,\n+                        item.links(),\n+                        item.source.clone(),\n+                        cx.render_type,\n+                        prefix,\n+                        &cx.shared)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -2146,10 +2160,10 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        stab_docs = stab_docs,\n                        docs = if cx.render_type == RenderType::Hoedown {\n                            format!(\"{}\",\n-                                   shorter(Some(&Markdown(doc_value,\n+                                   shorter(Some(&Markdown(doc_value, &myitem.links(),\n                                                           RenderType::Hoedown).to_string())))\n                        } else {\n-                           format!(\"{}\", MarkdownSummaryLine(doc_value))\n+                           format!(\"{}\", MarkdownSummaryLine(doc_value, &myitem.links()))\n                        },\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n@@ -3338,7 +3352,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(&*dox, cx.render_type))?;\n+            write!(w, \"<div class='docblock'>{}</div>\",\n+                   Markdown(&*dox, &i.impl_item.links(), cx.render_type))?;\n         }\n     }\n "}, {"sha": "6347c4a58dddd34779d72b41c262857ff0869436", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -503,6 +503,11 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     let crate_name = matches.opt_str(\"crate-name\");\n     let crate_version = matches.opt_str(\"crate-version\");\n     let plugin_path = matches.opt_str(\"plugin-path\");\n+    let render_type = if matches.opt_present(\"disable-commonmark\") {\n+        RenderType::Hoedown\n+    } else {\n+        RenderType::Pulldown\n+    };\n \n     info!(\"starting to run rustc\");\n     let display_warnings = matches.opt_present(\"display-warnings\");\n@@ -517,7 +522,7 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n \n         let (mut krate, renderinfo) =\n             core::run_core(paths, cfgs, externs, Input::File(cratefile), triple, maybe_sysroot,\n-                           display_warnings, force_unstable_if_unmarked);\n+                           display_warnings, force_unstable_if_unmarked, render_type);\n \n         info!(\"finished with rustc\");\n "}, {"sha": "9af2ebf0661da72960f63200fb2feff211230a0d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -104,7 +104,7 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n     } else {\n         // Save the state of USED_ID_MAP so it only gets updated once even\n         // though we're rendering twice.\n-        render_text(|ty| format!(\"{}\", Markdown(text, ty)))\n+        render_text(|ty| format!(\"{}\", Markdown(text, &[], ty)))\n     };\n \n     let mut differences = html_diff::get_differences(&pulldown_output, &hoedown_output);"}, {"sha": "7b208465369fc128388914aff1245c4618e92122", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -40,21 +40,21 @@ use doctree::*;\n // also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?\n \n-pub struct RustdocVisitor<'a, 'tcx: 'a> {\n-    cstore: &'tcx CrateStore,\n+pub struct RustdocVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n+    cstore: &'a CrateStore,\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n-    pub cx: &'a core::DocContext<'a, 'tcx>,\n+    pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n     view_item_stack: FxHashSet<ast::NodeId>,\n     inlining: bool,\n     /// Is the current module and all of its parents public?\n     inside_public_path: bool,\n     reexported_macros: FxHashSet<DefId>,\n }\n \n-impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cstore: &'tcx CrateStore,\n-               cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n+    pub fn new(cstore: &'a CrateStore,\n+               cx: &'a core::DocContext<'a, 'tcx, 'rcx>) -> RustdocVisitor<'a, 'tcx, 'rcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet();\n         stack.insert(ast::CRATE_NODE_ID);"}, {"sha": "15a8b58d0f6b92297010c63aea500bf6e241ec98", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -22,8 +22,8 @@ use clean::{AttributesExt, NestedAttributesExt};\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n-pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    cx: &'a ::core::DocContext<'b, 'tcx>,\n+pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n+    cx: &'a ::core::DocContext<'a, 'tcx, 'rcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable\n@@ -32,8 +32,8 @@ pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     visited_mods: FxHashSet<DefId>,\n }\n \n-impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n-    pub fn new(cx: &'a ::core::DocContext<'b, 'tcx>) -> LibEmbargoVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'tcx, 'rcx> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n+    pub fn new(cx: &'a ::core::DocContext<'a, 'tcx, 'rcx>) -> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n         LibEmbargoVisitor {\n             cx,\n             access_levels: cx.access_levels.borrow_mut(),"}, {"sha": "aa6f553875441384ec5676f0906c78ccb7d628fb", "filename": "src/test/rustdoc/intra-links.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Ftest%2Frustdoc%2Fintra-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Ftest%2Frustdoc%2Fintra-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-links.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has intra_links/index.html\n+// @has - '//a/@href' '../intra_links/struct.ThisType.html'\n+// @has - '//a/@href' '../intra_links/enum.ThisEnum.html'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html'\n+// @has - '//a/@href' '../intra_links/type.ThisAlias.html'\n+// @has - '//a/@href' '../intra_links/union.ThisUnion.html'\n+// @has - '//a/@href' '../intra_links/fn.this_function.html'\n+// @has - '//a/@href' '../intra_links/constant.THIS_CONST.html'\n+// @has - '//a/@href' '../intra_links/static.THIS_STATIC.html'\n+// @has - '//a/@href' '../intra_links/macro.this_macro.html'\n+// @has - '//a/@href' '../intra_links/trait.SoAmbiguous.html'\n+// @has - '//a/@href' '../intra_links/fn.SoAmbiguous.html'\n+//! In this crate we would like to link to:\n+//!\n+//! * [`ThisType`](ThisType)\n+//! * [`ThisEnum`](ThisEnum)\n+//! * [`ThisTrait`](ThisTrait)\n+//! * [`ThisAlias`](ThisAlias)\n+//! * [`ThisUnion`](ThisUnion)\n+//! * [`this_function`](this_function())\n+//! * [`THIS_CONST`](const@THIS_CONST)\n+//! * [`THIS_STATIC`](static@THIS_STATIC)\n+//! * [`this_macro`](this_macro!)\n+//!\n+//! In addition, there's some specifics we want to look at. There's [a trait called\n+//! SoAmbiguous][ambig-trait], but there's also [a function called SoAmbiguous][ambig-fn] too!\n+//! Whatever shall we do?\n+//!\n+//! [ambig-trait]: trait@SoAmbiguous\n+//! [ambig-fn]: SoAmbiguous()\n+\n+#[macro_export]\n+macro_rules! this_macro {\n+    () => {};\n+}\n+\n+pub struct ThisType;\n+pub enum ThisEnum { ThisVariant, }\n+pub trait ThisTrait {}\n+pub type ThisAlias = Result<(), ()>;\n+pub union ThisUnion { this_field: usize, }\n+\n+pub fn this_function() {}\n+pub const THIS_CONST: usize = 5usize;\n+pub static THIS_STATIC: usize = 5usize;\n+\n+pub trait SoAmbiguous {}\n+\n+#[allow(bad_style)]\n+pub fn SoAmbiguous() {}"}, {"sha": "8454e71fa3f9b8c720f1d3dc725f049398164de9", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a7ea9c4095e3218df39832dfc51a456534ecc9/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=48a7ea9c4095e3218df39832dfc51a456534ecc9", "patch": "@@ -100,7 +100,7 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, RenderType::Hoedown))?,\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc, &[], RenderType::Hoedown))?,\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}