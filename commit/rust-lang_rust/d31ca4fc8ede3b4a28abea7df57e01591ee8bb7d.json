{"sha": "d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMWNhNGZjOGVkZTNiNGEyOGFiZWE3ZGY1N2UwMTU5MWVlOGJiN2Q=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T07:34:23Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-26T05:04:58Z"}, "message": "Move Utf8Error to new mod", "tree": {"sha": "89a917970cfc756a190eddf31f4c422d6704cad0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89a917970cfc756a190eddf31f4c422d6704cad0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "html_url": "https://github.com/rust-lang/rust/commit/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6622d1d05d1ea58cfd9b56cc3a91b2c17316c96", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6622d1d05d1ea58cfd9b56cc3a91b2c17316c96", "html_url": "https://github.com/rust-lang/rust/commit/c6622d1d05d1ea58cfd9b56cc3a91b2c17316c96"}], "stats": {"total": 260, "additions": 134, "deletions": 126}, "files": [{"sha": "43b790a4aca9096be45c6a6d8ea5c266faf65cae", "filename": "library/core/src/str/error.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs?ref=d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "patch": "@@ -0,0 +1,129 @@\n+//! Defines utf8 error type.\n+\n+use crate::fmt;\n+\n+/// Errors which can occur when attempting to interpret a sequence of [`u8`]\n+/// as a string.\n+///\n+/// As such, the `from_utf8` family of functions and methods for both [`String`]s\n+/// and [`&str`]s make use of this error, for example.\n+///\n+/// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n+/// [`&str`]: from_utf8\n+///\n+/// # Examples\n+///\n+/// This error type\u2019s methods can be used to create functionality\n+/// similar to `String::from_utf8_lossy` without allocating heap memory:\n+///\n+/// ```\n+/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n+///     loop {\n+///         match std::str::from_utf8(input) {\n+///             Ok(valid) => {\n+///                 push(valid);\n+///                 break\n+///             }\n+///             Err(error) => {\n+///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n+///                 unsafe {\n+///                     push(std::str::from_utf8_unchecked(valid))\n+///                 }\n+///                 push(\"\\u{FFFD}\");\n+///\n+///                 if let Some(invalid_sequence_length) = error.error_len() {\n+///                     input = &after_valid[invalid_sequence_length..]\n+///                 } else {\n+///                     break\n+///                 }\n+///             }\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[derive(Copy, Eq, PartialEq, Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Utf8Error {\n+    pub(super) valid_up_to: usize,\n+    pub(super) error_len: Option<u8>,\n+}\n+\n+impl Utf8Error {\n+    /// Returns the index in the given string up to which valid UTF-8 was\n+    /// verified.\n+    ///\n+    /// It is the maximum index such that `from_utf8(&input[..index])`\n+    /// would return `Ok(_)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::str;\n+    ///\n+    /// // some invalid bytes, in a vector\n+    /// let sparkle_heart = vec![0, 159, 146, 150];\n+    ///\n+    /// // std::str::from_utf8 returns a Utf8Error\n+    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n+    ///\n+    /// // the second byte is invalid here\n+    /// assert_eq!(1, error.valid_up_to());\n+    /// ```\n+    #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n+    pub fn valid_up_to(&self) -> usize {\n+        self.valid_up_to\n+    }\n+\n+    /// Provides more information about the failure:\n+    ///\n+    /// * `None`: the end of the input was reached unexpectedly.\n+    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n+    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n+    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n+    ///\n+    /// * `Some(len)`: an unexpected byte was encountered.\n+    ///   The length provided is that of the invalid byte sequence\n+    ///   that starts at the index given by `valid_up_to()`.\n+    ///   Decoding should resume after that sequence\n+    ///   (after inserting a [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD]) in case of\n+    ///   lossy decoding.\n+    ///\n+    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n+    #[stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")]\n+    pub fn error_len(&self) -> Option<usize> {\n+        self.error_len.map(|len| len as usize)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for Utf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let Some(error_len) = self.error_len {\n+            write!(\n+                f,\n+                \"invalid utf-8 sequence of {} bytes from index {}\",\n+                error_len, self.valid_up_to\n+            )\n+        } else {\n+            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n+        }\n+    }\n+}\n+\n+/// An error returned when parsing a `bool` using [`from_str`] fails\n+///\n+/// [`from_str`]: FromStr::from_str\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseBoolError {\n+    pub(super) _priv: (),\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseBoolError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"provided string was not `true` or `false`\".fmt(f)\n+    }\n+}"}, {"sha": "b00d94f4858d94a90c75abe958d70c05ca778ceb", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 5, "deletions": 126, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "patch": "@@ -8,6 +8,8 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod error;\n+\n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n \n@@ -27,6 +29,9 @@ pub mod pattern;\n #[allow(missing_docs)]\n pub mod lossy;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use error::{ParseBoolError, Utf8Error};\n+\n /// Parse a value from a string\n ///\n /// `FromStr`'s [`from_str`] method is often used implicitly, through\n@@ -138,121 +143,10 @@ impl FromStr for bool {\n     }\n }\n \n-/// An error returned when parsing a `bool` using [`from_str`] fails\n-///\n-/// [`from_str`]: FromStr::from_str\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseBoolError {\n-    _priv: (),\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ParseBoolError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        \"provided string was not `true` or `false`\".fmt(f)\n-    }\n-}\n-\n /*\n Section: Creating a string\n */\n \n-/// Errors which can occur when attempting to interpret a sequence of [`u8`]\n-/// as a string.\n-///\n-/// As such, the `from_utf8` family of functions and methods for both [`String`]s\n-/// and [`&str`]s make use of this error, for example.\n-///\n-/// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n-/// [`&str`]: from_utf8\n-///\n-/// # Examples\n-///\n-/// This error type\u2019s methods can be used to create functionality\n-/// similar to `String::from_utf8_lossy` without allocating heap memory:\n-///\n-/// ```\n-/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n-///     loop {\n-///         match std::str::from_utf8(input) {\n-///             Ok(valid) => {\n-///                 push(valid);\n-///                 break\n-///             }\n-///             Err(error) => {\n-///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n-///                 unsafe {\n-///                     push(std::str::from_utf8_unchecked(valid))\n-///                 }\n-///                 push(\"\\u{FFFD}\");\n-///\n-///                 if let Some(invalid_sequence_length) = error.error_len() {\n-///                     input = &after_valid[invalid_sequence_length..]\n-///                 } else {\n-///                     break\n-///                 }\n-///             }\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[derive(Copy, Eq, PartialEq, Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Utf8Error {\n-    valid_up_to: usize,\n-    error_len: Option<u8>,\n-}\n-\n-impl Utf8Error {\n-    /// Returns the index in the given string up to which valid UTF-8 was\n-    /// verified.\n-    ///\n-    /// It is the maximum index such that `from_utf8(&input[..index])`\n-    /// would return `Ok(_)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::str;\n-    ///\n-    /// // some invalid bytes, in a vector\n-    /// let sparkle_heart = vec![0, 159, 146, 150];\n-    ///\n-    /// // std::str::from_utf8 returns a Utf8Error\n-    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n-    ///\n-    /// // the second byte is invalid here\n-    /// assert_eq!(1, error.valid_up_to());\n-    /// ```\n-    #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n-    pub fn valid_up_to(&self) -> usize {\n-        self.valid_up_to\n-    }\n-\n-    /// Provides more information about the failure:\n-    ///\n-    /// * `None`: the end of the input was reached unexpectedly.\n-    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n-    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n-    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n-    ///\n-    /// * `Some(len)`: an unexpected byte was encountered.\n-    ///   The length provided is that of the invalid byte sequence\n-    ///   that starts at the index given by `valid_up_to()`.\n-    ///   Decoding should resume after that sequence\n-    ///   (after inserting a [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD]) in case of\n-    ///   lossy decoding.\n-    ///\n-    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n-    #[stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")]\n-    pub fn error_len(&self) -> Option<usize> {\n-        self.error_len.map(|len| len as usize)\n-    }\n-}\n-\n /// Converts a slice of bytes to a string slice.\n ///\n /// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n@@ -440,21 +334,6 @@ pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n     unsafe { &mut *(v as *mut [u8] as *mut str) }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for Utf8Error {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some(error_len) = self.error_len {\n-            write!(\n-                f,\n-                \"invalid utf-8 sequence of {} bytes from index {}\",\n-                error_len, self.valid_up_to\n-            )\n-        } else {\n-            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n-        }\n-    }\n-}\n-\n /*\n Section: Iterators\n */"}]}