{"sha": "0c902cfeca67c948e86e5b13d264e9bf1d7deff3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOTAyY2ZlY2E2N2M5NDhlODZlNWIxM2QyNjRlOWJmMWQ3ZGVmZjM=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-05-16T05:31:29Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-05-16T05:31:29Z"}, "message": "Complete implementation of invalidates facts", "tree": {"sha": "92cc6c8e013adeb5064b4ddb2896b45e3b5fc393", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92cc6c8e013adeb5064b4ddb2896b45e3b5fc393"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c902cfeca67c948e86e5b13d264e9bf1d7deff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c902cfeca67c948e86e5b13d264e9bf1d7deff3", "html_url": "https://github.com/rust-lang/rust/commit/0c902cfeca67c948e86e5b13d264e9bf1d7deff3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c902cfeca67c948e86e5b13d264e9bf1d7deff3/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4", "html_url": "https://github.com/rust-lang/rust/commit/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4"}], "stats": {"total": 96, "additions": 60, "deletions": 36}, "files": [{"sha": "5a677e142ced8a80b10c04033843cb629143ddb5", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0c902cfeca67c948e86e5b13d264e9bf1d7deff3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c902cfeca67c948e86e5b13d264e9bf1d7deff3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=0c902cfeca67c948e86e5b13d264e9bf1d7deff3", "patch": "@@ -17,64 +17,70 @@ use borrow_check::{Context, ContextKind};\n use borrow_check::{LocalMutationIsAllowed, MutateMode};\n use borrow_check::ArtificialField;\n use borrow_check::{ReadKind, WriteKind, Overlap};\n-use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::facts::AllFacts;\n use dataflow::move_paths::indexes::BorrowIndex;\n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue, Projection};\n use rustc::mir::{Local, ProjectionElem};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::mir::{Field, Operand, BorrowKind};\n-use rustc::ty;\n+use rustc::ty::{self, ParamEnv};\n use rustc_data_structures::indexed_vec::Idx;\n use std::iter;\n \n pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n-    regioncx: &mut RegionInferenceContext<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n+    mir_def_id: DefId,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if !all_facts.is_some() {\n         // Nothing to do if we don't have any facts\n         return;\n     }\n \n-    let mut ig = InvalidationGenerator {\n-        all_facts: &mut all_facts.unwrap(),\n-        borrow_set,\n-        infcx,\n-        regioncx,\n-        location_table,\n-        mir,\n-    };\n+    let param_env = infcx.tcx.param_env(mir_def_id);\n+\n+    let mut all_facts_taken = all_facts.take().unwrap();\n+    {\n+        let mut ig = InvalidationGenerator {\n+            all_facts: &mut all_facts_taken,\n+            borrow_set,\n+            infcx,\n+            location_table,\n+            mir,\n+            param_env,\n+        };\n+        ig.visit_mir(mir);\n+    }\n+    *all_facts = Some(all_facts_taken);\n }\n \n /// 'cg = the duration of the constraint generation process itself.\n-struct InvalidationGenerator<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n+struct InvalidationGenerator<'cg, 'cx: 'cg, 'tcx: 'cx, 'gcx: 'tcx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &'cg mut AllFacts,\n     location_table: &'cg LocationTable,\n-    regioncx: &'cg mut RegionInferenceContext<'tcx>,\n     mir: &'cg Mir<'tcx>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n+    param_env: ParamEnv<'gcx>,\n }\n \n /// Visits the whole MIR and generates invalidates() facts\n /// Most of the code implementing this was stolen from borrow_check/mod.rs\n-impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx> {\n+impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n     fn visit_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>, location: Location) {\n         match statement.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n                 self.consume_rvalue(\n                     ContextKind::AssignRhs.new(location),\n                     rhs,\n-                    location\n                 );\n \n                 self.mutate_place(\n@@ -170,6 +176,7 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> Visitor<'tcx> for InvalidationGenerat\n                 let gcx = tcx.global_tcx();\n                 let drop_place_ty = drop_place.ty(self.mir, tcx);\n                 let drop_place_ty = tcx.erase_regions(&drop_place_ty).to_ty(tcx);\n+                let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n                 self.visit_terminator_drop(location, terminator, drop_place, drop_place_ty);\n             }\n             TerminatorKind::DropAndReplace {\n@@ -275,7 +282,7 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> Visitor<'tcx> for InvalidationGenerat\n     }\n }\n \n-impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx> {\n+impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n     /// Simulates dropping of a variable\n     fn visit_terminator_drop(\n         &mut self,\n@@ -286,10 +293,10 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n     ) {\n         let gcx = self.infcx.tcx.global_tcx();\n         let drop_field = |\n-        ig: &mut InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx>,\n-        (index, field): (usize, ty::Ty<'gcx>),\n+            ig: &mut InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx>,\n+            (index, field): (usize, ty::Ty<'gcx>),\n         | {\n-            let field_ty = gcx.normalize_erasing_regions(self.mir.param_env, field);\n+            let field_ty = gcx.normalize_erasing_regions(ig.param_env, field);\n             let place = drop_place.clone().field(Field::new(index), field_ty);\n \n             ig.visit_terminator_drop(loc, term, &place, field_ty);\n@@ -351,7 +358,7 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n         context: Context,\n         place: &Place<'tcx>,\n         kind: ShallowOrDeep,\n-        mode: MutateMode,\n+        _mode: MutateMode,\n     ) {\n         self.access_place(\n             context,\n@@ -393,7 +400,6 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n         &mut self,\n         context: Context,\n         rvalue: &Rvalue<'tcx>,\n-        location: Location,\n     ) {\n         match *rvalue {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n@@ -447,7 +453,7 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n             Rvalue::NullaryOp(_op, _ty) => {\n             }\n \n-            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+            Rvalue::Aggregate(_, ref operands) => {\n                 for operand in operands {\n                     self.consume_operand(context, operand);\n                 }\n@@ -461,7 +467,7 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n         context: Context,\n         place: &Place<'tcx>,\n         kind: (ShallowOrDeep, ReadOrWrite),\n-        is_local_mutation_allowed: LocalMutationIsAllowed,\n+        _is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) {\n         let (sd, rw) = kind;\n         // note: not doing check_access_permissions checks because they don't generate invalidates\n@@ -502,7 +508,7 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n                     // Reads/reservations don't invalidate shared borrows\n                 }\n \n-                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n+                (Read(_), BorrowKind::Unique) | (Read(_), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n                     if !this.is_active(borrow, context.loc) {\n                         // If the borrow isn't active yet, reads don't invalidate it\n@@ -512,20 +518,13 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n \n                     // Unique and mutable borrows are invalidated by reads from any\n                     // involved path\n-                    match kind {\n-                        ReadKind::Copy => {\n-                            this.generate_invalidates(borrow_index, context.loc);\n-                        }\n-                        ReadKind::Borrow(bk) => {\n-                            this.generate_invalidates(borrow_index, context.loc);\n-                        }\n-                    }\n+                    this.generate_invalidates(borrow_index, context.loc);\n                 }\n \n-                (Reservation(kind), BorrowKind::Unique)\n-                | (Reservation(kind), BorrowKind::Mut { .. })\n-                | (Activation(kind, _), _)\n-                | (Write(kind), _) => {\n+                (Reservation(_), BorrowKind::Unique)\n+                | (Reservation(_), BorrowKind::Mut { .. })\n+                | (Activation(_, _), _)\n+                | (Write(_), _) => {\n                     // unique or mutable borrows are invalidated by writes.\n                     // Reservations count as writes since we need to check\n                     // that activating the borrow will be OK\n@@ -588,6 +587,23 @@ impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx,\n         }\n     }\n \n+    /// Determine if a given two-phase borrow is active using dominator information\n+    fn is_active(&self, borrow: &BorrowData, location: Location) -> bool {\n+        // If it's not two-phase, the borrow is definitely active\n+        if !self.allow_two_phase_borrow(borrow.kind) {\n+            return true;\n+        }\n+        if borrow.activation_location.is_none() {\n+            return false;\n+        }\n+        let activation_location = borrow.activation_location.unwrap();\n+        if activation_location.block == location.block {\n+            activation_location.statement_index >= location.statement_index\n+        } else {\n+            self.mir.dominators().is_dominated_by(location.block, activation_location.block)\n+        }\n+    }\n+\n     /// Returns whether an access of kind `access` to `access_place` conflicts with\n     /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n     /// locations, this function is symmetric between `borrow_place` & `access_place`)."}, {"sha": "85dade1960e0f74e66da62aab0a5d88eb3b2deb5", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c902cfeca67c948e86e5b13d264e9bf1d7deff3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c902cfeca67c948e86e5b13d264e9bf1d7deff3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=0c902cfeca67c948e86e5b13d264e9bf1d7deff3", "patch": "@@ -131,6 +131,14 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         &mir,\n         borrow_set,\n     );\n+    invalidation::generate_invalidates(\n+        infcx,\n+        &mut all_facts,\n+        location_table,\n+        &mir,\n+        def_id,\n+        borrow_set\n+    );\n \n     // Dump facts if requested.\n     if let Some(all_facts) = all_facts {"}]}