{"sha": "f55482e7c965a7a4280fef968cb1cdd701c04ecc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NTQ4MmU3Yzk2NWE3YTQyODBmZWY5NjhjYjFjZGQ3MDFjMDRlY2M=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2016-10-28T20:58:32Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2016-11-29T12:04:27Z"}, "message": "rustc: replace body exprs by their ids", "tree": {"sha": "44ca3f8edfe124b9508d4715af78bfa89985574e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44ca3f8edfe124b9508d4715af78bfa89985574e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f55482e7c965a7a4280fef968cb1cdd701c04ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f55482e7c965a7a4280fef968cb1cdd701c04ecc", "html_url": "https://github.com/rust-lang/rust/commit/f55482e7c965a7a4280fef968cb1cdd701c04ecc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f55482e7c965a7a4280fef968cb1cdd701c04ecc/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "069a2442b82a8f05882fea4f79b7514e32754697", "url": "https://api.github.com/repos/rust-lang/rust/commits/069a2442b82a8f05882fea4f79b7514e32754697", "html_url": "https://github.com/rust-lang/rust/commit/069a2442b82a8f05882fea4f79b7514e32754697"}], "stats": {"total": 522, "additions": 327, "deletions": 195}, "files": [{"sha": "b5a6ba3555dd15edc3a841db00447163937dc328", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 78, "deletions": 27, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -67,6 +67,14 @@ impl<'a> FnKind<'a> {\n     }\n }\n \n+/// Specifies what nested things a visitor wants to visit. Currently there are\n+/// two modes: `OnlyBodies` descends into item bodies, but not into nested\n+/// items; `All` descends into item bodies and nested items.\n+pub enum NestedVisitMode {\n+    OnlyBodies,\n+    All\n+}\n+\n /// Each method of the Visitor trait is a hook to be potentially\n /// overridden.  Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n@@ -102,7 +110,7 @@ pub trait Visitor<'v> : Sized {\n     /// `panic!()`. This way, if a new `visit_nested_XXX` variant is\n     /// added in the future, we will see the panic in your code and\n     /// fix it appropriately.\n-    fn nested_visit_map(&mut self) -> Option<&Map<'v>> {\n+    fn nested_visit_map(&mut self) -> Option<(&Map<'v>, NestedVisitMode)> {\n         None\n     }\n \n@@ -116,7 +124,7 @@ pub trait Visitor<'v> : Sized {\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map()\n+        let opt_item = map_for_item(self)\n                            .map(|map| map.expect_item(id.id));\n         if let Some(item) = opt_item {\n             self.visit_item(item);\n@@ -128,13 +136,25 @@ pub trait Visitor<'v> : Sized {\n     /// method.\n     #[allow(unused_variables)]\n     fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n-        let opt_item = self.nested_visit_map()\n+        let opt_item = map_for_item(self)\n                            .map(|map| map.impl_item(id));\n         if let Some(item) = opt_item {\n             self.visit_impl_item(item);\n         }\n     }\n \n+    /// Invoked to visit the body of a function, method or closure. Like\n+    /// visit_nested_item, does nothing by default unless you override\n+    /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n+    /// body.\n+    fn visit_body(&mut self, id: ExprId) {\n+        let opt_expr = map_for_body(self)\n+                           .map(|map| map.expr(id));\n+        if let Some(expr) = opt_expr {\n+            self.visit_expr(expr);\n+        }\n+    }\n+\n     /// Visit the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n@@ -200,7 +220,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Expr, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: ExprId, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n@@ -279,6 +299,19 @@ pub trait Visitor<'v> : Sized {\n     }\n }\n \n+fn map_for_body<'v, V: Visitor<'v>>(visitor: &mut V) -> Option<&Map<'v>> {\n+    visitor.nested_visit_map().map(|(map, _mode)| map)\n+}\n+\n+fn map_for_item<'v, V: Visitor<'v>>(visitor: &mut V) -> Option<&Map<'v>> {\n+    visitor.nested_visit_map().and_then(|(map, mode)| {\n+        match mode {\n+            NestedVisitMode::OnlyBodies => None,\n+            NestedVisitMode::All => Some(map)\n+        }\n+    })\n+}\n+\n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n     if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n@@ -363,7 +396,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_expr(expr);\n         }\n-        ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemFn(ref declaration, unsafety, constness, abi, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n                                             generics,\n                                             unsafety,\n@@ -372,7 +405,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                             &item.vis,\n                                             &item.attrs),\n                              declaration,\n-                             body,\n+                             body_id,\n                              item.span,\n                              item.id)\n         }\n@@ -697,13 +730,25 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   function_body: &'v Expr,\n+                                   body_id: ExprId,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     walk_fn_decl(visitor, function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_expr(function_body)\n+    visitor.visit_body(body_id)\n+}\n+\n+pub fn walk_fn_with_body<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             function_kind: FnKind<'v>,\n+                                             function_declaration: &'v FnDecl,\n+                                             body: &'v Expr,\n+                                             _span: Span,\n+                                             id: NodeId) {\n+    visitor.visit_id(id);\n+    walk_fn_decl(visitor, function_declaration);\n+    walk_fn_kind(visitor, function_kind);\n+    visitor.visit_expr(body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n@@ -720,13 +765,13 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n-        MethodTraitItem(ref sig, Some(ref body)) => {\n+        MethodTraitItem(ref sig, Some(body_id)) => {\n             visitor.visit_fn(FnKind::Method(trait_item.name,\n                                             sig,\n                                             None,\n                                             &trait_item.attrs),\n                              &sig.decl,\n-                             body,\n+                             body_id,\n                              trait_item.span,\n                              trait_item.id);\n         }\n@@ -752,13 +797,13 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expr);\n         }\n-        ImplItemKind::Method(ref sig, ref body) => {\n+        ImplItemKind::Method(ref sig, body_id) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n                                             sig,\n                                             Some(&impl_item.vis),\n                                             &impl_item.attrs),\n                              &sig.decl,\n-                             body,\n+                             body_id,\n                              impl_item.span,\n                              impl_item.id);\n         }\n@@ -883,7 +928,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, ref body, _fn_decl_span) => {\n+        ExprClosure(_, ref function_declaration, body, _fn_decl_span) => {\n             visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n@@ -998,34 +1043,40 @@ impl IdRange {\n }\n \n \n-pub struct IdRangeComputingVisitor {\n-    pub result: IdRange,\n+pub struct IdRangeComputingVisitor<'a, 'ast: 'a> {\n+    result: IdRange,\n+    map: &'a map::Map<'ast>,\n }\n \n-impl IdRangeComputingVisitor {\n-    pub fn new() -> IdRangeComputingVisitor {\n-        IdRangeComputingVisitor { result: IdRange::max() }\n+impl<'a, 'ast> IdRangeComputingVisitor<'a, 'ast> {\n+    pub fn new(map: &'a map::Map<'ast>) -> IdRangeComputingVisitor<'a, 'ast> {\n+        IdRangeComputingVisitor { result: IdRange::max(), map: map }\n     }\n \n     pub fn result(&self) -> IdRange {\n         self.result\n     }\n }\n \n-impl<'v> Visitor<'v> for IdRangeComputingVisitor {\n+impl<'a, 'ast> Visitor<'ast> for IdRangeComputingVisitor<'a, 'ast> {\n+    fn nested_visit_map(&mut self) -> Option<(&Map<'ast>, NestedVisitMode)> {\n+        Some((&self.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n     fn visit_id(&mut self, id: NodeId) {\n         self.result.add(id);\n     }\n }\n \n /// Computes the id range for a single fn body, ignoring nested items.\n-pub fn compute_id_range_for_fn_body(fk: FnKind,\n-                                    decl: &FnDecl,\n-                                    body: &Expr,\n-                                    sp: Span,\n-                                    id: NodeId)\n-                                    -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor::new();\n-    visitor.visit_fn(fk, decl, body, sp, id);\n+pub fn compute_id_range_for_fn_body<'v>(fk: FnKind<'v>,\n+                                        decl: &'v FnDecl,\n+                                        body: &'v Expr,\n+                                        sp: Span,\n+                                        id: NodeId,\n+                                        map: &map::Map<'v>)\n+                                        -> IdRange {\n+    let mut visitor = IdRangeComputingVisitor::new(map);\n+    walk_fn_with_body(&mut visitor, fk, decl, body, sp, id);\n     visitor.result()\n }"}, {"sha": "ccf94e0b803db6391287cb12b383dabc121ae9e9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -845,12 +845,14 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n+                let body = self.expr_block(body, ThinVec::new());\n+                let body_id = self.record_expr(body);\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            P(self.expr_block(body, ThinVec::new())))\n+                            body_id)\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -917,7 +919,8 @@ impl<'a> LoweringContext<'a> {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n                                              body.as_ref().map(|x| {\n                             let body = this.lower_block(x);\n-                            P(this.expr_block(body, ThinVec::new()))\n+                            let expr = this.expr_block(body, ThinVec::new());\n+                            this.record_expr(expr)\n                         }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n@@ -945,8 +948,9 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  P(this.expr_block(body, ThinVec::new())))\n+                        let expr = this.expr_block(body, ThinVec::new());\n+                        let expr_id = this.record_expr(expr);\n+                        hir::ImplItemKind::Method(this.lower_method_sig(sig), expr_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -1395,9 +1399,10 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n                     self.with_parent_def(e.id, |this| {\n+                        let expr = this.lower_expr(body);\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         P(this.lower_expr(body)),\n+                                         this.record_expr(expr),\n                                          fn_decl_span)\n                     })\n                 }"}, {"sha": "0adeb90e697daa9d0d0a64a848bf8740e2b9b560", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -48,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: &'a Expr,\n+    pub body: ast::ExprId,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -115,7 +115,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     &'a Expr,\n+    body:     ast::ExprId,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -125,14 +125,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: &'a Expr,\n+    body: ast::ExprId,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: &'a Expr, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::ExprId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -172,9 +172,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> &'a Expr {\n-        self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Expr, _, _|  body,\n+    pub fn body(self) -> ast::ExprId {\n+        self.handle(|i: ItemFnParts<'a>|  i.body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: ast::ExprId, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -215,21 +215,21 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  &'a ast::Expr,\n+                  ast::ExprId,\n                   Span,\n                   &'a [Attribute])\n                   -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n             map::NodeItem(i) => match i.node {\n-                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, ref block) =>\n+                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,\n                         decl: &decl,\n                         unsafety: unsafety,\n-                        body: &block,\n+                        body: block,\n                         generics: generics,\n                         abi: abi,\n                         vis: &i.vis,\n@@ -240,14 +240,14 @@ impl<'a> FnLikeNode<'a> {\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n-                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                ast::MethodTraitItem(ref sig, Some(body)) => {\n                     method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n-                    ast::ImplItemKind::Method(ref sig, ref body) => {\n+                    ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n@@ -256,8 +256,8 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             }\n             map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, ref decl, ref block, _fn_decl_span) =>\n-                    closure(ClosureParts::new(&decl, &block, e.id, e.span, &e.attrs)),\n+                ast::ExprClosure(_, ref decl, block, _fn_decl_span) =>\n+                    closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "6033278575d301872dba06cdbface6e62c65945b", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -10,7 +10,8 @@\n \n use super::*;\n \n-use hir::intravisit::Visitor;\n+use hir::*;\n+use hir::intravisit::{Visitor, NestedVisitMode};\n use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n@@ -91,7 +92,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n \n-    fn nested_visit_map(&mut self) -> Option<&map::Map<'ast>> {\n+    fn nested_visit_map(&mut self) -> Option<(&map::Map<'ast>, NestedVisitMode)> {\n         panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n     }\n \n@@ -106,6 +107,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.visit_impl_item(self.krate.impl_item(item_id))\n     }\n \n+    fn visit_body(&mut self, id: ExprId) {\n+        self.visit_expr(self.krate.expr(id))\n+    }\n+\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -209,7 +214,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Expr, s: Span, id: NodeId) {\n+                b: ExprId, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }"}, {"sha": "a6d7c79e34646b1b76c2528403bc21a9a4c82cfc", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -327,6 +327,12 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n \n // We walk the HIR rather than the AST when reading items from metadata.\n impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n+    fn visit_body(&mut self, id: hir::ExprId) {\n+        if let Some(krate) = self.hir_crate {\n+            self.visit_expr(krate.expr(id));\n+        }\n+    }\n+\n     fn visit_item(&mut self, i: &'ast hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "7ef98fcce7e214837d8774d53895bd828e3cdc47", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -655,6 +655,10 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expr(&self, id: ExprId) -> &'ast Expr {\n+        self.expect_expr(id.node_id())\n+    }\n+\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {"}, {"sha": "f66e6788ee7fa954bbd322228ded6ba0234997c7", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -460,6 +460,10 @@ impl Crate {\n             visitor.visit_impl_item(impl_item);\n         }\n     }\n+\n+    pub fn expr(&self, id: ExprId) -> &Expr {\n+        &self.exprs[&id]\n+    }\n }\n \n /// A macro definition, in this crate or imported from another.\n@@ -925,7 +929,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, P<Expr>, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, ExprId, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -1079,7 +1083,7 @@ pub enum TraitItem_ {\n     /// must contain a value)\n     ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     /// A method with an optional body\n-    MethodTraitItem(MethodSig, Option<P<Expr>>),\n+    MethodTraitItem(MethodSig, Option<ExprId>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n@@ -1112,7 +1116,7 @@ pub enum ImplItemKind {\n     /// of the expression\n     Const(P<Ty>, P<Expr>),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, P<Expr>),\n+    Method(MethodSig, ExprId),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1557,7 +1561,7 @@ pub enum Item_ {\n     /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Expr>),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, ExprId),\n     /// A module\n     ItemMod(Mod),\n     /// An external module"}, {"sha": "74920b1328076d392dd9212fe903cd8ea0e80993", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -644,6 +644,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_expr_id(&mut self, expr_id: &hir::ExprId) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            let expr = &krate.exprs[expr_id];\n+            self.print_expr(expr)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n@@ -729,7 +738,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr(&body)?;\n+                self.print_expr_id(body)?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -1020,7 +1029,7 @@ impl<'a> State<'a> {\n                     self.nbsp()?;\n                     self.end()?; // need to close a box\n                     self.end()?; // need to close a box\n-                    self.print_expr(body)?;\n+                    self.print_expr_id(body)?;\n                 } else {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1065,7 +1074,7 @@ impl<'a> State<'a> {\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr(body)?;\n+                self.print_expr_id(body)?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1432,7 +1441,7 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n \n                 // this is a bare expression\n-                self.print_expr(body)?;\n+                self.print_expr_id(body)?;\n                 self.end()?; // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall"}, {"sha": "799c7e0cc84bcb8d1cb8b7009b99beebbd07199f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -719,10 +719,10 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ids<F>(&mut self, f: F)\n-        where F: FnOnce(&mut IdVisitor)\n+    fn visit_ids<'b, F: 'b>(&'b mut self, f: F)\n+        where F: FnOnce(&mut IdVisitor<'b, 'a, 'tcx>)\n     {\n-        let mut v = IdVisitor {\n+        let mut v = IdVisitor::<'b, 'a, 'tcx> {\n             cx: self\n         };\n         f(&mut v);\n@@ -791,8 +791,8 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, hir_visit::NestedVisitMode)> {\n+        Some((&self.tcx.map, hir_visit::NestedVisitMode::All))\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n@@ -835,9 +835,10 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                body: &'tcx hir::Expr, span: Span, id: ast::NodeId) {\n+                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n+        let body = self.tcx.map.expr(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n-        hir_visit::walk_fn(self, fk, decl, body, span, id);\n+        hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n     }\n \n@@ -1107,7 +1108,11 @@ struct IdVisitor<'a, 'b: 'a, 'tcx: 'a+'b> {\n }\n \n // Output any lints that were previously added to the session.\n-impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> hir_visit::Visitor<'tcx> for IdVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, hir_visit::NestedVisitMode)> {\n+        Some((&self.cx.tcx.map, hir_visit::NestedVisitMode::OnlyBodies))\n+    }\n+\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n@@ -1117,12 +1122,12 @@ impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _ti: &'tcx hir::TraitItem) {\n         // Do not recurse into trait or impl items automatically. These are\n         // processed separately by calling hir_visit::walk_trait_item()\n     }\n \n-    fn visit_impl_item(&mut self, _ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _ii: &'tcx hir::ImplItem) {\n         // See visit_trait_item()\n     }\n }"}, {"sha": "575ac9773a7da22616ecb77927af518e5369f7d5", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -15,7 +15,7 @@\n use dep_graph::DepNode;\n use hir::map as ast_map;\n use hir::{self, PatKind};\n-use hir::intravisit::{self, Visitor};\n+use hir::intravisit::{self, Visitor, NestedVisitMode};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n use middle::privacy;\n@@ -175,7 +175,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &ast_map::Node) {\n+    fn visit_node(&mut self, node: &ast_map::Node<'tcx>) {\n         let had_extern_repr = self.struct_has_extern_repr;\n         self.struct_has_extern_repr = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -220,9 +220,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n \n-    fn visit_variant_data(&mut self, def: &hir::VariantData, _: ast::Name,\n+    fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n                         _: &hir::Generics, _: ast::NodeId, _: syntax_pos::Span) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -234,7 +237,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_struct_def(self, def);\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let def = self.tcx.tables().qpath_def(qpath, expr.id);\n@@ -255,7 +258,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_arm(&mut self, arm: &hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n         if arm.pats.len() == 1 {\n             let variants = arm.pats[0].necessary_variants();\n \n@@ -271,7 +274,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ref fields, _) => {\n                 self.handle_field_pattern_match(pat, path.def, fields);\n@@ -288,8 +291,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         self.ignore_non_const_paths = false;\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        self.handle_definition(id, path.def);\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n+        self.lookup_and_handle_definition(id);\n         intravisit::walk_path(self, path);\n     }\n }\n@@ -507,8 +510,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::All))\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -562,12 +565,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 }\n                 intravisit::walk_expr(self, expr)\n             }\n-            hir::ImplItemKind::Method(_, ref body) => {\n+            hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                intravisit::walk_expr(self, body)\n+                self.visit_body(body_id)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -576,10 +579,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n-            hir::ConstTraitItem(_, Some(ref body))|\n-            hir::MethodTraitItem(_, Some(ref body)) => {\n+            hir::ConstTraitItem(_, Some(ref body)) => {\n                 intravisit::walk_expr(self, body)\n             }\n+            hir::MethodTraitItem(_, Some(body_id)) => {\n+                self.visit_body(body_id)\n+            }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |\n             hir::TypeTraitItem(..) => {}"}, {"sha": "57735b91ac5d68a4a0d82b1859b98980bb20ab6a", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use syntax_pos::Span;\n use hir::{self, PatKind};\n use hir::def::Def;\n-use hir::intravisit::{self, FnKind, Visitor};\n+use hir::intravisit::{self, FnKind, Visitor, NestedVisitMode};\n \n #[derive(Copy, Clone)]\n struct UnsafeContext {\n@@ -92,9 +92,13 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n-    fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n-                block: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n+                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>\n@@ -111,12 +115,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             self.unsafe_context = UnsafeContext::new(SafeContext)\n         }\n \n-        intravisit::walk_fn(self, fn_kind, fn_decl, block, span, id);\n+        intravisit::walk_fn(self, fn_kind, fn_decl, body_id, span, id);\n \n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block: &hir::Block) {\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n         let old_unsafe_context = self.unsafe_context;\n         match block.rules {\n             hir::UnsafeBlock(source) => {\n@@ -155,7 +159,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n@@ -212,7 +216,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n             if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n                 if adt.is_union() {"}, {"sha": "e927843a984b8c351a307ca2e625d4ba69f831bf", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -47,6 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n         find_item(item, self, at_root);\n     }\n \n+\n     fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n         // entry fn is never an impl item\n     }"}, {"sha": "5673ec05cf9400c184a256d834572c9eb445d1b8", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -19,7 +19,7 @@ use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n use syntax_pos::Span;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitMode};\n use hir;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -34,7 +34,7 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n-    fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n+    fn visit_const(&mut self, item_id: ast::NodeId, expr: &'tcx hir::Expr) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n         self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n@@ -116,9 +116,13 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n     // const, static and N in [T; N].\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n@@ -127,24 +131,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n             self.visit_const(item.id, expr);\n         } else {\n             intravisit::walk_trait_item(self, item);\n         }\n     }\n \n-    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n             self.visit_const(item.id, expr);\n         } else {\n             intravisit::walk_impl_item(self, item);\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n@@ -158,8 +162,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'gcx>, NestedVisitMode)> {\n+        Some((&self.infcx.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n             self.infcx.tcx.tables().qpath_def(qpath, expr.id)\n         } else {"}, {"sha": "ca28f1dae291ae7e807da8d48f6530e190e487c8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -128,7 +128,7 @@ use syntax_pos::Span;\n use hir::Expr;\n use hir;\n use hir::print::{expr_to_string, block_to_string};\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitMode};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -182,14 +182,17 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n-    fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n-    fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n-    fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n+    fn visit_local(&mut self, l: &'tcx hir::Local) { visit_local(self, l); }\n+    fn visit_expr(&mut self, ex: &'tcx Expr) { visit_expr(self, ex); }\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -348,28 +351,31 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v hir::FnDecl,\n-                _: &'v hir::Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.ir.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+    fn visit_fn(&mut self, _: FnKind<'tcx>, _: &'tcx hir::FnDecl,\n+                _: hir::ExprId, _: Span, _: NodeId) {\n         // do not check contents of nested fns\n     }\n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n         check_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n         check_arm(self, a);\n     }\n }\n \n-fn visit_fn(ir: &mut IrMaps,\n-            fk: FnKind,\n-            decl: &hir::FnDecl,\n-            body: &hir::Expr,\n-            sp: Span,\n-            id: ast::NodeId) {\n+fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n+                          fk: FnKind<'tcx>,\n+                          decl: &'tcx hir::FnDecl,\n+                          body_id: hir::ExprId,\n+                          sp: Span,\n+                          id: ast::NodeId) {\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n@@ -387,7 +393,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    intravisit::walk_fn(&mut fn_maps, fk, decl, body, sp, id);\n+    intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or panic\n@@ -400,6 +406,8 @@ fn visit_fn(ir: &mut IrMaps,\n         clean_exit_var: fn_maps.add_variable(CleanExit)\n     };\n \n+    let body = ir.tcx.map.expr(body_id);\n+\n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n     let entry_ln = lsets.compute(body);\n@@ -410,7 +418,7 @@ fn visit_fn(ir: &mut IrMaps,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n+fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n     local.pat.each_binding(|_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n@@ -423,7 +431,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n     intravisit::walk_local(ir, local);\n }\n \n-fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n+fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     for pat in &arm.pats {\n         pat.each_binding(|bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n@@ -439,7 +447,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     intravisit::walk_arm(ir, arm);\n }\n \n-fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n+fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n@@ -923,7 +931,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(.., ref blk, _) => {\n+          hir::ExprClosure(.., blk_id, _) => {\n               debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n \n@@ -932,7 +940,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               loop. The next-node for a continue is the top of this loop.\n               */\n               let node = self.live_node(expr.id, expr.span);\n-              self.with_loop_nodes(blk.id, succ, node, |this| {\n+              self.with_loop_nodes(blk_id.node_id(), succ, node, |this| {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n@@ -1354,7 +1362,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(this: &mut Liveness, local: &hir::Local) {\n+fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n     match local.init {\n         Some(_) => {\n             this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n@@ -1369,7 +1377,7 @@ fn check_local(this: &mut Liveness, local: &hir::Local) {\n     intravisit::walk_local(this, local);\n }\n \n-fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n+fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n@@ -1379,7 +1387,7 @@ fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n     intravisit::walk_arm(this, arm);\n }\n \n-fn check_expr(this: &mut Liveness, expr: &Expr) {\n+fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n         this.check_lvalue(&l);\n@@ -1469,7 +1477,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn check_lvalue(&mut self, expr: &Expr) {\n+    fn check_lvalue(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n                 if let Def::Local(def_id) = path.def {"}, {"sha": "4c3b102e540399f1c38d2f3b1b5841617a541ecd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -705,7 +705,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(.., ref body, _) => body.id,\n+                hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n                 _ => bug!()\n             }\n         };"}, {"sha": "f8a1b109d9dbd16671fd37d34aac0d4cb01134a6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -28,7 +28,7 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use hir;\n-use hir::intravisit::Visitor;\n+use hir::intravisit::{Visitor, NestedVisitMode};\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n@@ -88,8 +88,12 @@ struct ReachableContext<'a, 'tcx: 'a> {\n     any_library: bool,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n             hir::ExprPath(ref qpath) => {\n                 Some(self.tcx.tables().qpath_def(qpath, expr.id))\n@@ -216,7 +220,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &ast_map::Node,\n+    fn propagate_node(&mut self, node: &ast_map::Node<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n@@ -244,9 +248,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref body) => {\n+                    hir::ItemFn(.., body) => {\n                         if item_might_be_inlined(&item) {\n-                            self.visit_expr(body);\n+                            self.visit_body(body);\n                         }\n                     }\n \n@@ -274,10 +278,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::ConstTraitItem(_, Some(ref body)) |\n-                    hir::MethodTraitItem(_, Some(ref body)) => {\n+                    hir::ConstTraitItem(_, Some(ref body)) => {\n                         self.visit_expr(body);\n                     }\n+                    hir::MethodTraitItem(_, Some(body_id)) => {\n+                        self.visit_body(body_id);\n+                    }\n                     hir::TypeTraitItem(..) => {}\n                 }\n             }\n@@ -286,10 +292,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Const(_, ref expr) => {\n                         self.visit_expr(&expr);\n                     }\n-                    hir::ImplItemKind::Method(ref sig, ref body) => {\n+                    hir::ImplItemKind::Method(ref sig, body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            self.visit_expr(body)\n+                            self.visit_body(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}"}, {"sha": "49a2b4f17edd5e90ca44fe0d97196a576e183984", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -31,7 +31,7 @@ use syntax::ast::{self, NodeId};\n use syntax_pos::Span;\n \n use hir;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitMode};\n use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n@@ -302,14 +302,16 @@ pub struct Context {\n     parent: CodeExtent\n }\n \n-struct RegionResolutionVisitor<'a> {\n+struct RegionResolutionVisitor<'ast: 'a, 'a> {\n     sess: &'a Session,\n \n     // Generated maps:\n     region_maps: &'a RegionMaps,\n \n     cx: Context,\n \n+    map: &'a ast_map::Map<'ast>,\n+\n     /// `terminating_scopes` is a set containing the ids of each\n     /// statement, or conditional/repeating expression. These scopes\n     /// are calling \"terminating scopes\" because, when attempting to\n@@ -660,7 +662,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n     }\n }\n \n-fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n+fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk: &'tcx hir::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n@@ -731,7 +733,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n+fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.id);\n \n     if let Some(ref expr) = arm.guard {\n@@ -741,7 +743,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n     intravisit::walk_arm(visitor, arm);\n }\n \n-fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n+fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, pat: &'tcx hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -752,7 +754,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     intravisit::walk_pat(visitor, pat);\n }\n \n-fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n+fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt: &'tcx hir::Stmt) {\n     let stmt_id = stmt.node.id();\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -770,7 +772,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n+fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n@@ -848,7 +850,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n+fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, local: &'tcx hir::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n@@ -1063,7 +1065,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     }\n }\n \n-fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n+fn resolve_item<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, item: &'tcx hir::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n     let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n@@ -1078,38 +1080,38 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n     visitor.terminating_scopes = prev_ts;\n }\n \n-fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n-              kind: FnKind,\n-              decl: &hir::FnDecl,\n-              body: &hir::Expr,\n-              sp: Span,\n-              id: ast::NodeId) {\n+fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+                        kind: FnKind<'tcx>,\n+                        decl: &'tcx hir::FnDecl,\n+                        body_id: hir::ExprId,\n+                        sp: Span,\n+                        id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n                                span={:?}, \\\n                                body.id={:?}, \\\n                                cx.parent={:?})\",\n            id,\n            visitor.sess.codemap().span_to_string(sp),\n-           body.id,\n+           body_id,\n            visitor.cx.parent);\n \n     visitor.cx.parent = visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n \n     let fn_decl_scope = visitor.new_code_extent(\n-        CodeExtentData::ParameterScope { fn_id: id, body_id: body.id });\n+        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id() });\n \n     if let Some(root_id) = visitor.cx.root_id {\n-        visitor.region_maps.record_fn_parent(body.id, root_id);\n+        visitor.region_maps.record_fn_parent(body_id.node_id(), root_id);\n     }\n \n     let outer_cx = visitor.cx;\n     let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n-    visitor.terminating_scopes.insert(body.id);\n+    visitor.terminating_scopes.insert(body_id.node_id());\n \n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n-        root_id: Some(body.id),\n+        root_id: Some(body_id.node_id()),\n         parent: ROOT_CODE_EXTENT,\n         var_parent: fn_decl_scope,\n     };\n@@ -1119,18 +1121,18 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n-        root_id: Some(body.id),\n+        root_id: Some(body_id.node_id()),\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_expr(body);\n+    visitor.visit_body(body_id);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n     visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'a> RegionResolutionVisitor<'a> {\n+impl<'ast, 'a> RegionResolutionVisitor<'ast, 'a> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n     fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n         self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n@@ -1166,42 +1168,46 @@ impl<'a> RegionResolutionVisitor<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n-    fn visit_block(&mut self, b: &Block) {\n+impl<'ast, 'a> Visitor<'ast> for RegionResolutionVisitor<'ast, 'a> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'ast>, NestedVisitMode)> {\n+        Some((&self.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_block(&mut self, b: &'ast Block) {\n         resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &'ast Item) {\n         resolve_item(self, i);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n         intravisit::walk_impl_item(self, ii);\n         self.create_item_scope_if_needed(ii.id);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n         intravisit::walk_trait_item(self, ti);\n         self.create_item_scope_if_needed(ti.id);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Expr, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl,\n+                b: hir::ExprId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_arm(&mut self, a: &Arm) {\n+    fn visit_arm(&mut self, a: &'ast Arm) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &Pat) {\n+    fn visit_pat(&mut self, p: &'ast Pat) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &Stmt) {\n+    fn visit_stmt(&mut self, s: &'ast Stmt) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &'ast Expr) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &Local) {\n+    fn visit_local(&mut self, l: &'ast Local) {\n         resolve_local(self, l);\n     }\n }\n@@ -1228,6 +1234,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n+            map: map,\n             cx: Context {\n                 root_id: None,\n                 parent: ROOT_CODE_EXTENT,"}, {"sha": "7b94f9b32d90817f4f65bbe8794989c60decdb04", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -34,7 +34,7 @@ use util::nodemap::NodeMap;\n use rustc_data_structures::fx::FxHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitMode};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n@@ -132,8 +132,8 @@ pub fn krate(sess: &Session,\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     // Override the nested functions -- lifetimes follow lexical scope,\n     // so it's convenient to walk the tree in lexical order.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.hir_map)\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.hir_map, NestedVisitMode::All))\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: &'tcx hir::Expr, s: Span, fn_id: ast::NodeId) {\n+                b: hir::ExprId, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -407,7 +407,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: hir::ExprId) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -419,7 +419,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_expr(b);\n+    gather.visit_expr(ctxt.hir_map.expr(b));\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n@@ -497,7 +497,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn(&mut self,\n                              fk: FnKind<'tcx>,\n                              fd: &'tcx hir::FnDecl,\n-                             fb: &'tcx hir::Expr,\n+                             fb: hir::ExprId,\n                              _span: Span,\n                              fn_id: ast::NodeId) {\n         match fk {\n@@ -518,8 +518,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // `self.labels_in_fn`.\n         extract_labels(self, fb);\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.id, s: self.scope },\n-                  |_old_scope, this| this.visit_expr(fb))\n+        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id(), s: self.scope },\n+                  |_old_scope, this| this.visit_body(fb))\n     }\n \n     // FIXME(#37666) this works around a limitation in the region inferencer"}, {"sha": "7417509e5b78b795b3052d3479fb72264812fc25", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -30,7 +30,7 @@ use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n \n use hir;\n use hir::{Item, Generics, StructField, Variant};\n-use hir::intravisit::{self, Visitor};\n+use hir::intravisit::{self, Visitor, NestedVisitMode};\n use hir::itemlikevisit::DeepVisitor;\n \n use std::mem::replace;\n@@ -234,8 +234,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::All))\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -534,6 +534,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemExternCrate(_) => {"}, {"sha": "16f84a1b8aa17d4dc7d77d9c1a68b01cbc50a5a6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.map.local_def_id(id),\n-                            tcx.region_maps.call_site_extent(id, body.id))\n+                            tcx.region_maps.call_site_extent(id, body.node_id()))\n                     }\n                 }\n             }\n@@ -1227,9 +1227,9 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let extent = if let Some(ref body) = *body {\n+                        let extent = if let Some(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.region_maps.call_site_extent(id, body.id)\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id())\n                         } else {\n                             // no default impl: use item extent as free_id_outlive bound.\n                             tcx.region_maps.item_extent(id)\n@@ -1243,14 +1243,14 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref body) => {\n+                    hir::ItemFn(.., body_id) => {\n                         // We assume this is a function.\n                         let fn_def_id = tcx.map.local_def_id(id);\n \n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            tcx.region_maps.call_site_extent(id, body.id))\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id()))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |"}, {"sha": "f1ffd2b3f09eb845690ff75316490f044fddc6ca", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -205,7 +205,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n+    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id, &tcx.map);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n "}, {"sha": "1434181075fa5e6c1576518c0261404f8814bd8d", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55482e7c965a7a4280fef968cb1cdd701c04ecc/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=f55482e7c965a7a4280fef968cb1cdd701c04ecc", "patch": "@@ -44,7 +44,7 @@ enum TableEntry<'tcx> {\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     pub fn encode_inlined_item(&mut self, ii: InlinedItemRef) -> Lazy<Ast<'tcx>> {\n-        let mut id_visitor = IdRangeComputingVisitor::new();\n+        let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n         match ii {\n             InlinedItemRef::Item(_, i) => id_visitor.visit_item(i),\n             InlinedItemRef::TraitItem(_, ti) => id_visitor.visit_trait_item(ti),"}]}