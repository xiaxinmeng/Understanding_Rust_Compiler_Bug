{"sha": "a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "node_id": "C_kwDOAAsO6NoAKGE5YmQwYmQzMjE0ZjA0ZTVmM2RmOWNjNWNkOWY2ZWNkMzc1ZTYyNDI", "commit": {"author": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-07T12:08:09Z"}, "committer": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-19T18:00:19Z"}, "message": "Handle repeated str::replace calls with single char kind to str", "tree": {"sha": "c7a945e9c49b9e6914bcf9db28e768d7c3235dae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7a945e9c49b9e6914bcf9db28e768d7c3235dae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "html_url": "https://github.com/rust-lang/rust/commit/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e866875294be38b02c1deaf0b1cba181a65109b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e866875294be38b02c1deaf0b1cba181a65109b", "html_url": "https://github.com/rust-lang/rust/commit/6e866875294be38b02c1deaf0b1cba181a65109b"}], "stats": {"total": 349, "additions": 258, "deletions": 91}, "files": [{"sha": "b4e97a3bea4cd47d28a06a47768cec1072c50c17", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 250, "deletions": 87, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "patch": "@@ -1,17 +1,16 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-// use clippy_utils::source::snippet_with_context;\n+use clippy_utils::get_parent_expr;\n use clippy_utils::visitors::for_each_expr;\n use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::*;\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n-use std::unreachable;\n-// use rustc_span::Span;\n \n use super::method_call;\n use super::COLLAPSIBLE_STR_REPLACE;\n@@ -25,28 +24,46 @@ pub(super) fn check<'tcx>(\n ) {\n     match (name, args) {\n         (\"replace\", [from, to]) => {\n-            // Check for `str::replace` calls with char slice for linting\n+            // The receiver of the method call must be `str` type to lint `collapsible_str_replace`\n             let original_recv = find_original_recv(recv);\n-            let original_recv_ty = cx.typeck_results().expr_ty(original_recv).peel_refs();\n+            let original_recv_ty_kind = cx.typeck_results().expr_ty(original_recv).peel_refs().kind();\n+            let original_recv_is_str_kind = matches!(original_recv_ty_kind, ty::Str);\n+\n             if_chain! {\n-                // Check the receiver of the method call is `str` type\n-                if matches!(original_recv_ty.kind(), ty::Str);\n-                let from_ty = cx.typeck_results().expr_ty(from).peel_refs();\n-                if let ty::Array(array_ty, _) = from_ty.kind();\n+                // Check for `str::replace` calls with char slice for linting\n+                if original_recv_is_str_kind;\n+                let from_ty_kind = cx.typeck_results().expr_ty(from).peel_refs().kind();\n+                if let ty::Array(array_ty, _) = from_ty_kind;\n                 if matches!(array_ty.kind(), ty::Char);\n                 then {\n                     check_replace_call_with_char_slice(cx, from, to);\n+                    return;\n+                }\n+            }\n+\n+            if_chain! {\n+                if original_recv_is_str_kind;\n+                if let Some(parent) = get_parent_expr(cx, expr);\n+                if let Some((name, [..], _)) = method_call(parent);\n+\n+                then {\n+                    match name {\n+                        \"replace\" => return,\n+                        _ => {\n+                            check_consecutive_replace_calls(cx, expr);\n+                            return;\n+                        },\n+                    }\n                 }\n             }\n \n             match method_call(recv) {\n                 // Check if there's an earlier `str::replace` call\n-                Some((\"replace\", [prev_recv, prev_from, prev_to], prev_span)) => {\n-                    println!(\"Consecutive replace calls\");\n-                    // Check that the original receiver is of `ty::Str` type\n-                    // Check that all the `from` args are char literals\n-                    // Check that all the `to` args are the same variable or has the same &str value\n-                    // If so, then lint\n+                Some((\"replace\", [_, _, _], _)) => {\n+                    if original_recv_is_str_kind {\n+                        check_consecutive_replace_calls(cx, expr);\n+                        return;\n+                    }\n                 },\n                 _ => {},\n             }\n@@ -55,100 +72,246 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n-fn find_original_recv<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> &'tcx hir::Expr<'tcx> {\n-    let mut original_recv = recv;\n-\n-    let _: Option<()> = for_each_expr(recv, |e| {\n-        if let Some((name, [prev_recv, args @ ..], _)) = method_call(e) {\n-            match (name, args) {\n-                (\"replace\", [_, _]) => {\n-                    original_recv = prev_recv;\n-                    ControlFlow::Continue(())\n-                },\n-                _ => ControlFlow::BREAK,\n-            }\n-        } else {\n-            ControlFlow::Continue(())\n-        }\n-    });\n-\n-    original_recv\n-}\n-\n+/// Check a `str::replace` call that contains a char slice as `from` argument for\n+/// `collapsible_str_replace` lint.\n fn check_replace_call_with_char_slice<'tcx>(\n     cx: &LateContext<'tcx>,\n     from_arg: &'tcx hir::Expr<'tcx>,\n     to_arg: &'tcx hir::Expr<'tcx>,\n ) {\n-    let mut has_no_var = true;\n-    let mut char_list: Vec<char> = Vec::new();\n+    let mut char_slice_has_no_variables = true;\n+    let mut chars: Vec<String> = Vec::new();\n+\n     // Go through the `from_arg` to collect all char literals\n     let _: Option<()> = for_each_expr(from_arg, |e| {\n         if let ExprKind::Lit(Spanned {\n-            node: LitKind::Char(val),\n-            ..\n+            node: LitKind::Char(_), ..\n         }) = e.kind\n         {\n-            char_list.push(val);\n+            chars.push(get_replace_call_char_arg_repr(e).unwrap());\n             ControlFlow::Continue(())\n         } else if let ExprKind::Path(..) = e.kind {\n             // If a variable is found in the char slice, no lint for first version of this lint\n-            has_no_var = false;\n+            char_slice_has_no_variables = false;\n             ControlFlow::BREAK\n         } else {\n             ControlFlow::Continue(())\n         }\n     });\n \n-    if has_no_var {\n-        let to_arg_repr = match to_arg.kind {\n-            ExprKind::Lit(Spanned {\n-                node: LitKind::Str(to_arg_val, _),\n-                ..\n-            }) => {\n-                let repr = to_arg_val.as_str();\n-                let double_quote = \"\\\"\";\n-                double_quote.to_owned() + repr + double_quote\n-            },\n-            ExprKind::Path(QPath::Resolved(\n-                _,\n-                Path {\n-                    segments: path_segments,\n-                    ..\n+    if char_slice_has_no_variables {\n+        if let Some(to_arg_repr) = get_replace_call_char_arg_repr(to_arg) {\n+            let app = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                COLLAPSIBLE_STR_REPLACE,\n+                from_arg.span,\n+                \"used slice of chars in `str::replace` call\",\n+                \"replace with\",\n+                format!(\"replace(|c| matches!(c, {}), {})\", chars.join(\" | \"), to_arg_repr,),\n+                app,\n+            );\n+        }\n+    }\n+}\n+\n+/// Check a chain of `str::replace` calls for `collapsible_str_replace` lint.\n+fn check_consecutive_replace_calls<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n+    if_chain! {\n+        if let Some(from_args) = get_replace_call_from_args_if_all_char_ty(cx, expr);\n+        if let Some(to_arg) = get_replace_call_unique_to_arg_repr(expr);\n+        then {\n+            if replace_call_from_args_are_only_lit_chars(&from_args) {\n+                let from_arg_reprs: Vec<String> = from_args.iter().map(|from_arg| {\n+                    get_replace_call_char_arg_repr(from_arg).unwrap()\n+                }).collect();\n+                let app = Applicability::MachineApplicable;\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    COLLAPSIBLE_STR_REPLACE,\n+                    expr.span,\n+                    \"used consecutive `str::replace` call\",\n+                    \"replace with\",\n+                    format!(\n+                        \"replace(|c| matches!(c, {}), {})\",\n+                        from_arg_reprs.join(\" | \"),\n+                        to_arg,\n+                    ),\n+                    app,\n+                );\n+            } else {\n+                // Use fallback lint\n+                let from_arg_reprs: Vec<String> = from_args.iter().map(|from_arg| {\n+                    get_replace_call_char_arg_repr(from_arg).unwrap()\n+                }).collect();\n+                let app = Applicability::MachineApplicable;\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    COLLAPSIBLE_STR_REPLACE,\n+                    expr.span,\n+                    \"used consecutive `str::replace` call\",\n+                    \"replace with\",\n+                    format!(\n+                        \"replace(&[{}], {})\",\n+                        from_arg_reprs.join(\" , \"),\n+                        to_arg,\n+                    ),\n+                    app,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Check if all the `from` arguments of a chain of consecutive calls to `str::replace`\n+/// are all of `ExprKind::Lit` types. If any is not, return false.\n+fn replace_call_from_args_are_only_lit_chars<'tcx>(from_args: &Vec<&'tcx hir::Expr<'tcx>>) -> bool {\n+    let mut only_lit_chars = true;\n+\n+    for from_arg in from_args.iter() {\n+        match from_arg.kind {\n+            ExprKind::Lit(..) => {},\n+            _ => only_lit_chars = false,\n+        }\n+    }\n+\n+    only_lit_chars\n+}\n+\n+/// Collect and return all of the `from` arguments of a chain of consecutive `str::replace` calls\n+/// if these `from` arguments's expressions are of the `ty::Char` kind. Otherwise return `None`.\n+fn get_replace_call_from_args_if_all_char_ty<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+) -> Option<Vec<&'tcx hir::Expr<'tcx>>> {\n+    let mut all_from_args_are_chars = true;\n+    let mut from_args = Vec::new();\n+\n+    let _: Option<()> = for_each_expr(expr, |e| {\n+        if let Some((name, [_, args @ ..], _)) = method_call(e) {\n+            match (name, args) {\n+                (\"replace\", [from, _]) => {\n+                    let from_ty_kind = cx.typeck_results().expr_ty(from).peel_refs().kind();\n+                    if matches!(from_ty_kind, ty::Char) {\n+                        from_args.push(from);\n+                    } else {\n+                        all_from_args_are_chars = false;\n+                    }\n+                    ControlFlow::Continue(())\n                 },\n-            )) => {\n-                // join the path_segments values by \"::\"\n-                let path_segment_ident_names: Vec<&str> = path_segments\n-                    .iter()\n-                    .map(|path_seg| path_seg.ident.name.as_str())\n-                    .collect();\n-\n-                path_segment_ident_names.join(\"::\")\n+                _ => ControlFlow::BREAK,\n+            }\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    });\n+\n+    if all_from_args_are_chars {\n+        return Some(from_args);\n+    } else {\n+        return None;\n+    }\n+}\n+\n+/// Return a unique String representation of the `to` argument used in a chain of `str::replace`\n+/// calls if each `str::replace` call's `to` argument is identical to the other `to` arguments in\n+/// the chain. Otherwise, return `None`.\n+fn get_replace_call_unique_to_arg_repr<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<String> {\n+    let mut to_args = Vec::new();\n+\n+    let _: Option<()> = for_each_expr(expr, |e| {\n+        if let Some((name, [_, args @ ..], _)) = method_call(e) {\n+            match (name, args) {\n+                (\"replace\", [_, to]) => {\n+                    to_args.push(to);\n+                    ControlFlow::Continue(())\n+                },\n+                _ => ControlFlow::BREAK,\n+            }\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    });\n+\n+    // let mut to_arg_repr_set = FxHashSet::default();\n+    let mut to_arg_reprs = Vec::new();\n+    for &to_arg in to_args.iter() {\n+        if let Some(to_arg_repr) = get_replace_call_char_arg_repr(to_arg) {\n+            to_arg_reprs.push(to_arg_repr);\n+        }\n+    }\n+\n+    let to_arg_repr_set = FxHashSet::from_iter(to_arg_reprs.iter().cloned());\n+    // Check if the set of `to` argument representations has more than one unique value\n+    if to_arg_repr_set.len() != 1 {\n+        return None;\n+    }\n+\n+    // Return the single representation value\n+    to_arg_reprs.pop()\n+}\n+\n+/// Get the representation of an argument of a `str::replace` call either of the literal char value\n+/// or variable name, i.e. the resolved path segments `ident`.\n+/// Return:\n+/// - the str literal with double quotes, e.g. \"\\\"l\\\"\"\n+/// - the char literal with single quotes, e.g. \"'l'\"\n+/// - the variable as a String, e.g. \"l\"\n+fn get_replace_call_char_arg_repr<'tcx>(arg: &'tcx hir::Expr<'tcx>) -> Option<String> {\n+    match arg.kind {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Str(to_arg_val, _),\n+            ..\n+        }) => {\n+            let repr = to_arg_val.as_str();\n+            let double_quote = \"\\\"\";\n+            Some(double_quote.to_owned() + repr + double_quote)\n+        },\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Char(to_arg_val),\n+            ..\n+        }) => {\n+            let repr = to_arg_val.to_string();\n+            let double_quote = \"\\'\";\n+            Some(double_quote.to_owned() + &repr + double_quote)\n+        },\n+        ExprKind::Path(QPath::Resolved(\n+            _,\n+            Path {\n+                segments: path_segments,\n+                ..\n             },\n-            _ => unreachable!(),\n-        };\n-\n-        let app = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            COLLAPSIBLE_STR_REPLACE,\n-            from_arg.span,\n-            \"used slice of chars in `str::replace` call\",\n-            \"replace with\",\n-            format!(\n-                \"replace(|c| matches!(c, {}), {})\",\n-                format_slice_of_chars_for_sugg(&char_list),\n-                to_arg_repr,\n-            ),\n-            app,\n-        );\n+        )) => {\n+            // join the path_segments values by \"::\"\n+            let path_segment_ident_names: Vec<&str> = path_segments\n+                .iter()\n+                .map(|path_seg| path_seg.ident.name.as_str())\n+                .collect();\n+            Some(path_segment_ident_names.join(\"::\"))\n+        },\n+        _ => None,\n     }\n }\n \n-fn format_slice_of_chars_for_sugg(chars: &Vec<char>) -> String {\n-    let single_quoted_chars: Vec<String> = chars\n-        .iter()\n-        .map(|c| \"'\".to_owned() + &c.to_string() + &\"'\".to_owned())\n-        .collect();\n-    single_quoted_chars.join(\" | \")\n+/// Find the original receiver of a chain of `str::replace` method calls.\n+fn find_original_recv<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> &'tcx hir::Expr<'tcx> {\n+    let mut original_recv = recv;\n+\n+    let _: Option<()> = for_each_expr(recv, |e| {\n+        if let Some((name, [prev_recv, args @ ..], _)) = method_call(e) {\n+            match (name, args) {\n+                (\"replace\", [_, _]) => {\n+                    original_recv = prev_recv;\n+                    ControlFlow::Continue(())\n+                },\n+                _ => ControlFlow::BREAK,\n+            }\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    });\n+\n+    original_recv\n }"}, {"sha": "f93586936239583b06e3d84c80abde34566c66ca", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "patch": "@@ -3519,7 +3519,10 @@ impl Methods {\n                 (\"sort_unstable_by\", [arg]) => {\n                     unnecessary_sort_by::check(cx, expr, recv, arg, true);\n                 },\n-                (\"replace\", [_, _]) => collapsible_str_replace::check(cx, expr, name, recv, args),\n+                (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n+                    no_effect_replace::check(cx, expr, arg1, arg2);\n+                    collapsible_str_replace::check(cx, expr, name, recv, args);\n+                },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);\n@@ -3585,9 +3588,6 @@ impl Methods {\n                         unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n                     },\n                 },\n-                (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n-                    no_effect_replace::check(cx, expr, arg1, arg2);\n-                },\n                 (\"zip\", [arg]) => {\n                     if let ExprKind::MethodCall(name, [iter_recv], _) = recv.kind\n                         && name.ident.name == sym::iter"}, {"sha": "4257fce448d4d8574ca69d3411b6031619e56520", "filename": "tests/ui/collapsible_str_replace.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242/tests%2Fui%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242/tests%2Fui%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.rs?ref=a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "patch": "@@ -49,6 +49,10 @@ fn main() {\n     let replacement = misspelled.replace(s, \"l\");\n     println!(\"{replacement}\");\n \n+    // If the consecutive `str::replace` calls have different `to` arguments, do not lint\n+    let replacement = misspelled.replace('s', \"l\").replace('u', \"p\");\n+    println!(\"{replacement}\");\n+\n     // If the `from` argument is of kind other than a slice or a char, do not lint\n     let replacement = misspelled.replace(&get_filter(), \"l\");\n "}]}