{"sha": "d681bccb6a2141012a747cc272991a7440cb2408", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ODFiY2NiNmEyMTQxMDEyYTc0N2NjMjcyOTkxYTc0NDBjYjI0MDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T03:16:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T03:16:56Z"}, "message": "auto merge of #7471 : msullivan/rust/default-methods, r=graydon\n\nThis fixes a bunch of default method bugs and restructures how vtable resolutions are represented.\r\n\r\n(It also adds a depth counter to llvm::type_to_str as a hacky work around for our circular llvm types. This is related in the sense that I needed to do it to make debug tracing not cause rustc to crash after running out of stack space.)", "tree": {"sha": "cab40edc4a380a3eae1847ef833a28bc2139dfaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cab40edc4a380a3eae1847ef833a28bc2139dfaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d681bccb6a2141012a747cc272991a7440cb2408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d681bccb6a2141012a747cc272991a7440cb2408", "html_url": "https://github.com/rust-lang/rust/commit/d681bccb6a2141012a747cc272991a7440cb2408", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d681bccb6a2141012a747cc272991a7440cb2408/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e23934645aa7eb526e9f55da6b3d7c262dc1670f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e23934645aa7eb526e9f55da6b3d7c262dc1670f", "html_url": "https://github.com/rust-lang/rust/commit/e23934645aa7eb526e9f55da6b3d7c262dc1670f"}, {"sha": "9340fd5ce0d7bd0f1bbfbda73944920bcc1364eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9340fd5ce0d7bd0f1bbfbda73944920bcc1364eb", "html_url": "https://github.com/rust-lang/rust/commit/9340fd5ce0d7bd0f1bbfbda73944920bcc1364eb"}], "stats": {"total": 602, "additions": 425, "deletions": 177}, "files": [{"sha": "41349d9c085c42f63e1e9ef4b9ccd56af9dedeef", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -2149,18 +2149,24 @@ impl TypeNames {\n         self.named_types.find_equiv(&s).map_consume(|x| Type::from_ref(*x))\n     }\n \n-    pub fn type_to_str(&self, ty: Type) -> ~str {\n+    // We have a depth count, because we seem to make infinite types.\n+    pub fn type_to_str_depth(&self, ty: Type, depth: int) -> ~str {\n         match self.find_name(&ty) {\n             option::Some(name) => return name.to_owned(),\n             None => ()\n         }\n \n+        if depth == 0 {\n+            return ~\"###\";\n+        }\n+\n         unsafe {\n             let kind = ty.kind();\n \n             match kind {\n                 Void => ~\"Void\",\n                 Half => ~\"Half\",\n+                Float => ~\"Float\",\n                 Double => ~\"Double\",\n                 X86_FP80 => ~\"X86_FP80\",\n                 FP128 => ~\"FP128\",\n@@ -2175,31 +2181,36 @@ impl TypeNames {\n                 Function => {\n                     let out_ty = ty.return_type();\n                     let args = ty.func_params();\n-                    let args = args.map(|&ty| self.type_to_str(ty)).connect(\", \");\n-                    let out_ty = self.type_to_str(out_ty);\n+                    let args =\n+                        args.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n+                    let out_ty = self.type_to_str_depth(out_ty, depth-1);\n                     fmt!(\"fn(%s) -> %s\", args, out_ty)\n                 }\n                 Struct => {\n                     let tys = ty.field_types();\n-                    let tys = tys.map(|&ty| self.type_to_str(ty)).connect(\", \");\n+                    let tys = tys.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n                     fmt!(\"{%s}\", tys)\n                 }\n                 Array => {\n                     let el_ty = ty.element_type();\n-                    let el_ty = self.type_to_str(el_ty);\n+                    let el_ty = self.type_to_str_depth(el_ty, depth-1);\n                     let len = ty.array_length();\n                     fmt!(\"[%s x %u]\", el_ty, len)\n                 }\n                 Pointer => {\n                     let el_ty = ty.element_type();\n-                    let el_ty = self.type_to_str(el_ty);\n+                    let el_ty = self.type_to_str_depth(el_ty, depth-1);\n                     fmt!(\"*%s\", el_ty)\n                 }\n                 _ => fail!(\"Unknown Type Kind (%u)\", kind as uint)\n             }\n         }\n     }\n \n+    pub fn type_to_str(&self, ty: Type) -> ~str {\n+        self.type_to_str_depth(ty, 30)\n+    }\n+\n     pub fn val_to_str(&self, val: ValueRef) -> ~str {\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(val));"}, {"sha": "16e3bd34cddeb173658a66b026b0c7762655cfd9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -599,8 +599,10 @@ fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |ebml_w, vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+    do ebml_w.emit_from_vec(*dr) |ebml_w, param_tables| {\n+        do ebml_w.emit_from_vec(**param_tables) |ebml_w, vtable_origin| {\n+            encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+        }\n     }\n }\n \n@@ -632,6 +634,13 @@ fn encode_vtable_origin(ecx: &e::EncodeContext,\n                 }\n             }\n           }\n+          typeck::vtable_self(def_id) => {\n+            do ebml_w.emit_enum_variant(\"vtable_self\", 2u, 1u) |ebml_w| {\n+                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+                    ebml_w.emit_def_id(def_id)\n+                }\n+            }\n+          }\n         }\n     }\n }\n@@ -646,13 +655,17 @@ trait vtable_decoder_helpers {\n impl vtable_decoder_helpers for reader::Decoder {\n     fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|this| this.read_vtable_origin(xcx))\n+        @self.read_to_vec(|this|\n+           @this.read_to_vec(|this|\n+               this.read_vtable_origin(xcx)))\n     }\n \n     fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin {\n         do self.read_enum(\"vtable_origin\") |this| {\n-            do this.read_enum_variant([\"vtable_static\", \"vtable_param\"])\n+            do this.read_enum_variant([\"vtable_static\",\n+                                       \"vtable_param\",\n+                                       \"vtable_self\"])\n                     |this, i| {\n                 match i {\n                   0 => {\n@@ -678,6 +691,13 @@ impl vtable_decoder_helpers for reader::Decoder {\n                         }\n                     )\n                   }\n+                  2 => {\n+                    typeck::vtable_self(\n+                        do this.read_enum_variant_arg(0u) |this| {\n+                            this.read_def_id(xcx)\n+                        }\n+                    )\n+                  }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n                 }"}, {"sha": "efa69ab5e625bd6d36cbe82cf25b69e2cb77344b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -461,6 +461,7 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                                                     &tsubsts,\n                                                     None,\n                                                     None,\n+                                                    None,\n                                                     None);\n \n         val\n@@ -1544,17 +1545,15 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n                         output_type: ty::t,\n-                        impl_id: Option<ast::def_id>,\n                         param_substs: Option<@param_substs>,\n                         sp: Option<span>)\n                      -> fn_ctxt {\n     for param_substs.iter().advance |p| { p.validate(); }\n \n-    debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, impl_id=%?, \\\n+    debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, \\\n             param_substs=%s)\",\n            path_str(ccx.sess, path),\n            id,\n-           impl_id,\n            param_substs.repr(ccx.tcx));\n \n     let llbbs = mk_standard_basic_blocks(llfndecl);\n@@ -1583,7 +1582,6 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n           lllocals: @mut HashMap::new(),\n           llupvars: @mut HashMap::new(),\n           id: id,\n-          impl_id: impl_id,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n@@ -1604,7 +1602,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    output_type: ty::t,\n                    sp: Option<span>)\n                 -> fn_ctxt {\n-    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, None, sp)\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1773,7 +1771,6 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      self_arg: self_arg,\n                      param_substs: Option<@param_substs>,\n                      id: ast::node_id,\n-                     impl_id: Option<ast::def_id>,\n                      attributes: &[ast::attribute],\n                      output_type: ty::t,\n                      maybe_load_env: &fn(fn_ctxt),\n@@ -1791,7 +1788,6 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                                llfndecl,\n                                id,\n                                output_type,\n-                               impl_id,\n                                param_substs,\n                                Some(body.span));\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n@@ -1850,7 +1846,6 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                 self_arg: self_arg,\n                 param_substs: Option<@param_substs>,\n                 id: ast::node_id,\n-                impl_id: Option<ast::def_id>,\n                 attrs: &[ast::attribute]) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n@@ -1870,7 +1865,6 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   self_arg,\n                   param_substs,\n                   id,\n-                  impl_id,\n                   attrs,\n                   output_type,\n                   |fcx| {\n@@ -1920,7 +1914,6 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n                                llfndecl,\n                                variant.node.id,\n                                enum_ty,\n-                               None,\n                                param_substs,\n                                None);\n \n@@ -2000,7 +1993,6 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n                                llfndecl,\n                                ctor_id,\n                                tup_ty,\n-                               None,\n                                param_substs,\n                                None);\n \n@@ -2080,7 +2072,6 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n                      no_self,\n                      None,\n                      item.id,\n-                     None,\n                      item.attrs);\n         } else {\n             for body.node.stmts.iter().advance |stmt| {"}, {"sha": "4c07f88f16eba38b250708c08e63491fc53357e0", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 90, "deletions": 8, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -17,6 +17,7 @@\n // closure.\n \n use core::prelude::*;\n+use core::vec;\n \n use back::abi;\n use driver::session;\n@@ -194,6 +195,58 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n                                                type_params, vtables))}\n }\n \n+fn get_impl_resolutions(bcx: block,\n+                        impl_id: ast::def_id)\n+                         -> typeck::vtable_res {\n+    if impl_id.crate == ast::local_crate {\n+        *bcx.ccx().maps.vtable_map.get(&impl_id.node)\n+    } else {\n+        // XXX: This is a temporary hack to work around not properly\n+        // exporting information about resolutions for impls.\n+        // This doesn't actually work if the trait has param bounds,\n+        // but it does allow us to survive the case when it does not.\n+        let trait_ref = ty::impl_trait_ref(bcx.tcx(), impl_id).get();\n+        @vec::from_elem(trait_ref.substs.tps.len(), @~[])\n+    }\n+}\n+\n+fn resolve_default_method_vtables(bcx: block,\n+                                  impl_id: ast::def_id,\n+                                  method: &ty::Method,\n+                                  substs: &ty::substs,\n+                                  impl_vtables: Option<typeck::vtable_res>)\n+                                 -> typeck::vtable_res {\n+\n+    // Get the vtables that the impl implements the trait at\n+    let trait_vtables = get_impl_resolutions(bcx, impl_id);\n+\n+    // Build up a param_substs that we are going to resolve the\n+    // trait_vtables under.\n+    let param_substs = Some(@param_substs {\n+        tys: copy substs.tps,\n+        self_ty: substs.self_ty,\n+        vtables: impl_vtables,\n+        self_vtable: None\n+    });\n+\n+    let trait_vtables_fixed = resolve_vtables_under_param_substs(\n+        bcx.tcx(), param_substs, trait_vtables);\n+\n+    // Now we pull any vtables for parameters on the actual method.\n+    let num_method_vtables = method.generics.type_param_defs.len();\n+    let method_vtables = match impl_vtables {\n+        Some(vtables) => {\n+            let num_impl_type_parameters =\n+                vtables.len() - num_method_vtables;\n+            vtables.tailn(num_impl_type_parameters).to_owned()\n+        },\n+        None => vec::from_elem(num_method_vtables, @~[])\n+    };\n+\n+    @(*trait_vtables_fixed + method_vtables)\n+}\n+\n+\n pub fn trans_fn_ref_with_vtables(\n         bcx: block,            //\n         def_id: ast::def_id,   // def id of fn\n@@ -233,15 +286,21 @@ pub fn trans_fn_ref_with_vtables(\n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n \n-    let substs = ty::substs { self_r: None, self_ty: None,\n+    // For simplicity, we want to use the Subst trait when composing\n+    // substitutions for default methods.  The subst trait does\n+    // substitutions with regions, though, so we put a dummy self\n+    // region parameter in to keep it from failing. This is a hack.\n+    let substs = ty::substs { self_r: Some(ty::re_empty),\n+                              self_ty: None,\n                               tps: /*bad*/ type_params.to_owned() };\n \n \n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (def_id, opt_impl_did, substs) = match tcx.provided_method_sources.find(&def_id) {\n-        None => (def_id, None, substs),\n+    let (def_id, opt_impl_did, substs, self_vtable, vtables) =\n+        match tcx.provided_method_sources.find(&def_id) {\n+        None => (def_id, None, substs, None, vtables),\n         Some(source) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n@@ -261,20 +320,42 @@ pub fn trans_fn_ref_with_vtables(\n                          default methods\");\n             let method = ty::method(tcx, source.method_id);\n \n+            // Get all of the type params for the receiver\n+            let param_defs = method.generics.type_param_defs;\n+            let receiver_substs =\n+                type_params.initn(param_defs.len()).to_owned();\n+            let receiver_vtables = match vtables {\n+                None => @~[],\n+                Some(call_vtables) => {\n+                    @call_vtables.initn(param_defs.len()).to_owned()\n+                }\n+            };\n+\n+            let self_vtable =\n+                typeck::vtable_static(source.impl_id, receiver_substs,\n+                                      receiver_vtables);\n             // Compute the first substitution\n             let first_subst = make_substs_for_receiver_types(\n                 tcx, source.impl_id, trait_ref, method);\n \n             // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n+\n+\n+            let vtables =\n+                resolve_default_method_vtables(bcx, source.impl_id,\n+                                               method, &new_substs, vtables);\n+\n             debug!(\"trans_fn_with_vtables - default method: \\\n                     substs = %s, trait_subst = %s, \\\n-                    first_subst = %s, new_subst = %s\",\n+                    first_subst = %s, new_subst = %s, \\\n+                    self_vtable = %s, vtables = %s\",\n                    substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                   first_subst.repr(tcx), new_substs.repr(tcx));\n-\n+                   first_subst.repr(tcx), new_substs.repr(tcx),\n+                   self_vtable.repr(tcx), vtables.repr(tcx));\n \n-            (source.method_id, Some(source.impl_id), new_substs)\n+            (source.method_id, Some(source.impl_id),\n+             new_substs, Some(self_vtable), Some(vtables))\n         }\n     };\n \n@@ -321,7 +402,8 @@ pub fn trans_fn_ref_with_vtables(\n \n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n-                                         vtables, opt_impl_did, Some(ref_id));\n+                                         vtables, self_vtable,\n+                                         opt_impl_did, Some(ref_id));\n         let mut val = val;\n         if must_cast && ref_id != 0 {\n             // Monotype of the REFERENCE to the function (type params"}, {"sha": "ad68ffb402e1d35f9e5e1e492395696c9c787645", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -444,7 +444,6 @@ pub fn trans_expr_fn(bcx: block,\n                           no_self,\n                           /*bad*/ copy bcx.fcx.param_substs,\n                           user_id,\n-                          None,\n                           [],\n                           real_return_type,\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars,"}, {"sha": "7624fb13903f572a5bff24cd91b7493aa9ec01f5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -130,9 +130,9 @@ pub struct ValSelfData {\n // will only be set in the case of default methods.\n pub struct param_substs {\n     tys: ~[ty::t],\n+    self_ty: Option<ty::t>,\n     vtables: Option<typeck::vtable_res>,\n-    type_param_defs: @~[ty::TypeParameterDef],\n-    self_ty: Option<ty::t>\n+    self_vtable: Option<typeck::vtable_origin>\n }\n \n impl param_substs {\n@@ -143,10 +143,9 @@ impl param_substs {\n }\n \n fn param_substs_to_str(this: &param_substs, tcx: ty::ctxt) -> ~str {\n-    fmt!(\"param_substs {tys:%s, vtables:%s, type_param_defs:%s}\",\n+    fmt!(\"param_substs {tys:%s, vtables:%s}\",\n          this.tys.repr(tcx),\n-         this.vtables.repr(tcx),\n-         this.type_param_defs.repr(tcx))\n+         this.vtables.repr(tcx))\n }\n \n impl Repr for param_substs {\n@@ -223,9 +222,6 @@ pub struct fn_ctxt_ {\n     // a user-defined function.\n     id: ast::node_id,\n \n-    // The def_id of the impl we're inside, or None if we aren't inside one.\n-    impl_id: Option<ast::def_id>,\n-\n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n     param_substs: Option<@param_substs>,\n@@ -981,7 +977,11 @@ pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n         }\n-        _ => { assert!(!ty::type_has_params(t)); t }\n+        _ => {\n+            assert!(!ty::type_has_params(t));\n+            assert!(!ty::type_has_self(t));\n+            t\n+        }\n     }\n }\n \n@@ -1030,29 +1030,50 @@ pub fn node_vtables(bcx: block, id: ast::node_id)\n \n pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, copy *d))\n+    resolve_vtables_under_param_substs(fcx.ccx.tcx,\n+                                       fcx.param_substs,\n+                                       vts)\n+}\n+\n+pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n+                                          param_substs: Option<@param_substs>,\n+                                          vts: typeck::vtable_res)\n+    -> typeck::vtable_res {\n+    @vec::map(*vts, |ds|\n+      @vec::map(**ds, |d|\n+                resolve_vtable_under_param_substs(tcx, param_substs, copy *d)))\n }\n \n+\n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n // eliminate any vtable_params.\n pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n     -> typeck::vtable_origin {\n-    let tcx = fcx.ccx.tcx;\n+    resolve_vtable_under_param_substs(fcx.ccx.tcx,\n+                                      fcx.param_substs,\n+                                      vt)\n+}\n+\n+pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n+                                         param_substs: Option<@param_substs>,\n+                                         vt: typeck::vtable_origin)\n+    -> typeck::vtable_origin {\n     match vt {\n         typeck::vtable_static(trait_id, tys, sub) => {\n-            let tys = match fcx.param_substs {\n+            let tys = match param_substs {\n                 Some(substs) => {\n                     do vec::map(tys) |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n                     }\n                 }\n                 _ => tys\n             };\n-            typeck::vtable_static(trait_id, tys,\n-                                  resolve_vtables_in_fn_ctxt(fcx, sub))\n+            typeck::vtable_static(\n+                trait_id, tys,\n+                resolve_vtables_under_param_substs(tcx, param_substs, sub))\n         }\n         typeck::vtable_param(n_param, n_bound) => {\n-            match fcx.param_substs {\n+            match param_substs {\n                 Some(substs) => {\n                     find_vtable(tcx, substs, n_param, n_bound)\n                 }\n@@ -1063,6 +1084,19 @@ pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n                 }\n             }\n         }\n+        typeck::vtable_self(_trait_id) => {\n+            match param_substs {\n+                Some(@param_substs\n+                     {self_vtable: Some(ref self_vtable), _}) => {\n+                    copy *self_vtable\n+                }\n+                _ => {\n+                    tcx.sess.bug(fmt!(\n+                        \"resolve_vtable_in_fn_ctxt: asked to lookup but \\\n+                         no self_vtable in the fn_ctxt!\"))\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -1072,13 +1106,7 @@ pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     debug!(\"find_vtable(n_param=%u, n_bound=%u, ps=%s)\",\n            n_param, n_bound, ps.repr(tcx));\n \n-    // Vtables are stored in a flat array, finding the right one is\n-    // somewhat awkward\n-    let first_n_type_param_defs = ps.type_param_defs.slice(0, n_param);\n-    let vtables_to_skip =\n-        ty::count_traits_and_supertraits(tcx, first_n_type_param_defs);\n-    let vtable_off = vtables_to_skip + n_bound;\n-    /*bad*/ copy ps.vtables.get()[vtable_off]\n+    /*bad*/ copy ps.vtables.get()[n_param][n_bound]\n }\n \n pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {"}, {"sha": "7672f3b615d035ae7304026d559ba57568bf71e2", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -555,7 +555,6 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                                decl,\n                                item.id,\n                                output_type,\n-                               None,\n                                Some(substs),\n                                Some(item.span));\n \n@@ -1183,7 +1182,6 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                  no_self,\n                  None,\n                  id,\n-                 None,\n                  []);\n         return llfndecl;\n     }"}, {"sha": "11c02f165b6f707679ab9f6560cabe93ae88e58f", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -127,7 +127,6 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id,\n                        self_kind,\n                        None,\n                        mth.id,\n-                       Some(impl_did),\n                        []);\n           }\n           local_def(mth.id)"}, {"sha": "f145f83f13c2b56e76e25581d29e58094ae26075", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 47, "deletions": 86, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -68,8 +68,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n                          path,\n                          *method,\n                          None,\n-                         llfn,\n-                         ast_util::local_def(id));\n+                         llfn);\n         }\n     }\n }\n@@ -90,8 +89,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n                     path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n-                    llfn: ValueRef,\n-                    impl_id: ast::def_id) {\n+                    llfn: ValueRef) {\n     // figure out how self is being passed\n     let self_arg = match method.explicit_self.node {\n       ast::sty_static => {\n@@ -127,7 +125,6 @@ pub fn trans_method(ccx: @mut CrateContext,\n              self_arg,\n              param_substs,\n              method.id,\n-             Some(impl_id),\n              []);\n }\n \n@@ -139,7 +136,6 @@ pub fn trans_self_arg(bcx: block,\n \n     // Compute the type of self.\n     let self_ty = monomorphize_type(bcx, mentry.self_ty);\n-\n     let result = trans_arg_expr(bcx,\n                                 self_ty,\n                                 mentry.self_mode,\n@@ -174,21 +170,6 @@ pub fn trans_method_callee(bcx: block,\n     // Replace method_self with method_static here.\n     let mut origin = mentry.origin;\n     match origin {\n-        typeck::method_self(trait_id, method_index) => {\n-            // Get the ID of the impl we're inside.\n-            let impl_def_id = bcx.fcx.impl_id.get();\n-\n-            debug!(\"impl_def_id is %?\", impl_def_id);\n-\n-            // Get the ID of the method we're calling.\n-            let method_name =\n-                ty::trait_method(tcx, trait_id, method_index).ident;\n-            let method_id =\n-                method_with_name_or_default(bcx.ccx(),\n-                                            impl_def_id,\n-                                            method_name);\n-            origin = typeck::method_static(method_id);\n-        }\n         typeck::method_super(trait_id, method_index) => {\n             // <self_ty> is the self type for this method call\n             let self_ty = node_id_type(bcx, this.id);\n@@ -213,6 +194,7 @@ pub fn trans_method_callee(bcx: block,\n                                             impl_id,\n                                             method_name));\n         }\n+        typeck::method_self(*) |\n         typeck::method_static(*) | typeck::method_param(*) |\n         typeck::method_trait(*) => {}\n     }\n@@ -250,6 +232,21 @@ pub fn trans_method_callee(bcx: block,\n                 None => fail!(\"trans_method_callee: missing param_substs\")\n             }\n         }\n+\n+        typeck::method_self(trait_id, method_index) => {\n+            match bcx.fcx.param_substs {\n+                Some(@param_substs\n+                     {self_vtable: Some(ref vtbl), _}) => {\n+                    trans_monomorphized_callee(bcx, callee_id, this, mentry,\n+                                               trait_id, method_index,\n+                                               copy *vtbl)\n+                }\n+                _ => {\n+                    fail!(\"trans_method_callee: missing self_vtable\")\n+                }\n+            }\n+        }\n+\n         typeck::method_trait(_, off, store) => {\n             trans_trait_callee(bcx,\n                                callee_id,\n@@ -258,9 +255,9 @@ pub fn trans_method_callee(bcx: block,\n                                store,\n                                mentry.explicit_self)\n         }\n-        typeck::method_self(*) | typeck::method_super(*) => {\n-            fail!(\"method_self or method_super should have been handled \\\n-                above\")\n+            typeck::method_super(*) => {\n+            fail!(\"method_super should have been handled \\\n+                   above\")\n         }\n     }\n }\n@@ -292,15 +289,9 @@ pub fn trans_static_method_callee(bcx: block,\n     //\n     // So when we see a call to this function foo, we have to figure\n     // out which impl the `Trait<T1...Tn>` bound on the type `self` was\n-    // bound to.  Due to the fact that we use a flattened list of\n-    // impls, one per bound, this means we have to total up the bounds\n-    // found on the type parametesr T1...Tn to find the index of the\n-    // one we are interested in.\n-    let bound_index = {\n-        let trait_def = ty::lookup_trait_def(bcx.tcx(), trait_id);\n-        ty::count_traits_and_supertraits(\n-            bcx.tcx(), *trait_def.generics.type_param_defs)\n-    };\n+    // bound to.\n+    let bound_index = ty::lookup_trait_def(bcx.tcx(), trait_id).\n+        generics.type_param_defs.len();\n \n     let mname = if method_id.crate == ast::local_crate {\n         match bcx.tcx().items.get_copy(&method_id.node) {\n@@ -322,17 +313,17 @@ pub fn trans_static_method_callee(bcx: block,\n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n \n-    match vtbls[bound_index] {\n+    match vtbls[bound_index][0] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name_or_default(bcx.ccx(),\n                                                      impl_did,\n                                                      mname);\n-            let callee_substs = combine_impl_and_methods_tps(\n-                bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n-            let callee_origins = combine_impl_and_methods_origins(\n-                bcx, mth_id, impl_did, callee_id, rcvr_origins);\n+            let (callee_substs, callee_origins) =\n+                combine_impl_and_methods_tps(\n+                    bcx, mth_id, impl_did, callee_id,\n+                    *rcvr_substs, rcvr_origins);\n \n             let FnData {llfn: lval} =\n                 trans_fn_ref_with_vtables(bcx,\n@@ -428,10 +419,10 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n-          let callee_substs = combine_impl_and_methods_tps(\n-              bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n-          let callee_origins = combine_impl_and_methods_origins(\n-              bcx, mth_id, impl_did, callee_id, rcvr_origins);\n+          let (callee_substs, callee_origins) =\n+              combine_impl_and_methods_tps(\n+                  bcx, mth_id, impl_did, callee_id,\n+                  *rcvr_substs, rcvr_origins);\n \n           // translate the function\n           let callee = trans_fn_ref_with_vtables(bcx,\n@@ -460,6 +451,9 @@ pub fn trans_monomorphized_callee(bcx: block,\n       typeck::vtable_param(*) => {\n           fail!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n+      typeck::vtable_self(*) => {\n+          fail!(\"vtable_self left in monomorphized function's vtable substs\");\n+      }\n     };\n \n }\n@@ -468,8 +462,9 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n                                     mth_did: ast::def_id,\n                                     impl_did: ast::def_id,\n                                     callee_id: ast::node_id,\n-                                    rcvr_substs: &[ty::t])\n-                                    -> ~[ty::t] {\n+                                    rcvr_substs: &[ty::t],\n+                                    rcvr_origins: typeck::vtable_res)\n+                                    -> (~[ty::t], typeck::vtable_res) {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -498,52 +493,18 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n     debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n \n-    return ty_substs;\n-}\n \n-pub fn combine_impl_and_methods_origins(bcx: block,\n-                                        mth_did: ast::def_id,\n-                                        impl_did: ast::def_id,\n-                                        callee_id: ast::node_id,\n-                                        rcvr_origins: typeck::vtable_res)\n-                                     -> typeck::vtable_res {\n-    /*!\n-     *\n-     * Similar to `combine_impl_and_methods_tps`, but for vtables.\n-     * This is much messier because of the flattened layout we are\n-     * currently using (for some reason that I fail to understand).\n-     * The proper fix is described in #3446.\n-     */\n-\n-\n-    // Find the bounds for the method, which are the tail of the\n-    // bounds found in the item type, as the item type combines the\n-    // rcvr + method bounds.\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n-    let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n-    let ty::ty_param_bounds_and_ty {\n-        generics: r_m_generics,\n-        _\n-    } = ty::lookup_item_type(tcx, mth_did);\n-    let n_r_m_tps = r_m_generics.type_param_defs.len(); // rcvr + method tps\n-    let m_type_param_defs =\n-        r_m_generics.type_param_defs.slice(n_r_m_tps - n_m_tps, n_r_m_tps);\n-\n-    // Flatten out to find the number of vtables the method expects.\n-    let m_vtables = ty::count_traits_and_supertraits(tcx, m_type_param_defs);\n-\n-    // Find the vtables we computed at type check time and monomorphize them\n+    // Now, do the same work for the vtables.  The vtables might not\n+    // exist, in which case we need to make them.\n     let r_m_origins = match node_vtables(bcx, callee_id) {\n         Some(vt) => vt,\n-        None => @~[]\n+        None => @vec::from_elem(node_substs.len(), @~[])\n     };\n+    let vtables\n+        = @vec::append(rcvr_origins.to_owned(),\n+                       r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n \n-    // Extract those that belong to method:\n-    let m_origins = r_m_origins.tailn(r_m_origins.len() - m_vtables);\n-\n-    // Combine rcvr + method to find the final result:\n-    @vec::append(/*bad*/copy *rcvr_origins, m_origins)\n+    return (ty_substs, vtables);\n }\n \n \n@@ -842,7 +803,7 @@ pub fn trans_trait_cast(bcx: block,\n     bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n \n     // Store the vtable into the pair or triple.\n-    let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0];\n+    let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0][0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx, v_ty, orig);\n     Store(bcx, vtable, PointerCast(bcx,"}, {"sha": "92d8192aee6298236e0824ae57f3ec2b0a0ee7b4", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -43,6 +43,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       fn_id: ast::def_id,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n+                      self_vtable: Option<typeck::vtable_origin>,\n                       impl_did_opt: Option<ast::def_id>,\n                       ref_id: Option<ast::node_id>)\n     -> (ValueRef, bool)\n@@ -165,6 +166,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let mut pt = /* bad */copy (*pt);\n     pt.push(elt);\n     let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n+    debug!(\"monomorphize_fn mangled to %s\", s);\n \n     let mk_lldecl = || {\n         let lldecl = decl_internal_cdecl_fn(ccx.llmod, /*bad*/copy s, llfty);\n@@ -175,8 +177,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let psubsts = Some(@param_substs {\n         tys: substs,\n         vtables: vtables,\n-        type_param_defs: tpt.generics.type_param_defs,\n-        self_ty: real_substs.self_ty\n+        self_ty: real_substs.self_ty,\n+        self_vtable: self_vtable\n     });\n \n     let lldecl = match map_node {\n@@ -194,7 +196,6 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                  no_self,\n                  psubsts,\n                  fn_id.node,\n-                 None,\n                  []);\n         d\n       }\n@@ -222,27 +223,17 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         }\n         d\n       }\n-      ast_map::node_method(mth, supplied_impl_did, _) => {\n+      ast_map::node_method(mth, _, _) => {\n         // XXX: What should the self type be here?\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n-\n-        // Override the impl def ID if necessary.\n-        let impl_did;\n-        match impl_did_opt {\n-            None => impl_did = supplied_impl_did,\n-            Some(override_impl_did) => impl_did = override_impl_did\n-        }\n-\n-        meth::trans_method(ccx, pt, mth, psubsts, d, impl_did);\n+        meth::trans_method(ccx, pt, mth, psubsts, d);\n         d\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n-        debug!(\"monomorphic_fn impl_did_opt is %?\", impl_did_opt);\n-        meth::trans_method(ccx, /*bad*/copy *pt, mth, psubsts, d,\n-                           impl_did_opt.get());\n+        meth::trans_method(ccx, /*bad*/copy *pt, mth, psubsts, d);\n         d\n       }\n       ast_map::node_struct_ctor(struct_def, _, _) => {\n@@ -337,14 +328,10 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n-        let item_ty = ty::lookup_item_type(ccx.tcx, item);\n-        let mut i = 0;\n-        vec::map_zip(*item_ty.generics.type_param_defs, substs, |type_param_def, subst| {\n-            let mut v = ~[];\n-            for type_param_def.bounds.trait_bounds.iter().advance |_bound| {\n-                v.push(meth::vtable_id(ccx, &vts[i]));\n-                i += 1;\n-            }\n+        debug!(\"make_mono_id vtables=%s substs=%s\",\n+               vts.repr(ccx.tcx), substs.repr(ccx.tcx));\n+        vec::map_zip(*vts, substs, |vtable, subst| {\n+            let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n         })\n       }"}, {"sha": "23266767124c89ead730d5c6202e2dc275ae78bb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -609,6 +609,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         for ms.iter().advance |m| {\n             check_method(ccx, *m);\n         }\n+        vtable::resolve_impl(ccx, it);\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n         for (*trait_methods).iter().advance |trait_method| {"}, {"sha": "0bf20f9fbcb94a59d79a8534f49f9579e2fb0a62", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -17,8 +17,8 @@ use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::infer::fixup_err_to_str;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n-use middle::typeck::{CrateCtxt, vtable_origin, vtable_param, vtable_res};\n-use middle::typeck::vtable_static;\n+use middle::typeck::{CrateCtxt, vtable_origin, vtable_res};\n+use middle::typeck::{vtable_static, vtable_param, vtable_self};\n use middle::subst::Subst;\n use util::common::indenter;\n use util::ppaux::tys_to_str;\n@@ -90,6 +90,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     let mut i = 0u;\n     for substs.tps.iter().advance |ty| {\n         // ty is the value supplied for the type parameter A...\n+        let mut param_result = ~[];\n \n         for ty::each_bound_trait_and_supertraits(\n             tcx, type_param_defs[i].bounds) |trait_ref|\n@@ -106,7 +107,7 @@ fn lookup_vtables(vcx: &VtableContext,\n             debug!(\"after subst: %s\", trait_ref.repr(tcx));\n \n             match lookup_vtable(vcx, location_info, *ty, &trait_ref, is_early) {\n-                Some(vtable) => result.push(vtable),\n+                Some(vtable) => param_result.push(vtable),\n                 None => {\n                     vcx.tcx().sess.span_fatal(\n                         location_info.span,\n@@ -117,6 +118,7 @@ fn lookup_vtables(vcx: &VtableContext,\n                 }\n             }\n         }\n+        result.push(@param_result);\n         i += 1u;\n     }\n     debug!(\"lookup_vtables result(\\\n@@ -237,6 +239,17 @@ fn lookup_vtable(vcx: &VtableContext,\n             }\n         }\n \n+        ty::ty_self(trait_id) => {\n+            debug!(\"trying to find %? vtable for type %?\",\n+                   trait_ref.def_id, trait_id);\n+\n+            if trait_id == trait_ref.def_id {\n+                let vtable = vtable_self(trait_id);\n+                debug!(\"found self vtable: %?\", vtable);\n+                return Some(vtable);\n+            }\n+        }\n+\n         _ => {\n             let mut found = ~[];\n \n@@ -467,6 +480,12 @@ pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n         id: expr.id\n     }\n }\n+pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n+    LocationInfo {\n+        span: item.span,\n+        id: item.id\n+    }\n+}\n \n pub fn early_resolve_expr(ex: @ast::expr,\n                           fcx: @mut FnCtxt,\n@@ -583,7 +602,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                   // vtable (that is: \"ex has vtable\n                                   // <vtable>\")\n                                   if !is_early {\n-                                      insert_vtables(fcx, ex.id, @~[vtable]);\n+                                      insert_vtables(fcx, ex.id,\n+                                                     @~[@~[vtable]]);\n                                   }\n                               }\n                               None => {\n@@ -650,6 +670,27 @@ fn resolve_expr(ex: @ast::expr,\n     visit::visit_expr(ex, (fcx, v));\n }\n \n+pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n+    let def_id = ast_util::local_def(impl_item.id);\n+    match ty::impl_trait_ref(ccx.tcx, def_id) {\n+        None => {},\n+        Some(trait_ref) => {\n+            let infcx = infer::new_infer_ctxt(ccx.tcx);\n+            let vcx = VtableContext { ccx: ccx, infcx: infcx };\n+            let trait_def = ty::lookup_trait_def(ccx.tcx, trait_ref.def_id);\n+\n+            let vtbls = lookup_vtables(&vcx,\n+                                       &location_info_for_item(impl_item),\n+                                       *trait_def.generics.type_param_defs,\n+                                       &trait_ref.substs,\n+                                       false);\n+\n+            // FIXME(#7450): Doesn't work cross crate\n+            ccx.vtable_map.insert(impl_item.id, vtbls);\n+        }\n+    }\n+}\n+\n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n pub fn resolve_in_block(fcx: @mut FnCtxt, bl: &ast::blk) {"}, {"sha": "e2efdc51fcad4bacbc57a0d55f10d5284c9a39ff", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -20,7 +20,8 @@ use middle::typeck::check::{FnCtxt, SelfInfo};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n-use middle::typeck::{vtable_origin, vtable_static, vtable_param};\n+use middle::typeck::{vtable_res, vtable_origin};\n+use middle::typeck::{vtable_static, vtable_param, vtable_self};\n use middle::typeck::method_map_entry;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n@@ -84,26 +85,34 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     match fcx.inh.vtable_map.find(&id) {\n         None => {}\n         Some(origins) => {\n-            let r_origins = @origins.map(|o| resolve_origin(fcx, sp, o));\n+            let r_origins = resolve_origins(fcx, sp, *origins);\n             let vtable_map = fcx.ccx.vtable_map;\n             vtable_map.insert(id, r_origins);\n             debug!(\"writeback::resolve_vtable_map_entry(id=%d, vtables=%?)\",\n                    id, r_origins.repr(fcx.tcx()));\n         }\n     }\n \n+    fn resolve_origins(fcx: @mut FnCtxt, sp: span,\n+                       vtbls: vtable_res) -> vtable_res {\n+        @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n+    }\n+\n     fn resolve_origin(fcx: @mut FnCtxt,\n                       sp: span,\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n             &vtable_static(def_id, ref tys, origins) => {\n                 let r_tys = resolve_type_vars_in_types(fcx, sp, *tys);\n-                let r_origins = @origins.map(|o| resolve_origin(fcx, sp, o));\n+                let r_origins = resolve_origins(fcx, sp, origins);\n                 vtable_static(def_id, r_tys, r_origins)\n             }\n             &vtable_param(n, b) => {\n                 vtable_param(n, b)\n             }\n+            &vtable_self(def_id) => {\n+                vtable_self(def_id)\n+            }\n         }\n     }\n }"}, {"sha": "98f7af4bfd4de53a9de6028b2aa8a1498fa403a7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -135,8 +135,9 @@ pub struct method_map_entry {\n // of the method to be invoked\n pub type method_map = @mut HashMap<ast::node_id, method_map_entry>;\n \n+pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = @~[vtable_origin];\n+pub type vtable_res = @~[vtable_param_res];\n \n pub enum vtable_origin {\n     /*\n@@ -154,7 +155,12 @@ pub enum vtable_origin {\n       The first uint is the param number (identifying T in the example),\n       and the second is the bound number (identifying baz)\n      */\n-    vtable_param(uint, uint)\n+    vtable_param(uint, uint),\n+\n+    /*\n+     Dynamic vtable, comes from self.\n+    */\n+    vtable_self(ast::def_id)\n }\n \n impl Repr for vtable_origin {\n@@ -171,6 +177,9 @@ impl Repr for vtable_origin {\n             vtable_param(x, y) => {\n                 fmt!(\"vtable_param(%?, %?)\", x, y)\n             }\n+            vtable_self(def_id) => {\n+                fmt!(\"vtable_self(%?)\", def_id)\n+            }\n         }\n     }\n }"}, {"sha": "8555d99255d5a98493ed8f9eb37db48b3994f2ab", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -2346,6 +2346,7 @@ impl<T> FromIter<T> for ~[T]{\n     }\n }\n \n+#[cfg(stage0)]\n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {\n         let mut xs = ~[];\n@@ -2356,7 +2357,8 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     }\n }\n \n-/* FIXME: #7341 - ICE\n+\n+#[cfg(not(stage0))]\n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n@@ -2367,7 +2369,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n         xs\n     }\n }\n-*/\n+\n \n #[cfg(test)]\n mod tests {"}, {"sha": "00c415a860d4fe385913c33d09b6be67768aed7b", "filename": "src/test/compile-fail/impl-bounds-checking.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Ftest%2Fcompile-fail%2Fimpl-bounds-checking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Ftest%2Fcompile-fail%2Fimpl-bounds-checking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-bounds-checking.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Clone2 {\n+    fn clone(&self) -> Self;\n+}\n+\n+\n+trait Getter<T: Clone2> {\n+    fn get(&self) -> T;\n+}\n+\n+impl Getter<int> for int { //~ ERROR failed to find an implementation of trait Clone2 for int\n+    fn get(&self) -> int { *self }\n+}\n+\n+fn main() { }"}, {"sha": "4fc5587e7f36d28da867b3274a5da33f2320a200", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(default_methods)]\n+trait Speak {\n+    fn say(&self, s:&str) -> ~str;\n+    fn hi(&self) -> ~str { hello(self) }\n+}\n+\n+fn hello<S:Speak>(s:&S) -> ~str{\n+    s.say(\"hello\")\n+}\n+\n+impl Speak for int {\n+    fn say(&self, s:&str) -> ~str {\n+        fmt!(\"%s: %d\", s, *self)\n+    }\n+}\n+\n+impl<T: Speak> Speak for Option<T> {\n+    fn say(&self, s:&str) -> ~str {\n+        match *self {\n+            None => fmt!(\"%s - none\", s),\n+            Some(ref x) => { ~\"something!\" + x.say(s) }\n+        }\n+    }\n+}\n+\n+\n+fn main() {\n+    assert_eq!(3.hi(), ~\"hello: 3\");\n+    assert_eq!(Some(Some(3)).hi(), ~\"something!something!hello: 3\");\n+    assert_eq!(None::<int>.hi(), ~\"hello - none\");\n+\n+    // These fail because of a bug in monomorphization's ID generation.\n+    //assert_eq!(Some(None::<int>).hi(), ~\"something!hello - none\");\n+    //assert_eq!(Some(3).hi(), ~\"something!hello: 3\");\n+}"}, {"sha": "b3ddbbb9dc112a542ad7625677b2cd7f7d3984c3", "filename": "src/test/run-pass/trait-with-bounds-default.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d681bccb6a2141012a747cc272991a7440cb2408/src%2Ftest%2Frun-pass%2Ftrait-with-bounds-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d681bccb6a2141012a747cc272991a7440cb2408/src%2Ftest%2Frun-pass%2Ftrait-with-bounds-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-with-bounds-default.rs?ref=d681bccb6a2141012a747cc272991a7440cb2408", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Clone2 {\n+    /// Returns a copy of the value. The contents of owned pointers\n+    /// are copied to maintain uniqueness, while the contents of\n+    /// managed pointers are not copied.\n+    fn clone(&self) -> Self;\n+}\n+\n+#[allow(default_methods)]\n+trait Getter<T: Clone> {\n+    fn do_get(&self) -> T;\n+\n+    fn do_get2(&self) -> (T, T) {\n+        let x = self.do_get();\n+        (x.clone(), x.clone())\n+    }\n+\n+}\n+\n+impl Getter<int> for int {\n+    fn do_get(&self) -> int { *self }\n+}\n+\n+impl<T: Clone> Getter<T> for Option<T> {\n+    fn do_get(&self) -> T { self.get_ref().clone() }\n+}\n+\n+\n+fn main() {\n+    assert_eq!(3.do_get2(), (3, 3));\n+    assert_eq!(Some(~\"hi\").do_get2(), (~\"hi\", ~\"hi\"));\n+}"}]}