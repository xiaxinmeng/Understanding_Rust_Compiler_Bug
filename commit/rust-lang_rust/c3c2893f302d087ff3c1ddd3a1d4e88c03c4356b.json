{"sha": "c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYzI4OTNmMzAyZDA4N2ZmM2MxZGRkM2ExZDRlODhjMDNjNDM1NmI=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-22T15:17:27Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:45Z"}, "message": "Update match checking.\n\nfn is_useful , more skeletons\n\nSpecify a lifetime on pattern references\n\nimpl PatStack\n\nfill impl Matrix\n\nPatStack::pop_head_constructor\n\nIndex-based approach\n\nstruct PatCtxt\n\nfields construction fn Fields::wildcards\n\nsplit wildcard\n\nfn Constructor::is_covered_by_any(..)\n\nfn Matrix::specialize_constructor(..)\n\nimpl Usefulness\n\nInitial work on witness construction\n\nReorganize files\n\nReplace match checking diagnostic\n\nHandle types of expanded patterns\n\nunit match checking go brrr", "tree": {"sha": "dc24743a4482f625b287c697f3ef17bfbfb9097f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc24743a4482f625b287c697f3ef17bfbfb9097f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "html_url": "https://github.com/rust-lang/rust/commit/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c1d8ca63510bb719fd91bbf38692e45b19c04d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c1d8ca63510bb719fd91bbf38692e45b19c04d6", "html_url": "https://github.com/rust-lang/rust/commit/7c1d8ca63510bb719fd91bbf38692e45b19c04d6"}], "stats": {"total": 1472, "additions": 1471, "deletions": 1}, "files": [{"sha": "4b714c6d8e4977015794ba943ab064e6e0ab72da", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "patch": "@@ -22,6 +22,7 @@ chalk-solve = { version = \"0.68\", default-features = false }\n chalk-ir = \"0.68\"\n chalk-recursive = \"0.68\"\n la-arena = { version = \"0.2.0\", path = \"../../lib/arena\" }\n+once_cell = { version = \"1.5.0\" }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n hir_def = { path = \"../hir_def\", version = \"0.0.0\" }"}, {"sha": "87a3594c52c85a93ea024c5365a3b29aae8afb08", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "patch": "@@ -1,6 +1,8 @@\n //! Type inference-based diagnostics.\n mod expr;\n+#[allow(unused)] //todo\n mod match_check;\n+mod pattern;\n mod unsafe_check;\n mod decl_check;\n "}, {"sha": "ea70a5f9f62b694ddd88fa25161c9aa7167075c6", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n             match expr {\n                 Expr::Match { expr, arms } => {\n-                    self.validate_match(id, *expr, arms, db, self.infer.clone());\n+                    self.validate_match2(id, *expr, arms, db, self.infer.clone());\n                 }\n                 Expr::Call { .. } | Expr::MethodCall { .. } => {\n                     self.validate_call(db, id, expr);\n@@ -277,6 +277,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n+    #[allow(dead_code)]\n     fn validate_match(\n         &mut self,\n         id: ExprId,\n@@ -358,6 +359,73 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n+    fn validate_match2(\n+        &mut self,\n+        id: ExprId,\n+        match_expr: ExprId,\n+        arms: &[MatchArm],\n+        db: &dyn HirDatabase,\n+        infer: Arc<InferenceResult>,\n+    ) {\n+        use crate::diagnostics::pattern::usefulness;\n+        use hir_def::HasModule;\n+\n+        let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n+            db.body_with_source_map(self.owner);\n+\n+        let match_expr_ty = if infer.type_of_expr[match_expr].is_unknown() {\n+            return;\n+        } else {\n+            &infer.type_of_expr[match_expr]\n+        };\n+        eprintln!(\"ExprValidator::validate_match2({:?})\", match_expr_ty.kind(&Interner));\n+\n+        let pattern_arena = usefulness::PatternArena::clone_from(&body.pats);\n+        let cx = usefulness::MatchCheckCtx {\n+            krate: self.owner.module(db.upcast()).krate(),\n+            match_expr,\n+            body,\n+            infer: &infer,\n+            db,\n+            pattern_arena: &pattern_arena,\n+        };\n+\n+        let m_arms: Vec<_> = arms\n+            .iter()\n+            .map(|arm| usefulness::MatchArm { pat: arm.pat, has_guard: arm.guard.is_some() })\n+            .collect();\n+\n+        let report = usefulness::compute_match_usefulness(&cx, &m_arms);\n+\n+        // TODO Report unreacheble arms\n+        // let mut catchall = None;\n+        // for (arm_index, (arm, is_useful)) in report.arm_usefulness.iter().enumerate() {\n+        //     match is_useful{\n+        //         Unreachable => {\n+        //         }\n+        //         Reachable(_) => {}\n+        //     }\n+        // }\n+\n+        let witnesses = report.non_exhaustiveness_witnesses;\n+        if !witnesses.is_empty() {\n+            if let Ok(source_ptr) = source_map.expr_syntax(id) {\n+                let root = source_ptr.file_syntax(db.upcast());\n+                if let ast::Expr::MatchExpr(match_expr) = &source_ptr.value.to_node(&root) {\n+                    if let (Some(match_expr), Some(arms)) =\n+                        (match_expr.expr(), match_expr.match_arm_list())\n+                    {\n+                        self.sink.push(MissingMatchArms {\n+                            file: source_ptr.file_id,\n+                            match_expr: AstPtr::new(&match_expr),\n+                            arms: AstPtr::new(&arms),\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn validate_results_in_tail_expr(&mut self, body_id: ExprId, id: ExprId, db: &dyn HirDatabase) {\n         // the mismatch will be on the whole block currently\n         let mismatch = match self.infer.type_mismatch_for_expr(body_id) {"}, {"sha": "28c7a244d6378a6dc88a167e2b20b77e14c12beb", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "patch": "@@ -0,0 +1,36 @@\n+#![deny(elided_lifetimes_in_paths)]\n+#![allow(unused)] // todo remove\n+\n+mod deconstruct_pat;\n+pub mod usefulness;\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unit_exhaustive() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match ()   { ()   => {} }\n+    match ()   { _    => {} }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unit_non_exhaustive() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match ()   {            }\n+        //^^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "cde04409e01d306c122a864c6dbb6f42df38e5c6", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "patch": "@@ -0,0 +1,627 @@\n+use hir_def::{\n+    expr::{Pat, PatId},\n+    AttrDefId, EnumVariantId, HasModule, VariantId,\n+};\n+\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n+\n+use super::usefulness::{MatchCheckCtx, PatCtxt};\n+\n+use self::Constructor::*;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(super) enum ToDo {}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(super) struct IntRange {\n+    range: ToDo,\n+}\n+\n+impl IntRange {\n+    #[inline]\n+    fn is_integral(ty: &Ty) -> bool {\n+        match ty.kind(&Interner) {\n+            TyKind::Scalar(Scalar::Char)\n+            | TyKind::Scalar(Scalar::Int(_))\n+            | TyKind::Scalar(Scalar::Uint(_))\n+            | TyKind::Scalar(Scalar::Bool) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by(&self, other: &Self) -> bool {\n+        todo!()\n+    }\n+}\n+\n+/// A constructor for array and slice patterns.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(super) struct Slice {\n+    todo: ToDo,\n+}\n+\n+impl Slice {\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by(self, other: Self) -> bool {\n+        todo!()\n+    }\n+}\n+\n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// the constructor. See also `Fields`.\n+///\n+/// `pat_constructor` retrieves the constructor corresponding to a pattern.\n+/// `specialize_constructor` returns the list of fields corresponding to a pattern, given a\n+/// constructor. `Constructor::apply` reconstructs the pattern from a pair of `Constructor` and\n+/// `Fields`.\n+#[derive(Clone, Debug, PartialEq)]\n+pub(super) enum Constructor {\n+    /// The constructor for patterns that have a single constructor, like tuples, struct patterns\n+    /// and fixed-length arrays.\n+    Single,\n+    /// Enum variants.\n+    Variant(EnumVariantId),\n+    /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n+    IntRange(IntRange),\n+    /// Array and slice patterns.\n+    Slice(Slice),\n+    /// Stands for constructors that are not seen in the matrix, as explained in the documentation\n+    /// for [`SplitWildcard`].\n+    Missing,\n+    /// Wildcard pattern.\n+    Wildcard,\n+}\n+\n+impl Constructor {\n+    pub(super) fn is_wildcard(&self) -> bool {\n+        matches!(self, Wildcard)\n+    }\n+\n+    fn as_int_range(&self) -> Option<&IntRange> {\n+        match self {\n+            IntRange(range) => Some(range),\n+            _ => None,\n+        }\n+    }\n+\n+    fn as_slice(&self) -> Option<Slice> {\n+        match self {\n+            Slice(slice) => Some(*slice),\n+            _ => None,\n+        }\n+    }\n+\n+    fn variant_id_for_adt(&self, adt: hir_def::AdtId, cx: &MatchCheckCtx<'_>) -> VariantId {\n+        match *self {\n+            Variant(id) => id.into(),\n+            Single => {\n+                assert!(!matches!(adt, hir_def::AdtId::EnumId(_)));\n+                match adt {\n+                    hir_def::AdtId::EnumId(_) => unreachable!(),\n+                    hir_def::AdtId::StructId(id) => id.into(),\n+                    hir_def::AdtId::UnionId(id) => id.into(),\n+                }\n+            }\n+            _ => panic!(\"bad constructor {:?} for adt {:?}\", self, adt),\n+        }\n+    }\n+\n+    pub(super) fn from_pat(cx: &MatchCheckCtx<'_>, pat: PatId) -> Self {\n+        match &cx.pattern_arena.borrow()[pat] {\n+            Pat::Bind { .. } | Pat::Wild => Wildcard,\n+            Pat::Tuple { .. } | Pat::Ref { .. } | Pat::Box { .. } => Single,\n+\n+            pat => todo!(\"Constructor::from_pat {:?}\", pat),\n+            // Pat::Missing => {}\n+            // Pat::Or(_) => {}\n+            // Pat::Record { path, args, ellipsis } => {}\n+            // Pat::Range { start, end } => {}\n+            // Pat::Slice { prefix, slice, suffix } => {}\n+            // Pat::Path(_) => {}\n+            // Pat::Lit(_) => {}\n+            // Pat::TupleStruct { path, args, ellipsis } => {}\n+            // Pat::ConstBlock(_) => {}\n+        }\n+    }\n+\n+    /// Some constructors (namely `Wildcard`, `IntRange` and `Slice`) actually stand for a set of actual\n+    /// constructors (like variants, integers or fixed-sized slices). When specializing for these\n+    /// constructors, we want to be specialising for the actual underlying constructors.\n+    /// Naively, we would simply return the list of constructors they correspond to. We instead are\n+    /// more clever: if there are constructors that we know will behave the same wrt the current\n+    /// matrix, we keep them grouped. For example, all slices of a sufficiently large length\n+    /// will either be all useful or all non-useful with a given matrix.\n+    ///\n+    /// See the branches for details on how the splitting is done.\n+    ///\n+    /// This function may discard some irrelevant constructors if this preserves behavior and\n+    /// diagnostics. Eg. for the `_` case, we ignore the constructors already present in the\n+    /// matrix, unless all of them are.\n+    pub(super) fn split<'a>(\n+        &self,\n+        pcx: &PatCtxt<'_>,\n+        ctors: impl Iterator<Item = &'a Constructor> + Clone,\n+    ) -> SmallVec<[Self; 1]> {\n+        match self {\n+            Wildcard => {\n+                let mut split_wildcard = SplitWildcard::new(pcx);\n+                split_wildcard.split(pcx, ctors);\n+                split_wildcard.into_ctors(pcx)\n+            }\n+            // Fast-track if the range is trivial. In particular, we don't do the overlapping\n+            // ranges check.\n+            IntRange(_) => todo!(\"Constructor::split IntRange\"),\n+            Slice(_) => todo!(\"Constructor::split Slice\"),\n+            // Any other constructor can be used unchanged.\n+            _ => smallvec![self.clone()],\n+        }\n+    }\n+\n+    /// Returns whether `self` is covered by `other`, i.e. whether `self` is a subset of `other`.\n+    /// For the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n+    /// this checks for inclusion.\n+    // We inline because this has a single call site in `Matrix::specialize_constructor`.\n+    #[inline]\n+    pub(super) fn is_covered_by(&self, pcx: &PatCtxt<'_>, other: &Self) -> bool {\n+        // This must be kept in sync with `is_covered_by_any`.\n+        match (self, other) {\n+            // Wildcards cover anything\n+            (_, Wildcard) => true,\n+            // The missing ctors are not covered by anything in the matrix except wildcards.\n+            (Missing, _) | (Wildcard, _) => false,\n+\n+            (Single, Single) => true,\n+            (Variant(self_id), Variant(other_id)) => self_id == other_id,\n+\n+            (Constructor::IntRange(_), Constructor::IntRange(_)) => todo!(),\n+\n+            (Constructor::Slice(_), Constructor::Slice(_)) => todo!(),\n+\n+            _ => panic!(\"bug\"),\n+        }\n+    }\n+\n+    /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n+    /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n+    /// assumed to have been split from a wildcard.\n+    fn is_covered_by_any(&self, pcx: &PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n+        if used_ctors.is_empty() {\n+            return false;\n+        }\n+\n+        // This must be kept in sync with `is_covered_by`.\n+        match self {\n+            // If `self` is `Single`, `used_ctors` cannot contain anything else than `Single`s.\n+            Single => !used_ctors.is_empty(),\n+            Variant(_) => used_ctors.iter().any(|c| c == self),\n+            IntRange(range) => used_ctors\n+                .iter()\n+                .filter_map(|c| c.as_int_range())\n+                .any(|other| range.is_covered_by(other)),\n+            Slice(slice) => used_ctors\n+                .iter()\n+                .filter_map(|c| c.as_slice())\n+                .any(|other| slice.is_covered_by(other)),\n+\n+            _ => todo!(),\n+        }\n+    }\n+}\n+\n+/// A wildcard constructor that we split relative to the constructors in the matrix, as explained\n+/// at the top of the file.\n+///\n+/// A constructor that is not present in the matrix rows will only be covered by the rows that have\n+/// wildcards. Thus we can group all of those constructors together; we call them \"missing\n+/// constructors\". Splitting a wildcard would therefore list all present constructors individually\n+/// (or grouped if they are integers or slices), and then all missing constructors together as a\n+/// group.\n+///\n+/// However we can go further: since any constructor will match the wildcard rows, and having more\n+/// rows can only reduce the amount of usefulness witnesses, we can skip the present constructors\n+/// and only try the missing ones.\n+/// This will not preserve the whole list of witnesses, but will preserve whether the list is empty\n+/// or not. In fact this is quite natural from the point of view of diagnostics too. This is done\n+/// in `to_ctors`: in some cases we only return `Missing`.\n+#[derive(Debug)]\n+pub(super) struct SplitWildcard {\n+    /// Constructors seen in the matrix.\n+    matrix_ctors: Vec<Constructor>,\n+    /// All the constructors for this type\n+    all_ctors: SmallVec<[Constructor; 1]>,\n+}\n+\n+impl SplitWildcard {\n+    pub(super) fn new(pcx: &PatCtxt<'_>) -> Self {\n+        // let cx = pcx.cx;\n+        // let make_range = |start, end| IntRange(todo!());\n+\n+        // This determines the set of all possible constructors for the type `pcx.ty`. For numbers,\n+        // arrays and slices we use ranges and variable-length slices when appropriate.\n+        //\n+        // If the `exhaustive_patterns` feature is enabled, we make sure to omit constructors that\n+        // are statically impossible. E.g., for `Option<!>`, we do not include `Some(_)` in the\n+        // returned list of constructors.\n+        // Invariant: this is empty if and only if the type is uninhabited (as determined by\n+        // `cx.is_uninhabited()`).\n+        let all_ctors = match pcx.ty.kind(&Interner) {\n+            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(_)), _) => todo!(),\n+            TyKind::Adt(..) | TyKind::Tuple(..) | TyKind::Ref(..) => smallvec![Single],\n+            _ => todo!(),\n+        };\n+        SplitWildcard { matrix_ctors: Vec::new(), all_ctors }\n+    }\n+\n+    /// Pass a set of constructors relative to which to split this one. Don't call twice, it won't\n+    /// do what you want.\n+    pub(super) fn split<'a>(\n+        &mut self,\n+        pcx: &PatCtxt<'_>,\n+        ctors: impl Iterator<Item = &'a Constructor> + Clone,\n+    ) {\n+        // Since `all_ctors` never contains wildcards, this won't recurse further.\n+        self.all_ctors =\n+            self.all_ctors.iter().flat_map(|ctor| ctor.split(pcx, ctors.clone())).collect();\n+        self.matrix_ctors = ctors.filter(|c| !c.is_wildcard()).cloned().collect();\n+    }\n+\n+    /// Whether there are any value constructors for this type that are not present in the matrix.\n+    fn any_missing(&self, pcx: &PatCtxt<'_>) -> bool {\n+        self.iter_missing(pcx).next().is_some()\n+    }\n+\n+    /// Iterate over the constructors for this type that are not present in the matrix.\n+    pub(super) fn iter_missing<'a>(\n+        &'a self,\n+        pcx: &'a PatCtxt<'_>,\n+    ) -> impl Iterator<Item = &'a Constructor> {\n+        self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n+    }\n+\n+    /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n+    /// top of the file, if any constructors are missing we can ignore the present ones.\n+    fn into_ctors(self, pcx: &PatCtxt<'_>) -> SmallVec<[Constructor; 1]> {\n+        if self.any_missing(pcx) {\n+            // Some constructors are missing, thus we can specialize with the special `Missing`\n+            // constructor, which stands for those constructors that are not seen in the matrix,\n+            // and matches the same rows as any of them (namely the wildcard rows). See the top of\n+            // the file for details.\n+            // However, when all constructors are missing we can also specialize with the full\n+            // `Wildcard` constructor. The difference will depend on what we want in diagnostics.\n+\n+            // If some constructors are missing, we typically want to report those constructors,\n+            // e.g.:\n+            // ```\n+            //     enum Direction { N, S, E, W }\n+            //     let Direction::N = ...;\n+            // ```\n+            // we can report 3 witnesses: `S`, `E`, and `W`.\n+            //\n+            // However, if the user didn't actually specify a constructor\n+            // in this arm, e.g., in\n+            // ```\n+            //     let x: (Direction, Direction, bool) = ...;\n+            //     let (_, _, false) = x;\n+            // ```\n+            // we don't want to show all 16 possible witnesses `(<direction-1>, <direction-2>,\n+            // true)` - we are satisfied with `(_, _, true)`. So if all constructors are missing we\n+            // prefer to report just a wildcard `_`.\n+            //\n+            // The exception is: if we are at the top-level, for example in an empty match, we\n+            // sometimes prefer reporting the list of constructors instead of just `_`.\n+\n+            let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(&pcx.ty);\n+            let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n+                Missing\n+            } else {\n+                Wildcard\n+            };\n+            return smallvec![ctor];\n+        }\n+\n+        // All the constructors are present in the matrix, so we just go through them all.\n+        self.all_ctors\n+    }\n+}\n+\n+#[test]\n+fn it_works2() {}\n+\n+/// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n+/// `Fields` struct. This struct represents such a potentially-hidden field.\n+#[derive(Debug, Copy, Clone)]\n+pub(super) enum FilteredField {\n+    Kept(PatId),\n+    Hidden,\n+}\n+\n+impl FilteredField {\n+    fn kept(self) -> Option<PatId> {\n+        match self {\n+            FilteredField::Kept(p) => Some(p),\n+            FilteredField::Hidden => None,\n+        }\n+    }\n+}\n+\n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// those fields, generalized to allow patterns in each field. See also `Constructor`.\n+/// This is constructed from a constructor using [`Fields::wildcards()`].\n+///\n+/// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n+/// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n+/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rarely used,\n+/// so we avoid it when possible to preserve performance.\n+#[derive(Debug, Clone)]\n+pub(super) enum Fields {\n+    /// Lists of patterns that don't contain any filtered fields.\n+    /// `Slice` and `Vec` behave the same; the difference is only to avoid allocating and\n+    /// triple-dereferences when possible. Frankly this is premature optimization, I (Nadrieril)\n+    /// have not measured if it really made a difference.\n+    Vec(SmallVec<[PatId; 2]>),\n+}\n+\n+impl Fields {\n+    /// Internal use. Use `Fields::wildcards()` instead.\n+    /// Must not be used if the pattern is a field of a struct/tuple/variant.\n+    fn from_single_pattern(pat: PatId) -> Self {\n+        Fields::Vec(smallvec![pat])\n+    }\n+\n+    /// Convenience; internal use.\n+    fn wildcards_from_tys<'a>(\n+        cx: &MatchCheckCtx<'_>,\n+        tys: impl IntoIterator<Item = &'a Ty>,\n+    ) -> Self {\n+        let wilds = tys.into_iter().map(|ty| (Pat::Wild, ty));\n+        let pats = wilds.map(|(pat, ty)| cx.alloc_pat(pat, ty)).collect();\n+        Fields::Vec(pats)\n+    }\n+\n+    pub(crate) fn wildcards(pcx: &PatCtxt<'_>, constructor: &Constructor) -> Self {\n+        let ty = &pcx.ty;\n+        let cx = pcx.cx;\n+        let wildcard_from_ty = |ty| cx.alloc_pat(Pat::Wild, ty);\n+\n+        let ret = match constructor {\n+            Single | Variant(_) => match ty.kind(&Interner) {\n+                TyKind::Tuple(_, substs) => {\n+                    let tys = substs.iter(&Interner).map(|ty| ty.assert_ty_ref(&Interner));\n+                    Fields::wildcards_from_tys(cx, tys)\n+                }\n+                TyKind::Ref(.., rty) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n+                TyKind::Adt(AdtId(adt), substs) => {\n+                    let adt_is_box = false; // TODO(iDawer): handle box patterns\n+                    if adt_is_box {\n+                        // Use T as the sub pattern type of Box<T>.\n+                        let ty = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n+                        Fields::from_single_pattern(wildcard_from_ty(ty))\n+                    } else {\n+                        let variant_id = constructor.variant_id_for_adt(*adt, cx);\n+                        let variant = variant_id.variant_data(cx.db.upcast());\n+                        let adt_is_local = variant_id.module(cx.db.upcast()).krate() == cx.krate;\n+                        // Whether we must not match the fields of this variant exhaustively.\n+                        let is_non_exhaustive =\n+                            is_field_list_non_exhaustive(variant_id, cx) && !adt_is_local;\n+                        let field_ty_arena = cx.db.field_types(variant_id);\n+                        let field_tys =\n+                            || field_ty_arena.iter().map(|(_, binders)| binders.skip_binders());\n+                        // In the following cases, we don't need to filter out any fields. This is\n+                        // the vast majority of real cases, since uninhabited fields are uncommon.\n+                        let has_no_hidden_fields = (matches!(adt, hir_def::AdtId::EnumId(_))\n+                            && !is_non_exhaustive)\n+                            || !field_tys().any(|ty| cx.is_uninhabited(ty));\n+\n+                        if has_no_hidden_fields {\n+                            Fields::wildcards_from_tys(cx, field_tys())\n+                        } else {\n+                            //FIXME(iDawer): see MatchCheckCtx::is_uninhabited\n+                            unimplemented!(\"exhaustive_patterns feature\")\n+                        }\n+                    }\n+                }\n+                _ => panic!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n+            },\n+            Missing | Wildcard => Fields::Vec(Default::default()),\n+            _ => todo!(),\n+        };\n+        ret\n+    }\n+\n+    /// Apply a constructor to a list of patterns, yielding a new pattern. `self`\n+    /// must have as many elements as this constructor's arity.\n+    ///\n+    /// This is roughly the inverse of `specialize_constructor`.\n+    ///\n+    /// Examples:\n+    /// `ctor`: `Constructor::Single`\n+    /// `ty`: `Foo(u32, u32, u32)`\n+    /// `self`: `[10, 20, _]`\n+    /// returns `Foo(10, 20, _)`\n+    ///\n+    /// `ctor`: `Constructor::Variant(Option::Some)`\n+    /// `ty`: `Option<bool>`\n+    /// `self`: `[false]`\n+    /// returns `Some(false)`\n+    pub(super) fn apply(self, pcx: &PatCtxt<'_>, ctor: &Constructor) -> Pat {\n+        let subpatterns_and_indices = self.patterns_and_indices();\n+        let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p);\n+\n+        match ctor {\n+            Single | Variant(_) => match pcx.ty.kind(&Interner) {\n+                TyKind::Adt(..) | TyKind::Tuple(..) => {\n+                    // We want the real indices here.\n+                    // TODO indices\n+                    let subpatterns = subpatterns_and_indices.iter().map(|&(_, pat)| pat).collect();\n+\n+                    if let Some((adt, substs)) = pcx.ty.as_adt() {\n+                        if let hir_def::AdtId::EnumId(_) = adt {\n+                            todo!()\n+                        } else {\n+                            todo!()\n+                        }\n+                    } else {\n+                        // TODO ellipsis\n+                        Pat::Tuple { args: subpatterns, ellipsis: None }\n+                    }\n+                }\n+\n+                _ => todo!(),\n+                // TyKind::AssociatedType(_, _) => {}\n+                // TyKind::Scalar(_) => {}\n+                // TyKind::Array(_, _) => {}\n+                // TyKind::Slice(_) => {}\n+                // TyKind::Raw(_, _) => {}\n+                // TyKind::Ref(_, _, _) => {}\n+                // TyKind::OpaqueType(_, _) => {}\n+                // TyKind::FnDef(_, _) => {}\n+                // TyKind::Str => {}\n+                // TyKind::Never => {}\n+                // TyKind::Closure(_, _) => {}\n+                // TyKind::Generator(_, _) => {}\n+                // TyKind::GeneratorWitness(_, _) => {}\n+                // TyKind::Foreign(_) => {}\n+                // TyKind::Error => {}\n+                // TyKind::Placeholder(_) => {}\n+                // TyKind::Dyn(_) => {}\n+                // TyKind::Alias(_) => {}\n+                // TyKind::Function(_) => {}\n+                // TyKind::BoundVar(_) => {}\n+                // TyKind::InferenceVar(_, _) => {}\n+            },\n+\n+            _ => todo!(),\n+            // Constructor::IntRange(_) => {}\n+            // Constructor::Slice(_) => {}\n+            // Missing => {}\n+            // Wildcard => {}\n+        }\n+    }\n+\n+    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n+    /// construct `self`.\n+    pub(super) fn len(&self) -> usize {\n+        match self {\n+            Fields::Vec(pats) => pats.len(),\n+        }\n+    }\n+\n+    /// Returns the list of patterns along with the corresponding field indices.\n+    fn patterns_and_indices(&self) -> SmallVec<[(usize, PatId); 2]> {\n+        match self {\n+            Fields::Vec(pats) => pats.iter().copied().enumerate().collect(),\n+        }\n+    }\n+\n+    pub(super) fn into_patterns(self) -> SmallVec<[PatId; 2]> {\n+        match self {\n+            Fields::Vec(pats) => pats,\n+        }\n+    }\n+\n+    /// Overrides some of the fields with the provided patterns. Exactly like\n+    /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n+    fn replace_with_fieldpats(&self, new_pats: impl IntoIterator<Item = PatId>) -> Self {\n+        self.replace_fields_indexed(new_pats.into_iter().enumerate())\n+    }\n+\n+    /// Overrides some of the fields with the provided patterns. This is used when a pattern\n+    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start\n+    /// with a `Fields` that is just one wildcard per field of the `Foo` struct, and override the\n+    /// entry corresponding to `field1` with the pattern `Some(_)`. This is also used for slice\n+    /// patterns for the same reason.\n+    fn replace_fields_indexed(&self, new_pats: impl IntoIterator<Item = (usize, PatId)>) -> Self {\n+        let mut fields = self.clone();\n+\n+        match &mut fields {\n+            Fields::Vec(pats) => {\n+                for (i, pat) in new_pats {\n+                    if let Some(p) = pats.get_mut(i) {\n+                        *p = pat;\n+                    }\n+                }\n+            }\n+        }\n+        fields\n+    }\n+\n+    /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n+    /// in `pats`.\n+    pub(super) fn replace_fields(\n+        &self,\n+        cx: &MatchCheckCtx<'_>,\n+        pats: impl IntoIterator<Item = Pat>,\n+    ) -> Self {\n+        let pats = {\n+            let mut arena = cx.pattern_arena.borrow_mut();\n+            pats.into_iter().map(move |pat| /* arena.alloc(pat) */ todo!()).collect()\n+        };\n+\n+        match self {\n+            Fields::Vec(_) => Fields::Vec(pats),\n+        }\n+    }\n+\n+    /// Replaces contained fields with the arguments of the given pattern. Only use on a pattern\n+    /// that is compatible with the constructor used to build `self`.\n+    /// This is meant to be used on the result of `Fields::wildcards()`. The idea is that\n+    /// `wildcards` constructs a list of fields where all entries are wildcards, and the pattern\n+    /// provided to this function fills some of the fields with non-wildcards.\n+    /// In the following example `Fields::wildcards` would return `[_, _, _, _]`. If we call\n+    /// `replace_with_pattern_arguments` on it with the pattern, the result will be `[Some(0), _,\n+    /// _, _]`.\n+    /// ```rust\n+    /// let x: [Option<u8>; 4] = foo();\n+    /// match x {\n+    ///     [Some(0), ..] => {}\n+    /// }\n+    /// ```\n+    /// This is guaranteed to preserve the number of patterns in `self`.\n+    pub(super) fn replace_with_pattern_arguments(\n+        &self,\n+        pat: PatId,\n+        cx: &MatchCheckCtx<'_>,\n+    ) -> Self {\n+        match &cx.pattern_arena.borrow()[pat] {\n+            Pat::Ref { pat: subpattern, .. } => {\n+                assert_eq!(self.len(), 1);\n+                Fields::from_single_pattern(*subpattern)\n+            }\n+            Pat::Tuple { args: subpatterns, ellipsis } => {\n+                // FIXME(iDawer) handle ellipsis.\n+                // XXX(iDawer): in rustc, this is handled by HIR->TypedHIR lowering\n+                // rustc_mir_build::thir::pattern::PatCtxt::lower_tuple_subpats(..)\n+                self.replace_with_fieldpats(subpatterns.iter().copied())\n+            }\n+\n+            Pat::Wild => self.clone(),\n+            pat => todo!(\"Fields::replace_with_pattern_arguments({:?})\", pat),\n+            // Pat::Missing => {}\n+            // Pat::Or(_) => {}\n+            // Pat::Record { path, args, ellipsis } => {}\n+            // Pat::Range { start, end } => {}\n+            // Pat::Slice { prefix, slice, suffix } => {}\n+            // Pat::Path(_) => {}\n+            // Pat::Lit(_) => {}\n+            // Pat::Bind { mode, name, subpat } => {}\n+            // Pat::TupleStruct { path, args, ellipsis } => {}\n+            // Pat::Box { inner } => {}\n+            // Pat::ConstBlock(_) => {}\n+        }\n+    }\n+}\n+\n+fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_>) -> bool {\n+    let attr_def_id = match variant_id {\n+        VariantId::EnumVariantId(id) => id.into(),\n+        VariantId::StructId(id) => id.into(),\n+        VariantId::UnionId(id) => id.into(),\n+    };\n+    cx.db.attrs(attr_def_id).by_key(\"non_exhaustive\").exists()\n+}\n+\n+#[test]\n+fn it_works() {}"}, {"sha": "f5f6bf49495349599f3ea6fc361adb2ce93537f8", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "added", "additions": 736, "deletions": 0, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "patch": "@@ -0,0 +1,736 @@\n+// Based on rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\n+// rust/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\n+\n+use std::{cell::RefCell, iter::FromIterator, ops::Index, sync::Arc};\n+\n+use base_db::CrateId;\n+use hir_def::{\n+    body::Body,\n+    expr::{ExprId, Pat, PatId},\n+};\n+use la_arena::Arena;\n+use once_cell::unsync::OnceCell;\n+use rustc_hash::FxHashMap;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{db::HirDatabase, InferenceResult, Ty};\n+\n+use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n+\n+use self::{\n+    helper::{Captures, PatIdExt},\n+    Usefulness::*,\n+    WitnessPreference::*,\n+};\n+\n+pub(crate) struct MatchCheckCtx<'a> {\n+    pub(crate) krate: CrateId,\n+    pub(crate) match_expr: ExprId,\n+    pub(crate) body: Arc<Body>,\n+    pub(crate) infer: &'a InferenceResult,\n+    pub(crate) db: &'a dyn HirDatabase,\n+    /// Patterns from self.body.pats plus generated by the check.\n+    pub(crate) pattern_arena: &'a RefCell<PatternArena>,\n+}\n+\n+impl<'a> MatchCheckCtx<'a> {\n+    pub(super) fn is_uninhabited(&self, ty: &Ty) -> bool {\n+        // FIXME(iDawer) implement exhaustive_patterns feature. More info in:\n+        // Tracking issue for RFC 1872: exhaustive_patterns feature https://github.com/rust-lang/rust/issues/51085\n+        false\n+    }\n+\n+    pub(super) fn alloc_pat(&self, pat: Pat, ty: &Ty) -> PatId {\n+        self.pattern_arena.borrow_mut().alloc(pat, ty)\n+    }\n+\n+    /// Get type of a pattern. Handles expanded patterns.\n+    pub(super) fn type_of(&self, pat: PatId) -> Ty {\n+        let type_of_expanded_pat = self.pattern_arena.borrow().type_of_epat.get(&pat).cloned();\n+        type_of_expanded_pat.unwrap_or_else(|| self.infer[pat].clone())\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub(super) struct PatCtxt<'a> {\n+    pub(super) cx: &'a MatchCheckCtx<'a>,\n+    /// Type of the current column under investigation.\n+    pub(super) ty: Ty,\n+    /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n+    /// subpattern.\n+    pub(super) is_top_level: bool,\n+}\n+\n+impl PatIdExt for PatId {\n+    fn is_wildcard(self, cx: &MatchCheckCtx<'_>) -> bool {\n+        matches!(cx.pattern_arena.borrow()[self], Pat::Bind { subpat: None, .. } | Pat::Wild)\n+    }\n+\n+    fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool {\n+        matches!(cx.pattern_arena.borrow()[self], Pat::Or(..))\n+    }\n+\n+    /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+    fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self> {\n+        fn expand(pat: PatId, vec: &mut Vec<PatId>, pat_arena: &PatternArena) {\n+            if let Pat::Or(pats) = &pat_arena[pat] {\n+                for &pat in pats {\n+                    expand(pat, vec, pat_arena);\n+                }\n+            } else {\n+                vec.push(pat)\n+            }\n+        }\n+\n+        let pat_arena = cx.pattern_arena.borrow();\n+        let mut pats = Vec::new();\n+        expand(self, &mut pats, &pat_arena);\n+        pats\n+    }\n+}\n+\n+/// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n+/// works well.\n+#[derive(Clone)]\n+pub(super) struct PatStack {\n+    pats: SmallVec<[PatId; 2]>,\n+    /// Cache for the constructor of the head\n+    head_ctor: OnceCell<Constructor>,\n+}\n+\n+impl PatStack {\n+    fn from_pattern(pat: PatId) -> Self {\n+        Self::from_vec(smallvec![pat])\n+    }\n+\n+    fn from_vec(vec: SmallVec<[PatId; 2]>) -> Self {\n+        PatStack { pats: vec, head_ctor: OnceCell::new() }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.pats.is_empty()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.pats.len()\n+    }\n+\n+    fn head(&self) -> PatId {\n+        self.pats[0]\n+    }\n+\n+    #[inline]\n+    fn head_ctor(&self, cx: &MatchCheckCtx<'_>) -> &Constructor {\n+        self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = PatId> + '_ {\n+        self.pats.iter().copied()\n+    }\n+\n+    // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n+    // or-pattern. Panics if `self` is empty.\n+    fn expand_or_pat(&self, cx: &MatchCheckCtx<'_>) -> impl Iterator<Item = PatStack> + '_ {\n+        self.head().expand_or_pat(cx).into_iter().map(move |pat| {\n+            let mut new_patstack = PatStack::from_pattern(pat);\n+            new_patstack.pats.extend_from_slice(&self.pats[1..]);\n+            new_patstack\n+        })\n+    }\n+\n+    /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n+    ///\n+    /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+    /// fields filled with wild patterns.\n+    ///\n+    /// This is roughly the inverse of `Constructor::apply`.\n+    fn pop_head_constructor(\n+        &self,\n+        ctor_wild_subpatterns: &Fields,\n+        cx: &MatchCheckCtx<'_>,\n+    ) -> PatStack {\n+        // We pop the head pattern and push the new fields extracted from the arguments of\n+        // `self.head()`.\n+        let mut new_fields =\n+            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head(), cx).into_patterns();\n+        new_fields.extend_from_slice(&self.pats[1..]);\n+        PatStack::from_vec(new_fields)\n+    }\n+}\n+\n+impl Default for PatStack {\n+    fn default() -> Self {\n+        Self::from_vec(smallvec![])\n+    }\n+}\n+\n+impl PartialEq for PatStack {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.pats == other.pats\n+    }\n+}\n+\n+impl FromIterator<PatId> for PatStack {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = PatId>,\n+    {\n+        Self::from_vec(iter.into_iter().collect())\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub(super) struct Matrix {\n+    patterns: Vec<PatStack>,\n+}\n+\n+impl Matrix {\n+    fn empty() -> Self {\n+        Matrix { patterns: vec![] }\n+    }\n+\n+    /// Number of columns of this matrix. `None` is the matrix is empty.\n+    pub(super) fn column_count(&self) -> Option<usize> {\n+        self.patterns.get(0).map(|r| r.len())\n+    }\n+\n+    /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n+    /// expands it.\n+    fn push(&mut self, row: PatStack, cx: &MatchCheckCtx<'_>) {\n+        if !row.is_empty() && row.head().is_or_pat(cx) {\n+            for row in row.expand_or_pat(cx) {\n+                self.patterns.push(row);\n+            }\n+        } else {\n+            self.patterns.push(row);\n+        }\n+    }\n+\n+    /// Iterate over the first component of each row\n+    fn heads(&self) -> impl Iterator<Item = PatId> + '_ {\n+        self.patterns.iter().map(|r| r.head())\n+    }\n+\n+    /// Iterate over the first constructor of each row.\n+    fn head_ctors<'a>(\n+        &'a self,\n+        cx: &'a MatchCheckCtx<'_>,\n+    ) -> impl Iterator<Item = &'a Constructor> + Clone {\n+        self.patterns.iter().map(move |r| r.head_ctor(cx))\n+    }\n+\n+    /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    fn specialize_constructor(\n+        &self,\n+        pcx: &PatCtxt<'_>,\n+        ctor: &Constructor,\n+        ctor_wild_subpatterns: &Fields,\n+    ) -> Matrix {\n+        let rows = self\n+            .patterns\n+            .iter()\n+            .filter(|r| ctor.is_covered_by(pcx, r.head_ctor(pcx.cx)))\n+            .map(|r| r.pop_head_constructor(ctor_wild_subpatterns, pcx.cx));\n+        Matrix::from_iter(rows, pcx.cx)\n+    }\n+\n+    fn from_iter(rows: impl IntoIterator<Item = PatStack>, cx: &MatchCheckCtx<'_>) -> Matrix {\n+        let mut matrix = Matrix::empty();\n+        for x in rows {\n+            // Using `push` ensures we correctly expand or-patterns.\n+            matrix.push(x, cx);\n+        }\n+        matrix\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+enum SubPatSet {\n+    /// The empty set. This means the pattern is unreachable.\n+    Empty,\n+    /// The set containing the full pattern.\n+    Full,\n+    /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n+    /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n+    /// common case.\n+    Seq { subpats: FxHashMap<usize, SubPatSet> },\n+    /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n+    /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n+    Alt {\n+        subpats: FxHashMap<usize, SubPatSet>,\n+        /// Counts the total number of alternatives in the pattern\n+        alt_count: usize,\n+        /// We keep the pattern around to retrieve spans.\n+        pat: PatId,\n+    },\n+}\n+\n+impl SubPatSet {\n+    fn full() -> Self {\n+        SubPatSet::Full\n+    }\n+\n+    fn empty() -> Self {\n+        SubPatSet::Empty\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        match self {\n+            SubPatSet::Empty => true,\n+            SubPatSet::Full => false,\n+            // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n+            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_empty()),\n+            // An or-pattern is reachable if any of its alternatives is.\n+            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_empty()),\n+        }\n+    }\n+\n+    fn is_full(&self) -> bool {\n+        match self {\n+            SubPatSet::Empty => false,\n+            SubPatSet::Full => true,\n+            // The whole pattern is reachable only when all its alternatives are.\n+            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n+            // The whole or-pattern is reachable only when all its alternatives are.\n+            SubPatSet::Alt { subpats, alt_count, .. } => {\n+                subpats.len() == *alt_count && subpats.values().all(|set| set.is_full())\n+            }\n+        }\n+    }\n+\n+    /// Union `self` with `other`, mutating `self`.\n+    fn union(&mut self, other: Self) {\n+        use SubPatSet::*;\n+        // Union with full stays full; union with empty changes nothing.\n+        if self.is_full() || other.is_empty() {\n+            return;\n+        } else if self.is_empty() {\n+            *self = other;\n+            return;\n+        } else if other.is_full() {\n+            *self = Full;\n+            return;\n+        }\n+\n+        match (&mut *self, other) {\n+            (Seq { .. }, Seq { .. }) => {\n+                todo!()\n+            }\n+            (Alt { .. }, Alt { .. }) => {\n+                todo!()\n+            }\n+            _ => panic!(\"bug\"),\n+        }\n+    }\n+\n+    /// Returns a list of the spans of the unreachable subpatterns. If `self` is empty (i.e. the\n+    /// whole pattern is unreachable) we return `None`.\n+    fn list_unreachable_spans(&self) -> Option<Vec<()>> {\n+        if self.is_empty() {\n+            return None;\n+        }\n+        if self.is_full() {\n+            // No subpatterns are unreachable.\n+            return Some(Vec::new());\n+        }\n+        todo!()\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from specialization, after running\n+    /// `unspecialize` it will refer to the original patstack before specialization.\n+    fn unspecialize(self, arity: usize) -> Self {\n+        use SubPatSet::*;\n+        match self {\n+            Full => Full,\n+            Empty => Empty,\n+            Seq { subpats } => {\n+                todo!()\n+            }\n+            Alt { .. } => panic!(\"bug\"),\n+        }\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n+    /// running `unspecialize` it will refer to the original patstack before splitting.\n+    ///\n+    /// For example:\n+    /// ```\n+    /// match Some(true) {\n+    ///     Some(true) => {}\n+    ///     None | Some(true | false) => {}\n+    /// }\n+    /// ```\n+    /// Here `None` would return the full set and `Some(true | false)` would return the set\n+    /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n+    /// This is what this function does.\n+    fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: PatId) -> Self {\n+        todo!()\n+    }\n+}\n+\n+/// This carries the results of computing usefulness, as described at the top of the file. When\n+/// checking usefulness of a match branch, we use the `NoWitnesses` variant, which also keeps track\n+/// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n+/// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n+/// witnesses of non-exhaustiveness when there are any.\n+/// Which variant to use is dictated by `WitnessPreference`.\n+#[derive(Clone, Debug)]\n+enum Usefulness {\n+    /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n+    /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n+    /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n+    /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n+    /// (the whole pattern is reachable).\n+    NoWitnesses(SubPatSet),\n+    /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n+    /// pattern is unreachable.\n+    WithWitnesses(Vec<Witness>),\n+}\n+\n+impl Usefulness {\n+    fn new_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::full()),\n+        }\n+    }\n+    fn new_not_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => WithWitnesses(vec![]),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n+        }\n+    }\n+\n+    /// Combine usefulnesses from two branches. This is an associative operation.\n+    fn extend(&mut self, other: Self) {\n+        match (&mut *self, other) {\n+            (WithWitnesses(_), WithWitnesses(o)) if o.is_empty() => {}\n+            (WithWitnesses(s), WithWitnesses(o)) if s.is_empty() => *self = WithWitnesses(o),\n+            (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n+            (NoWitnesses(s), NoWitnesses(o)) => s.union(o),\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n+    /// results together.\n+    fn merge(pref: WitnessPreference, usefulnesses: impl Iterator<Item = Self>) -> Self {\n+        let mut ret = Self::new_not_useful(pref);\n+        for u in usefulnesses {\n+            ret.extend(u);\n+            if let NoWitnesses(subpats) = &ret {\n+                if subpats.is_full() {\n+                    // Once we reach the full set, more unions won't change the result.\n+                    return ret;\n+                }\n+            }\n+        }\n+        ret\n+    }\n+\n+    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n+    /// usefulness mergeable with those from the other branches.\n+    fn unsplit_or_pat(self, alt_id: usize, alt_count: usize, pat: PatId) -> Self {\n+        match self {\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, alt_count, pat)),\n+            WithWitnesses(_) => panic!(\"bug\"),\n+        }\n+    }\n+\n+    /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n+    /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n+    /// with the results of specializing with the other constructors.\n+    fn apply_constructor(\n+        self,\n+        pcx: &PatCtxt<'_>,\n+        matrix: &Matrix,\n+        ctor: &Constructor,\n+        ctor_wild_subpatterns: &Fields,\n+    ) -> Self {\n+        match self {\n+            WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n+            WithWitnesses(w) => {\n+                let new_witnesses = if matches!(ctor, Constructor::Missing) {\n+                    let mut split_wildcard = SplitWildcard::new(pcx);\n+                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                } else {\n+                    todo!(\"Usefulness::apply_constructor({:?})\", ctor)\n+                };\n+                todo!(\"Usefulness::apply_constructor({:?})\", ctor)\n+            }\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum WitnessPreference {\n+    ConstructWitness,\n+    LeaveOutWitness,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct Witness(Vec<Pat>);\n+\n+impl Witness {\n+    /// Asserts that the witness contains a single pattern, and returns it.\n+    fn single_pattern(self) -> Pat {\n+        assert_eq!(self.0.len(), 1);\n+        self.0.into_iter().next().unwrap()\n+    }\n+\n+    /// Constructs a partial witness for a pattern given a list of\n+    /// patterns expanded by the specialization step.\n+    ///\n+    /// When a pattern P is discovered to be useful, this function is used bottom-up\n+    /// to reconstruct a complete witness, e.g., a pattern P' that covers a subset\n+    /// of values, V, where each value in that set is not covered by any previously\n+    /// used patterns and is covered by the pattern P'. Examples:\n+    ///\n+    /// left_ty: tuple of 3 elements\n+    /// pats: [10, 20, _]           => (10, 20, _)\n+    ///\n+    /// left_ty: struct X { a: (bool, &'static str), b: usize}\n+    /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+    fn apply_constructor(\n+        mut self,\n+        pcx: &PatCtxt<'_>,\n+        ctor: &Constructor,\n+        ctor_wild_subpatterns: &Fields,\n+    ) -> Self {\n+        let pat = {\n+            let len = self.0.len();\n+            let arity = ctor_wild_subpatterns.len();\n+            let pats = self.0.drain((len - arity)..).rev();\n+            ctor_wild_subpatterns.replace_fields(pcx.cx, pats).apply(pcx, ctor)\n+        };\n+\n+        self.0.push(pat);\n+\n+        self\n+    }\n+}\n+\n+/// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n+/// The algorithm from the paper has been modified to correctly handle empty\n+/// types. The changes are:\n+///   (0) We don't exit early if the pattern matrix has zero rows. We just\n+///       continue to recurse over columns.\n+///   (1) all_constructors will only return constructors that are statically\n+///       possible. E.g., it will only return `Ok` for `Result<T, !>`.\n+///\n+/// This finds whether a (row) vector `v` of patterns is 'useful' in relation\n+/// to a set of such vectors `m` - this is defined as there being a set of\n+/// inputs that will match `v` but not any of the sets in `m`.\n+///\n+/// All the patterns at each column of the `matrix ++ v` matrix must have the same type.\n+///\n+/// This is used both for reachability checking (if a pattern isn't useful in\n+/// relation to preceding patterns, it is not reachable) and exhaustiveness\n+/// checking (if a wildcard pattern is useful in relation to a matrix, the\n+/// matrix isn't exhaustive).\n+///\n+/// `is_under_guard` is used to inform if the pattern has a guard. If it\n+/// has one it must not be inserted into the matrix. This shouldn't be\n+/// relied on for soundness.\n+fn is_useful(\n+    cx: &MatchCheckCtx<'_>,\n+    matrix: &Matrix,\n+    v: &PatStack,\n+    witness_preference: WitnessPreference,\n+    is_under_guard: bool,\n+    is_top_level: bool,\n+) -> Usefulness {\n+    let Matrix { patterns: rows, .. } = matrix;\n+\n+    // The base case. We are pattern-matching on () and the return value is\n+    // based on whether our matrix has a row or not.\n+    // NOTE: This could potentially be optimized by checking rows.is_empty()\n+    // first and then, if v is non-empty, the return value is based on whether\n+    // the type of the tuple we're checking is inhabited or not.\n+    if v.is_empty() {\n+        let ret = if rows.is_empty() {\n+            Usefulness::new_useful(witness_preference)\n+        } else {\n+            Usefulness::new_not_useful(witness_preference)\n+        };\n+        return ret;\n+    }\n+\n+    assert!(rows.iter().all(|r| r.len() == v.len()));\n+\n+    // FIXME(Nadrieril): Hack to work around type normalization issues (see rust-lang/rust#72476).\n+    // TODO(iDawer): ty.as_reference()\n+    let ty = matrix.heads().next().map_or(cx.type_of(v.head()), |r| cx.type_of(r));\n+    let pcx = PatCtxt { cx, ty, is_top_level };\n+\n+    // If the first pattern is an or-pattern, expand it.\n+    let ret = if v.head().is_or_pat(cx) {\n+        //expanding or-pattern\n+        let v_head = v.head();\n+        let vs: Vec<_> = v.expand_or_pat(cx).collect();\n+        let alt_count = vs.len();\n+        // We try each or-pattern branch in turn.\n+        let mut matrix = matrix.clone();\n+        let usefulnesses = vs.into_iter().enumerate().map(|(i, v)| {\n+            let usefulness = is_useful(cx, &matrix, &v, witness_preference, is_under_guard, false);\n+            // If pattern has a guard don't add it to the matrix.\n+            if !is_under_guard {\n+                // We push the already-seen patterns into the matrix in order to detect redundant\n+                // branches like `Some(_) | Some(0)`.\n+                matrix.push(v, cx);\n+            }\n+            usefulness.unsplit_or_pat(i, alt_count, v_head)\n+        });\n+        Usefulness::merge(witness_preference, usefulnesses)\n+    } else {\n+        let v_ctor = v.head_ctor(cx);\n+        // if let Constructor::IntRange(ctor_range) = v_ctor {\n+        //     // Lint on likely incorrect range patterns (#63987)\n+        //     ctor_range.lint_overlapping_range_endpoints(\n+        //         pcx,\n+        //         matrix.head_ctors_and_spans(cx),\n+        //         matrix.column_count().unwrap_or(0),\n+        //         hir_id,\n+        //     )\n+        // }\n+\n+        // We split the head constructor of `v`.\n+        let split_ctors = v_ctor.split(&pcx, matrix.head_ctors(cx));\n+        // For each constructor, we compute whether there's a value that starts with it that would\n+        // witness the usefulness of `v`.\n+        let start_matrix = matrix;\n+        let usefulnesses = split_ctors.into_iter().map(|ctor| {\n+            // debug!(\"specialize({:?})\", ctor);\n+            // We cache the result of `Fields::wildcards` because it is used a lot.\n+            let ctor_wild_subpatterns = Fields::wildcards(&pcx, &ctor);\n+            let spec_matrix =\n+                start_matrix.specialize_constructor(&pcx, &ctor, &ctor_wild_subpatterns);\n+            let v = v.pop_head_constructor(&ctor_wild_subpatterns, cx);\n+            let usefulness =\n+                is_useful(cx, &spec_matrix, &v, witness_preference, is_under_guard, false);\n+            usefulness.apply_constructor(&pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n+        });\n+        Usefulness::merge(witness_preference, usefulnesses)\n+    };\n+\n+    ret\n+}\n+\n+/// The arm of a match expression.\n+#[derive(Clone, Copy)]\n+pub(crate) struct MatchArm {\n+    pub(crate) pat: PatId,\n+    pub(crate) has_guard: bool,\n+}\n+\n+/// Indicates whether or not a given arm is reachable.\n+#[derive(Clone, Debug)]\n+pub(crate) enum Reachability {\n+    /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n+    /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n+    /// of or-patterns, otherwise it stays empty.\n+    Reachable(Vec<()>),\n+    /// The arm is unreachable.\n+    Unreachable,\n+}\n+/// The output of checking a match for exhaustiveness and arm reachability.\n+pub(crate) struct UsefulnessReport {\n+    /// For each arm of the input, whether that arm is reachable after the arms above it.\n+    pub(crate) arm_usefulness: Vec<(MatchArm, Reachability)>,\n+    /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n+    /// exhaustiveness.\n+    pub(crate) non_exhaustiveness_witnesses: Vec<Pat>,\n+}\n+\n+pub(crate) fn compute_match_usefulness(\n+    cx: &MatchCheckCtx<'_>,\n+    arms: &[MatchArm],\n+) -> UsefulnessReport {\n+    let mut matrix = Matrix::empty();\n+    let arm_usefulness: Vec<_> = arms\n+        .iter()\n+        .copied()\n+        .map(|arm| {\n+            let v = PatStack::from_pattern(arm.pat);\n+            let usefulness = is_useful(cx, &matrix, &v, LeaveOutWitness, arm.has_guard, true);\n+            if !arm.has_guard {\n+                matrix.push(v, cx);\n+            }\n+            let reachability = match usefulness {\n+                NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n+                NoWitnesses(subpats) => {\n+                    Reachability::Reachable(subpats.list_unreachable_spans().unwrap())\n+                }\n+                WithWitnesses(..) => panic!(\"bug\"),\n+            };\n+            (arm, reachability)\n+        })\n+        .collect();\n+\n+    let wild_pattern = cx.pattern_arena.borrow_mut().alloc(Pat::Wild, &cx.infer[cx.match_expr]);\n+    let v = PatStack::from_pattern(wild_pattern);\n+    let usefulness = is_useful(cx, &matrix, &v, LeaveOutWitness, false, true);\n+    let non_exhaustiveness_witnesses = match usefulness {\n+        // TODO: ConstructWitness\n+        // WithWitnesses(pats) => pats.into_iter().map(Witness::single_pattern).collect(),\n+        // NoWitnesses(_) => panic!(\"bug\"),\n+        NoWitnesses(subpats) if subpats.is_empty() => Vec::new(),\n+        NoWitnesses(subpats) => vec![Pat::Wild],\n+        WithWitnesses(..) => panic!(\"bug\"),\n+    };\n+    UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n+}\n+\n+pub(crate) struct PatternArena {\n+    arena: Arena<Pat>,\n+    /// Types of expanded patterns.\n+    type_of_epat: FxHashMap<PatId, Ty>,\n+}\n+\n+impl PatternArena {\n+    pub(crate) fn clone_from(pats: &Arena<Pat>) -> RefCell<Self> {\n+        PatternArena { arena: pats.clone(), type_of_epat: Default::default() }.into()\n+    }\n+\n+    fn alloc(&mut self, pat: Pat, ty: &Ty) -> PatId {\n+        let id = self.arena.alloc(pat);\n+        self.type_of_epat.insert(id, ty.clone());\n+        id\n+    }\n+}\n+\n+impl Index<PatId> for PatternArena {\n+    type Output = Pat;\n+\n+    fn index(&self, pat: PatId) -> &Pat {\n+        &self.arena[pat]\n+    }\n+}\n+\n+mod helper {\n+    use hir_def::expr::{Pat, PatId};\n+\n+    use super::MatchCheckCtx;\n+\n+    pub(super) trait PatIdExt: Sized {\n+        fn is_wildcard(self, cx: &MatchCheckCtx<'_>) -> bool;\n+        fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool;\n+        fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self>;\n+    }\n+\n+    // Copy-pasted from rust/compiler/rustc_data_structures/src/captures.rs\n+    /// \"Signaling\" trait used in impl trait to tag lifetimes that you may\n+    /// need to capture but don't really need for other reasons.\n+    /// Basically a workaround; see [this comment] for details.\n+    ///\n+    /// [this comment]: https://github.com/rust-lang/rust/issues/34511#issuecomment-373423999\n+    // FIXME(eddyb) false positive, the lifetime parameter is \"phantom\" but needed.\n+    #[allow(unused_lifetimes)]\n+    pub trait Captures<'a> {}\n+\n+    impl<'a, T: ?Sized> Captures<'a> for T {}\n+}\n+\n+#[test]\n+fn it_works() {}"}]}