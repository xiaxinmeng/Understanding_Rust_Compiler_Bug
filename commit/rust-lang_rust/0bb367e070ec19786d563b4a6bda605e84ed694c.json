{"sha": "0bb367e070ec19786d563b4a6bda605e84ed694c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYjM2N2UwNzBlYzE5Nzg2ZDU2M2I0YTZiZGE2MDVlODRlZDY5NGM=", "commit": {"author": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-03-02T14:54:10Z"}, "committer": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-03-12T12:24:29Z"}, "message": "Split pretty printer logic for scalar int and scalar ptr\n\nValue trees won't have scalar ptr at all, so we need a scalar int printing method anyway. This way we'll be able to share that method between all const representations.", "tree": {"sha": "b9c151c19ae77d9a25412a77b5ba4bba75ba98aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9c151c19ae77d9a25412a77b5ba4bba75ba98aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bb367e070ec19786d563b4a6bda605e84ed694c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb367e070ec19786d563b4a6bda605e84ed694c", "html_url": "https://github.com/rust-lang/rust/commit/0bb367e070ec19786d563b4a6bda605e84ed694c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bb367e070ec19786d563b4a6bda605e84ed694c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b729cc9d6129c11c1cd71a61f6eb745dd98531c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b729cc9d6129c11c1cd71a61f6eb745dd98531c6", "html_url": "https://github.com/rust-lang/rust/commit/b729cc9d6129c11c1cd71a61f6eb745dd98531c6"}], "stats": {"total": 113, "additions": 67, "deletions": 46}, "files": [{"sha": "7946d170064c98b2061680dd05cc184d991b01c2", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 67, "deletions": 46, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0bb367e070ec19786d563b4a6bda605e84ed694c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb367e070ec19786d563b4a6bda605e84ed694c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0bb367e070ec19786d563b4a6bda605e84ed694c", "patch": "@@ -956,32 +956,40 @@ pub trait PrettyPrinter<'tcx>:\n     }\n \n     fn pretty_print_const_scalar(\n-        mut self,\n+        self,\n         scalar: Scalar,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        match scalar {\n+            Scalar::Ptr(ptr) => self.pretty_print_const_scalar_ptr(ptr, ty, print_ty),\n+            Scalar::Int(int) => self.pretty_print_const_scalar_int(int, ty, print_ty),\n+        }\n+    }\n+\n+    fn pretty_print_const_scalar_ptr(\n+        mut self,\n+        ptr: Pointer,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        match (scalar, &ty.kind()) {\n+        match ty.kind() {\n             // Byte strings (&[u8; N])\n-            (\n-                Scalar::Ptr(ptr),\n-                ty::Ref(\n-                    _,\n-                    ty::TyS {\n-                        kind:\n-                            ty::Array(\n-                                ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n-                                ty::Const {\n-                                    val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n-                                    ..\n-                                },\n-                            ),\n-                        ..\n-                    },\n-                    _,\n-                ),\n+            ty::Ref(\n+                _,\n+                ty::TyS {\n+                    kind:\n+                        ty::Array(\n+                            ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n+                            ty::Const {\n+                                val: ty::ConstKind::Value(ConstValue::Scalar(int)), ..\n+                            },\n+                        ),\n+                    ..\n+                },\n+                _,\n             ) => match self.tcx().get_global_alloc(ptr.alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n                     let bytes = int.assert_bits(self.tcx().data_layout.pointer_size);\n@@ -997,28 +1005,59 @@ pub trait PrettyPrinter<'tcx>:\n                 Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n                 None => p!(\"<dangling pointer>\"),\n             },\n+            ty::FnPtr(_) => {\n+                // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n+                // printing above (which also has to handle pointers to all sorts of things).\n+                match self.tcx().get_global_alloc(ptr.alloc_id) {\n+                    Some(GlobalAlloc::Function(instance)) => {\n+                        self = self.typed_value(\n+                            |this| this.print_value_path(instance.def_id(), instance.substs),\n+                            |this| this.print_type(ty),\n+                            \" as \",\n+                        )?;\n+                    }\n+                    _ => self = self.pretty_print_const_pointer(ptr, ty, print_ty)?,\n+                }\n+            }\n+            // Any pointer values not covered by a branch above\n+            _ => {\n+                self = self.pretty_print_const_pointer(ptr, ty, print_ty)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn pretty_print_const_scalar_int(\n+        mut self,\n+        int: ScalarInt,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        match ty.kind() {\n             // Bool\n-            (Scalar::Int(int), ty::Bool) if int == ScalarInt::FALSE => p!(\"false\"),\n-            (Scalar::Int(int), ty::Bool) if int == ScalarInt::TRUE => p!(\"true\"),\n+            ty::Bool if int == ScalarInt::FALSE => p!(\"false\"),\n+            ty::Bool if int == ScalarInt::TRUE => p!(\"true\"),\n             // Float\n-            (Scalar::Int(int), ty::Float(ty::FloatTy::F32)) => {\n+            ty::Float(ty::FloatTy::F32) => {\n                 p!(write(\"{}f32\", Single::try_from(int).unwrap()))\n             }\n-            (Scalar::Int(int), ty::Float(ty::FloatTy::F64)) => {\n+            ty::Float(ty::FloatTy::F64) => {\n                 p!(write(\"{}f64\", Double::try_from(int).unwrap()))\n             }\n             // Int\n-            (Scalar::Int(int), ty::Uint(_) | ty::Int(_)) => {\n+            ty::Uint(_) | ty::Int(_) => {\n                 let int =\n                     ConstInt::new(int, matches!(ty.kind(), ty::Int(_)), ty.is_ptr_sized_integral());\n                 if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n             }\n             // Char\n-            (Scalar::Int(int), ty::Char) if char::try_from(int).is_ok() => {\n+            ty::Char if char::try_from(int).is_ok() => {\n                 p!(write(\"{:?}\", char::try_from(int).unwrap()))\n             }\n             // Raw pointers\n-            (Scalar::Int(int), ty::RawPtr(_) | ty::FnPtr(_)) => {\n+            ty::RawPtr(_) | ty::FnPtr(_) => {\n                 let data = int.assert_bits(self.tcx().data_layout.pointer_size);\n                 self = self.typed_value(\n                     |mut this| {\n@@ -1029,26 +1068,12 @@ pub trait PrettyPrinter<'tcx>:\n                     \" as \",\n                 )?;\n             }\n-            (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n-                // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n-                // printing above (which also has to handle pointers to all sorts of things).\n-                match self.tcx().get_global_alloc(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(instance)) => {\n-                        self = self.typed_value(\n-                            |this| this.print_value_path(instance.def_id(), instance.substs),\n-                            |this| this.print_type(ty),\n-                            \" as \",\n-                        )?;\n-                    }\n-                    _ => self = self.pretty_print_const_pointer(ptr, ty, print_ty)?,\n-                }\n-            }\n             // For function type zsts just printing the path is enough\n-            (Scalar::Int(int), ty::FnDef(d, s)) if int == ScalarInt::ZST => {\n+            ty::FnDef(d, s) if int == ScalarInt::ZST => {\n                 p!(print_value_path(*d, s))\n             }\n             // Nontrivial types with scalar bit representation\n-            (Scalar::Int(int), _) => {\n+            _ => {\n                 let print = |mut this: Self| {\n                     if int.size() == Size::ZERO {\n                         write!(this, \"transmute(())\")?;\n@@ -1063,10 +1088,6 @@ pub trait PrettyPrinter<'tcx>:\n                     print(self)?\n                 };\n             }\n-            // Any pointer values not covered by a branch above\n-            (Scalar::Ptr(p), _) => {\n-                self = self.pretty_print_const_pointer(p, ty, print_ty)?;\n-            }\n         }\n         Ok(self)\n     }"}]}