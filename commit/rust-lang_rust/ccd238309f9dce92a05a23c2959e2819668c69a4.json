{"sha": "ccd238309f9dce92a05a23c2959e2819668c69a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZDIzODMwOWY5ZGNlOTJhMDVhMjNjMjk1OWUyODE5NjY4YzY5YTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-20T20:56:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-20T20:56:09Z"}, "message": "Auto merge of #67020 - pnkfelix:issue-59535-accumulate-past-lto-imports, r=mw\n\nsave LTO import info and check it when trying to reuse build products\n\nFix #59535\n\nPrevious runs of LTO optimization on the previous incremental build can import larger portions of the dependence graph into a codegen unit than the current compilation run is choosing to import. We need to take that into account when we choose to reuse PostLTO-optimization object files from previous compiler invocations.\n\nThis PR accomplishes that by serializing the LTO import information on each incremental build. We load up the previous LTO import data as well as the current LTO import data. Then as we decide whether to reuse previous PostLTO objects or redo LTO optimization, we check whether the LTO import data matches. After we finish with this decision process for every object, we write the LTO import data back to disk.\n\n----\n\nWhat is the scenario where comparing against past LTO import information is necessary?\n\nI've tried to capture it in the comments in the regression test, but here's yet another attempt from me to summarize the situation:\n\n 1. Consider a call-graph like `[A] -> [B -> D] <- [C]` (where the letters are functions and the modules are enclosed in `[]`)\n 2. In our specific instance, the earlier compilations were inlining the call to`B` into `A`; thus `A` ended up with a external reference to the symbol `D` in its object code, to be resolved at subsequent link time. The LTO import information provided by LLVM for those runs reflected that information: it explicitly says during those runs, `B` definition and `D` declaration were imported into `[A]`.\n 3. The change between incremental builds was that the call `D <- C` was removed.\n 4. That change, coupled with other decisions within `rustc`, made the compiler decide to make `D` an internal symbol (since it was no longer accessed from other codegen units, this makes sense locally). And then the definition of `D` was inlined into `B` and `D` itself was eliminated entirely.\n  5. The current LTO import information reported that `B` alone is imported into `[A]` for the *current compilation*. So when the Rust compiler surveyed the dependence graph, it determined that nothing `[A]` imports changed since the last build (and `[A]` itself has not changed either), so it chooses to reuse the object code generated during the previous compilation.\n  6. But that previous object code has an unresolved reference to `D`, and that causes a link time failure!\n\n----\n\nThe interesting thing is that its quite hard to actually observe the above scenario arising, which is probably why no one has noticed this bug in the year or so since incremental LTO support landed (PR #53673).\n\nI've literally spent days trying to observe the bug on my local machine, but haven't managed to find the magic combination of factors to get LLVM and `rustc` to do just the right set of the inlining and `internal`-reclassification choices that cause this particular problem to arise.\n\n----\n\nAlso, I have tried to be careful about injecting new bugs with this PR. Specifically, I was/am worried that we could get into a scenario where overwriting the current LTO import data with past LTO import data would cause us to \"forget\" a current import. ~~To guard against this, the PR as currently written always asserts, at overwrite time, that the past LTO import-set is a *superset* of the current LTO import-set. This way, the overwriting process should always be safe to run.~~\n * The previous note was written based on the first version of this PR. It has since been revised to use a simpler strategy, where we never attempt to merge the past LTO import information into the current one. We just *compare* them, and act accordingly.\n * Also, as you can see from the comments on the PR itself, I was quite right to be worried about forgetting past imports; that scenario was observable via a trivial transformation of the regression test I had devised.", "tree": {"sha": "d613e0c2870c15a5b533a2af30359c56bb4c8558", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d613e0c2870c15a5b533a2af30359c56bb4c8558"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccd238309f9dce92a05a23c2959e2819668c69a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd238309f9dce92a05a23c2959e2819668c69a4", "html_url": "https://github.com/rust-lang/rust/commit/ccd238309f9dce92a05a23c2959e2819668c69a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccd238309f9dce92a05a23c2959e2819668c69a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a46509a4c2dc430ebebf940a26232fdaeeba81", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a46509a4c2dc430ebebf940a26232fdaeeba81", "html_url": "https://github.com/rust-lang/rust/commit/01a46509a4c2dc430ebebf940a26232fdaeeba81"}, {"sha": "42b00a46812bd6af74880984d66a5eac59fca43b", "url": "https://api.github.com/repos/rust-lang/rust/commits/42b00a46812bd6af74880984d66a5eac59fca43b", "html_url": "https://github.com/rust-lang/rust/commit/42b00a46812bd6af74880984d66a5eac59fca43b"}], "stats": {"total": 260, "additions": 250, "deletions": 10}, "files": [{"sha": "6481ef5c73ce011eb7ba27c37914ce4c10dd15f8", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ccd238309f9dce92a05a23c2959e2819668c69a4/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd238309f9dce92a05a23c2959e2819668c69a4/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=ccd238309f9dce92a05a23c2959e2819668c69a4", "patch": "@@ -16,15 +16,24 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_codegen_ssa::{RLIB_BYTECODE_EXTENSION, ModuleCodegen, ModuleKind};\n use log::{info, debug};\n \n use std::ffi::{CStr, CString};\n+use std::fs::File;\n+use std::io;\n+use std::mem;\n+use std::path::Path;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n \n+/// We keep track of past LTO imports that were used to produce the current set\n+/// of compiled object files that we might choose to reuse during this\n+/// compilation session.\n+pub const THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-imports.bin\";\n+\n pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     match crate_type {\n         config::CrateType::Executable |\n@@ -472,13 +481,26 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n         info!(\"thin LTO data created\");\n \n-        let import_map = if cgcx.incr_comp_session_dir.is_some() {\n-            ThinLTOImports::from_thin_lto_data(data)\n+        let (import_map_path, prev_import_map, curr_import_map) =\n+            if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir\n+        {\n+            let path = incr_comp_session_dir.join(THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME);\n+            // If previous imports have been deleted, or we get an IO error\n+            // reading the file storing them, then we'll just use `None` as the\n+            // prev_import_map, which will force the code to be recompiled.\n+            let prev = if path.exists() {\n+                ThinLTOImports::load_from_file(&path).ok()\n+            } else {\n+                None\n+            };\n+            let curr = ThinLTOImports::from_thin_lto_data(data);\n+            (Some(path), prev, curr)\n         } else {\n             // If we don't compile incrementally, we don't need to load the\n             // import data from LLVM.\n             assert!(green_modules.is_empty());\n-            ThinLTOImports::default()\n+            let curr = ThinLTOImports::default();\n+            (None, None, curr)\n         };\n         info!(\"thin LTO import map loaded\");\n \n@@ -502,18 +524,36 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         for (module_index, module_name) in shared.module_names.iter().enumerate() {\n             let module_name = module_name_to_str(module_name);\n \n-            // If the module hasn't changed and none of the modules it imports\n-            // from has changed, we can re-use the post-ThinLTO version of the\n-            // module.\n-            if green_modules.contains_key(module_name) {\n-                let imports_all_green = import_map.modules_imported_by(module_name)\n+            // If (1.) the module hasn't changed, and (2.) none of the modules\n+            // it imports from has changed, *and* (3.) the import-set itself has\n+            // not changed from the previous compile when it was last\n+            // ThinLTO'ed, then we can re-use the post-ThinLTO version of the\n+            // module. Otherwise, freshly perform LTO optimization.\n+            //\n+            // This strategy means we can always save the computed imports as\n+            // canon: when we reuse the post-ThinLTO version, condition (3.)\n+            // ensures that the curent import set is the same as the previous\n+            // one. (And of course, when we don't reuse the post-ThinLTO\n+            // version, the current import set *is* the correct one, since we\n+            // are doing the ThinLTO in this current compilation cycle.)\n+            //\n+            // See rust-lang/rust#59535.\n+            if let (Some(prev_import_map), true) =\n+                (prev_import_map.as_ref(), green_modules.contains_key(module_name))\n+            {\n+                assert!(cgcx.incr_comp_session_dir.is_some());\n+\n+                let prev_imports = prev_import_map.modules_imported_by(module_name);\n+                let curr_imports = curr_import_map.modules_imported_by(module_name);\n+                let imports_all_green = curr_imports\n                     .iter()\n                     .all(|imported_module| green_modules.contains_key(imported_module));\n \n-                if imports_all_green {\n+                if imports_all_green && equivalent_as_sets(prev_imports, curr_imports) {\n                     let work_product = green_modules[module_name].clone();\n                     copy_jobs.push(work_product);\n                     info!(\" - {}: re-used\", module_name);\n+                    assert!(cgcx.incr_comp_session_dir.is_some());\n                     cgcx.cgu_reuse_tracker.set_actual_reuse(module_name,\n                                                             CguReuse::PostLto);\n                     continue\n@@ -527,10 +567,33 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }));\n         }\n \n+        // Save the curent ThinLTO import information for the next compilation\n+        // session, overwriting the previous serialized imports (if any).\n+        if let Some(path) = import_map_path {\n+            if let Err(err) = curr_import_map.save_to_file(&path) {\n+                let msg = format!(\"Error while writing ThinLTO import data: {}\", err);\n+                return Err(write::llvm_err(&diag_handler, &msg));\n+            }\n+        }\n+\n         Ok((opt_jobs, copy_jobs))\n     }\n }\n \n+/// Given two slices, each with no repeat elements. returns true if and only if\n+/// the two slices have the same contents when considered as sets (i.e. when\n+/// element order is disregarded).\n+fn equivalent_as_sets(a: &[String], b: &[String]) -> bool {\n+    // cheap path: unequal lengths means cannot possibly be set equivalent.\n+    if a.len() != b.len() { return false; }\n+    // fast path: before building new things, check if inputs are equivalent as is.\n+    if a == b { return true; }\n+    // slow path: general set comparison.\n+    let a: FxHashSet<&str> = a.iter().map(|s| s.as_str()).collect();\n+    let b: FxHashSet<&str> = b.iter().map(|s| s.as_str()).collect();\n+    a == b\n+}\n+\n pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                     module: &ModuleCodegen<ModuleLlvm>,\n                     config: &ModuleConfig,\n@@ -832,6 +895,47 @@ impl ThinLTOImports {\n         self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n     }\n \n+    fn save_to_file(&self, path: &Path) -> io::Result<()> {\n+        use std::io::Write;\n+        let file = File::create(path)?;\n+        let mut writer = io::BufWriter::new(file);\n+        for (importing_module_name, imported_modules) in &self.imports {\n+            writeln!(writer, \"{}\", importing_module_name)?;\n+            for imported_module in imported_modules {\n+                writeln!(writer, \" {}\", imported_module)?;\n+            }\n+            writeln!(writer)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn load_from_file(path: &Path) -> io::Result<ThinLTOImports> {\n+        use std::io::BufRead;\n+        let mut imports = FxHashMap::default();\n+        let mut current_module = None;\n+        let mut current_imports = vec![];\n+        let file = File::open(path)?;\n+        for line in io::BufReader::new(file).lines() {\n+            let line = line?;\n+            if line.is_empty() {\n+                let importing_module = current_module\n+                    .take()\n+                    .expect(\"Importing module not set\");\n+                imports.insert(importing_module,\n+                               mem::replace(&mut current_imports, vec![]));\n+            } else if line.starts_with(\" \") {\n+                // Space marks an imported module\n+                assert_ne!(current_module, None);\n+                current_imports.push(line.trim().to_string());\n+            } else {\n+                // Otherwise, beginning of a new module (must be start or follow empty line)\n+                assert_eq!(current_module, None);\n+                current_module = Some(line.trim().to_string());\n+            }\n+        }\n+        Ok(ThinLTOImports { imports })\n+    }\n+\n     /// Loads the ThinLTO import map from ThinLTOData.\n     unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImports {\n         unsafe extern \"C\" fn imported_module_callback(payload: *mut libc::c_void,"}, {"sha": "42168dd273eff42627997c1be212f2530f734dae", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_import_added.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ccd238309f9dce92a05a23c2959e2819668c69a4/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_added.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd238309f9dce92a05a23c2959e2819668c69a4/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_added.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_added.rs?ref=ccd238309f9dce92a05a23c2959e2819668c69a4", "patch": "@@ -0,0 +1,62 @@\n+// revisions: cfail1 cfail2\n+// compile-flags: -O -Zhuman-readable-cgu-names -Cllvm-args=-import-instr-limit=10\n+// build-pass\n+\n+// rust-lang/rust#59535:\n+//\n+// This is analgous to cgu_invalidated_when_import_removed.rs, but it covers\n+// the other direction:\n+//\n+// We start with a call-graph like `[A] -> [B -> D] [C]` (where the letters are\n+// functions and the modules are enclosed in `[]`), and add a new call `D <- C`,\n+// yielding the new call-graph: `[A] -> [B -> D] <- [C]`\n+//\n+// The effect of this is that the compiler previously classfied `D` as internal\n+// and the import-set of `[A]` to be just `B`. But after adding the `D <- C` call,\n+// `D` is no longer classified as internal, and the import-set of `[A]` becomes\n+// both `B` and `D`.\n+//\n+// We check this case because an early proposed pull request included an\n+// assertion that the import-sets monotonically decreased over time, a claim\n+// which this test case proves to be false.\n+\n+fn main() {\n+    foo::foo();\n+    bar::baz();\n+}\n+\n+mod foo {\n+\n+    // In cfail1, ThinLTO decides that foo() does not get inlined into main, and\n+    // instead bar() gets inlined into foo().\n+    // In cfail2, foo() gets inlined into main.\n+    pub fn foo(){\n+        bar()\n+    }\n+\n+    // This function needs to be big so that it does not get inlined by ThinLTO\n+    // but *does* get inlined into foo() when it is declared `internal` in\n+    // cfail1 (alone).\n+    pub fn bar(){\n+        println!(\"quux1\");\n+        println!(\"quux2\");\n+        println!(\"quux3\");\n+        println!(\"quux4\");\n+        println!(\"quux5\");\n+        println!(\"quux6\");\n+        println!(\"quux7\");\n+        println!(\"quux8\");\n+        println!(\"quux9\");\n+    }\n+}\n+\n+mod bar {\n+\n+    #[inline(never)]\n+    pub fn baz() {\n+        #[cfg(cfail2)]\n+        {\n+            crate::foo::bar();\n+        }\n+    }\n+}"}, {"sha": "19ce7b3e148f73f0388ab80dc21049f9a60120e6", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_import_removed.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ccd238309f9dce92a05a23c2959e2819668c69a4/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccd238309f9dce92a05a23c2959e2819668c69a4/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_import_removed.rs?ref=ccd238309f9dce92a05a23c2959e2819668c69a4", "patch": "@@ -0,0 +1,74 @@\n+// revisions: cfail1 cfail2\n+// compile-flags: -O -Zhuman-readable-cgu-names -Cllvm-args=-import-instr-limit=10\n+// build-pass\n+\n+// rust-lang/rust#59535:\n+//\n+// Consider a call-graph like `[A] -> [B -> D] <- [C]` (where the letters are\n+// functions and the modules are enclosed in `[]`)\n+//\n+// In our specific instance, the earlier compilations were inlining the call\n+// to`B` into `A`; thus `A` ended up with a external reference to the symbol `D`\n+// in its object code, to be resolved at subsequent link time. The LTO import\n+// information provided by LLVM for those runs reflected that information: it\n+// explicitly says during those runs, `B` definition and `D` declaration were\n+// imported into `[A]`.\n+//\n+// The change between incremental builds was that the call `D <- C` was removed.\n+//\n+// That change, coupled with other decisions within `rustc`, made the compiler\n+// decide to make `D` an internal symbol (since it was no longer accessed from\n+// other codegen units, this makes sense locally). And then the definition of\n+// `D` was inlined into `B` and `D` itself was eliminated entirely.\n+//\n+// The current LTO import information reported that `B` alone is imported into\n+// `[A]` for the *current compilation*. So when the Rust compiler surveyed the\n+// dependence graph, it determined that nothing `[A]` imports changed since the\n+// last build (and `[A]` itself has not changed either), so it chooses to reuse\n+// the object code generated during the previous compilation.\n+//\n+// But that previous object code has an unresolved reference to `D`, and that\n+// causes a link time failure!\n+\n+fn main() {\n+    foo::foo();\n+    bar::baz();\n+}\n+\n+mod foo {\n+\n+    // In cfail1, foo() gets inlined into main.\n+    // In cfail2, ThinLTO decides that foo() does not get inlined into main, and\n+    // instead bar() gets inlined into foo(). But faulty logic in our incr.\n+    // ThinLTO implementation thought that `main()` is unchanged and thus reused\n+    // the object file still containing a call to the now non-existant bar().\n+    pub fn foo(){\n+        bar()\n+    }\n+\n+    // This function needs to be big so that it does not get inlined by ThinLTO\n+    // but *does* get inlined into foo() once it is declared `internal` in\n+    // cfail2.\n+    pub fn bar(){\n+        println!(\"quux1\");\n+        println!(\"quux2\");\n+        println!(\"quux3\");\n+        println!(\"quux4\");\n+        println!(\"quux5\");\n+        println!(\"quux6\");\n+        println!(\"quux7\");\n+        println!(\"quux8\");\n+        println!(\"quux9\");\n+    }\n+}\n+\n+mod bar {\n+\n+    #[inline(never)]\n+    pub fn baz() {\n+        #[cfg(cfail1)]\n+        {\n+            crate::foo::bar();\n+        }\n+    }\n+}"}]}