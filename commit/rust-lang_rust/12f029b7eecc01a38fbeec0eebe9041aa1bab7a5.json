{"sha": "12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZjAyOWI3ZWVjYzAxYTM4ZmJlZWMwZWViZTkwNDFhYTFiYWI3YTU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-10T01:07:13Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-15T12:43:09Z"}, "message": "Fix deref impl on type alias", "tree": {"sha": "4a2e203e3246024c00110e370abc908151ea8f19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a2e203e3246024c00110e370abc908151ea8f19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "html_url": "https://github.com/rust-lang/rust/commit/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf84eb538fd16743240434b3e837b36c35719fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf84eb538fd16743240434b3e837b36c35719fee", "html_url": "https://github.com/rust-lang/rust/commit/bf84eb538fd16743240434b3e837b36c35719fee"}], "stats": {"total": 117, "additions": 90, "deletions": 27}, "files": [{"sha": "fc75bf35b250d0e3e9c518f96fa105a390026c98", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "patch": "@@ -273,6 +273,24 @@ fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n     clean::Typedef {\n         type_: cx.tcx.type_of(did).clean(cx),\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        item_type: build_type_alias_type(cx, did),\n+    }\n+}\n+\n+fn build_type_alias_type(cx: &DocContext<'_>, did: DefId) -> Option<clean::Type> {\n+    let type_ = cx.tcx.type_of(did).clean(cx);\n+    type_.def_id().and_then(|did| build_ty(cx, did))\n+}\n+\n+pub fn build_ty(cx: &DocContext, did: DefId) -> Option<clean::Type> {\n+    match cx.tcx.def_kind(did)? {\n+        DefKind::Struct |\n+        DefKind::Union |\n+        DefKind::Enum |\n+        DefKind::Const |\n+        DefKind::Static => Some(cx.tcx.type_of(did).clean(cx)),\n+        DefKind::TyAlias => build_type_alias_type(cx, did),\n+        _ => None,\n     }\n }\n "}, {"sha": "0cc4c55f49be82b335a5ff945298e61945415455", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "patch": "@@ -1122,7 +1122,16 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 MethodItem((sig, &self.generics, body, Some(self.defaultness)).clean(cx))\n             }\n             hir::ImplItemKind::TyAlias(ref ty) => {\n-                TypedefItem(Typedef { type_: ty.clean(cx), generics: Generics::default() }, true)\n+                let type_ = ty.clean(cx);\n+                let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n+                TypedefItem(\n+                    Typedef {\n+                        type_,\n+                        generics: Generics::default(),\n+                        item_type,\n+                    },\n+                    true,\n+                )\n             }\n             hir::ImplItemKind::OpaqueTy(ref bounds) => OpaqueTyItem(\n                 OpaqueTy { bounds: bounds.clean(cx), generics: Generics::default() },\n@@ -1282,10 +1291,13 @@ impl Clean<Item> for ty::AssocItem {\n \n                     AssocTypeItem(bounds, ty.clean(cx))\n                 } else {\n+                    let type_ = cx.tcx.type_of(self.def_id).clean(cx);\n+                    let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n                     TypedefItem(\n                         Typedef {\n-                            type_: cx.tcx.type_of(self.def_id).clean(cx),\n+                            type_,\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                            item_type,\n                         },\n                         true,\n                     )\n@@ -1989,6 +2001,8 @@ impl Clean<String> for ast::Name {\n \n impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n+        let type_ = self.ty.clean(cx);\n+        let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1998,7 +2012,11 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: TypedefItem(\n-                Typedef { type_: self.ty.clean(cx), generics: self.gen.clean(cx) },\n+                Typedef {\n+                    type_,\n+                    generics: self.gen.clean(cx),\n+                    item_type,\n+                },\n                 false,\n             ),\n         }"}, {"sha": "79a078ca7a991abdaf58ccdf8728d6e22b466fbf", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "patch": "@@ -1406,6 +1406,14 @@ pub struct PathSegment {\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n+    // Type of target item.\n+    pub item_type: Option<Type>,\n+}\n+\n+impl GetDefId for Typedef {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.type_.def_id()\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "69e268f3f80c1688f9e64cef00b06d327b2eecd9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "patch": "@@ -3469,22 +3469,27 @@ fn render_deref_methods(\n     deref_mut: bool,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n-    let target = impl_\n+    let (target, real_target) = impl_\n         .inner_impl()\n         .items\n         .iter()\n         .filter_map(|item| match item.inner {\n-            clean::TypedefItem(ref t, true) => Some(&t.type_),\n+            clean::TypedefItem(ref t, true) => {\n+                Some(match *t {\n+                    clean::Typedef { item_type: Some(ref type_), .. } => (&t.type_, type_),\n+                    _ => (&t.type_, &t.type_),\n+                })\n+            }\n             _ => None,\n         })\n         .next()\n         .expect(\"Expected associated type binding\");\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: target, deref_mut_: deref_mut };\n-    if let Some(did) = target.def_id() {\n+    if let Some(did) = real_target.def_id() {\n         render_assoc_items(w, cx, container_item, did, what)\n     } else {\n-        if let Some(prim) = target.primitive_type() {\n+        if let Some(prim) = real_target.primitive_type() {\n             if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n                 render_assoc_items(w, cx, container_item, did, what);\n             }\n@@ -4123,17 +4128,22 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n-                if let Some(target) = impl_\n+                if let Some((target, real_target)) = impl_\n                     .inner_impl()\n                     .items\n                     .iter()\n                     .filter_map(|item| match item.inner {\n-                        clean::TypedefItem(ref t, true) => Some(&t.type_),\n+                        clean::TypedefItem(ref t, true) => {\n+                            Some(match *t {\n+                                clean::Typedef { item_type: Some(ref type_), .. } => (&t.type_, type_),\n+                                _ => (&t.type_, &t.type_),\n+                            })\n+                        }\n                         _ => None,\n                     })\n                     .next()\n                 {\n-                    let inner_impl = target\n+                    let inner_impl = real_target\n                         .def_id()\n                         .or(target\n                             .primitive_type()"}, {"sha": "cdfd6b3073adfc9e230a5449e4a02055186fbf31", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f029b7eecc01a38fbeec0eebe9041aa1bab7a5/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=12f029b7eecc01a38fbeec0eebe9041aa1bab7a5", "patch": "@@ -277,7 +277,7 @@ impl DocFolder for Cache {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.parent_stack.last().unwrap()),\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n                         Some(&self.stack[..self.stack.len() - 1]),\n                     ),\n                     false,\n@@ -286,7 +286,7 @@ impl DocFolder for Cache {\n                     if self.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n-                        let last = self.parent_stack.last().unwrap();\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n                             // The current stack not necessarily has correlation\n@@ -468,7 +468,7 @@ impl DocFolder for Cache {\n                         self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n                     }\n                 } else {\n-                    let trait_did = impl_item.trait_did().unwrap();\n+                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n                     self.orphan_trait_impls.push((trait_did, dids, impl_item));\n                 }\n                 None\n@@ -478,10 +478,10 @@ impl DocFolder for Cache {\n         });\n \n         if pushed {\n-            self.stack.pop().unwrap();\n+            self.stack.pop().expect(\"stack already empty\");\n         }\n         if parent_pushed {\n-            self.parent_stack.pop().unwrap();\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n         self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n@@ -574,6 +574,9 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     // has since been learned.\n     for &(did, ref item) in orphan_impl_items {\n         if let Some(&(ref fqp, _)) = paths.get(&did) {\n+            if item.name.is_none() { // this is most likely from a typedef\n+                continue;\n+            }\n             search_index.push(IndexItem {\n                 ty: item.type_(),\n                 name: item.name.clone().unwrap(),\n@@ -592,19 +595,25 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut lastpathid = 0usize;\n \n     for item in search_index {\n-        item.parent_idx = item.parent.map(|nodeid| {\n-            if nodeid_to_pathid.contains_key(&nodeid) {\n-                *nodeid_to_pathid.get(&nodeid).unwrap()\n-            } else {\n-                let pathid = lastpathid;\n-                nodeid_to_pathid.insert(nodeid, pathid);\n-                lastpathid += 1;\n+        item.parent_idx = match item.parent {\n+            Some(nodeid) => {\n+                Some(if nodeid_to_pathid.contains_key(&nodeid) {\n+                    *nodeid_to_pathid.get(&nodeid).expect(\"no pathid\")\n+                } else {\n+                    let pathid = lastpathid;\n+                    nodeid_to_pathid.insert(nodeid, pathid);\n+                    lastpathid += 1;\n \n-                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n-                crate_paths.push((short, fqp.last().unwrap().clone()));\n-                pathid\n+                    if let Some(&(ref fqp, short)) = paths.get(&nodeid) {\n+                        crate_paths.push((short, fqp.last().expect(\"no fqp\").clone()));\n+                    } else {\n+                        continue\n+                    }\n+                    pathid\n+                })\n             }\n-        });\n+            None => None,\n+        };\n \n         // Omit the parent path if it is same to that of the prior item.\n         if lastpath == item.path {\n@@ -639,7 +648,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n             items: crate_items,\n             paths: crate_paths,\n         })\n-        .unwrap()\n+        .expect(\"failed serde conversion\")\n     )\n }\n "}]}