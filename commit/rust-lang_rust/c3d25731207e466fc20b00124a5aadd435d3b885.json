{"sha": "c3d25731207e466fc20b00124a5aadd435d3b885", "node_id": "C_kwDOAAsO6NoAKGMzZDI1NzMxMjA3ZTQ2NmZjMjBiMDAxMjRhNWFhZGQ0MzVkM2I4ODU", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2023-01-17T11:05:01Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2023-01-19T09:40:47Z"}, "message": "Use UnordMap instead of FxHashMap in define_id_collections!().", "tree": {"sha": "77aa0c3f673405aa4fb89b5e08798624264a468b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77aa0c3f673405aa4fb89b5e08798624264a468b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d25731207e466fc20b00124a5aadd435d3b885", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d25731207e466fc20b00124a5aadd435d3b885", "html_url": "https://github.com/rust-lang/rust/commit/c3d25731207e466fc20b00124a5aadd435d3b885", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d25731207e466fc20b00124a5aadd435d3b885/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a1de57a4aaf4ff13d20fdbc162064f237bb7679", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a1de57a4aaf4ff13d20fdbc162064f237bb7679", "html_url": "https://github.com/rust-lang/rust/commit/8a1de57a4aaf4ff13d20fdbc162064f237bb7679"}], "stats": {"total": 357, "additions": 254, "deletions": 103}, "files": [{"sha": "b442483346d6cde5c21433262e4d71e164fe3fce", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -173,11 +173,15 @@ fn exported_symbols_provider_local(\n         return &[];\n     }\n \n-    let mut symbols: Vec<_> = tcx\n-        .reachable_non_generics(LOCAL_CRATE)\n-        .iter()\n-        .map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info))\n-        .collect();\n+    // FIXME: Sorting this is unnecessary since we are sorting later anyway.\n+    //        Can we skip the later sorting?\n+    let mut symbols: Vec<_> = tcx.with_stable_hashing_context(|hcx| {\n+        tcx.reachable_non_generics(LOCAL_CRATE)\n+            .to_sorted(&hcx)\n+            .into_iter()\n+            .map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info))\n+            .collect()\n+    });\n \n     if tcx.entry_fn(()).is_some() {\n         let exported_symbol ="}, {"sha": "9fce0e1e65cc90f416fe8fa228a861796a51a5d9", "filename": "compiler/rustc_data_structures/src/fx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -11,7 +11,7 @@ pub type IndexEntry<'a, K, V> = indexmap::map::Entry<'a, K, V>;\n #[macro_export]\n macro_rules! define_id_collections {\n     ($map_name:ident, $set_name:ident, $entry_name:ident, $key:ty) => {\n-        pub type $map_name<T> = $crate::fx::FxHashMap<$key, T>;\n+        pub type $map_name<T> = $crate::unord::UnordMap<$key, T>;\n         pub type $set_name = $crate::unord::UnordSet<$key>;\n         pub type $entry_name<'a, T> = $crate::fx::StdEntry<'a, $key, T>;\n     };"}, {"sha": "1e71629a7c4e046bf872ef2d120ff0a8a6c11899", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 108, "deletions": 2, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -6,8 +6,10 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use smallvec::SmallVec;\n use std::{\n     borrow::Borrow,\n+    collections::hash_map::Entry,\n     hash::Hash,\n     iter::{Product, Sum},\n+    ops::Index,\n };\n \n use crate::{\n@@ -187,7 +189,16 @@ impl<V: Eq + Hash> UnordSet<V> {\n     }\n \n     #[inline]\n-    pub fn items(&self) -> UnordItems<&V, impl Iterator<Item = &V>> {\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> bool\n+    where\n+        V: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.remove(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -254,6 +265,18 @@ impl<K: Hash + Eq, V> Extend<(K, V)> for UnordMap<K, V> {\n     }\n }\n \n+impl<K: Hash + Eq, V> FromIterator<(K, V)> for UnordMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self {\n+        UnordMap { inner: FxHashMap::from_iter(iter) }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V, I: Iterator<Item = (K, V)>> From<UnordItems<(K, V), I>> for UnordMap<K, V> {\n+    fn from(items: UnordItems<(K, V), I>) -> Self {\n+        UnordMap { inner: FxHashMap::from_iter(items.0) }\n+    }\n+}\n+\n impl<K: Eq + Hash, V> UnordMap<K, V> {\n     #[inline]\n     pub fn len(&self) -> usize {\n@@ -275,7 +298,44 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn items(&self) -> UnordItems<(&K, &V), impl Iterator<Item = (&K, &V)>> {\n+    pub fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+        self.inner.entry(key)\n+    }\n+\n+    #[inline]\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.get(k)\n+    }\n+\n+    #[inline]\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.get_mut(k)\n+    }\n+\n+    #[inline]\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.remove(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -290,6 +350,46 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     pub fn extend<I: Iterator<Item = (K, V)>>(&mut self, items: UnordItems<(K, V), I>) {\n         self.inner.extend(items.0)\n     }\n+\n+    pub fn to_sorted<HCX>(&self, hcx: &HCX) -> Vec<(&K, &V)>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        let mut items: Vec<(&K, &V)> = self.inner.iter().collect();\n+        items.sort_by_cached_key(|(k, _)| k.to_stable_hash_key(hcx));\n+        items\n+    }\n+\n+    pub fn into_sorted<HCX>(self, hcx: &HCX) -> Vec<(K, V)>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        let mut items: Vec<(K, V)> = self.inner.into_iter().collect();\n+        items.sort_by_cached_key(|(k, _)| k.to_stable_hash_key(hcx));\n+        items\n+    }\n+\n+    pub fn values_sorted<HCX>(&self, hcx: &HCX) -> impl Iterator<Item = &V>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        let mut items: Vec<(&K, &V)> = self.inner.iter().collect();\n+        items.sort_by_cached_key(|(k, _)| k.to_stable_hash_key(hcx));\n+        items.into_iter().map(|(_, v)| v)\n+    }\n+}\n+\n+impl<K, Q: ?Sized, V> Index<&Q> for UnordMap<K, V>\n+where\n+    K: Eq + Hash + Borrow<Q>,\n+    Q: Eq + Hash,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, key: &Q) -> &V {\n+        &self.inner[key]\n+    }\n }\n \n impl<HCX, K: Hash + Eq + HashStable<HCX>, V: HashStable<HCX>> HashStable<HCX> for UnordMap<K, V> {\n@@ -354,6 +454,12 @@ impl<T> Extend<T> for UnordBag<T> {\n     }\n }\n \n+impl<T, I: Iterator<Item = T>> From<UnordItems<T, I>> for UnordBag<T> {\n+    fn from(value: UnordItems<T, I>) -> Self {\n+        UnordBag { inner: Vec::from_iter(value.0) }\n+    }\n+}\n+\n impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordBag<V> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {"}, {"sha": "2d283532bdfc3dea4d32008fe31b3839d617207d", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -5,8 +5,7 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::DefIdMap;\n use rustc_middle::ty;\n \n use super::constraints::*;\n@@ -89,14 +88,12 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn create_map(&self) -> FxHashMap<DefId, &'tcx [ty::Variance]> {\n+    fn create_map(&self) -> DefIdMap<&'tcx [ty::Variance]> {\n         let tcx = self.terms_cx.tcx;\n \n         let solutions = &self.solutions;\n-        self.terms_cx\n-            .inferred_starts\n-            .iter()\n-            .map(|(&def_id, &InferredIndex(start))| {\n+        DefIdMap::from(self.terms_cx.inferred_starts.items().map(\n+            |(&def_id, &InferredIndex(start))| {\n                 let generics = tcx.generics_of(def_id);\n                 let count = generics.count();\n \n@@ -115,8 +112,8 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 }\n \n                 (def_id.to_def_id(), &*variances)\n-            })\n-            .collect()\n+            },\n+        ))\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "6e6b63beca2a7784bf708219a1c8b78fda1724fe", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -449,8 +449,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (id, origin) in fcx_typeck_results.closure_kind_origins().iter() {\n-            let hir_id = hir::HirId { owner: common_hir_owner, local_id: *id };\n+        let fcx_closure_kind_origins =\n+            fcx_typeck_results.closure_kind_origins().items_in_stable_order(self.tcx());\n+\n+        for (&local_id, origin) in fcx_closure_kind_origins {\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let place_span = origin.0;\n             let place = self.resolve(origin.1.clone(), &place_span);\n             self.typeck_results.closure_kind_origins_mut().insert(hir_id, (place_span, place));\n@@ -477,22 +480,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        let mut errors_buffer = Vec::new();\n-        for (&local_id, c_ty) in fcx_typeck_results.user_provided_types().iter() {\n-            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n-\n-            if cfg!(debug_assertions) && c_ty.needs_infer() {\n-                span_bug!(\n-                    hir_id.to_span(self.fcx.tcx),\n-                    \"writeback: `{:?}` has inference variables\",\n-                    c_ty\n-                );\n-            };\n+        if self.rustc_dump_user_substs {\n+            let sorted_user_provided_types =\n+                fcx_typeck_results.user_provided_types().items_in_stable_order(self.tcx());\n \n-            self.typeck_results.user_provided_types_mut().insert(hir_id, *c_ty);\n+            let mut errors_buffer = Vec::new();\n+            for (&local_id, c_ty) in sorted_user_provided_types {\n+                let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-            if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n-                if self.rustc_dump_user_substs {\n+                if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n                     // This is a unit-testing mechanism.\n                     let span = self.tcx().hir().span(hir_id);\n                     // We need to buffer the errors in order to guarantee a consistent\n@@ -504,31 +500,49 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     err.buffer(&mut errors_buffer);\n                 }\n             }\n-        }\n \n-        if !errors_buffer.is_empty() {\n-            errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n-            for mut diag in errors_buffer {\n-                self.tcx().sess.diagnostic().emit_diagnostic(&mut diag);\n+            if !errors_buffer.is_empty() {\n+                errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n+                for mut diag in errors_buffer {\n+                    self.tcx().sess.diagnostic().emit_diagnostic(&mut diag);\n+                }\n             }\n         }\n+\n+        self.typeck_results.user_provided_types_mut().extend(\n+            fcx_typeck_results.user_provided_types().items().map(|(local_id, c_ty)| {\n+                let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n+\n+                if cfg!(debug_assertions) && c_ty.needs_infer() {\n+                    span_bug!(\n+                        hir_id.to_span(self.fcx.tcx),\n+                        \"writeback: `{:?}` has inference variables\",\n+                        c_ty\n+                    );\n+                };\n+\n+                (hir_id, *c_ty)\n+            }),\n+        );\n     }\n \n     fn visit_user_provided_sigs(&mut self) {\n         let fcx_typeck_results = self.fcx.typeck_results.borrow();\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n \n-        for (&def_id, c_sig) in fcx_typeck_results.user_provided_sigs.iter() {\n-            if cfg!(debug_assertions) && c_sig.needs_infer() {\n-                span_bug!(\n-                    self.fcx.tcx.def_span(def_id),\n-                    \"writeback: `{:?}` has inference variables\",\n-                    c_sig\n-                );\n-            };\n-\n-            self.typeck_results.user_provided_sigs.insert(def_id, *c_sig);\n-        }\n+        self.typeck_results.user_provided_sigs.extend(\n+            fcx_typeck_results.user_provided_sigs.items().map(|(&def_id, c_sig)| {\n+                if cfg!(debug_assertions) && c_sig.needs_infer() {\n+                    span_bug!(\n+                        self.fcx.tcx.def_span(def_id),\n+                        \"writeback: `{:?}` has inference variables\",\n+                        c_sig\n+                    );\n+                };\n+\n+                (def_id, *c_sig)\n+            }),\n+        );\n     }\n \n     fn visit_generator_interior_types(&mut self) {\n@@ -647,7 +661,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, &fn_sig) in fcx_typeck_results.liberated_fn_sigs().iter() {\n+        let fcx_liberated_fn_sigs =\n+            fcx_typeck_results.liberated_fn_sigs().items_in_stable_order(self.tcx());\n+\n+        for (&local_id, &fn_sig) in fcx_liberated_fn_sigs {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n             self.typeck_results.liberated_fn_sigs_mut().insert(hir_id, fn_sig);\n@@ -659,7 +676,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, ftys) in fcx_typeck_results.fru_field_types().iter() {\n+        let fcx_fru_field_types =\n+            fcx_typeck_results.fru_field_types().items_in_stable_order(self.tcx());\n+\n+        for (&local_id, ftys) in fcx_fru_field_types {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let ftys = self.resolve(ftys.clone(), &hir_id);\n             self.typeck_results.fru_field_types_mut().insert(hir_id, ftys);"}, {"sha": "9aca485e502e663c58c5ce879b1ca5c0d62c87be", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -6,8 +6,9 @@\n extern crate rustc_macros;\n \n pub use self::Level::*;\n-use rustc_ast::node_id::{NodeId, NodeMap};\n+use rustc_ast::node_id::NodeId;\n use rustc_ast::{AttrId, Attribute};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_error_messages::{DiagnosticMessage, MultiSpan};\n use rustc_hir::HashStableContext;\n@@ -544,7 +545,7 @@ pub struct BufferedEarlyLint {\n \n #[derive(Default)]\n pub struct LintBuffer {\n-    pub map: NodeMap<Vec<BufferedEarlyLint>>,\n+    pub map: FxIndexMap<NodeId, Vec<BufferedEarlyLint>>,\n }\n \n impl LintBuffer {"}, {"sha": "78997961d173d54b55934ed4325dbe55cd4b0925", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -382,7 +382,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             // keys from the former.\n             // This is a rudimentary check that does not catch all cases,\n             // just the easiest.\n-            let mut fallback_map: DefIdMap<DefId> = Default::default();\n+            let mut fallback_map: Vec<(DefId, DefId)> = Default::default();\n \n             // Issue 46112: We want the map to prefer the shortest\n             // paths when reporting the path to an item. Therefore we\n@@ -412,12 +412,12 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n \n                 if let Some(def_id) = child.res.opt_def_id() {\n                     if child.ident.name == kw::Underscore {\n-                        fallback_map.insert(def_id, parent);\n+                        fallback_map.push((def_id, parent));\n                         return;\n                     }\n \n                     if ty::util::is_doc_hidden(tcx, parent) {\n-                        fallback_map.insert(def_id, parent);\n+                        fallback_map.push((def_id, parent));\n                         return;\n                     }\n \n@@ -451,6 +451,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             // Fill in any missing entries with the less preferable path.\n             // If this path re-exports the child as `_`, we still use this\n             // path in a diagnostic that suggests importing `::*`.\n+\n             for (child, parent) in fallback_map {\n                 visible_parent_map.entry(child).or_insert(parent);\n             }"}, {"sha": "c3292681cc6abc055789996dddef23322632720f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -1187,8 +1187,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n         }\n-        let inherent_impls = tcx.crate_inherent_impls(());\n-        for (def_id, implementations) in inherent_impls.inherent_impls.iter() {\n+        let inherent_impls = tcx.with_stable_hashing_context(|hcx| {\n+            tcx.crate_inherent_impls(()).inherent_impls.to_sorted(&hcx)\n+        });\n+\n+        for (def_id, implementations) in inherent_impls {\n             if implementations.is_empty() {\n                 continue;\n             }"}, {"sha": "7dfcd1bb5074d50863784d5168ca751851dcdd57", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -38,7 +38,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n@@ -436,7 +436,7 @@ pub struct CrateVariancesMap<'tcx> {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics. If an item has no generics, it will have no\n     /// entry.\n-    pub variances: FxHashMap<DefId, &'tcx [ty::Variance]>,\n+    pub variances: DefIdMap<&'tcx [ty::Variance]>,\n }\n \n // Contains information needed to resolve types and (in the future) look up"}, {"sha": "0eaa47178c05da46a6ff0fdf978103bef248922b", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -6,7 +6,12 @@ use crate::{\n         GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n     },\n };\n-use rustc_data_structures::{fx::FxHashMap, sync::Lrc, unord::UnordSet, vec_map::VecMap};\n+use rustc_data_structures::{\n+    fx::FxHashMap,\n+    sync::Lrc,\n+    unord::{UnordItems, UnordSet},\n+    vec_map::VecMap,\n+};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::{\n@@ -20,13 +25,9 @@ use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n use rustc_session::Session;\n use rustc_span::Span;\n-use std::{\n-    collections::hash_map::{self, Entry},\n-    hash::Hash,\n-    iter,\n-};\n+use std::{collections::hash_map::Entry, hash::Hash, iter};\n \n-use super::RvalueScopes;\n+use super::{RvalueScopes, TyCtxt};\n \n #[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct TypeckResults<'tcx> {\n@@ -567,8 +568,16 @@ impl<'a, V> LocalTableInContext<'a, V> {\n         self.data.get(&id.local_id)\n     }\n \n-    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n-        self.data.iter()\n+    pub fn items(\n+        &'a self,\n+    ) -> UnordItems<(hir::ItemLocalId, &'a V), impl Iterator<Item = (hir::ItemLocalId, &'a V)>>\n+    {\n+        self.data.items().map(|(id, value)| (*id, value))\n+    }\n+\n+    #[allow(rustc::pass_by_value)]\n+    pub fn items_in_stable_order(&self, tcx: TyCtxt<'_>) -> Vec<(&'a ItemLocalId, &'a V)> {\n+        tcx.with_stable_hashing_context(|hcx| self.data.to_sorted(&hcx))\n     }\n }\n \n@@ -605,6 +614,16 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n         validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.remove(&id.local_id)\n     }\n+\n+    pub fn extend(\n+        &mut self,\n+        items: UnordItems<(hir::HirId, V), impl Iterator<Item = (hir::HirId, V)>>,\n+    ) {\n+        self.data.extend(items.map(|(id, value)| {\n+            validate_hir_id_for_typeck_results(self.hir_owner, id);\n+            (id.local_id, value)\n+        }))\n+    }\n }\n \n rustc_index::newtype_index! {"}, {"sha": "eae4c9992eb08d4a6c31118b0fb73abf8d5ce2ea", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -28,9 +28,9 @@ use crate::module_to_string;\n use crate::Resolver;\n \n use rustc_ast as ast;\n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{pluralize, MultiSpan};\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -40,7 +40,7 @@ struct UnusedImport<'a> {\n     use_tree: &'a ast::UseTree,\n     use_tree_id: ast::NodeId,\n     item_span: Span,\n-    unused: FxHashSet<ast::NodeId>,\n+    unused: UnordSet<ast::NodeId>,\n }\n \n impl<'a> UnusedImport<'a> {\n@@ -52,7 +52,7 @@ impl<'a> UnusedImport<'a> {\n struct UnusedImportCheckVisitor<'a, 'b> {\n     r: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n-    unused_imports: NodeMap<UnusedImport<'a>>,\n+    unused_imports: FxIndexMap<ast::NodeId, UnusedImport<'a>>,\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n@@ -89,7 +89,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n             use_tree,\n             use_tree_id,\n             item_span,\n-            unused: FxHashSet::default(),\n+            unused: Default::default(),\n         })\n     }\n }"}, {"sha": "81b37ce5dfc2d2da44b43acafc19401737cbec14", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -52,21 +52,19 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n         // List of spans to lint. (lint_span, first_span)\n         let mut lint_spans = Vec::new();\n \n-        for (_, impl_ids) in cx\n+        let inherent_impls = cx\n             .tcx\n-            .crate_inherent_impls(())\n-            .inherent_impls\n-            .iter()\n-            .filter(|(&id, impls)| {\n-                impls.len() > 1\n-                    // Check for `#[allow]` on the type definition\n-                    && !is_lint_allowed(\n-                        cx,\n-                        MULTIPLE_INHERENT_IMPL,\n-                        cx.tcx.hir().local_def_id_to_hir_id(id),\n-                    )\n-            })\n-        {\n+            .with_stable_hashing_context(|hcx| cx.tcx.crate_inherent_impls(()).inherent_impls.to_sorted(&hcx));\n+\n+        for (_, impl_ids) in inherent_impls.into_iter().filter(|(&id, impls)| {\n+            impls.len() > 1\n+            // Check for `#[allow]` on the type definition\n+            && !is_lint_allowed(\n+                cx,\n+                MULTIPLE_INHERENT_IMPL,\n+                cx.tcx.hir().local_def_id_to_hir_id(id),\n+            )\n+        }) {\n             for impl_id in impl_ids.iter().map(|id| id.expect_local()) {\n                 match type_map.entry(cx.tcx.type_of(impl_id)) {\n                     Entry::Vacant(e) => {"}, {"sha": "d1a1f773f87b3b0878b83ab05a261a8ea89ab4c9", "filename": "src/tools/clippy/clippy_lints/src/loops/while_immutable_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'\n         } else {\n             return;\n         };\n-    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n+    let mutable_static_in_cond = var_visitor.def_ids.items().any(|(_, v)| *v);\n \n     let mut has_break_or_return_visitor = HasBreakOrReturnVisitor {\n         has_break_or_return: false,"}, {"sha": "1c61c6e551c35c785a1d2b553b125247713e3965", "filename": "src/tools/clippy/clippy_lints/src/missing_trait_methods.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -80,19 +80,21 @@ impl<'tcx> LateLintPass<'tcx> for MissingTraitMethods {\n                 }\n             }\n \n-            for assoc in provided.values() {\n-                let source_map = cx.tcx.sess.source_map();\n-                let definition_span = source_map.guess_head_span(cx.tcx.def_span(assoc.def_id));\n+            cx.tcx.with_stable_hashing_context(|hcx| {\n+                for assoc in provided.values_sorted(&hcx) {\n+                    let source_map = cx.tcx.sess.source_map();\n+                    let definition_span = source_map.guess_head_span(cx.tcx.def_span(assoc.def_id));\n \n-                span_lint_and_help(\n-                    cx,\n-                    MISSING_TRAIT_METHODS,\n-                    source_map.guess_head_span(item.span),\n-                    &format!(\"missing trait method provided by default: `{}`\", assoc.name),\n-                    Some(definition_span),\n-                    \"implement the method\",\n-                );\n-            }\n+                    span_lint_and_help(\n+                        cx,\n+                        MISSING_TRAIT_METHODS,\n+                        source_map.guess_head_span(item.span),\n+                        &format!(\"missing trait method provided by default: `{}`\", assoc.name),\n+                        Some(definition_span),\n+                        \"implement the method\",\n+                    );\n+                }\n+            })\n         }\n     }\n }"}, {"sha": "2d21aaa4f7fdb5606f560763c8e00dcac0a8ab93", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d25731207e466fc20b00124a5aadd435d3b885/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=c3d25731207e466fc20b00124a5aadd435d3b885", "patch": "@@ -190,10 +190,10 @@ impl<'tcx> PassByRefOrValue {\n                             // Don't lint if an unsafe pointer is created.\n                             // TODO: Limit the check only to unsafe pointers to the argument (or part of the argument)\n                             //       which escape the current function.\n-                            if typeck.node_types().iter().any(|(_, &ty)| ty.is_unsafe_ptr())\n+                            if typeck.node_types().items().any(|(_, &ty)| ty.is_unsafe_ptr())\n                                 || typeck\n                                     .adjustments()\n-                                    .iter()\n+                                    .items()\n                                     .flat_map(|(_, a)| a)\n                                     .any(|a| matches!(a.kind, Adjust::Pointer(PointerCast::UnsafeFnPointer)))\n                             {"}]}