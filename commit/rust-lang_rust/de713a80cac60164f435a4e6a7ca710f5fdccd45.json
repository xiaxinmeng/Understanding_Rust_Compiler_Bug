{"sha": "de713a80cac60164f435a4e6a7ca710f5fdccd45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNzEzYTgwY2FjNjAxNjRmNDM1YTRlNmE3Y2E3MTBmNWZkY2NkNDU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-25T14:37:49Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-25T14:37:49Z"}, "message": "Replace all uses of PassMode with ArgAbi", "tree": {"sha": "9c1c0bb0c324906b7198151c0304645399aa3545", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c1c0bb0c324906b7198151c0304645399aa3545"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de713a80cac60164f435a4e6a7ca710f5fdccd45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de713a80cac60164f435a4e6a7ca710f5fdccd45", "html_url": "https://github.com/rust-lang/rust/commit/de713a80cac60164f435a4e6a7ca710f5fdccd45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de713a80cac60164f435a4e6a7ca710f5fdccd45/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff3304285a41c85486249c5db337e4561ef970c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff3304285a41c85486249c5db337e4561ef970c5", "html_url": "https://github.com/rust-lang/rust/commit/ff3304285a41c85486249c5db337e4561ef970c5"}], "stats": {"total": 391, "additions": 232, "deletions": 159}, "files": [{"sha": "af42e54451b16b2e6e91d6b4eb848eb4f8449891", "filename": "src/abi/comments.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=de713a80cac60164f435a4e6a7ca710f5fdccd45", "patch": "@@ -4,6 +4,7 @@\n use std::borrow::Cow;\n \n use rustc_middle::mir;\n+use rustc_target::abi::call::ArgAbi;\n \n use cranelift_codegen::entity::EntityRef;\n \n@@ -22,7 +23,7 @@ pub(super) fn add_arg_comment<'tcx>(\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: EmptySinglePair<Value>,\n-    pass_mode: PassMode,\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ty: Ty<'tcx>,\n ) {\n     let local = if let Some(local) = local {\n@@ -42,7 +43,7 @@ pub(super) fn add_arg_comment<'tcx>(\n         Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n     };\n \n-    let pass_mode = format!(\"{:?}\", pass_mode);\n+    let pass_mode = format!(\"{:?}\", arg_abi.mode);\n     fx.add_global_comment(format!(\n         \"{kind:5}{local:>3}{local_field:<5} {params:10} {pass_mode:36} {ty:?}\",\n         kind = kind,"}, {"sha": "ddbef5eadfecffce0d01160c25764d51fe1c0ced", "filename": "src/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 46, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=de713a80cac60164f435a4e6a7ca710f5fdccd45", "patch": "@@ -6,9 +6,10 @@ mod pass_mode;\n mod returning;\n \n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_target::abi::call::PassMode as RustcPassMode;\n use rustc_target::spec::abi::Abi;\n \n-use cranelift_codegen::ir::{AbiParam, ArgumentPurpose};\n+use cranelift_codegen::ir::AbiParam;\n \n use self::pass_mode::*;\n use crate::prelude::*;\n@@ -96,7 +97,6 @@ fn clif_sig_from_fn_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n     sig: FnSig<'tcx>,\n-    span: Span,\n     is_vtable_fn: bool,\n     requires_caller_location: bool,\n ) -> Signature {\n@@ -147,54 +147,26 @@ fn clif_sig_from_fn_sig<'tcx>(\n                     .layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit())))\n                     .unwrap();\n             }\n-            let pass_mode = get_pass_mode(tcx, layout);\n+            let mut arg_abi = get_arg_abi(tcx, layout);\n             if abi != Abi::Rust && abi != Abi::RustCall && abi != Abi::RustIntrinsic {\n-                match pass_mode {\n-                    PassMode::NoPass | PassMode::ByVal(_) => {}\n-                    PassMode::ByRef { size: Some(size) } => {\n-                        let purpose = ArgumentPurpose::StructArgument(u32::try_from(size.bytes()).expect(\"struct too big to pass on stack\"));\n-                        return EmptySinglePair::Single(AbiParam::special(pointer_ty(tcx), purpose)).into_iter();\n-                    }\n-                    PassMode::ByValPair(_, _) | PassMode::ByRef { size: None } => {\n-                        tcx.sess.span_warn(\n-                            span,\n-                            &format!(\n-                                \"Argument of type `{:?}` with pass mode `{:?}` is not yet supported \\\n-                                for non-rust abi `{}`. Calling this function may result in a crash.\",\n-                                layout.ty,\n-                                pass_mode,\n-                                abi,\n-                            ),\n-                        );\n-                    }\n+                match arg_abi.mode {\n+                    RustcPassMode::Indirect {\n+                        ref mut on_stack, ..\n+                    } => *on_stack = true,\n+                    _ => {}\n                 }\n             }\n-            pass_mode.get_param_ty(tcx).map(AbiParam::new).into_iter()\n+            arg_abi.get_abi_param(tcx).into_iter()\n         })\n         .flatten();\n \n-    let (mut params, returns): (Vec<_>, Vec<_>) = match get_pass_mode(\n+    let return_arg_abi = get_arg_abi(\n         tcx,\n         tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n-    ) {\n-        PassMode::NoPass => (inputs.collect(), vec![]),\n-        PassMode::ByVal(ret_ty) => (inputs.collect(), vec![AbiParam::new(ret_ty)]),\n-        PassMode::ByValPair(ret_ty_a, ret_ty_b) => (\n-            inputs.collect(),\n-            vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n-        ),\n-        PassMode::ByRef { size: Some(_) } => {\n-            (\n-                Some(pointer_ty(tcx)) // First param is place to put return val\n-                    .into_iter()\n-                    .map(|ty| AbiParam::special(ty, ArgumentPurpose::StructReturn))\n-                    .chain(inputs)\n-                    .collect(),\n-                vec![],\n-            )\n-        }\n-        PassMode::ByRef { size: None } => todo!(),\n-    };\n+    );\n+    let (return_ptr, returns) = return_arg_abi.get_abi_return(tcx);\n+    // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n+    let mut params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n     if requires_caller_location {\n         params.push(AbiParam::new(pointer_ty(tcx)));\n@@ -226,7 +198,6 @@ pub(crate) fn get_function_name_and_sig<'tcx>(\n         tcx,\n         triple,\n         fn_sig,\n-        tcx.def_span(inst.def_id()),\n         false,\n         inst.def.requires_caller_location(tcx),\n     );\n@@ -584,7 +555,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                     nop_inst,\n                     format!(\n                         \"virtual call; self arg pass mode: {:?}\",\n-                        get_pass_mode(fx.tcx, args[0].layout())\n+                        get_arg_abi(fx.tcx, args[0].layout()).mode,\n                     ),\n                 );\n             }\n@@ -647,7 +618,6 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                     fx.tcx,\n                     fx.triple(),\n                     fn_sig,\n-                    span,\n                     is_virtual_call,\n                     false, // calls through function pointers never pass the caller location\n                 );\n@@ -723,7 +693,6 @@ pub(crate) fn codegen_drop<'tcx>(\n                     fx.tcx,\n                     fx.triple(),\n                     fn_sig,\n-                    span,\n                     true,\n                     false, // `drop_in_place` is never `#[track_caller]`\n                 );"}, {"sha": "51fc4ecd1ef090fc6c0715f6bba44c93eee035ed", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 147, "deletions": 83, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=de713a80cac60164f435a4e6a7ca710f5fdccd45", "patch": "@@ -2,17 +2,10 @@\n \n use crate::prelude::*;\n \n+use cranelift_codegen::ir::ArgumentPurpose;\n use rustc_target::abi::call::{ArgAbi, ArgAttributes, PassMode as RustcPassMode};\n pub(super) use EmptySinglePair::*;\n \n-#[derive(Copy, Clone, Debug)]\n-pub(super) enum PassMode {\n-    NoPass,\n-    ByVal(Type),\n-    ByValPair(Type, Type),\n-    ByRef { size: Option<Size> },\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub(super) enum EmptySinglePair<T> {\n     Empty,\n@@ -67,19 +60,126 @@ impl<T: std::fmt::Debug> EmptySinglePair<T> {\n     }\n }\n \n-impl PassMode {\n-    pub(super) fn get_param_ty(self, tcx: TyCtxt<'_>) -> EmptySinglePair<Type> {\n-        match self {\n-            PassMode::NoPass => Empty,\n-            PassMode::ByVal(clif_type) => Single(clif_type),\n-            PassMode::ByValPair(a, b) => Pair(a, b),\n-            PassMode::ByRef { size: Some(_) } => Single(pointer_ty(tcx)),\n-            PassMode::ByRef { size: None } => Pair(pointer_ty(tcx), pointer_ty(tcx)),\n+pub(super) trait ArgAbiExt<'tcx> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> EmptySinglePair<AbiParam>;\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>);\n+}\n+\n+impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> EmptySinglePair<AbiParam> {\n+        match self.mode {\n+            RustcPassMode::Ignore => EmptySinglePair::Empty,\n+            RustcPassMode::Direct(_) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => {\n+                    EmptySinglePair::Single(AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())))\n+                }\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    EmptySinglePair::Single(AbiParam::new(vector_ty))\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            RustcPassMode::Pair(_, _) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    EmptySinglePair::Pair(AbiParam::new(a), AbiParam::new(b))\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            RustcPassMode::Cast(_) => EmptySinglePair::Single(AbiParam::new(pointer_ty(tcx))),\n+            RustcPassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                if on_stack {\n+                    let size = u32::try_from(self.layout.size.bytes()).unwrap();\n+                    EmptySinglePair::Single(AbiParam::special(\n+                        pointer_ty(tcx),\n+                        ArgumentPurpose::StructArgument(size),\n+                    ))\n+                } else {\n+                    EmptySinglePair::Single(AbiParam::new(pointer_ty(tcx)))\n+                }\n+            }\n+            RustcPassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: Some(_),\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                EmptySinglePair::Pair(\n+                    AbiParam::new(pointer_ty(tcx)),\n+                    AbiParam::new(pointer_ty(tcx)),\n+                )\n+            }\n+        }\n+    }\n+\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>) {\n+        match self.mode {\n+            RustcPassMode::Ignore => (None, vec![]),\n+            RustcPassMode::Direct(_) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => (\n+                    None,\n+                    vec![AbiParam::new(scalar_to_clif_type(\n+                        tcx,\n+                        scalar.clone(),\n+                    ))],\n+                ),\n+                // FIXME implement Vector Abi in a cg_llvm compatible way\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    (None, vec![AbiParam::new(vector_ty)])\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            RustcPassMode::Pair(_, _) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    (\n+                        None,\n+                        vec![AbiParam::new(a), AbiParam::new(b)],\n+                    )\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            RustcPassMode::Cast(_) => (\n+                Some(AbiParam::special(\n+                    pointer_ty(tcx),\n+                    ArgumentPurpose::StructReturn,\n+                )),\n+                vec![],\n+            ),\n+            RustcPassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                (\n+                    Some(AbiParam::special(\n+                        pointer_ty(tcx),\n+                        ArgumentPurpose::StructReturn,\n+                    )),\n+                    vec![],\n+                )\n+            }\n+            RustcPassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: Some(_),\n+                on_stack: _,\n+            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n \n-pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> PassMode {\n+pub(super) fn get_arg_abi<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    layout: TyAndLayout<'tcx>,\n+) -> ArgAbi<'tcx, Ty<'tcx>> {\n     let mut arg_abi = ArgAbi::new(&tcx, layout, |_, _, _| ArgAttributes::new());\n     if layout.is_zst() {\n         // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n@@ -88,7 +188,7 @@ pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>)\n     match arg_abi.mode {\n         RustcPassMode::Ignore => {}\n         RustcPassMode::Direct(_) => match &arg_abi.layout.abi {\n-            Abi::Scalar(_) => {},\n+            Abi::Scalar(_) => {}\n             // FIXME implement Vector Abi in a cg_llvm compatible way\n             Abi::Vector { .. } => {\n                 if crate::intrinsics::clif_vector_type(tcx, arg_abi.layout).is_none() {\n@@ -99,7 +199,7 @@ pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>)\n                     };\n                 }\n             }\n-            _ => unreachable!(\"{:?}\", arg_abi.layout.abi)\n+            _ => unreachable!(\"{:?}\", arg_abi.layout.abi),\n         },\n         RustcPassMode::Pair(_, _) => match &arg_abi.layout.abi {\n             Abi::ScalarPair(a, b) => {\n@@ -113,69 +213,27 @@ pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>)\n                     };\n                 }\n             }\n-            _ => unreachable!(\"{:?}\", arg_abi.layout.abi)\n+            _ => unreachable!(\"{:?}\", arg_abi.layout.abi),\n         },\n         _ => {}\n     }\n-    match arg_abi.mode {\n-        RustcPassMode::Ignore => PassMode::NoPass,\n-        RustcPassMode::Direct(_) => match &arg_abi.layout.abi {\n-            Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n-            // FIXME implement Vector Abi in a cg_llvm compatible way\n-            Abi::Vector { .. } => {\n-                let vector_ty = crate::intrinsics::clif_vector_type(tcx, arg_abi.layout).unwrap();\n-                PassMode::ByVal(vector_ty)\n-            }\n-            _ => unreachable!(\"{:?}\", arg_abi.layout.abi)\n-        },\n-        RustcPassMode::Pair(_, _) => match &arg_abi.layout.abi {\n-            Abi::ScalarPair(a, b) => {\n-                let a = scalar_to_clif_type(tcx, a.clone());\n-                let b = scalar_to_clif_type(tcx, b.clone());\n-                PassMode::ByValPair(a, b)\n-            }\n-            _ => unreachable!(\"{:?}\", arg_abi.layout.abi)\n-        },\n-        RustcPassMode::Cast(_) | RustcPassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: false,\n-        } => PassMode::ByRef {\n-            size: Some(arg_abi.layout.size),\n-        },\n-        RustcPassMode::Indirect {\n-            attrs: _,\n-            extra_attrs,\n-            on_stack: true,\n-        } => {\n-            assert!(extra_attrs.is_none());\n-            PassMode::ByRef {\n-                size: Some(arg_abi.layout.size)\n-            }\n-        }\n-        RustcPassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: false,\n-        } => PassMode::ByRef {\n-            size: None,\n-        },\n-    }\n+    arg_abi\n }\n \n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     arg: CValue<'tcx>,\n ) -> EmptySinglePair<Value> {\n-    match get_pass_mode(fx.tcx, arg.layout()) {\n-        PassMode::NoPass => Empty,\n-        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n-        PassMode::ByValPair(_, _) => {\n+    let arg_abi = get_arg_abi(fx.tcx, arg.layout());\n+    match arg_abi.mode {\n+        RustcPassMode::Ignore => Empty,\n+        RustcPassMode::Direct(_) => Single(arg.load_scalar(fx)),\n+        RustcPassMode::Pair(_, _) => {\n             let (a, b) = arg.load_scalar_pair(fx);\n             Pair(a, b)\n         }\n-        PassMode::ByRef { size: _ } => match arg.force_stack(fx) {\n+        RustcPassMode::Cast(_) | RustcPassMode::Indirect { .. } => match arg.force_stack(fx) {\n             (ptr, None) => Single(ptr.get_addr(fx)),\n             (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n         },\n@@ -192,14 +250,11 @@ pub(super) fn cvalue_for_param<'tcx>(\n     arg_ty: Ty<'tcx>,\n ) -> Option<CValue<'tcx>> {\n     let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, layout);\n+    let arg_abi = get_arg_abi(fx.tcx, layout);\n \n-    if let PassMode::NoPass = pass_mode {\n-        return None;\n-    }\n-\n-    let clif_types = pass_mode.get_param_ty(fx.tcx);\n-    let block_params = clif_types.map(|t| fx.bcx.append_block_param(start_block, t));\n+    let clif_types = arg_abi.get_abi_param(fx.tcx);\n+    let block_params =\n+        clif_types.map(|abi_param| fx.bcx.append_block_param(start_block, abi_param.value_type));\n \n     #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n@@ -208,22 +263,31 @@ pub(super) fn cvalue_for_param<'tcx>(\n         local,\n         local_field,\n         block_params,\n-        pass_mode,\n+        &arg_abi,\n         arg_ty,\n     );\n \n-    match pass_mode {\n-        PassMode::NoPass => unreachable!(),\n-        PassMode::ByVal(_) => Some(CValue::by_val(block_params.assert_single(), layout)),\n-        PassMode::ByValPair(_, _) => {\n+    match arg_abi.mode {\n+        RustcPassMode::Ignore => None,\n+        RustcPassMode::Direct(_) => Some(CValue::by_val(block_params.assert_single(), layout)),\n+        RustcPassMode::Pair(_, _) => {\n             let (a, b) = block_params.assert_pair();\n             Some(CValue::by_val_pair(a, b, layout))\n         }\n-        PassMode::ByRef { size: Some(_) } => Some(CValue::by_ref(\n+        RustcPassMode::Cast(_)\n+        | RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => Some(CValue::by_ref(\n             Pointer::new(block_params.assert_single()),\n             layout,\n         )),\n-        PassMode::ByRef { size: None } => {\n+        RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => {\n             let (ptr, meta) = block_params.assert_pair();\n             Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))\n         }"}, {"sha": "9edaa1dd879fc9a72e94e2685a3dbb4e9d3dfe6e", "filename": "src/abi/returning.rs", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de713a80cac60164f435a4e6a7ca710f5fdccd45/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=de713a80cac60164f435a4e6a7ca710f5fdccd45", "patch": "@@ -3,6 +3,8 @@\n use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n+use rustc_target::abi::call::PassMode as RustcPassMode;\n+\n fn return_layout<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> TyAndLayout<'tcx> {\n     fx.layout_of(fx.monomorphize(&fx.mir.local_decls[RETURN_PLACE].ty))\n }\n@@ -12,10 +14,10 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n ) -> bool {\n-    match get_pass_mode(tcx, dest_layout) {\n-        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => true,\n-        // FIXME Make it possible to return ByRef to an ssa var.\n-        PassMode::ByRef { size: _ } => false,\n+    match get_arg_abi(tcx, dest_layout).mode {\n+        RustcPassMode::Ignore | RustcPassMode::Direct(_) | RustcPassMode::Pair(_, _) => true,\n+        // FIXME Make it possible to return Cast and Indirect to an ssa var.\n+        RustcPassMode::Cast(_) | RustcPassMode::Indirect { .. } => false,\n     }\n }\n \n@@ -27,24 +29,33 @@ pub(super) fn codegen_return_param<'tcx>(\n     start_block: Block,\n ) -> CPlace<'tcx> {\n     let ret_layout = return_layout(fx);\n-    let ret_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let (ret_place, ret_param) = match ret_pass_mode {\n-        PassMode::NoPass => (CPlace::no_place(ret_layout), Empty),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n+    let ret_arg_abi = get_arg_abi(fx.tcx, ret_layout);\n+    let (ret_place, ret_param) = match ret_arg_abi.mode {\n+        RustcPassMode::Ignore => (CPlace::no_place(ret_layout), Empty),\n+        RustcPassMode::Direct(_) | RustcPassMode::Pair(_, _) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(fx, RETURN_PLACE, ret_layout, is_ssa),\n                 Empty,\n             )\n         }\n-        PassMode::ByRef { size: Some(_) } => {\n+        RustcPassMode::Cast(_)\n+        | RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n             let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n             (\n                 CPlace::for_ptr(Pointer::new(ret_param), ret_layout),\n                 Single(ret_param),\n             )\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n+        RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     };\n \n     #[cfg(not(debug_assertions))]\n@@ -57,7 +68,7 @@ pub(super) fn codegen_return_param<'tcx>(\n         Some(RETURN_PLACE),\n         None,\n         ret_param,\n-        ret_pass_mode,\n+        &ret_arg_abi,\n         ret_layout.ty,\n     );\n \n@@ -74,54 +85,82 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n ) -> (Inst, T) {\n     let ret_layout = fx.layout_of(fn_sig.output());\n \n-    let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let return_ptr = match output_pass_mode {\n-        PassMode::NoPass => None,\n-        PassMode::ByRef { size: Some(_) } => match ret_place {\n+    let output_arg_abi = get_arg_abi(fx.tcx, ret_layout);\n+    let return_ptr = match output_arg_abi.mode {\n+        RustcPassMode::Ignore => None,\n+        RustcPassMode::Cast(_)\n+        | RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n+        RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        RustcPassMode::Direct(_) | RustcPassMode::Pair(_, _) => None,\n     };\n \n     let (call_inst, meta) = f(fx, return_ptr);\n \n-    match output_pass_mode {\n-        PassMode::NoPass => {}\n-        PassMode::ByVal(_) => {\n+    match output_arg_abi.mode {\n+        RustcPassMode::Ignore => {}\n+        RustcPassMode::Direct(_) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val = fx.bcx.inst_results(call_inst)[0];\n                 ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n             }\n         }\n-        PassMode::ByValPair(_, _) => {\n+        RustcPassMode::Pair(_, _) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n                 let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n                 ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n             }\n         }\n-        PassMode::ByRef { size: Some(_) } => {}\n-        PassMode::ByRef { size: None } => todo!(),\n+        RustcPassMode::Cast(_)\n+        | RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {}\n+        RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     }\n \n     (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    match get_pass_mode(fx.tcx, return_layout(fx)) {\n-        PassMode::NoPass | PassMode::ByRef { size: Some(_) } => {\n+    match get_arg_abi(fx.tcx, return_layout(fx)).mode {\n+        RustcPassMode::Ignore\n+        | RustcPassMode::Cast(_)\n+        | RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) => {\n+        RustcPassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        RustcPassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);\n             fx.bcx.ins().return_(&[ret_val]);\n         }\n-        PassMode::ByValPair(_, _) => {\n+        RustcPassMode::Pair(_, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);"}]}