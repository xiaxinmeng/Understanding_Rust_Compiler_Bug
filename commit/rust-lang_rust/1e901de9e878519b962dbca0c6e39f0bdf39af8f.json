{"sha": "1e901de9e878519b962dbca0c6e39f0bdf39af8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOTAxZGU5ZTg3ODUxOWI5NjJkYmNhMGM2ZTM5ZjBiZGYzOWFmOGY=", "commit": {"author": {"name": "Dan Fockler", "email": "dfockler13@gmail.com", "date": "2016-05-04T22:42:56Z"}, "committer": {"name": "Dan Fockler", "email": "dfockler13@gmail.com", "date": "2016-05-12T21:20:45Z"}, "message": "Add error explanations for E0374, E0375, E0376 on issue #33383", "tree": {"sha": "e172144c15e521a7ef55038400f6152854930c49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e172144c15e521a7ef55038400f6152854930c49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e901de9e878519b962dbca0c6e39f0bdf39af8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e901de9e878519b962dbca0c6e39f0bdf39af8f", "html_url": "https://github.com/rust-lang/rust/commit/1e901de9e878519b962dbca0c6e39f0bdf39af8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e901de9e878519b962dbca0c6e39f0bdf39af8f/comments", "author": {"login": "dfockler", "id": 2158103, "node_id": "MDQ6VXNlcjIxNTgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2158103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfockler", "html_url": "https://github.com/dfockler", "followers_url": "https://api.github.com/users/dfockler/followers", "following_url": "https://api.github.com/users/dfockler/following{/other_user}", "gists_url": "https://api.github.com/users/dfockler/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfockler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfockler/subscriptions", "organizations_url": "https://api.github.com/users/dfockler/orgs", "repos_url": "https://api.github.com/users/dfockler/repos", "events_url": "https://api.github.com/users/dfockler/events{/privacy}", "received_events_url": "https://api.github.com/users/dfockler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dfockler", "id": 2158103, "node_id": "MDQ6VXNlcjIxNTgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2158103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfockler", "html_url": "https://github.com/dfockler", "followers_url": "https://api.github.com/users/dfockler/followers", "following_url": "https://api.github.com/users/dfockler/following{/other_user}", "gists_url": "https://api.github.com/users/dfockler/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfockler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfockler/subscriptions", "organizations_url": "https://api.github.com/users/dfockler/orgs", "repos_url": "https://api.github.com/users/dfockler/repos", "events_url": "https://api.github.com/users/dfockler/events{/privacy}", "received_events_url": "https://api.github.com/users/dfockler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e88defe71806ad190588e168e513bc1098f7c9fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88defe71806ad190588e168e513bc1098f7c9fb", "html_url": "https://github.com/rust-lang/rust/commit/e88defe71806ad190588e168e513bc1098f7c9fb"}], "stats": {"total": 165, "additions": 158, "deletions": 7}, "files": [{"sha": "629a715d6bf6bdcb3b4d0e9d9c2f43d9ad5cc0ef", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 158, "deletions": 7, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/1e901de9e878519b962dbca0c6e39f0bdf39af8f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e901de9e878519b962dbca0c6e39f0bdf39af8f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1e901de9e878519b962dbca0c6e39f0bdf39af8f", "patch": "@@ -3284,6 +3284,164 @@ impl Baz for Bar { } // Note: This is OK\n ```\n \"##,\n \n+E0374: r##\"\n+A struct without a field containing an unsized type cannot implement\n+`CoerceUnsized`. An\n+[unsized type](https://doc.rust-lang.org/book/unsized-types.html)\n+is any type that the compiler doesn't know the length or alignment of at\n+compile time. Any struct containing an unsized type is also unsized.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+}\n+\n+// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.\n+impl<T, U> CoerceUnsized<Foo<U>> for Foo<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+`CoerceUnsized` is used to coerce one struct containing an unsized type\n+into another struct containing a different unsized type. If the struct\n+doesn't have any fields of unsized types then you don't need explicit\n+coercion to get the types you want. To fix this you can either\n+not try to implement `CoerceUnsized` or you can add a field that is\n+unsized to the struct.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+// We don't need to impl `CoerceUnsized` here.\n+struct Foo {\n+    a: i32,\n+}\n+\n+// We add the unsized type field to the struct.\n+struct Bar<T: ?Sized> {\n+    a: i32,\n+    b: T,\n+}\n+\n+// The struct has an unsized field so we can implement\n+// `CoerceUnsized` for it.\n+impl<T, U> CoerceUnsized<Bar<U>> for Bar<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+Note that `CoerceUnsized` is mainly used by smart pointers like `Box`, `Rc`\n+and `Arc` to be able to mark that they can coerce unsized types that they\n+are pointing at.\n+\"##,\n+\n+E0375: r##\"\n+A struct with more than one field containing an unsized type cannot implement\n+`CoerceUnsized`. This only occurs when you are trying to coerce one of the\n+types in your struct to another type in the struct. In this case we try to\n+impl `CoerceUnsized` from `T` to `U` which are both types that the struct\n+takes. An [unsized type](https://doc.rust-lang.org/book/unsized-types.html)\n+is any type that the compiler doesn't know the length or alignment of at\n+compile time. Any struct containing an unsized type is also unsized.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized, U: ?Sized> {\n+    a: i32,\n+    b: T,\n+    c: U,\n+}\n+\n+// error: Struct `Foo` has more than one unsized field.\n+impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}\n+```\n+\n+`CoerceUnsized` only allows for coercion from a structure with a single\n+unsized type field to another struct with a single unsized type field.\n+In fact Rust only allows for a struct to have one unsized type in a struct\n+and that unsized type must be the last field in the struct. So having two\n+unsized types in a single struct is not allowed by the compiler. To fix this\n+use only one field containing an unsized type in the struct and then use\n+multiple structs to manage each unsized type field you need.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+    b: T,\n+}\n+\n+impl <T, U> CoerceUnsized<Foo<U>> for Foo<T>\n+    where T: CoerceUnsized<U> {}\n+\n+fn coerce_foo<T: CoerceUnsized<U>, U>(t: T) -> Foo<U> {\n+    Foo { a: 12i32, b: t } // we use coercion to get the `Foo<U>` type we need\n+}\n+```\n+\n+\"##,\n+\n+E0376: r##\"\n+The type you are trying to impl `CoerceUnsized` for is not a struct.\n+`CoerceUnsized` can only be implemented for a struct. Unsized types are\n+already able to be coerced without an implementation of `CoerceUnsized`\n+whereas a struct containing an unsized type needs to know the unsized type\n+field it's containing is able to be coerced. An\n+[unsized type](https://doc.rust-lang.org/book/unsized-types.html)\n+is any type that the compiler doesn't know the length or alignment of at\n+compile time. Any struct containing an unsized type is also unsized.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: T,\n+}\n+\n+// error: The type `U` is not a struct\n+impl<T, U> CoerceUnsized<U> for Foo<T> {}\n+```\n+\n+The `CoerceUnsized` trait takes a struct type. Make sure the type you are\n+providing to `CoerceUnsized` is a struct with only the last field containing an\n+unsized type.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T> {\n+    a: T,\n+}\n+\n+// The `Foo<U>` is a struct so `CoerceUnsized` can be implemented\n+impl<T, U> CoerceUnsized<Foo<U>> for Foo<T> where T: CoerceUnsized<U> {}\n+```\n+\n+Note that in Rust, structs can only contain an unsized type if the field\n+containing the unsized type is the last and only unsized type field in the\n+struct.\n+\"##,\n+\n E0379: r##\"\n Trait methods cannot be declared `const` by design. For more information, see\n [RFC 911].\n@@ -3777,13 +3935,6 @@ register_diagnostics! {\n     E0320, // recursive overflow during dropck\n     E0328, // cannot implement Unsize explicitly\n //  E0372, // coherence not object safe\n-    E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n-           // between structures with one field being coerced, none found\n-    E0375, // the trait `CoerceUnsized` may only be implemented for a coercion\n-           // between structures with one field being coerced, but multiple\n-           // fields need coercions\n-    E0376, // the trait `CoerceUnsized` may only be implemented for a coercion\n-           // between structures\n     E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with the same definition\n     E0399, // trait items need to be implemented because the associated"}]}