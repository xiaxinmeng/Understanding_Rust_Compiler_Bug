{"sha": "f0afb8830258c2cfc36306e21bb436d55e74c4fa", "node_id": "C_kwDOAAsO6NoAKGYwYWZiODgzMDI1OGMyY2ZjMzYzMDZlMjFiYjQzNmQ1NWU3NGM0ZmE", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-01T19:48:22Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-07T19:19:27Z"}, "message": "migrate lang_items.rs to translateable diagnostics", "tree": {"sha": "7a935ed0c2c8d42f391f8b2ed2e7ad3244db871a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a935ed0c2c8d42f391f8b2ed2e7ad3244db871a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0afb8830258c2cfc36306e21bb436d55e74c4fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0afb8830258c2cfc36306e21bb436d55e74c4fa", "html_url": "https://github.com/rust-lang/rust/commit/f0afb8830258c2cfc36306e21bb436d55e74c4fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0afb8830258c2cfc36306e21bb436d55e74c4fa/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "b17ec43637276773cd331844896fe7071de2475c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b17ec43637276773cd331844896fe7071de2475c", "html_url": "https://github.com/rust-lang/rust/commit/b17ec43637276773cd331844896fe7071de2475c"}], "stats": {"total": 274, "additions": 180, "deletions": 94}, "files": [{"sha": "9499ad56aa93bc86f6d9a4fabf837c5a064af725", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f0afb8830258c2cfc36306e21bb436d55e74c4fa/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f0afb8830258c2cfc36306e21bb436d55e74c4fa/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=f0afb8830258c2cfc36306e21bb436d55e74c4fa", "patch": "@@ -383,9 +383,6 @@ passes_unknown_lang_item =\n     definition of an unknown language item: `{$name}`\n     .label = definition of unknown language item `{$name}`\n \n-passes_local_duplicate_lang_item =\n-    found duplicate lang item `{$name}`\n-\n passes_invalid_attr_at_crate_level =\n     `{$name}` attribute cannot be used at crate level\n     .suggestion = perhaps you meant to use an outer attribute\n@@ -534,3 +531,30 @@ passes_no_main_function =\n     .consider_adding_main_at_crate = consider adding a `main` function at the crate level\n     .teach_note = If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/\n     .non_function_main = non-function item at `crate::main` is found\n+\n+passes_duplicate_lang_item =\n+    {$message ->\n+        *[duplicate] found duplicate lang item `{$lang_item_name}`\n+        [duplicate_in_crate] duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n+        [duplicate_in_crate_depends] duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n+    }\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_incorrect_target =\n+    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n+        [true] at least {$num}\n+        *[false] {$num}\n+    } generic {$num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n+        [one] argument\n+        *[other] arguments\n+    }"}, {"sha": "bf3350129b0bb2c31c85d44dd2ad4fbdb9a6e716", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f0afb8830258c2cfc36306e21bb436d55e74c4fa/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afb8830258c2cfc36306e21bb436d55e74c4fa/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=f0afb8830258c2cfc36306e21bb436d55e74c4fa", "patch": "@@ -1191,3 +1191,77 @@ impl<'a> IntoDiagnostic<'a> for NoMainErr {\n         diag\n     }\n }\n+\n+pub struct DuplicateLangItem<'a> {\n+    pub local_span: Option<Span>,\n+    pub lang_item_name: Symbol,\n+    pub crate_name: Symbol,\n+    pub dependency_of: Symbol,\n+    pub is_local: bool,\n+    pub path: String,\n+    pub first_defined_span: Option<Span>,\n+    pub orig_crate_name: Symbol,\n+    pub orig_dependency_of: Symbol,\n+    pub orig_is_local: bool,\n+    pub orig_path: String,\n+    pub message: &'a str,\n+}\n+\n+impl<'a, 'b> IntoDiagnostic<'a> for DuplicateLangItem<'b> {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = handler.struct_err_with_code(\n+            rustc_errors::fluent::passes::duplicate_lang_item,\n+            error_code!(E0152),\n+        );\n+        diag.set_arg(\"lang_item_name\", self.lang_item_name);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"dependency_of\", self.dependency_of);\n+        diag.set_arg(\"path\", self.path);\n+        diag.set_arg(\"orig_crate_name\", self.orig_crate_name);\n+        diag.set_arg(\"orig_dependency_of\", self.orig_dependency_of);\n+        diag.set_arg(\"orig_path\", self.orig_path);\n+        diag.set_arg(\"message\", self.message);\n+        if let Some(span) = self.local_span {\n+            diag.set_span(span);\n+        }\n+        if let Some(span) = self.first_defined_span {\n+            diag.span_note(span, rustc_errors::fluent::passes::first_defined_span);\n+        } else {\n+            if self.orig_dependency_of.is_empty() {\n+                diag.note(rustc_errors::fluent::passes::first_defined_crate);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::first_defined_crate_depends);\n+            }\n+\n+            if self.orig_is_local {\n+                diag.note(rustc_errors::fluent::passes::first_definition_local);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::first_definition_path);\n+            }\n+\n+            if self.is_local {\n+                diag.note(rustc_errors::fluent::passes::second_definition_local);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::second_definition_path);\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::incorrect_target, code = \"E0718\")]\n+pub struct IncorrectTarget<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub generics_span: Span,\n+    pub name: &'a str,\n+    pub kind: &'static str,\n+    pub num: usize,\n+    pub actual_num: usize,\n+    pub at_least: bool,\n+}"}, {"sha": "0af7c0cd3fcc925354c93080f33aa80f98e1ca13", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 79, "deletions": 91, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f0afb8830258c2cfc36306e21bb436d55e74c4fa/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afb8830258c2cfc36306e21bb436d55e74c4fa/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=f0afb8830258c2cfc36306e21bb436d55e74c4fa", "patch": "@@ -8,18 +8,19 @@\n //! * Functions called by the compiler itself.\n \n use crate::check_attr::target_from_impl_item;\n-use crate::errors::{LangItemOnIncorrectTarget, UnknownLangItem};\n+use crate::errors::{\n+    DuplicateLangItem, IncorrectTarget, LangItemOnIncorrectTarget, UnknownLangItem,\n+};\n use crate::weak_lang_items;\n \n-use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{extract, GenericRequirement, ITEM_REFS};\n use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ExternCrate;\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n use rustc_middle::ty::query::Providers;\n \n@@ -62,74 +63,72 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n         // Check for duplicates.\n         if let Some(original_def_id) = self.items.items[item_index] {\n             if original_def_id != item_def_id {\n-                let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n-                let name = lang_item.name();\n-                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n-                    Some(span) => struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0152,\n-                        \"found duplicate lang item `{}`\",\n-                        name\n-                    ),\n-                    None => match self.tcx.extern_crate(item_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of),\n-                                name\n-                            ))\n-                        }\n-                        _ => self.tcx.sess.struct_err(&format!(\n-                            \"duplicate lang item in crate `{}`: `{}`.\",\n-                            self.tcx.crate_name(item_def_id.krate),\n-                            name\n-                        )),\n-                    },\n+                let local_span = self.tcx.hir().span_if_local(item_def_id);\n+                let lang_item_name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let crate_name = self.tcx.crate_name(item_def_id.krate);\n+                let mut dependency_of = Symbol::intern(\"\");\n+                let is_local = item_def_id.is_local();\n+                let path = if is_local {\n+                    String::new()\n+                } else {\n+                    self.tcx\n+                        .crate_extern_paths(item_def_id.krate)\n+                        .iter()\n+                        .map(|p| p.display().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                        .into()\n                 };\n-                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"the lang item is first defined here\");\n+                let first_defined_span = self.tcx.hir().span_if_local(original_def_id);\n+                let mut orig_crate_name = Symbol::intern(\"\");\n+                let mut orig_dependency_of = Symbol::intern(\"\");\n+                let orig_is_local = original_def_id.is_local();\n+                let orig_path = if orig_is_local {\n+                    String::new()\n                 } else {\n-                    match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            err.note(&format!(\n-                                \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n-                                self.tcx.crate_name(original_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of)\n-                            ));\n-                        }\n-                        _ => {\n-                            err.note(&format!(\n-                                \"the lang item is first defined in crate `{}`.\",\n-                                self.tcx.crate_name(original_def_id.krate)\n-                            ));\n-                        }\n+                    self.tcx\n+                        .crate_extern_paths(original_def_id.krate)\n+                        .iter()\n+                        .map(|p| p.display().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                        .into()\n+                };\n+                if first_defined_span.is_none() {\n+                    orig_crate_name = self.tcx.crate_name(original_def_id.krate);\n+                    if let Some(ExternCrate { dependency_of: inner_dependency_of, .. }) =\n+                        self.tcx.extern_crate(original_def_id)\n+                    {\n+                        orig_dependency_of = self.tcx.crate_name(*inner_dependency_of);\n                     }\n-                    let mut note_def = |which, def_id: DefId| {\n-                        let crate_name = self.tcx.crate_name(def_id.krate);\n-                        let note = if def_id.is_local() {\n-                            format!(\"{} definition in the local crate (`{}`)\", which, crate_name)\n-                        } else {\n-                            let paths: Vec<_> = self\n-                                .tcx\n-                                .crate_extern_paths(def_id.krate)\n-                                .iter()\n-                                .map(|p| p.display().to_string())\n-                                .collect();\n-                            format!(\n-                                \"{} definition in `{}` loaded from {}\",\n-                                which,\n-                                crate_name,\n-                                paths.join(\", \")\n-                            )\n-                        };\n-                        err.note(&note);\n-                    };\n-                    note_def(\"first\", original_def_id);\n-                    note_def(\"second\", item_def_id);\n                 }\n-                err.emit();\n+\n+                let message = if local_span.is_some() {\n+                    \"duplicate\"\n+                } else {\n+                    match self.tcx.extern_crate(item_def_id) {\n+                        Some(ExternCrate { dependency_of: inner_dependency_of, .. }) => {\n+                            dependency_of = self.tcx.crate_name(*inner_dependency_of);\n+                            \"duplicate_in_crate_depends\"\n+                        }\n+                        _ => \"duplicate_in_crate\",\n+                    }\n+                };\n+\n+                self.tcx.sess.emit_err(DuplicateLangItem {\n+                    local_span,\n+                    lang_item_name,\n+                    crate_name,\n+                    dependency_of,\n+                    is_local,\n+                    path,\n+                    first_defined_span,\n+                    orig_crate_name,\n+                    orig_dependency_of,\n+                    orig_is_local,\n+                    orig_path,\n+                    message,\n+                });\n             }\n         }\n \n@@ -162,41 +161,30 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n                 None => (0, *item_span),\n             };\n \n+            let mut at_least = false;\n             let required = match lang_item.required_generics() {\n-                GenericRequirement::Exact(num) if num != actual_num => {\n-                    Some((format!(\"{}\", num), pluralize!(num)))\n-                }\n+                GenericRequirement::Exact(num) if num != actual_num => Some(num),\n                 GenericRequirement::Minimum(num) if actual_num < num => {\n-                    Some((format!(\"at least {}\", num), pluralize!(num)))\n-                }\n+                    at_least = true;\n+                    Some(num)}\n+                ,\n                 // If the number matches, or there is no requirement, handle it normally\n                 _ => None,\n             };\n \n-            if let Some((range_str, pluralized)) = required {\n+            if let Some(num) = required {\n                 // We are issuing E0718 \"incorrect target\" here, because while the\n                 // item kind of the target is correct, the target is still wrong\n                 // because of the wrong number of generic arguments.\n-                struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(IncorrectTarget {\n                     span,\n-                    E0718,\n-                    \"`{}` language item must be applied to a {} with {} generic argument{}\",\n-                    name,\n-                    kind.descr(),\n-                    range_str,\n-                    pluralized,\n-                )\n-                .span_label(\n                     generics_span,\n-                    format!(\n-                        \"this {} has {} generic argument{}\",\n-                        kind.descr(),\n-                        actual_num,\n-                        pluralize!(actual_num),\n-                    ),\n-                )\n-                .emit();\n+                    name: name.as_str(),\n+                    kind: kind.descr(),\n+                    num,\n+                    actual_num,\n+                    at_least,\n+                });\n \n                 // return early to not collect the lang item\n                 return;"}]}