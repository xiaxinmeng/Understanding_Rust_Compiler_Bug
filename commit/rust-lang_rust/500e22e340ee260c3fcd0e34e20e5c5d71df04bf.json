{"sha": "500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "node_id": "C_kwDOAAsO6NoAKDUwMGUyMmUzNDBlZTI2MGMzZmNkMGUzNGUyMGU1YzVkNzFkZjA0YmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-26T23:31:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-26T23:31:01Z"}, "message": "Auto merge of #89092 - bjorn3:sync_cg_clif-2021-09-19, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nNothing exciting this time. Mostly internal refactorings.\n\nr? `@ghost`\n\n`@rustbot` label +A-codegen +A-cranelift +T-compiler", "tree": {"sha": "5cf9c7e94f924daf928f480a040497724dd71b94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cf9c7e94f924daf928f480a040497724dd71b94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "html_url": "https://github.com/rust-lang/rust/commit/500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b34e2d678bc45a2877c18d93a7a5049f8f8ef84", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b34e2d678bc45a2877c18d93a7a5049f8f8ef84", "html_url": "https://github.com/rust-lang/rust/commit/1b34e2d678bc45a2877c18d93a7a5049f8f8ef84"}, {"sha": "5d3b8e7c1b259b82549d631f66b88bd041dce3fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3b8e7c1b259b82549d631f66b88bd041dce3fc", "html_url": "https://github.com/rust-lang/rust/commit/5d3b8e7c1b259b82549d631f66b88bd041dce3fc"}], "stats": {"total": 625, "additions": 332, "deletions": 293}, "files": [{"sha": "b6567aca78679cc0fe53bfd4967636832eda11ff", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -15,4 +15,4 @@ perf.data.old\n /rand\n /regex\n /simple-raytracer\n-/stdsimd\n+/portable-simd"}, {"sha": "4afddf76869de4a872b1a49bd5e2f6e7814ff046", "filename": "Cargo.lock", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -33,16 +33,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n@@ -57,27 +57,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -87,8 +87,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -104,8 +104,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -115,8 +115,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -125,8 +125,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.75.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime.git#5deda279775dca5e37449c829cda1f6276d6542b\"\n+version = \"0.76.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime.git#9c550fcf41425942ed97c747f0169b2ca81f9c1b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\","}, {"sha": "22be21cb8dee9a3d1a4ff4096218a2abfbbea13f", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"addr2line\"\n-version = \"0.14.1\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a55f82cfe485775d02112886f4169bde0c5894d75e79ead7eafe7e40a25e45f7\"\n+checksum = \"3e61f2b7f93d2c7d2b08263acaa4a363b3e276806c68af6134c44f523bf1aacd\"\n dependencies = [\n  \"compiler_builtins\",\n  \"gimli\",\n@@ -40,9 +40,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.69\"\n+version = \"1.0.70\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e70cc2f62c6ce1868963827bd677764c62d07c3d9a3e1fb1177ee1a9ab199eb2\"\n+checksum = \"d26a6ce4b6a484fa3edb70f7efa6fc430fd2b87285fe8b84304fd0936faa0dc0\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -56,7 +56,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.46\"\n+version = \"0.1.50\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -99,9 +99,9 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.23.0\"\n+version = \"0.25.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f6503fe142514ca4799d4c26297c4248239fe8838d827db6bd6065c6ed29a6ce\"\n+checksum = \"f0a01e0497841a3b2db4f8afa483cce65f7e96a3498bd6c541734792aeac8fe7\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -132,13 +132,23 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.98\"\n+version = \"0.2.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n+checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"memchr\"\n+version = \"2.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"miniz_oxide\"\n version = \"0.4.4\"\n@@ -154,11 +164,12 @@ dependencies = [\n \n [[package]]\n name = \"object\"\n-version = \"0.22.0\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d3b63360ec3cb337817c2dbd47ab4a0f170d285d8e5a2064600f3def1402397\"\n+checksum = \"39f37e50073ccad23b6d09bcb5b263f4e76d3bb6038e4a3c08e52162ffa8abc2\"\n dependencies = [\n  \"compiler_builtins\",\n+ \"memchr\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n@@ -195,9 +206,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.20\"\n+version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dead70b0b5e03e9c814bcb6b01e03e68f7c57a80aa48c72ec92152ab3e818d49\"\n+checksum = \"7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -286,9 +297,9 @@ dependencies = [\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3\"\n+checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\","}, {"sha": "ae9a35048bda9a56873fec5e678bb835e80e6e10", "filename": "build_system/prepare.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/build_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/build_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fprepare.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -28,11 +28,11 @@ pub(crate) fn prepare() {\n     );\n \n     clone_repo(\n-        \"stdsimd\",\n-        \"https://github.com/rust-lang/stdsimd\",\n-        \"be96995d8ddec03fac9a0caf4d4c51c7fbc33507\",\n+        \"portable-simd\",\n+        \"https://github.com/rust-lang/portable-simd\",\n+        \"8cf7a62e5d2552961df51e5200aaa5b7c890a4bf\",\n     );\n-    apply_patches(\"stdsimd\", Path::new(\"stdsimd\"));\n+    apply_patches(\"portable-simd\", Path::new(\"portable-simd\"));\n \n     clone_repo(\n         \"simple-raytracer\",\n@@ -92,7 +92,7 @@ fn prepare_sysroot() {\n     clone_repo(\n         \"build_sysroot/compiler-builtins\",\n         \"https://github.com/rust-lang/compiler-builtins.git\",\n-        \"0.1.46\",\n+        \"0.1.50\",\n     );\n     apply_patches(\"compiler-builtins\", Path::new(\"build_sysroot/compiler-builtins\"));\n }"}, {"sha": "865de7d234f1419affc4a673bab58986e6d6a790", "filename": "clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/clean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/clean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clean_all.sh?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -3,4 +3,4 @@ set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n rm -rf target/ build/ perf.data{,.old}\n-rm -rf rand/ regex/ simple-raytracer/ stdsimd/\n+rm -rf rand/ regex/ simple-raytracer/ portable-simd/"}, {"sha": "bcc5745d9d1974af3115e83f9004151b10eeeba2", "filename": "docs/usage.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/docs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/docs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fusage.md?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -24,6 +24,8 @@ $ $cg_clif_dir/build/bin/cg_clif my_crate.rs\n \n ## Jit mode\n \n+> \u26a0\u26a0\u26a0 The JIT mode is highly experimental. It may be slower than AOT compilation due to lack of incremental compilation. It may also be hard to setup if you have cargo dependencies. \u26a0\u26a0\u26a0\n+\n In jit mode cg_clif will immediately execute your code without creating an executable file.\n \n > This requires all dependencies to be available as dynamic library."}, {"sha": "d0d492e96742d6601819878ee7f94e4126639b7a", "filename": "example/alloc_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/example%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/example%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Falloc_example.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, core_intrinsics, alloc_prelude, alloc_error_handler)]\n+#![feature(start, core_intrinsics, alloc_prelude, alloc_error_handler, box_syntax)]\n #![no_std]\n \n extern crate alloc;"}, {"sha": "cbfdb3c44f33e1170c2e9d6a8b9abfb5654c7c7a", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,4 +1,4 @@\n-#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local)]\n+#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local, box_syntax)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n "}, {"sha": "2e683694663632c2a80cfe43c9e42c2a5fef2a32", "filename": "patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "renamed", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -4,21 +4,20 @@ Date: Sun, 25 Jul 2021 18:39:31 +0200\n Subject: [PATCH] Disable unsupported tests\n \n ---\n- crates/core_simd/src/array.rs        |  2 ++\n- crates/core_simd/src/lib.rs          |  2 +-\n+ crates/core_simd/src/vector.rs        |  2 ++\n  crates/core_simd/src/math.rs         |  4 ++++\n  crates/core_simd/tests/masks.rs      | 12 ------------\n  crates/core_simd/tests/ops_macros.rs |  6 ++++++\n  crates/core_simd/tests/round.rs      |  2 ++\n  6 files changed, 15 insertions(+), 13 deletions(-)\n \n-diff --git a/crates/core_simd/src/array.rs b/crates/core_simd/src/array.rs\n+diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n index 25c5309..2b3d819 100644\n---- a/crates/core_simd/src/array.rs\n-+++ b/crates/core_simd/src/array.rs\n+--- a/crates/core_simd/src/vector.rs\n++++ b/crates/core_simd/src/vector.rs\n @@ -22,6 +22,7 @@ where\n-     #[must_use]\n-     fn splat(val: Self::Scalar) -> Self;\n+         self.0\n+     }\n  \n +    /*\n      /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n@@ -31,27 +30,14 @@ index 25c5309..2b3d819 100644\n +    */\n  }\n  \n- macro_rules! impl_simdarray_for {\n-diff --git a/crates/core_simd/src/lib.rs b/crates/core_simd/src/lib.rs\n-index a64904d..299eb11 100644\n---- a/crates/core_simd/src/lib.rs\n-+++ b/crates/core_simd/src/lib.rs\n-@@ -1,7 +1,7 @@\n- #![no_std]\n- #![allow(incomplete_features)]\n- #![feature(\n--    const_generics, \n-+    const_generics,\n-     platform_intrinsics,\n-     repr_simd,\n-     simd_ffi,\n+ impl<T, const LANES: usize> Copy for Simd<T, LANES>\n diff --git a/crates/core_simd/src/math.rs b/crates/core_simd/src/math.rs\n index 7290a28..e394730 100644\n --- a/crates/core_simd/src/math.rs\n +++ b/crates/core_simd/src/math.rs\n @@ -2,6 +2,7 @@ macro_rules! impl_uint_arith {\n-     ($(($name:ident, $n:ident)),+) => {\n-         $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+     ($($ty:ty),+) => {\n+         $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n  \n +            /*\n              /// Lanewise saturating add.\n@@ -66,8 +52,8 @@ index 7290a28..e394730 100644\n      }\n  }\n @@ -46,6 +48,7 @@ macro_rules! impl_int_arith {\n-     ($(($name:ident, $n:ident)),+) => {\n-         $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+     ($($ty:ty),+) => {\n+         $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n  \n +            /*\n              /// Lanewise saturating add.\n@@ -85,21 +71,22 @@ diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n index 61d8e44..2bccae2 100644\n --- a/crates/core_simd/tests/masks.rs\n +++ b/crates/core_simd/tests/masks.rs\n-@@ -67,18 +67,6 @@ macro_rules! test_mask_api {\n+@@ -67,19 +67,6 @@ macro_rules! test_mask_api {\n                  assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n-                 assert_eq!(core_simd::$name::<8>::from_int(int), mask);\n+                 assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n              }\n -\n+-            #[cfg(feature = \"generic_const_exprs\")]\n -            #[test]\n -            fn roundtrip_bitmask_conversion() {\n -                let values = [\n -                    true, false, false, true, false, false, true, false,\n -                    true, true, false, false, false, false, false, true,\n -                ];\n--                let mask = core_simd::$name::<16>::from_array(values);\n+-                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n -                let bitmask = mask.to_bitmask();\n -                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n--                assert_eq!(core_simd::$name::<16>::from_bitmask(bitmask), mask);\n+-                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n -            }\n          }\n      }\n@@ -122,7 +109,7 @@ index cb39e73..fc0ebe1 100644\n                  }\n +                */\n  \n-                 fn sqrt<const LANES: usize>() {\n+                 fn recip<const LANES: usize>() {\n                      test_helpers::test_unary_elementwise(\n @@ -581,6 +585,7 @@ macro_rules! impl_float_tests {\n                      });\n@@ -138,8 +125,8 @@ index cb39e73..fc0ebe1 100644\n                  }\n +                */\n              }\n-         }\n-     }\n+ \n+             #[cfg(feature = \"std\")]\n diff --git a/crates/core_simd/tests/round.rs b/crates/core_simd/tests/round.rs\n index 37044a7..4cdc6b7 100644\n --- a/crates/core_simd/tests/round.rs", "previous_filename": "patches/0001-stdsimd-Disable-unsupported-tests.patch"}, {"sha": "e2d07bd12670264d2674919a63809eb55d15a112", "filename": "patches/0027-sysroot-128bit-atomic-operations.patch", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/patches%2F0027-sysroot-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/patches%2F0027-sysroot-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0027-sysroot-128bit-atomic-operations.patch?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,4 +1,4 @@\n-From 6a4e6f5dc8c8a529a822eb9b57f9e57519595439 Mon Sep 17 00:00:00 2001\n+From ad7ffe71baba46865f2e65266ab025920dfdc20b Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n Date: Thu, 18 Feb 2021 18:45:28 +0100\n Subject: [PATCH] Disable 128bit atomic operations\n@@ -8,7 +8,8 @@ Cranelift doesn't support them yet\n  library/core/src/panic/unwind_safe.rs |  6 -----\n  library/core/src/sync/atomic.rs       | 38 ---------------------------\n  library/core/tests/atomic.rs          |  4 ---\n- 3 files changed, 48 deletions(-)\n+ library/std/src/time/monotonic.rs     |  6 +++--\n+ 4 files changed, 4 insertions(+), 50 deletions(-)\n \n diff --git a/library/core/src/panic/unwind_safe.rs b/library/core/src/panic/unwind_safe.rs\n index 092b7cf..158cf71 100644\n@@ -35,10 +36,10 @@ index 092b7cf..158cf71 100644\n  #[cfg(target_has_atomic_load_store = \"8\")]\n  #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n diff --git a/library/core/src/sync/atomic.rs b/library/core/src/sync/atomic.rs\n-index 0194c58..25a0038 100644\n+index d9de37e..8293fce 100644\n --- a/library/core/src/sync/atomic.rs\n +++ b/library/core/src/sync/atomic.rs\n-@@ -2229,44 +2229,6 @@ atomic_int! {\n+@@ -2234,44 +2234,6 @@ atomic_int! {\n      \"AtomicU64::new(0)\",\n      u64 AtomicU64 ATOMIC_U64_INIT\n  }\n@@ -98,6 +99,38 @@ index b735957..ea728b6 100644\n      #[cfg(target_has_atomic = \"ptr\")]\n      assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n      #[cfg(target_has_atomic = \"ptr\")]\n+diff --git a/library/std/src/time/monotonic.rs b/library/std/src/time/monotonic.rs\n+index fa96b7a..2854f9c 100644\n+--- a/library/std/src/time/monotonic.rs\n++++ b/library/std/src/time/monotonic.rs\n+@@ -5,7 +5,7 @@ pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+     inner::monotonize(raw)\n+ }\n+ \n+-#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n++#[cfg(target_has_atomic = \"64\")]\n+ pub mod inner {\n+     use crate::sync::atomic::AtomicU64;\n+     use crate::sync::atomic::Ordering::*;\n+@@ -70,6 +70,7 @@ pub mod inner {\n+     }\n+ }\n+ \n++/*\n+ #[cfg(target_has_atomic = \"128\")]\n+ pub mod inner {\n+     use crate::sync::atomic::AtomicU128;\n+@@ -94,8 +95,9 @@ pub mod inner {\n+         ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n+     }\n+ }\n++*/\n+ \n+-#[cfg(not(any(target_has_atomic = \"64\", target_has_atomic = \"128\")))]\n++#[cfg(not(target_has_atomic = \"64\"))]\n+ pub mod inner {\n+     use crate::cmp;\n+     use crate::sys::time;\n -- \n 2.26.2.7.g19db9cfb68\n "}, {"sha": "360570b3ae7a145c8bd24f7496878f6997912678", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-08-05\"\n+channel = \"nightly-2021-09-19\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "b714d47fec2a6d3d63fedc5d4b80ae3fcdb4b071", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -11,7 +11,7 @@ pushd rust\n cargo install ripgrep\n \n rm -r src/test/ui/{extern/,panics/,unsized-locals/,thinlto/,simd*,*lto*.rs,linkage*,unwind-*.rs} || true\n-for test in $(rg --files-with-matches \"asm!|catch_unwind|should_panic|lto\" src/test/ui); do\n+for test in $(rg --files-with-matches \"asm!|catch_unwind|should_panic|lto|// needs-asm-support\" src/test/ui); do\n   rm $test\n done\n "}, {"sha": "28a7980d6613cf0eef6c013879a59f3f442950f4", "filename": "scripts/tests.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/scripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/scripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftests.sh?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -137,8 +137,8 @@ function extended_sysroot_tests() {\n     fi\n     popd\n \n-    pushd stdsimd\n-    echo \"[TEST] rust-lang/stdsimd\"\n+    pushd portable-simd\n+    echo \"[TEST] rust-lang/portable-simd\"\n     ../build/cargo clean\n     ../build/cargo build --all-targets --target $TARGET_TRIPLE\n     if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then"}, {"sha": "8a1f654399004a3c80280754aa57d4ff6bc3179f", "filename": "src/archive.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,17 +1,20 @@\n //! Creation of ar archives like for the lib and staticlib crate type\n \n use std::collections::BTreeMap;\n+use std::convert::TryFrom;\n use std::fs::File;\n+use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n use rustc_session::Session;\n \n-use object::{Object, ObjectSymbol, SymbolKind};\n+use object::read::archive::ArchiveFile;\n+use object::{Object, ObjectSymbol, ReadCache, SymbolKind};\n \n #[derive(Debug)]\n enum ArchiveEntry {\n-    FromArchive { archive_index: usize, entry_index: usize },\n+    FromArchive { archive_index: usize, file_range: (u64, u64) },\n     File(PathBuf),\n }\n \n@@ -21,29 +24,28 @@ pub(crate) struct ArArchiveBuilder<'a> {\n     use_gnu_style_archive: bool,\n     no_builtin_ranlib: bool,\n \n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n+    src_archives: Vec<File>,\n     // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n     // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n+    entries: Vec<(Vec<u8>, ArchiveEntry)>,\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n         let (src_archives, entries) = if let Some(input) = input {\n-            let mut archive = ar::Archive::new(File::open(input).unwrap());\n+            let read_cache = ReadCache::new(File::open(input).unwrap());\n+            let archive = ArchiveFile::parse(&read_cache).unwrap();\n             let mut entries = Vec::new();\n \n-            let mut i = 0;\n-            while let Some(entry) = archive.next_entry() {\n+            for entry in archive.members() {\n                 let entry = entry.unwrap();\n                 entries.push((\n-                    String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n+                    entry.name().to_vec(),\n+                    ArchiveEntry::FromArchive { archive_index: 0, file_range: entry.file_range() },\n                 ));\n-                i += 1;\n             }\n \n-            (vec![(input.to_owned(), archive)], entries)\n+            (vec![read_cache.into_inner()], entries)\n         } else {\n             (vec![], Vec::new())\n         };\n@@ -61,21 +63,21 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     }\n \n     fn src_files(&mut self) -> Vec<String> {\n-        self.entries.iter().map(|(name, _)| name.clone()).collect()\n+        self.entries.iter().map(|(name, _)| String::from_utf8(name.clone()).unwrap()).collect()\n     }\n \n     fn remove_file(&mut self, name: &str) {\n         let index = self\n             .entries\n             .iter()\n-            .position(|(entry_name, _)| entry_name == name)\n+            .position(|(entry_name, _)| entry_name == name.as_bytes())\n             .expect(\"Tried to remove file not existing in src archive\");\n         self.entries.remove(index);\n     }\n \n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string(),\n+            file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n             ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n@@ -84,22 +86,23 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     where\n         F: FnMut(&str) -> bool + 'static,\n     {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n+        let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n+        let archive = ArchiveFile::parse(&read_cache).unwrap();\n         let archive_index = self.src_archives.len();\n \n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n-                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n+        for entry in archive.members() {\n+            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+            let file_name = String::from_utf8(entry.name().to_vec())\n+                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                self.entries\n-                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n+                self.entries.push((\n+                    file_name.into_bytes(),\n+                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n+                ));\n             }\n-            i += 1;\n         }\n \n-        self.src_archives.push((archive_path.to_owned(), archive));\n+        self.src_archives.push(read_cache.into_inner());\n         Ok(())\n     }\n \n@@ -121,14 +124,14 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n-                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n+                ArchiveEntry::FromArchive { archive_index, file_range } => {\n                     // FIXME read symbols from symtab\n-                    use std::io::Read;\n-                    let (ref _src_archive_path, ref mut src_archive) =\n-                        self.src_archives[archive_index];\n-                    let mut entry = src_archive.jump_to_entry(entry_index).unwrap();\n-                    let mut data = Vec::new();\n-                    entry.read_to_end(&mut data).unwrap();\n+                    let src_read_cache = &mut self.src_archives[archive_index];\n+\n+                    src_read_cache.seek(io::SeekFrom::Start(file_range.0)).unwrap();\n+                    let mut data = std::vec::from_elem(0, usize::try_from(file_range.1).unwrap());\n+                    src_read_cache.read_exact(&mut data).unwrap();\n+\n                     data\n                 }\n                 ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n@@ -143,7 +146,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 match object::File::parse(&*data) {\n                     Ok(object) => {\n                         symbol_table.insert(\n-                            entry_name.as_bytes().to_vec(),\n+                            entry_name.to_vec(),\n                             object\n                                 .symbols()\n                                 .filter_map(|symbol| {\n@@ -168,7 +171,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                         } else {\n                             sess.fatal(&format!(\n                                 \"error parsing `{}` during archive creation: {}\",\n-                                entry_name, err\n+                                String::from_utf8_lossy(&entry_name),\n+                                err\n                             ));\n                         }\n                     }\n@@ -187,7 +191,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                             err\n                         ));\n                     }),\n-                    entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n+                    entries.iter().map(|(name, _)| name.clone()).collect(),\n                     ar::GnuSymbolTableFormat::Size32,\n                     symbol_table,\n                 )\n@@ -210,7 +214,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n         // Add all files\n         for (entry_name, data) in entries.into_iter() {\n-            let header = ar::Header::new(entry_name.into_bytes(), data.len() as u64);\n+            let header = ar::Header::new(entry_name, data.len() as u64);\n             match builder {\n                 BuilderKind::Bsd(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n                 BuilderKind::Gnu(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),"}, {"sha": "05c06bac27db47d653f3cea67422290b9f7fe517", "filename": "src/backend.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1b34e2d678bc45a2877c18d93a7a5049f8f8ef84/src%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b34e2d678bc45a2877c18d93a7a5049f8f8ef84/src%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbackend.rs?ref=1b34e2d678bc45a2877c18d93a7a5049f8f8ef84", "patch": "@@ -1,152 +0,0 @@\n-//! Abstraction around the object writing crate\n-\n-use std::convert::{TryFrom, TryInto};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_session::Session;\n-\n-use cranelift_codegen::isa::TargetIsa;\n-use cranelift_module::FuncId;\n-use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n-\n-use object::write::*;\n-use object::{RelocationEncoding, SectionKind, SymbolFlags};\n-\n-use gimli::SectionId;\n-\n-use crate::debuginfo::{DebugReloc, DebugRelocName};\n-\n-pub(crate) trait WriteMetadata {\n-    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>);\n-}\n-\n-impl WriteMetadata for object::write::Object {\n-    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>) {\n-        let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n-        let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n-        let offset = self.append_section_data(section_id, &data, 1);\n-        // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n-        // .rustc section. For ELF this isn't necessary, but it also doesn't harm.\n-        self.add_symbol(object::write::Symbol {\n-            name: symbol_name.into_bytes(),\n-            value: offset,\n-            size: data.len() as u64,\n-            kind: object::SymbolKind::Data,\n-            scope: object::SymbolScope::Dynamic,\n-            weak: false,\n-            section: SymbolSection::Section(section_id),\n-            flags: SymbolFlags::None,\n-        });\n-    }\n-}\n-\n-pub(crate) trait WriteDebugInfo {\n-    type SectionId: Copy;\n-\n-    fn add_debug_section(&mut self, name: SectionId, data: Vec<u8>) -> Self::SectionId;\n-    fn add_debug_reloc(\n-        &mut self,\n-        section_map: &FxHashMap<SectionId, Self::SectionId>,\n-        from: &Self::SectionId,\n-        reloc: &DebugReloc,\n-    );\n-}\n-\n-impl WriteDebugInfo for ObjectProduct {\n-    type SectionId = (object::write::SectionId, object::write::SymbolId);\n-\n-    fn add_debug_section(\n-        &mut self,\n-        id: SectionId,\n-        data: Vec<u8>,\n-    ) -> (object::write::SectionId, object::write::SymbolId) {\n-        let name = if self.object.format() == object::BinaryFormat::MachO {\n-            id.name().replace('.', \"__\") // machO expects __debug_info instead of .debug_info\n-        } else {\n-            id.name().to_string()\n-        }\n-        .into_bytes();\n-\n-        let segment = self.object.segment_name(StandardSegment::Debug).to_vec();\n-        // FIXME use SHT_X86_64_UNWIND for .eh_frame\n-        let section_id = self.object.add_section(\n-            segment,\n-            name,\n-            if id == SectionId::EhFrame { SectionKind::ReadOnlyData } else { SectionKind::Debug },\n-        );\n-        self.object\n-            .section_mut(section_id)\n-            .set_data(data, if id == SectionId::EhFrame { 8 } else { 1 });\n-        let symbol_id = self.object.section_symbol(section_id);\n-        (section_id, symbol_id)\n-    }\n-\n-    fn add_debug_reloc(\n-        &mut self,\n-        section_map: &FxHashMap<SectionId, Self::SectionId>,\n-        from: &Self::SectionId,\n-        reloc: &DebugReloc,\n-    ) {\n-        let (symbol, symbol_offset) = match reloc.name {\n-            DebugRelocName::Section(id) => (section_map.get(&id).unwrap().1, 0),\n-            DebugRelocName::Symbol(id) => {\n-                let symbol_id = self.function_symbol(FuncId::from_u32(id.try_into().unwrap()));\n-                self.object\n-                    .symbol_section_and_offset(symbol_id)\n-                    .expect(\"Debug reloc for undef sym???\")\n-            }\n-        };\n-        self.object\n-            .add_relocation(\n-                from.0,\n-                Relocation {\n-                    offset: u64::from(reloc.offset),\n-                    symbol,\n-                    kind: reloc.kind,\n-                    encoding: RelocationEncoding::Generic,\n-                    size: reloc.size * 8,\n-                    addend: i64::try_from(symbol_offset).unwrap() + reloc.addend,\n-                },\n-            )\n-            .unwrap();\n-    }\n-}\n-\n-pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n-    let triple = crate::target_triple(sess);\n-\n-    let binary_format = match triple.binary_format {\n-        target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n-        target_lexicon::BinaryFormat::Coff => object::BinaryFormat::Coff,\n-        target_lexicon::BinaryFormat::Macho => object::BinaryFormat::MachO,\n-        binary_format => sess.fatal(&format!(\"binary format {} is unsupported\", binary_format)),\n-    };\n-    let architecture = match triple.architecture {\n-        target_lexicon::Architecture::X86_32(_) => object::Architecture::I386,\n-        target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n-        target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n-        target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n-        architecture => {\n-            sess.fatal(&format!(\"target architecture {:?} is unsupported\", architecture,))\n-        }\n-    };\n-    let endian = match triple.endianness().unwrap() {\n-        target_lexicon::Endianness::Little => object::Endianness::Little,\n-        target_lexicon::Endianness::Big => object::Endianness::Big,\n-    };\n-\n-    let mut metadata_object = object::write::Object::new(binary_format, architecture, endian);\n-    metadata_object.add_file_symbol(name.as_bytes().to_vec());\n-    f(&mut metadata_object);\n-    metadata_object.write().unwrap()\n-}\n-\n-pub(crate) fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n-    let mut builder =\n-        ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n-    // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n-    // is important, while cg_clif cares more about compilation times. Enabling -Zfunction-sections\n-    // can easily double the amount of time necessary to perform linking.\n-    builder.per_function_section(sess.opts.debugging_opts.function_sections.unwrap_or(false));\n-    ObjectModule::new(builder)\n-}"}, {"sha": "b924f2085a0fc5546936a82df6019233e48f053a", "filename": "src/bin/cg_clif.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcg_clif.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,4 +1,7 @@\n #![feature(rustc_private, once_cell)]\n+#![warn(rust_2018_idioms)]\n+#![warn(unused_lifetimes)]\n+#![warn(unreachable_pub)]\n \n extern crate rustc_data_structures;\n extern crate rustc_driver;"}, {"sha": "bde4d71b9a33c4f385b9640410e68b0bff51d5e5", "filename": "src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcg_clif_build_sysroot.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -7,6 +7,9 @@\n //! target crates.\n \n #![feature(rustc_private)]\n+#![warn(rust_2018_idioms)]\n+#![warn(unused_lifetimes)]\n+#![warn(unreachable_pub)]\n \n extern crate rustc_driver;\n extern crate rustc_interface;"}, {"sha": "c8c2d50b03409619bcc05a668f4e0002a5d3e0d4", "filename": "src/debuginfo/emit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Femit.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,16 +1,16 @@\n //! Write the debuginfo into an object file.\n \n+use cranelift_object::ObjectProduct;\n use rustc_data_structures::fx::FxHashMap;\n \n use gimli::write::{Address, AttributeValue, EndianVec, Result, Sections, Writer};\n use gimli::{RunTimeEndian, SectionId};\n \n-use crate::backend::WriteDebugInfo;\n-\n+use super::object::WriteDebugInfo;\n use super::DebugContext;\n \n impl DebugContext<'_> {\n-    pub(crate) fn emit<P: WriteDebugInfo>(&mut self, product: &mut P) {\n+    pub(crate) fn emit(&mut self, product: &mut ObjectProduct) {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();\n         let root = self.dwarf.unit.get_mut(root);"}, {"sha": "6d172817cb12ef129fd78aad78ec101d3fb1cf82", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -2,6 +2,7 @@\n \n mod emit;\n mod line_info;\n+mod object;\n mod unwind;\n \n use crate::prelude::*;"}, {"sha": "9984dc92c44d09b15d7dec2ae66322388d9ea72e", "filename": "src/debuginfo/object.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Fobject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Fobject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fobject.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -0,0 +1,85 @@\n+use std::convert::{TryFrom, TryInto};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use cranelift_module::FuncId;\n+use cranelift_object::ObjectProduct;\n+\n+use object::write::{Relocation, StandardSegment};\n+use object::{RelocationEncoding, SectionKind};\n+\n+use gimli::SectionId;\n+\n+use crate::debuginfo::{DebugReloc, DebugRelocName};\n+\n+pub(super) trait WriteDebugInfo {\n+    type SectionId: Copy;\n+\n+    fn add_debug_section(&mut self, name: SectionId, data: Vec<u8>) -> Self::SectionId;\n+    fn add_debug_reloc(\n+        &mut self,\n+        section_map: &FxHashMap<SectionId, Self::SectionId>,\n+        from: &Self::SectionId,\n+        reloc: &DebugReloc,\n+    );\n+}\n+\n+impl WriteDebugInfo for ObjectProduct {\n+    type SectionId = (object::write::SectionId, object::write::SymbolId);\n+\n+    fn add_debug_section(\n+        &mut self,\n+        id: SectionId,\n+        data: Vec<u8>,\n+    ) -> (object::write::SectionId, object::write::SymbolId) {\n+        let name = if self.object.format() == object::BinaryFormat::MachO {\n+            id.name().replace('.', \"__\") // machO expects __debug_info instead of .debug_info\n+        } else {\n+            id.name().to_string()\n+        }\n+        .into_bytes();\n+\n+        let segment = self.object.segment_name(StandardSegment::Debug).to_vec();\n+        // FIXME use SHT_X86_64_UNWIND for .eh_frame\n+        let section_id = self.object.add_section(\n+            segment,\n+            name,\n+            if id == SectionId::EhFrame { SectionKind::ReadOnlyData } else { SectionKind::Debug },\n+        );\n+        self.object\n+            .section_mut(section_id)\n+            .set_data(data, if id == SectionId::EhFrame { 8 } else { 1 });\n+        let symbol_id = self.object.section_symbol(section_id);\n+        (section_id, symbol_id)\n+    }\n+\n+    fn add_debug_reloc(\n+        &mut self,\n+        section_map: &FxHashMap<SectionId, Self::SectionId>,\n+        from: &Self::SectionId,\n+        reloc: &DebugReloc,\n+    ) {\n+        let (symbol, symbol_offset) = match reloc.name {\n+            DebugRelocName::Section(id) => (section_map.get(&id).unwrap().1, 0),\n+            DebugRelocName::Symbol(id) => {\n+                let symbol_id = self.function_symbol(FuncId::from_u32(id.try_into().unwrap()));\n+                self.object\n+                    .symbol_section_and_offset(symbol_id)\n+                    .expect(\"Debug reloc for undef sym???\")\n+            }\n+        };\n+        self.object\n+            .add_relocation(\n+                from.0,\n+                Relocation {\n+                    offset: u64::from(reloc.offset),\n+                    symbol,\n+                    kind: reloc.kind,\n+                    encoding: RelocationEncoding::Generic,\n+                    size: reloc.size * 8,\n+                    addend: i64::try_from(symbol_offset).unwrap() + reloc.addend,\n+                },\n+            )\n+            .unwrap();\n+    }\n+}"}, {"sha": "f0896ea0e167fd09d2ec81e8f29b04e86484cdee", "filename": "src/debuginfo/unwind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Funwind.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -4,10 +4,11 @@ use crate::prelude::*;\n \n use cranelift_codegen::isa::{unwind::UnwindInfo, TargetIsa};\n \n+use cranelift_object::ObjectProduct;\n use gimli::write::{Address, CieId, EhFrame, FrameTable, Section};\n use gimli::RunTimeEndian;\n \n-use crate::backend::WriteDebugInfo;\n+use super::object::WriteDebugInfo;\n \n pub(crate) struct UnwindContext {\n     endian: RunTimeEndian,\n@@ -55,7 +56,7 @@ impl UnwindContext {\n         }\n     }\n \n-    pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n+    pub(crate) fn emit(self, product: &mut ObjectProduct) {\n         let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(self.endian));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n "}, {"sha": "40cbc5e1a7ee473fd317a4f046b602e11722bde6", "filename": "src/driver/aot.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -11,8 +11,10 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n+use rustc_session::Session;\n \n-use cranelift_object::ObjectModule;\n+use cranelift_codegen::isa::TargetIsa;\n+use cranelift_object::{ObjectBuilder, ObjectModule};\n \n use crate::{prelude::*, BackendConfig};\n \n@@ -24,6 +26,16 @@ impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n     }\n }\n \n+fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n+    let mut builder =\n+        ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n+    // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n+    // is important, while cg_clif cares more about compilation times. Enabling -Zfunction-sections\n+    // can easily double the amount of time necessary to perform linking.\n+    builder.per_function_section(sess.opts.debugging_opts.function_sections.unwrap_or(false));\n+    ObjectModule::new(builder)\n+}\n+\n fn emit_module(\n     tcx: TyCtxt<'_>,\n     backend_config: &BackendConfig,\n@@ -104,7 +116,7 @@ fn module_codegen(\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n     let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut module = crate::backend::make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n+    let mut module = make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n@@ -227,8 +239,7 @@ pub(crate) fn run_aot(\n     tcx.sess.abort_if_errors();\n \n     let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut allocator_module =\n-        crate::backend::make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n+    let mut allocator_module = make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n     assert_eq!(pointer_ty(tcx), allocator_module.target_config().pointer_type());\n     let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa(), true);\n     let created_alloc_shim =\n@@ -266,9 +277,7 @@ pub(crate) fn run_aot(\n             let tmp_file =\n                 tcx.output_filenames(()).temp_path(OutputType::Metadata, Some(&metadata_cgu_name));\n \n-            let obj = crate::backend::with_object(tcx.sess, &metadata_cgu_name, |object| {\n-                crate::metadata::write_metadata(tcx, object);\n-            });\n+            let obj = crate::metadata::new_metadata_object(tcx, &metadata_cgu_name, &metadata);\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n                 tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));"}, {"sha": "2ceccdd34994d038781f6509bac70cb76f00d086", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,4 +1,5 @@\n-#![feature(rustc_private, decl_macro, never_type, hash_drain_filter, vec_into_raw_parts, once_cell)]\n+#![feature(rustc_private, decl_macro)]\n+#![cfg_attr(feature = \"jit\", feature(never_type, vec_into_raw_parts, once_cell))]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n@@ -44,7 +45,6 @@ mod abi;\n mod allocator;\n mod analyze;\n mod archive;\n-mod backend;\n mod base;\n mod cast;\n mod codegen_i128;"}, {"sha": "9afa999a87d8d20b3687bd29c2add1215b5e40d2", "filename": "src/metadata.rs", "status": "modified", "additions": 60, "deletions": 8, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e22e340ee260c3fcd0e34e20e5c5d71df04bf/src%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmetadata.rs?ref=500e22e340ee260c3fcd0e34e20e5c5d71df04bf", "patch": "@@ -1,20 +1,72 @@\n //! Writing of the rustc metadata for dylibs\n \n-use rustc_middle::ty::TyCtxt;\n+use object::write::{Object, StandardSegment, Symbol, SymbolSection};\n+use object::{SectionKind, SymbolFlags, SymbolKind, SymbolScope};\n \n-use crate::backend::WriteMetadata;\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::ty::TyCtxt;\n \n // Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n-pub(crate) fn write_metadata<O: WriteMetadata>(tcx: TyCtxt<'_>, object: &mut O) {\n+pub(crate) fn new_metadata_object(tcx: TyCtxt<'_>, cgu_name: &str, metadata: &EncodedMetadata) -> Vec<u8> {\n     use snap::write::FrameEncoder;\n     use std::io::Write;\n \n-    let metadata = tcx.encode_metadata();\n     let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n     FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n-    object.add_rustc_section(\n-        rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),\n-        compressed,\n-    );\n+    let triple = crate::target_triple(tcx.sess);\n+\n+    let binary_format = match triple.binary_format {\n+        target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n+        target_lexicon::BinaryFormat::Coff => object::BinaryFormat::Coff,\n+        target_lexicon::BinaryFormat::Macho => object::BinaryFormat::MachO,\n+        binary_format => tcx.sess.fatal(&format!(\"binary format {} is unsupported\", binary_format)),\n+    };\n+    let architecture = match triple.architecture {\n+        target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n+        target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n+        target_lexicon::Architecture::Avr => object::Architecture::Avr,\n+        target_lexicon::Architecture::Hexagon => object::Architecture::Hexagon,\n+        target_lexicon::Architecture::Mips32(_) => object::Architecture::Mips,\n+        target_lexicon::Architecture::Mips64(_) => object::Architecture::Mips64,\n+        target_lexicon::Architecture::Msp430 => object::Architecture::Msp430,\n+        target_lexicon::Architecture::Powerpc => object::Architecture::PowerPc,\n+        target_lexicon::Architecture::Powerpc64 => object::Architecture::PowerPc64,\n+        target_lexicon::Architecture::Powerpc64le => todo!(),\n+        target_lexicon::Architecture::Riscv32(_) => object::Architecture::Riscv32,\n+        target_lexicon::Architecture::Riscv64(_) => object::Architecture::Riscv64,\n+        target_lexicon::Architecture::S390x => object::Architecture::S390x,\n+        target_lexicon::Architecture::Sparc64 => object::Architecture::Sparc64,\n+        target_lexicon::Architecture::Sparcv9 => object::Architecture::Sparc64,\n+        target_lexicon::Architecture::X86_32(_) => object::Architecture::I386,\n+        target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n+        architecture => {\n+            tcx.sess.fatal(&format!(\"target architecture {:?} is unsupported\", architecture,))\n+        }\n+    };\n+    let endian = match triple.endianness().unwrap() {\n+        target_lexicon::Endianness::Little => object::Endianness::Little,\n+        target_lexicon::Endianness::Big => object::Endianness::Big,\n+    };\n+\n+    let mut object = Object::new(binary_format, architecture, endian);\n+    object.add_file_symbol(cgu_name.as_bytes().to_vec());\n+\n+    let segment = object.segment_name(StandardSegment::Data).to_vec();\n+    let section_id = object.add_section(segment, b\".rustc\".to_vec(), SectionKind::Data);\n+    let offset = object.append_section_data(section_id, &compressed, 1);\n+    // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n+    // .rustc section. For ELF this isn't necessary, but it also doesn't harm.\n+    object.add_symbol(Symbol {\n+        name: rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx).into_bytes(),\n+        value: offset,\n+        size: compressed.len() as u64,\n+        kind: SymbolKind::Data,\n+        scope: SymbolScope::Dynamic,\n+        weak: false,\n+        section: SymbolSection::Section(section_id),\n+        flags: SymbolFlags::None,\n+    });\n+\n+    object.write().unwrap()\n }"}]}