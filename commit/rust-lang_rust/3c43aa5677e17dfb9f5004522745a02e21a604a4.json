{"sha": "3c43aa5677e17dfb9f5004522745a02e21a604a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNDNhYTU2NzdlMTdkZmI5ZjUwMDQ1MjI3NDVhMDJlMjFhNjA0YTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T16:42:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T16:42:31Z"}, "message": "Auto merge of #50102 - Zoxc:query-nomacro, r=michaelwoerister\n\nMove query code outside macros and store query jobs separately from query results\n\nBased on https://github.com/rust-lang/rust/pull/50067\n\nr? @michaelwoerister", "tree": {"sha": "7ed9ce8c95dfe3f264a4edef5ef00f05b024589b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ed9ce8c95dfe3f264a4edef5ef00f05b024589b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c43aa5677e17dfb9f5004522745a02e21a604a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c43aa5677e17dfb9f5004522745a02e21a604a4", "html_url": "https://github.com/rust-lang/rust/commit/3c43aa5677e17dfb9f5004522745a02e21a604a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c43aa5677e17dfb9f5004522745a02e21a604a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d3dac4a86d192c2c80948621859da3b363fa50", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d3dac4a86d192c2c80948621859da3b363fa50", "html_url": "https://github.com/rust-lang/rust/commit/71d3dac4a86d192c2c80948621859da3b363fa50"}, {"sha": "f678bf0ababf77ca224c8110bd6aea5569c698da", "url": "https://api.github.com/repos/rust-lang/rust/commits/f678bf0ababf77ca224c8110bd6aea5569c698da", "html_url": "https://github.com/rust-lang/rust/commit/f678bf0ababf77ca224c8110bd6aea5569c698da"}], "stats": {"total": 1017, "additions": 508, "deletions": 509}, "files": [{"sha": "57c8c4f34e70e66c72ad4a8724972d8a989d6f74", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -9,24 +9,45 @@\n // except according to those terms.\n \n use dep_graph::SerializedDepNodeIndex;\n+use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId};\n use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::maps::queries;\n+use ty::maps::Query;\n+use ty::maps::QueryMap;\n \n use std::hash::Hash;\n+use std::fmt::Debug;\n use syntax_pos::symbol::InternedString;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::stable_hasher::HashStable;\n+use ich::StableHashingContext;\n \n /// Query configuration and description traits.\n \n-pub trait QueryConfig {\n-    type Key: Eq + Hash + Clone;\n-    type Value;\n+pub trait QueryConfig<'tcx> {\n+    const NAME: &'static str;\n+\n+    type Key: Eq + Hash + Clone + Debug;\n+    type Value: Clone + for<'a> HashStable<StableHashingContext<'a>>;\n+\n+    fn query(key: Self::Key) -> Query<'tcx>;\n+\n+    // Don't use this method to access query results, instead use the methods on TyCtxt\n+    fn query_map<'a>(tcx: TyCtxt<'a, 'tcx, '_>) -> &'a Lock<QueryMap<'tcx, Self>>;\n+\n+    fn to_dep_node(tcx: TyCtxt<'_, 'tcx, '_>, key: &Self::Key) -> DepNode;\n+\n+    // Don't use this method to compute query results, instead use the methods on TyCtxt\n+    fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value;\n+\n+    fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value;\n }\n \n-pub(super) trait QueryDescription<'tcx>: QueryConfig {\n+pub trait QueryDescription<'tcx>: QueryConfig<'tcx> {\n     fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n \n     #[inline]\n@@ -41,7 +62,7 @@ pub(super) trait QueryDescription<'tcx>: QueryConfig {\n     }\n }\n \n-impl<'tcx, M: QueryConfig<Key=DefId>> QueryDescription<'tcx> for M {\n+impl<'tcx, M: QueryConfig<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.item_path_str(def_id))"}, {"sha": "3b6af018d6b789d839c4bb2a2f84781bc867cc9a", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -17,13 +17,10 @@ use ty::context::TyCtxt;\n use errors::Diagnostic;\n \n /// Indicates the state of a query for a given key in a query map\n-pub(super) enum QueryResult<'tcx, T> {\n+pub(super) enum QueryResult<'tcx> {\n     /// An already executing query. The query job can be used to await for its completion\n     Started(Lrc<QueryJob<'tcx>>),\n \n-    /// The query is complete and produced `T`\n-    Complete(T),\n-\n     /// The query panicked. Queries trying to wait on this will raise a fatal error / silently panic\n     Poisoned,\n }"}, {"sha": "57223a3c7b2749d6881a51f945f5c2647b91d1cf", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use dep_graph::{DepConstructor, DepNode};\n-use errors::DiagnosticBuilder;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n@@ -43,7 +42,7 @@ use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n-use util::common::{profq_msg, ErrorReported, ProfileQueriesMsg};\n+use util::common::{ErrorReported};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_target::spec::PanicStrategy;\n@@ -68,7 +67,6 @@ pub use self::plumbing::force_from_dep_node;\n \n mod job;\n pub use self::job::{QueryJob, QueryInfo};\n-use self::job::QueryResult;\n \n mod keys;\n pub use self::keys::Key;"}, {"sha": "cea2a03fd532c58c3ea572c5c90c6ffe2567de14", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -30,7 +30,6 @@ use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n-use ty::maps::job::QueryResult;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use ty::context::TyCtxt;\n use util::common::time;\n@@ -239,14 +238,12 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<specialization_graph_of, _>(tcx, enc, qri)?;\n \n                 // const eval is special, it only encodes successfully evaluated constants\n-                use ty::maps::plumbing::GetCacheInternal;\n-                for (key, entry) in const_eval::get_cache_internal(tcx).map.iter() {\n+                use ty::maps::QueryConfig;\n+                let map = const_eval::query_map(tcx).borrow();\n+                assert!(map.active.is_empty());\n+                for (key, entry) in map.results.iter() {\n                     use ty::maps::config::QueryDescription;\n                     if const_eval::cache_on_disk(key.clone()) {\n-                        let entry = match *entry {\n-                            QueryResult::Complete(ref v) => v,\n-                            _ => panic!(\"incomplete query\"),\n-                        };\n                         if let Ok(ref value) = entry.value {\n                             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n@@ -1124,7 +1121,7 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               encoder: &mut CacheEncoder<'enc, 'a, 'tcx, E>,\n                                               query_result_index: &mut EncodedQueryResultIndex)\n                                               -> Result<(), E::Error>\n-    where Q: super::plumbing::GetCacheInternal<'tcx>,\n+    where Q: super::config::QueryDescription<'tcx>,\n           E: 'enc + TyEncoder,\n           Q::Value: Encodable,\n {\n@@ -1133,12 +1130,10 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     time(tcx.sess, desc, || {\n \n-    for (key, entry) in Q::get_cache_internal(tcx).map.iter() {\n+    let map = Q::query_map(tcx).borrow();\n+    assert!(map.active.is_empty());\n+    for (key, entry) in map.results.iter() {\n         if Q::cache_on_disk(key.clone()) {\n-            let entry = match *entry {\n-                QueryResult::Complete(ref v) => v,\n-                _ => panic!(\"incomplete query\"),\n-            };\n             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n             // Record position of the cache entry"}, {"sha": "37950463f74446d1f9b486224e416832a04e8f9b", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 460, "deletions": 478, "changes": 938, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -15,21 +15,29 @@\n use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::DiagnosticBuilder;\n use errors::Level;\n+use errors::Diagnostic;\n+use errors::FatalError;\n use ty::tls;\n use ty::{TyCtxt};\n use ty::maps::Query;\n+use ty::maps::config::QueryConfig;\n use ty::maps::config::QueryDescription;\n-use ty::maps::job::{QueryResult, QueryInfo};\n+use ty::maps::job::{QueryJob, QueryResult, QueryInfo};\n use ty::item_path;\n \n+use util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n+\n use rustc_data_structures::fx::{FxHashMap};\n-use rustc_data_structures::sync::LockGuard;\n-use std::marker::PhantomData;\n+use rustc_data_structures::sync::{Lrc, Lock};\n+use std::mem;\n+use std::ptr;\n+use std::collections::hash_map::Entry;\n use syntax_pos::Span;\n+use syntax::codemap::DUMMY_SP;\n \n-pub(super) struct QueryMap<'tcx, D: QueryDescription<'tcx>> {\n-    phantom: PhantomData<(D, &'tcx ())>,\n-    pub(super) map: FxHashMap<D::Key, QueryResult<'tcx, QueryValue<D::Value>>>,\n+pub struct QueryMap<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n+    pub(super) results: FxHashMap<D::Key, QueryValue<D::Value>>,\n+    pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,\n }\n \n pub(super) struct QueryValue<T> {\n@@ -48,18 +56,166 @@ impl<T> QueryValue<T> {\n     }\n }\n \n-impl<'tcx, M: QueryDescription<'tcx>> QueryMap<'tcx, M> {\n+impl<'tcx, M: QueryConfig<'tcx>> QueryMap<'tcx, M> {\n     pub(super) fn new() -> QueryMap<'tcx, M> {\n         QueryMap {\n-            phantom: PhantomData,\n-            map: FxHashMap(),\n+            results: FxHashMap(),\n+            active: FxHashMap(),\n+        }\n+    }\n+}\n+\n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries() {\n+                profq_msg($tcx.sess, $msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_query_msg {\n+    ($query:expr, $tcx:expr, $key:expr) => {{\n+        let msg = if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None };\n+        QueryMsg {\n+            query: $query,\n+            msg,\n+        }\n+    }}\n+}\n+\n+/// A type representing the responsibility to execute the job in the `job` field.\n+/// This will poison the relevant query if dropped.\n+pub(super) struct JobOwner<'a, 'tcx: 'a, Q: QueryDescription<'tcx> + 'a> {\n+    map: &'a Lock<QueryMap<'tcx, Q>>,\n+    key: Q::Key,\n+    job: Lrc<QueryJob<'tcx>>,\n+}\n+\n+impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n+    /// Either gets a JobOwner corresponding the the query, allowing us to\n+    /// start executing the query, or it returns with the result of the query.\n+    /// If the query is executing elsewhere, this will wait for it.\n+    /// If the query panicked, this will silently panic.\n+    pub(super) fn try_get(\n+        tcx: TyCtxt<'a, 'tcx, '_>,\n+        span: Span,\n+        key: &Q::Key,\n+    ) -> TryGetJob<'a, 'tcx, Q> {\n+        let map = Q::query_map(tcx);\n+        loop {\n+            let mut lock = map.borrow_mut();\n+            if let Some(value) = lock.results.get(key) {\n+                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                let result = Ok((value.value.clone(), value.index));\n+                return TryGetJob::JobCompleted(result);\n+            }\n+            let job = match lock.active.entry((*key).clone()) {\n+                Entry::Occupied(entry) => {\n+                    match *entry.get() {\n+                        QueryResult::Started(ref job) => job.clone(),\n+                        QueryResult::Poisoned => FatalError.raise(),\n+                    }\n+                }\n+                Entry::Vacant(entry) => {\n+                    // No job entry for this query. Return a new one to be started later\n+                    return tls::with_related_context(tcx, |icx| {\n+                        let info = QueryInfo {\n+                            span,\n+                            query: Q::query(key.clone()),\n+                        };\n+                        let job = Lrc::new(QueryJob::new(info, icx.query.clone()));\n+                        let owner = JobOwner {\n+                            map,\n+                            job: job.clone(),\n+                            key: (*key).clone(),\n+                        };\n+                        entry.insert(QueryResult::Started(job));\n+                        TryGetJob::NotYetStarted(owner)\n+                    })\n+                }\n+            };\n+            mem::drop(lock);\n+\n+            if let Err(cycle) = job.await(tcx, span) {\n+                return TryGetJob::JobCompleted(Err(cycle));\n+            }\n+        }\n+    }\n+\n+    /// Completes the query by updating the query map with the `result`,\n+    /// signals the waiter and forgets the JobOwner, so it won't poison the query\n+    pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n+        // We can move out of `self` here because we `mem::forget` it below\n+        let key = unsafe { ptr::read(&self.key) };\n+        let job = unsafe { ptr::read(&self.job) };\n+        let map = self.map;\n+\n+        // Forget ourself so our destructor won't poison the query\n+        mem::forget(self);\n+\n+        let value = QueryValue::new(result.clone(), dep_node_index);\n+        {\n+            let mut lock = map.borrow_mut();\n+            lock.active.remove(&key);\n+            lock.results.insert(key, value);\n         }\n+\n+        job.signal_complete();\n+    }\n+\n+    /// Executes a job by changing the ImplicitCtxt to point to the\n+    /// new query job while it executes. It returns the diagnostics\n+    /// captured during execution and the actual result.\n+    pub(super) fn start<'lcx, F, R>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        compute: F)\n+    -> (R, Vec<Diagnostic>)\n+    where\n+        F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'lcx>) -> R\n+    {\n+        // The TyCtxt stored in TLS has the same global interner lifetime\n+        // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n+        // when accessing the ImplicitCtxt\n+        let r = tls::with_related_context(tcx, move |current_icx| {\n+            // Update the ImplicitCtxt to point to our new query job\n+            let new_icx = tls::ImplicitCtxt {\n+                tcx,\n+                query: Some(self.job.clone()),\n+                layout_depth: current_icx.layout_depth,\n+                task: current_icx.task,\n+            };\n+\n+            // Use the ImplicitCtxt while we execute the query\n+            tls::enter_context(&new_icx, |_| {\n+                compute(tcx)\n+            })\n+        });\n+\n+        // Extract the diagnostic from the job\n+        let diagnostics = mem::replace(&mut *self.job.diagnostics.lock(), Vec::new());\n+\n+        (r, diagnostics)\n     }\n }\n \n-pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n-    fn get_cache_internal<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> LockGuard<'a, QueryMap<'tcx, Self>>;\n+impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n+    fn drop(&mut self) {\n+        // Poison the query so jobs waiting on it panic\n+        self.map.borrow_mut().active.insert(self.key.clone(), QueryResult::Poisoned);\n+        // Also signal the completion of the job, so waiters\n+        // will continue execution\n+        self.job.signal_complete();\n+    }\n }\n \n #[derive(Clone)]\n@@ -70,14 +226,14 @@ pub(super) struct CycleError<'tcx> {\n }\n \n /// The result of `try_get_lock`\n-pub(super) enum TryGetLock<'a, 'tcx: 'a, T, D: QueryDescription<'tcx> + 'a> {\n+pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     /// The query is not yet started. Contains a guard to the map eventually used to start it.\n-    NotYetStarted(LockGuard<'a, QueryMap<'tcx, D>>),\n+    NotYetStarted(JobOwner<'a, 'tcx, D>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep node index\n     /// if it succeeded or a cycle error if it failed\n-    JobCompleted(Result<(T, DepNodeIndex), CycleError<'tcx>>),\n+    JobCompleted(Result<(D::Value, DepNodeIndex), CycleError<'tcx>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -180,28 +336,277 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-}\n \n-// If enabled, send a message to the profile-queries thread\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries() {\n-                profq_msg($tcx.sess, $msg)\n+    fn try_get_with<Q: QueryDescription<'gcx>>(\n+        self,\n+        span: Span,\n+        key: Q::Key)\n+    -> Result<Q::Value, CycleError<'gcx>>\n+    {\n+        debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+               Q::NAME,\n+               key,\n+               span);\n+\n+        profq_msg!(self,\n+            ProfileQueriesMsg::QueryBegin(\n+                span.data(),\n+                profq_query_msg!(Q::NAME, self, key),\n+            )\n+        );\n+\n+        let job = match JobOwner::try_get(self, span, &key) {\n+            TryGetJob::NotYetStarted(job) => job,\n+            TryGetJob::JobCompleted(result) => {\n+                return result.map(|(v, index)| {\n+                    self.dep_graph.read_index(index);\n+                    v\n+                })\n             }\n+        };\n+\n+        // Fast path for when incr. comp. is off. `to_dep_node` is\n+        // expensive for some DepKinds.\n+        if !self.dep_graph.is_fully_enabled() {\n+            let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n+            return self.force_query_with_job::<Q>(key, job, null_dep_node).map(|(v, _)| v);\n+        }\n+\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n+        if dep_node.kind.is_anon() {\n+            profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+\n+            let res = job.start(self, |tcx| {\n+                tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                    Q::compute(tcx.global_tcx(), key)\n+                })\n+            });\n+\n+            profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n+            let ((result, dep_node_index), diagnostics) = res;\n+\n+            self.dep_graph.read_index(dep_node_index);\n+\n+            self.on_disk_query_result_cache\n+                .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+\n+            job.complete(&result, dep_node_index);\n+\n+            return Ok(result);\n+        }\n+\n+        if !dep_node.kind.is_input() {\n+            if let Some(dep_node_index) = self.try_mark_green_and_read(&dep_node) {\n+                profq_msg!(self, ProfileQueriesMsg::CacheHit);\n+                return self.load_from_disk_and_cache_in_memory::<Q>(key,\n+                                                                    job,\n+                                                                    dep_node_index,\n+                                                                    &dep_node)\n+            }\n+        }\n+\n+        match self.force_query_with_job::<Q>(key, job, dep_node) {\n+            Ok((result, dep_node_index)) => {\n+                self.dep_graph.read_index(dep_node_index);\n+                Ok(result)\n+            }\n+            Err(e) => Err(e)\n         }\n     }\n-}\n \n-// If enabled, format a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_key {\n-    ($tcx:expr, $key:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None }\n+    fn load_from_disk_and_cache_in_memory<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        job: JobOwner<'a, 'gcx, Q>,\n+        dep_node_index: DepNodeIndex,\n+        dep_node: &DepNode\n+    ) -> Result<Q::Value, CycleError<'gcx>>\n+    {\n+        // Note this function can be called concurrently from the same query\n+        // We must ensure that this is handled correctly\n+\n+        debug_assert!(self.dep_graph.is_green(dep_node));\n+\n+        // First we try to load the result from the on-disk cache\n+        let result = if Q::cache_on_disk(key.clone()) &&\n+                        self.sess.opts.debugging_opts.incremental_queries {\n+            let prev_dep_node_index =\n+                self.dep_graph.prev_dep_node_index_of(dep_node);\n+            let result = Q::try_load_from_disk(self.global_tcx(),\n+                                                    prev_dep_node_index);\n+\n+            // We always expect to find a cached result for things that\n+            // can be forced from DepNode.\n+            debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n+                            result.is_some(),\n+                            \"Missing on-disk cache entry for {:?}\",\n+                            dep_node);\n+            result\n+        } else {\n+            // Some things are never cached on disk.\n+            None\n+        };\n+\n+        let result = if let Some(result) = result {\n+            result\n+        } else {\n+            // We could not load a result from the on-disk cache, so\n+            // recompute.\n+\n+            // The diagnostics for this query have already been\n+            // promoted to the current session during\n+            // try_mark_green(), so we can ignore them here.\n+            let (result, _) = job.start(self, |tcx| {\n+                // The dep-graph for this computation is already in\n+                // place\n+                tcx.dep_graph.with_ignore(|| {\n+                    Q::compute(tcx, key)\n+                })\n+            });\n+            result\n+        };\n+\n+        // If -Zincremental-verify-ich is specified, re-hash results from\n+        // the cache and make sure that they have the expected fingerprint.\n+        if self.sess.opts.debugging_opts.incremental_verify_ich {\n+            use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+            use ich::Fingerprint;\n+\n+            assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n+                    self.dep_graph.prev_fingerprint_of(dep_node),\n+                    \"Fingerprint for green query instance not loaded \\\n+                        from cache: {:?}\", dep_node);\n+\n+            debug!(\"BEGIN verify_ich({:?})\", dep_node);\n+            let mut hcx = self.create_stable_hashing_context();\n+            let mut hasher = StableHasher::new();\n+\n+            result.hash_stable(&mut hcx, &mut hasher);\n+\n+            let new_hash: Fingerprint = hasher.finish();\n+            debug!(\"END verify_ich({:?})\", dep_node);\n+\n+            let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n+\n+            assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n+                for {:?}\", dep_node);\n+        }\n+\n+        if self.sess.opts.debugging_opts.query_dep_graph {\n+            self.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n+        }\n+\n+        job.complete(&result, dep_node_index);\n+\n+        Ok(result)\n+    }\n+\n+    fn force_query_with_job<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        job: JobOwner<'_, 'gcx, Q>,\n+        dep_node: DepNode)\n+    -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+        // If the following assertion triggers, it can have two reasons:\n+        // 1. Something is wrong with DepNode creation, either here or\n+        //    in DepGraph::try_mark_green()\n+        // 2. Two distinct query keys get mapped to the same DepNode\n+        //    (see for example #48923)\n+        assert!(!self.dep_graph.dep_node_exists(&dep_node),\n+                \"Forcing query with already existing DepNode.\\n\\\n+                    - query-key: {:?}\\n\\\n+                    - dep-node: {:?}\",\n+                key, dep_node);\n+\n+        profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+        let res = job.start(self, |tcx| {\n+            if dep_node.kind.is_eval_always() {\n+                tcx.dep_graph.with_eval_always_task(dep_node,\n+                                                    tcx,\n+                                                    key,\n+                                                    Q::compute)\n+            } else {\n+                tcx.dep_graph.with_task(dep_node,\n+                                        tcx,\n+                                        key,\n+                                        Q::compute)\n+            }\n+        });\n+        profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n+\n+        let ((result, dep_node_index), diagnostics) = res;\n+\n+        if self.sess.opts.debugging_opts.query_dep_graph {\n+            self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n+        }\n+\n+        if dep_node.kind != ::dep_graph::DepKind::Null {\n+            self.on_disk_query_result_cache\n+                .store_diagnostics(dep_node_index, diagnostics);\n+        }\n+\n+        job.complete(&result, dep_node_index);\n+\n+        Ok((result, dep_node_index))\n+    }\n+\n+    /// Ensure that either this query has all green inputs or been executed.\n+    /// Executing query::ensure(D) is considered a read of the dep-node D.\n+    ///\n+    /// This function is particularly useful when executing passes for their\n+    /// side-effects -- e.g., in order to report errors for erroneous programs.\n+    ///\n+    /// Note: The optimization is only available during incr. comp.\n+    pub fn ensure_query<Q: QueryDescription<'gcx>>(self, key: Q::Key) -> () {\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n+        // Ensuring an \"input\" or anonymous query makes no sense\n+        assert!(!dep_node.kind.is_anon());\n+        assert!(!dep_node.kind.is_input());\n+        if self.try_mark_green_and_read(&dep_node).is_none() {\n+            // A None return from `try_mark_green_and_read` means that this is either\n+            // a new dep node or that the dep node has already been marked red.\n+            // Either way, we can't call `dep_graph.read()` as we don't have the\n+            // DepNodeIndex. We must invoke the query itself. The performance cost\n+            // this introduces should be negligible as we'll immediately hit the\n+            // in-memory cache, or another query down the line will.\n+            let _ = self.get_query::<Q>(DUMMY_SP, key);\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    fn force_query<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        span: Span,\n+        dep_node: DepNode\n+    ) -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+        // We may be concurrently trying both execute and force a query\n+        // Ensure that only one of them runs the query\n+        let job = match JobOwner::try_get(self, span, &key) {\n+            TryGetJob::NotYetStarted(job) => job,\n+            TryGetJob::JobCompleted(result) => return result,\n+        };\n+        self.force_query_with_job::<Q>(key, job, dep_node)\n+    }\n+\n+    pub fn try_get_query<Q: QueryDescription<'gcx>>(\n+        self,\n+        span: Span,\n+        key: Q::Key\n+    ) -> Result<Q::Value, DiagnosticBuilder<'a>> {\n+        match self.try_get_with::<Q>(span, key) {\n+            Ok(e) => Ok(e),\n+            Err(e) => Err(self.report_cycle(e)),\n+        }\n+    }\n+\n+    pub fn get_query<Q: QueryDescription<'gcx>>(self, span: Span, key: Q::Key) -> Q::Value {\n+        self.try_get_query::<Q>(span, key).unwrap_or_else(|mut e| {\n+            e.emit();\n+            Q::handle_cycle_error(self)\n+        })\n     }\n }\n \n@@ -210,7 +615,7 @@ macro_rules! handle_cycle_error {\n         Value::from_cycle_error($this.global_tcx())\n     }};\n     ([fatal_cycle$(, $modifiers:ident)*][$this:expr]) => {{\n-        $this.tcx.sess.abort_if_errors();\n+        $this.sess.abort_if_errors();\n         unreachable!();\n     }};\n     ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n@@ -223,12 +628,7 @@ macro_rules! define_maps {\n      $($(#[$attr:meta])*\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n-        use dep_graph::DepNodeIndex;\n-        use std::mem;\n-        use errors::Diagnostic;\n-        use errors::FatalError;\n-        use rustc_data_structures::sync::{Lock, LockGuard};\n-        use rustc_data_structures::OnDrop;\n+        use rustc_data_structures::sync::Lock;\n \n         define_map_struct! {\n             tcx: $tcx,\n@@ -251,12 +651,6 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n-        #[allow(bad_style)]\n-        #[derive(Clone, Debug, PartialEq, Eq)]\n-        pub enum QueryMsg {\n-            $($name(Option<String>)),*\n-        }\n-\n         impl<$tcx> Query<$tcx> {\n             pub fn name(&self) -> &'static str {\n                 match *self {\n@@ -303,162 +697,38 @@ macro_rules! define_maps {\n             })*\n         }\n \n-        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n+        $(impl<$tcx> QueryConfig<$tcx> for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n-        }\n \n-        impl<$tcx> GetCacheInternal<$tcx> for queries::$name<$tcx> {\n-            fn get_cache_internal<'a>(tcx: TyCtxt<'a, $tcx, $tcx>)\n-                                      -> LockGuard<'a, QueryMap<$tcx, Self>> {\n-                tcx.maps.$name.borrow()\n+            const NAME: &'static str = stringify!($name);\n+\n+            fn query(key: Self::Key) -> Query<'tcx> {\n+                Query::$name(key)\n             }\n-        }\n \n-        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+            fn query_map<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryMap<$tcx, Self>> {\n+                &tcx.maps.$name\n+            }\n \n             #[allow(unused)]\n-            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n+            fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n \n                 DepNode::new(tcx, $node(*key))\n             }\n \n-            /// Either get the lock of the query map, allowing us to\n-            /// start executing the query, or it returns with the result of the query.\n-            /// If the query already executed and panicked, this will fatal error / silently panic\n-            fn try_get_lock(\n-                tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                span: Span,\n-                key: &$K\n-            ) -> TryGetLock<'a, $tcx, $V, Self>\n-            {\n-                loop {\n-                    let lock = tcx.maps.$name.borrow_mut();\n-                    let job = if let Some(value) = lock.map.get(key) {\n-                        match *value {\n-                            QueryResult::Started(ref job) => Some(job.clone()),\n-                            QueryResult::Complete(ref value) => {\n-                                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                                let result = Ok(((&value.value).clone(), value.index));\n-                                return TryGetLock::JobCompleted(result);\n-                            },\n-                            QueryResult::Poisoned => FatalError.raise(),\n-                        }\n-                    } else {\n-                        None\n-                    };\n-                    let job = if let Some(job) = job {\n-                        job\n-                    } else {\n-                        return TryGetLock::NotYetStarted(lock);\n-                    };\n-                    mem::drop(lock);\n-\n-                    if let Err(cycle) = job.await(tcx, span) {\n-                        return TryGetLock::JobCompleted(Err(cycle));\n-                    }\n-                }\n+            fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value {\n+                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                provider(tcx.global_tcx(), key)\n             }\n \n-            fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                            span: Span,\n-                            key: $K)\n-                            -> Result<$V, CycleError<$tcx>>\n-            {\n-                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n-                       stringify!($name),\n-                       key,\n-                       span);\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        span.data(),\n-                        QueryMsg::$name(profq_key!(tcx, key))\n-                    )\n-                );\n-\n-                /// Get the lock used to start the query or\n-                /// return the result of the completed query\n-                macro_rules! get_lock_or_return {\n-                    () => {{\n-                        match Self::try_get_lock(tcx, span, &key) {\n-                            TryGetLock::NotYetStarted(lock) => lock,\n-                            TryGetLock::JobCompleted(result) => {\n-                                return result.map(|(v, index)| {\n-                                    tcx.dep_graph.read_index(index);\n-                                    v\n-                                })\n-                            }\n-                        }\n-                    }}\n-                }\n-\n-                let mut lock = get_lock_or_return!();\n-\n-                // Fast path for when incr. comp. is off. `to_dep_node` is\n-                // expensive for some DepKinds.\n-                if !tcx.dep_graph.is_fully_enabled() {\n-                    let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n-                    return Self::force_with_lock(tcx, key, span, lock, null_dep_node)\n-                                .map(|(v, _)| v);\n-                }\n-\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-\n-                if dep_node.kind.is_anon() {\n-                    profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-\n-                    let res = Self::start_job(tcx, span, key, lock, |tcx| {\n-                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                            Self::compute_result(tcx.global_tcx(), key)\n-                        })\n-                    })?;\n-\n-                    profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                    let (((result, dep_node_index), diagnostics), job) = res;\n-\n-                    tcx.dep_graph.read_index(dep_node_index);\n-\n-                    tcx.on_disk_query_result_cache\n-                       .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n-\n-                    let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                    tcx.maps\n-                       .$name\n-                       .borrow_mut()\n-                       .map\n-                       .insert(key, QueryResult::Complete(value));\n-\n-                    job.signal_complete();\n-\n-                    return Ok(result);\n-                }\n-\n-                if !dep_node.kind.is_input() {\n-                    // try_mark_green_and_read may force queries. So we must drop our lock here\n-                    mem::drop(lock);\n-                    if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n-                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        return Self::load_from_disk_and_cache_in_memory(tcx,\n-                                                                        key,\n-                                                                        span,\n-                                                                        dep_node_index,\n-                                                                        &dep_node)\n-                    }\n-                    lock = get_lock_or_return!();\n-                }\n-\n-                match Self::force_with_lock(tcx, key, span, lock, dep_node) {\n-                    Ok((result, dep_node_index)) => {\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                        Ok(result)\n-                    }\n-                    Err(e) => Err(e)\n-                }\n+            fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value {\n+                handle_cycle_error!([$($modifiers)*][tcx])\n             }\n+        }\n \n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n             /// Ensure that either this query has all green inputs or been executed.\n             /// Executing query::ensure(D) is considered a read of the dep-node D.\n             ///\n@@ -467,282 +737,7 @@ macro_rules! define_maps {\n             ///\n             /// Note: The optimization is only available during incr. comp.\n             pub fn ensure(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> () {\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-\n-                // Ensuring an \"input\" or anonymous query makes no sense\n-                assert!(!dep_node.kind.is_anon());\n-                assert!(!dep_node.kind.is_input());\n-                if tcx.try_mark_green_and_read(&dep_node).is_none() {\n-                    // A None return from `try_mark_green_and_read` means that this is either\n-                    // a new dep node or that the dep node has already been marked red.\n-                    // Either way, we can't call `dep_graph.read()` as we don't have the\n-                    // DepNodeIndex. We must invoke the query itself. The performance cost\n-                    // this introduces should be negligible as we'll immediately hit the\n-                    // in-memory cache, or another query down the line will.\n-                    let _ = tcx.$name(key);\n-                }\n-            }\n-\n-            /// Creates a job for the query and updates the query map indicating that it started.\n-            /// Then it changes ImplicitCtxt to point to the new query job while it executes.\n-            /// If the query panics, this updates the query map to indicate so.\n-            fn start_job<F, R>(tcx: TyCtxt<'_, $tcx, 'lcx>,\n-                               span: Span,\n-                               key: $K,\n-                               mut map: LockGuard<'_, QueryMap<$tcx, Self>>,\n-                               compute: F)\n-                -> Result<((R, Vec<Diagnostic>), Lrc<QueryJob<$tcx>>), CycleError<$tcx>>\n-                where F: for<'b> FnOnce(TyCtxt<'b, $tcx, 'lcx>) -> R\n-            {\n-                let query = Query::$name(Clone::clone(&key));\n-\n-                let entry = QueryInfo {\n-                    span,\n-                    query,\n-                };\n-\n-                // The TyCtxt stored in TLS has the same global interner lifetime\n-                // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n-                // when accessing the ImplicitCtxt\n-                let (r, job) = ty::tls::with_related_context(tcx, move |icx| {\n-                    let job = Lrc::new(QueryJob::new(entry, icx.query.clone()));\n-\n-                    // Store the job in the query map and drop the lock to allow\n-                    // others to wait it\n-                    map.map.entry(key).or_insert(QueryResult::Started(job.clone()));\n-                    mem::drop(map);\n-\n-                    let r = {\n-                        let on_drop = OnDrop(|| {\n-                            // Poison the query so jobs waiting on it panic\n-                            tcx.maps\n-                            .$name\n-                            .borrow_mut()\n-                            .map\n-                            .insert(key, QueryResult::Poisoned);\n-                            // Also signal the completion of the job, so waiters\n-                            // will continue execution\n-                            job.signal_complete();\n-                        });\n-\n-                        // Update the ImplicitCtxt to point to our new query job\n-                        let icx = ty::tls::ImplicitCtxt {\n-                            tcx,\n-                            query: Some(job.clone()),\n-                            layout_depth: icx.layout_depth,\n-                            task: icx.task,\n-                        };\n-\n-                        // Use the ImplicitCtxt while we execute the query\n-                        let r = ty::tls::enter_context(&icx, |icx| {\n-                            compute(icx.tcx)\n-                        });\n-\n-                        mem::forget(on_drop);\n-\n-                        r\n-                    };\n-\n-                    (r, job)\n-                });\n-\n-                // Extract the diagnostic from the job\n-                let diagnostics: Vec<_> = mem::replace(&mut *job.diagnostics.lock(), Vec::new());\n-\n-                Ok(((r, diagnostics), job))\n-            }\n-\n-            fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n-                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                provider(tcx.global_tcx(), key)\n-            }\n-\n-            fn load_from_disk_and_cache_in_memory(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                                                  key: $K,\n-                                                  span: Span,\n-                                                  dep_node_index: DepNodeIndex,\n-                                                  dep_node: &DepNode)\n-                                                  -> Result<$V, CycleError<$tcx>>\n-            {\n-                // Note this function can be called concurrently from the same query\n-                // We must ensure that this is handled correctly\n-\n-                debug_assert!(tcx.dep_graph.is_green(dep_node));\n-\n-                // First we try to load the result from the on-disk cache\n-                let result = if Self::cache_on_disk(key) &&\n-                                tcx.sess.opts.debugging_opts.incremental_queries {\n-                    let prev_dep_node_index =\n-                        tcx.dep_graph.prev_dep_node_index_of(dep_node);\n-                    let result = Self::try_load_from_disk(tcx.global_tcx(),\n-                                                          prev_dep_node_index);\n-\n-                    // We always expect to find a cached result for things that\n-                    // can be forced from DepNode.\n-                    debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n-                                  result.is_some(),\n-                                  \"Missing on-disk cache entry for {:?}\",\n-                                  dep_node);\n-                    result\n-                } else {\n-                    // Some things are never cached on disk.\n-                    None\n-                };\n-\n-                let (result, job) = if let Some(result) = result {\n-                    (result, None)\n-                } else {\n-                    // We could not load a result from the on-disk cache, so\n-                    // recompute.\n-\n-                    // The diagnostics for this query have already been\n-                    // promoted to the current session during\n-                    // try_mark_green(), so we can ignore them here.\n-                    let ((result, _), job) = Self::start_job(tcx,\n-                                                             span,\n-                                                             key,\n-                                                             tcx.maps.$name.borrow_mut(),\n-                                                             |tcx| {\n-                        // The dep-graph for this computation is already in\n-                        // place\n-                        tcx.dep_graph.with_ignore(|| {\n-                            Self::compute_result(tcx, key)\n-                        })\n-                    })?;\n-                    (result, Some(job))\n-                };\n-\n-                // If -Zincremental-verify-ich is specified, re-hash results from\n-                // the cache and make sure that they have the expected fingerprint.\n-                if tcx.sess.opts.debugging_opts.incremental_verify_ich {\n-                    use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-                    use ich::Fingerprint;\n-\n-                    assert!(Some(tcx.dep_graph.fingerprint_of(dep_node_index)) ==\n-                            tcx.dep_graph.prev_fingerprint_of(dep_node),\n-                            \"Fingerprint for green query instance not loaded \\\n-                             from cache: {:?}\", dep_node);\n-\n-                    debug!(\"BEGIN verify_ich({:?})\", dep_node);\n-                    let mut hcx = tcx.create_stable_hashing_context();\n-                    let mut hasher = StableHasher::new();\n-\n-                    result.hash_stable(&mut hcx, &mut hasher);\n-\n-                    let new_hash: Fingerprint = hasher.finish();\n-                    debug!(\"END verify_ich({:?})\", dep_node);\n-\n-                    let old_hash = tcx.dep_graph.fingerprint_of(dep_node_index);\n-\n-                    assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n-                        for {:?}\", dep_node);\n-                }\n-\n-                if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n-                }\n-\n-                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                tcx.maps\n-                   .$name\n-                   .borrow_mut()\n-                   .map\n-                   .insert(key, QueryResult::Complete(value));\n-\n-                job.map(|j| j.signal_complete());\n-\n-                Ok(result)\n-            }\n-\n-            #[allow(dead_code)]\n-            fn force(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                     key: $K,\n-                     span: Span,\n-                     dep_node: DepNode)\n-                     -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n-                // We may be concurrently trying both execute and force a query\n-                // Ensure that only one of them runs the query\n-                let lock = match Self::try_get_lock(tcx, span, &key) {\n-                    TryGetLock::NotYetStarted(lock) => lock,\n-                    TryGetLock::JobCompleted(result) => return result,\n-                };\n-                Self::force_with_lock(tcx,\n-                                      key,\n-                                      span,\n-                                      lock,\n-                                      dep_node)\n-            }\n-\n-            fn force_with_lock(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                               key: $K,\n-                               span: Span,\n-                               map: LockGuard<'_, QueryMap<$tcx, Self>>,\n-                               dep_node: DepNode)\n-                               -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n-                // If the following assertion triggers, it can have two reasons:\n-                // 1. Something is wrong with DepNode creation, either here or\n-                //    in DepGraph::try_mark_green()\n-                // 2. Two distinct query keys get mapped to the same DepNode\n-                //    (see for example #48923)\n-                assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n-                        \"Forcing query with already existing DepNode.\\n\\\n-                          - query-key: {:?}\\n\\\n-                          - dep-node: {:?}\",\n-                        key, dep_node);\n-\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-                let res = Self::start_job(tcx,\n-                                          span,\n-                                          key,\n-                                          map,\n-                                          |tcx| {\n-                    if dep_node.kind.is_eval_always() {\n-                        tcx.dep_graph.with_eval_always_task(dep_node,\n-                                                            tcx,\n-                                                            key,\n-                                                            Self::compute_result)\n-                    } else {\n-                        tcx.dep_graph.with_task(dep_node,\n-                                                tcx,\n-                                                key,\n-                                                Self::compute_result)\n-                    }\n-                })?;\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-\n-                let (((result, dep_node_index), diagnostics), job) = res;\n-\n-                if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n-                }\n-\n-                if dep_node.kind != ::dep_graph::DepKind::Null {\n-                    tcx.on_disk_query_result_cache\n-                       .store_diagnostics(dep_node_index, diagnostics);\n-                }\n-\n-                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                tcx.maps\n-                   .$name\n-                   .borrow_mut()\n-                   .map\n-                   .insert(key, QueryResult::Complete(value));\n-\n-                let job: Lrc<QueryJob> = job;\n-\n-                job.signal_complete();\n-\n-                Ok((result, dep_node_index))\n-            }\n-\n-            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, DiagnosticBuilder<'a>> {\n-                match Self::try_get_with(tcx, span, key) {\n-                    Ok(e) => Ok(e),\n-                    Err(e) => Err(tcx.report_cycle(e)),\n-                }\n+                tcx.ensure_query::<queries::$name>(key);\n             }\n         })*\n \n@@ -778,10 +773,7 @@ macro_rules! define_maps {\n         impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n             $($(#[$attr])*\n             pub fn $name(self, key: $K) -> $V {\n-                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n-                    e.emit();\n-                    handle_cycle_error!([$($modifiers)*][self])\n-                })\n+                self.tcx.get_query::<queries::$name>(self.span, key)\n             })*\n         }\n \n@@ -872,7 +864,6 @@ macro_rules! define_provider_struct {\n pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                                            dep_node: &DepNode)\n                                            -> bool {\n-    use ty::maps::keys::Key;\n     use hir::def_id::LOCAL_CRATE;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n@@ -915,23 +906,14 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n             {\n                 use $crate::util::common::{ProfileQueriesMsg, profq_msg};\n \n-                // FIXME(eddyb) Get more valid Span's on queries.\n-                // def_span guard is necessary to prevent a recursive loop,\n-                // default_span calls def_span query internally.\n-                let span = if stringify!($query) != \"def_span\" {\n-                    $key.default_span(tcx)\n-                } else {\n-                    ::syntax_pos::DUMMY_SP\n-                };\n-\n                 profq_msg!(tcx,\n                     ProfileQueriesMsg::QueryBegin(\n-                        span.data(),\n-                        ::ty::maps::QueryMsg::$query(profq_key!(tcx, $key))\n+                        DUMMY_SP.data(),\n+                        profq_query_msg!(::ty::maps::queries::$query::NAME, tcx, $key),\n                     )\n                 );\n \n-                match ::ty::maps::queries::$query::force(tcx, $key, span, *dep_node) {\n+                match tcx.force_query::<::ty::maps::queries::$query>($key, DUMMY_SP, *dep_node) {\n                     Ok(_) => {},\n                     Err(e) => {\n                         tcx.report_cycle(e).emit();"}, {"sha": "5a121d3edbe31f7a62c958675b9d892de4492114", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -2031,7 +2031,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n-        match queries::adt_sized_constraint::try_get(tcx, DUMMY_SP, self.did) {\n+        match tcx.try_get_query::<queries::adt_sized_constraint>(DUMMY_SP, self.did) {\n             Ok(tys) => tys,\n             Err(mut bug) => {\n                 debug!(\"adt_sized_constraint: {:?} is recursive\", self);"}, {"sha": "4aa70e1f7e006964adef5cb1069a1ec8f885afc3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -1024,7 +1024,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {\n-        match ty::queries::needs_drop_raw::try_get(tcx, DUMMY_SP, param_env.and(ty)) {\n+        match tcx.try_get_query::<ty::queries::needs_drop_raw>(DUMMY_SP, param_env.and(ty)) {\n             Ok(v) => v,\n             Err(mut bug) => {\n                 // Cycles should be reported as an error by `check_representable`."}, {"sha": "c74e42263ef1497aacee2fedeaceed19746487b1", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -25,7 +25,6 @@ use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n-use ty::maps::{QueryMsg};\n use ty::TyCtxt;\n use dep_graph::{DepNode};\n use proc_macro;\n@@ -77,6 +76,13 @@ pub struct ProfQDumpParams {\n     pub dump_profq_msg_log:bool,\n }\n \n+#[allow(bad_style)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct QueryMsg {\n+    pub query: &'static str,\n+    pub msg: Option<String>,\n+}\n+\n /// A sequence of these messages induce a trace of query-based incremental compilation.\n /// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n #[derive(Clone,Debug)]"}, {"sha": "6426286ccbc6c3bfb7a0ac2dc5c7176ef9aa2855", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -10,7 +10,7 @@\n \n use super::*;\n use syntax_pos::SpanData;\n-use rustc::ty::maps::QueryMsg;\n+use rustc::util::common::QueryMsg;\n use std::fs::File;\n use std::time::{Duration, Instant};\n use std::collections::hash_map::HashMap;"}, {"sha": "fdfe2a98bf9b935a259eaa1e6dcde776a8ff6d7d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -51,7 +51,7 @@ macro_rules! provide {\n         pub fn provide_extern<$lt>(providers: &mut Providers<$lt>) {\n             $(fn $name<'a, $lt:$lt, T>($tcx: TyCtxt<'a, $lt, $lt>, def_id_arg: T)\n                                     -> <ty::queries::$name<$lt> as\n-                                        QueryConfig>::Value\n+                                        QueryConfig<$lt>>::Value\n                 where T: IntoArgs,\n             {\n                 #[allow(unused_variables)]"}, {"sha": "2e2f84941462826346cce5ece5b4220a3d9e6eef", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c43aa5677e17dfb9f5004522745a02e21a604a4/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=3c43aa5677e17dfb9f5004522745a02e21a604a4", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let callee_mir = match ty::queries::optimized_mir::try_get(self.tcx,\n+                let callee_mir = match self.tcx.try_get_query::<ty::queries::optimized_mir>(\n                                                                            callsite.location.span,\n                                                                            callsite.callee) {\n                     Ok(callee_mir) if self.should_inline(callsite, callee_mir) => {"}]}