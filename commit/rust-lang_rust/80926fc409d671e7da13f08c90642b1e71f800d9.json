{"sha": "80926fc409d671e7da13f08c90642b1e71f800d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwOTI2ZmM0MDlkNjcxZTdkYTEzZjA4YzkwNjQyYjFlNzFmODAwZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-22T14:53:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-22T14:53:58Z"}, "message": "Auto merge of #86368 - michaelwoerister:lexing-ice, r=davidtwco\n\nDisambiguate between SourceFiles from different crates even if they have the same path\n\nThis PR fixes an ICE that can occur when the compiler encounters a source file that is part of both the local crate and an upstream crate:\n\n1. While importing source files from an upstream crate the compiler creates a `SourceFile` entry for `foo.rs` in the `SourceMap`. Since this is an imported source file its `src` field is `None`.\n2. At a later point the parser encounters `foo.rs` again. It tells the `SourceMap` to load the file but because we already have an entry for `foo.rs` the `SourceMap` will return the existing version with `src == None`.\n3. The parser proceeds under the assumption that `src.is_some()` and panics when actually trying to use the file's contents.\n\nThis PR fixes the issue by adding the source file's associated `CrateNum` to the `SourceMap`'s interning key. As a consequence the two instances of the file will each have a separate entry in the `SourceMap`. They just happen to share the same file path. This approach seemed less problematic to me than trying to mutate the `SourceFile` after it had already been created.\n\nAnother, more involved, approach might be to merge the `src` and the `external_src` field.\n\nFixes #85955", "tree": {"sha": "726ca593e13f10dfc8c0ec3eb38aa40c2e27403a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/726ca593e13f10dfc8c0ec3eb38aa40c2e27403a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80926fc409d671e7da13f08c90642b1e71f800d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80926fc409d671e7da13f08c90642b1e71f800d9", "html_url": "https://github.com/rust-lang/rust/commit/80926fc409d671e7da13f08c90642b1e71f800d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80926fc409d671e7da13f08c90642b1e71f800d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3487be11d5f3c9afc4d8e44438cdd2af1e98c859", "url": "https://api.github.com/repos/rust-lang/rust/commits/3487be11d5f3c9afc4d8e44438cdd2af1e98c859", "html_url": "https://github.com/rust-lang/rust/commit/3487be11d5f3c9afc4d8e44438cdd2af1e98c859"}, {"sha": "c3c4ab5ed204b09a8446f9abbdb4d49b278756be", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c4ab5ed204b09a8446f9abbdb4d49b278756be", "html_url": "https://github.com/rust-lang/rust/commit/c3c4ab5ed204b09a8446f9abbdb4d49b278756be"}], "stats": {"total": 104, "additions": 89, "deletions": 15}, "files": [{"sha": "6df8e64fada8615684fafe37c9ab2a95f57f49d5", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/80926fc409d671e7da13f08c90642b1e71f800d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80926fc409d671e7da13f08c90642b1e71f800d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=80926fc409d671e7da13f08c90642b1e71f800d9", "patch": "@@ -54,7 +54,7 @@ pub struct OnDiskCache<'sess> {\n     cnum_map: OnceCell<UnhashMap<StableCrateId, CrateNum>>,\n \n     source_map: &'sess SourceMap,\n-    file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n+    file_index_to_stable_id: FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n \n     // Caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n@@ -111,7 +111,7 @@ pub struct OnDiskCache<'sess> {\n // This type is used only for serialization and deserialization.\n #[derive(Encodable, Decodable)]\n struct Footer {\n-    file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n+    file_index_to_stable_id: FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n     // The location of all allocations.\n@@ -157,6 +157,32 @@ crate struct RawDefId {\n     pub index: u32,\n }\n \n+/// An `EncodedSourceFileId` is the same as a `StableSourceFileId` except that\n+/// the source crate is represented as a [StableCrateId] instead of as a\n+/// `CrateNum`. This way `EncodedSourceFileId` can be encoded and decoded\n+/// without any additional context, i.e. with a simple `opaque::Decoder` (which\n+/// is the only thing available when decoding the cache's [Footer].\n+#[derive(Encodable, Decodable, Clone, Debug)]\n+struct EncodedSourceFileId {\n+    file_name_hash: u64,\n+    stable_crate_id: StableCrateId,\n+}\n+\n+impl EncodedSourceFileId {\n+    fn translate(&self, cnum_map: &UnhashMap<StableCrateId, CrateNum>) -> StableSourceFileId {\n+        let cnum = cnum_map[&self.stable_crate_id];\n+        StableSourceFileId { file_name_hash: self.file_name_hash, cnum }\n+    }\n+\n+    fn new(tcx: TyCtxt<'_>, file: &SourceFile) -> EncodedSourceFileId {\n+        let source_file_id = StableSourceFileId::new(file);\n+        EncodedSourceFileId {\n+            file_name_hash: source_file_id.file_name_hash,\n+            stable_crate_id: tcx.stable_crate_id(source_file_id.cnum),\n+        }\n+    }\n+}\n+\n impl<'sess> OnDiskCache<'sess> {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n     pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n@@ -238,7 +264,8 @@ impl<'sess> OnDiskCache<'sess> {\n                     let index = SourceFileIndex(index as u32);\n                     let file_ptr: *const SourceFile = &**file as *const _;\n                     file_to_file_index.insert(file_ptr, index);\n-                    file_index_to_stable_id.insert(index, StableSourceFileId::new(&file));\n+                    let source_file_id = EncodedSourceFileId::new(tcx, &file);\n+                    file_index_to_stable_id.insert(index, source_file_id);\n                 }\n \n                 (file_to_file_index, file_index_to_stable_id)\n@@ -605,7 +632,7 @@ pub struct CacheDecoder<'a, 'tcx> {\n     source_map: &'a SourceMap,\n     cnum_map: &'a UnhashMap<StableCrateId, CrateNum>,\n     file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n-    file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, StableSourceFileId>,\n+    file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n     syntax_contexts: &'a FxHashMap<u32, AbsoluteBytePos>,\n     expn_data: &'a FxHashMap<u32, AbsoluteBytePos>,\n@@ -618,14 +645,15 @@ impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n             ref file_index_to_file,\n             ref file_index_to_stable_id,\n             ref source_map,\n+            ref cnum_map,\n             ..\n         } = *self;\n \n         file_index_to_file\n             .borrow_mut()\n             .entry(index)\n             .or_insert_with(|| {\n-                let stable_id = file_index_to_stable_id[&index];\n+                let stable_id = file_index_to_stable_id[&index].translate(cnum_map);\n                 source_map\n                     .source_file_by_stable_id(stable_id)\n                     .expect(\"failed to lookup `SourceFile` in new context\")"}, {"sha": "32031ac70715f9735ceff3b2f759e2824f98bde7", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/80926fc409d671e7da13f08c90642b1e71f800d9/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80926fc409d671e7da13f08c90642b1e71f800d9/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=80926fc409d671e7da13f08c90642b1e71f800d9", "patch": "@@ -117,25 +117,42 @@ impl FileLoader for RealFileLoader {\n     }\n }\n \n-// This is a `SourceFile` identifier that is used to correlate `SourceFile`s between\n-// subsequent compilation sessions (which is something we need to do during\n-// incremental compilation).\n+/// This is a [SourceFile] identifier that is used to correlate source files between\n+/// subsequent compilation sessions (which is something we need to do during\n+/// incremental compilation).\n+///\n+/// The [StableSourceFileId] also contains the CrateNum of the crate the source\n+/// file was originally parsed for. This way we get two separate entries in\n+/// the [SourceMap] if the same file is part of both the local and an upstream\n+/// crate. Trying to only have one entry for both cases is problematic because\n+/// at the point where we discover that there's a local use of the file in\n+/// addition to the upstream one, we might already have made decisions based on\n+/// the assumption that it's an upstream file. Treating the two files as\n+/// different has no real downsides.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n-pub struct StableSourceFileId(u128);\n+pub struct StableSourceFileId {\n+    // A hash of the source file's FileName. This is hash so that it's size\n+    // is more predictable than if we included the actual FileName value.\n+    pub file_name_hash: u64,\n+\n+    // The CrateNum of the crate this source file was originally parsed for.\n+    // We cannot include this information in the hash because at the time\n+    // of hashing we don't have the context to map from the CrateNum's numeric\n+    // value to a StableCrateId.\n+    pub cnum: CrateNum,\n+}\n \n // FIXME: we need a more globally consistent approach to the problem solved by\n // StableSourceFileId, perhaps built atop source_file.name_hash.\n impl StableSourceFileId {\n     pub fn new(source_file: &SourceFile) -> StableSourceFileId {\n-        StableSourceFileId::new_from_name(&source_file.name)\n+        StableSourceFileId::new_from_name(&source_file.name, source_file.cnum)\n     }\n \n-    fn new_from_name(name: &FileName) -> StableSourceFileId {\n+    fn new_from_name(name: &FileName, cnum: CrateNum) -> StableSourceFileId {\n         let mut hasher = StableHasher::new();\n-\n         name.hash(&mut hasher);\n-\n-        StableSourceFileId(hasher.finish())\n+        StableSourceFileId { file_name_hash: hasher.finish(), cnum }\n     }\n }\n \n@@ -274,7 +291,7 @@ impl SourceMap {\n         // be empty, so the working directory will be used.\n         let (filename, _) = self.path_mapping.map_filename_prefix(&filename);\n \n-        let file_id = StableSourceFileId::new_from_name(&filename);\n+        let file_id = StableSourceFileId::new_from_name(&filename, LOCAL_CRATE);\n \n         let lrc_sf = match self.source_file_by_stable_id(file_id) {\n             Some(lrc_sf) => lrc_sf,\n@@ -288,6 +305,10 @@ impl SourceMap {\n                     self.hash_kind,\n                 ));\n \n+                // Let's make sure the file_id we generated above actually matches\n+                // the ID we generate for the SourceFile we just created.\n+                debug_assert_eq!(StableSourceFileId::new(&source_file), file_id);\n+\n                 let mut files = self.files.borrow_mut();\n \n                 files.source_files.push(source_file.clone());"}, {"sha": "7b680bce49eb30bd8771e39c085b141be0f5db49", "filename": "src/test/ui/include-macros/auxiliary/same-file-in-two-crates-aux.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80926fc409d671e7da13f08c90642b1e71f800d9/src%2Ftest%2Fui%2Finclude-macros%2Fauxiliary%2Fsame-file-in-two-crates-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80926fc409d671e7da13f08c90642b1e71f800d9/src%2Ftest%2Fui%2Finclude-macros%2Fauxiliary%2Fsame-file-in-two-crates-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finclude-macros%2Fauxiliary%2Fsame-file-in-two-crates-aux.rs?ref=80926fc409d671e7da13f08c90642b1e71f800d9", "patch": "@@ -0,0 +1,4 @@\n+#[inline]\n+pub fn some_function() -> u32 {\n+    1\n+}"}, {"sha": "f49efa2cf8a89c2f18b9c07e097b195b0f10e093", "filename": "src/test/ui/include-macros/same-file-in-two-crates.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/80926fc409d671e7da13f08c90642b1e71f800d9/src%2Ftest%2Fui%2Finclude-macros%2Fsame-file-in-two-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80926fc409d671e7da13f08c90642b1e71f800d9/src%2Ftest%2Fui%2Finclude-macros%2Fsame-file-in-two-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finclude-macros%2Fsame-file-in-two-crates.rs?ref=80926fc409d671e7da13f08c90642b1e71f800d9", "patch": "@@ -0,0 +1,21 @@\n+// This test makes sure that the compiler can handle the same source file to be\n+// part of the local crate *and* an upstream crate. This can happen, for example,\n+// when there is some auto-generated code that is part of both a library and an\n+// accompanying integration test.\n+//\n+// The test uses include!() to include a source file that is also part of\n+// an upstream crate.\n+//\n+// This is a regression test for https://github.com/rust-lang/rust/issues/85955.\n+\n+// check-pass\n+// compile-flags: --crate-type=rlib\n+// aux-build:same-file-in-two-crates-aux.rs\n+extern crate same_file_in_two_crates_aux;\n+\n+pub fn foo() -> u32 {\n+    same_file_in_two_crates_aux::some_function() +\n+    some_function()\n+}\n+\n+include!(\"./auxiliary/same-file-in-two-crates-aux.rs\");"}]}