{"sha": "d338a803941c2b0ac83decfcdfac33c09dfaa971", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMzhhODAzOTQxYzJiMGFjODNkZWNmY2RmYWMzM2MwOWRmYWE5NzE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-16T15:37:23Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-16T19:51:20Z"}, "message": "Start refactoring ide_completion tests", "tree": {"sha": "6656cf5923aa537bbfba8c1bd267fe8dfafb2c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6656cf5923aa537bbfba8c1bd267fe8dfafb2c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d338a803941c2b0ac83decfcdfac33c09dfaa971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d338a803941c2b0ac83decfcdfac33c09dfaa971", "html_url": "https://github.com/rust-lang/rust/commit/d338a803941c2b0ac83decfcdfac33c09dfaa971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d338a803941c2b0ac83decfcdfac33c09dfaa971/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f38770cd2606148bfe764351849ea7ebea45132c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f38770cd2606148bfe764351849ea7ebea45132c", "html_url": "https://github.com/rust-lang/rust/commit/f38770cd2606148bfe764351849ea7ebea45132c"}], "stats": {"total": 549, "additions": 302, "deletions": 247}, "files": [{"sha": "cba5eb0c688d20f2d793a5381173103d70688014", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -41,9 +41,9 @@ pub struct Completions {\n     buf: Vec<CompletionItem>,\n }\n \n-impl Into<Vec<CompletionItem>> for Completions {\n-    fn into(self) -> Vec<CompletionItem> {\n-        self.buf\n+impl From<Completions> for Vec<CompletionItem> {\n+    fn from(val: Completions) -> Self {\n+        val.buf\n     }\n }\n \n@@ -74,35 +74,6 @@ impl Completions {\n         items.into_iter().for_each(|item| self.add(item.into()))\n     }\n \n-    pub(crate) fn add_field(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        receiver: Option<hir::Name>,\n-        field: hir::Field,\n-        ty: &hir::Type,\n-    ) {\n-        let item = render_field(RenderContext::new(ctx), receiver, field, ty);\n-        self.add(item);\n-    }\n-\n-    pub(crate) fn add_tuple_field(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        receiver: Option<hir::Name>,\n-        field: usize,\n-        ty: &hir::Type,\n-    ) {\n-        let item = render_tuple_field(RenderContext::new(ctx), receiver, field, ty);\n-        self.add(item);\n-    }\n-\n-    pub(crate) fn add_static_lifetime(&mut self, ctx: &CompletionContext) {\n-        let mut item =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), \"'static\");\n-        item.kind(CompletionItemKind::SymbolKind(SymbolKind::LifetimeParam));\n-        self.add(item.build());\n-    }\n-\n     pub(crate) fn add_resolution(\n         &mut self,\n         ctx: &CompletionContext,\n@@ -144,72 +115,102 @@ impl Completions {\n         self.add_opt(render_method(RenderContext::new(ctx), None, receiver, local_name, func));\n     }\n \n-    pub(crate) fn add_variant_pat(\n+    pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n+        self.add_opt(render_const(RenderContext::new(ctx), constant));\n+    }\n+\n+    pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n+        self.add_opt(render_type_alias(RenderContext::new(ctx), type_alias));\n+    }\n+\n+    pub(crate) fn add_type_alias_with_eq(\n         &mut self,\n         ctx: &CompletionContext,\n-        variant: hir::Variant,\n-        local_name: Option<hir::Name>,\n+        type_alias: hir::TypeAlias,\n     ) {\n-        self.add_opt(render_variant_pat(RenderContext::new(ctx), variant, local_name, None));\n+        self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx), type_alias));\n     }\n \n-    pub(crate) fn add_qualified_variant_pat(\n+    pub(crate) fn add_qualified_enum_variant(\n         &mut self,\n         ctx: &CompletionContext,\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n-        self.add_opt(render_variant_pat(RenderContext::new(ctx), variant, None, Some(path)));\n+        let item = render_variant(RenderContext::new(ctx), None, None, variant, Some(path));\n+        self.add(item);\n     }\n \n-    pub(crate) fn add_struct_pat(\n+    pub(crate) fn add_enum_variant(\n         &mut self,\n         ctx: &CompletionContext,\n-        strukt: hir::Struct,\n+        variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n-        self.add_opt(render_struct_pat(RenderContext::new(ctx), strukt, local_name));\n+        let item = render_variant(RenderContext::new(ctx), None, local_name, variant, None);\n+        self.add(item);\n     }\n \n-    pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n-        self.add_opt(render_const(RenderContext::new(ctx), constant));\n+    pub(crate) fn add_field(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        receiver: Option<hir::Name>,\n+        field: hir::Field,\n+        ty: &hir::Type,\n+    ) {\n+        let item = render_field(RenderContext::new(ctx), receiver, field, ty);\n+        self.add(item);\n     }\n \n-    pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n-        self.add_opt(render_type_alias(RenderContext::new(ctx), type_alias));\n+    pub(crate) fn add_tuple_field(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        receiver: Option<hir::Name>,\n+        field: usize,\n+        ty: &hir::Type,\n+    ) {\n+        let item = render_tuple_field(RenderContext::new(ctx), receiver, field, ty);\n+        self.add(item);\n     }\n \n-    pub(crate) fn add_type_alias_with_eq(\n+    pub(crate) fn add_static_lifetime(&mut self, ctx: &CompletionContext) {\n+        let mut item =\n+            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), \"'static\");\n+        item.kind(CompletionItemKind::SymbolKind(SymbolKind::LifetimeParam));\n+        self.add(item.build());\n+    }\n+\n+    pub(crate) fn add_variant_pat(\n         &mut self,\n         ctx: &CompletionContext,\n-        type_alias: hir::TypeAlias,\n+        variant: hir::Variant,\n+        local_name: Option<hir::Name>,\n     ) {\n-        self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx), type_alias));\n+        self.add_opt(render_variant_pat(RenderContext::new(ctx), variant, local_name, None));\n     }\n \n-    pub(crate) fn add_qualified_enum_variant(\n+    pub(crate) fn add_qualified_variant_pat(\n         &mut self,\n         ctx: &CompletionContext,\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n-        let item = render_variant(RenderContext::new(ctx), None, None, variant, Some(path));\n-        self.add(item);\n+        self.add_opt(render_variant_pat(RenderContext::new(ctx), variant, None, Some(path)));\n     }\n \n-    pub(crate) fn add_enum_variant(\n+    pub(crate) fn add_struct_pat(\n         &mut self,\n         ctx: &CompletionContext,\n-        variant: hir::Variant,\n+        strukt: hir::Struct,\n         local_name: Option<hir::Name>,\n     ) {\n-        let item = render_variant(RenderContext::new(ctx), None, local_name, variant, None);\n-        self.add(item);\n+        self.add_opt(render_struct_pat(RenderContext::new(ctx), strukt, local_name));\n     }\n }\n \n /// Calls the callback for each variant of the provided enum with the path to the variant.\n-fn complete_enum_variants(\n+/// Skips variants that are visible with single segment paths.\n+fn enum_variants_with_paths(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     enum_: hir::Enum,"}, {"sha": "2c42438d66c513f18cb32eaf5ec5bbd88484d301", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -230,30 +230,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn test_keywords_at_source_file_level() {\n-        check(\n-            r\"m$0\",\n-            expect![[r#\"\n-                kw pub(crate)\n-                kw pub\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw use\n-                kw impl\n-                kw trait\n-                kw static\n-                kw extern\n-                kw mod\n-                kw enum\n-                kw struct\n-                kw union\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn test_keywords_in_function() {\n         check(\n@@ -442,18 +418,6 @@ fn quux() -> i32 {\n         );\n     }\n \n-    #[test]\n-    fn test_keywords_after_unsafe_in_item_list() {\n-        check(\n-            r\"unsafe $0\",\n-            expect![[r#\"\n-                kw fn\n-                kw trait\n-                kw impl\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn test_keywords_after_unsafe_in_block_expr() {\n         check("}, {"sha": "e45b2a1ea1762933b598a54d2ecf29bccf409eba", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -13,7 +13,7 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         if let Some(hir::Adt::Enum(e)) =\n             ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n         {\n-            super::complete_enum_variants(acc, ctx, e, |acc, ctx, variant, path| {\n+            super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n                 acc.add_qualified_variant_pat(ctx, variant, path.clone());\n                 acc.add_qualified_enum_variant(ctx, variant, path);\n             });"}, {"sha": "165b9e6a5407bc371fa73941d572ed67de66d1a1", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -713,24 +713,6 @@ impl MyStruct {\n         );\n     }\n \n-    #[test]\n-    fn completes_in_item_list() {\n-        check(\n-            r#\"\n-struct MyStruct {}\n-#[macro_export]\n-macro_rules! foo {}\n-mod bar {}\n-\n-crate::$0\n-\"#,\n-            expect![[r#\"\n-                md bar\n-                ma foo!(\u2026) #[macro_export] macro_rules! foo\n-            \"#]],\n-        )\n-    }\n-\n     #[test]\n     fn test_super_super_completion() {\n         check("}, {"sha": "5560f1acf01dbc9d468b6ec033a2f0dac64de707", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -105,21 +105,4 @@ mod tests {\n         check(r#\"fn foo(x: i32) { ::foo$0 }\"#, expect![[\"\"]]);\n         check(r#\"fn foo(x: i32) { ::$0 }\"#, expect![[\"\"]]);\n     }\n-\n-    #[test]\n-    fn completes_snippets_in_items() {\n-        check(\n-            r#\"\n-#[cfg(test)]\n-mod tests {\n-    $0\n-}\n-\"#,\n-            expect![[r#\"\n-                sn tmod (Test module)\n-                sn tfn (Test function)\n-                sn macro_rules\n-            \"#]],\n-        )\n-    }\n }"}, {"sha": "2c623bf7ae2398159e49da6fb0a714d408637537", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -40,7 +40,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         if let Some(hir::Adt::Enum(e)) =\n             ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n         {\n-            super::complete_enum_variants(acc, ctx, e, |acc, ctx, variant, path| {\n+            super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n                 acc.add_qualified_enum_variant(ctx, variant, path)\n             });\n         }"}, {"sha": "be6442426c2f7d6d54b510244d6d5eeb53eba212", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 7, "deletions": 118, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -1,14 +1,16 @@\n //! `completions` crate provides utilities for generating completions of user input.\n \n+mod completions;\n mod config;\n-mod item;\n mod context;\n+mod item;\n mod patterns;\n-#[cfg(test)]\n-mod test_utils;\n mod render;\n \n-mod completions;\n+#[cfg(test)]\n+mod tests;\n+#[cfg(test)]\n+mod test_utils;\n \n use completions::flyimport::position_for_import;\n use ide_db::{\n@@ -141,6 +143,7 @@ pub fn completions(\n     let ctx = CompletionContext::new(db, position, config)?;\n \n     if ctx.no_completion_required() {\n+        cov_mark::hit!(no_completion_required);\n         // No work required here.\n         return None;\n     }\n@@ -200,117 +203,3 @@ pub fn resolve_completion_edits(\n \n     ImportEdit { import, scope }.to_text_edit(config.insert_use).map(|edit| vec![edit])\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::test_utils::{self, TEST_CONFIG};\n-\n-    struct DetailAndDocumentation<'a> {\n-        detail: &'a str,\n-        documentation: &'a str,\n-    }\n-\n-    fn check_detail_and_documentation(ra_fixture: &str, expected: DetailAndDocumentation) {\n-        let (db, position) = test_utils::position(ra_fixture);\n-        let config = TEST_CONFIG;\n-        let completions: Vec<_> = crate::completions(&db, &config, position).unwrap().into();\n-        for item in completions {\n-            if item.detail() == Some(expected.detail) {\n-                let opt = item.documentation();\n-                let doc = opt.as_ref().map(|it| it.as_str());\n-                assert_eq!(doc, Some(expected.documentation));\n-                return;\n-            }\n-        }\n-        panic!(\"completion detail not found: {}\", expected.detail)\n-    }\n-\n-    fn check_no_completion(ra_fixture: &str) {\n-        let (db, position) = test_utils::position(ra_fixture);\n-        let config = TEST_CONFIG;\n-\n-        let completions: Option<Vec<String>> = crate::completions(&db, &config, position)\n-            .and_then(|completions| {\n-                let completions: Vec<_> = completions.into();\n-                if completions.is_empty() {\n-                    None\n-                } else {\n-                    Some(completions)\n-                }\n-            })\n-            .map(|completions| {\n-                completions.into_iter().map(|completion| format!(\"{:?}\", completion)).collect()\n-            });\n-\n-        // `assert_eq` instead of `assert!(completions.is_none())` to get the list of completions if test will panic.\n-        assert_eq!(completions, None, \"Completions were generated, but weren't expected\");\n-    }\n-\n-    #[test]\n-    fn test_completion_detail_from_macro_generated_struct_fn_doc_attr() {\n-        check_detail_and_documentation(\n-            r#\"\n-macro_rules! bar {\n-    () => {\n-        struct Bar;\n-        impl Bar {\n-            #[doc = \"Do the foo\"]\n-            fn foo(&self) {}\n-        }\n-    }\n-}\n-\n-bar!();\n-\n-fn foo() {\n-    let bar = Bar;\n-    bar.fo$0;\n-}\n-\"#,\n-            DetailAndDocumentation { detail: \"fn(&self)\", documentation: \"Do the foo\" },\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_detail_from_macro_generated_struct_fn_doc_comment() {\n-        check_detail_and_documentation(\n-            r#\"\n-macro_rules! bar {\n-    () => {\n-        struct Bar;\n-        impl Bar {\n-            /// Do the foo\n-            fn foo(&self) {}\n-        }\n-    }\n-}\n-\n-bar!();\n-\n-fn foo() {\n-    let bar = Bar;\n-    bar.fo$0;\n-}\n-\"#,\n-            DetailAndDocumentation { detail: \"fn(&self)\", documentation: \"Do the foo\" },\n-        );\n-    }\n-\n-    #[test]\n-    fn test_no_completions_required() {\n-        // There must be no hint for 'in' keyword.\n-        check_no_completion(r#\"fn foo() { for i i$0 }\"#);\n-        // After 'in' keyword hints may be spawned.\n-        check_detail_and_documentation(\n-            r#\"\n-/// Do the foo\n-fn foo() -> &'static str { \"foo\" }\n-\n-fn bar() {\n-    for c in fo$0\n-}\n-\"#,\n-            DetailAndDocumentation { detail: \"fn() -> &str\", documentation: \"Do the foo\" },\n-        );\n-    }\n-}"}, {"sha": "4485a908e5d3761816135bae9c63ebef24da0d4f", "filename": "crates/ide_completion/src/tests.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -0,0 +1,64 @@\n+mod item_list;\n+\n+use expect_test::Expect;\n+use stdx::format_to;\n+\n+use crate::{\n+    test_utils::{self, get_all_items, TEST_CONFIG},\n+    CompletionConfig, CompletionItem,\n+};\n+\n+fn completion_list(code: &str) -> String {\n+    completion_list_with_config(TEST_CONFIG, code)\n+}\n+\n+fn completion_list_with_config(config: CompletionConfig, code: &str) -> String {\n+    fn monospace_width(s: &str) -> usize {\n+        s.chars().count()\n+    }\n+\n+    let kind_completions: Vec<CompletionItem> = get_all_items(config, code).into_iter().collect();\n+    let label_width = kind_completions\n+        .iter()\n+        .map(|it| monospace_width(it.label()))\n+        .max()\n+        .unwrap_or_default()\n+        .min(16);\n+    kind_completions\n+        .into_iter()\n+        .map(|it| {\n+            let tag = it.kind().unwrap().tag();\n+            let var_name = format!(\"{} {}\", tag, it.label());\n+            let mut buf = var_name;\n+            if let Some(detail) = it.detail() {\n+                let width = label_width.saturating_sub(monospace_width(it.label()));\n+                format_to!(buf, \"{:width$} {}\", \"\", detail, width = width);\n+            }\n+            if it.deprecated() {\n+                format_to!(buf, \" DEPRECATED\");\n+            }\n+            format_to!(buf, \"\\n\");\n+            buf\n+        })\n+        .collect()\n+}\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n+fn check_no_completion(ra_fixture: &str) {\n+    let (db, position) = test_utils::position(ra_fixture);\n+\n+    assert!(\n+        crate::completions(&db, &TEST_CONFIG, position).is_none(),\n+        \"Completions were generated, but weren't expected\"\n+    );\n+}\n+\n+#[test]\n+fn test_no_completions_required() {\n+    cov_mark::check!(no_completion_required);\n+    check_no_completion(r#\"fn foo() { for i i$0 }\"#);\n+}"}, {"sha": "bd060a63237b344ef5d0520381f97d67a422fedc", "filename": "crates/ide_completion/src/tests/item_list.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338a803941c2b0ac83decfcdfac33c09dfaa971/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=d338a803941c2b0ac83decfcdfac33c09dfaa971", "patch": "@@ -0,0 +1,172 @@\n+use expect_test::expect;\n+\n+use crate::tests::check;\n+\n+#[test]\n+fn in_mod_item_list() {\n+    check(\n+        r#\"mod tests {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw pub(crate)\n+            kw pub\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw use\n+            kw impl\n+            kw trait\n+            kw static\n+            kw extern\n+            kw mod\n+            kw enum\n+            kw struct\n+            kw union\n+            sn tmod (Test module)\n+            sn tfn (Test function)\n+            sn macro_rules\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn in_source_file_item_list() {\n+    check(\n+        r#\"\n+enum Enum { Variant }\n+struct MyStruct {}\n+#[macro_export]\n+macro_rules! foo {}\n+mod bar {}\n+const CONST: () = ();\n+\n+$0\"#,\n+        expect![[r##\"\n+            kw pub(crate)\n+            kw pub\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw use\n+            kw impl\n+            kw trait\n+            kw static\n+            kw extern\n+            kw mod\n+            kw enum\n+            kw struct\n+            kw union\n+            sn tmod (Test module)\n+            sn tfn (Test function)\n+            sn macro_rules\n+            md bar\n+            ma foo!(\u2026)          #[macro_export] macro_rules! foo\n+            ma foo!(\u2026)          #[macro_export] macro_rules! foo\n+        \"##]],\n+    )\n+}\n+\n+#[test]\n+fn in_qualified_path() {\n+    check(\n+        r#\"\n+enum Enum { Variant }\n+struct MyStruct {}\n+#[macro_export]\n+macro_rules! foo {}\n+mod bar {}\n+const CONST: () = ();\n+\n+crate::$0\"#,\n+        expect![[r##\"\n+            kw pub(crate)\n+            kw pub\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw use\n+            kw impl\n+            kw trait\n+            kw static\n+            kw extern\n+            kw mod\n+            kw enum\n+            kw struct\n+            kw union\n+            sn tmod (Test module)\n+            sn tfn (Test function)\n+            sn macro_rules\n+            md bar\n+            ma foo!(\u2026)          #[macro_export] macro_rules! foo\n+        \"##]],\n+    )\n+}\n+\n+#[test]\n+fn after_unsafe_token() {\n+    check(\n+        r#\"\n+enum Enum { Variant }\n+struct MyStruct {}\n+#[macro_export]\n+macro_rules! foo {}\n+mod bar {}\n+const CONST: () = ();\n+\n+unsafe $0\"#,\n+        expect![[r##\"\n+            kw fn\n+            kw trait\n+            kw impl\n+            sn tmod (Test module)\n+            sn tfn (Test function)\n+            sn macro_rules\n+            md bar\n+            ma foo!(\u2026)          #[macro_export] macro_rules! foo\n+            ma foo!(\u2026)          #[macro_export] macro_rules! foo\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn after_visibility() {\n+    check(\n+        r#\"\n+enum Enum { Variant }\n+struct MyStruct {}\n+#[macro_export]\n+macro_rules! foo {}\n+mod bar {}\n+const CONST: () = ();\n+\n+pub $0\"#,\n+        expect![[r##\"\n+            kw pub(crate)\n+            kw pub\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw use\n+            kw impl\n+            kw trait\n+            kw static\n+            kw extern\n+            kw mod\n+            kw enum\n+            kw struct\n+            kw union\n+            sn tmod (Test module)\n+            sn tfn (Test function)\n+            sn macro_rules\n+            md bar\n+            ma foo!(\u2026)          #[macro_export] macro_rules! foo\n+            ma foo!(\u2026)          #[macro_export] macro_rules! foo\n+        \"##]],\n+    );\n+}"}]}