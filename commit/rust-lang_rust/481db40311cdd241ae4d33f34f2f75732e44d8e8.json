{"sha": "481db40311cdd241ae4d33f34f2f75732e44d8e8", "node_id": "C_kwDOAAsO6NoAKDQ4MWRiNDAzMTFjZGQyNDFhZTRkMzNmMzRmMmY3NTczMmU0NGQ4ZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-12T12:48:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-12T12:48:30Z"}, "message": "Auto merge of #95562 - lcnr:attr-no-encode, r=davidtwco\n\ndon't encode only locally used attrs\n\nPart of https://github.com/rust-lang/compiler-team/issues/505.\n\nWe now filter builtin attributes before encoding them in the crate metadata in case they should only be used in the local crate. To prevent accidental misuse `get_attrs` now requires the caller to state which attribute they are interested in. For places where that isn't trivially possible, I've added a method `fn get_attrs_unchecked` which I intend to remove in a followup PR.\n\nAfter this pull request landed, we can then slowly move all attributes to only be used in the local crate while being certain that we don't accidentally try to access them from extern crates.\n\ncc https://github.com/rust-lang/rust/pull/94963#issuecomment-1082924289", "tree": {"sha": "6c5d0ea5404f19cd916403f46a6ae2105fddd096", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c5d0ea5404f19cd916403f46a6ae2105fddd096"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/481db40311cdd241ae4d33f34f2f75732e44d8e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/481db40311cdd241ae4d33f34f2f75732e44d8e8", "html_url": "https://github.com/rust-lang/rust/commit/481db40311cdd241ae4d33f34f2f75732e44d8e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/481db40311cdd241ae4d33f34f2f75732e44d8e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18bd2dd5cda08b09ace6e37c1a0312e9b2bb4beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/18bd2dd5cda08b09ace6e37c1a0312e9b2bb4beb", "html_url": "https://github.com/rust-lang/rust/commit/18bd2dd5cda08b09ace6e37c1a0312e9b2bb4beb"}, {"sha": "ebf95836e3cfc8c442cc71239324d947aafa3eac", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf95836e3cfc8c442cc71239324d947aafa3eac", "html_url": "https://github.com/rust-lang/rust/commit/ebf95836e3cfc8c442cc71239324d947aafa3eac"}], "stats": {"total": 918, "additions": 453, "deletions": 465}, "files": [{"sha": "3d4bd222715c3950a54ca4a4f4bdef75ff22279b", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 141, "deletions": 138, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -868,177 +868,180 @@ impl IntType {\n /// structure layout, `packed` to remove padding, and `transparent` to delegate representation\n /// concerns to the only non-ZST field.\n pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n-    use ReprAttr::*;\n+    if attr.has_name(sym::repr) { parse_repr_attr(sess, attr) } else { Vec::new() }\n+}\n \n+pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n+    assert!(attr.has_name(sym::repr), \"expected `#[repr(..)]`, found: {:?}\", attr);\n+    use ReprAttr::*;\n     let mut acc = Vec::new();\n     let diagnostic = &sess.parse_sess.span_diagnostic;\n-    if attr.has_name(sym::repr) {\n-        if let Some(items) = attr.meta_item_list() {\n-            for item in items {\n-                let mut recognised = false;\n-                if item.is_word() {\n-                    let hint = match item.name_or_empty() {\n-                        sym::C => Some(ReprC),\n-                        sym::packed => Some(ReprPacked(1)),\n-                        sym::simd => Some(ReprSimd),\n-                        sym::transparent => Some(ReprTransparent),\n-                        sym::no_niche => Some(ReprNoNiche),\n-                        sym::align => {\n-                            let mut err = struct_span_err!(\n-                                diagnostic,\n-                                item.span(),\n-                                E0589,\n-                                \"invalid `repr(align)` attribute: `align` needs an argument\"\n-                            );\n-                            err.span_suggestion(\n-                                item.span(),\n-                                \"supply an argument here\",\n-                                \"align(...)\".to_string(),\n-                                Applicability::HasPlaceholders,\n-                            );\n-                            err.emit();\n-                            recognised = true;\n-                            None\n-                        }\n-                        name => int_type_of_word(name).map(ReprInt),\n-                    };\n \n-                    if let Some(h) = hint {\n+    if let Some(items) = attr.meta_item_list() {\n+        for item in items {\n+            let mut recognised = false;\n+            if item.is_word() {\n+                let hint = match item.name_or_empty() {\n+                    sym::C => Some(ReprC),\n+                    sym::packed => Some(ReprPacked(1)),\n+                    sym::simd => Some(ReprSimd),\n+                    sym::transparent => Some(ReprTransparent),\n+                    sym::no_niche => Some(ReprNoNiche),\n+                    sym::align => {\n+                        let mut err = struct_span_err!(\n+                            diagnostic,\n+                            item.span(),\n+                            E0589,\n+                            \"invalid `repr(align)` attribute: `align` needs an argument\"\n+                        );\n+                        err.span_suggestion(\n+                            item.span(),\n+                            \"supply an argument here\",\n+                            \"align(...)\".to_string(),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                        err.emit();\n                         recognised = true;\n-                        acc.push(h);\n+                        None\n                     }\n-                } else if let Some((name, value)) = item.name_value_literal() {\n-                    let mut literal_error = None;\n-                    if name == sym::align {\n-                        recognised = true;\n-                        match parse_alignment(&value.kind) {\n-                            Ok(literal) => acc.push(ReprAlign(literal)),\n-                            Err(message) => literal_error = Some(message),\n-                        };\n-                    } else if name == sym::packed {\n-                        recognised = true;\n-                        match parse_alignment(&value.kind) {\n-                            Ok(literal) => acc.push(ReprPacked(literal)),\n-                            Err(message) => literal_error = Some(message),\n-                        };\n-                    } else if matches!(name, sym::C | sym::simd | sym::transparent | sym::no_niche)\n-                        || int_type_of_word(name).is_some()\n-                    {\n-                        recognised = true;\n-                        struct_span_err!(\n+                    name => int_type_of_word(name).map(ReprInt),\n+                };\n+\n+                if let Some(h) = hint {\n+                    recognised = true;\n+                    acc.push(h);\n+                }\n+            } else if let Some((name, value)) = item.name_value_literal() {\n+                let mut literal_error = None;\n+                if name == sym::align {\n+                    recognised = true;\n+                    match parse_alignment(&value.kind) {\n+                        Ok(literal) => acc.push(ReprAlign(literal)),\n+                        Err(message) => literal_error = Some(message),\n+                    };\n+                } else if name == sym::packed {\n+                    recognised = true;\n+                    match parse_alignment(&value.kind) {\n+                        Ok(literal) => acc.push(ReprPacked(literal)),\n+                        Err(message) => literal_error = Some(message),\n+                    };\n+                } else if matches!(name, sym::C | sym::simd | sym::transparent | sym::no_niche)\n+                    || int_type_of_word(name).is_some()\n+                {\n+                    recognised = true;\n+                    struct_span_err!(\n                                 diagnostic,\n                                 item.span(),\n                                 E0552,\n                                 \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n                                 name.to_ident_string(),\n                             ).emit();\n-                    }\n-                    if let Some(literal_error) = literal_error {\n-                        struct_span_err!(\n+                }\n+                if let Some(literal_error) = literal_error {\n+                    struct_span_err!(\n+                        diagnostic,\n+                        item.span(),\n+                        E0589,\n+                        \"invalid `repr({})` attribute: {}\",\n+                        name.to_ident_string(),\n+                        literal_error\n+                    )\n+                    .emit();\n+                }\n+            } else if let Some(meta_item) = item.meta_item() {\n+                if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n+                    if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n+                        let name = meta_item.name_or_empty().to_ident_string();\n+                        recognised = true;\n+                        let mut err = struct_span_err!(\n                             diagnostic,\n                             item.span(),\n-                            E0589,\n-                            \"invalid `repr({})` attribute: {}\",\n-                            name.to_ident_string(),\n-                            literal_error\n-                        )\n-                        .emit();\n-                    }\n-                } else if let Some(meta_item) = item.meta_item() {\n-                    if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n-                        if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n-                            let name = meta_item.name_or_empty().to_ident_string();\n-                            recognised = true;\n-                            let mut err = struct_span_err!(\n-                                diagnostic,\n-                                item.span(),\n-                                E0693,\n-                                \"incorrect `repr({})` attribute format\",\n-                                name,\n-                            );\n-                            match value.kind {\n-                                ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                    err.span_suggestion(\n-                                        item.span(),\n-                                        \"use parentheses instead\",\n-                                        format!(\"{}({})\", name, int),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                                ast::LitKind::Str(s, _) => {\n-                                    err.span_suggestion(\n-                                        item.span(),\n-                                        \"use parentheses instead\",\n-                                        format!(\"{}({})\", name, s),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                                _ => {}\n+                            E0693,\n+                            \"incorrect `repr({})` attribute format\",\n+                            name,\n+                        );\n+                        match value.kind {\n+                            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                                err.span_suggestion(\n+                                    item.span(),\n+                                    \"use parentheses instead\",\n+                                    format!(\"{}({})\", name, int),\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n-                            err.emit();\n-                        } else {\n-                            if matches!(\n-                                meta_item.name_or_empty(),\n-                                sym::C | sym::simd | sym::transparent | sym::no_niche\n-                            ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                            {\n-                                recognised = true;\n-                                struct_span_err!(\n-                                    diagnostic,\n-                                    meta_item.span,\n-                                    E0552,\n-                                    \"invalid representation hint: `{}` does not take a value\",\n-                                    meta_item.name_or_empty().to_ident_string(),\n-                                )\n-                                .emit();\n+                            ast::LitKind::Str(s, _) => {\n+                                err.span_suggestion(\n+                                    item.span(),\n+                                    \"use parentheses instead\",\n+                                    format!(\"{}({})\", name, s),\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n+                            _ => {}\n                         }\n-                    } else if let MetaItemKind::List(_) = meta_item.kind {\n-                        if meta_item.has_name(sym::align) {\n+                        err.emit();\n+                    } else {\n+                        if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent | sym::no_niche\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n                             recognised = true;\n                             struct_span_err!(\n                                 diagnostic,\n                                 meta_item.span,\n-                                E0693,\n-                                \"incorrect `repr(align)` attribute format: \\\n-                                 `align` takes exactly one argument in parentheses\"\n+                                E0552,\n+                                \"invalid representation hint: `{}` does not take a value\",\n+                                meta_item.name_or_empty().to_ident_string(),\n                             )\n                             .emit();\n-                        } else if meta_item.has_name(sym::packed) {\n-                            recognised = true;\n-                            struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"incorrect `repr(packed)` attribute format: \\\n+                        }\n+                    }\n+                } else if let MetaItemKind::List(_) = meta_item.kind {\n+                    if meta_item.has_name(sym::align) {\n+                        recognised = true;\n+                        struct_span_err!(\n+                            diagnostic,\n+                            meta_item.span,\n+                            E0693,\n+                            \"incorrect `repr(align)` attribute format: \\\n+                                 `align` takes exactly one argument in parentheses\"\n+                        )\n+                        .emit();\n+                    } else if meta_item.has_name(sym::packed) {\n+                        recognised = true;\n+                        struct_span_err!(\n+                            diagnostic,\n+                            meta_item.span,\n+                            E0552,\n+                            \"incorrect `repr(packed)` attribute format: \\\n                                  `packed` takes exactly one parenthesized argument, \\\n                                  or no parentheses at all\"\n-                            )\n-                            .emit();\n-                        } else if matches!(\n-                            meta_item.name_or_empty(),\n-                            sym::C | sym::simd | sym::transparent | sym::no_niche\n-                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                        {\n-                            recognised = true;\n-                            struct_span_err!(\n+                        )\n+                        .emit();\n+                    } else if matches!(\n+                        meta_item.name_or_empty(),\n+                        sym::C | sym::simd | sym::transparent | sym::no_niche\n+                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                    {\n+                        recognised = true;\n+                        struct_span_err!(\n                                 diagnostic,\n                                 meta_item.span,\n                                 E0552,\n                                 \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n                                 meta_item.name_or_empty().to_ident_string(),\n                             ).emit();\n-                        }\n                     }\n                 }\n-                if !recognised {\n-                    // Not a word we recognize. This will be caught and reported by\n-                    // the `check_mod_attrs` pass, but this pass doesn't always run\n-                    // (e.g. if we only pretty-print the source), so we have to gate\n-                    // the `delay_span_bug` call as follows:\n-                    if sess.opts.pretty.map_or(true, |pp| pp.needs_analysis()) {\n-                        diagnostic.delay_span_bug(item.span(), \"unrecognized representation hint\");\n-                    }\n+            }\n+            if !recognised {\n+                // Not a word we recognize. This will be caught and reported by\n+                // the `check_mod_attrs` pass, but this pass doesn't always run\n+                // (e.g. if we only pretty-print the source), so we have to gate\n+                // the `delay_span_bug` call as follows:\n+                if sess.opts.pretty.map_or(true, |pp| pp.needs_analysis()) {\n+                    diagnostic.delay_span_bug(item.span(), \"unrecognized representation hint\");\n                 }\n             }\n         }"}, {"sha": "9394d60134f8c0e9ba0b942b0b3abbc40da657fd", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -6,6 +6,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::OptLevel;\n+use rustc_span::symbol::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::{FramePointer, SanitizerSet, StackProbeType, StackProtector};\n use smallvec::SmallVec;\n@@ -329,9 +330,7 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n     ) {\n         let span = cx\n             .tcx\n-            .get_attrs(instance.def_id())\n-            .iter()\n-            .find(|a| a.has_name(rustc_span::sym::target_feature))\n+            .get_attr(instance.def_id(), sym::target_feature)\n             .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n         let msg = format!(\n             \"the target features {} must all be either enabled or disabled together\","}, {"sha": "8d3bbefb371865812b4397a31e96c0b6fbf88e32", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -312,11 +312,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n \n             Status::Unstable(gate) if self.tcx.features().enabled(gate) => {\n                 let unstable_in_stable = self.ccx.is_const_stable_const_fn()\n-                    && !super::rustc_allow_const_fn_unstable(\n-                        self.tcx,\n-                        self.def_id().to_def_id(),\n-                        gate,\n-                    );\n+                    && !super::rustc_allow_const_fn_unstable(self.tcx, self.def_id(), gate);\n                 if unstable_in_stable {\n                     emit_unstable_in_stable_error(self.ccx, span, gate);\n                 }\n@@ -713,7 +709,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n         match &terminator.kind {\n             TerminatorKind::Call { func, args, fn_span, from_hir_call, .. } => {\n                 let ConstCx { tcx, body, param_env, .. } = *self.ccx;\n-                let caller = self.def_id().to_def_id();\n+                let caller = self.def_id();\n \n                 let fn_ty = func.ty(body, tcx);\n \n@@ -797,7 +793,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             // trait.\n                             let callee_trait = tcx.trait_of_item(callee);\n                             if callee_trait.is_some()\n-                                && tcx.has_attr(caller, sym::default_method_body_is_const)\n+                                && tcx.has_attr(caller.to_def_id(), sym::default_method_body_is_const)\n                                 && callee_trait == tcx.trait_of_item(caller)\n                                 // Can only call methods when it's `<Self as TheTrait>::f`.\n                                 && tcx.types.self_param == substs.type_at(0)"}, {"sha": "23e2afae79183bd1d15b0e9f84ff09f1510d6ded", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -66,8 +66,12 @@ impl<'mir, 'tcx> ConstCx<'mir, 'tcx> {\n     }\n }\n \n-pub fn rustc_allow_const_fn_unstable(tcx: TyCtxt<'_>, def_id: DefId, feature_gate: Symbol) -> bool {\n-    let attrs = tcx.get_attrs(def_id);\n+pub fn rustc_allow_const_fn_unstable(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+    feature_gate: Symbol,\n+) -> bool {\n+    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n     attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n }\n "}, {"sha": "122471b208d8001aa12ea92f02dd5502ca3e5099", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1,5 +1,6 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n+use hir::def_id::LocalDefId;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -95,7 +96,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n /// A function call where the callee is not marked as `const`.\n #[derive(Debug, Clone, Copy)]\n pub struct FnCallNonConst<'tcx> {\n-    pub caller: DefId,\n+    pub caller: LocalDefId,\n     pub callee: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub span: Span,\n@@ -117,13 +118,8 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n             match self_ty.kind() {\n                 Param(param_ty) => {\n                     debug!(?param_ty);\n-                    if let Some(generics) = caller\n-                        .as_local()\n-                        .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n-                        .map(|id| tcx.hir().get(id))\n-                        .as_ref()\n-                        .and_then(|node| node.generics())\n-                    {\n+                    let caller_hir_id = tcx.hir().local_def_id_to_hir_id(caller);\n+                    if let Some(generics) = tcx.hir().get(caller_hir_id).generics() {\n                         let constraint = with_no_trimmed_paths!(format!(\n                             \"~const {}\",\n                             trait_ref.print_only_trait_path()"}, {"sha": "097493e8985fb25ea4c8ec5339b57a940db871f8", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -147,6 +147,16 @@ pub enum AttributeDuplicates {\n     FutureWarnPreceding,\n }\n \n+/// A conveniece macro to deal with `$($expr)?`.\n+macro_rules! or_default {\n+    ($default:expr,) => {\n+        $default\n+    };\n+    ($default:expr, $next:expr) => {\n+        $next\n+    };\n+}\n+\n /// A convenience macro for constructing attribute templates.\n /// E.g., `template!(Word, List: \"description\")` means that the attribute\n /// supports forms `#[attr]` and `#[attr(description)]`.\n@@ -168,9 +178,10 @@ macro_rules! template {\n }\n \n macro_rules! ungated {\n-    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(,)?) => {\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)? $(,)?) => {\n         BuiltinAttribute {\n             name: sym::$attr,\n+            only_local: or_default!(false, $($only_local)?),\n             type_: $typ,\n             template: $tpl,\n             gate: Ungated,\n@@ -180,18 +191,20 @@ macro_rules! ungated {\n }\n \n macro_rules! gated {\n-    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr, $gate:ident, $msg:expr $(,)?) => {\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)?, $gate:ident, $msg:expr $(,)?) => {\n         BuiltinAttribute {\n             name: sym::$attr,\n+            only_local: or_default!(false, $($only_local)?),\n             type_: $typ,\n             template: $tpl,\n             duplicates: $duplicates,\n             gate: Gated(Stability::Unstable, sym::$gate, $msg, cfg_fn!($gate)),\n         }\n     };\n-    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr, $msg:expr $(,)?) => {\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)?, $msg:expr $(,)?) => {\n         BuiltinAttribute {\n             name: sym::$attr,\n+            only_local: or_default!(false, $($only_local)?),\n             type_: $typ,\n             template: $tpl,\n             duplicates: $duplicates,\n@@ -201,12 +214,13 @@ macro_rules! gated {\n }\n \n macro_rules! rustc_attr {\n-    (TEST, $attr:ident, $typ:expr, $tpl:expr, $duplicate:expr $(,)?) => {\n+    (TEST, $attr:ident, $typ:expr, $tpl:expr, $duplicate:expr $(, @only_local: $only_local:expr)? $(,)?) => {\n         rustc_attr!(\n             $attr,\n             $typ,\n             $tpl,\n             $duplicate,\n+            $(@only_local: $only_local,)?\n             concat!(\n                 \"the `#[\",\n                 stringify!($attr),\n@@ -215,9 +229,10 @@ macro_rules! rustc_attr {\n             ),\n         )\n     };\n-    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr, $msg:expr $(,)?) => {\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)?, $msg:expr $(,)?) => {\n         BuiltinAttribute {\n             name: sym::$attr,\n+            only_local: or_default!(false, $($only_local)?),\n             type_: $typ,\n             template: $tpl,\n             duplicates: $duplicates,\n@@ -237,6 +252,10 @@ const INTERNAL_UNSTABLE: &str = \"this is an internal attribute that will never b\n \n pub struct BuiltinAttribute {\n     pub name: Symbol,\n+    /// Whether this attribute is only used in the local crate.\n+    ///\n+    /// If so, it is not encoded in the crate metadata.\n+    pub only_local: bool,\n     pub type_: AttributeType,\n     pub template: AttributeTemplate,\n     pub duplicates: AttributeDuplicates,\n@@ -295,7 +314,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(must_use, Normal, template!(Word, NameValueStr: \"reason\"), FutureWarnFollowing),\n     gated!(\n         must_not_suspend, Normal, template!(Word, NameValueStr: \"reason\"), WarnFollowing,\n-        must_not_suspend, experimental!(must_not_suspend)\n+        experimental!(must_not_suspend)\n     ),\n     ungated!(\n         deprecated, Normal,\n@@ -324,8 +343,8 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk),\n     ungated!(export_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(link_section, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n-    ungated!(no_mangle, Normal, template!(Word), WarnFollowing),\n-    ungated!(used, Normal, template!(Word, List: \"compiler|linker\"), WarnFollowing),\n+    ungated!(no_mangle, Normal, template!(Word), WarnFollowing, @only_local: true),\n+    ungated!(used, Normal, template!(Word, List: \"compiler|linker\"), WarnFollowing, @only_local: true),\n \n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n@@ -358,8 +377,8 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(panic_handler, Normal, template!(Word), WarnFollowing), // RFC 2070\n \n     // Code generation:\n-    ungated!(inline, Normal, template!(Word, List: \"always|never\"), FutureWarnFollowing),\n-    ungated!(cold, Normal, template!(Word), WarnFollowing),\n+    ungated!(inline, Normal, template!(Word, List: \"always|never\"), FutureWarnFollowing, @only_local: true),\n+    ungated!(cold, Normal, template!(Word), WarnFollowing, @only_local: true),\n     ungated!(no_builtins, CrateLevel, template!(Word), WarnFollowing),\n     ungated!(target_feature, Normal, template!(List: r#\"enable = \"name\"\"#), DuplicatesOk),\n     ungated!(track_caller, Normal, template!(Word), WarnFollowing),\n@@ -385,7 +404,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n \n     // Linking:\n-    gated!(naked, Normal, template!(Word), WarnFollowing, naked_functions, experimental!(naked)),\n+    gated!(naked, Normal, template!(Word), WarnFollowing, @only_local: true, naked_functions, experimental!(naked)),\n     gated!(\n         link_ordinal, Normal, template!(List: \"ordinal\"), ErrorPreceding, raw_dylib,\n         experimental!(link_ordinal)\n@@ -394,6 +413,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Plugins:\n     BuiltinAttribute {\n         name: sym::plugin,\n+        only_local: false,\n         type_: CrateLevel,\n         template: template!(List: \"name\"),\n         duplicates: DuplicatesOk,\n@@ -475,7 +495,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     // DuplicatesOk since it has its own validation\n     ungated!(\n-        stable, Normal, template!(List: r#\"feature = \"name\", since = \"version\"\"#), DuplicatesOk\n+        stable, Normal, template!(List: r#\"feature = \"name\", since = \"version\"\"#), DuplicatesOk,\n     ),\n     ungated!(\n         unstable, Normal,\n@@ -546,11 +566,11 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     gated!(\n-        linkage, Normal, template!(NameValueStr: \"external|internal|...\"), ErrorPreceding,\n+        linkage, Normal, template!(NameValueStr: \"external|internal|...\"), ErrorPreceding, @only_local: true,\n         \"the `linkage` attribute is experimental and not portable across platforms\",\n     ),\n     rustc_attr!(\n-        rustc_std_internal_symbol, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE\n+        rustc_std_internal_symbol, Normal, template!(Word), WarnFollowing, @only_local: true, INTERNAL_UNSTABLE\n     ),\n \n     // ==========================================================================\n@@ -633,7 +653,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes, Misc:\n     // ==========================================================================\n     gated!(\n-        lang, Normal, template!(NameValueStr: \"name\"), DuplicatesOk, lang_items,\n+        lang, Normal, template!(NameValueStr: \"name\"), DuplicatesOk, @only_local: true, lang_items,\n         \"language items are subject to change\",\n     ),\n     rustc_attr!(\n@@ -642,11 +662,11 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"#[rustc_pass_by_value] is used to mark types that must be passed by value instead of reference.\"\n     ),\n     rustc_attr!(\n-        rustc_coherence_is_core, AttributeType::CrateLevel, template!(Word), ErrorFollowing,\n+        rustc_coherence_is_core, AttributeType::CrateLevel, template!(Word), ErrorFollowing, @only_local: true,\n         \"#![rustc_coherence_is_core] allows inherent methods on builtin types, only intended to be used in `core`.\"\n     ),\n     rustc_attr!(\n-        rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing,\n+        rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing, @only_local: true,\n         \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\"\n     ),\n     rustc_attr!(\n@@ -656,6 +676,8 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     BuiltinAttribute {\n         name: sym::rustc_diagnostic_item,\n+        // FIXME: This can be `true` once we always use `tcx.is_diagnostic_item`.\n+        only_local: false,\n         type_: Normal,\n         template: template!(NameValueStr: \"name\"),\n         duplicates: ErrorFollowing,\n@@ -676,7 +698,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"unboxed_closures are still evolving\",\n     ),\n     rustc_attr!(\n-        rustc_inherit_overflow_checks, Normal, template!(Word), WarnFollowing,\n+        rustc_inherit_overflow_checks, Normal, template!(Word), WarnFollowing, @only_local: true,\n         \"the `#[rustc_inherit_overflow_checks]` attribute is just used to control \\\n         overflow checking behavior of several libcore functions that are inlined \\\n         across crates and will never be stable\",\n@@ -778,6 +800,10 @@ pub fn is_builtin_attr_name(name: Symbol) -> bool {\n     BUILTIN_ATTRIBUTE_MAP.get(&name).is_some()\n }\n \n+pub fn is_builtin_only_local(name: Symbol) -> bool {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| attr.only_local)\n+}\n+\n pub static BUILTIN_ATTRIBUTE_MAP: SyncLazy<FxHashMap<Symbol, &BuiltinAttribute>> =\n     SyncLazy::new(|| {\n         let mut map = FxHashMap::default();"}, {"sha": "26e0538b0eb4e8e4618265aa30b81d10e38e2a40", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -149,7 +149,8 @@ pub use accepted::ACCEPTED_FEATURES;\n pub use active::{Features, ACTIVE_FEATURES, INCOMPATIBLE_FEATURES};\n pub use builtin_attrs::AttributeDuplicates;\n pub use builtin_attrs::{\n-    deprecated_attributes, find_gated_cfg, is_builtin_attr_name, AttributeGate, AttributeTemplate,\n-    AttributeType, BuiltinAttribute, GatedCfg, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n+    deprecated_attributes, find_gated_cfg, is_builtin_attr_name, is_builtin_only_local,\n+    AttributeGate, AttributeTemplate, AttributeType, BuiltinAttribute, GatedCfg,\n+    BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n };\n pub use removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};"}, {"sha": "424164d8760c4e8176a351416ca8ec105f1ffca3", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -183,10 +183,7 @@ pub struct DirtyCleanVisitor<'tcx> {\n impl<'tcx> DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: LocalDefId, attr: &Attribute) -> Option<Assertion> {\n-        if !attr.has_name(sym::rustc_clean) {\n-            // skip: not rustc_clean/dirty\n-            return None;\n-        }\n+        assert!(attr.has_name(sym::rustc_clean));\n         if !check_config(self.tcx, attr) {\n             // skip: not the correct `cfg=`\n             return None;\n@@ -384,7 +381,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     fn check_item(&mut self, item_id: LocalDefId) {\n         let item_span = self.tcx.def_span(item_id.to_def_id());\n         let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n-        for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n+        for attr in self.tcx.get_attrs(item_id.to_def_id(), sym::rustc_clean) {\n             let Some(assertion) = self.assertion_maybe(item_id, attr) else {\n                 continue;\n             };"}, {"sha": "136f0443fa0a36e4285366095e2c788af36a800d", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -258,10 +258,7 @@ impl<'tcx> Queries<'tcx> {\n     /// an error.\n     fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n         let Some((def_id, _)) = tcx.entry_fn(()) else { return };\n-\n-        let attrs = &*tcx.get_attrs(def_id);\n-        let attrs = attrs.iter().filter(|attr| attr.has_name(sym::rustc_error));\n-        for attr in attrs {\n+        for attr in tcx.get_attrs(def_id, sym::rustc_error) {\n             match attr.meta_item_list() {\n                 // Check if there is a `#[rustc_error(delay_span_bug_from_inside_query)]`.\n                 Some(list)"}, {"sha": "a87083a082b3f1da7fd1f53f98d070010e82afd9", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -551,7 +551,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let attrs = cx.tcx.get_attrs(def_id.to_def_id());\n+        let attrs = cx.tcx.hir().attrs(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n         let has_doc = attrs.iter().any(has_doc);\n         if !has_doc {\n             cx.struct_span_lint(\n@@ -2738,11 +2738,7 @@ impl ClashingExternDeclarations {\n                 // bottleneck, this does just fine.\n                 (\n                     overridden_link_name,\n-                    tcx.get_attrs(fi.def_id.to_def_id())\n-                        .iter()\n-                        .find(|at| at.has_name(sym::link_name))\n-                        .unwrap()\n-                        .span,\n+                    tcx.get_attr(fi.def_id.to_def_id(), sym::link_name).unwrap().span,\n                 )\n             })\n         {"}, {"sha": "62d427fcd0238bcb3b3cbe6c5bfad67ea39f80d7", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -668,7 +668,7 @@ enum FfiResult<'tcx> {\n }\n \n crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n-    tcx.get_attrs(def.did()).iter().any(|a| a.has_name(sym::rustc_nonnull_optimization_guaranteed))\n+    tcx.has_attr(def.did(), sym::rustc_nonnull_optimization_guaranteed)\n }\n \n /// `repr(transparent)` structs can have a single non-ZST field, this function returns that"}, {"sha": "8cae95f46dc377acb809c1bfc63eced274990b57", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -303,26 +303,25 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_pre_path: &str,\n             descr_post_path: &str,\n         ) -> bool {\n-            for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if attr.has_name(sym::must_use) {\n-                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n-                        let msg = format!(\n-                            \"unused {}`{}`{} that must be used\",\n-                            descr_pre_path,\n-                            cx.tcx.def_path_str(def_id),\n-                            descr_post_path\n-                        );\n-                        let mut err = lint.build(&msg);\n-                        // check for #[must_use = \"...\"]\n-                        if let Some(note) = attr.value_str() {\n-                            err.note(note.as_str());\n-                        }\n-                        err.emit();\n-                    });\n-                    return true;\n-                }\n+            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n+                cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n+                    let msg = format!(\n+                        \"unused {}`{}`{} that must be used\",\n+                        descr_pre_path,\n+                        cx.tcx.def_path_str(def_id),\n+                        descr_post_path\n+                    );\n+                    let mut err = lint.build(&msg);\n+                    // check for #[must_use = \"...\"]\n+                    if let Some(note) = attr.value_str() {\n+                        err.note(note.as_str());\n+                    }\n+                    err.emit();\n+                });\n+                true\n+            } else {\n+                false\n             }\n-            false\n         }\n     }\n }"}, {"sha": "1de7dae3c25cba332737f3298c499dc4ec78f281", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -985,11 +985,17 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_attrs(&mut self, def_id: DefId) {\n-        let attrs = self.tcx.get_attrs(def_id);\n-        record!(self.tables.attributes[def_id] <- attrs);\n-        if attrs.iter().any(|attr| attr.may_have_doc_links()) {\n-            self.tables.may_have_doc_links.set(def_id.index, ());\n+    fn encode_attrs(&mut self, def_id: LocalDefId) {\n+        let mut attrs = self\n+            .tcx\n+            .hir()\n+            .attrs(self.tcx.hir().local_def_id_to_hir_id(def_id))\n+            .iter()\n+            .filter(|attr| !rustc_feature::is_builtin_only_local(attr.name_or_empty()));\n+\n+        record!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n+        if attrs.any(|attr| attr.may_have_doc_links()) {\n+            self.tables.may_have_doc_links.set(def_id.local_def_index, ());\n         }\n     }\n \n@@ -1005,7 +1011,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let Some(def_kind) = def_kind else { continue };\n             self.tables.opt_def_kind.set(def_id.index, def_kind);\n             record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n-            self.encode_attrs(def_id);\n+            self.encode_attrs(local_id);\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if def_kind.has_codegen_attrs() {\n                 record!(self.tables.codegen_fn_attrs[def_id] <- self.tcx.codegen_fn_attrs(def_id));\n@@ -1670,7 +1676,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n-            self.encode_attrs(LOCAL_CRATE.as_def_id());\n+            self.encode_attrs(LOCAL_CRATE.as_def_id().expect_local());\n             record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n             if let Some(stability) = stability {\n                 record!(self.tables.lookup_stability[LOCAL_CRATE.as_def_id()] <- stability);\n@@ -1711,7 +1717,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let def_id = id.to_def_id();\n                 self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n-                self.encode_attrs(def_id);\n+                self.encode_attrs(id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n                 record!(self.tables.def_span[def_id] <- span);"}, {"sha": "6d7ec247d0452356671d17e9cbc1c500985abe63", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1072,6 +1072,9 @@ rustc_queries! {\n         desc { |tcx| \"checking whether `{}` is `doc(hidden)`\", tcx.def_path_str(def_id) }\n     }\n \n+    /// Returns the attributes on the item at `def_id`.\n+    ///\n+    /// Do not use this directly, use `tcx.get_attrs` instead.\n     query item_attrs(def_id: DefId) -> &'tcx [ast::Attribute] {\n         desc { |tcx| \"collecting attributes of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern"}, {"sha": "bf7cb610a9097fa3186ca16bd4c40162800ec2c9", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -230,8 +230,7 @@ impl AdtDefData {\n             flags |= AdtFlags::HAS_CTOR;\n         }\n \n-        let attrs = tcx.get_attrs(did);\n-        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n+        if tcx.has_attr(did, sym::fundamental) {\n             flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {"}, {"sha": "36f1045efef013fc541432da77d8fcc49c8c9939", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1148,9 +1148,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `rustc_layout_scalar_valid_range` attribute.\n     // FIXME(eddyb) this is an awkward spot for this method, maybe move it?\n     pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n-        let attrs = self.get_attrs(def_id);\n         let get = |name| {\n-            let Some(attr) = attrs.iter().find(|a| a.has_name(name)) else {\n+            let Some(attr) = self.get_attr(def_id, name) else {\n                 return Bound::Unbounded;\n             };\n             debug!(\"layout_scalar_valid_range: attr={:?}\", attr);"}, {"sha": "a0fe632f11a07f21b3cf37f5649226c318d399bf", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -568,11 +568,8 @@ impl<T> Trait<T> for X {\n                 }\n             }\n             TargetFeatureCast(def_id) => {\n-                let attrs = self.get_attrs(*def_id);\n-                let target_spans = attrs\n-                    .iter()\n-                    .filter(|attr| attr.has_name(sym::target_feature))\n-                    .map(|attr| attr.span);\n+                let target_spans =\n+                    self.get_attrs(*def_id, sym::target_feature).map(|attr| attr.span);\n                 diag.note(\n                     \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n                 );"}, {"sha": "2180078133301dcf671973172ede6bb826291799", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n use rustc_middle::ty::normalize_erasing_regions::NormalizationError;\n+use rustc_span::Symbol;\n \n use std::fmt;\n \n@@ -185,8 +186,8 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn attrs(&self, tcx: TyCtxt<'tcx>) -> ty::Attributes<'tcx> {\n-        tcx.get_attrs(self.def_id())\n+    pub fn get_attrs(&self, tcx: TyCtxt<'tcx>, attr: Symbol) -> ty::Attributes<'tcx> {\n+        tcx.get_attrs(self.def_id(), attr)\n     }\n \n     /// Returns `true` if the LLVM version of this instance is unconditionally"}, {"sha": "0e30998388d31f5f2a0e2e818a9e9c4e49ef4ed9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -14,12 +14,6 @@ pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n-pub use adt::*;\n-pub use assoc::*;\n-pub use generics::*;\n-use rustc_data_structures::fingerprint::Fingerprint;\n-pub use vtable::*;\n-\n use crate::metadata::ModChild;\n use crate::middle::privacy::AccessLevels;\n use crate::mir::{Body, GeneratorLayout};\n@@ -28,8 +22,12 @@ use crate::ty;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::Discr;\n+pub use adt::*;\n+pub use assoc::*;\n+pub use generics::*;\n use rustc_ast as ast;\n use rustc_attr as attr;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -44,6 +42,7 @@ use rustc_session::cstore::CrateStoreDyn;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Align;\n+pub use vtable::*;\n \n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -1818,8 +1817,8 @@ impl ReprOptions {\n             field_shuffle_seed ^= user_seed;\n         }\n \n-        for attr in tcx.get_attrs(did).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n+        for attr in tcx.get_attrs(did, sym::repr) {\n+            for r in attr::parse_repr_attr(&tcx.sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n@@ -1941,8 +1940,7 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-pub type Attributes<'tcx> = &'tcx [ast::Attribute];\n-\n+pub type Attributes<'tcx> = impl Iterator<Item = &'tcx ast::Attribute>;\n #[derive(Debug, PartialEq, Eq)]\n pub enum ImplOverlapKind {\n     /// These impls are always allowed to overlap.\n@@ -2186,18 +2184,38 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Gets the attributes of a definition.\n-    pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n+    // FIXME(@lcnr): Remove this function.\n+    pub fn get_attrs_unchecked(self, did: DefId) -> &'tcx [ast::Attribute] {\n         if let Some(did) = did.as_local() {\n             self.hir().attrs(self.hir().local_def_id_to_hir_id(did))\n         } else {\n             self.item_attrs(did)\n         }\n     }\n \n+    /// Gets all attributes with the given name.\n+    pub fn get_attrs(self, did: DefId, attr: Symbol) -> ty::Attributes<'tcx> {\n+        let filter_fn = move |a: &&ast::Attribute| a.has_name(attr);\n+        if let Some(did) = did.as_local() {\n+            self.hir().attrs(self.hir().local_def_id_to_hir_id(did)).iter().filter(filter_fn)\n+        } else if cfg!(debug_assertions) && rustc_feature::is_builtin_only_local(attr) {\n+            bug!(\"tried to access the `only_local` attribute `{}` from an extern crate\", attr);\n+        } else {\n+            self.item_attrs(did).iter().filter(filter_fn)\n+        }\n+    }\n+\n+    pub fn get_attr(self, did: DefId, attr: Symbol) -> Option<&'tcx ast::Attribute> {\n+        self.get_attrs(did, attr).next()\n+    }\n+\n     /// Determines whether an item is annotated with an attribute.\n     pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n-        self.sess.contains_name(&self.get_attrs(did), attr)\n+        if cfg!(debug_assertions) && !did.is_local() && rustc_feature::is_builtin_only_local(attr) {\n+            bug!(\"tried to access the `only_local` attribute `{}` from an extern crate\", attr);\n+        } else {\n+            self.get_attrs(did, attr).next().is_some()\n+        }\n     }\n \n     /// Returns `true` if this is an `auto trait`."}, {"sha": "b5f8726cdc5b1ba62a4bee70590a0f5db43bc3f2", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1163,9 +1163,8 @@ pub fn normalize_opaque_types<'tcx>(\n \n /// Determines whether an item is annotated with `doc(hidden)`.\n pub fn is_doc_hidden(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    tcx.get_attrs(def_id)\n-        .iter()\n-        .filter_map(|attr| if attr.has_name(sym::doc) { attr.meta_item_list() } else { None })\n+    tcx.get_attrs(def_id, sym::doc)\n+        .filter_map(|attr| attr.meta_item_list())\n         .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n }\n "}, {"sha": "c63c511e09cb42520791349a8b82ac6589970b13", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -679,7 +679,6 @@ where\n     } else {\n         None\n     };\n-    debug!(\"fn_id {:?} has attrs {:?}\", fn_def, tcx.get_attrs(fn_def.did.to_def_id()));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;"}, {"sha": "50efb4c1dc42a4a9750bc3bccc468530cb3c1f70", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -333,14 +333,11 @@ struct RustcMirAttrs {\n \n impl RustcMirAttrs {\n     fn parse(tcx: TyCtxt<'_>, def_id: DefId) -> Result<Self, ()> {\n-        let attrs = tcx.get_attrs(def_id);\n-\n         let mut result = Ok(());\n         let mut ret = RustcMirAttrs::default();\n \n-        let rustc_mir_attrs = attrs\n-            .iter()\n-            .filter(|attr| attr.has_name(sym::rustc_mir))\n+        let rustc_mir_attrs = tcx\n+            .get_attrs(def_id, sym::rustc_mir)\n             .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n \n         for attr in rustc_mir_attrs {"}, {"sha": "c1124a533bf2ba277c9d90689756e2cbb9243f2c", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -14,9 +14,9 @@ extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n \n-use rustc_ast::{self as ast, MetaItem};\n-use rustc_middle::ty;\n-use rustc_session::Session;\n+use rustc_ast::MetaItem;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n pub use self::drop_flag_effects::{\n@@ -49,19 +49,13 @@ pub struct MoveDataParamEnv<'tcx> {\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub fn has_rustc_mir_with(\n-    _sess: &Session,\n-    attrs: &[ast::Attribute],\n-    name: Symbol,\n-) -> Option<MetaItem> {\n-    for attr in attrs {\n-        if attr.has_name(sym::rustc_mir) {\n-            let items = attr.meta_item_list();\n-            for item in items.iter().flat_map(|l| l.iter()) {\n-                match item.meta_item() {\n-                    Some(mi) if mi.has_name(name) => return Some(mi.clone()),\n-                    _ => continue,\n-                }\n+pub fn has_rustc_mir_with(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol) -> Option<MetaItem> {\n+    for attr in tcx.get_attrs(def_id, sym::rustc_mir) {\n+        let items = attr.meta_item_list();\n+        for item in items.iter().flat_map(|l| l.iter()) {\n+            match item.meta_item() {\n+                Some(mi) if mi.has_name(name) => return Some(mi.clone()),\n+                _ => continue,\n             }\n         }\n     }"}, {"sha": "cc9ee1016c6dbbc4f52da8abb95da1fe95807883", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1,4 +1,3 @@\n-use rustc_ast::ast;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n@@ -31,43 +30,41 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n             debug!(\"running rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n         }\n \n-        let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data, param_env };\n-        let sess = &tcx.sess;\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_init).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_maybe_init).is_some() {\n             let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_inits);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_inits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_uninit).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_maybe_uninit).is_some() {\n             let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_uninits);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_uninits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_definite_init).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_definite_init).is_some() {\n             let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_def_inits);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_def_inits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_liveness).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_liveness).is_some() {\n             let flow_liveness = MaybeLiveLocals.into_engine(tcx, body).iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_liveness);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_liveness);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::stop_after_dataflow).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n     }\n@@ -92,7 +89,6 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n pub fn sanity_check_via_rustc_peek<'tcx, A>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    _attributes: &[ast::Attribute],\n     results: &Results<'tcx, A>,\n ) where\n     A: RustcPeekAt<'tcx>,"}, {"sha": "3cfd935d8b0ae1d41743eadccb7027c9abafbd1a", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -197,7 +197,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     unused_parameters: &FiniteBitSet<u32>,\n ) {\n     let base_def_id = tcx.typeck_root_def_id(def_id);\n-    if !tcx.get_attrs(base_def_id).iter().any(|a| a.has_name(sym::rustc_polymorphize_error)) {\n+    if !tcx.has_attr(base_def_id, sym::rustc_polymorphize_error) {\n         return;\n     }\n "}, {"sha": "15e24299075b96f7557573c0cf18c113b5f6a4e7", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -170,7 +170,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n             // If `def_id` is `None`, we don't need to consider stability attributes.\n             let def_id = match def_id {\n-                Some(x) => x.to_def_id(),\n+                Some(x) => x,\n                 None => return true,\n             };\n \n@@ -182,14 +182,16 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n             // If this crate is not using stability attributes, or this function is not claiming to be a\n             // stable `const fn`, that is all that is required.\n-            if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n+            if !tcx.features().staged_api\n+                || tcx.has_attr(def_id.to_def_id(), sym::rustc_const_unstable)\n+            {\n                 return true;\n             }\n \n             // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n             // opt-in via `rustc_allow_const_fn_unstable`.\n-            attr::rustc_allow_const_fn_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n-                .any(|name| name == feature_gate)\n+            let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n+            attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n         };\n \n         match required_gates {"}, {"sha": "ed694eb0e327a1f247b15b8c2bbfcda89f5f7d5e", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -83,7 +83,7 @@ fn collect_item(tcx: TyCtxt<'_>, items: &mut DiagnosticItems, name: Symbol, item\n     }\n }\n \n-/// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.p\n+/// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().find_map(|attr| {\n         if attr.has_name(sym::rustc_diagnostic_item) { attr.value_str() } else { None }"}, {"sha": "728aaab6137ab6047784ea04e192119623e88ee3", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -27,10 +27,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             | ItemKind::Enum(..)\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..) => {\n-                for attr in self.tcx.get_attrs(item.def_id.to_def_id()).iter() {\n-                    if attr.has_name(sym::rustc_layout) {\n-                        self.dump_layout_of(item.def_id, item, attr);\n-                    }\n+                for attr in self.tcx.get_attrs(item.def_id.to_def_id(), sym::rustc_layout) {\n+                    self.dump_layout_of(item.def_id, item, attr);\n                 }\n             }\n             _ => {}"}, {"sha": "e1bc248971ae25ff1b7245553a77341315607dcb", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n-        let attrs = self.tcx.get_attrs(def_id.to_def_id());\n+        let attrs = self.tcx.hir().attrs(self.tcx.hir().local_def_id_to_hir_id(def_id));\n         debug!(\"annotate(id = {:?}, attrs = {:?})\", def_id, attrs);\n \n         let depr = attr::find_deprecation(&self.tcx.sess, attrs);"}, {"sha": "ae4455531ab5bf226b6225619fda0193364cb9fd", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -2002,12 +2002,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         let parent_def_id = self.tcx.parent(def_id);\n                         if let Some(def_id) = parent_def_id.as_local() {\n                             // lifetimes in `derive` expansions don't count (Issue #53738)\n-                            if self\n-                                .tcx\n-                                .get_attrs(def_id.to_def_id())\n-                                .iter()\n-                                .any(|attr| attr.has_name(sym::automatically_derived))\n-                            {\n+                            if self.tcx.has_attr(def_id.to_def_id(), sym::automatically_derived) {\n                                 continue;\n                             }\n "}, {"sha": "7249ce04c155ecac4c357fbd7af61220c096e75a", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -49,27 +49,26 @@ struct SymbolNamesTest<'tcx> {\n impl SymbolNamesTest<'_> {\n     fn process_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n-        for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n-            if attr.has_name(SYMBOL_NAME) {\n-                let def_id = def_id.to_def_id();\n-                let instance = Instance::new(\n-                    def_id,\n-                    tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def_id)),\n-                );\n-                let mangled = tcx.symbol_name(instance);\n-                tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n-                if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {\n-                    tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n-                    tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n-                }\n-            } else if attr.has_name(DEF_PATH) {\n-                let path = with_no_trimmed_paths!(tcx.def_path_str(def_id.to_def_id()));\n-                tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n+        // The formatting of `tag({})` is chosen so that tests can elect\n+        // to test the entirety of the string, if they choose, or else just\n+        // some subset.\n+        for attr in tcx.get_attrs(def_id.to_def_id(), SYMBOL_NAME) {\n+            let def_id = def_id.to_def_id();\n+            let instance = Instance::new(\n+                def_id,\n+                tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def_id)),\n+            );\n+            let mangled = tcx.symbol_name(instance);\n+            tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n+            if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {\n+                tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n+                tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n             }\n+        }\n \n-            // (*) The formatting of `tag({})` is chosen so that tests can elect\n-            // to test the entirety of the string, if they choose, or else just\n-            // some subset.\n+        for attr in tcx.get_attrs(def_id.to_def_id(), DEF_PATH) {\n+            let path = with_no_trimmed_paths!(tcx.def_path_str(def_id.to_def_id()));\n+            tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n         }\n     }\n }"}, {"sha": "7d4181981953627e016b2cec5c236b2c866fc955", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -175,9 +175,7 @@ impl<'tcx> OnUnimplementedDirective {\n     }\n \n     pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n-        let attrs = tcx.get_attrs(item_def_id);\n-\n-        let Some(attr) = tcx.sess.find_by_name(&attrs, sym::rustc_on_unimplemented) else {\n+        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n             return Ok(None);\n         };\n "}, {"sha": "3d6bcc93c978c5bd357599c152f241e0a03b88a1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1156,9 +1156,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if let ImplCandidate(def_id) = candidate {\n             if let ty::ImplPolarity::Reservation = tcx.impl_polarity(def_id) {\n                 if let Some(intercrate_ambiguity_clauses) = &mut self.intercrate_ambiguity_causes {\n-                    let attrs = tcx.get_attrs(def_id);\n-                    let attr = tcx.sess.find_by_name(&attrs, sym::rustc_reservation_impl);\n-                    let value = attr.and_then(|a| a.value_str());\n+                    let value = tcx\n+                        .get_attr(def_id, sym::rustc_reservation_impl)\n+                        .and_then(|a| a.value_str());\n                     if let Some(value) = value {\n                         debug!(\n                             \"filter_reservation_impls: \\"}, {"sha": "35cc2da15bd69daab0cda75b343e3fe98ac184da", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1056,9 +1056,7 @@ fn check_impl_items_against_trait<'tcx>(\n         if let Some(missing_items) = must_implement_one_of {\n             let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n             let attr_span = tcx\n-                .get_attrs(impl_trait_ref.def_id)\n-                .iter()\n-                .find(|attr| attr.has_name(sym::rustc_must_implement_one_of))\n+                .get_attr(impl_trait_ref.def_id, sym::rustc_must_implement_one_of)\n                 .map(|attr| attr.span);\n \n             missing_items_must_implement_one_of_err(tcx, impl_span, missing_items, attr_span);\n@@ -1158,20 +1156,20 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n     let repr = def.repr();\n     if repr.packed() {\n-        for attr in tcx.get_attrs(def.did()).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n+        for attr in tcx.get_attrs(def.did(), sym::repr) {\n+            for r in attr::parse_repr_attr(&tcx.sess, attr) {\n                 if let attr::ReprPacked(pack) = r\n-                    && let Some(repr_pack) = repr.pack\n-                    && pack as u64 != repr_pack.bytes()\n-                {\n-                            struct_span_err!(\n-                                tcx.sess,\n-                                sp,\n-                                E0634,\n-                                \"type has conflicting packed representation hints\"\n-                            )\n-                            .emit();\n-                }\n+                && let Some(repr_pack) = repr.pack\n+                && pack as u64 != repr_pack.bytes()\n+            {\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            sp,\n+                            E0634,\n+                            \"type has conflicting packed representation hints\"\n+                        )\n+                        .emit();\n+            }\n             }\n         }\n         if repr.align.is_some() {\n@@ -1321,8 +1319,7 @@ fn check_enum<'tcx>(\n     def.destructor(tcx); // force the destructor to be evaluated\n \n     if vs.is_empty() {\n-        let attributes = tcx.get_attrs(def_id.to_def_id());\n-        if let Some(attr) = tcx.sess.find_by_name(&attributes, sym::repr) {\n+        if let Some(attr) = tcx.get_attr(def_id.to_def_id(), sym::repr) {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,"}, {"sha": "ae4cebe866bdbf5f7e4a5395c2739ddbd018ad5e", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -407,8 +407,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.has_only_self_parameter(m)\n                 && self\n                     .tcx\n-                    .get_attrs(m.def_id)\n-                    .iter()\n                     // This special internal attribute is used to permit\n                     // \"identity-like\" conversion methods to be suggested here.\n                     //\n@@ -419,7 +417,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     //\n                     // FIXME? Other potential candidate methods: `as_ref` and\n                     // `as_mut`?\n-                    .any(|a| a.has_name(sym::rustc_conversion_suggestion))\n+                    .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n         });\n \n         methods"}, {"sha": "be389f0e3f515973329db6d82036ac69f917c478", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -609,44 +609,43 @@ fn check_must_not_suspend_def(\n     hir_id: HirId,\n     data: SuspendCheckData<'_, '_>,\n ) -> bool {\n-    for attr in tcx.get_attrs(def_id).iter() {\n-        if attr.has_name(sym::must_not_suspend) {\n-            tcx.struct_span_lint_hir(\n-                rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n-                hir_id,\n-                data.source_span,\n-                |lint| {\n-                    let msg = format!(\n-                        \"{}`{}`{} held across a suspend point, but should not be\",\n-                        data.descr_pre,\n-                        tcx.def_path_str(def_id),\n-                        data.descr_post,\n-                    );\n-                    let mut err = lint.build(&msg);\n+    if let Some(attr) = tcx.get_attr(def_id, sym::must_not_suspend) {\n+        tcx.struct_span_lint_hir(\n+            rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n+            hir_id,\n+            data.source_span,\n+            |lint| {\n+                let msg = format!(\n+                    \"{}`{}`{} held across a suspend point, but should not be\",\n+                    data.descr_pre,\n+                    tcx.def_path_str(def_id),\n+                    data.descr_post,\n+                );\n+                let mut err = lint.build(&msg);\n \n-                    // add span pointing to the offending yield/await\n-                    err.span_label(data.yield_span, \"the value is held across this suspend point\");\n+                // add span pointing to the offending yield/await\n+                err.span_label(data.yield_span, \"the value is held across this suspend point\");\n \n-                    // Add optional reason note\n-                    if let Some(note) = attr.value_str() {\n-                        // FIXME(guswynn): consider formatting this better\n-                        err.span_note(data.source_span, note.as_str());\n-                    }\n+                // Add optional reason note\n+                if let Some(note) = attr.value_str() {\n+                    // FIXME(guswynn): consider formatting this better\n+                    err.span_note(data.source_span, note.as_str());\n+                }\n \n-                    // Add some quick suggestions on what to do\n-                    // FIXME: can `drop` work as a suggestion here as well?\n-                    err.span_help(\n-                        data.source_span,\n-                        \"consider using a block (`{ ... }`) \\\n-                        to shrink the value's scope, ending before the suspend point\",\n-                    );\n+                // Add some quick suggestions on what to do\n+                // FIXME: can `drop` work as a suggestion here as well?\n+                err.span_help(\n+                    data.source_span,\n+                    \"consider using a block (`{ ... }`) \\\n+                    to shrink the value's scope, ending before the suspend point\",\n+                );\n \n-                    err.emit();\n-                },\n-            );\n+                err.emit();\n+            },\n+        );\n \n-            return true;\n-        }\n+        true\n+    } else {\n+        false\n     }\n-    false\n }"}, {"sha": "00f0d1e6f02a9744bd014ce2ab7e243789138e41", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -128,7 +128,8 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n                 tcx.struct_span_lint_hir(lint, id, span, |lint| {\n                     // Removal suggestion span needs to include attributes (Issue #54400)\n                     let span_with_attrs = tcx\n-                        .get_attrs(extern_crate.def_id)\n+                        .hir()\n+                        .attrs(id)\n                         .iter()\n                         .map(|attr| attr.span)\n                         .fold(span, |acc, attr_span| acc.to(attr_span));\n@@ -166,13 +167,13 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n             continue;\n         }\n \n+        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         // If the extern crate has any attributes, they may have funky\n         // semantics we can't faithfully represent using `use` (most\n         // notably `#[macro_use]`). Ignore it.\n-        if !tcx.get_attrs(extern_crate.def_id).is_empty() {\n+        if !tcx.hir().attrs(id).is_empty() {\n             continue;\n         }\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         tcx.struct_span_lint_hir(lint, id, extern_crate.span, |lint| {\n             // Otherwise, we can convert it into a `use` of some kind.\n             let base_replacement = match extern_crate.orig_name {"}, {"sha": "cda817dee1e1e715514650dffaa1798c6d760623", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1200,9 +1200,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n         ty::trait_def::TraitSpecializationKind::None\n     };\n     let must_implement_one_of = tcx\n-        .get_attrs(def_id)\n-        .iter()\n-        .find(|attr| attr.has_name(sym::rustc_must_implement_one_of))\n+        .get_attr(def_id, sym::rustc_must_implement_one_of)\n         // Check that there are at least 2 arguments of `#[rustc_must_implement_one_of]`\n         // and that they are all identifiers\n         .and_then(|attr| match attr.meta_item_list() {"}, {"sha": "67c6e791bfe584bd4902f98e6926b5065bfaf6aa", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -298,17 +298,12 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         error = true;\n     }\n \n-    for attr in tcx.get_attrs(main_def_id) {\n-        if attr.has_name(sym::track_caller) {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr.span,\n-                    \"`main` function is not allowed to be `#[track_caller]`\",\n-                )\n-                .span_label(main_span, \"`main` function is not allowed to be `#[track_caller]`\")\n-                .emit();\n-            error = true;\n-        }\n+    for attr in tcx.get_attrs(main_def_id, sym::track_caller) {\n+        tcx.sess\n+            .struct_span_err(attr.span, \"`main` function is not allowed to be `#[track_caller]`\")\n+            .span_label(main_span, \"`main` function is not allowed to be `#[track_caller]`\")\n+            .emit();\n+        error = true;\n     }\n \n     if error {"}, {"sha": "9a579cb5311642487251b5697021af5532b4dba3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -22,7 +22,7 @@ use crate::clean::{\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n-type Attrs<'hir> = rustc_middle::ty::Attributes<'hir>;\n+type Attrs<'hir> = &'hir [ast::Attribute];\n \n /// Attempt to inline a definition into this AST.\n ///\n@@ -155,7 +155,7 @@ crate fn try_inline_glob(\n }\n \n crate fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n-    cx.tcx.get_attrs(did)\n+    cx.tcx.get_attrs_unchecked(did)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n@@ -691,7 +691,7 @@ crate fn record_extern_trait(cx: &mut DocContext<'_>, did: DefId) {\n \n     let trait_ = clean::TraitWithExtraInfo {\n         trait_,\n-        is_notable: clean::utils::has_doc_flag(cx.tcx.get_attrs(did), sym::notable_trait),\n+        is_notable: clean::utils::has_doc_flag(cx.tcx, did, sym::notable_trait),\n     };\n     cx.external_traits.borrow_mut().insert(did, trait_);\n     cx.active_extern_traits.remove(&did);"}, {"sha": "456d860f12559d4832c5df65e9d0121bafa127d1", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -211,8 +211,8 @@ impl ExternalCrate {\n         // Failing that, see if there's an attribute specifying where to find this\n         // external crate\n         let did = self.crate_num.as_def_id();\n-        tcx.get_attrs(did)\n-            .lists(sym::doc)\n+        tcx.get_attrs(did, sym::doc)\n+            .flat_map(|attr| attr.meta_item_list().unwrap_or_default())\n             .filter(|a| a.has_name(sym::html_root_url))\n             .filter_map(|a| a.value_str())\n             .map(to_remote)\n@@ -226,11 +226,13 @@ impl ExternalCrate {\n \n         let as_keyword = |res: Res<!>| {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n-                let attrs = tcx.get_attrs(def_id);\n                 let mut keyword = None;\n-                for attr in attrs.lists(sym::doc) {\n-                    if attr.has_name(sym::keyword) {\n-                        if let Some(v) = attr.value_str() {\n+                let meta_items = tcx\n+                    .get_attrs(def_id, sym::doc)\n+                    .flat_map(|attr| attr.meta_item_list().unwrap_or_default());\n+                for meta in meta_items {\n+                    if meta.has_name(sym::keyword) {\n+                        if let Some(v) = meta.value_str() {\n                             keyword = Some(v);\n                             break;\n                         }\n@@ -288,11 +290,13 @@ impl ExternalCrate {\n         // rendering by delegating everything to a hash map.\n         let as_primitive = |res: Res<!>| {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n-                let attrs = tcx.get_attrs(def_id);\n                 let mut prim = None;\n-                for attr in attrs.lists(sym::doc) {\n-                    if let Some(v) = attr.value_str() {\n-                        if attr.has_name(sym::primitive) {\n+                let meta_items = tcx\n+                    .get_attrs(def_id, sym::doc)\n+                    .flat_map(|attr| attr.meta_item_list().unwrap_or_default());\n+                for meta in meta_items {\n+                    if let Some(v) = meta.value_str() {\n+                        if meta.has_name(sym::primitive) {\n                             prim = PrimitiveType::from_symbol(v);\n                             if prim.is_some() {\n                                 break;\n@@ -413,7 +417,10 @@ impl Item {\n     }\n \n     crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n-        self.item_id.as_def_id().map(|did| tcx.get_attrs(did).inner_docs()).unwrap_or(false)\n+        self.item_id\n+            .as_def_id()\n+            .map(|did| tcx.get_attrs_unchecked(did).inner_docs())\n+            .unwrap_or(false)\n     }\n \n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -464,7 +471,7 @@ impl Item {\n         kind: ItemKind,\n         cx: &mut DocContext<'_>,\n     ) -> Item {\n-        let ast_attrs = cx.tcx.get_attrs(def_id);\n+        let ast_attrs = cx.tcx.get_attrs_unchecked(def_id);\n \n         Self::from_def_id_and_attrs_and_parts(\n             def_id,"}, {"sha": "c67b92df6431f72eb610b2529375e74729382cb8", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -474,10 +474,9 @@ crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<De\n ///\n /// This function exists because it runs on `hir::Attributes` whereas the other is a\n /// `clean::Attributes` method.\n-crate fn has_doc_flag(attrs: ty::Attributes<'_>, flag: Symbol) -> bool {\n-    attrs.iter().any(|attr| {\n-        attr.has_name(sym::doc)\n-            && attr.meta_item_list().map_or(false, |l| rustc_attr::list_contains_name(&l, flag))\n+crate fn has_doc_flag(tcx: TyCtxt<'_>, did: DefId, flag: Symbol) -> bool {\n+    tcx.get_attrs(did, sym::doc).any(|attr| {\n+        attr.meta_item_list().map_or(false, |l| rustc_attr::list_contains_name(&l, flag))\n     })\n }\n "}, {"sha": "4951cd83af207a3635d1aa4c6c7a10d0bce8663b", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -323,7 +323,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n             clean::ImportItem(ref import) => {\n                 let (stab, stab_tags) = if let Some(import_def_id) = import.source.did {\n-                    let ast_attrs = cx.tcx().get_attrs(import_def_id);\n+                    let ast_attrs = cx.tcx().get_attrs_unchecked(import_def_id);\n                     let import_attrs = Box::new(clean::Attributes::from_ast(ast_attrs, None));\n \n                     // Just need an item with the correct def_id and attrs"}, {"sha": "3b7ca7dc3c5193bd2551f33ba1a34bddd00bf961", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -53,9 +53,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n             while let Some(did) = parent {\n                 attr_buf.extend(\n                     cx.tcx\n-                        .get_attrs(did)\n-                        .iter()\n-                        .filter(|attr| attr.has_name(sym::doc))\n+                        .get_attrs(did, sym::doc)\n                         .filter(|attr| {\n                             if let Some([attr]) = attr.meta_item_list().as_deref() {\n                                 attr.has_name(sym::cfg)"}, {"sha": "34a5f8444dea0af0d58a1d221db4a1ca3998999a", "filename": "src/tools/clippy/clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{is_automatically_derived, is_default_equivalent, peel_blocks};\n+use clippy_utils::{is_default_equivalent, peel_blocks};\n use rustc_hir::{\n     def::{DefKind, Res},\n     Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n@@ -71,8 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                 self_ty,\n                 ..\n             }) = item.kind;\n-            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            if !is_automatically_derived(attrs);\n+            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n             if !item.span.from_expansion();\n             if let Some(def_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n@@ -81,6 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n             if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n             if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|attr| attr.doc_str().is_some());\n             if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);\n             if !child_attrs.iter().any(|attr| attr.doc_str().is_some());"}, {"sha": "545bc7d210332706e960f0d96fa72f65c3e5f0f7", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_then};\n use clippy_utils::paths;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{is_automatically_derived, is_lint_allowed, match_def_path};\n+use clippy_utils::{is_lint_allowed, match_def_path};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, Visitor};\n use rustc_hir::{\n@@ -171,8 +171,8 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n         }) = item.kind\n         {\n             let ty = cx.tcx.type_of(item.def_id);\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let is_automatically_derived = is_automatically_derived(attrs);\n+            let is_automatically_derived =\n+                cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n             check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);\n@@ -201,7 +201,7 @@ fn check_hash_peq<'tcx>(\n         then {\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n-                let peq_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n+                let peq_is_automatically_derived = cx.tcx.has_attr(impl_id, sym::automatically_derived);\n \n                 if peq_is_automatically_derived == hash_is_automatically_derived {\n                     return;\n@@ -255,7 +255,7 @@ fn check_ord_partial_ord<'tcx>(\n         then {\n             // Look for the PartialOrd implementations for `ty`\n             cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n-                let partial_ord_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n+                let partial_ord_is_automatically_derived = cx.tcx.has_attr(impl_id, sym::automatically_derived);\n \n                 if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n                     return;"}, {"sha": "6672a6cb0b58fb7be926b3d0f074021645f602e2", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -13,13 +13,13 @@ use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n-use clippy_utils::{match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n+use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n \n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    let attr = must_use_attr(attrs);\n+    let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n     if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -44,7 +44,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n+        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id).is_none() {\n@@ -67,7 +67,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n+        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {"}, {"sha": "09164690700ef0fa95b7c11584ac7b36938cba8d", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1,4 +1,3 @@\n-use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::{is_lint_allowed, meets_msrv, msrvs};\n@@ -161,7 +160,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n                 let id = cx.tcx.hir().local_def_id(v.id);\n                 (matches!(v.data, hir::VariantData::Unit(_))\n                     && v.ident.as_str().starts_with('_')\n-                    && is_doc_hidden(cx.tcx.get_attrs(id.to_def_id())))\n+                    && cx.tcx.is_doc_hidden(id.to_def_id()))\n                 .then(|| (id, v.span))\n             });\n             if let Some((id, span)) = iter.next()"}, {"sha": "fc45ccee18528fbbffe6f6664cd3a91f7d298160", "filename": "src/tools/clippy/clippy_lints/src/matches/match_wild_enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -193,6 +193,5 @@ impl<'a> CommonPrefixSearcher<'a> {\n }\n \n fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n-    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n-    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n+    cx.tcx.is_doc_hidden(variant_def.def_id) || cx.tcx.has_attr(variant_def.def_id, sym::unstable)\n }"}, {"sha": "2bdccb425071b135ebb88e5ff403460912f03fa4", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -85,7 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if clippy_utils::is_doc_hidden(cx.tcx.hir().attrs(id)) {\n+                        if cx.tcx.is_doc_hidden(impl_item.def_id) {\n                             // shouldn't be implemented when it is hidden in docs\n                             return;\n                         }"}, {"sha": "09ac514d014eb1d67fc1f9a6ad9a58f5061bdaaf", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_hir;\n-use clippy_utils::is_automatically_derived;\n use if_chain::if_chain;\n use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -37,8 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: Some(ref trait_ref), items: impl_items, .. }) = item.kind;\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            if !is_automatically_derived(attrs);\n+            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {"}, {"sha": "f300acf0fb2ba4d300e490449e9a99a4d56c7f04", "filename": "src/tools/clippy/clippy_lints/src/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -290,7 +290,7 @@ impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n \n     fn has_sig_drop_attr(&mut self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         if let Some(adt) = ty.ty_adt_def() {\n-            if get_attr(cx.sess(), cx.tcx.get_attrs(adt.did()), \"has_significant_drop\").count() > 0 {\n+            if get_attr(cx.sess(), cx.tcx.get_attrs_unchecked(adt.did()), \"has_significant_drop\").count() > 0 {\n                 return true;\n             }\n         }"}, {"sha": "904b1a05ccc30dfc50a81f0581bbb3431f751f88", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -1,6 +1,7 @@\n-use rustc_ast::{ast, attr};\n+use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_session::Session;\n+use rustc_ast::attr;\n use rustc_span::sym;\n use std::str::FromStr;\n \n@@ -158,7 +159,3 @@ pub fn is_doc_hidden(attrs: &[ast::Attribute]) -> bool {\n         .any(|l| attr::list_contains_name(&l, sym::hidden))\n }\n \n-/// Return true if the attributes contain `#[unstable]`\n-pub fn is_unstable(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym::unstable))\n-}"}, {"sha": "98a073d122e317cb532b1b6fb4c40eac925b17e9", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -66,7 +66,7 @@ use std::lazy::SyncOnceCell;\n use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, LitKind};\n+use rustc_ast::ast::{self, LitKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n@@ -1472,12 +1472,6 @@ pub fn recurse_or_patterns<'tcx, F: FnMut(&'tcx Pat<'tcx>)>(pat: &'tcx Pat<'tcx>\n     }\n }\n \n-/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n-/// implementations have.\n-pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    has_attr(attrs, sym::automatically_derived)\n-}\n-\n pub fn is_self(slf: &Param<'_>) -> bool {\n     if let PatKind::Binding(.., name, _) = slf.pat.kind {\n         name.name == kw::SelfLower\n@@ -1724,11 +1718,6 @@ pub fn get_async_fn_body<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Option<&'t\n     None\n }\n \n-// Finds the `#[must_use]` attribute, if any\n-pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n-    attrs.iter().find(|a| a.has_name(sym::must_use))\n-}\n-\n // check if expr is calling method or function with #[must_use] attribute\n pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n@@ -1745,7 +1734,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         _ => None,\n     };\n \n-    did.map_or(false, |did| must_use_attr(cx.tcx.get_attrs(did)).is_some())\n+    did.map_or(false, |did| cx.tcx.has_attr(did, sym::must_use))\n }\n \n /// Checks if an expression represents the identity function"}, {"sha": "7f14a306d0e529a6601e3dab93921d7b10e9184b", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481db40311cdd241ae4d33f34f2f75732e44d8e8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=481db40311cdd241ae4d33f34f2f75732e44d8e8", "patch": "@@ -22,7 +22,7 @@ use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{match_def_path, must_use_attr, path_res, paths};\n+use crate::{match_def_path, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -178,18 +178,18 @@ pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // Returns whether the type has #[must_use] attribute\n pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did())).is_some(),\n-        ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n+        ty::Adt(adt, _) => cx.tcx.has_attr(adt.did(), sym::must_use),\n+        ty::Foreign(did) => cx.tcx.has_attr(*did, sym::must_use),\n         ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n-        ty::Opaque(ref def_id, _) => {\n+        ty::Opaque(def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n-                    if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n+                    if cx.tcx.has_attr(trait_predicate.trait_ref.def_id, sym::must_use) {\n                         return true;\n                     }\n                 }\n@@ -199,7 +199,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Dynamic(binder, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n-                    if must_use_attr(cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n+                    if cx.tcx.has_attr(trait_ref.def_id, sym::must_use) {\n                         return true;\n                     }\n                 }"}]}