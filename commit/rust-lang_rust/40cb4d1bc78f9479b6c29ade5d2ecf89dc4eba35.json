{"sha": "40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "node_id": "C_kwDOAAsO6NoAKDQwY2I0ZDFiYzc4Zjk0NzliNmMyOWFkZTVkMmVjZjg5ZGM0ZWJhMzU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-12T21:08:14Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-14T20:27:38Z"}, "message": "Even less HIR.", "tree": {"sha": "228d7195e0d0b3a83b63cdd8a08437e76a3374f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/228d7195e0d0b3a83b63cdd8a08437e76a3374f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "html_url": "https://github.com/rust-lang/rust/commit/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68fb752035aa954b7881b846ec1cd5bd3354a4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/68fb752035aa954b7881b846ec1cd5bd3354a4cf", "html_url": "https://github.com/rust-lang/rust/commit/68fb752035aa954b7881b846ec1cd5bd3354a4cf"}], "stats": {"total": 61, "additions": 28, "deletions": 33}, "files": [{"sha": "71ed9253668cb17905558b48103dbdd1f70e2fbe", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "patch": "@@ -21,7 +21,9 @@ use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtDef, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, AdtDef, DefIdTree, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n@@ -174,16 +176,8 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         Ok(l) => l,\n         // Foreign statics that overflow their allowed size should emit an error\n         Err(LayoutError::SizeOverflow(_))\n-            if {\n-                let node = tcx.hir().get_by_def_id(def_id);\n-                matches!(\n-                    node,\n-                    hir::Node::ForeignItem(hir::ForeignItem {\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    })\n-                )\n-            } =>\n+            if matches!(tcx.def_kind(def_id), DefKind::Static(_)\n+                if tcx.def_kind(tcx.local_parent(def_id)) == DefKind::ForeignMod) =>\n         {\n             tcx.sess\n                 .struct_span_err(span, \"extern static is too large for the current architecture\")\n@@ -215,7 +209,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     let item = tcx.hir().item(id);\n     let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n-        tcx.sess.delay_span_bug(tcx.hir().span(id.hir_id()), \"expected opaque item\");\n+        tcx.sess.delay_span_bug(item.span, \"expected opaque item\");\n         return;\n     };\n "}, {"sha": "56ac18c492792ac0206ad56b88d0c63963e13eab", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "patch": "@@ -414,15 +414,15 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                 // Check that sym actually points to a function. Later passes\n                 // depend on this.\n                 hir::InlineAsmOperand::SymFn { anon_const } => {\n-                    let ty = self.tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n+                    let ty = self.tcx.type_of(anon_const.def_id);\n                     match ty.kind() {\n                         ty::Never | ty::Error(_) => {}\n                         ty::FnDef(..) => {}\n                         _ => {\n                             let mut err =\n                                 self.tcx.sess.struct_span_err(*op_sp, \"invalid `sym` operand\");\n                             err.span_label(\n-                                self.tcx.hir().span(anon_const.body.hir_id),\n+                                self.tcx.def_span(anon_const.def_id),\n                                 &format!(\"is {} `{}`\", ty.kind().article(), ty),\n                             );\n                             err.help(\"`sym` operands must refer to either a function or a static\");"}, {"sha": "c0ba385987d77b60eeb34d4e7e449ceebc8bdc4b", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "patch": "@@ -202,8 +202,7 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'_>, impl_did: LocalDefId)\n fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-    let span = tcx.hir().span(impl_hir_id);\n+    let span = tcx.def_span(impl_did);\n \n     let dispatch_from_dyn_trait = tcx.require_lang_item(LangItem::DispatchFromDyn, Some(span));\n "}, {"sha": "49a9a2ea2930923acddd2f5d74ea2bbbb007dcb3", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=40cb4d1bc78f9479b6c29ade5d2ecf89dc4eba35", "patch": "@@ -38,26 +38,28 @@ fn do_orphan_check_impl<'tcx>(\n     def_id: LocalDefId,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_def_id = trait_ref.def_id;\n-\n-    let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(impl_) = item.kind else {\n-        bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n-    };\n     let sp = tcx.def_span(def_id);\n-    let tr = impl_.of_trait.as_ref().unwrap();\n \n-    match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n+    match traits::orphan_check(tcx, def_id.to_def_id()) {\n         Ok(()) => {}\n-        Err(err) => emit_orphan_check_error(\n-            tcx,\n-            sp,\n-            item.span,\n-            tr.path.span,\n-            trait_ref,\n-            impl_.self_ty.span,\n-            &impl_.generics,\n-            err,\n-        )?,\n+        Err(err) => {\n+            let item = tcx.hir().expect_item(def_id);\n+            let hir::ItemKind::Impl(impl_) = item.kind else {\n+                bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n+            };\n+            let tr = impl_.of_trait.as_ref().unwrap();\n+\n+            emit_orphan_check_error(\n+                tcx,\n+                sp,\n+                item.span,\n+                tr.path.span,\n+                trait_ref,\n+                impl_.self_ty.span,\n+                &impl_.generics,\n+                err,\n+            )?\n+        }\n     }\n \n     // In addition to the above rules, we restrict impls of auto traits"}]}