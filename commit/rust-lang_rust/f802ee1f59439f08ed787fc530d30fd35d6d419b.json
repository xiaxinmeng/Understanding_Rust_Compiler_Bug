{"sha": "f802ee1f59439f08ed787fc530d30fd35d6d419b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MDJlZTFmNTk0MzlmMDhlZDc4N2ZjNTMwZDMwZmQzNWQ2ZDQxOWI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-10T08:30:39Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-21T09:22:21Z"}, "message": "Cache flags and escaping vars for predicates\n\nAlso hash predicates by address", "tree": {"sha": "db8001bfa300a22da5def707c92a015812794bb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db8001bfa300a22da5def707c92a015812794bb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f802ee1f59439f08ed787fc530d30fd35d6d419b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f802ee1f59439f08ed787fc530d30fd35d6d419b", "html_url": "https://github.com/rust-lang/rust/commit/f802ee1f59439f08ed787fc530d30fd35d6d419b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f802ee1f59439f08ed787fc530d30fd35d6d419b/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "html_url": "https://github.com/rust-lang/rust/commit/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b"}], "stats": {"total": 230, "additions": 202, "deletions": 28}, "files": [{"sha": "4f1889aeb162a4a4cc6b2824bdf5034a1ea86557", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=f802ee1f59439f08ed787fc530d30fd35d6d419b", "patch": "@@ -100,6 +100,7 @@ macro_rules! arena_types {\n \n             // Interned types\n             [] tys: rustc_middle::ty::TyS<$tcx>, rustc_middle::ty::TyS<'_x>;\n+            [] predicates: rustc_middle::ty::PredicateInner<$tcx>, rustc_middle::ty::PredicateInner<'_x>;\n \n             // HIR query types\n             [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>, rustc_middle::hir::map::IndexedHir<'_x>;"}, {"sha": "56f4ae9e9848bc66322501c5967a7a397f8c9696", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=f802ee1f59439f08ed787fc530d30fd35d6d419b", "patch": "@@ -19,8 +19,9 @@ use crate::ty::TyKind::*;\n use crate::ty::{\n     self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n     DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n-    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, ProjectionTy,\n-    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n+    ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n+    TyVid, TypeAndMut,\n };\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -76,7 +77,7 @@ pub struct CtxtInterners<'tcx> {\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo>>,\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n-    predicate_kind: InternedSet<'tcx, PredicateKind<'tcx>>,\n+    predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -95,7 +96,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             region: Default::default(),\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n-            predicate_kind: Default::default(),\n+            predicate: Default::default(),\n             predicates: Default::default(),\n             projs: Default::default(),\n             place_elems: Default::default(),\n@@ -123,6 +124,23 @@ impl<'tcx> CtxtInterners<'tcx> {\n             })\n             .0\n     }\n+\n+    #[inline(never)]\n+    fn intern_predicate(&self, kind: PredicateKind<'tcx>) -> &'tcx PredicateInner<'tcx> {\n+        self.predicate\n+            .intern(kind, |kind| {\n+                let flags = super::flags::FlagComputation::for_predicate(&kind);\n+\n+                let predicate_struct = PredicateInner {\n+                    kind,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n+\n+                Interned(self.arena.alloc(predicate_struct))\n+            })\n+            .0\n+    }\n }\n \n pub struct CommonTypes<'tcx> {\n@@ -1627,7 +1645,7 @@ macro_rules! nop_list_lift {\n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n-nop_lift! {predicate_kind; &'a PredicateKind<'a> => &'tcx PredicateKind<'tcx>}\n+nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n@@ -1986,6 +2004,26 @@ impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n         &self.0.kind\n     }\n }\n+// N.B., an `Interned<PredicateInner>` compares and hashes as a `PredicateKind`.\n+impl<'tcx> PartialEq for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn eq(&self, other: &Interned<'tcx, PredicateInner<'tcx>>) -> bool {\n+        self.0.kind == other.0.kind\n+    }\n+}\n+\n+impl<'tcx> Eq for Interned<'tcx, PredicateInner<'tcx>> {}\n+\n+impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.0.kind.hash(s)\n+    }\n+}\n+\n+impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n+        &self.0.kind\n+    }\n+}\n \n // N.B., an `Interned<List<T>>` compares and hashes as its elements.\n impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n@@ -2052,11 +2090,10 @@ macro_rules! direct_interners {\n     }\n }\n \n-direct_interners!(\n+direct_interners! {\n     region: mk_region(RegionKind),\n     const_: mk_const(Const<'tcx>),\n-    predicate_kind: intern_predicate_kind(PredicateKind<'tcx>),\n-);\n+}\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+) => (\n@@ -2127,8 +2164,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_predicate(&self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n-        let kind = self.intern_predicate_kind(kind);\n-        Predicate { kind }\n+        let inner = self.interners.intern_predicate(kind);\n+        Predicate { inner }\n     }\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {"}, {"sha": "c782eee938721aca7f3c2c0c7bf47fd4dbb60dcf", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=f802ee1f59439f08ed787fc530d30fd35d6d419b", "patch": "@@ -1,5 +1,6 @@\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, InferConst, Ty, TypeFlags};\n+use std::slice;\n \n #[derive(Debug)]\n pub struct FlagComputation {\n@@ -21,6 +22,12 @@ impl FlagComputation {\n         result\n     }\n \n+    pub fn for_predicate(kind: &ty::PredicateKind<'_>) -> FlagComputation {\n+        let mut result = FlagComputation::new();\n+        result.add_predicate_kind(kind);\n+        result\n+    }\n+\n     pub fn for_const(c: &ty::Const<'_>) -> TypeFlags {\n         let mut result = FlagComputation::new();\n         result.add_const(c);\n@@ -32,7 +39,7 @@ impl FlagComputation {\n     }\n \n     /// indicates that `self` refers to something at binding level `binder`\n-    fn add_binder(&mut self, binder: ty::DebruijnIndex) {\n+    fn add_bound_var(&mut self, binder: ty::DebruijnIndex) {\n         let exclusive_binder = binder.shifted_in(1);\n         self.add_exclusive_binder(exclusive_binder);\n     }\n@@ -46,7 +53,7 @@ impl FlagComputation {\n \n     /// Adds the flags/depth from a set of types that appear within the current type, but within a\n     /// region binder.\n-    fn add_bound_computation(&mut self, computation: &FlagComputation) {\n+    fn add_bound_computation(&mut self, computation: FlagComputation) {\n         self.add_flags(computation.flags);\n \n         // The types that contributed to `computation` occurred within\n@@ -84,15 +91,15 @@ impl FlagComputation {\n             &ty::GeneratorWitness(ref ts) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_tys(&ts.skip_binder()[..]);\n-                self.add_bound_computation(&computation);\n+                self.add_bound_computation(computation);\n             }\n \n             &ty::Closure(_, ref substs) => {\n                 self.add_substs(substs);\n             }\n \n             &ty::Bound(debruijn, _) => {\n-                self.add_binder(debruijn);\n+                self.add_bound_var(debruijn);\n             }\n \n             &ty::Placeholder(..) => {\n@@ -133,12 +140,12 @@ impl FlagComputation {\n                         ty::ExistentialPredicate::Projection(p) => {\n                             let mut proj_computation = FlagComputation::new();\n                             proj_computation.add_existential_projection(&p);\n-                            self.add_bound_computation(&proj_computation);\n+                            self.add_bound_computation(proj_computation);\n                         }\n                         ty::ExistentialPredicate::AutoTrait(_) => {}\n                     }\n                 }\n-                self.add_bound_computation(&computation);\n+                self.add_bound_computation(computation);\n                 self.add_region(r);\n             }\n \n@@ -172,6 +179,63 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_predicate_kind(&mut self, kind: &ty::PredicateKind<'_>) {\n+        match kind {\n+            ty::PredicateKind::Trait(trait_pred, _constness) => {\n+                let mut computation = FlagComputation::new();\n+                computation.add_substs(trait_pred.skip_binder().trait_ref.substs);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::RegionOutlives(poly_outlives) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::OutlivesPredicate(a, b) = poly_outlives.skip_binder();\n+                computation.add_region(a);\n+                computation.add_region(b);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::TypeOutlives(poly_outlives) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::OutlivesPredicate(ty, region) = poly_outlives.skip_binder();\n+                computation.add_ty(ty);\n+                computation.add_region(region);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::Subtype(poly_subtype) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::SubtypePredicate { a_is_expected: _, a, b } = poly_subtype.skip_binder();\n+                computation.add_ty(a);\n+                computation.add_ty(b);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::Projection(projection) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::ProjectionPredicate { projection_ty, ty } = projection.skip_binder();\n+                computation.add_projection_ty(projection_ty);\n+                computation.add_ty(ty);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::WellFormed(arg) => {\n+                self.add_substs(slice::from_ref(arg));\n+            }\n+            ty::PredicateKind::ObjectSafe(_def_id) => {}\n+            ty::PredicateKind::ClosureKind(_def_id, substs, _kind) => {\n+                self.add_substs(substs);\n+            }\n+            ty::PredicateKind::ConstEvaluatable(_def_id, substs) => {\n+                self.add_substs(substs);\n+            }\n+            ty::PredicateKind::ConstEquate(expected, found) => {\n+                self.add_const(expected);\n+                self.add_const(found);\n+            }\n+        }\n+    }\n+\n     fn add_ty(&mut self, ty: Ty<'_>) {\n         self.add_flags(ty.flags);\n         self.add_exclusive_binder(ty.outer_exclusive_binder);\n@@ -189,13 +253,13 @@ impl FlagComputation {\n         computation.add_tys(fn_sig.skip_binder().inputs());\n         computation.add_ty(fn_sig.skip_binder().output());\n \n-        self.add_bound_computation(&computation);\n+        self.add_bound_computation(computation);\n     }\n \n     fn add_region(&mut self, r: ty::Region<'_>) {\n         self.add_flags(r.type_flags());\n         if let ty::ReLateBound(debruijn, _) = *r {\n-            self.add_binder(debruijn);\n+            self.add_bound_var(debruijn);\n         }\n     }\n \n@@ -214,7 +278,7 @@ impl FlagComputation {\n                 }\n             }\n             ty::ConstKind::Bound(debruijn, _) => {\n-                self.add_binder(debruijn);\n+                self.add_bound_var(debruijn);\n             }\n             ty::ConstKind::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_CT_PARAM);"}, {"sha": "2d25c7c6ac983546a87cfb4f954f235f3b88ef97", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=f802ee1f59439f08ed787fc530d30fd35d6d419b", "patch": "@@ -31,6 +31,7 @@\n //! These methods return true to indicate that the visitor has found what it is\n //! looking for, and does not need to visit anything else.\n \n+use crate::ty::structural_impls::PredicateVisitor;\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -908,6 +909,12 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     }\n }\n \n+impl<'tcx> PredicateVisitor<'tcx> for HasEscapingVarsVisitor {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        predicate.inner.outer_exclusive_binder > self.outer_index\n+    }\n+}\n+\n // FIXME: Optimize for checking for infer flags\n struct HasTypeFlagsVisitor {\n     flags: ty::TypeFlags,\n@@ -932,6 +939,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n }\n \n+impl<'tcx> PredicateVisitor<'tcx> for HasTypeFlagsVisitor {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        debug!(\n+            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n+            predicate, predicate.inner.flags, self.flags\n+        );\n+        predicate.inner.flags.intersects(self.flags)\n+    }\n+}\n /// Collects all the late-bound regions at the innermost binding level\n /// into a hash set.\n struct LateBoundRegionsCollector {"}, {"sha": "6b7940ed7abcc1f66b794cab63bcb3e22273c9c3", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=f802ee1f59439f08ed787fc530d30fd35d6d419b", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TyS {\n             ref kind,\n@@ -1001,16 +1001,35 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Hash, RustcEncodable, RustcDecodable, Lift)]\n-#[derive(HashStable)]\n+#[derive(Debug)]\n+crate struct PredicateInner<'tcx> {\n+    kind: PredicateKind<'tcx>,\n+    flags: TypeFlags,\n+    /// See the comment for the corresponding field of [TyS].\n+    outer_exclusive_binder: ty::DebruijnIndex,\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PredicateInner<'_>, 40);\n+\n+#[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n-    kind: &'tcx PredicateKind<'tcx>,\n+    inner: &'tcx PredicateInner<'tcx>,\n }\n \n+impl rustc_serialize::UseSpecializedEncodable for Predicate<'_> {}\n+impl rustc_serialize::UseSpecializedDecodable for Predicate<'_> {}\n+\n impl<'tcx> PartialEq for Predicate<'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         // `self.kind` is always interned.\n-        ptr::eq(self.kind, other.kind)\n+        ptr::eq(self.inner, other.inner)\n+    }\n+}\n+\n+impl Hash for Predicate<'_> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self.inner as *const PredicateInner<'_>).hash(s)\n     }\n }\n \n@@ -1019,7 +1038,22 @@ impl<'tcx> Eq for Predicate<'tcx> {}\n impl<'tcx> Predicate<'tcx> {\n     #[inline(always)]\n     pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n-        self.kind\n+        &self.inner.kind\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let PredicateInner {\n+            ref kind,\n+\n+            // The other fields just provide fast access to information that is\n+            // also contained in `kind`, so no need to hash them.\n+            flags: _,\n+            outer_exclusive_binder: _,\n+        } = self.inner;\n+\n+        kind.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "f736037b5c15a598eccd5ccb8b093e73b72e307e", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f802ee1f59439f08ed787fc530d30fd35d6d419b/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=f802ee1f59439f08ed787fc530d30fd35d6d419b", "patch": "@@ -987,12 +987,34 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let new = ty::PredicateKind::super_fold_with(self.kind, folder);\n-        if new != *self.kind { folder.tcx().mk_predicate(new) } else { *self }\n+        let new = ty::PredicateKind::super_fold_with(&self.inner.kind, folder);\n+        if new != self.inner.kind { folder.tcx().mk_predicate(new) } else { *self }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        ty::PredicateKind::super_visit_with(self.kind, visitor)\n+        ty::PredicateKind::super_visit_with(&self.inner.kind, visitor)\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_predicate(*self)\n+    }\n+\n+    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.inner.outer_exclusive_binder > binder\n+    }\n+\n+    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n+        self.inner.flags.intersects(flags)\n+    }\n+}\n+\n+pub(super) trait PredicateVisitor<'tcx>: TypeVisitor<'tcx> {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool;\n+}\n+\n+impl<T: TypeVisitor<'tcx>> PredicateVisitor<'tcx> for T {\n+    default fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        predicate.super_visit_with(self)\n     }\n }\n "}]}