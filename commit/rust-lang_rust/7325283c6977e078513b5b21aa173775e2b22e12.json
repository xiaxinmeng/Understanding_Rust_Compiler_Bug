{"sha": "7325283c6977e078513b5b21aa173775e2b22e12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMjUyODNjNjk3N2UwNzg1MTNiNWIyMWFhMTczNzc1ZTJiMjJlMTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-31T15:09:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-31T15:09:31Z"}, "message": "Merge #5624\n\n5624: Finalize expressions grammar r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7be8b4fbc2e7470bf7891d81b3812eb572bb0d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7be8b4fbc2e7470bf7891d81b3812eb572bb0d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7325283c6977e078513b5b21aa173775e2b22e12", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfJDQrCRBK7hj4Ov3rIwAAdHIIAIOCEiTdtzvx/PVQEt1yXOyS\nKTflM7Q5dWYaZVBssWkv/HAkKMcP8ce2nGx77KjrXLLfs6MoEYqXtotkZjSzqGn2\njNDn1TBEErvNBefBUCZ1K7JoMjbWxd0fvps4mpaQhJdxm1V0ESY0Qdn0uGjEkwZA\nB+XGH1pZNuPKA+VK7nQwAiT+6k4KQTSyqmvlvgzHo5osZ5H8w99qel97SxYBVtG9\nHITYEsLsrO0vn9qbSiJxIrLsLZD80v5F4aK6RvckWMyk8A22IMtQxTS5jUS16kLJ\nEk9nOyWH/+Nl/4tkHno6R1NL9AV4UwxGC+fTbwGFthcVhWZ74/hCPhtEpzpZr2o=\n=H/kf\n-----END PGP SIGNATURE-----\n", "payload": "tree 7be8b4fbc2e7470bf7891d81b3812eb572bb0d1c\nparent ad239f6197bda31f7a9b904b5ccb25c93cbc701a\nparent 633aace41108b74fe6c93c5ab04272067db033f9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1596208171 +0000\ncommitter GitHub <noreply@github.com> 1596208171 +0000\n\nMerge #5624\n\n5624: Finalize expressions grammar r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7325283c6977e078513b5b21aa173775e2b22e12", "html_url": "https://github.com/rust-lang/rust/commit/7325283c6977e078513b5b21aa173775e2b22e12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7325283c6977e078513b5b21aa173775e2b22e12/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad239f6197bda31f7a9b904b5ccb25c93cbc701a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad239f6197bda31f7a9b904b5ccb25c93cbc701a", "html_url": "https://github.com/rust-lang/rust/commit/ad239f6197bda31f7a9b904b5ccb25c93cbc701a"}, {"sha": "633aace41108b74fe6c93c5ab04272067db033f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/633aace41108b74fe6c93c5ab04272067db033f9", "html_url": "https://github.com/rust-lang/rust/commit/633aace41108b74fe6c93c5ab04272067db033f9"}], "stats": {"total": 1742, "additions": 894, "deletions": 848}, "files": [{"sha": "cc62db0c446ae10041dd0b27e739350dcdc2b7d4", "filename": "crates/ra_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -1,7 +1,7 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::{\n-        BLOCK_EXPR, BREAK_EXPR, COMMENT, LAMBDA_EXPR, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n+        BLOCK_EXPR, BREAK_EXPR, CLOSURE_EXPR, COMMENT, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n     },\n     SyntaxNode,\n };\n@@ -148,7 +148,7 @@ impl Anchor {\n             }\n \n             if let Some(parent) = node.parent() {\n-                if parent.kind() == MATCH_ARM || parent.kind() == LAMBDA_EXPR {\n+                if parent.kind() == MATCH_ARM || parent.kind() == CLOSURE_EXPR {\n                     return Some(Anchor::WrapInBlock(node));\n                 }\n             }"}, {"sha": "99d72340259a84893c8e5eaf136079759d894cd6", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -224,9 +224,22 @@ impl ExprCollector<'_> {\n                     self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n                 }\n                 // FIXME: we need to record these effects somewhere...\n-                ast::Effect::Async(_) | ast::Effect::Label(_) => {\n-                    self.collect_block_opt(e.block_expr())\n-                }\n+                ast::Effect::Label(label) => match e.block_expr() {\n+                    Some(block) => {\n+                        let res = self.collect_block(block);\n+                        match &mut self.body.exprs[res] {\n+                            Expr::Block { label: block_label, .. } => {\n+                                *block_label =\n+                                    label.lifetime_token().map(|t| Name::new_lifetime(&t))\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                        res\n+                    }\n+                    None => self.missing_expr(),\n+                },\n+                // FIXME: we need to record these effects somewhere...\n+                ast::Effect::Async(_) => self.collect_block_opt(e.block_expr()),\n             },\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n@@ -460,7 +473,7 @@ impl ExprCollector<'_> {\n                     self.alloc_expr(Expr::Missing, syntax_ptr)\n                 }\n             }\n-            ast::Expr::LambdaExpr(e) => {\n+            ast::Expr::ClosureExpr(e) => {\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n@@ -618,8 +631,7 @@ impl ExprCollector<'_> {\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n-        let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n-        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n+        self.alloc_expr(Expr::Block { statements, tail, label: None }, syntax_node_ptr)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {"}, {"sha": "f3b7cd492c0bcf9d328a2a281312e360462eb5d5", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -379,7 +379,7 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n \n         FOR_EXPR => FragmentKind::Expr,\n         PATH_EXPR => FragmentKind::Expr,\n-        LAMBDA_EXPR => FragmentKind::Expr,\n+        CLOSURE_EXPR => FragmentKind::Expr,\n         CONDITION => FragmentKind::Expr,\n         BREAK_EXPR => FragmentKind::Expr,\n         RETURN_EXPR => FragmentKind::Expr,"}, {"sha": "9e654b373cbddb6b3aadc684a42db6504f546910", "filename": "crates/ra_ide/src/completion/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -134,7 +134,7 @@ pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n         NodeOrToken::Token(token) => token.parent(),\n     };\n     for node in leaf.ancestors() {\n-        if node.kind() == FN || node.kind() == LAMBDA_EXPR {\n+        if node.kind() == FN || node.kind() == CLOSURE_EXPR {\n             break;\n         }\n         let loop_body = match_ast! {"}, {"sha": "0b01d3bc64640f4d3e6aeb69ce3262757a7676cd", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -250,7 +250,7 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n             p.error(\"expected expression\");\n         }\n     }\n-    m.complete(p, LAMBDA_EXPR)\n+    m.complete(p, CLOSURE_EXPR)\n }\n \n // test if_expr"}, {"sha": "2830c0d74b3b07e900c82cdba252e1e87090eb5c", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -173,7 +173,7 @@ pub enum SyntaxKind {\n     ARRAY_EXPR,\n     PAREN_EXPR,\n     PATH_EXPR,\n-    LAMBDA_EXPR,\n+    CLOSURE_EXPR,\n     IF_EXPR,\n     WHILE_EXPR,\n     CONDITION,"}, {"sha": "158544fa2160e70b99c67c393d0960831db02b0a", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 664, "deletions": 661, "changes": 1325, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -349,7 +349,6 @@ pub struct BlockExpr {\n }\n impl ast::AttrsOwner for BlockExpr {}\n impl BlockExpr {\n-    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n     pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -468,6 +467,19 @@ impl ExternItemList {\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ConstParam {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ConstParam {}\n+impl ast::NameOwner for ConstParam {}\n+impl ConstParam {\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeParam {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -490,19 +502,6 @@ impl TypeParam {\n     pub fn default_type(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ConstParam {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ConstParam {}\n-impl ast::NameOwner for ConstParam {}\n-impl ConstParam {\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WherePred {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -519,6 +518,7 @@ impl WherePred {\n pub struct Literal {\n     pub(crate) syntax: SyntaxNode,\n }\n+impl ast::AttrsOwner for Literal {}\n impl Literal {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n@@ -533,6 +533,15 @@ impl TokenTree {\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExprStmt {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ExprStmt {}\n+impl ExprStmt {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -547,165 +556,191 @@ impl LetStmt {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ExprStmt {\n+pub struct ArrayExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ExprStmt {}\n-impl ExprStmt {\n+impl ast::AttrsOwner for ArrayExpr {}\n+impl ArrayExpr {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ParenType {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ParenType {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TupleType {\n+pub struct AwaitExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl TupleType {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn fields(&self) -> AstChildren<Type> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n+impl ast::AttrsOwner for AwaitExpr {}\n+impl AwaitExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n+    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct NeverType {\n+pub struct BinExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl NeverType {\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n-}\n+impl ast::AttrsOwner for BinExpr {}\n+impl BinExpr {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathType {\n+pub struct BoxExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl PathType {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for BoxExpr {}\n+impl BoxExpr {\n+    pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PointerType {\n+pub struct BreakExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl PointerType {\n-    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for BreakExpr {}\n+impl BreakExpr {\n+    pub fn break_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![break]) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n+    }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ArrayType {\n+pub struct CallExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ArrayType {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+impl ast::AttrsOwner for CallExpr {}\n+impl ast::ArgListOwner for CallExpr {}\n+impl CallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct SliceType {\n+pub struct CastExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl SliceType {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+impl ast::AttrsOwner for CastExpr {}\n+impl CastExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ReferenceType {\n+pub struct ContinueExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ReferenceType {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+impl ast::AttrsOwner for ContinueExpr {}\n+impl ContinueExpr {\n+    pub fn continue_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![continue])\n+    }\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct InferType {\n+pub struct EffectExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl InferType {\n-    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n+impl ast::AttrsOwner for EffectExpr {}\n+impl EffectExpr {\n+    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n+    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FnPointerType {\n+pub struct FieldExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl FnPointerType {\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n-    pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }\n-    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n-    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for FieldExpr {}\n+impl FieldExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ForType {\n+pub struct ForExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ForType {\n+impl ast::AttrsOwner for ForExpr {}\n+impl ast::LoopBodyOwner for ForExpr {}\n+impl ForExpr {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n-    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n+    pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ImplTraitType {\n+pub struct IfExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ImplTraitType {\n-    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n-    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for IfExpr {}\n+impl IfExpr {\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n+    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n+    pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct DynTraitType {\n+pub struct IndexExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl DynTraitType {\n-    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n-    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for IndexExpr {}\n+impl IndexExpr {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeBound {\n+pub struct Label {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl TypeBound {\n+impl Label {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TupleExpr {\n+pub struct ClosureExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for TupleExpr {}\n-impl TupleExpr {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n+impl ast::AttrsOwner for ClosureExpr {}\n+impl ClosureExpr {\n+    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn move_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![move]) }\n+    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n+    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n+    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ArrayExpr {\n+pub struct LoopExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ArrayExpr {}\n-impl ArrayExpr {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n+impl ast::AttrsOwner for LoopExpr {}\n+impl ast::LoopBodyOwner for LoopExpr {}\n+impl LoopExpr {\n+    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MatchExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for MatchExpr {}\n+impl MatchExpr {\n+    pub fn match_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![match]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n+    pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MethodCallExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for MethodCallExpr {}\n+impl ast::ArgListOwner for MethodCallExpr {}\n+impl MethodCallExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n@@ -721,82 +756,73 @@ impl ParenExpr {\n pub struct PathExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n+impl ast::AttrsOwner for PathExpr {}\n impl PathExpr {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LambdaExpr {\n+pub struct PrefixExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for LambdaExpr {}\n-impl LambdaExpr {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n-    pub fn move_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![move]) }\n-    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n-    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n-    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for PrefixExpr {}\n+impl PrefixExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct IfExpr {\n+pub struct RangeExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for IfExpr {}\n-impl IfExpr {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n-}\n+impl ast::AttrsOwner for RangeExpr {}\n+impl RangeExpr {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Condition {\n+pub struct RecordExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl Condition {\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl RecordExpr {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+    pub fn record_expr_field_list(&self) -> Option<RecordExprFieldList> {\n+        support::child(&self.syntax)\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct EffectExpr {\n+pub struct RefExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for EffectExpr {}\n-impl EffectExpr {\n-    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n-    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n-    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for RefExpr {}\n+impl RefExpr {\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![raw]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Label {\n+pub struct ReturnExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl Label {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n+impl ast::AttrsOwner for ReturnExpr {}\n+impl ReturnExpr {\n+    pub fn return_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![return]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LoopExpr {\n+pub struct TryExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for LoopExpr {}\n-impl ast::LoopBodyOwner for LoopExpr {}\n-impl LoopExpr {\n-    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n+impl ast::AttrsOwner for TryExpr {}\n+impl TryExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ForExpr {\n+pub struct TupleExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ForExpr {}\n-impl ast::LoopBodyOwner for ForExpr {}\n-impl ForExpr {\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n-    pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for TupleExpr {}\n+impl TupleExpr {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhileExpr {\n@@ -809,46 +835,25 @@ impl WhileExpr {\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ContinueExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ContinueExpr {}\n-impl ContinueExpr {\n-    pub fn continue_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![continue])\n-    }\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BreakExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for BreakExpr {}\n-impl BreakExpr {\n-    pub fn break_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![break]) }\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ReturnExpr {\n+pub struct RecordExprFieldList {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ReturnExpr {}\n-impl ReturnExpr {\n-    pub fn return_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![return]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for RecordExprFieldList {}\n+impl RecordExprFieldList {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn fields(&self) -> AstChildren<RecordExprField> { support::children(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n+    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct CallExpr {\n+pub struct RecordExprField {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for CallExpr {}\n-impl ast::ArgListOwner for CallExpr {}\n-impl CallExpr {\n+impl ast::AttrsOwner for RecordExprField {}\n+impl RecordExprField {\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -861,18 +866,6 @@ impl ArgList {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MethodCallExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for MethodCallExpr {}\n-impl ast::ArgListOwner for MethodCallExpr {}\n-impl MethodCallExpr {\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -886,162 +879,174 @@ impl TypeArgList {\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FieldExpr {\n+pub struct Condition {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for FieldExpr {}\n-impl FieldExpr {\n+impl Condition {\n+    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct IndexExpr {\n+pub struct MatchArmList {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for IndexExpr {}\n-impl IndexExpr {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n+impl ast::AttrsOwner for MatchArmList {}\n+impl MatchArmList {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct AwaitExpr {\n+pub struct MatchArm {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for AwaitExpr {}\n-impl AwaitExpr {\n+impl ast::AttrsOwner for MatchArm {}\n+impl MatchArm {\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n+    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n-    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n+    pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TryExpr {\n+pub struct MatchGuard {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for TryExpr {}\n-impl TryExpr {\n+impl MatchGuard {\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct CastExpr {\n+pub struct ArrayType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for CastExpr {}\n-impl CastExpr {\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n+impl ArrayType {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RefExpr {\n+pub struct DynTraitType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for RefExpr {}\n-impl RefExpr {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n-    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![raw]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+impl DynTraitType {\n+    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n+    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FnPointerType {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl FnPointerType {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n+    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }\n+    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n+    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PrefixExpr {\n+pub struct ForType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for PrefixExpr {}\n-impl PrefixExpr {\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ForType {\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n+    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BoxExpr {\n+pub struct ImplTraitType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for BoxExpr {}\n-impl BoxExpr {\n-    pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ImplTraitType {\n+    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n+    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RangeExpr {\n+pub struct InferType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for RangeExpr {}\n-impl RangeExpr {}\n+impl InferType {\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n+}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BinExpr {\n+pub struct NeverType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for BinExpr {}\n-impl BinExpr {}\n+impl NeverType {\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n+}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchExpr {\n+pub struct ParenType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for MatchExpr {}\n-impl MatchExpr {\n-    pub fn match_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![match]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n+impl ParenType {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchArmList {\n+pub struct PathType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl MatchArmList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+impl PathType {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchArm {\n+pub struct PointerType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for MatchArm {}\n-impl MatchArm {\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n-    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl PointerType {\n+    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchGuard {\n+pub struct ReferenceType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl MatchGuard {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ReferenceType {\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n+    }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordExpr {\n+pub struct SliceType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl RecordExpr {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn record_expr_field_list(&self) -> Option<RecordExprFieldList> {\n-        support::child(&self.syntax)\n-    }\n+impl SliceType {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordExprFieldList {\n+pub struct TupleType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl RecordExprFieldList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn fields(&self) -> AstChildren<RecordExprField> { support::children(&self.syntax) }\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n-    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+impl TupleType {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn fields(&self) -> AstChildren<Type> { support::children(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordExprField {\n+pub struct TypeBound {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for RecordExprField {}\n-impl RecordExprField {\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl TypeBound {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n+    }\n+    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct OrPat {\n@@ -1285,19 +1290,19 @@ pub enum Item {\n impl ast::AttrsOwner for Item {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Type {\n-    ParenType(ParenType),\n-    TupleType(TupleType),\n-    NeverType(NeverType),\n-    PathType(PathType),\n-    PointerType(PointerType),\n     ArrayType(ArrayType),\n-    SliceType(SliceType),\n-    ReferenceType(ReferenceType),\n-    InferType(InferType),\n+    DynTraitType(DynTraitType),\n     FnPointerType(FnPointerType),\n     ForType(ForType),\n     ImplTraitType(ImplTraitType),\n-    DynTraitType(DynTraitType),\n+    InferType(InferType),\n+    NeverType(NeverType),\n+    ParenType(ParenType),\n+    PathType(PathType),\n+    PointerType(PointerType),\n+    ReferenceType(ReferenceType),\n+    SliceType(SliceType),\n+    TupleType(TupleType),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n@@ -1324,42 +1329,42 @@ pub enum FieldList {\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Expr {\n-    TupleExpr(TupleExpr),\n     ArrayExpr(ArrayExpr),\n-    ParenExpr(ParenExpr),\n-    PathExpr(PathExpr),\n-    LambdaExpr(LambdaExpr),\n-    IfExpr(IfExpr),\n-    LoopExpr(LoopExpr),\n-    ForExpr(ForExpr),\n-    WhileExpr(WhileExpr),\n-    ContinueExpr(ContinueExpr),\n-    BreakExpr(BreakExpr),\n-    Label(Label),\n+    AwaitExpr(AwaitExpr),\n+    BinExpr(BinExpr),\n     BlockExpr(BlockExpr),\n-    ReturnExpr(ReturnExpr),\n-    MatchExpr(MatchExpr),\n-    RecordExpr(RecordExpr),\n+    BoxExpr(BoxExpr),\n+    BreakExpr(BreakExpr),\n     CallExpr(CallExpr),\n+    CastExpr(CastExpr),\n+    ContinueExpr(ContinueExpr),\n+    EffectExpr(EffectExpr),\n+    FieldExpr(FieldExpr),\n+    ForExpr(ForExpr),\n+    IfExpr(IfExpr),\n     IndexExpr(IndexExpr),\n+    Label(Label),\n+    ClosureExpr(ClosureExpr),\n+    Literal(Literal),\n+    LoopExpr(LoopExpr),\n+    MacroCall(MacroCall),\n+    MatchExpr(MatchExpr),\n     MethodCallExpr(MethodCallExpr),\n-    FieldExpr(FieldExpr),\n-    AwaitExpr(AwaitExpr),\n-    TryExpr(TryExpr),\n-    EffectExpr(EffectExpr),\n-    CastExpr(CastExpr),\n-    RefExpr(RefExpr),\n+    ParenExpr(ParenExpr),\n+    PathExpr(PathExpr),\n     PrefixExpr(PrefixExpr),\n     RangeExpr(RangeExpr),\n-    BinExpr(BinExpr),\n-    Literal(Literal),\n-    MacroCall(MacroCall),\n-    BoxExpr(BoxExpr),\n+    RecordExpr(RecordExpr),\n+    RefExpr(RefExpr),\n+    ReturnExpr(ReturnExpr),\n+    TryExpr(TryExpr),\n+    TupleExpr(TupleExpr),\n+    WhileExpr(WhileExpr),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AdtDef {\n-    Struct(Struct),\n     Enum(Enum),\n+    Struct(Struct),\n     Union(Union),\n }\n impl ast::AttrsOwner for AdtDef {}\n@@ -1368,10 +1373,10 @@ impl ast::NameOwner for AdtDef {}\n impl ast::VisibilityOwner for AdtDef {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n-    Fn(Fn),\n-    TypeAlias(TypeAlias),\n     Const(Const),\n+    Fn(Fn),\n     MacroCall(MacroCall),\n+    TypeAlias(TypeAlias),\n }\n impl ast::AttrsOwner for AssocItem {}\n impl ast::NameOwner for AssocItem {}\n@@ -1385,16 +1390,16 @@ impl ast::AttrsOwner for ExternItem {}\n impl ast::NameOwner for ExternItem {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericParam {\n+    ConstParam(ConstParam),\n     LifetimeParam(LifetimeParam),\n     TypeParam(TypeParam),\n-    ConstParam(ConstParam),\n }\n impl ast::AttrsOwner for GenericParam {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Stmt {\n-    LetStmt(LetStmt),\n     ExprStmt(ExprStmt),\n     Item(Item),\n+    LetStmt(LetStmt),\n }\n impl AstNode for SourceFile {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n@@ -1847,8 +1852,8 @@ impl AstNode for ExternItemList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LifetimeParam {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_PARAM }\n+impl AstNode for ConstParam {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1858,8 +1863,8 @@ impl AstNode for LifetimeParam {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeParam {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }\n+impl AstNode for LifetimeParam {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1869,8 +1874,8 @@ impl AstNode for TypeParam {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ConstParam {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_PARAM }\n+impl AstNode for TypeParam {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1913,8 +1918,8 @@ impl AstNode for TokenTree {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LetStmt {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }\n+impl AstNode for ExprStmt {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1924,8 +1929,8 @@ impl AstNode for LetStmt {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ExprStmt {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }\n+impl AstNode for LetStmt {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1935,8 +1940,8 @@ impl AstNode for ExprStmt {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ParenType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_TYPE }\n+impl AstNode for ArrayExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1946,8 +1951,8 @@ impl AstNode for ParenType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TupleType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_TYPE }\n+impl AstNode for AwaitExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AWAIT_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1957,8 +1962,8 @@ impl AstNode for TupleType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for NeverType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NEVER_TYPE }\n+impl AstNode for BinExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1968,8 +1973,8 @@ impl AstNode for NeverType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }\n+impl AstNode for BoxExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BOX_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1979,8 +1984,8 @@ impl AstNode for PathType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PointerType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == POINTER_TYPE }\n+impl AstNode for BreakExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1990,8 +1995,8 @@ impl AstNode for PointerType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ArrayType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_TYPE }\n+impl AstNode for CallExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2001,8 +2006,8 @@ impl AstNode for ArrayType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for SliceType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_TYPE }\n+impl AstNode for CastExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CAST_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2012,8 +2017,8 @@ impl AstNode for SliceType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ReferenceType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == REFERENCE_TYPE }\n+impl AstNode for ContinueExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2023,8 +2028,8 @@ impl AstNode for ReferenceType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for InferType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == INFER_TYPE }\n+impl AstNode for EffectExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EFFECT_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2034,8 +2039,8 @@ impl AstNode for InferType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for FnPointerType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_POINTER_TYPE }\n+impl AstNode for FieldExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FIELD_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2045,8 +2050,8 @@ impl AstNode for FnPointerType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ForType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_TYPE }\n+impl AstNode for ForExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2056,8 +2061,8 @@ impl AstNode for ForType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ImplTraitType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_TRAIT_TYPE }\n+impl AstNode for IfExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2067,8 +2072,8 @@ impl AstNode for ImplTraitType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for DynTraitType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DYN_TRAIT_TYPE }\n+impl AstNode for IndexExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == INDEX_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2078,8 +2083,8 @@ impl AstNode for DynTraitType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeBound {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND }\n+impl AstNode for Label {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LABEL }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2089,8 +2094,8 @@ impl AstNode for TypeBound {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TupleExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_EXPR }\n+impl AstNode for ClosureExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CLOSURE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2100,8 +2105,8 @@ impl AstNode for TupleExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ArrayExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_EXPR }\n+impl AstNode for LoopExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2111,8 +2116,8 @@ impl AstNode for ArrayExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ParenExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }\n+impl AstNode for MatchExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2122,8 +2127,8 @@ impl AstNode for ParenExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }\n+impl AstNode for MethodCallExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == METHOD_CALL_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2133,8 +2138,8 @@ impl AstNode for PathExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LambdaExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_EXPR }\n+impl AstNode for ParenExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2144,8 +2149,8 @@ impl AstNode for LambdaExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for IfExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_EXPR }\n+impl AstNode for PathExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2155,8 +2160,8 @@ impl AstNode for IfExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Condition {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION }\n+impl AstNode for PrefixExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PREFIX_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2166,8 +2171,8 @@ impl AstNode for Condition {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for EffectExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EFFECT_EXPR }\n+impl AstNode for RangeExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2177,8 +2182,8 @@ impl AstNode for EffectExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Label {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LABEL }\n+impl AstNode for RecordExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2188,8 +2193,8 @@ impl AstNode for Label {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LoopExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_EXPR }\n+impl AstNode for RefExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2199,8 +2204,8 @@ impl AstNode for LoopExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ForExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }\n+impl AstNode for ReturnExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2210,8 +2215,8 @@ impl AstNode for ForExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for WhileExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_EXPR }\n+impl AstNode for TryExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2221,8 +2226,8 @@ impl AstNode for WhileExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ContinueExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_EXPR }\n+impl AstNode for TupleExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2232,8 +2237,8 @@ impl AstNode for ContinueExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BreakExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_EXPR }\n+impl AstNode for WhileExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2243,8 +2248,8 @@ impl AstNode for BreakExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ReturnExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_EXPR }\n+impl AstNode for RecordExprFieldList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2254,8 +2259,8 @@ impl AstNode for ReturnExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for CallExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL_EXPR }\n+impl AstNode for RecordExprField {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2276,8 +2281,8 @@ impl AstNode for ArgList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MethodCallExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == METHOD_CALL_EXPR }\n+impl AstNode for TypeArgList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2287,8 +2292,8 @@ impl AstNode for MethodCallExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeArgList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }\n+impl AstNode for Condition {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2298,8 +2303,8 @@ impl AstNode for TypeArgList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for FieldExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FIELD_EXPR }\n+impl AstNode for MatchArmList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2309,8 +2314,8 @@ impl AstNode for FieldExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for IndexExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == INDEX_EXPR }\n+impl AstNode for MatchArm {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2320,8 +2325,8 @@ impl AstNode for IndexExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for AwaitExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == AWAIT_EXPR }\n+impl AstNode for MatchGuard {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_GUARD }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2331,8 +2336,8 @@ impl AstNode for AwaitExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TryExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_EXPR }\n+impl AstNode for ArrayType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2342,8 +2347,8 @@ impl AstNode for TryExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for CastExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CAST_EXPR }\n+impl AstNode for DynTraitType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DYN_TRAIT_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2353,8 +2358,8 @@ impl AstNode for CastExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RefExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_EXPR }\n+impl AstNode for FnPointerType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_POINTER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2364,8 +2369,8 @@ impl AstNode for RefExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PrefixExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PREFIX_EXPR }\n+impl AstNode for ForType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2375,8 +2380,8 @@ impl AstNode for PrefixExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BoxExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BOX_EXPR }\n+impl AstNode for ImplTraitType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_TRAIT_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2386,8 +2391,8 @@ impl AstNode for BoxExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RangeExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_EXPR }\n+impl AstNode for InferType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == INFER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2397,8 +2402,8 @@ impl AstNode for RangeExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BinExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }\n+impl AstNode for NeverType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NEVER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2408,8 +2413,8 @@ impl AstNode for BinExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_EXPR }\n+impl AstNode for ParenType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2419,8 +2424,8 @@ impl AstNode for MatchExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchArmList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM_LIST }\n+impl AstNode for PathType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2430,8 +2435,8 @@ impl AstNode for MatchArmList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchArm {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM }\n+impl AstNode for PointerType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == POINTER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2441,8 +2446,8 @@ impl AstNode for MatchArm {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchGuard {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_GUARD }\n+impl AstNode for ReferenceType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == REFERENCE_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2452,8 +2457,8 @@ impl AstNode for MatchGuard {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR }\n+impl AstNode for SliceType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2463,8 +2468,8 @@ impl AstNode for RecordExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordExprFieldList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD_LIST }\n+impl AstNode for TupleType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2474,8 +2479,8 @@ impl AstNode for RecordExprFieldList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordExprField {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD }\n+impl AstNode for TypeBound {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2849,88 +2854,88 @@ impl AstNode for Item {\n         }\n     }\n }\n-impl From<ParenType> for Type {\n-    fn from(node: ParenType) -> Type { Type::ParenType(node) }\n+impl From<ArrayType> for Type {\n+    fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n }\n-impl From<TupleType> for Type {\n-    fn from(node: TupleType) -> Type { Type::TupleType(node) }\n+impl From<DynTraitType> for Type {\n+    fn from(node: DynTraitType) -> Type { Type::DynTraitType(node) }\n+}\n+impl From<FnPointerType> for Type {\n+    fn from(node: FnPointerType) -> Type { Type::FnPointerType(node) }\n+}\n+impl From<ForType> for Type {\n+    fn from(node: ForType) -> Type { Type::ForType(node) }\n+}\n+impl From<ImplTraitType> for Type {\n+    fn from(node: ImplTraitType) -> Type { Type::ImplTraitType(node) }\n+}\n+impl From<InferType> for Type {\n+    fn from(node: InferType) -> Type { Type::InferType(node) }\n }\n impl From<NeverType> for Type {\n     fn from(node: NeverType) -> Type { Type::NeverType(node) }\n }\n+impl From<ParenType> for Type {\n+    fn from(node: ParenType) -> Type { Type::ParenType(node) }\n+}\n impl From<PathType> for Type {\n     fn from(node: PathType) -> Type { Type::PathType(node) }\n }\n impl From<PointerType> for Type {\n     fn from(node: PointerType) -> Type { Type::PointerType(node) }\n }\n-impl From<ArrayType> for Type {\n-    fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n-}\n-impl From<SliceType> for Type {\n-    fn from(node: SliceType) -> Type { Type::SliceType(node) }\n-}\n impl From<ReferenceType> for Type {\n     fn from(node: ReferenceType) -> Type { Type::ReferenceType(node) }\n }\n-impl From<InferType> for Type {\n-    fn from(node: InferType) -> Type { Type::InferType(node) }\n-}\n-impl From<FnPointerType> for Type {\n-    fn from(node: FnPointerType) -> Type { Type::FnPointerType(node) }\n-}\n-impl From<ForType> for Type {\n-    fn from(node: ForType) -> Type { Type::ForType(node) }\n-}\n-impl From<ImplTraitType> for Type {\n-    fn from(node: ImplTraitType) -> Type { Type::ImplTraitType(node) }\n+impl From<SliceType> for Type {\n+    fn from(node: SliceType) -> Type { Type::SliceType(node) }\n }\n-impl From<DynTraitType> for Type {\n-    fn from(node: DynTraitType) -> Type { Type::DynTraitType(node) }\n+impl From<TupleType> for Type {\n+    fn from(node: TupleType) -> Type { Type::TupleType(node) }\n }\n impl AstNode for Type {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE\n-            | SLICE_TYPE | REFERENCE_TYPE | INFER_TYPE | FN_POINTER_TYPE | FOR_TYPE\n-            | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,\n+            ARRAY_TYPE | DYN_TRAIT_TYPE | FN_POINTER_TYPE | FOR_TYPE | IMPL_TRAIT_TYPE\n+            | INFER_TYPE | NEVER_TYPE | PAREN_TYPE | PATH_TYPE | POINTER_TYPE | REFERENCE_TYPE\n+            | SLICE_TYPE | TUPLE_TYPE => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            PAREN_TYPE => Type::ParenType(ParenType { syntax }),\n-            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),\n-            NEVER_TYPE => Type::NeverType(NeverType { syntax }),\n-            PATH_TYPE => Type::PathType(PathType { syntax }),\n-            POINTER_TYPE => Type::PointerType(PointerType { syntax }),\n             ARRAY_TYPE => Type::ArrayType(ArrayType { syntax }),\n-            SLICE_TYPE => Type::SliceType(SliceType { syntax }),\n-            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),\n-            INFER_TYPE => Type::InferType(InferType { syntax }),\n+            DYN_TRAIT_TYPE => Type::DynTraitType(DynTraitType { syntax }),\n             FN_POINTER_TYPE => Type::FnPointerType(FnPointerType { syntax }),\n             FOR_TYPE => Type::ForType(ForType { syntax }),\n             IMPL_TRAIT_TYPE => Type::ImplTraitType(ImplTraitType { syntax }),\n-            DYN_TRAIT_TYPE => Type::DynTraitType(DynTraitType { syntax }),\n+            INFER_TYPE => Type::InferType(InferType { syntax }),\n+            NEVER_TYPE => Type::NeverType(NeverType { syntax }),\n+            PAREN_TYPE => Type::ParenType(ParenType { syntax }),\n+            PATH_TYPE => Type::PathType(PathType { syntax }),\n+            POINTER_TYPE => Type::PointerType(PointerType { syntax }),\n+            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),\n+            SLICE_TYPE => Type::SliceType(SliceType { syntax }),\n+            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            Type::ParenType(it) => &it.syntax,\n-            Type::TupleType(it) => &it.syntax,\n-            Type::NeverType(it) => &it.syntax,\n-            Type::PathType(it) => &it.syntax,\n-            Type::PointerType(it) => &it.syntax,\n             Type::ArrayType(it) => &it.syntax,\n-            Type::SliceType(it) => &it.syntax,\n-            Type::ReferenceType(it) => &it.syntax,\n-            Type::InferType(it) => &it.syntax,\n+            Type::DynTraitType(it) => &it.syntax,\n             Type::FnPointerType(it) => &it.syntax,\n             Type::ForType(it) => &it.syntax,\n             Type::ImplTraitType(it) => &it.syntax,\n-            Type::DynTraitType(it) => &it.syntax,\n+            Type::InferType(it) => &it.syntax,\n+            Type::NeverType(it) => &it.syntax,\n+            Type::ParenType(it) => &it.syntax,\n+            Type::PathType(it) => &it.syntax,\n+            Type::PointerType(it) => &it.syntax,\n+            Type::ReferenceType(it) => &it.syntax,\n+            Type::SliceType(it) => &it.syntax,\n+            Type::TupleType(it) => &it.syntax,\n         }\n     }\n }\n@@ -3057,253 +3062,251 @@ impl AstNode for FieldList {\n         }\n     }\n }\n-impl From<TupleExpr> for Expr {\n-    fn from(node: TupleExpr) -> Expr { Expr::TupleExpr(node) }\n-}\n impl From<ArrayExpr> for Expr {\n     fn from(node: ArrayExpr) -> Expr { Expr::ArrayExpr(node) }\n }\n-impl From<ParenExpr> for Expr {\n-    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }\n+impl From<AwaitExpr> for Expr {\n+    fn from(node: AwaitExpr) -> Expr { Expr::AwaitExpr(node) }\n }\n-impl From<PathExpr> for Expr {\n-    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }\n+impl From<BinExpr> for Expr {\n+    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }\n }\n-impl From<LambdaExpr> for Expr {\n-    fn from(node: LambdaExpr) -> Expr { Expr::LambdaExpr(node) }\n+impl From<BlockExpr> for Expr {\n+    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }\n }\n-impl From<IfExpr> for Expr {\n-    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }\n+impl From<BoxExpr> for Expr {\n+    fn from(node: BoxExpr) -> Expr { Expr::BoxExpr(node) }\n }\n-impl From<LoopExpr> for Expr {\n-    fn from(node: LoopExpr) -> Expr { Expr::LoopExpr(node) }\n+impl From<BreakExpr> for Expr {\n+    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }\n }\n-impl From<ForExpr> for Expr {\n-    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }\n+impl From<CallExpr> for Expr {\n+    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }\n }\n-impl From<WhileExpr> for Expr {\n-    fn from(node: WhileExpr) -> Expr { Expr::WhileExpr(node) }\n+impl From<CastExpr> for Expr {\n+    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }\n }\n impl From<ContinueExpr> for Expr {\n     fn from(node: ContinueExpr) -> Expr { Expr::ContinueExpr(node) }\n }\n-impl From<BreakExpr> for Expr {\n-    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }\n-}\n-impl From<Label> for Expr {\n-    fn from(node: Label) -> Expr { Expr::Label(node) }\n-}\n-impl From<BlockExpr> for Expr {\n-    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }\n-}\n-impl From<ReturnExpr> for Expr {\n-    fn from(node: ReturnExpr) -> Expr { Expr::ReturnExpr(node) }\n+impl From<EffectExpr> for Expr {\n+    fn from(node: EffectExpr) -> Expr { Expr::EffectExpr(node) }\n }\n-impl From<MatchExpr> for Expr {\n-    fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n+impl From<FieldExpr> for Expr {\n+    fn from(node: FieldExpr) -> Expr { Expr::FieldExpr(node) }\n }\n-impl From<RecordExpr> for Expr {\n-    fn from(node: RecordExpr) -> Expr { Expr::RecordExpr(node) }\n+impl From<ForExpr> for Expr {\n+    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }\n }\n-impl From<CallExpr> for Expr {\n-    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }\n+impl From<IfExpr> for Expr {\n+    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }\n }\n impl From<IndexExpr> for Expr {\n     fn from(node: IndexExpr) -> Expr { Expr::IndexExpr(node) }\n }\n-impl From<MethodCallExpr> for Expr {\n-    fn from(node: MethodCallExpr) -> Expr { Expr::MethodCallExpr(node) }\n+impl From<Label> for Expr {\n+    fn from(node: Label) -> Expr { Expr::Label(node) }\n }\n-impl From<FieldExpr> for Expr {\n-    fn from(node: FieldExpr) -> Expr { Expr::FieldExpr(node) }\n+impl From<ClosureExpr> for Expr {\n+    fn from(node: ClosureExpr) -> Expr { Expr::ClosureExpr(node) }\n }\n-impl From<AwaitExpr> for Expr {\n-    fn from(node: AwaitExpr) -> Expr { Expr::AwaitExpr(node) }\n+impl From<Literal> for Expr {\n+    fn from(node: Literal) -> Expr { Expr::Literal(node) }\n }\n-impl From<TryExpr> for Expr {\n-    fn from(node: TryExpr) -> Expr { Expr::TryExpr(node) }\n+impl From<LoopExpr> for Expr {\n+    fn from(node: LoopExpr) -> Expr { Expr::LoopExpr(node) }\n }\n-impl From<EffectExpr> for Expr {\n-    fn from(node: EffectExpr) -> Expr { Expr::EffectExpr(node) }\n+impl From<MacroCall> for Expr {\n+    fn from(node: MacroCall) -> Expr { Expr::MacroCall(node) }\n }\n-impl From<CastExpr> for Expr {\n-    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }\n+impl From<MatchExpr> for Expr {\n+    fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n }\n-impl From<RefExpr> for Expr {\n-    fn from(node: RefExpr) -> Expr { Expr::RefExpr(node) }\n+impl From<MethodCallExpr> for Expr {\n+    fn from(node: MethodCallExpr) -> Expr { Expr::MethodCallExpr(node) }\n+}\n+impl From<ParenExpr> for Expr {\n+    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }\n+}\n+impl From<PathExpr> for Expr {\n+    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }\n }\n impl From<PrefixExpr> for Expr {\n     fn from(node: PrefixExpr) -> Expr { Expr::PrefixExpr(node) }\n }\n impl From<RangeExpr> for Expr {\n     fn from(node: RangeExpr) -> Expr { Expr::RangeExpr(node) }\n }\n-impl From<BinExpr> for Expr {\n-    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }\n+impl From<RecordExpr> for Expr {\n+    fn from(node: RecordExpr) -> Expr { Expr::RecordExpr(node) }\n+}\n+impl From<RefExpr> for Expr {\n+    fn from(node: RefExpr) -> Expr { Expr::RefExpr(node) }\n+}\n+impl From<ReturnExpr> for Expr {\n+    fn from(node: ReturnExpr) -> Expr { Expr::ReturnExpr(node) }\n }\n-impl From<Literal> for Expr {\n-    fn from(node: Literal) -> Expr { Expr::Literal(node) }\n+impl From<TryExpr> for Expr {\n+    fn from(node: TryExpr) -> Expr { Expr::TryExpr(node) }\n }\n-impl From<MacroCall> for Expr {\n-    fn from(node: MacroCall) -> Expr { Expr::MacroCall(node) }\n+impl From<TupleExpr> for Expr {\n+    fn from(node: TupleExpr) -> Expr { Expr::TupleExpr(node) }\n }\n-impl From<BoxExpr> for Expr {\n-    fn from(node: BoxExpr) -> Expr { Expr::BoxExpr(node) }\n+impl From<WhileExpr> for Expr {\n+    fn from(node: WhileExpr) -> Expr { Expr::WhileExpr(node) }\n }\n impl AstNode for Expr {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR\n-            | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL\n-            | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | RECORD_EXPR | CALL_EXPR | INDEX_EXPR\n-            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | EFFECT_EXPR | CAST_EXPR\n-            | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL | BOX_EXPR => {\n-                true\n-            }\n+            ARRAY_EXPR | AWAIT_EXPR | BIN_EXPR | BLOCK_EXPR | BOX_EXPR | BREAK_EXPR | CALL_EXPR\n+            | CAST_EXPR | CONTINUE_EXPR | EFFECT_EXPR | FIELD_EXPR | FOR_EXPR | IF_EXPR\n+            | INDEX_EXPR | LABEL | CLOSURE_EXPR | LITERAL | LOOP_EXPR | MACRO_CALL | MATCH_EXPR\n+            | METHOD_CALL_EXPR | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR | RANGE_EXPR\n+            | RECORD_EXPR | REF_EXPR | RETURN_EXPR | TRY_EXPR | TUPLE_EXPR | WHILE_EXPR => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),\n             ARRAY_EXPR => Expr::ArrayExpr(ArrayExpr { syntax }),\n-            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n-            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),\n-            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),\n-            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),\n-            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n-            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),\n-            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),\n-            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),\n-            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),\n-            LABEL => Expr::Label(Label { syntax }),\n+            AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),\n+            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),\n             BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),\n-            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),\n-            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n-            RECORD_EXPR => Expr::RecordExpr(RecordExpr { syntax }),\n+            BOX_EXPR => Expr::BoxExpr(BoxExpr { syntax }),\n+            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),\n             CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),\n+            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),\n+            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),\n+            EFFECT_EXPR => Expr::EffectExpr(EffectExpr { syntax }),\n+            FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),\n+            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),\n+            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),\n             INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),\n+            LABEL => Expr::Label(Label { syntax }),\n+            CLOSURE_EXPR => Expr::ClosureExpr(ClosureExpr { syntax }),\n+            LITERAL => Expr::Literal(Literal { syntax }),\n+            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n+            MACRO_CALL => Expr::MacroCall(MacroCall { syntax }),\n+            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n             METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n-            FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),\n-            AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),\n-            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),\n-            EFFECT_EXPR => Expr::EffectExpr(EffectExpr { syntax }),\n-            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),\n-            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),\n+            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n+            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),\n             PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),\n             RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),\n-            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),\n-            LITERAL => Expr::Literal(Literal { syntax }),\n-            MACRO_CALL => Expr::MacroCall(MacroCall { syntax }),\n-            BOX_EXPR => Expr::BoxExpr(BoxExpr { syntax }),\n+            RECORD_EXPR => Expr::RecordExpr(RecordExpr { syntax }),\n+            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),\n+            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),\n+            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),\n+            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),\n+            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            Expr::TupleExpr(it) => &it.syntax,\n             Expr::ArrayExpr(it) => &it.syntax,\n-            Expr::ParenExpr(it) => &it.syntax,\n-            Expr::PathExpr(it) => &it.syntax,\n-            Expr::LambdaExpr(it) => &it.syntax,\n-            Expr::IfExpr(it) => &it.syntax,\n-            Expr::LoopExpr(it) => &it.syntax,\n-            Expr::ForExpr(it) => &it.syntax,\n-            Expr::WhileExpr(it) => &it.syntax,\n-            Expr::ContinueExpr(it) => &it.syntax,\n-            Expr::BreakExpr(it) => &it.syntax,\n-            Expr::Label(it) => &it.syntax,\n+            Expr::AwaitExpr(it) => &it.syntax,\n+            Expr::BinExpr(it) => &it.syntax,\n             Expr::BlockExpr(it) => &it.syntax,\n-            Expr::ReturnExpr(it) => &it.syntax,\n-            Expr::MatchExpr(it) => &it.syntax,\n-            Expr::RecordExpr(it) => &it.syntax,\n+            Expr::BoxExpr(it) => &it.syntax,\n+            Expr::BreakExpr(it) => &it.syntax,\n             Expr::CallExpr(it) => &it.syntax,\n+            Expr::CastExpr(it) => &it.syntax,\n+            Expr::ContinueExpr(it) => &it.syntax,\n+            Expr::EffectExpr(it) => &it.syntax,\n+            Expr::FieldExpr(it) => &it.syntax,\n+            Expr::ForExpr(it) => &it.syntax,\n+            Expr::IfExpr(it) => &it.syntax,\n             Expr::IndexExpr(it) => &it.syntax,\n+            Expr::Label(it) => &it.syntax,\n+            Expr::ClosureExpr(it) => &it.syntax,\n+            Expr::Literal(it) => &it.syntax,\n+            Expr::LoopExpr(it) => &it.syntax,\n+            Expr::MacroCall(it) => &it.syntax,\n+            Expr::MatchExpr(it) => &it.syntax,\n             Expr::MethodCallExpr(it) => &it.syntax,\n-            Expr::FieldExpr(it) => &it.syntax,\n-            Expr::AwaitExpr(it) => &it.syntax,\n-            Expr::TryExpr(it) => &it.syntax,\n-            Expr::EffectExpr(it) => &it.syntax,\n-            Expr::CastExpr(it) => &it.syntax,\n-            Expr::RefExpr(it) => &it.syntax,\n+            Expr::ParenExpr(it) => &it.syntax,\n+            Expr::PathExpr(it) => &it.syntax,\n             Expr::PrefixExpr(it) => &it.syntax,\n             Expr::RangeExpr(it) => &it.syntax,\n-            Expr::BinExpr(it) => &it.syntax,\n-            Expr::Literal(it) => &it.syntax,\n-            Expr::MacroCall(it) => &it.syntax,\n-            Expr::BoxExpr(it) => &it.syntax,\n+            Expr::RecordExpr(it) => &it.syntax,\n+            Expr::RefExpr(it) => &it.syntax,\n+            Expr::ReturnExpr(it) => &it.syntax,\n+            Expr::TryExpr(it) => &it.syntax,\n+            Expr::TupleExpr(it) => &it.syntax,\n+            Expr::WhileExpr(it) => &it.syntax,\n         }\n     }\n }\n-impl From<Struct> for AdtDef {\n-    fn from(node: Struct) -> AdtDef { AdtDef::Struct(node) }\n-}\n impl From<Enum> for AdtDef {\n     fn from(node: Enum) -> AdtDef { AdtDef::Enum(node) }\n }\n+impl From<Struct> for AdtDef {\n+    fn from(node: Struct) -> AdtDef { AdtDef::Struct(node) }\n+}\n impl From<Union> for AdtDef {\n     fn from(node: Union) -> AdtDef { AdtDef::Union(node) }\n }\n impl AstNode for AdtDef {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            STRUCT | ENUM | UNION => true,\n+            ENUM | STRUCT | UNION => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            STRUCT => AdtDef::Struct(Struct { syntax }),\n             ENUM => AdtDef::Enum(Enum { syntax }),\n+            STRUCT => AdtDef::Struct(Struct { syntax }),\n             UNION => AdtDef::Union(Union { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            AdtDef::Struct(it) => &it.syntax,\n             AdtDef::Enum(it) => &it.syntax,\n+            AdtDef::Struct(it) => &it.syntax,\n             AdtDef::Union(it) => &it.syntax,\n         }\n     }\n }\n-impl From<Fn> for AssocItem {\n-    fn from(node: Fn) -> AssocItem { AssocItem::Fn(node) }\n-}\n-impl From<TypeAlias> for AssocItem {\n-    fn from(node: TypeAlias) -> AssocItem { AssocItem::TypeAlias(node) }\n-}\n impl From<Const> for AssocItem {\n     fn from(node: Const) -> AssocItem { AssocItem::Const(node) }\n }\n+impl From<Fn> for AssocItem {\n+    fn from(node: Fn) -> AssocItem { AssocItem::Fn(node) }\n+}\n impl From<MacroCall> for AssocItem {\n     fn from(node: MacroCall) -> AssocItem { AssocItem::MacroCall(node) }\n }\n+impl From<TypeAlias> for AssocItem {\n+    fn from(node: TypeAlias) -> AssocItem { AssocItem::TypeAlias(node) }\n+}\n impl AstNode for AssocItem {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            FN | TYPE_ALIAS | CONST | MACRO_CALL => true,\n+            CONST | FN | MACRO_CALL | TYPE_ALIAS => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            FN => AssocItem::Fn(Fn { syntax }),\n-            TYPE_ALIAS => AssocItem::TypeAlias(TypeAlias { syntax }),\n             CONST => AssocItem::Const(Const { syntax }),\n+            FN => AssocItem::Fn(Fn { syntax }),\n             MACRO_CALL => AssocItem::MacroCall(MacroCall { syntax }),\n+            TYPE_ALIAS => AssocItem::TypeAlias(TypeAlias { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            AssocItem::Fn(it) => &it.syntax,\n-            AssocItem::TypeAlias(it) => &it.syntax,\n             AssocItem::Const(it) => &it.syntax,\n+            AssocItem::Fn(it) => &it.syntax,\n             AssocItem::MacroCall(it) => &it.syntax,\n+            AssocItem::TypeAlias(it) => &it.syntax,\n         }\n     }\n }\n@@ -3340,48 +3343,48 @@ impl AstNode for ExternItem {\n         }\n     }\n }\n+impl From<ConstParam> for GenericParam {\n+    fn from(node: ConstParam) -> GenericParam { GenericParam::ConstParam(node) }\n+}\n impl From<LifetimeParam> for GenericParam {\n     fn from(node: LifetimeParam) -> GenericParam { GenericParam::LifetimeParam(node) }\n }\n impl From<TypeParam> for GenericParam {\n     fn from(node: TypeParam) -> GenericParam { GenericParam::TypeParam(node) }\n }\n-impl From<ConstParam> for GenericParam {\n-    fn from(node: ConstParam) -> GenericParam { GenericParam::ConstParam(node) }\n-}\n impl AstNode for GenericParam {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            LIFETIME_PARAM | TYPE_PARAM | CONST_PARAM => true,\n+            CONST_PARAM | LIFETIME_PARAM | TYPE_PARAM => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n+            CONST_PARAM => GenericParam::ConstParam(ConstParam { syntax }),\n             LIFETIME_PARAM => GenericParam::LifetimeParam(LifetimeParam { syntax }),\n             TYPE_PARAM => GenericParam::TypeParam(TypeParam { syntax }),\n-            CONST_PARAM => GenericParam::ConstParam(ConstParam { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n+            GenericParam::ConstParam(it) => &it.syntax,\n             GenericParam::LifetimeParam(it) => &it.syntax,\n             GenericParam::TypeParam(it) => &it.syntax,\n-            GenericParam::ConstParam(it) => &it.syntax,\n         }\n     }\n }\n-impl From<LetStmt> for Stmt {\n-    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n-}\n impl From<ExprStmt> for Stmt {\n     fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }\n }\n impl From<Item> for Stmt {\n     fn from(node: Item) -> Stmt { Stmt::Item(node) }\n }\n+impl From<LetStmt> for Stmt {\n+    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n+}\n impl std::fmt::Display for Item {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3637,17 +3640,17 @@ impl std::fmt::Display for ExternItemList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LifetimeParam {\n+impl std::fmt::Display for ConstParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeParam {\n+impl std::fmt::Display for LifetimeParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ConstParam {\n+impl std::fmt::Display for TypeParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3667,162 +3670,162 @@ impl std::fmt::Display for TokenTree {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LetStmt {\n+impl std::fmt::Display for ExprStmt {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ExprStmt {\n+impl std::fmt::Display for LetStmt {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ParenType {\n+impl std::fmt::Display for ArrayExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TupleType {\n+impl std::fmt::Display for AwaitExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for NeverType {\n+impl std::fmt::Display for BinExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PathType {\n+impl std::fmt::Display for BoxExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PointerType {\n+impl std::fmt::Display for BreakExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ArrayType {\n+impl std::fmt::Display for CallExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for SliceType {\n+impl std::fmt::Display for CastExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ReferenceType {\n+impl std::fmt::Display for ContinueExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for InferType {\n+impl std::fmt::Display for EffectExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for FnPointerType {\n+impl std::fmt::Display for FieldExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ForType {\n+impl std::fmt::Display for ForExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ImplTraitType {\n+impl std::fmt::Display for IfExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for DynTraitType {\n+impl std::fmt::Display for IndexExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeBound {\n+impl std::fmt::Display for Label {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TupleExpr {\n+impl std::fmt::Display for ClosureExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ArrayExpr {\n+impl std::fmt::Display for LoopExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ParenExpr {\n+impl std::fmt::Display for MatchExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PathExpr {\n+impl std::fmt::Display for MethodCallExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LambdaExpr {\n+impl std::fmt::Display for ParenExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for IfExpr {\n+impl std::fmt::Display for PathExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Condition {\n+impl std::fmt::Display for PrefixExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for EffectExpr {\n+impl std::fmt::Display for RangeExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Label {\n+impl std::fmt::Display for RecordExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LoopExpr {\n+impl std::fmt::Display for RefExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ForExpr {\n+impl std::fmt::Display for ReturnExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for WhileExpr {\n+impl std::fmt::Display for TryExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ContinueExpr {\n+impl std::fmt::Display for TupleExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BreakExpr {\n+impl std::fmt::Display for WhileExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ReturnExpr {\n+impl std::fmt::Display for RecordExprFieldList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for CallExpr {\n+impl std::fmt::Display for RecordExprField {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3832,97 +3835,97 @@ impl std::fmt::Display for ArgList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MethodCallExpr {\n+impl std::fmt::Display for TypeArgList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeArgList {\n+impl std::fmt::Display for Condition {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for FieldExpr {\n+impl std::fmt::Display for MatchArmList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for IndexExpr {\n+impl std::fmt::Display for MatchArm {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for AwaitExpr {\n+impl std::fmt::Display for MatchGuard {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TryExpr {\n+impl std::fmt::Display for ArrayType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for CastExpr {\n+impl std::fmt::Display for DynTraitType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RefExpr {\n+impl std::fmt::Display for FnPointerType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PrefixExpr {\n+impl std::fmt::Display for ForType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BoxExpr {\n+impl std::fmt::Display for ImplTraitType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RangeExpr {\n+impl std::fmt::Display for InferType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BinExpr {\n+impl std::fmt::Display for NeverType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchExpr {\n+impl std::fmt::Display for ParenType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchArmList {\n+impl std::fmt::Display for PathType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchArm {\n+impl std::fmt::Display for PointerType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchGuard {\n+impl std::fmt::Display for ReferenceType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordExpr {\n+impl std::fmt::Display for SliceType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordExprFieldList {\n+impl std::fmt::Display for TupleType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordExprField {\n+impl std::fmt::Display for TypeBound {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }"}, {"sha": "e0f1d0c27499d1feaf414bb2c77a81c58e58476a", "filename": "crates/ra_syntax/test_data/parser/err/0010_unsafe_lambda_block.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0010_unsafe_lambda_block.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -12,7 +12,7 @@ SOURCE_FILE@0..42\n       L_CURLY@10..11 \"{\"\n       WHITESPACE@11..16 \"\\n    \"\n       EXPR_STMT@16..24\n-        LAMBDA_EXPR@16..24\n+        CLOSURE_EXPR@16..24\n           PARAM_LIST@16..18\n             PIPE@16..17 \"|\"\n             PIPE@17..18 \"|\""}, {"sha": "0afa24b775d56823459000677f8cf4f7c5b0a144", "filename": "crates/ra_syntax/test_data/parser/err/0012_broken_lambda.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0012_broken_lambda.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0012_broken_lambda.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0012_broken_lambda.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -117,7 +117,7 @@ SOURCE_FILE@0..389\n         WHITESPACE@140..141\n         EQ@141..142\n         WHITESPACE@142..143\n-        LAMBDA_EXPR@143..389\n+        CLOSURE_EXPR@143..389\n           PARAM_LIST@143..388\n             PIPE@143..144\n             PARAM@144..159"}, {"sha": "0678d42781db42f14400c7c70c0626ae16320250", "filename": "crates/ra_syntax/test_data/parser/err/0039_lambda_recovery.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0039_lambda_recovery.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -49,7 +49,7 @@ SOURCE_FILE@0..83\n               IDENT@48..51 \"map\"\n             ARG_LIST@51..57\n               L_PAREN@51..52 \"(\"\n-              LAMBDA_EXPR@52..56\n+              CLOSURE_EXPR@52..56\n                 PARAM_LIST@52..56\n                   PIPE@52..53 \"|\"\n                   PARAM@53..55"}, {"sha": "a80d79563ad96ed81085476e918361ce4a3ade21", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0106_lambda_expr.rast", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0106_lambda_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0106_lambda_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0106_lambda_expr.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -12,7 +12,7 @@ SOURCE_FILE@0..134\n       L_CURLY@9..10 \"{\"\n       WHITESPACE@10..15 \"\\n    \"\n       EXPR_STMT@15..21\n-        LAMBDA_EXPR@15..20\n+        CLOSURE_EXPR@15..20\n           PARAM_LIST@15..17\n             PIPE@15..16 \"|\"\n             PIPE@16..17 \"|\"\n@@ -23,7 +23,7 @@ SOURCE_FILE@0..134\n         SEMICOLON@20..21 \";\"\n       WHITESPACE@21..26 \"\\n    \"\n       EXPR_STMT@26..43\n-        LAMBDA_EXPR@26..42\n+        CLOSURE_EXPR@26..42\n           PARAM_LIST@26..28\n             PIPE@26..27 \"|\"\n             PIPE@27..28 \"|\"\n@@ -47,7 +47,7 @@ SOURCE_FILE@0..134\n         SEMICOLON@42..43 \";\"\n       WHITESPACE@43..48 \"\\n    \"\n       EXPR_STMT@48..54\n-        LAMBDA_EXPR@48..53\n+        CLOSURE_EXPR@48..53\n           PARAM_LIST@48..51\n             PIPE@48..49 \"|\"\n             PARAM@49..50\n@@ -64,7 +64,7 @@ SOURCE_FILE@0..134\n         SEMICOLON@53..54 \";\"\n       WHITESPACE@54..59 \"\\n    \"\n       EXPR_STMT@59..76\n-        LAMBDA_EXPR@59..75\n+        CLOSURE_EXPR@59..75\n           MOVE_KW@59..63 \"move\"\n           WHITESPACE@63..64 \" \"\n           PARAM_LIST@64..73\n@@ -91,7 +91,7 @@ SOURCE_FILE@0..134\n         SEMICOLON@75..76 \";\"\n       WHITESPACE@76..81 \"\\n    \"\n       EXPR_STMT@81..93\n-        LAMBDA_EXPR@81..92\n+        CLOSURE_EXPR@81..92\n           ASYNC_KW@81..86 \"async\"\n           WHITESPACE@86..87 \" \"\n           PARAM_LIST@87..89\n@@ -104,7 +104,7 @@ SOURCE_FILE@0..134\n         SEMICOLON@92..93 \";\"\n       WHITESPACE@93..98 \"\\n    \"\n       EXPR_STMT@98..109\n-        LAMBDA_EXPR@98..108\n+        CLOSURE_EXPR@98..108\n           MOVE_KW@98..102 \"move\"\n           WHITESPACE@102..103 \" \"\n           PARAM_LIST@103..105\n@@ -117,7 +117,7 @@ SOURCE_FILE@0..134\n         SEMICOLON@108..109 \";\"\n       WHITESPACE@109..114 \"\\n    \"\n       EXPR_STMT@114..131\n-        LAMBDA_EXPR@114..130\n+        CLOSURE_EXPR@114..130\n           ASYNC_KW@114..119 \"async\"\n           WHITESPACE@119..120 \" \"\n           MOVE_KW@120..124 \"move\""}, {"sha": "d2fd6e567a409f4f2c94a22fa227c41ce4385f2a", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0130_let_stmt.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0130_let_stmt.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0130_let_stmt.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0130_let_stmt.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -105,7 +105,7 @@ SOURCE_FILE@0..135\n         WHITESPACE@117..118 \" \"\n         EQ@118..119 \"=\"\n         WHITESPACE@119..120 \" \"\n-        LAMBDA_EXPR@120..131\n+        CLOSURE_EXPR@120..131\n           ATTR@120..127\n             POUND@120..121 \"#\"\n             L_BRACK@121..122 \"[\""}, {"sha": "0a9f7c137643ff72814fef37d972c5843fdaf488", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0155_closure_params.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0155_closure_params.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0155_closure_params.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0155_closure_params.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -20,7 +20,7 @@ SOURCE_FILE@0..63\n         WHITESPACE@22..23 \" \"\n         EQ@23..24 \"=\"\n         WHITESPACE@24..25 \" \"\n-        LAMBDA_EXPR@25..59\n+        CLOSURE_EXPR@25..59\n           PARAM_LIST@25..56\n             PIPE@25..26 \"|\"\n             PARAM@26..29"}, {"sha": "aa4099a9293063e4ba39843b0f1cd58bb78d11f5", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0158_lambda_ret_block.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0158_lambda_ret_block.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0158_lambda_ret_block.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0158_lambda_ret_block.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -13,7 +13,7 @@ SOURCE_FILE@0..34\n       WHITESPACE@11..12 \" \"\n       EXPR_STMT@12..31\n         CALL_EXPR@12..30\n-          LAMBDA_EXPR@12..28\n+          CLOSURE_EXPR@12..28\n             PARAM_LIST@12..14\n               PIPE@12..13 \"|\"\n               PIPE@13..14 \"|\""}, {"sha": "1d75ed08f0ac06e3b92be1d5c5ea612b6ac28227", "filename": "crates/ra_syntax/test_data/parser/ok/0035_weird_exprs.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0035_weird_exprs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0035_weird_exprs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0035_weird_exprs.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -351,7 +351,7 @@ SOURCE_FILE@0..3813\n         WHITESPACE@766..767 \" \"\n         BLOCK_EXPR@767..777\n           L_CURLY@767..768 \"{\"\n-          LAMBDA_EXPR@768..776\n+          CLOSURE_EXPR@768..776\n             PARAM_LIST@768..770\n               PIPE@768..769 \"|\"\n               PIPE@769..770 \"|\"\n@@ -1628,7 +1628,7 @@ SOURCE_FILE@0..3813\n               CALL_EXPR@2950..2995\n                 PAREN_EXPR@2950..2971\n                   L_PAREN@2950..2951 \"(\"\n-                  LAMBDA_EXPR@2951..2970\n+                  CLOSURE_EXPR@2951..2970\n                     PARAM_LIST@2951..2968\n                       PIPE@2951..2952 \"|\"\n                       PARAM@2952..2962"}, {"sha": "650f4e3102dfc43944ba8658f0d66045a2771837", "filename": "crates/ra_syntax/test_data/parser/ok/0044_let_attrs.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0044_let_attrs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0044_let_attrs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0044_let_attrs.rast?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -52,7 +52,7 @@ SOURCE_FILE@0..166\n                   IDENT@134..146 \"catch_unwind\"\n           ARG_LIST@146..162\n             L_PAREN@146..147 \"(\"\n-            LAMBDA_EXPR@147..161\n+            CLOSURE_EXPR@147..161\n               MOVE_KW@147..151 \"move\"\n               WHITESPACE@151..152 \" \"\n               PARAM_LIST@152..154"}, {"sha": "427406249c99877c34a15924814d04150221a476", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -144,7 +144,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"ARRAY_EXPR\",\n         \"PAREN_EXPR\",\n         \"PATH_EXPR\",\n-        \"LAMBDA_EXPR\",\n+        \"CLOSURE_EXPR\",\n         \"IF_EXPR\",\n         \"WHILE_EXPR\",\n         \"CONDITION\","}, {"sha": "05953869693e52f8bfcca4a24db32e08b6491d8f", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -579,6 +579,21 @@ fn lower_rule(acc: &mut Vec<Field>, grammar: &Grammar, label: Option<&String>, r\n         }\n         Rule::Labeled { label: l, rule } => {\n             assert!(label.is_none());\n+            let manually_implemented = matches!(\n+                l.as_str(),\n+                \"lhs\"\n+                    | \"rhs\"\n+                    | \"then_branch\"\n+                    | \"else_branch\"\n+                    | \"start\"\n+                    | \"end\"\n+                    | \"op\"\n+                    | \"index\"\n+                    | \"base\"\n+            );\n+            if manually_implemented {\n+                return;\n+            }\n             lower_rule(acc, grammar, Some(l), rule);\n         }\n         Rule::Seq(rules) | Rule::Alt(rules) => {"}, {"sha": "aef07cb1e82512bea1bf1962fde17767a1a503f4", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 174, "deletions": 158, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/7325283c6977e078513b5b21aa173775e2b22e12/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/7325283c6977e078513b5b21aa173775e2b22e12/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=7325283c6977e078513b5b21aa173775e2b22e12", "patch": "@@ -115,8 +115,8 @@ Union =\n   RecordFieldList\n \n AdtDef =\n-  Struct\n-| Enum\n+  Enum\n+| Struct\n | Union\n \n Const =\n@@ -136,10 +136,10 @@ AssocItemList =\n   '{' Attr* AssocItem* '}'\n \n AssocItem =\n-  Fn\n-| TypeAlias\n-| Const\n+  Const\n+| Fn\n | MacroCall\n+| TypeAlias\n \n Impl =\n  Attr* Visibility?\n@@ -162,9 +162,9 @@ GenericParamList =\n   '<' (GenericParam (',' GenericParam)* ','?)? '>'\n \n GenericParam =\n-  LifetimeParam\n+  ConstParam\n+| LifetimeParam\n | TypeParam\n-| ConstParam\n \n TypeParam =\n   Attr* Name (':' TypeBoundList?)?\n@@ -195,9 +195,9 @@ Attr =\n   '#' '!'? '[' Path ('=' Literal | TokenTree)? ']'\n \n Stmt =\n-  LetStmt\n-| ExprStmt\n+  ExprStmt\n | Item\n+| LetStmt\n \n LetStmt =\n   Attr* 'let' Pat (':' Type)?\n@@ -206,189 +206,238 @@ LetStmt =\n ExprStmt =\n   Attr* Expr ';'?\n \n-Type =\n-  ParenType\n-| TupleType\n-| NeverType\n-| PathType\n-| PointerType\n-| ArrayType\n-| SliceType\n-| ReferenceType\n-| InferType\n-| FnPointerType\n-| ForType\n-| ImplTraitType\n-| DynTraitType\n+Expr =\n+  ArrayExpr\n+| AwaitExpr\n+| BinExpr\n+| BlockExpr\n+| BoxExpr\n+| BreakExpr\n+| CallExpr\n+| CastExpr\n+| ContinueExpr\n+| EffectExpr\n+| FieldExpr\n+| ForExpr\n+| IfExpr\n+| IndexExpr\n+| Label\n+| ClosureExpr\n+| Literal\n+| LoopExpr\n+| MacroCall\n+| MatchExpr\n+| MethodCallExpr\n+| ParenExpr\n+| PathExpr\n+| PrefixExpr\n+| RangeExpr\n+| RecordExpr\n+| RefExpr\n+| ReturnExpr\n+| TryExpr\n+| TupleExpr\n+| WhileExpr\n \n-ParenType =\n-  '(' Type ')'\n+Literal =\n+  Attr* 'int_number'\n \n-NeverType =\n-  '!'\n+PathExpr =\n+  Attr* Path\n \n-PathType =\n-  Path\n+BlockExpr =\n+  '{'\n+    Attr*\n+    statements:Stmt*\n+    Expr?\n+  '}'\n \n-TupleType =\n-  '(' fields:(Type (',' Type)* ','?)? ')'\n+RefExpr =\n+  Attr* '&' ('raw' |'mut' | 'const') Expr\n \n-PointerType =\n-  '*' ('const' | 'mut') Type\n+TryExpr =\n+  Attr* Expr '?'\n \n-ReferenceType =\n-  '&' 'lifetime'? 'mut'? Type\n+EffectExpr =\n+  Attr* Label? ('try' | 'unsafe' | 'async') BlockExpr\n \n-ArrayType =\n-  '[' Type ';' Expr ']'\n+PrefixExpr =\n+  Attr* op:('-' | '!' | '*') Expr\n \n-SliceType =\n-  '[' Type ']'\n+BinExpr =\n+  Attr*\n+  lhs:Expr\n+  op:(\n+    '||' | '&&'\n+    | '==' | '!=' | '<=' | '>=' | '<' | '>'\n+    | '+' | '*' | '-' | '/' | '%' | '<<' | '>>' | '^' | '|' | '&'\n+    | '=' | '+=' | '/=' | '*=' | '%=' | '>>=' | '<<=' | '-=' | '|=' | '&=' | '^='\n+  )\n+  rhs:Expr\n \n-InferType =\n-   '_'\n+CastExpr =\n+  Attr* Expr 'as' Type\n \n-FnPointerType =\n-   'const'? 'async'? 'unsafe'? Abi? 'fn' ParamList RetType?\n+ParenExpr =\n+  Attr* '(' Attr* Expr ')'\n \n-ForType =\n-   'for' GenericParamList Type\n+ArrayExpr =\n+  Attr* '[' Attr* (\n+    (Expr (',' Expr)* ','?)?\n+  | Expr ';' Expr\n+  ) ']'\n \n-ImplTraitType =\n-  'impl' TypeBoundList\n+IndexExpr =\n+  Attr* base:Expr '[' index:Expr ']'\n \n-DynTraitType =\n-  'dyn' TypeBoundList\n+TupleExpr =\n+  Attr* '(' Attr* (Expr (',' Expr)* ','?)? ')'\n \n-TypeBoundList =\n-   bounds:(TypeBound ('+' TypeBound)* '+'?)\n+RecordExpr =\n+  Path RecordExprFieldList\n \n-TypeBound =\n-  'lifetime'\n-| '?'? Type\n+RecordExprFieldList =\n+  '{'\n+    Attr*\n+    fields:(RecordExprField (',' RecordExprField)* ','?)\n+    ('..' spread:Expr)?\n+  '}'\n \n-TupleExpr =\n-  Attr* '(' Expr* ')'\n+RecordExprField =\n+  Attr* NameRef (':' Expr)?\n \n-ArrayExpr =\n-  Attr* '[' (Expr* | Expr ';' Expr) ']'\n+CallExpr =\n+  Attr* Expr ArgList\n \n-ParenExpr =\n-  Attr* '(' Expr ')'\n+ArgList =\n+  '(' args:(Expr (',' Expr)* ','?)? ')'\n \n-PathExpr =\n-  Path\n+MethodCallExpr =\n+  Attr* Expr '.' NameRef TypeArgList? ArgList\n+\n+FieldExpr =\n+  Attr* Expr '.' NameRef\n \n-LambdaExpr =\n+ClosureExpr =\n   Attr* 'static'? 'async'? 'move'?  ParamList RetType?\n   body:Expr\n \n IfExpr =\n-  Attr* 'if' Condition\n+  Attr* 'if' Condition then_branch:BlockExpr\n+  ('else' else_branch:(IfExpr | BlockExpr))?\n \n Condition =\n   'let' Pat '=' Expr\n | Expr\n \n-EffectExpr =\n-  Attr* Label? ('try' | 'unsafe' | 'async') BlockExpr\n-\n LoopExpr =\n   Attr* Label? 'loop'\n-  loop_body:BlockExpr?\n+  loop_body:BlockExpr\n \n ForExpr =\n   Attr* Label? 'for' Pat 'in' iterable:Expr\n-  loop_body:BlockExpr?\n+  loop_body:BlockExpr\n \n WhileExpr =\n   Attr* Label? 'while' Condition\n   loop_body:BlockExpr?\n \n-ContinueExpr =\n-  Attr* 'continue' 'lifetime'?\n+Label =\n+  'lifetime'\n \n BreakExpr =\n   Attr* 'break' 'lifetime'? Expr?\n \n-Label =\n-  'lifetime'\n-\n-BlockExpr =\n-  Attr* Label\n-  '{'\n-    statements:Stmt*\n-    Expr?\n-  '}'\n+ContinueExpr =\n+  Attr* 'continue' 'lifetime'?\n \n-ReturnExpr =\n-  Attr* 'return' Expr\n+RangeExpr =\n+  Attr* start:Expr? op:('..' | '..=') end:Expr?\n \n-CallExpr =\n-  Attr* Expr ArgList\n+MatchExpr =\n+  Attr* 'match' Expr MatchArmList\n \n-MethodCallExpr =\n-  Attr* Expr '.' NameRef TypeArgList? ArgList\n+MatchArmList =\n+  '{'\n+    Attr*\n+    arms:MatchArm*\n+  '}'\n \n-ArgList =\n-  '(' args:Expr* ')'\n+MatchArm =\n+  Attr* Pat guard:MatchGuard? '=>' Expr ','?\n \n-FieldExpr =\n-  Attr* Expr '.' NameRef\n+MatchGuard =\n+  'if' Expr\n \n-IndexExpr =\n-  Attr* '[' ']'\n+ReturnExpr =\n+  Attr* 'return' Expr?\n \n AwaitExpr =\n   Attr* Expr '.' 'await'\n \n-TryExpr =\n-  Attr* Expr '?'\n+BoxExpr =\n+  Attr* 'box' Expr\n \n-CastExpr =\n-  Attr* Expr 'as' Type\n+Type =\n+  ArrayType\n+| DynTraitType\n+| FnPointerType\n+| ForType\n+| ImplTraitType\n+| InferType\n+| NeverType\n+| ParenType\n+| PathType\n+| PointerType\n+| ReferenceType\n+| SliceType\n+| TupleType\n \n-RefExpr =\n-  Attr* '&' ('raw' | 'mut' | 'const') Expr\n+ParenType =\n+  '(' Type ')'\n \n-PrefixExpr =\n-  Attr* Expr\n+NeverType =\n+  '!'\n \n-BoxExpr =\n-  Attr* 'box' Expr\n+PathType =\n+  Path\n \n-RangeExpr =\n-  Attr*\n+TupleType =\n+  '(' fields:(Type (',' Type)* ','?)? ')'\n \n-BinExpr =\n-  Attr*\n+PointerType =\n+  '*' ('const' | 'mut') Type\n \n-Literal =\n-  'int_number'\n+ReferenceType =\n+  '&' 'lifetime'? 'mut'? Type\n \n-MatchExpr =\n-  Attr* 'match' Expr MatchArmList\n+ArrayType =\n+  '[' Type ';' Expr ']'\n \n-MatchArmList =\n-  '{' arms:MatchArm* '}'\n+SliceType =\n+  '[' Type ']'\n \n-MatchArm =\n-  Attr* Pat guard:MatchGuard? '=>' Expr\n+InferType =\n+   '_'\n \n-MatchGuard =\n-  'if' Expr\n+FnPointerType =\n+   'const'? 'async'? 'unsafe'? Abi? 'fn' ParamList RetType?\n \n-RecordExpr =\n- Path RecordExprFieldList\n+ForType =\n+   'for' GenericParamList Type\n \n-RecordExprFieldList =\n-  '{'\n-    fields:RecordExprField*\n-    ('..' spread:Expr)?\n-  '}'\n+ImplTraitType =\n+  'impl' TypeBoundList\n \n-RecordExprField =\n-  Attr* NameRef (':' Expr)?\n+DynTraitType =\n+  'dyn' TypeBoundList\n+\n+TypeBoundList =\n+   bounds:(TypeBound ('+' TypeBound)* '+'?)\n+\n+TypeBound =\n+  'lifetime'\n+| '?'? Type\n \n OrPat =\n   Pat*\n@@ -510,36 +559,3 @@ Pat =\n | RangePat\n | LiteralPat\n | MacroPat\n-\n-Expr =\n-  TupleExpr\n-| ArrayExpr\n-| ParenExpr\n-| PathExpr\n-| LambdaExpr\n-| IfExpr\n-| LoopExpr\n-| ForExpr\n-| WhileExpr\n-| ContinueExpr\n-| BreakExpr\n-| Label\n-| BlockExpr\n-| ReturnExpr\n-| MatchExpr\n-| RecordExpr\n-| CallExpr\n-| IndexExpr\n-| MethodCallExpr\n-| FieldExpr\n-| AwaitExpr\n-| TryExpr\n-| EffectExpr\n-| CastExpr\n-| RefExpr\n-| PrefixExpr\n-| RangeExpr\n-| BinExpr\n-| Literal\n-| MacroCall\n-| BoxExpr"}]}