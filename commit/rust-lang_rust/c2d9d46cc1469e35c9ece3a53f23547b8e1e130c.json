{"sha": "c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZDlkNDZjYzE0NjllMzVjOWVjZTNhNTNmMjM1NDdiOGUxZTEzMGM=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2017-03-03T18:53:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-03T18:53:15Z"}, "message": "Merge pull request #1592 from Manishearth/node_id_to_type\n\nBugfixes", "tree": {"sha": "a9108b98c10dec4a4ec145c15f68d6b2cdf4f1aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9108b98c10dec4a4ec145c15f68d6b2cdf4f1aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "html_url": "https://github.com/rust-lang/rust/commit/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "268b15f2888cf708b142e70afe1cbcd12cb83f64", "url": "https://api.github.com/repos/rust-lang/rust/commits/268b15f2888cf708b142e70afe1cbcd12cb83f64", "html_url": "https://github.com/rust-lang/rust/commit/268b15f2888cf708b142e70afe1cbcd12cb83f64"}, {"sha": "ac48e092554a4fe019ceee4dacbca747ac705eaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac48e092554a4fe019ceee4dacbca747ac705eaa", "html_url": "https://github.com/rust-lang/rust/commit/ac48e092554a4fe019ceee4dacbca747ac705eaa"}], "stats": {"total": 137, "additions": 61, "deletions": 76}, "files": [{"sha": "3b624ff3d6cde0c2d3c12d5bab5bd2a395a991f9", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "patch": "@@ -53,21 +53,6 @@ pub enum Constant {\n     Tuple(Vec<Constant>),\n }\n \n-impl Constant {\n-    /// Convert to `u64` if possible.\n-    ///\n-    /// # panics\n-    ///\n-    /// If the constant could not be converted to `u64` losslessly.\n-    fn as_u64(&self) -> u64 {\n-        if let Constant::Int(val) = *self {\n-            val.to_u64().expect(\"negative constant can't be casted to `u64`\")\n-        } else {\n-            panic!(\"Could not convert a `{:?}` to `u64`\", self);\n-        }\n-    }\n-}\n-\n impl PartialEq for Constant {\n     fn eq(&self, other: &Constant) -> bool {\n         match (self, other) {\n@@ -266,11 +251,12 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tcx, self.tables.expr_ty(e))),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprRepeat(ref value, number_id) => {\n-                let val = &self.tcx.hir.body(number_id).value;\n-                self.binop_apply(value,\n-                                 val,\n-                                 |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n+            ExprRepeat(ref value, _) => {\n+                let n = match self.tables.expr_ty(e).sty {\n+                    ty::TyArray(_, n) => n,\n+                    _ => span_bug!(e.span, \"typeck error\"),\n+                };\n+                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| match op {\n@@ -375,15 +361,4 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             _ => None,\n         }\n     }\n-\n-\n-    fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n-        where F: Fn(Constant, Constant) -> Option<Constant>\n-    {\n-        if let (Some(lc), Some(rc)) = (self.expr(left), self.expr(right)) {\n-            op(lc, rc)\n-        } else {\n-            None\n-        }\n-    }\n }"}, {"sha": "8729a39733ac5597bcf11137f85db8c9f6eb0bbe", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 30, "deletions": 44, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "patch": "@@ -10,7 +10,7 @@ use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use utils::paths;\n use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block, walk_ptrs_ty,\n-            is_expn_of};\n+            is_expn_of, remove_blocks};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for matches with a single arm where an `if let`\n@@ -179,11 +179,12 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n       arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n-        let els = if is_unit_expr(&arms[1].body) {\n+        let els = remove_blocks(&arms[1].body);\n+        let els = if is_unit_expr(els) {\n             None\n-        } else if let ExprBlock(_) = arms[1].body.node {\n+        } else if let ExprBlock(_) = els.node {\n             // matches with blocks that contain statements are prettier as `if let + else`\n-            Some(&*arms[1].body)\n+            Some(els)\n         } else {\n             // allow match arms with just expressions\n             return;\n@@ -198,29 +199,33 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n \n fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     if arms[1].pats[0].node == PatKind::Wild {\n-        let lint = if els.is_some() {\n-            SINGLE_MATCH_ELSE\n-        } else {\n-            SINGLE_MATCH\n-        };\n-        let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n-        span_lint_and_then(cx,\n-                           lint,\n-                           expr.span,\n-                           \"you seem to be trying to use match for destructuring a single pattern. \\\n-                           Consider using `if let`\",\n-                           |db| {\n-            db.span_suggestion(expr.span,\n-                               \"try this\",\n-                               format!(\"if let {} = {} {}{}\",\n-                                       snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                       snippet(cx, ex.span, \"..\"),\n-                                       expr_block(cx, &arms[0].body, None, \"..\"),\n-                                       els_str));\n-        });\n+        report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n \n+fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+    let lint = if els.is_some() {\n+        SINGLE_MATCH_ELSE\n+    } else {\n+        SINGLE_MATCH\n+    };\n+    let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n+    span_lint_and_then(cx,\n+                        lint,\n+                        expr.span,\n+                        \"you seem to be trying to use match for destructuring a single pattern. \\\n+                        Consider using `if let`\",\n+                        |db| {\n+        db.span_suggestion(expr.span,\n+                            \"try this\",\n+                            format!(\"if let {} = {} {}{}\",\n+                                    snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                    snippet(cx, ex.span, \"..\"),\n+                                    expr_block(cx, &arms[0].body, None, \"..\"),\n+                                    els_str));\n+    });\n+}\n+\n fn check_single_match_opt_like(\n     cx: &LateContext,\n     ex: &Expr,\n@@ -253,26 +258,7 @@ fn check_single_match_opt_like(\n \n     for &(ty_path, pat_path) in candidates {\n         if &path == pat_path && match_type(cx, ty, ty_path) {\n-            let lint = if els.is_some() {\n-                SINGLE_MATCH_ELSE\n-            } else {\n-                SINGLE_MATCH\n-            };\n-            let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n-            span_lint_and_then(cx,\n-                               lint,\n-                               expr.span,\n-                               \"you seem to be trying to use match for destructuring a single pattern. Consider \\\n-                                using `if let`\",\n-                               |db| {\n-                db.span_suggestion(expr.span,\n-                                   \"try this\",\n-                                   format!(\"if let {} = {} {}{}\",\n-                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                           snippet(cx, ex.span, \"..\"),\n-                                           expr_block(cx, &arms[0].body, None, \"..\"),\n-                                           els_str));\n-            });\n+            report_single_match_single_pattern(cx, ex, arms, expr, els);\n         }\n     }\n }"}, {"sha": "32e8c90ad993ef6f5422bd57f5fa57e3e243eeec", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "patch": "@@ -385,7 +385,7 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n /// snippet(cx, expr.span, \"..\")\n /// ```\n pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or_else(|_| Cow::Borrowed(default))\n+    snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n }\n \n /// Convert a span to a code snippet. Returns `None` if not available."}, {"sha": "d53d3a1cc758f660260567f9d7b86e4aef8b102c", "filename": "tests/run-pass/ice-1588.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/tests%2Frun-pass%2Fice-1588.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/tests%2Frun-pass%2Fice-1588.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fice-1588.rs?ref=c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "patch": "@@ -0,0 +1,13 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![allow(clippy)]\n+\n+fn main() {\n+    match 1 {\n+        1 => {}\n+        2 => {\n+            [0; 1];\n+        }\n+        _ => {}\n+    }\n+}"}, {"sha": "fe3cf1ce71f0d8e98e1472130f8813fdddd9d334", "filename": "tests/run-pass/single-match-else.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/tests%2Frun-pass%2Fsingle-match-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d9d46cc1469e35c9ece3a53f23547b8e1e130c/tests%2Frun-pass%2Fsingle-match-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsingle-match-else.rs?ref=c2d9d46cc1469e35c9ece3a53f23547b8e1e130c", "patch": "@@ -0,0 +1,11 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![warn(single_match_else)]\n+\n+fn main() {\n+    let n = match (42, 43) {\n+        (42, n) => n,\n+        _ => panic!(\"typeck error\"),\n+    };\n+    assert_eq!(n, 43);\n+}"}]}