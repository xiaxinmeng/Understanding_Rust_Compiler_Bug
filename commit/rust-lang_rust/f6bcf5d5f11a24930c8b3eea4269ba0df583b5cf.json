{"sha": "f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YmNmNWQ1ZjExYTI0OTMwYzhiM2VlYTQyNjliYTBkZjU4M2I1Y2Y=", "commit": {"author": {"name": "maikklein", "email": "maikklein@googlemail.com", "date": "2013-07-23T00:27:53Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-28T06:41:09Z"}, "message": "cleanup .chain and .chain_err + fixing other files", "tree": {"sha": "1767bb41f471226be2be3ac530141702e3915e53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1767bb41f471226be2be3ac530141702e3915e53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "html_url": "https://github.com/rust-lang/rust/commit/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/comments", "author": {"login": "MaikKlein", "id": 1994306, "node_id": "MDQ6VXNlcjE5OTQzMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1994306?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaikKlein", "html_url": "https://github.com/MaikKlein", "followers_url": "https://api.github.com/users/MaikKlein/followers", "following_url": "https://api.github.com/users/MaikKlein/following{/other_user}", "gists_url": "https://api.github.com/users/MaikKlein/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaikKlein/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaikKlein/subscriptions", "organizations_url": "https://api.github.com/users/MaikKlein/orgs", "repos_url": "https://api.github.com/users/MaikKlein/repos", "events_url": "https://api.github.com/users/MaikKlein/events{/privacy}", "received_events_url": "https://api.github.com/users/MaikKlein/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e308167a2fe558924fcebcc99358c057ae0b90b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e308167a2fe558924fcebcc99358c057ae0b90b4", "html_url": "https://github.com/rust-lang/rust/commit/e308167a2fe558924fcebcc99358c057ae0b90b4"}], "stats": {"total": 141, "additions": 54, "deletions": 87}, "files": [{"sha": "7ac215e3949eee20d630b1fff6533c36f568f582", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "patch": "@@ -147,7 +147,7 @@ pub fn get_rustpkg_root() -> Result<Path, ~str> {\n }\n \n pub fn get_rustpkg_root_nearest() -> Result<Path, ~str> {\n-    do result::chain(get_rustpkg_root()) |p| {\n+    do get_rustpkg_root().chain |p| {\n         let cwd = os::getcwd();\n         let cwd_rustpkg = cwd.push(\".rustpkg\");\n         let rustpkg_is_non_root_file =\n@@ -173,13 +173,13 @@ pub fn get_rustpkg_root_nearest() -> Result<Path, ~str> {\n }\n \n fn get_rustpkg_lib_path() -> Result<Path, ~str> {\n-    do result::chain(get_rustpkg_root()) |p| {\n+    do get_rustpkg_root().chain |p| {\n         result::Ok(p.push(libdir()))\n     }\n }\n \n fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n-    do result::chain(get_rustpkg_root_nearest()) |p| {\n+    do get_rustpkg_root_nearest().chain |p| {\n         result::Ok(p.push(libdir()))\n     }\n }"}, {"sha": "aa3557e8a9d848e3ead55ba2a046ae677e2afd98", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "patch": "@@ -138,36 +138,30 @@ fn config_from_opts(\n \n     let config = default_config(input_crate);\n     let result = result::Ok(config);\n-    let result = do result::chain(result) |config| {\n+    let result = do result.chain |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map(|s| Path(*s));\n         result::Ok(Config {\n             output_dir: output_dir.get_or_default(config.output_dir.clone()),\n             .. config\n         })\n     };\n-    let result = do result::chain(result) |config| {\n-        let output_format = getopts::opt_maybe_str(\n-            matches, opt_output_format());\n-        do output_format.map_default(result::Ok(config.clone()))\n-            |output_format| {\n-            do result::chain(parse_output_format(*output_format))\n-                |output_format| {\n-\n+    let result = do result.chain |config| {\n+        let output_format = getopts::opt_maybe_str(matches, opt_output_format());\n+        do output_format.map_default(result::Ok(config.clone())) |output_format| {\n+            do parse_output_format(*output_format).chain |output_format| {\n                 result::Ok(Config {\n                     output_format: output_format,\n                     .. config.clone()\n                 })\n             }\n         }\n     };\n-    let result = do result::chain(result) |config| {\n+    let result = do result.chain |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n-        do output_style.map_default(result::Ok(config.clone()))\n-            |output_style| {\n-            do result::chain(parse_output_style(*output_style))\n-                |output_style| {\n+        do output_style.map_default(result::Ok(config.clone())) |output_style| {\n+            do parse_output_style(*output_style).chain |output_style| {\n                 result::Ok(Config {\n                     output_style: output_style,\n                     .. config.clone()\n@@ -176,11 +170,11 @@ fn config_from_opts(\n         }\n     };\n     let process_output = Cell::new(process_output);\n-    let result = do result::chain(result) |config| {\n+    let result = do result.chain |config| {\n         let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             &config, pandoc_cmd, process_output.take());\n-        do result::chain(pandoc_cmd) |pandoc_cmd| {\n+        do pandoc_cmd.chain |pandoc_cmd| {\n             result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n                 .. config.clone()"}, {"sha": "0d781a1aea22a9d03a37df8c35b6a85684f55975", "filename": "src/libstd/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "patch": "@@ -1726,21 +1726,21 @@ pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n }\n \n pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n-    result::chain(read_whole_file(file), |bytes| {\n+    do read_whole_file(file).chain |bytes| {\n         if str::is_utf8(bytes) {\n             result::Ok(str::from_bytes(bytes))\n         } else {\n             result::Err(file.to_str() + \" is not UTF-8\")\n         }\n-    })\n+    }\n }\n \n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n-    result::chain(file_reader(file), |rdr| {\n+    do file_reader(file).chain |rdr| {\n         result::Ok(rdr.read_whole_stream())\n-    })\n+    }\n }\n \n // fsync related\n@@ -1851,10 +1851,10 @@ mod tests {\n             ~\"A hoopy frood who really knows where his towel is.\";\n         debug!(frood.clone());\n         {\n-            let out: @io::Writer = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n+            let out = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n             out.write_str(frood);\n         }\n-        let inp: @io::Reader = io::file_reader(tmpfile).unwrap();\n+        let inp = io::file_reader(tmpfile).unwrap();\n         let frood2: ~str = inp.read_c_str();\n         debug!(frood2.clone());\n         assert_eq!(frood, frood2);"}, {"sha": "0aeb9654f56537736ef30962fec05aba6f5d233f", "filename": "src/libstd/result.rs", "status": "modified", "additions": 35, "deletions": 62, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=f6bcf5d5f11a24930c8b3eea4269ba0df583b5cf", "patch": "@@ -77,61 +77,6 @@ pub fn to_either<T:Clone,U:Clone>(res: &Result<U, T>)\n     }\n }\n \n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n- * `op`s result is returned. if `res` is `err` then it is immediately\n- * returned. This function can be used to compose the results of two\n- * functions.\n- *\n- * Example:\n- *\n- *     let res = chain(read_file(file)) { |buf|\n- *         ok(parse_bytes(buf))\n- *     }\n- */\n-#[inline]\n-pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n-    -> Result<U, V>) -> Result<U, V> {\n-    match res {\n-        Ok(t) => op(t),\n-        Err(e) => Err(e)\n-    }\n-}\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `err` then the value is extracted and passed to `op`\n- * whereupon `op`s result is returned. if `res` is `ok` then it is\n- * immediately returned.  This function can be used to pass through a\n- * successful result while handling an error.\n- */\n-#[inline]\n-pub fn chain_err<T, U, V>(\n-    res: Result<T, V>,\n-    op: &fn(t: V) -> Result<T, U>)\n-    -> Result<T, U> {\n-    match res {\n-      Ok(t) => Ok(t),\n-      Err(v) => op(v)\n-    }\n-}\n-\n-\n-\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `err` then the value is extracted and passed to `op` whereupon\n- * `op`s result is returned. if `res` is `ok` then it is immediately returned.\n- * This function can be used to pass through a successful result while\n- * handling an error.\n- */\n-\n-\n /**\n  * Call a function based on a previous result\n  *\n@@ -208,7 +153,7 @@ impl<T, E> Result<T, E> {\n      * Call a function based on a previous result\n      *\n      * If `*self` is `ok` then the value is extracted and passed to `op` whereupon\n-     * `op`s result is returned. if `res` is `err` then it is immediately\n+     * `op`s result is returned. if `*self` is `err` then it is immediately\n      * returned. This function can be used to compose the results of two\n      * functions.\n      *\n@@ -230,7 +175,7 @@ impl<T, E> Result<T, E> {\n      * Call a function based on a previous result\n      *\n      * If `*self` is `err` then the value is extracted and passed to `op` whereupon\n-     * `op`s result is returned. if `res` is `ok` then it is immediately returned.\n+     * `op`s result is returned. if `*self` is `ok` then it is immediately returned.\n      * This function can be used to pass through a successful result while\n      * handling an error.\n      */\n@@ -260,14 +205,42 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n+    /**\n+     * Call a function based on a previous result\n+     *\n+     * If `self` is `ok` then the value is extracted and passed to `op` whereupon\n+     * `op`s result is returned. if `self` is `err` then it is immediately\n+     * returned. This function can be used to compose the results of two\n+     * functions.\n+     *\n+     * Example:\n+     *\n+     *     let res = read_file(file).chain(op) { |buf|\n+     *         ok(parse_bytes(buf))\n+     *     }\n+     */\n     #[inline]\n     pub fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n-        chain(self, op)\n+        match self {\n+            Ok(t) => op(t),\n+            Err(e) => Err(e)\n+        }\n     }\n \n+    /**\n+    * Call a function based on a previous result\n+    *\n+    * If `self` is `err` then the value is extracted and passed to `op`\n+    * whereupon `op`s result is returned. if `self` is `ok` then it is\n+    * immediately returned.  This function can be used to pass through a\n+    * successful result while handling an error.\n+    */\n     #[inline]\n     pub fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n-        chain_err(self, op)\n+        match self {\n+            Ok(t) => Ok(t),\n+            Err(v) => op(v)\n+        }\n     }\n }\n \n@@ -390,7 +363,7 @@ pub fn iter_vec2<S,T,U>(ss: &[S], ts: &[T],\n \n #[cfg(test)]\n mod tests {\n-    use result::{Err, Ok, Result, chain, get, get_err};\n+    use result::{Err, Ok, Result, get, get_err};\n     use result;\n \n     pub fn op1() -> result::Result<int, ~str> { result::Ok(666) }\n@@ -403,12 +376,12 @@ mod tests {\n \n     #[test]\n     pub fn chain_success() {\n-        assert_eq!(get(&chain(op1(), op2)), 667u);\n+        assert_eq!(get(&(op1().chain(op2))), 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        assert_eq!(get_err(&chain(op3(), op2)), ~\"sadface\");\n+        assert_eq!(get_err(&op3().chain( op2)), ~\"sadface\");\n     }\n \n     #[test]"}]}