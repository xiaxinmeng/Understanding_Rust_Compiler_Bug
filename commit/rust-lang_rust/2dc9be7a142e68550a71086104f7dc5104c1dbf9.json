{"sha": "2dc9be7a142e68550a71086104f7dc5104c1dbf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYzliZTdhMTQyZTY4NTUwYTcxMDg2MTA0ZjdkYzUxMDRjMWRiZjk=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-08-24T19:03:11Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-08-24T19:18:32Z"}, "message": "Remove deprecated modes from libstd/time.rs\n\nI've changed the unique string arguments to slices, and internally use\nreferences to tm enums.  These changes are self-contained and so likely\ndon't step on any of @graydon's feet for a change!", "tree": {"sha": "b174bdd1fabe88a1c93e2937dda8670f1d6d0fd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b174bdd1fabe88a1c93e2937dda8670f1d6d0fd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dc9be7a142e68550a71086104f7dc5104c1dbf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc9be7a142e68550a71086104f7dc5104c1dbf9", "html_url": "https://github.com/rust-lang/rust/commit/2dc9be7a142e68550a71086104f7dc5104c1dbf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dc9be7a142e68550a71086104f7dc5104c1dbf9/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f996f70a632d1427801f20935a69a57fbb3679e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f996f70a632d1427801f20935a69a57fbb3679e", "html_url": "https://github.com/rust-lang/rust/commit/0f996f70a632d1427801f20935a69a57fbb3679e"}], "stats": {"total": 37, "additions": 20, "deletions": 17}, "files": [{"sha": "5ce9853fcdbb3b2126dda173a65577aa6d08ce4b", "filename": "src/libstd/time.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2dc9be7a142e68550a71086104f7dc5104c1dbf9/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc9be7a142e68550a71086104f7dc5104c1dbf9/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=2dc9be7a142e68550a71086104f7dc5104c1dbf9", "patch": "@@ -1,3 +1,6 @@\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n import libc::{c_char, c_int, c_long, size_t, time_t};\n import io::Reader;\n import result::{result, ok, err};\n@@ -128,7 +131,7 @@ fn now() -> tm {\n }\n \n /// Parses the time from the string according to the format string.\n-fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n+fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n     type tm_mut = {\n        mut tm_sec: i32,\n        mut tm_min: i32,\n@@ -144,7 +147,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n        mut tm_nsec: i32,\n     };\n \n-    fn match_str(s: ~str, pos: uint, needle: ~str) -> bool {\n+    fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n         for str::each(needle) |ch| {\n             if s[i] != ch {\n@@ -155,14 +158,14 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         return true;\n     }\n \n-    fn match_strs(s: ~str, pos: uint, strs: ~[(~str, i32)])\n+    fn match_strs(ss: &str, pos: uint, strs: &[(~str, i32)])\n       -> option<(i32, uint)> {\n         let mut i = 0u;\n         let len = vec::len(strs);\n         while i < len {\n             let (needle, value) = strs[i];\n \n-            if match_str(s, pos, needle) {\n+            if match_str(ss, pos, needle) {\n                 return some((value, pos + str::len(needle)));\n             }\n             i += 1u;\n@@ -171,14 +174,14 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         none\n     }\n \n-    fn match_digits(s: ~str, pos: uint, digits: uint, ws: bool)\n+    fn match_digits(ss: &str, pos: uint, digits: uint, ws: bool)\n       -> option<(i32, uint)> {\n         let mut pos = pos;\n         let mut value = 0_i32;\n \n         let mut i = 0u;\n         while i < digits {\n-            let {ch, next} = str::char_range_at(s, pos);\n+            let {ch, next} = str::char_range_at(str::from_slice(ss), pos);\n             pos = next;\n \n             match ch {\n@@ -194,7 +197,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         some((value, pos))\n     }\n \n-    fn parse_char(s: ~str, pos: uint, c: char) -> result<uint, ~str> {\n+    fn parse_char(s: &str, pos: uint, c: char) -> result<uint, ~str> {\n         let {ch, next} = str::char_range_at(s, pos);\n \n         if c == ch {\n@@ -206,7 +209,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         }\n     }\n \n-    fn parse_type(s: ~str, pos: uint, ch: char, tm: tm_mut)\n+    fn parse_type(s: &str, pos: uint, ch: char, tm: &tm_mut)\n       -> result<uint, ~str> {\n         match ch {\n           'A' => match match_strs(s, pos, ~[\n@@ -516,7 +519,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         }\n     }\n \n-    do io::with_str_reader(format) |rdr| {\n+    do io::with_str_reader(str::from_slice(format)) |rdr| {\n         let tm = {\n             mut tm_sec: 0_i32,\n             mut tm_min: 0_i32,\n@@ -539,7 +542,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             let {ch, next} = str::char_range_at(s, pos);\n \n             match rdr.read_char() {\n-              '%' => match parse_type(s, pos, rdr.read_char(), tm) {\n+              '%' => match parse_type(s, pos, rdr.read_char(), &tm) {\n                 ok(next) => pos = next,\n                   err(e) => { result = err(e); break; }\n               },\n@@ -569,8 +572,8 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n     }\n }\n \n-fn strftime(format: ~str, tm: tm) -> ~str {\n-    fn parse_type(ch: char, tm: tm) -> ~str {\n+fn strftime(format: &str, +tm: tm) -> ~str {\n+    fn parse_type(ch: char, tm: &tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n       let die = || #fmt(\"strftime: can't understand this format %c \",\n                              ch);\n@@ -725,10 +728,10 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n \n     let mut buf = ~\"\";\n \n-    do io::with_str_reader(format) |rdr| {\n+    do io::with_str_reader(str::from_slice(format)) |rdr| {\n         while !rdr.eof() {\n             match rdr.read_char() {\n-                '%' => buf += parse_type(rdr.read_char(), tm),\n+                '%' => buf += parse_type(rdr.read_char(), &tm),\n                 ch => str::push_char(buf, ch)\n             }\n         }\n@@ -766,7 +769,7 @@ impl tm {\n     fn ctime() -> ~str { self.strftime(~\"%c\") }\n \n     /// Formats the time according to the format string.\n-    fn strftime(format: ~str) -> ~str { strftime(format, self) }\n+    fn strftime(format: &str) -> ~str { strftime(format, self) }\n \n     /**\n      * Returns a time string formatted according to RFC 822.\n@@ -983,9 +986,9 @@ mod tests {\n           }\n         }\n \n-        fn test(s: ~str, format: ~str) -> bool {\n+        fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              ok(tm) => tm.strftime(format) == s,\n+              ok(tm) => tm.strftime(format) == str::from_slice(s),\n               err(e) => fail e\n             }\n         }"}]}