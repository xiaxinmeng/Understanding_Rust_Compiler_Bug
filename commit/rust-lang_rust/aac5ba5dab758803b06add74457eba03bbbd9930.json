{"sha": "aac5ba5dab758803b06add74457eba03bbbd9930", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYzViYTVkYWI3NTg4MDNiMDZhZGQ3NDQ1N2ViYTAzYmJiZDk5MzA=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-07T23:41:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:07Z"}, "message": "resolve instances to ty::Instance directly\n\nThis removes the duplication between collector, callee, and (eventually)\nMIRI.", "tree": {"sha": "7a75615d5d3c9bc32149bb0446422253fe4d1d4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a75615d5d3c9bc32149bb0446422253fe4d1d4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aac5ba5dab758803b06add74457eba03bbbd9930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aac5ba5dab758803b06add74457eba03bbbd9930", "html_url": "https://github.com/rust-lang/rust/commit/aac5ba5dab758803b06add74457eba03bbbd9930", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aac5ba5dab758803b06add74457eba03bbbd9930/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf80fec326d0fa7b58882d6f2102808a3f220651", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf80fec326d0fa7b58882d6f2102808a3f220651", "html_url": "https://github.com/rust-lang/rust/commit/bf80fec326d0fa7b58882d6f2102808a3f220651"}], "stats": {"total": 884, "additions": 389, "deletions": 495}, "files": [{"sha": "c71fc28b4d6b3a71776fae56652048f8d484078b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -40,7 +40,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n-pub use self::specialize::{SpecializesCache, find_method};\n+pub use self::specialize::{SpecializesCache, find_associated_item};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;"}, {"sha": "50a4d982832ace739c8c78b7afac69938d07f6c7", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -29,8 +29,6 @@ use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n \n-use syntax::ast;\n-\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -106,22 +104,23 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n /// Given a selected impl described by `impl_data`, returns the\n-/// definition and substitions for the method with the name `name`,\n-/// and trait method substitutions `substs`, in that impl, a less\n-/// specialized impl, or the trait default, whichever applies.\n-pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             name: ast::Name,\n-                             substs: &'tcx Substs<'tcx>,\n-                             impl_data: &super::VtableImplData<'tcx, ()>)\n-                             -> (DefId, &'tcx Substs<'tcx>)\n-{\n+/// definition and substitions for the method with the name `name`\n+/// the kind `kind`, and trait method substitutions `substs`, in\n+/// that impl, a less specialized impl, or the trait default,\n+/// whichever applies.\n+pub fn find_associated_item<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    item: &ty::AssociatedItem,\n+    substs: &'tcx Substs<'tcx>,\n+    impl_data: &super::VtableImplData<'tcx, ()>,\n+) -> (DefId, &'tcx Substs<'tcx>) {\n     assert!(!substs.needs_infer());\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n \n     let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n-    match ancestors.defs(tcx, name, ty::AssociatedKind::Method).next() {\n+    match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n@@ -137,7 +136,7 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             (node_item.item.def_id, substs)\n         }\n         None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_data.impl_def_id)\n+            bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id)\n         }\n     }\n }"}, {"sha": "5543223105b444c37f5d8e512588661627c094a1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -1469,6 +1469,15 @@ impl<T, R> InternIteratorElement<T, R> for T {\n     }\n }\n \n+impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n+    where T: Clone + 'a\n+{\n+    type Output = R;\n+    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n+        f(&iter.cloned().collect::<AccumulateVec<[_; 8]>>())\n+    }\n+}\n+\n impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     type Output = Result<R, E>;\n     fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {"}, {"sha": "d93482acbcb5775a10d7d41a5c87edef9bd9d17d", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -27,17 +27,30 @@ pub struct Instance<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum InstanceDef<'tcx> {\n     Item(DefId),\n+    Intrinsic(DefId),\n     // <fn() as FnTrait>::call_*\n+    // def-id is FnTrait::call_*\n     FnPtrShim(DefId, Ty<'tcx>),\n+    // <Trait as Trait>::fn\n+    Virtual(DefId, usize),\n+    // <[mut closure] as FnOnce>::call_once\n+    ClosureOnceShim {\n+        call_once: DefId,\n+        closure_did: DefId\n+    },\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n     #[inline]\n     pub fn def_id(&self) -> DefId {\n         match *self {\n             InstanceDef::Item(def_id) |\n-            InstanceDef::FnPtrShim(def_id, _)\n-                => def_id\n+            InstanceDef::FnPtrShim(def_id, _) |\n+            InstanceDef::Virtual(def_id, _) |\n+            InstanceDef::Intrinsic(def_id, ) |\n+            InstanceDef::ClosureOnceShim {\n+                call_once: def_id, closure_did: _\n+            } => def_id\n         }\n     }\n \n@@ -73,14 +86,23 @@ impl<'tcx> InstanceDef<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ppaux::parameterized(f, self.substs, self.def_id(), &[])?;\n         match self.def {\n-            InstanceDef::Item(def) => {\n-                ppaux::parameterized(f, self.substs, def, &[])\n+            InstanceDef::Item(_) => Ok(()),\n+            InstanceDef::Intrinsic(_) => {\n+                write!(f, \" - intrinsic\")\n             }\n-            InstanceDef::FnPtrShim(def, ty) => {\n-                ppaux::parameterized(f, self.substs, def, &[])?;\n+            InstanceDef::Virtual(_, num) => {\n+                write!(f, \" - shim(#{})\", num)\n+            }\n+            InstanceDef::FnPtrShim(_, ty) => {\n                 write!(f, \" - shim({:?})\", ty)\n             }\n+            InstanceDef::ClosureOnceShim {\n+                call_once: _, closure_did\n+            } => {\n+                write!(f, \" - shim({:?})\", closure_did)\n+            }\n         }\n     }\n }"}, {"sha": "1d816d342c4fd3f3b53f7c9046bf0c431d3af3e8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -408,8 +408,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n         })\n     }\n-\n-\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {"}, {"sha": "2a053535e7e106691c10cee883e8f8c30b77ff1a", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -41,6 +41,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ty::InstanceDef::FnPtrShim(_, ty) => {\n             build_fn_ptr_shim(tcx, ty, instance.def_ty(tcx))\n         }\n+        _ => bug!(\"unknown shim kind\")\n     };\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n "}, {"sha": "10ab199671f6418b10b2ac5eec9b158f445a5890", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -36,9 +36,7 @@ use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{AssertDepGraphSafe, DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n@@ -54,7 +52,6 @@ use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef};\n use common::CrateContext;\n-use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n@@ -80,7 +77,7 @@ use std::ffi::{CStr, CString};\n use std::rc::Rc;\n use std::str;\n use std::i32;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n use syntax::attr;\n use rustc::hir;\n use rustc::ty::layout::{self, Layout};\n@@ -313,25 +310,6 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     }\n }\n \n-pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n-                                             source_ty: Ty<'tcx>,\n-                                             target_ty: Ty<'tcx>)\n-                                             -> CustomCoerceUnsized {\n-    let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n-    });\n-\n-    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n-        traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n-        }\n-        vtable => {\n-            bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n-        }\n-    }\n-}\n-\n pub fn cast_shift_expr_rhs(\n     cx: &Builder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {"}, {"sha": "70da2a69ef4253c382710367be9b03b22c25859b", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 32, "deletions": 154, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -19,13 +19,13 @@ pub use self::CalleeData::*;\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::{Substs, Subst};\n-use rustc::traits;\n use abi::{Abi, FnType};\n use attributes;\n use builder::Builder;\n use common::{self, CrateContext};\n use cleanup::CleanupScope;\n use mir::lvalue::LvalueRef;\n+use monomorphize;\n use consts;\n use common::instance_ty;\n use declare;\n@@ -38,8 +38,6 @@ use type_of;\n use rustc::ty::{self, Ty, TypeFoldable};\n use std::iter;\n \n-use syntax_pos::DUMMY_SP;\n-\n use mir::lvalue::Alignment;\n \n #[derive(Debug)]\n@@ -60,102 +58,48 @@ pub struct Callee<'tcx> {\n }\n \n impl<'tcx> Callee<'tcx> {\n-    /// Function pointer.\n-    pub fn ptr(llfn: ValueRef, ty: Ty<'tcx>) -> Callee<'tcx> {\n-        Callee {\n-            data: Fn(llfn),\n-            ty: ty\n-        }\n-    }\n-\n     /// Function or method definition.\n     pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>)\n                    -> Callee<'tcx> {\n-        let tcx = ccx.tcx();\n-\n-        if let Some(trait_id) = tcx.trait_of_item(def_id) {\n-            return Callee::trait_method(ccx, trait_id, def_id, substs);\n-        }\n-\n-        let instance = ty::Instance::new(def_id, substs);\n-        let fn_ty = instance_ty(ccx.shared(), &instance);\n-        if let ty::TyFnDef(.., f) = fn_ty.sty {\n-            if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n-                return Callee {\n-                    data: Intrinsic,\n-                    ty: fn_ty\n+        let instance = monomorphize::resolve(ccx.shared(), def_id, substs);\n+        let ty = instance_ty(ccx.shared(), &instance);\n+        let data = match instance.def {\n+            ty::InstanceDef::Intrinsic(_) => Intrinsic,\n+            ty::InstanceDef::ClosureOnceShim { .. } => {\n+                let closure_ty = instance.substs.type_at(0);\n+                let (closure_def_id, closure_substs) = match closure_ty.sty {\n+                    ty::TyClosure(def_id, substs) => (def_id, substs),\n+                    _ => bug!(\"bad closure instance {:?}\", instance)\n                 };\n-            }\n-        }\n-\n-        let (llfn, ty) = get_fn(ccx, instance);\n-        Callee::ptr(llfn, ty)\n-    }\n \n-    /// Trait method, which has to be resolved to an impl method.\n-    pub fn trait_method<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                            trait_id: DefId,\n-                            def_id: DefId,\n-                            substs: &'tcx Substs<'tcx>)\n-                            -> Callee<'tcx> {\n-        let tcx = ccx.tcx();\n-\n-        let trait_ref = ty::TraitRef::from_method(tcx, trait_id, substs);\n-        let trait_ref = tcx.normalize_associated_type(&ty::Binder(trait_ref));\n-        match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let name = tcx.item_name(def_id);\n-                let instance = common::find_method(tcx, name, substs, &vtable_impl);\n-\n-                // Translate the function, bypassing Callee::def.\n-                // That is because default methods have the same ID as the\n-                // trait method used to look up the impl method that ended\n-                // up here, so calling Callee::def would infinitely recurse.\n-                let (llfn, ty) = get_fn(ccx, instance);\n-                Callee::ptr(llfn, ty)\n-            }\n-            traits::VtableClosure(vtable_closure) => {\n-                // The substitutions should have no type parameters remaining\n-                // after passing through fulfill_obligation\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let instance = Instance::new(def_id, substs);\n-                let llfn = trans_closure_method(\n+                Fn(trans_fn_once_adapter_shim(\n                     ccx,\n-                    vtable_closure.closure_def_id,\n-                    vtable_closure.substs,\n+                    closure_def_id,\n+                    closure_substs,\n                     instance,\n-                    trait_closure_kind);\n-\n-                let method_ty = instance_ty(ccx.shared(), &instance);\n-                Callee::ptr(llfn, method_ty)\n-            }\n-            traits::VtableFnPointer(data) => {\n-                let instance = ty::Instance {\n-                    def: ty::InstanceDef::FnPtrShim(def_id, data.fn_ty),\n-                    substs: substs,\n-                };\n-\n-                let (llfn, ty) = get_fn(ccx, instance);\n-                Callee::ptr(llfn, ty)\n+                    get_fn(\n+                        ccx,\n+                        Instance::new(closure_def_id, closure_substs.substs)\n+                    )\n+                ))\n             }\n-            traits::VtableObject(ref data) => {\n-                Callee {\n-                    data: Virtual(tcx.get_vtable_index_of_object_method(data, def_id)),\n-                    ty: instance_ty(ccx.shared(), &Instance::new(def_id, substs))\n-                }\n+            ty::InstanceDef::Virtual(_, n) => Virtual(n),\n+            ty::InstanceDef::FnPtrShim(..) |\n+            ty::InstanceDef::Item(..) => {\n+                Fn(get_fn(ccx, instance))\n             }\n-            vtable => {\n-                bug!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n-            }\n-        }\n+        };\n+\n+        Callee { data, ty }\n     }\n \n     /// Get the abi::FnType for a direct call. Mainly deals with the fact\n     /// that a Virtual call doesn't take the vtable, like its shim does.\n     /// The extra argument types are for variadic (extern \"C\") functions.\n     pub fn direct_fn_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n                               extra_args: &[Ty<'tcx>]) -> FnType {\n-        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&self.ty.fn_sig());\n+        let sig = common::ty_fn_sig(ccx, self.ty);\n+        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         if let Virtual(_) = self.data {\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n@@ -175,72 +119,6 @@ impl<'tcx> Callee<'tcx> {\n     }\n }\n \n-fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                  def_id: DefId,\n-                                  substs: ty::ClosureSubsts<'tcx>,\n-                                  method_instance: Instance<'tcx>,\n-                                  trait_closure_kind: ty::ClosureKind)\n-                                  -> ValueRef\n-{\n-    // If this is a closure, redirect to it.\n-    let (llfn, _) = get_fn(ccx, Instance::new(def_id, substs.substs));\n-\n-    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n-    // then adapt the self type\n-    let llfn_closure_kind = ccx.tcx().closure_kind(def_id);\n-\n-    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n-           trait_closure_kind={:?}, llfn={:?})\",\n-           llfn_closure_kind, trait_closure_kind, Value(llfn));\n-\n-    match needs_fn_once_adapter_shim(llfn_closure_kind, trait_closure_kind) {\n-        Ok(true) => trans_fn_once_adapter_shim(ccx,\n-                                               def_id,\n-                                               substs,\n-                                               method_instance,\n-                                               llfn),\n-        Ok(false) => llfn,\n-        Err(()) => {\n-            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                 llfn_closure_kind,\n-                 trait_closure_kind);\n-        }\n-    }\n-}\n-\n-pub fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n-                                  trait_closure_kind: ty::ClosureKind)\n-                                  -> Result<bool, ()>\n-{\n-    match (actual_closure_kind, trait_closure_kind) {\n-        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n-            // No adapter needed.\n-           Ok(false)\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n-            // basically the same thing, so we can just return llfn.\n-            Ok(false)\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n-            // this by doing something like:\n-            //\n-            //     fn call_once(self, ...) { call_mut(&self, ...) }\n-            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-            //\n-            // These are both the same at trans time.\n-            Ok(true)\n-        }\n-        _ => Err(()),\n-    }\n-}\n-\n fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     def_id: DefId,\n@@ -307,7 +185,6 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // the first argument (`self`) will be the (by value) closure env.\n \n     let mut llargs = get_params(lloncefn);\n-    let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n     let self_idx = fn_ty.ret.is_indirect() as usize;\n     let env_arg = &orig_fn_ty.args[0];\n@@ -344,7 +221,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     }\n     fn_ty.apply_attrs_callsite(llret);\n \n-    if fn_ret.0.is_never() {\n+    if sig.output().is_never() {\n         bcx.unreachable();\n     } else {\n         self_scope.trans(&bcx);\n@@ -372,7 +249,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n /// - `substs`: values for each of the fn/method's parameters\n fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     instance: Instance<'tcx>)\n-                    -> (ValueRef, Ty<'tcx>) {\n+                    -> ValueRef\n+{\n     let tcx = ccx.tcx();\n \n     debug!(\"get_fn(instance={:?})\", instance);\n@@ -383,7 +261,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let fn_ty = common::instance_ty(ccx.shared(), &instance);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-        return (llfn, fn_ty);\n+        return llfn;\n     }\n \n     let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n@@ -455,5 +333,5 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     ccx.instances().borrow_mut().insert(instance, llfn);\n \n-    (llfn, fn_ty)\n+    llfn\n }"}, {"sha": "9476ffc9444857dfc64440da936a49567c213b0c", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 53, "deletions": 182, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -203,11 +203,8 @@ use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n use syntax::abi::Abi;\n-use syntax_pos::DUMMY_SP;\n-use base::custom_coerce_unsize_info;\n-use callee::needs_fn_once_adapter_shim;\n use context::SharedCrateContext;\n-use common::{def_ty, find_method, instance_ty, fulfill_obligation};\n+use common::{def_ty, instance_ty};\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -555,7 +552,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         let substs = monomorphize::apply_param_substs(self.scx,\n                                                                       self.param_substs,\n                                                                       &substs);\n-                        let instance = monomorphize::resolve_const(self.scx, def_id, substs);\n+                        let instance = monomorphize::resolve(self.scx, def_id, substs);\n                         collect_neighbours(self.scx, instance, self.output);\n                     }\n \n@@ -580,32 +577,23 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             let callee_substs = monomorphize::apply_param_substs(self.scx,\n                                                                  self.param_substs,\n                                                                  &callee_substs);\n-            let dispatched = do_static_dispatch(self.scx,\n-                                                callee_def_id,\n-                                                callee_substs);\n-\n-            if let StaticDispatchResult::Dispatched {\n-                instance, fn_once_adjustment\n-            } = dispatched {\n-                // if we have a concrete impl (which we might not have\n-                // in the case of something compiler generated like an\n-                // object shim or a closure that is handled differently),\n-                // we check if the callee is something that will actually\n-                // result in a translation item ...\n-                if should_trans_locally(self.scx.tcx(), &instance) {\n-                    self.output.push(create_fn_trans_item(instance));\n-\n-                    // This call will instantiate an FnOnce adapter, which drops\n-                    // the closure environment. Therefore we need to make sure\n-                    // that we collect the drop-glue for the environment type.\n-                    if let Some(env_ty) = fn_once_adjustment {\n-                        let env_ty = glue::get_drop_glue_type(self.scx, env_ty);\n-                        if self.scx.type_needs_drop(env_ty) {\n-                            let dg = DropGlueKind::Ty(env_ty);\n-                            self.output.push(TransItem::DropGlue(dg));\n-                        }\n+            let instance =\n+                monomorphize::resolve(self.scx, callee_def_id, callee_substs);\n+            if should_trans_locally(self.scx.tcx(), &instance) {\n+                if let ty::InstanceDef::ClosureOnceShim { .. } = instance.def {\n+                    // This call will instantiate an FnOnce adapter, which\n+                    // drops the closure environment. Therefore we need to\n+                    // make sure that we collect the drop-glue for the\n+                    // environment type.\n+\n+                    let env_ty = instance.substs.type_at(0);\n+                    let env_ty = glue::get_drop_glue_type(self.scx, env_ty);\n+                    if self.scx.type_needs_drop(env_ty) {\n+                        let dg = DropGlueKind::Ty(env_ty);\n+                        self.output.push(TransItem::DropGlue(dg));\n                     }\n                 }\n+                self.output.push(create_fn_trans_item(instance));\n             }\n         }\n \n@@ -664,8 +652,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n                                   -> bool {\n     let def_id = match instance.def {\n-        ty::InstanceDef::Item(def_id) => def_id,\n-        ty::InstanceDef::FnPtrShim(..) => return true\n+        ty::InstanceDef::Item(def_id) |\n+        ty::InstanceDef::ClosureOnceShim {\n+            call_once: _, closure_did: def_id\n+        } => def_id,\n+        ty::InstanceDef::FnPtrShim(..) => return true,\n+        ty::InstanceDef::Virtual(..) |\n+        ty::InstanceDef::Intrinsic(_) => return false\n     };\n     match tcx.hir.get_if_local(def_id) {\n         Some(hir_map::NodeForeignItem(..)) => {\n@@ -718,31 +711,21 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     // If the type implements Drop, also add a translation item for the\n     // monomorphized Drop::drop() implementation.\n-    let destructor = match ty.sty {\n-        ty::TyAdt(def, _) => def.destructor(scx.tcx()),\n-        _ => None\n+    let has_dtor = match ty.sty {\n+        ty::TyAdt(def, _) => def.has_dtor(scx.tcx()),\n+        _ => false\n     };\n \n-    if let (Some(destructor), false) = (destructor, ty.is_box()) {\n-        use rustc::ty::ToPolyTraitRef;\n-\n+    if has_dtor && !ty.is_box() {\n         let drop_trait_def_id = scx.tcx()\n                                    .lang_items\n                                    .drop_trait()\n                                    .unwrap();\n-\n-        let self_type_substs = scx.tcx().mk_substs_trait(ty, &[]);\n-\n-        let trait_ref = ty::TraitRef {\n-            def_id: drop_trait_def_id,\n-            substs: self_type_substs,\n-        }.to_poly_trait_ref();\n-\n-        let substs = match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n-            traits::VtableImpl(data) => data.substs,\n-            _ => bug!()\n-        };\n-        let instance = Instance::new(destructor.did, substs);\n+        let drop_method = scx.tcx().associated_items(drop_trait_def_id)\n+            .find(|it| it.kind == ty::AssociatedKind::Method)\n+            .unwrap().def_id;\n+        let substs = scx.tcx().mk_substs_trait(ty, &[]);\n+        let instance = monomorphize::resolve(scx, drop_method, substs);\n         if should_trans_locally(scx.tcx(), &instance) {\n             output.push(create_fn_trans_item(instance));\n         }\n@@ -817,115 +800,6 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-enum StaticDispatchResult<'tcx> {\n-    // The call could be resolved statically as going to the method with\n-    // `instance`.\n-    Dispatched {\n-        instance: Instance<'tcx>,\n-        // If this is a call to a closure that needs an FnOnce adjustment,\n-        // this contains the new self type of the call (= type of the closure\n-        // environment)\n-        fn_once_adjustment: Option<ty::Ty<'tcx>>,\n-    },\n-    // This goes to somewhere that we don't know at compile-time\n-    Unknown\n-}\n-\n-fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                fn_def_id: DefId,\n-                                fn_substs: &'tcx Substs<'tcx>)\n-                                -> StaticDispatchResult<'tcx> {\n-    debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?})\",\n-           def_id_to_string(scx.tcx(), fn_def_id),\n-           fn_substs);\n-    if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n-        debug!(\" => trait method, attempting to find impl\");\n-        do_static_trait_method_dispatch(scx,\n-                                        &scx.tcx().associated_item(fn_def_id),\n-                                        trait_def_id,\n-                                        fn_substs)\n-    } else {\n-        debug!(\" => regular function\");\n-        // The function is not part of an impl or trait, no dispatching\n-        // to be done\n-        StaticDispatchResult::Dispatched {\n-            instance: Instance::new(fn_def_id, fn_substs),\n-            fn_once_adjustment: None,\n-        }\n-    }\n-}\n-\n-// Given a trait-method and substitution information, find out the actual\n-// implementation of the trait method.\n-fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                             trait_method: &ty::AssociatedItem,\n-                                             trait_id: DefId,\n-                                             rcvr_substs: &'tcx Substs<'tcx>)\n-                                             -> StaticDispatchResult<'tcx> {\n-    let tcx = scx.tcx();\n-    debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n-                                            trait_id={}, \\\n-                                            rcvr_substs={:?})\",\n-           def_id_to_string(scx.tcx(), trait_method.def_id),\n-           def_id_to_string(scx.tcx(), trait_id),\n-           rcvr_substs);\n-\n-    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n-\n-    // Now that we know which impl is being used, we can dispatch to\n-    // the actual function:\n-    match vtbl {\n-        traits::VtableImpl(impl_data) => {\n-            StaticDispatchResult::Dispatched {\n-                instance: find_method(tcx, trait_method.name, rcvr_substs, &impl_data),\n-                fn_once_adjustment: None,\n-            }\n-        }\n-        traits::VtableClosure(closure_data) => {\n-            let closure_def_id = closure_data.closure_def_id;\n-            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-            let actual_closure_kind = tcx.closure_kind(closure_def_id);\n-\n-            let needs_fn_once_adapter_shim =\n-                match needs_fn_once_adapter_shim(actual_closure_kind,\n-                                                 trait_closure_kind) {\n-                Ok(true) => true,\n-                _ => false,\n-            };\n-\n-            let fn_once_adjustment = if needs_fn_once_adapter_shim {\n-                Some(tcx.mk_closure_from_closure_substs(closure_def_id,\n-                                                        closure_data.substs))\n-            } else {\n-                None\n-            };\n-\n-            StaticDispatchResult::Dispatched {\n-                instance: Instance::new(closure_def_id, closure_data.substs.substs),\n-                fn_once_adjustment: fn_once_adjustment,\n-            }\n-        }\n-        traits::VtableFnPointer(ref data) => {\n-            StaticDispatchResult::Dispatched {\n-                instance: Instance {\n-                    def: ty::InstanceDef::FnPtrShim(trait_method.def_id, data.fn_ty),\n-                    substs: trait_ref.substs\n-                },\n-                fn_once_adjustment: None,\n-            }\n-        }\n-        // Trait object shims are always instantiated in-place, and as they are\n-        // just an ABI-adjusting indirect call they do not have any dependencies.\n-        traits::VtableObject(..) => {\n-            StaticDispatchResult::Unknown\n-        }\n-        _ => {\n-            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n-        }\n-    }\n-}\n-\n /// For given pair of source and target type that occur in an unsizing coercion,\n /// this function finds the pair of types that determines the vtable linking\n /// them.\n@@ -991,7 +865,8 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n          &ty::TyAdt(target_adt_def, target_substs)) => {\n             assert_eq!(source_adt_def, target_adt_def);\n \n-            let kind = custom_coerce_unsize_info(scx, source_ty, target_ty);\n+            let kind =\n+                monomorphize::custom_coerce_unsize_info(scx, source_ty, target_ty);\n \n             let coerce_index = match kind {\n                 CustomCoerceUnsized::Struct(i) => i\n@@ -1017,6 +892,20 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n     debug!(\"create_fn_trans_item(instance={})\", instance);\n+    let instance = match instance.def {\n+        ty::InstanceDef::ClosureOnceShim { .. } => {\n+            // HACK: don't create ClosureOnce trans items for now\n+            // have someone else generate the drop glue\n+            let closure_ty = instance.substs.type_at(0);\n+            match closure_ty.sty {\n+                ty::TyClosure(def_id, substs) => {\n+                    Instance::new(def_id, substs.substs)\n+                }\n+                _ => bug!(\"bad closure instance {:?}\", instance)\n+            }\n+        }\n+        _ => instance\n+    };\n     TransItem::Fn(instance)\n }\n \n@@ -1037,18 +926,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n-                .filter_map(|(def_id, substs)| {\n-                    if let StaticDispatchResult::Dispatched {\n-                        instance,\n-                        // We already add the drop-glue for the closure env\n-                        // unconditionally below.\n-                        fn_once_adjustment: _ ,\n-                    } = do_static_dispatch(scx, def_id, substs) {\n-                        Some(instance)\n-                    } else {\n-                        None\n-                    }\n-                })\n+                .map(|(def_id, substs)| monomorphize::resolve(scx, def_id, substs))\n                 .filter(|&instance| should_trans_locally(scx.tcx(), &instance))\n                 .map(|instance| create_fn_trans_item(instance));\n             output.extend(methods);\n@@ -1203,18 +1081,11 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    // The substitutions we have are on the impl, so we grab\n-                    // the method type from the impl to substitute into.\n-                    let impl_substs = tcx.empty_substs_for_def_id(impl_def_id);\n-                    let impl_data = traits::VtableImplData {\n-                        impl_def_id: impl_def_id,\n-                        substs: impl_substs,\n-                        nested: vec![]\n-                    };\n-                    let instance = find_method(tcx, method.name, callee_substs, &impl_data);\n+                    let instance =\n+                        monomorphize::resolve(scx, method.def_id, callee_substs);\n \n                     let predicates = tcx.item_predicates(instance.def_id()).predicates\n-                        .subst(tcx, impl_substs);\n+                        .subst(tcx, instance.substs);\n                     if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n                     }"}, {"sha": "431325c5ec74ed4e8c9ae9ccdc398833fc09b3d4", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -17,7 +17,6 @@ use llvm::{ValueRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use base;\n use builder::Builder;\n@@ -30,13 +29,11 @@ use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::traits::{self, SelectionContext, Reveal};\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n use std::iter;\n \n-use syntax::ast;\n use syntax::attr;\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n@@ -427,73 +424,6 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n-/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n-/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                    span: Span,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> traits::Vtable<'tcx, ()>\n-{\n-    let tcx = scx.tcx();\n-\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n-\n-    scx.trait_cache().memoize(trait_ref, || {\n-        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-               trait_ref, trait_ref.def_id());\n-\n-        // Do the initial selection for the obligation. This yields the\n-        // shallow result we are looking for -- that is, what specific impl.\n-        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-\n-            let obligation_cause = traits::ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-            let obligation = traits::Obligation::new(obligation_cause,\n-                                                     trait_ref.to_poly_trait_predicate());\n-\n-            let selection = match selcx.select(&obligation) {\n-                Ok(Some(selection)) => selection,\n-                Ok(None) => {\n-                    // Ambiguity can happen when monomorphizing during trans\n-                    // expands to some humongo type that never occurred\n-                    // statically -- this humongo type can then overflow,\n-                    // leading to an ambiguous result. So report this as an\n-                    // overflow bug, since I believe this is the only case\n-                    // where ambiguity can result.\n-                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                            presuming due to overflow\",\n-                           trait_ref);\n-                    tcx.sess.span_fatal(span,\n-                        \"reached the recursion limit during monomorphization \\\n-                         (selection ambiguity)\");\n-                }\n-                Err(e) => {\n-                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                              e, trait_ref)\n-                }\n-            };\n-\n-            debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-            // Currently, we use a fulfillment context to completely resolve\n-            // all nested obligations. This is because they can inform the\n-            // inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-            vtable\n-        })\n-    })\n-}\n-\n pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,\n@@ -617,6 +547,7 @@ pub fn requests_inline<'a, 'tcx>(\n         _ => attr::requests_inline(&tcx.get_attrs(def_id)[..]),\n     }\n }\n+\n /// Given a DefId and some Substs, produces the monomorphic item type.\n pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                         def_id: DefId,\n@@ -635,14 +566,3 @@ pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n     let ty = instance.def.def_ty(shared.tcx());\n     monomorphize::apply_param_substs(shared, instance.substs, &ty)\n }\n-\n-pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             name: ast::Name,\n-                             substs: &'tcx Substs<'tcx>,\n-                             impl_data: &traits::VtableImplData<'tcx, ()>)\n-                             -> ty::Instance<'tcx>\n-{\n-    let (def_id, substs) = traits::find_method(tcx, name, substs, impl_data);\n-    let substs = tcx.erase_regions(&substs);\n-    ty::Instance::new(def_id, substs)\n-}"}, {"sha": "2eb94aa56ab50ecd1c9309dfb7c8b8625ee26c50", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -39,7 +39,6 @@ use value::Value;\n use Disr;\n use builder::Builder;\n \n-use syntax_pos::DUMMY_SP;\n use mir::lvalue::Alignment;\n \n pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) {\n@@ -241,8 +240,6 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             let shallow_drop = def.is_union();\n             let tcx = bcx.tcx();\n \n-            let def = t.ty_adt_def().unwrap();\n-\n             // Be sure to put the contents into a scope so we can use an invoke\n             // instruction to call the user destructor but still call the field\n             // destructors if the user destructor panics.\n@@ -256,17 +253,12 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             } else {\n                 CleanupScope::noop()\n             };\n-\n-            let trait_ref = ty::Binder(ty::TraitRef {\n-                def_id: tcx.lang_items.drop_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(t, &[])\n-            });\n-            let vtbl = match fulfill_obligation(bcx.ccx.shared(), DUMMY_SP, trait_ref) {\n-                traits::VtableImpl(data) => data,\n-                _ => bug!(\"dtor for {:?} is not an impl???\", t)\n-            };\n-            let dtor_did = def.destructor(tcx).unwrap().did;\n-            let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n+            let drop_trait_def_id = tcx.lang_items.drop_trait().unwrap();\n+            let drop_method = tcx.associated_items(drop_trait_def_id)\n+                .find(|it| it.kind == ty::AssociatedKind::Method)\n+                .unwrap().def_id;\n+            let self_type_substs = tcx.mk_substs_trait(t, &[]);\n+            let callee = Callee::def(bcx.ccx, drop_method, self_type_substs);\n             let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n             let llret;\n             let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];"}, {"sha": "49cc0b5fad4016213a6d91444850ce8eb90a1c44", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -28,6 +28,7 @@\n #![feature(box_syntax)]\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n+#![cfg_attr(stage0, feature(field_init_shorthand))]\n #![allow(unused_attributes)]\n #![feature(i128_type)]\n #![feature(libc)]"}, {"sha": "69009ab3560448443843cb32d4a76fbe8ec16f01", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -249,7 +249,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = monomorphize::resolve_const(ccx.shared(), def_id, substs);\n+        let instance = monomorphize::resolve(ccx.shared(), def_id, substs);\n         let mir = ccx.tcx().instance_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }"}, {"sha": "bf073d8b97844c58682460c120a380978ed963b0", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 239, "deletions": 17, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -8,38 +8,260 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use abi::Abi;\n use common::*;\n+\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n-use rustc::traits;\n+use rustc::traits::{self, SelectionContext, Reveal};\n+use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::fold::{TypeFolder, TypeFoldable};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::common::MemoizationMap;\n \n-use syntax::codemap::DUMMY_SP;\n+use syntax::ast;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n pub use rustc::ty::Instance;\n \n-/// For associated constants from traits, return the impl definition.\n-pub fn resolve_const<'a, 'tcx>(\n-    scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>\n+fn fn_once_adapter_instance<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    closure_did: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    ) -> Instance<'tcx> {\n+    debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n+           closure_did,\n+           substs);\n+    let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+    let call_once = tcx.associated_items(fn_once)\n+        .find(|it| it.kind == ty::AssociatedKind::Method)\n+        .unwrap().def_id;\n+    let def = ty::InstanceDef::ClosureOnceShim { call_once, closure_did };\n+\n+    let self_ty = tcx.mk_closure_from_closure_substs(\n+        closure_did, substs);\n+\n+    let sig = tcx.closure_type(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.inputs().len(), 1);\n+    let substs = tcx.mk_substs([\n+        Kind::from(self_ty),\n+        Kind::from(sig.inputs()[0]),\n+    ].iter().cloned());\n+\n+    debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n+    Instance { def, substs }\n+}\n+\n+/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n+/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n+/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n+fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                span: Span,\n+                                trait_ref: ty::PolyTraitRef<'tcx>)\n+                                -> traits::Vtable<'tcx, ()>\n+{\n+    let tcx = scx.tcx();\n+\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = tcx.erase_regions(&trait_ref);\n+\n+    scx.trait_cache().memoize(trait_ref, || {\n+        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+               trait_ref, trait_ref.def_id());\n+\n+        // Do the initial selection for the obligation. This yields the\n+        // shallow result we are looking for -- that is, what specific impl.\n+        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+            let mut selcx = SelectionContext::new(&infcx);\n+\n+            let obligation_cause = traits::ObligationCause::misc(span,\n+                                                             ast::DUMMY_NODE_ID);\n+            let obligation = traits::Obligation::new(obligation_cause,\n+                                                     trait_ref.to_poly_trait_predicate());\n+\n+            let selection = match selcx.select(&obligation) {\n+                Ok(Some(selection)) => selection,\n+                Ok(None) => {\n+                    // Ambiguity can happen when monomorphizing during trans\n+                    // expands to some humongo type that never occurred\n+                    // statically -- this humongo type can then overflow,\n+                    // leading to an ambiguous result. So report this as an\n+                    // overflow bug, since I believe this is the only case\n+                    // where ambiguity can result.\n+                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                            presuming due to overflow\",\n+                           trait_ref);\n+                    tcx.sess.span_fatal(span,\n+                        \"reached the recursion limit during monomorphization \\\n+                         (selection ambiguity)\");\n+                }\n+                Err(e) => {\n+                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                              e, trait_ref)\n+                }\n+            };\n+\n+            debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+            // Currently, we use a fulfillment context to completely resolve\n+            // all nested obligations. This is because they can inform the\n+            // inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+            vtable\n+        })\n+    })\n+}\n+\n+fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n+                              trait_closure_kind: ty::ClosureKind)\n+                              -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+           Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            Ok(true)\n+        }\n+        _ => Err(()),\n+    }\n+}\n+\n+fn resolve_associated_item<'a, 'tcx>(\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    trait_item: &ty::AssociatedItem,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n ) -> Instance<'tcx> {\n-    if let Some(trait_id) = scx.tcx().trait_of_item(def_id) {\n-        let trait_ref = ty::TraitRef::new(trait_id, substs);\n-        let trait_ref = ty::Binder(trait_ref);\n-        let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n-        if let traits::VtableImpl(vtable_impl) = vtable {\n-            let name = scx.tcx().item_name(def_id);\n-            let ac = scx.tcx().associated_items(vtable_impl.impl_def_id)\n-                .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n-            if let Some(ac) = ac {\n-                return Instance::new(ac.def_id, vtable_impl.substs);\n+    let tcx = scx.tcx();\n+    let def_id = trait_item.def_id;\n+    debug!(\"resolve_associated_item(trait_item={:?}, \\\n+                                    trait_id={:?}, \\\n+                                    rcvr_substs={:?})\",\n+           def_id, trait_id, rcvr_substs);\n+\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(impl_data) => {\n+            let (def_id, substs) = traits::find_associated_item(\n+                tcx, trait_item, rcvr_substs, &impl_data);\n+            let substs = tcx.erase_regions(&substs);\n+            ty::Instance::new(def_id, substs)\n+        }\n+        traits::VtableClosure(closure_data) => {\n+            let closure_def_id = closure_data.closure_def_id;\n+            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            let actual_closure_kind = tcx.closure_kind(closure_def_id);\n+\n+            match needs_fn_once_adapter_shim(actual_closure_kind,\n+                                             trait_closure_kind) {\n+                Ok(true) => fn_once_adapter_instance(\n+                    tcx, closure_def_id, closure_data.substs),\n+                _ => Instance::new(closure_def_id, closure_data.substs.substs),\n+            }\n+        }\n+        traits::VtableFnPointer(ref data) => {\n+            Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs\n+            }\n+        }\n+        traits::VtableObject(ref data) => {\n+            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            Instance {\n+                def: ty::InstanceDef::Virtual(def_id, index),\n+                substs: rcvr_substs\n             }\n         }\n+        _ => {\n+            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n+        }\n     }\n+}\n \n-    Instance::new(def_id, substs)\n+/// The point where linking happens. Resolve a (def_id, substs)\n+/// pair to an instance.\n+pub fn resolve<'a, 'tcx>(\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>\n+) -> Instance<'tcx> {\n+    debug!(\"resolve(def_id={:?}, substs={:?})\",\n+           def_id, substs);\n+    let result = if let Some(trait_def_id) = scx.tcx().trait_of_item(def_id) {\n+        debug!(\" => associated item, attempting to find impl\");\n+        let item = scx.tcx().associated_item(def_id);\n+        resolve_associated_item(scx, &item, trait_def_id, substs)\n+    } else {\n+        let item_type = def_ty(scx, def_id, substs);\n+        let def = match item_type.sty {\n+            ty::TyFnDef(_, _, f) if\n+                f.abi() == Abi::RustIntrinsic ||\n+                f.abi() == Abi::PlatformIntrinsic =>\n+            {\n+                debug!(\" => intrinsic\");\n+                ty::InstanceDef::Intrinsic(def_id)\n+            }\n+            _ => {\n+                debug!(\" => free item\");\n+                ty::InstanceDef::Item(def_id)\n+            }\n+        };\n+        Instance { def, substs }\n+    };\n+    debug!(\"resolve(def_id={:?}, substs={:?}) = {}\",\n+           def_id, substs, result);\n+    result\n+}\n+\n+pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n+                                             source_ty: Ty<'tcx>,\n+                                             target_ty: Ty<'tcx>)\n+                                             -> CustomCoerceUnsized {\n+    let trait_ref = ty::Binder(ty::TraitRef {\n+        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n+        substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n+    });\n+\n+    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n+        traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n+            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n+        }\n+        vtable => {\n+            bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n+        }\n+    }\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope"}, {"sha": "d0cf32508d44c2b94f31407a23e8bc3b49aceeda", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac5ba5dab758803b06add74457eba03bbbd9930/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=aac5ba5dab758803b06add74457eba03bbbd9930", "patch": "@@ -458,7 +458,10 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n         TransItem::Fn(instance) => {\n             let def_id = match instance.def {\n                 ty::InstanceDef::Item(def_id) => def_id,\n-                ty::InstanceDef::FnPtrShim(..) => return None\n+                ty::InstanceDef::FnPtrShim(..) |\n+                ty::InstanceDef::ClosureOnceShim { .. } |\n+                ty::InstanceDef::Intrinsic(..) |\n+                ty::InstanceDef::Virtual(..) => return None\n             };\n \n             // If this is a method, we want to put it into the same module as"}]}