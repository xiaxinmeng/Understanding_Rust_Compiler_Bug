{"sha": "68b7475dc04d4429d4bfb4837a902090915b6584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4Yjc0NzVkYzA0ZDQ0MjlkNGJmYjQ4MzdhOTAyMDkwOTE1YjY1ODQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-15T12:22:59Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-28T07:43:24Z"}, "message": "move \"ADT master drop flag\" logic to `open_drop_for_adt_contents`\n\nFixes #41888.", "tree": {"sha": "b609f5c40ea5b56ee0f4bd4600141dbfff2eec01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b609f5c40ea5b56ee0f4bd4600141dbfff2eec01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68b7475dc04d4429d4bfb4837a902090915b6584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68b7475dc04d4429d4bfb4837a902090915b6584", "html_url": "https://github.com/rust-lang/rust/commit/68b7475dc04d4429d4bfb4837a902090915b6584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68b7475dc04d4429d4bfb4837a902090915b6584/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d0b5bdd81a2b87351afb587e02c557e9e6355e", "html_url": "https://github.com/rust-lang/rust/commit/c6d0b5bdd81a2b87351afb587e02c557e9e6355e"}], "stats": {"total": 484, "additions": 351, "deletions": 133}, "files": [{"sha": "3ec27db60c2bf9f1f5ff7f10b20110d24ed123f5", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 140, "deletions": 133, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/68b7475dc04d4429d4bfb4837a902090915b6584/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b7475dc04d4429d4bfb4837a902090915b6584/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=68b7475dc04d4429d4bfb4837a902090915b6584", "patch": "@@ -243,30 +243,37 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     }\n \n     /// Create one-half of the drop ladder for a list of fields, and return\n-    /// the list of steps in it in reverse order.\n+    /// the list of steps in it in reverse order, with the first step\n+    /// dropping 0 fields and so on.\n     ///\n     /// `unwind_ladder` is such a list of steps in reverse order,\n     /// which is called if the matching step of the drop glue panics.\n     fn drop_halfladder(&mut self,\n                        unwind_ladder: &[Unwind],\n-                       succ: BasicBlock,\n+                       mut succ: BasicBlock,\n                        fields: &[(Lvalue<'tcx>, Option<D::Path>)])\n                        -> Vec<BasicBlock>\n     {\n-        let goto = TerminatorKind::Goto { target: succ };\n-        let mut succ = self.new_block(unwind_ladder[0], goto);\n-\n-        // Always clear the \"master\" drop flag at the bottom of the\n-        // ladder. This is needed because the \"master\" drop flag\n-        // protects the ADT's discriminant, which is invalidated\n-        // after the ADT is dropped.\n-        let succ_loc = Location { block: succ, statement_index: 0 };\n-        self.elaborator.clear_drop_flag(succ_loc, self.path, DropFlagMode::Shallow);\n-\n-        fields.iter().rev().zip(unwind_ladder).map(|(&(ref lv, path), &unwind_succ)| {\n-            succ = self.drop_subpath(lv, path, succ, unwind_succ);\n-            succ\n-        }).collect()\n+        Some(succ).into_iter().chain(\n+            fields.iter().rev().zip(unwind_ladder)\n+                .map(|(&(ref lv, path), &unwind_succ)| {\n+                    succ = self.drop_subpath(lv, path, succ, unwind_succ);\n+                    succ\n+                })\n+        ).collect()\n+    }\n+\n+    fn drop_ladder_bottom(&mut self) -> (BasicBlock, Unwind) {\n+        // Clear the \"master\" drop flag at the end. This is needed\n+        // because the \"master\" drop protects the ADT's discriminant,\n+        // which is invalidated after the ADT is dropped.\n+        let (succ, unwind) = (self.succ, self.unwind); // FIXME(#6393)\n+        (\n+            self.drop_flag_reset_block(DropFlagMode::Shallow, succ, unwind),\n+            unwind.map(|unwind| {\n+                self.drop_flag_reset_block(DropFlagMode::Shallow, unwind, Unwind::InCleanup)\n+            })\n+        )\n     }\n \n     /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n@@ -283,8 +290,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///     ELAB(drop location.1 [target=.c2])\n     /// .c2:\n     ///     ELAB(drop location.2 [target=`self.unwind`])\n+    ///\n+    /// NOTE: this does not clear the master drop flag, so you need\n+    /// to point succ/unwind on a `drop_ladder_bottom`.\n     fn drop_ladder<'a>(&mut self,\n-                       fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>)\n+                       fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>,\n+                       succ: BasicBlock,\n+                       unwind: Unwind)\n                        -> (BasicBlock, Unwind)\n     {\n         debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n@@ -297,20 +309,17 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n \n         let unwind_ladder = vec![Unwind::InCleanup; fields.len() + 1];\n-        let unwind_ladder: Vec<_> = if let Unwind::To(target) = self.unwind {\n+        let unwind_ladder: Vec<_> = if let Unwind::To(target) = unwind {\n             let halfladder = self.drop_halfladder(&unwind_ladder, target, &fields);\n-            Some(self.unwind).into_iter().chain(halfladder.into_iter().map(Unwind::To))\n-                .collect()\n+            halfladder.into_iter().map(Unwind::To).collect()\n         } else {\n             unwind_ladder\n         };\n \n-        let succ = self.succ; // FIXME(#6393)\n         let normal_ladder =\n             self.drop_halfladder(&unwind_ladder, succ, &fields);\n \n-        (normal_ladder.last().cloned().unwrap_or(succ),\n-         unwind_ladder.last().cloned().unwrap_or(self.unwind))\n+        (*normal_ladder.last().unwrap(), *unwind_ladder.last().unwrap())\n     }\n \n     fn open_drop_for_tuple<'a>(&mut self, tys: &[Ty<'tcx>])\n@@ -323,7 +332,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n              self.elaborator.field_subpath(self.path, Field::new(i)))\n         }).collect();\n \n-        self.drop_ladder(fields).0\n+        let (succ, unwind) = self.drop_ladder_bottom();\n+        self.drop_ladder(fields, succ, unwind).0\n     }\n \n     fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n@@ -370,106 +380,100 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         }\n     }\n \n-    fn open_drop_for_adt_contents<'a>(&mut self, adt: &'tcx ty::AdtDef,\n-                                      substs: &'tcx Substs<'tcx>)\n-                                      -> (BasicBlock, Unwind) {\n-        match adt.variants.len() {\n-            1 => {\n-                let fields = self.move_paths_for_fields(\n-                    self.lvalue,\n-                    self.path,\n-                    &adt.variants[0],\n-                    substs\n-                );\n-                self.drop_ladder(fields)\n-            }\n-            _ => {\n-                let succ = self.succ;\n-                let unwind = self.unwind; // FIXME(#6393)\n+    fn open_drop_for_adt_contents(&mut self, adt: &'tcx ty::AdtDef,\n+                                  substs: &'tcx Substs<'tcx>)\n+                                  -> (BasicBlock, Unwind) {\n+        let (succ, unwind) = self.drop_ladder_bottom();\n+        if adt.variants.len() == 1 {\n+            let fields = self.move_paths_for_fields(\n+                self.lvalue,\n+                self.path,\n+                &adt.variants[0],\n+                substs\n+            );\n+            self.drop_ladder(fields, succ, unwind)\n+        } else {\n+            self.open_drop_for_multivariant(adt, substs, succ, unwind)\n+        }\n+    }\n+\n+    fn open_drop_for_multivariant(&mut self, adt: &'tcx ty::AdtDef,\n+                                  substs: &'tcx Substs<'tcx>,\n+                                  succ: BasicBlock,\n+                                  unwind: Unwind)\n+                                  -> (BasicBlock, Unwind) {\n+        let mut values = Vec::with_capacity(adt.variants.len());\n+        let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n+        let mut unwind_blocks = if unwind.is_cleanup() {\n+            None\n+        } else {\n+            Some(Vec::with_capacity(adt.variants.len()))\n+        };\n+\n+        let mut have_otherwise = false;\n \n-                let mut values = Vec::with_capacity(adt.variants.len());\n-                let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n-                let mut unwind_blocks = if unwind.is_cleanup() {\n-                    None\n-                } else {\n-                    Some(Vec::with_capacity(adt.variants.len()))\n-                };\n-                let mut otherwise = None;\n-                let mut unwind_otherwise = None;\n-                for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n-                    let subpath = self.elaborator.downcast_subpath(\n-                        self.path, variant_index);\n-                    if let Some(variant_path) = subpath {\n-                        let base_lv = self.lvalue.clone().elem(\n-                            ProjectionElem::Downcast(adt, variant_index)\n+        for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n+            let subpath = self.elaborator.downcast_subpath(\n+                self.path, variant_index);\n+            if let Some(variant_path) = subpath {\n+                let base_lv = self.lvalue.clone().elem(\n+                    ProjectionElem::Downcast(adt, variant_index)\n                         );\n-                        let fields = self.move_paths_for_fields(\n-                            &base_lv,\n-                            variant_path,\n-                            &adt.variants[variant_index],\n-                            substs);\n-                        values.push(discr);\n-                        if let Unwind::To(unwind) = unwind {\n-                            // We can't use the half-ladder from the original\n-                            // drop ladder, because this breaks the\n-                            // \"funclet can't have 2 successor funclets\"\n-                            // requirement from MSVC:\n-                            //\n-                            //           switch       unwind-switch\n-                            //          /      \\         /        \\\n-                            //         v1.0    v2.0  v2.0-unwind  v1.0-unwind\n-                            //         |        |      /             |\n-                            //    v1.1-unwind  v2.1-unwind           |\n-                            //      ^                                |\n-                            //       \\-------------------------------/\n-                            //\n-                            // Create a duplicate half-ladder to avoid that. We\n-                            // could technically only do this on MSVC, but I\n-                            // I want to minimize the divergence between MSVC\n-                            // and non-MSVC.\n-\n-                            let unwind_blocks = unwind_blocks.as_mut().unwrap();\n-                            let unwind_ladder = vec![Unwind::InCleanup; fields.len() + 1];\n-                            let halfladder =\n-                                self.drop_halfladder(&unwind_ladder, unwind, &fields);\n-                            unwind_blocks.push(halfladder.last().cloned().unwrap_or(unwind));\n-                        }\n-                        let (normal, _) = self.drop_ladder(fields);\n-                        normal_blocks.push(normal);\n-                    } else {\n-                        // variant not found - drop the entire enum\n-                        if let None = otherwise {\n-                            otherwise = Some(self.complete_drop(\n-                                Some(DropFlagMode::Shallow),\n-                                succ,\n-                                unwind));\n-                            if let Unwind::To(unwind) = unwind {\n-                                unwind_otherwise = Some(self.complete_drop(\n-                                    Some(DropFlagMode::Shallow),\n-                                    unwind,\n-                                    Unwind::InCleanup\n-                                ));\n-                            }\n-                        }\n-                    }\n-                }\n-                if let Some(block) = otherwise {\n-                    normal_blocks.push(block);\n-                    if let Some(ref mut unwind_blocks) = unwind_blocks {\n-                        unwind_blocks.push(unwind_otherwise.unwrap());\n-                    }\n-                } else {\n-                    values.pop();\n+                let fields = self.move_paths_for_fields(\n+                    &base_lv,\n+                    variant_path,\n+                    &adt.variants[variant_index],\n+                    substs);\n+                values.push(discr);\n+                if let Unwind::To(unwind) = unwind {\n+                    // We can't use the half-ladder from the original\n+                    // drop ladder, because this breaks the\n+                    // \"funclet can't have 2 successor funclets\"\n+                    // requirement from MSVC:\n+                    //\n+                    //           switch       unwind-switch\n+                    //          /      \\         /        \\\n+                    //         v1.0    v2.0  v2.0-unwind  v1.0-unwind\n+                    //         |        |      /             |\n+                    //    v1.1-unwind  v2.1-unwind           |\n+                    //      ^                                |\n+                    //       \\-------------------------------/\n+                    //\n+                    // Create a duplicate half-ladder to avoid that. We\n+                    // could technically only do this on MSVC, but I\n+                    // I want to minimize the divergence between MSVC\n+                    // and non-MSVC.\n+\n+                    let unwind_blocks = unwind_blocks.as_mut().unwrap();\n+                    let unwind_ladder = vec![Unwind::InCleanup; fields.len() + 1];\n+                    let halfladder =\n+                        self.drop_halfladder(&unwind_ladder, unwind, &fields);\n+                    unwind_blocks.push(halfladder.last().cloned().unwrap());\n                 }\n+                let (normal, _) = self.drop_ladder(fields, succ, unwind);\n+                normal_blocks.push(normal);\n+            } else {\n+                have_otherwise = true;\n+            }\n+        }\n \n-                (self.adt_switch_block(adt, normal_blocks, &values, succ, unwind),\n-                 unwind.map(|unwind| {\n-                     self.adt_switch_block(\n-                         adt, unwind_blocks.unwrap(), &values, unwind, Unwind::InCleanup\n-                     )\n-                 }))\n+        if have_otherwise {\n+            normal_blocks.push(self.drop_block(succ, unwind));\n+            if let Unwind::To(unwind) = unwind {\n+                unwind_blocks.as_mut().unwrap().push(\n+                    self.drop_block(unwind, Unwind::InCleanup)\n+                        );\n             }\n+        } else {\n+            values.pop();\n         }\n+\n+        (self.adt_switch_block(adt, normal_blocks, &values, succ, unwind),\n+         unwind.map(|unwind| {\n+             self.adt_switch_block(\n+                 adt, unwind_blocks.unwrap(), &values, unwind, Unwind::InCleanup\n+             )\n+         }))\n     }\n \n     fn adt_switch_block(&mut self,\n@@ -652,8 +656,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         });\n \n         // FIXME(#34708): handle partially-dropped array/slice elements.\n-        self.drop_flag_test_and_reset_block(\n-            Some(DropFlagMode::Deep), drop_block, succ, unwind)\n+        let reset_block = self.drop_flag_reset_block(DropFlagMode::Deep, drop_block, unwind);\n+        self.drop_flag_test_block(reset_block, succ, unwind)\n     }\n \n     /// The slow-path - create an \"open\", elaborated drop for a type\n@@ -707,23 +711,26 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         debug!(\"complete_drop({:?},{:?})\", self, drop_mode);\n \n         let drop_block = self.drop_block(succ, unwind);\n-        self.drop_flag_test_and_reset_block(drop_mode, drop_block, succ, unwind)\n+        let drop_block = if let Some(mode) = drop_mode {\n+            self.drop_flag_reset_block(mode, drop_block, unwind)\n+        } else {\n+            drop_block\n+        };\n+\n+        self.drop_flag_test_block(drop_block, succ, unwind)\n     }\n \n-    fn drop_flag_test_and_reset_block(&mut self,\n-                                      drop_mode: Option<DropFlagMode>,\n-                                      drop_block: BasicBlock,\n-                                      succ: BasicBlock,\n-                                      unwind: Unwind) -> BasicBlock\n+    fn drop_flag_reset_block(&mut self,\n+                             mode: DropFlagMode,\n+                             succ: BasicBlock,\n+                             unwind: Unwind) -> BasicBlock\n     {\n-        debug!(\"drop_flag_test_and_reset_block({:?},{:?})\", self, drop_mode);\n-\n-        if let Some(mode) = drop_mode {\n-            let block_start = Location { block: drop_block, statement_index: 0 };\n-            self.elaborator.clear_drop_flag(block_start, self.path, mode);\n-        }\n+        debug!(\"drop_flag_reset_block({:?},{:?})\", self, mode);\n \n-        self.drop_flag_test_block(drop_block, succ, unwind)\n+        let block = self.new_block(unwind, TerminatorKind::Goto { target: succ });\n+        let block_start = Location { block: block, statement_index: 0 };\n+        self.elaborator.clear_drop_flag(block_start, self.path, mode);\n+        block\n     }\n \n     fn elaborated_drop_block<'a>(&mut self) -> BasicBlock {"}, {"sha": "ea4d7d3165d061f5e5371855e9513129bb7c2e27", "filename": "src/test/mir-opt/issue-41888.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/68b7475dc04d4429d4bfb4837a902090915b6584/src%2Ftest%2Fmir-opt%2Fissue-41888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b7475dc04d4429d4bfb4837a902090915b6584/src%2Ftest%2Fmir-opt%2Fissue-41888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41888.rs?ref=68b7475dc04d4429d4bfb4837a902090915b6584", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we clear the \"ADT master drop flag\" even when there are\n+// no fields to be dropped.\n+\n+fn main() {\n+    let e;\n+    if cond() {\n+        e = E::F(K);\n+        if let E::F(_k) = e {\n+            // older versions of rustc used to not clear the\n+            // drop flag for `e` in this path.\n+        }\n+    }\n+}\n+\n+fn cond() -> bool { false }\n+\n+struct K;\n+\n+enum E {\n+    F(K),\n+    G(Box<E>)\n+}\n+\n+// END RUST SOURCE\n+// fn main() -> () {\n+//     let mut _0: ();\n+//     scope 1 {\n+//         let _1: E; // `e`\n+//         scope 2 {\n+//             let _6: K;\n+//         }\n+//     }\n+//     let mut _2: bool;\n+//     let mut _3: ();\n+//     let mut _4: E;\n+//     let mut _5: K;\n+//     let mut _7: isize;\n+//     let mut _8: bool; // drop flag for `e`\n+//     let mut _9: bool;\n+//     let mut _10: bool;\n+//     let mut _11: isize;\n+//     let mut _12: isize;\n+//\n+//     bb0: {\n+//         _8 = const false;\n+//         _10 = const false;\n+//         _9 = const false;\n+//         StorageLive(_1);\n+//         StorageLive(_2);\n+//         _2 = const cond() -> [return: bb3, unwind: bb2];\n+//     }\n+//\n+//     bb1: {\n+//         resume;\n+//     }\n+//\n+//     bb2: {\n+//         goto -> bb1;\n+//     }\n+//\n+//     bb3: {\n+//         switchInt(_2) -> [0u8: bb5, otherwise: bb4];\n+//     }\n+//\n+//     bb4: {\n+//         StorageLive(_4);\n+//         StorageLive(_5);\n+//         _5 = K::{{constructor}};\n+//         _4 = E::F(_5,);\n+//         StorageDead(_5);\n+//         goto -> bb15;\n+//     }\n+//\n+//     bb5: {\n+//         _0 = ();\n+//         goto -> bb12;\n+//     }\n+//\n+//     bb6: {\n+//         goto -> bb2;\n+//     }\n+//\n+//     bb7: {\n+//         goto -> bb8;\n+//     }\n+//\n+//     bb8: {\n+//         StorageDead(_4);\n+//         _7 = discriminant(_1);\n+//         switchInt(_7) -> [0isize: bb10, otherwise: bb9];\n+//     }\n+//\n+//     bb9: {\n+//         _0 = ();\n+//         goto -> bb11;\n+//     }\n+//\n+//     bb10: {\n+//         StorageLive(_6);\n+//         _10 = const false;\n+//         _6 = ((_1 as F).0: K);\n+//         _0 = ();\n+//         goto -> bb11;\n+//     }\n+//\n+//     bb11: {\n+//         StorageDead(_6);\n+//         goto -> bb12;\n+//     }\n+//\n+//     bb12: {\n+//         StorageDead(_2);\n+//         goto -> bb22;\n+//     }\n+//\n+//     bb13: {\n+//         StorageDead(_1);\n+//         return;\n+//     }\n+//\n+//     bb14: {\n+//         _8 = const true;\n+//         _9 = const true;\n+//         _10 = const true;\n+//         _1 = _4;\n+//         goto -> bb6;\n+//     }\n+//\n+//     bb15: {\n+//         _8 = const true;\n+//         _9 = const true;\n+//         _10 = const true;\n+//         _1 = _4;\n+//         goto -> bb7;\n+//     }\n+//\n+//     bb16: {\n+//         _8 = const false; // clear the drop flag - must always be reached\n+//         goto -> bb13;\n+//     }\n+//\n+//     bb17: {\n+//         _8 = const false;\n+//         goto -> bb1;\n+//     }\n+//\n+//     bb18: {\n+//         goto -> bb17;\n+//     }\n+//\n+//     bb19: {\n+//         drop(_1) -> [return: bb16, unwind: bb17];\n+//     }\n+//\n+//     bb20: {\n+//         drop(_1) -> bb17;\n+//     }\n+//\n+//     bb21: {\n+//         _11 = discriminant(_1);\n+//         switchInt(_11) -> [0isize: bb16, otherwise: bb19];\n+//     }\n+//\n+//     bb22: {\n+//         switchInt(_8) -> [0u8: bb16, otherwise: bb21];\n+//     }\n+//\n+//     bb23: {\n+//         _12 = discriminant(_1);\n+//         switchInt(_12) -> [0isize: bb18, otherwise: bb20];\n+//     }\n+//\n+//     bb24: {\n+//         switchInt(_8) -> [0u8: bb17, otherwise: bb23];\n+//     }\n+// }"}, {"sha": "6725a0c547f1dfaeb2e680c29774a68ee830c31b", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/68b7475dc04d4429d4bfb4837a902090915b6584/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b7475dc04d4429d4bfb4837a902090915b6584/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=68b7475dc04d4429d4bfb4837a902090915b6584", "patch": "@@ -90,6 +90,22 @@ fn dynamic_drop(a: &Allocator, c: bool) {\n     };\n }\n \n+struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n+fn struct_dynamic_drop(a: &Allocator, c0: bool, c1: bool, c: bool) {\n+    for i in 0..2 {\n+        let x;\n+        let y;\n+        if (c0 && i == 0) || (c1 && i == 1) {\n+            x = (a.alloc(), a.alloc(), a.alloc());\n+            y = TwoPtrs(a.alloc(), a.alloc());\n+            if c {\n+                drop(x.1);\n+                drop(y.0);\n+            }\n+        }\n+    }\n+}\n+\n fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n     let mut _v = a.alloc();\n     let mut _w = a.alloc();\n@@ -182,5 +198,14 @@ fn main() {\n     run_test(|a| array_simple(a));\n     run_test(|a| vec_simple(a));\n \n+    run_test(|a| struct_dynamic_drop(a, false, false, false));\n+    run_test(|a| struct_dynamic_drop(a, false, false, true));\n+    run_test(|a| struct_dynamic_drop(a, false, true, false));\n+    run_test(|a| struct_dynamic_drop(a, false, true, true));\n+    run_test(|a| struct_dynamic_drop(a, true, false, false));\n+    run_test(|a| struct_dynamic_drop(a, true, false, true));\n+    run_test(|a| struct_dynamic_drop(a, true, true, false));\n+    run_test(|a| struct_dynamic_drop(a, true, true, true));\n+\n     run_test_nopanic(|a| union1(a));\n }"}]}