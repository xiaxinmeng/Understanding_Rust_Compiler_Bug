{"sha": "e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZTQ2MTAwZDZjMmFlNjE3ZTEzMjFiYjAxY2U1YTJmM2NiMzdjNmE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-03T13:38:00Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-03T13:38:00Z"}, "message": "Refactor out tests module and remove empty subtree", "tree": {"sha": "37c14a32bb38f2ed716c55860bf3f60240207abc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37c14a32bb38f2ed716c55860bf3f60240207abc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a", "html_url": "https://github.com/rust-lang/rust/commit/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b29f442c8b8601feec4dbc49f121801b153d83e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b29f442c8b8601feec4dbc49f121801b153d83e1", "html_url": "https://github.com/rust-lang/rust/commit/b29f442c8b8601feec4dbc49f121801b153d83e1"}], "stats": {"total": 2509, "additions": 1372, "deletions": 1137}, "files": [{"sha": "9afc33093d75231fa2cf89bc3019e8bdfc901f93", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1137, "changes": 1138, "blob_url": "https://github.com/rust-lang/rust/blob/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a", "patch": "@@ -15,7 +15,6 @@ macro_rules! impl_froms {\n     }\n }\n \n-// mod tt_cursor;\n mod mbe_parser;\n mod mbe_expander;\n mod syntax_bridge;\n@@ -155,1139 +154,4 @@ pub(crate) struct Var {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use ra_syntax::{ast, AstNode};\n-\n-    use super::*;\n-\n-    // Good first issue (although a slightly challenging one):\n-    //\n-    // * Pick a random test from here\n-    //   https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n-    // * Port the test to rust and add it to this module\n-    // * Make it pass :-)\n-\n-    #[test]\n-    fn test_convert_tt() {\n-        let macro_definition = r#\"\n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-        )*\n-    }\n-}\n-\"#;\n-\n-        let macro_invocation = r#\"\n-impl_froms!(TokenTree: Leaf, Subtree);\n-\"#;\n-\n-        let source_file = ast::SourceFile::parse(macro_definition);\n-        let macro_definition =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let source_file = ast::SourceFile::parse(macro_invocation);\n-        let macro_invocation =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n-        let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n-        let rules = crate::MacroRules::parse(&definition_tt).unwrap();\n-        let expansion = rules.expand(&invocation_tt).unwrap();\n-        assert_eq!(\n-        expansion.to_string(),\n-        \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n-         impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n-    )\n-    }\n-\n-    pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n-        let source_file = ast::SourceFile::parse(macro_definition);\n-        let macro_definition =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n-        crate::MacroRules::parse(&definition_tt).unwrap()\n-    }\n-\n-    pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n-        let source_file = ast::SourceFile::parse(invocation);\n-        let macro_invocation =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n-\n-        rules.expand(&invocation_tt).unwrap()\n-    }\n-\n-    pub(crate) fn expand_to_items(\n-        rules: &MacroRules,\n-        invocation: &str,\n-    ) -> ra_syntax::TreeArc<ast::MacroItems> {\n-        let expanded = expand(rules, invocation);\n-        token_tree_to_macro_items(&expanded).unwrap()\n-    }\n-\n-    #[allow(unused)]\n-    pub(crate) fn expand_to_stmts(\n-        rules: &MacroRules,\n-        invocation: &str,\n-    ) -> ra_syntax::TreeArc<ast::MacroStmts> {\n-        let expanded = expand(rules, invocation);\n-        token_tree_to_macro_stmts(&expanded).unwrap()\n-    }\n-\n-    pub(crate) fn expand_to_expr(\n-        rules: &MacroRules,\n-        invocation: &str,\n-    ) -> ra_syntax::TreeArc<ast::Expr> {\n-        let expanded = expand(rules, invocation);\n-        token_tree_to_expr(&expanded).unwrap()\n-    }\n-\n-    pub(crate) fn assert_expansion(\n-        rules: &MacroRules,\n-        invocation: &str,\n-        expansion: &str,\n-    ) -> tt::Subtree {\n-        let expanded = expand(rules, invocation);\n-        assert_eq!(expanded.to_string(), expansion);\n-\n-        // FIXME: Temp comment below code\n-        // It is because after the lexer change,\n-        // The SyntaxNode structure cannot be matched easily\n-\n-        // let tree = token_tree_to_macro_items(&expanded);\n-\n-        // // Eat all white space by parse it back and forth\n-        // // Because $crate will seperate in two token , will do some special treatment here\n-        // let expansion = expansion.replace(\"$crate\", \"C_C__C\");\n-        // let expansion = ast::SourceFile::parse(&expansion);\n-        // let expansion = syntax_node_to_token_tree(expansion.syntax()).unwrap().0;\n-        // let file = token_tree_to_macro_items(&expansion);\n-        // let file = file.unwrap().syntax().debug_dump().trim().to_string();\n-        // let tree = tree.unwrap().syntax().debug_dump().trim().to_string();\n-\n-        // let file = file.replace(\"C_C__C\", \"$crate\");\n-        // assert_eq!(tree, file,);\n-\n-        expanded\n-    }\n-\n-    #[test]\n-    fn test_fail_match_pattern_by_first_token() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:ident) => (\n-                mod $ i {}\n-            );\n-            (= $ i:ident) => (\n-                fn $ i() {}\n-            );\n-            (+ $ i:ident) => (\n-                struct $ i;\n-            )\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! { foo }\", \"mod foo {}\");\n-        assert_expansion(&rules, \"foo! { = bar }\", \"fn bar () {}\");\n-        assert_expansion(&rules, \"foo! { + Baz }\", \"struct Baz ;\");\n-    }\n-\n-    #[test]\n-    fn test_fail_match_pattern_by_last_token() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:ident) => (\n-                mod $ i {}\n-            );\n-            ($ i:ident =) => (\n-                fn $ i() {}\n-            );\n-            ($ i:ident +) => (\n-                struct $ i;\n-            )\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! { foo }\", \"mod foo {}\");\n-        assert_expansion(&rules, \"foo! { bar = }\", \"fn bar () {}\");\n-        assert_expansion(&rules, \"foo! { Baz + }\", \"struct Baz ;\");\n-    }\n-\n-    #[test]\n-    fn test_fail_match_pattern_by_word_token() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:ident) => (\n-                mod $ i {}\n-            );\n-            (spam $ i:ident) => (\n-                fn $ i() {}\n-            );\n-            (eggs $ i:ident) => (\n-                struct $ i;\n-            )\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! { foo }\", \"mod foo {}\");\n-        assert_expansion(&rules, \"foo! { spam bar }\", \"fn bar () {}\");\n-        assert_expansion(&rules, \"foo! { eggs Baz }\", \"struct Baz ;\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_pattern_by_separator_token() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ($ (\n-                mod $ i {}\n-            )*);\n-            ($ ($ i:ident)#*) => ($ (\n-                fn $ i() {}\n-            )*);\n-            ($ i:ident ,# $ j:ident) => (\n-                struct $ i;\n-                struct $ j;\n-            )\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"mod foo {} mod bar {}\");\n-        assert_expansion(&rules, \"foo! { foo# bar }\", \"fn foo () {} fn bar () {}\");\n-        assert_expansion(&rules, \"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_pattern_with_multiple_defs() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ( struct Bar { $ (\n-                fn $ i {}\n-            )*} );            \n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"struct Bar {fn foo {} fn bar {}}\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_pattern_with_multiple_statement() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ( fn baz { $ (\n-                $ i ();\n-            )*} );            \n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_pattern_with_multiple_statement_without_semi() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident),*) => ( fn baz { $ (\n-                $i()\n-            );*} );            \n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_empty_fixed_token() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ ($ i:ident)* #abc) => ( fn baz { $ (\n-                $ i ();\n-            )*} );            \n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! {#abc}\", \"fn baz {}\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_in_subtree() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {            \n-            (fn $name:ident {$($i:ident)*} ) => ( fn $name() { $ (\n-                $ i ();\n-            )*} );            \n-        }\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_with_multichar_sep() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {            \n-            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );            \n-        }\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! (fn baz {true true} )\", \"fn baz () -> bool {true &&true}\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_zero_match() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {            \n-            ( $($i:ident)* ) => ();            \n-        }\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! ()\", \"\");\n-    }\n-\n-    #[test]\n-    fn test_match_group_in_group() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {            \n-            { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n-        }\"#,\n-        );\n-\n-        assert_expansion(&rules, \"foo! ( (a b) )\", \"(a b)\");\n-    }\n-\n-    #[test]\n-    fn test_expand_to_item_list() {\n-        let rules = create_rules(\n-            \"\n-            macro_rules! structs {\n-                ($($i:ident),*) => {\n-                    $(struct $i { field: u32 } )*\n-                }\n-            }\n-            \",\n-        );\n-        let expansion = expand(&rules, \"structs!(Foo, Bar)\");\n-        let tree = token_tree_to_macro_items(&expansion);\n-        assert_eq!(\n-            tree.unwrap().syntax().debug_dump().trim(),\n-            r#\"\n-MACRO_ITEMS@[0; 40)\n-  STRUCT_DEF@[0; 20)\n-    STRUCT_KW@[0; 6) \"struct\"\n-    NAME@[6; 9)\n-      IDENT@[6; 9) \"Foo\"\n-    NAMED_FIELD_DEF_LIST@[9; 20)\n-      L_CURLY@[9; 10) \"{\"\n-      NAMED_FIELD_DEF@[10; 19)\n-        NAME@[10; 15)\n-          IDENT@[10; 15) \"field\"\n-        COLON@[15; 16) \":\"\n-        PATH_TYPE@[16; 19)\n-          PATH@[16; 19)\n-            PATH_SEGMENT@[16; 19)\n-              NAME_REF@[16; 19)\n-                IDENT@[16; 19) \"u32\"\n-      R_CURLY@[19; 20) \"}\"\n-  STRUCT_DEF@[20; 40)\n-    STRUCT_KW@[20; 26) \"struct\"\n-    NAME@[26; 29)\n-      IDENT@[26; 29) \"Bar\"\n-    NAMED_FIELD_DEF_LIST@[29; 40)\n-      L_CURLY@[29; 30) \"{\"\n-      NAMED_FIELD_DEF@[30; 39)\n-        NAME@[30; 35)\n-          IDENT@[30; 35) \"field\"\n-        COLON@[35; 36) \":\"\n-        PATH_TYPE@[36; 39)\n-          PATH@[36; 39)\n-            PATH_SEGMENT@[36; 39)\n-              NAME_REF@[36; 39)\n-                IDENT@[36; 39) \"u32\"\n-      R_CURLY@[39; 40) \"}\"\"#\n-                .trim()\n-        );\n-    }\n-\n-    #[test]\n-    fn test_expand_literals_to_token_tree() {\n-        fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n-            if let tt::TokenTree::Subtree(subtree) = tt {\n-                return &subtree;\n-            }\n-            unreachable!(\"It is not a subtree\");\n-        }\n-\n-        fn to_literal(tt: &tt::TokenTree) -> &tt::Literal {\n-            if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = tt {\n-                return lit;\n-            }\n-            unreachable!(\"It is not a literal\");\n-        }\n-\n-        let rules = create_rules(\n-            r#\"\n-            macro_rules! literals {\n-                ($i:ident) => {\n-                    {\n-                        let a = 'c';\n-                        let c = 1000;\n-                        let f = 12E+99_f64;\n-                        let s = \"rust1\";\n-                    }\n-                }\n-            }\n-            \"#,\n-        );\n-        let expansion = expand(&rules, \"literals!(foo)\");\n-        let stm_tokens = &to_subtree(&expansion.token_trees[0]).token_trees;\n-\n-        // [let] [a] [=] ['c'] [;]\n-        assert_eq!(to_literal(&stm_tokens[3]).text, \"'c'\");\n-        // [let] [c] [=] [1000] [;]\n-        assert_eq!(to_literal(&stm_tokens[5 + 3]).text, \"1000\");\n-        // [let] [f] [=] [12E+99_f64] [;]\n-        assert_eq!(to_literal(&stm_tokens[10 + 3]).text, \"12E+99_f64\");\n-        // [let] [s] [=] [\"rust1\"] [;]\n-        assert_eq!(to_literal(&stm_tokens[15 + 3]).text, \"\\\"rust1\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_two_idents() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:ident, $ j:ident) => {\n-                fn foo() { let a = $ i; let b = $j; }\n-            }\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n-    }\n-\n-    #[test]\n-    fn test_tt_to_stmts() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            () => {\n-                 let a = 0;\n-                 a = 10 + 1;\n-                 a\n-            }\n-        }\n-\"#,\n-        );\n-\n-        let expanded = expand(&rules, \"foo!{}\");\n-        let stmts = token_tree_to_macro_stmts(&expanded);\n-\n-        assert_eq!(\n-            stmts.unwrap().syntax().debug_dump().trim(),\n-            r#\"MACRO_STMTS@[0; 15)\n-  LET_STMT@[0; 7)\n-    LET_KW@[0; 3) \"let\"\n-    BIND_PAT@[3; 4)\n-      NAME@[3; 4)\n-        IDENT@[3; 4) \"a\"\n-    EQ@[4; 5) \"=\"\n-    LITERAL@[5; 6)\n-      INT_NUMBER@[5; 6) \"0\"\n-    SEMI@[6; 7) \";\"\n-  EXPR_STMT@[7; 14)\n-    BIN_EXPR@[7; 13)\n-      PATH_EXPR@[7; 8)\n-        PATH@[7; 8)\n-          PATH_SEGMENT@[7; 8)\n-            NAME_REF@[7; 8)\n-              IDENT@[7; 8) \"a\"\n-      EQ@[8; 9) \"=\"\n-      BIN_EXPR@[9; 13)\n-        LITERAL@[9; 11)\n-          INT_NUMBER@[9; 11) \"10\"\n-        PLUS@[11; 12) \"+\"\n-        LITERAL@[12; 13)\n-          INT_NUMBER@[12; 13) \"1\"\n-    SEMI@[13; 14) \";\"\n-  EXPR_STMT@[14; 15)\n-    PATH_EXPR@[14; 15)\n-      PATH@[14; 15)\n-        PATH_SEGMENT@[14; 15)\n-          NAME_REF@[14; 15)\n-            IDENT@[14; 15) \"a\"\"#,\n-        );\n-    }\n-\n-    // The following tests are port from intellij-rust directly\n-    // https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n-\n-    #[test]\n-    fn test_path() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:path) => {\n-                fn foo() { let a = $ i; }\n-            }\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! { foo }\", \"fn foo () {let a = foo ;}\");\n-        assert_expansion(\n-            &rules,\n-            \"foo! { bar::<u8>::baz::<u8> }\",\n-            \"fn foo () {let a = bar ::< u8 >:: baz ::< u8 > ;}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_two_paths() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:path, $ j:path) => {\n-                fn foo() { let a = $ i; let b = $j; }\n-            }\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n-    }\n-\n-    #[test]\n-    fn test_path_with_path() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:path) => {\n-                fn foo() { let a = $ i :: bar; }\n-            }\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! { foo }\", \"fn foo () {let a = foo :: bar ;}\");\n-    }\n-\n-    #[test]\n-    fn test_expr() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:expr) => {\n-                 fn bar() { $ i; } \n-            }\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(\n-            &rules,\n-            \"foo! { 2 + 2 * baz(3).quux() }\",\n-            \"fn bar () {2 + 2 * baz (3) . quux () ;}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_expr_order() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:expr) => {\n-                 fn bar() { $ i * 2; } \n-            }\n-        }\n-\"#,\n-        );\n-\n-        assert_eq!(\n-            expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax().debug_dump().trim(),\n-            r#\"MACRO_ITEMS@[0; 15)\n-  FN_DEF@[0; 15)\n-    FN_KW@[0; 2) \"fn\"\n-    NAME@[2; 5)\n-      IDENT@[2; 5) \"bar\"\n-    PARAM_LIST@[5; 7)\n-      L_PAREN@[5; 6) \"(\"\n-      R_PAREN@[6; 7) \")\"\n-    BLOCK@[7; 15)\n-      L_CURLY@[7; 8) \"{\"\n-      EXPR_STMT@[8; 14)\n-        BIN_EXPR@[8; 13)\n-          BIN_EXPR@[8; 11)\n-            LITERAL@[8; 9)\n-              INT_NUMBER@[8; 9) \"1\"\n-            PLUS@[9; 10) \"+\"\n-            LITERAL@[10; 11)\n-              INT_NUMBER@[10; 11) \"1\"\n-          STAR@[11; 12) \"*\"\n-          LITERAL@[12; 13)\n-            INT_NUMBER@[12; 13) \"2\"\n-        SEMI@[13; 14) \";\"\n-      R_CURLY@[14; 15) \"}\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_last_expr() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! vec {\n-            ($($item:expr),*) => {\n-                {\n-                    let mut v = Vec::new();\n-                    $(\n-                        v.push($item);\n-                    )*\n-                    v\n-                }\n-            };\n-        }\n-\"#,\n-        );\n-        assert_expansion(\n-            &rules,\n-            \"vec!(1,2,3)\",\n-            \"{let mut v = Vec :: new () ; v . push (1) ; v . push (2) ; v . push (3) ; v}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ty() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:ty) => (\n-                fn bar() -> $ i { unimplemented!() }\n-            )\n-        }\n-\"#,\n-        );\n-        assert_expansion(\n-            &rules,\n-            \"foo! { Baz<u8> }\",\n-            \"fn bar () -> Baz < u8 > {unimplemented ! ()}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ty_with_complex_type() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:ty) => (\n-                fn bar() -> $ i { unimplemented!() }\n-            )\n-        }\n-\"#,\n-        );\n-\n-        // Reference lifetime struct with generic type\n-        assert_expansion(\n-            &rules,\n-            \"foo! { &'a Baz<u8> }\",\n-            \"fn bar () -> & 'a Baz < u8 > {unimplemented ! ()}\",\n-        );\n-\n-        // extern \"Rust\" func type\n-        assert_expansion(\n-            &rules,\n-            r#\"foo! { extern \"Rust\" fn() -> Ret }\"#,\n-            r#\"fn bar () -> extern \"Rust\" fn () -> Ret {unimplemented ! ()}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_pat_() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:pat) => { fn foo() { let $ i; } }\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n-    }\n-\n-    #[test]\n-    fn test_stmt() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:stmt) => (\n-                fn bar() { $ i; }\n-            )\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! { 2 }\", \"fn bar () {2 ;}\");\n-        assert_expansion(&rules, \"foo! { let a = 0 }\", \"fn bar () {let a = 0 ;}\");\n-    }\n-\n-    #[test]\n-    fn test_single_item() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:item) => (\n-                $ i\n-            )\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! {mod c {}}\", \"mod c {}\");\n-    }\n-\n-    #[test]\n-    fn test_all_items() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ ($ i:item)*) => ($ (\n-                $ i\n-            )*)\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, r#\"\n-        foo! {\n-            extern crate a;\n-            mod b;\n-            mod c {}\n-            use d;\n-            const E: i32 = 0;\n-            static F: i32 = 0;\n-            impl G {}\n-            struct H;\n-            enum I { Foo }\n-            trait J {}\n-            fn h() {}\n-            extern {}\n-            type T = u8;\n-        }\n-\"#, r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#);\n-    }\n-\n-    #[test]\n-    fn test_block() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:block) => { fn foo() $ i }\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, \"foo! { { 1; } }\", \"fn foo () {1 ;}\");\n-    }\n-\n-    #[test]\n-    fn test_meta() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-            ($ i:meta) => (\n-                #[$ i]\n-                fn bar() {}\n-            )\n-        }\n-\"#,\n-        );\n-        assert_expansion(\n-            &rules,\n-            r#\"foo! { cfg(target_os = \"windows\") }\"#,\n-            r#\"# [cfg (target_os = \"windows\")] fn bar () {}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    // fn test_tt_block() {\n-    //     let rules = create_rules(\n-    //         r#\"\n-    //         macro_rules! foo {\n-    //             ($ i:tt) => { fn foo() $ i }\n-    //         }\n-    // \"#,\n-    //     );\n-    //     assert_expansion(&rules, r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n-    // }\n-\n-    // #[test]\n-    // fn test_tt_group() {\n-    //     let rules = create_rules(\n-    //         r#\"\n-    //         macro_rules! foo {\n-    //              ($($ i:tt)*) => { $($ i)* }\n-    //         }\n-    // \"#,\n-    //     );\n-    //     assert_expansion(&rules, r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n-    // }\n-    #[test]\n-    fn test_lifetime() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-              ($ lt:lifetime) => { struct Ref<$ lt>{ s: &$ lt str } }\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n-    }\n-\n-    #[test]\n-    fn test_literal() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-              ($ type:ty $ lit:literal) => { const VALUE: $ type = $ lit;};\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, r#\"foo!(u8 0)\"#, r#\"const VALUE : u8 = 0 ;\"#);\n-    }\n-\n-    #[test]\n-    fn test_vis() {\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! foo {\n-              ($ vis:vis $ name:ident) => { $ vis fn $ name() {}};\n-        }\n-\"#,\n-        );\n-        assert_expansion(&rules, r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#);\n-    }\n-\n-    // The following tests are based on real world situations\n-    #[test]\n-    fn test_vec() {\n-        let rules = create_rules(\n-            r#\"\n-         macro_rules! vec {\n-            ($($item:expr),*) => {\n-                {\n-                    let mut v = Vec::new();\n-                    $(\n-                        v.push($item);\n-                    )*\n-                    v\n-                }\n-            };\n-}\n-\"#,\n-        );\n-        assert_expansion(&rules, r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ;  v}\"#);\n-        assert_expansion(\n-            &rules,\n-            r#\"vec![1u32,2]\"#,\n-            r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n-        );\n-\n-        assert_eq!(\n-            expand_to_expr(&rules, r#\"vec![1u32,2]\"#).syntax().debug_dump().trim(),\n-            r#\"BLOCK_EXPR@[0; 45)\n-  BLOCK@[0; 45)\n-    L_CURLY@[0; 1) \"{\"\n-    LET_STMT@[1; 20)\n-      LET_KW@[1; 4) \"let\"\n-      BIND_PAT@[4; 8)\n-        MUT_KW@[4; 7) \"mut\"\n-        NAME@[7; 8)\n-          IDENT@[7; 8) \"v\"\n-      EQ@[8; 9) \"=\"\n-      CALL_EXPR@[9; 19)\n-        PATH_EXPR@[9; 17)\n-          PATH@[9; 17)\n-            PATH@[9; 12)\n-              PATH_SEGMENT@[9; 12)\n-                NAME_REF@[9; 12)\n-                  IDENT@[9; 12) \"Vec\"\n-            COLONCOLON@[12; 14) \"::\"\n-            PATH_SEGMENT@[14; 17)\n-              NAME_REF@[14; 17)\n-                IDENT@[14; 17) \"new\"\n-        ARG_LIST@[17; 19)\n-          L_PAREN@[17; 18) \"(\"\n-          R_PAREN@[18; 19) \")\"\n-      SEMI@[19; 20) \";\"\n-    EXPR_STMT@[20; 33)\n-      METHOD_CALL_EXPR@[20; 32)\n-        PATH_EXPR@[20; 21)\n-          PATH@[20; 21)\n-            PATH_SEGMENT@[20; 21)\n-              NAME_REF@[20; 21)\n-                IDENT@[20; 21) \"v\"\n-        DOT@[21; 22) \".\"\n-        NAME_REF@[22; 26)\n-          IDENT@[22; 26) \"push\"\n-        ARG_LIST@[26; 32)\n-          L_PAREN@[26; 27) \"(\"\n-          LITERAL@[27; 31)\n-            INT_NUMBER@[27; 31) \"1u32\"\n-          R_PAREN@[31; 32) \")\"\n-      SEMI@[32; 33) \";\"\n-    EXPR_STMT@[33; 43)\n-      METHOD_CALL_EXPR@[33; 42)\n-        PATH_EXPR@[33; 34)\n-          PATH@[33; 34)\n-            PATH_SEGMENT@[33; 34)\n-              NAME_REF@[33; 34)\n-                IDENT@[33; 34) \"v\"\n-        DOT@[34; 35) \".\"\n-        NAME_REF@[35; 39)\n-          IDENT@[35; 39) \"push\"\n-        ARG_LIST@[39; 42)\n-          L_PAREN@[39; 40) \"(\"\n-          LITERAL@[40; 41)\n-            INT_NUMBER@[40; 41) \"2\"\n-          R_PAREN@[41; 42) \")\"\n-      SEMI@[42; 43) \";\"\n-    PATH_EXPR@[43; 44)\n-      PATH@[43; 44)\n-        PATH_SEGMENT@[43; 44)\n-          NAME_REF@[43; 44)\n-            IDENT@[43; 44) \"v\"\n-    R_CURLY@[44; 45) \"}\"\"#\n-        );\n-    }\n-\n-    #[test]\n-    fn test_winapi_struct() {\n-        // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n-\n-        let rules = create_rules(\n-            r#\"\n-macro_rules! STRUCT {\n-    ($(#[$attrs:meta])* struct $name:ident {\n-        $($field:ident: $ftype:ty,)+\n-    }) => (\n-        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n-        pub struct $name {\n-            $(pub $field: $ftype,)+\n-        }\n-        impl Clone for $name {\n-            #[inline]\n-            fn clone(&self) -> $name { *self }\n-        }\n-        #[cfg(feature = \"impl-default\")]\n-        impl Default for $name {\n-            #[inline]\n-            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n-        }\n-    );\n-}\n-\"#,\n-        );\n-        // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n-        assert_expansion(&rules, r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n-        \"# [repr (C)] # [derive (Copy)]  pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n-        assert_expansion(&rules, r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#, \n-        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n-    }\n-\n-    #[test]\n-    fn test_int_base() {\n-        let rules = create_rules(\n-            r#\"\n-macro_rules! int_base {\n-    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl fmt::$Trait for $T {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                $Radix.fmt_int(*self as $U, f)\n-            }\n-        }\n-    }\n-}            \n-\"#,\n-        );\n-\n-        assert_expansion(&rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#, \n-        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_pattern_iterators() {\n-        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n-        let rules = create_rules(\n-            r#\"\n-macro_rules! generate_pattern_iterators {        \n-        { double ended; with $(#[$common_stability_attribute:meta])*,\n-                           $forward_iterator:ident,\n-                           $reverse_iterator:ident, $iterty:ty\n-        } => {\n-            fn foo(){}\n-        }\n-}\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str )\"#, \n-        \"fn foo () {}\");\n-    }\n-\n-    #[test]\n-    fn test_impl_fn_for_zst() {\n-        // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n-        let rules = create_rules(\n-            r#\"\n-macro_rules! impl_fn_for_zst  {        \n-        {  $( $( #[$attr: meta] )*\n-        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n-            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n-$body: block; )+\n-        } => {\n-           $(\n-            $( #[$attr] )*\n-            struct $Name;\n-\n-            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n-                #[inline]\n-                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n-                    $body\n-                }\n-            }\n-\n-            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n-                #[inline]\n-                extern \"rust-call\" fn call_mut(\n-                    &mut self,\n-                    ($( $arg, )*): ($( $ArgTy, )*)\n-                ) -> $ReturnTy {\n-                    Fn::call(&*self, ($( $arg, )*))\n-                }\n-            }\n-\n-            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n-                type Output = $ReturnTy;\n-\n-                #[inline]\n-                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n-                    Fn::call(&self, ($( $arg, )*))\n-                }\n-            }\n-        )+\n-}\n-        }\n-}\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, r#\"\n-impl_fn_for_zst !   { \n-     # [ derive ( Clone ) ] \n-     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   { \n-         c . escape_debug_ext ( false ) \n-     } ; \n-\n-     # [ derive ( Clone ) ] \n-     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   { \n-         c . escape_unicode ( ) \n-     } ; \n-     # [ derive ( Clone ) ] \n-     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   { \n-         c . escape_default ( ) \n-     } ; \n- }\n-\"#, \n-        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl  Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl  FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl  Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl  FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl  Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl  FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\");\n-    }\n-\n-    #[test]\n-    fn test_impl_nonzero_fmt() {\n-        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! impl_nonzero_fmt {\n-            ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n-                fn foo() {}\n-            }\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, r#\"impl_nonzero_fmt ! { # [ stable ( feature = \"nonzero\" , since = \"1.28.0\" ) ] ( Debug , Display , Binary , Octal , LowerHex , UpperHex ) for NonZeroU8 }\"#, \n-        \"fn foo () {}\");\n-    }\n-\n-    #[test]\n-    fn test_cfg_if_items() {\n-        // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! __cfg_if_items {\n-            (($($not:meta,)*) ; ) => {};\n-            (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-                 __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-            }\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,         \n-        \"__cfg_if_items ! {(rustdoc , ) ; }\");\n-    }\n-\n-    #[test]\n-    fn test_cfg_if_main() {\n-        // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n-        let rules = create_rules(\n-            r#\"\n-        macro_rules! cfg_if {\n-            ($(\n-                if #[cfg($($meta:meta),*)] { $($it:item)* }\n-            ) else * else {\n-                $($it2:item)*\n-            }) => {\n-                __cfg_if_items! {\n-                    () ;\n-                    $( ( ($($meta),*) ($($it)*) ), )*\n-                    ( () ($($it2)*) ),\n-                }\n-            }\n-        }\n-\"#,\n-        );\n-\n-        assert_expansion(&rules, r#\"\n-cfg_if !   { \n-     if   # [ cfg ( target_env   =   \"msvc\" ) ]   { \n-         // no extra unwinder support needed \n-     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   { \n-         // no unwinder on the system! \n-     }   else   { \n-         mod   libunwind ; \n-         pub   use   libunwind :: * ; \n-     } \n- }        \n-\"#,         \n-        \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n-    }\n-}\n+mod tests;\n\\ No newline at end of file"}, {"sha": "1453a106d8be1a5e5c79ded7e68a4bc84af0ef3e", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a", "patch": "@@ -329,6 +329,14 @@ fn expand_subtree(\n         .token_trees\n         .iter()\n         .map(|it| expand_tt(it, ctx))\n+        .filter(|it| {\n+            // Filter empty subtree\n+            if let Ok(tt::TokenTree::Subtree(subtree)) = it {\n+                subtree.delimiter != tt::Delimiter::None || !subtree.token_trees.is_empty()\n+            } else {\n+                true\n+            }\n+        })\n         .collect::<Result<Vec<_>, ExpandError>>()?;\n \n     Ok(tt::Subtree { token_trees, delimiter: template.delimiter })"}, {"sha": "b81e6fcc92d1324e85af345b02bfc1058778c6e6", "filename": "crates/ra_mbe/src/tests.rs", "status": "added", "additions": 1363, "deletions": 0, "changes": 1363, "blob_url": "https://github.com/rust-lang/rust/blob/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=e8e46100d6c2ae617e1321bb01ce5a2f3cb37c6a", "patch": "@@ -0,0 +1,1363 @@\n+use ra_syntax::{ast, AstNode};\n+\n+use super::*;\n+\n+// Good first issue (although a slightly challenging one):\n+//\n+// * Pick a random test from here\n+//   https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n+// * Port the test to rust and add it to this module\n+// * Make it pass :-)\n+\n+#[test]\n+fn test_convert_tt() {\n+    let macro_definition = r#\"\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\"#;\n+\n+    let macro_invocation = r#\"\n+impl_froms!(TokenTree: Leaf, Subtree);\n+\"#;\n+\n+    let source_file = ast::SourceFile::parse(macro_definition);\n+    let macro_definition =\n+        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+    let source_file = ast::SourceFile::parse(macro_invocation);\n+    let macro_invocation =\n+        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+    let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+    let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n+    let rules = crate::MacroRules::parse(&definition_tt).unwrap();\n+    let expansion = rules.expand(&invocation_tt).unwrap();\n+    assert_eq!(\n+        expansion.to_string(),\n+        \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n+         impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n+    )\n+}\n+\n+pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n+    let source_file = ast::SourceFile::parse(macro_definition);\n+    let macro_definition =\n+        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+    let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+    crate::MacroRules::parse(&definition_tt).unwrap()\n+}\n+\n+pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n+    let source_file = ast::SourceFile::parse(invocation);\n+    let macro_invocation =\n+        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+    let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n+\n+    rules.expand(&invocation_tt).unwrap()\n+}\n+\n+pub(crate) fn expand_to_items(\n+    rules: &MacroRules,\n+    invocation: &str,\n+) -> ra_syntax::TreeArc<ast::MacroItems> {\n+    let expanded = expand(rules, invocation);\n+    token_tree_to_macro_items(&expanded).unwrap()\n+}\n+\n+#[allow(unused)]\n+pub(crate) fn expand_to_stmts(\n+    rules: &MacroRules,\n+    invocation: &str,\n+) -> ra_syntax::TreeArc<ast::MacroStmts> {\n+    let expanded = expand(rules, invocation);\n+    token_tree_to_macro_stmts(&expanded).unwrap()\n+}\n+\n+pub(crate) fn expand_to_expr(\n+    rules: &MacroRules,\n+    invocation: &str,\n+) -> ra_syntax::TreeArc<ast::Expr> {\n+    let expanded = expand(rules, invocation);\n+    token_tree_to_expr(&expanded).unwrap()\n+}\n+\n+pub(crate) fn text_to_tokentree(text: &str) -> tt::Subtree {\n+    // wrap the given text to a macro call\n+    let wrapped = format!(\"wrap_macro!( {} )\", text);\n+    let wrapped = ast::SourceFile::parse(&wrapped);\n+    let wrapped = wrapped.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+    let mut wrapped = ast_to_token_tree(wrapped).unwrap().0;\n+    wrapped.delimiter = tt::Delimiter::None;\n+\n+    wrapped\n+}\n+\n+pub(crate) enum MacroKind {\n+    Items,\n+    Stmts,\n+}\n+\n+use ra_syntax::WalkEvent;\n+\n+pub fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n+    use std::fmt::Write;\n+\n+    let mut level = 0;\n+    let mut buf = String::new();\n+    macro_rules! indent {\n+        () => {\n+            for _ in 0..level {\n+                buf.push_str(\"  \");\n+            }\n+        };\n+    }\n+\n+    for event in node.preorder_with_tokens() {\n+        match event {\n+            WalkEvent::Enter(element) => {\n+                match element {\n+                    ra_syntax::SyntaxElement::Node(node) => {\n+                        indent!();\n+                        writeln!(buf, \"{:?}\", node.kind()).unwrap();\n+                    }\n+                    ra_syntax::SyntaxElement::Token(token) => match token.kind() {\n+                        ra_syntax::SyntaxKind::WHITESPACE => {}\n+                        _ => {\n+                            indent!();\n+                            writeln!(buf, \"{:?}\", token.kind()).unwrap();\n+                        }\n+                    },\n+                }\n+                level += 1;\n+            }\n+            WalkEvent::Leave(_) => level -= 1,\n+        }\n+    }\n+\n+    buf\n+}\n+\n+pub(crate) fn assert_expansion(\n+    kind: MacroKind,\n+    rules: &MacroRules,\n+    invocation: &str,\n+    expected: &str,\n+) -> tt::Subtree {\n+    let expanded = expand(rules, invocation);\n+    assert_eq!(expanded.to_string(), expected);\n+\n+    let expected = expected.replace(\"$crate\", \"C_C__C\");\n+\n+    // wrap the given text to a macro call\n+    let expected = text_to_tokentree(&expected);\n+\n+    let (expanded_tree, expected_tree) = match kind {\n+        MacroKind::Items => {\n+            let expanded_tree = token_tree_to_macro_items(&expanded);\n+            let expected_tree = token_tree_to_macro_items(&expected);\n+\n+            (\n+                debug_dump_ignore_spaces(expanded_tree.unwrap().syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(expected_tree.unwrap().syntax()).trim().to_string(),\n+            )\n+        }\n+\n+        MacroKind::Stmts => {\n+            let expanded_tree = token_tree_to_macro_stmts(&expanded);\n+            let expected_tree = token_tree_to_macro_stmts(&expected);\n+\n+            (\n+                debug_dump_ignore_spaces(expanded_tree.unwrap().syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(expected_tree.unwrap().syntax()).trim().to_string(),\n+            )\n+        }\n+    };\n+\n+    let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n+    assert_eq!(\n+        expanded_tree, expected_tree,\n+        \"left => {}\\nright => {}\",\n+        expanded_tree, expected_tree,\n+    );\n+\n+    expanded\n+}\n+\n+#[test]\n+fn test_fail_match_pattern_by_first_token() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident) => (\n+                mod $ i {}\n+            );\n+            (= $ i:ident) => (\n+                fn $ i() {}\n+            );\n+            (+ $ i:ident) => (\n+                struct $ i;\n+            )\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"mod foo {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { = bar }\", \"fn bar () {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { + Baz }\", \"struct Baz ;\");\n+}\n+\n+#[test]\n+fn test_fail_match_pattern_by_last_token() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident) => (\n+                mod $ i {}\n+            );\n+            ($ i:ident =) => (\n+                fn $ i() {}\n+            );\n+            ($ i:ident +) => (\n+                struct $ i;\n+            )\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"mod foo {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { bar = }\", \"fn bar () {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { Baz + }\", \"struct Baz ;\");\n+}\n+\n+#[test]\n+fn test_fail_match_pattern_by_word_token() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident) => (\n+                mod $ i {}\n+            );\n+            (spam $ i:ident) => (\n+                fn $ i() {}\n+            );\n+            (eggs $ i:ident) => (\n+                struct $ i;\n+            )\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"mod foo {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { spam bar }\", \"fn bar () {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { eggs Baz }\", \"struct Baz ;\");\n+}\n+\n+#[test]\n+fn test_match_group_pattern_by_separator_token() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ($ (\n+                mod $ i {}\n+            )*);\n+            ($ ($ i:ident)#*) => ($ (\n+                fn $ i() {}\n+            )*);\n+            ($ i:ident ,# $ j:ident) => (\n+                struct $ i;\n+                struct $ j;\n+            )\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo, bar }\", \"mod foo {} mod bar {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo# bar }\", \"fn foo () {} fn bar () {}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n+}\n+\n+#[test]\n+fn test_match_group_pattern_with_multiple_defs() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ( struct Bar { $ (\n+                fn $ i {}\n+            )*} );            \n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! { foo, bar }\",\n+        \"struct Bar {fn foo {} fn bar {}}\",\n+    );\n+}\n+\n+#[test]\n+fn test_match_group_pattern_with_multiple_statement() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ( fn baz { $ (\n+                $ i ();\n+            )*} );            \n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n+}\n+\n+#[test]\n+fn test_match_group_pattern_with_multiple_statement_without_semi() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ( fn baz { $ (\n+                $i()\n+            );*} );            \n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n+}\n+\n+#[test]\n+fn test_match_group_empty_fixed_token() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident)* #abc) => ( fn baz { $ (\n+                $ i ();\n+            )*} );            \n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! {#abc}\", \"fn baz {}\");\n+}\n+\n+#[test]\n+fn test_match_group_in_subtree() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {            \n+            (fn $name:ident {$($i:ident)*} ) => ( fn $name() { $ (\n+                $ i ();\n+            )*} );            \n+        }\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n+}\n+\n+#[test]\n+fn test_match_group_with_multichar_sep() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {            \n+            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );            \n+        }\"#,\n+    );\n+\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! (fn baz {true true} )\",\n+        \"fn baz () -> bool {true &&true}\",\n+    );\n+}\n+\n+#[test]\n+fn test_match_group_zero_match() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {            \n+            ( $($i:ident)* ) => ();            \n+        }\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! ()\", \"\");\n+}\n+\n+#[test]\n+fn test_match_group_in_group() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {            \n+            { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n+        }\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, \"foo! ( (a b) )\", \"(a b)\");\n+}\n+\n+#[test]\n+fn test_expand_to_item_list() {\n+    let rules = create_rules(\n+        \"\n+            macro_rules! structs {\n+                ($($i:ident),*) => {\n+                    $(struct $i { field: u32 } )*\n+                }\n+            }\n+            \",\n+    );\n+    let expansion = expand(&rules, \"structs!(Foo, Bar)\");\n+    let tree = token_tree_to_macro_items(&expansion);\n+    assert_eq!(\n+        tree.unwrap().syntax().debug_dump().trim(),\n+        r#\"\n+MACRO_ITEMS@[0; 40)\n+  STRUCT_DEF@[0; 20)\n+    STRUCT_KW@[0; 6) \"struct\"\n+    NAME@[6; 9)\n+      IDENT@[6; 9) \"Foo\"\n+    NAMED_FIELD_DEF_LIST@[9; 20)\n+      L_CURLY@[9; 10) \"{\"\n+      NAMED_FIELD_DEF@[10; 19)\n+        NAME@[10; 15)\n+          IDENT@[10; 15) \"field\"\n+        COLON@[15; 16) \":\"\n+        PATH_TYPE@[16; 19)\n+          PATH@[16; 19)\n+            PATH_SEGMENT@[16; 19)\n+              NAME_REF@[16; 19)\n+                IDENT@[16; 19) \"u32\"\n+      R_CURLY@[19; 20) \"}\"\n+  STRUCT_DEF@[20; 40)\n+    STRUCT_KW@[20; 26) \"struct\"\n+    NAME@[26; 29)\n+      IDENT@[26; 29) \"Bar\"\n+    NAMED_FIELD_DEF_LIST@[29; 40)\n+      L_CURLY@[29; 30) \"{\"\n+      NAMED_FIELD_DEF@[30; 39)\n+        NAME@[30; 35)\n+          IDENT@[30; 35) \"field\"\n+        COLON@[35; 36) \":\"\n+        PATH_TYPE@[36; 39)\n+          PATH@[36; 39)\n+            PATH_SEGMENT@[36; 39)\n+              NAME_REF@[36; 39)\n+                IDENT@[36; 39) \"u32\"\n+      R_CURLY@[39; 40) \"}\"\"#\n+            .trim()\n+    );\n+}\n+\n+#[test]\n+fn test_expand_literals_to_token_tree() {\n+    fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n+        if let tt::TokenTree::Subtree(subtree) = tt {\n+            return &subtree;\n+        }\n+        unreachable!(\"It is not a subtree\");\n+    }\n+\n+    fn to_literal(tt: &tt::TokenTree) -> &tt::Literal {\n+        if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = tt {\n+            return lit;\n+        }\n+        unreachable!(\"It is not a literal\");\n+    }\n+\n+    let rules = create_rules(\n+        r#\"\n+            macro_rules! literals {\n+                ($i:ident) => {\n+                    {\n+                        let a = 'c';\n+                        let c = 1000;\n+                        let f = 12E+99_f64;\n+                        let s = \"rust1\";\n+                    }\n+                }\n+            }\n+            \"#,\n+    );\n+    let expansion = expand(&rules, \"literals!(foo)\");\n+    let stm_tokens = &to_subtree(&expansion.token_trees[0]).token_trees;\n+\n+    // [let] [a] [=] ['c'] [;]\n+    assert_eq!(to_literal(&stm_tokens[3]).text, \"'c'\");\n+    // [let] [c] [=] [1000] [;]\n+    assert_eq!(to_literal(&stm_tokens[5 + 3]).text, \"1000\");\n+    // [let] [f] [=] [12E+99_f64] [;]\n+    assert_eq!(to_literal(&stm_tokens[10 + 3]).text, \"12E+99_f64\");\n+    // [let] [s] [=] [\"rust1\"] [;]\n+    assert_eq!(to_literal(&stm_tokens[15 + 3]).text, \"\\\"rust1\\\"\");\n+}\n+\n+#[test]\n+fn test_two_idents() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ident, $ j:ident) => {\n+                fn foo() { let a = $ i; let b = $j; }\n+            }\n+        }\n+\"#,\n+    );\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! { foo, bar }\",\n+        \"fn foo () {let a = foo ; let b = bar ;}\",\n+    );\n+}\n+\n+#[test]\n+fn test_tt_to_stmts() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            () => {\n+                 let a = 0;\n+                 a = 10 + 1;\n+                 a\n+            }\n+        }\n+\"#,\n+    );\n+\n+    let expanded = expand(&rules, \"foo!{}\");\n+    let stmts = token_tree_to_macro_stmts(&expanded);\n+\n+    assert_eq!(\n+        stmts.unwrap().syntax().debug_dump().trim(),\n+        r#\"MACRO_STMTS@[0; 15)\n+  LET_STMT@[0; 7)\n+    LET_KW@[0; 3) \"let\"\n+    BIND_PAT@[3; 4)\n+      NAME@[3; 4)\n+        IDENT@[3; 4) \"a\"\n+    EQ@[4; 5) \"=\"\n+    LITERAL@[5; 6)\n+      INT_NUMBER@[5; 6) \"0\"\n+    SEMI@[6; 7) \";\"\n+  EXPR_STMT@[7; 14)\n+    BIN_EXPR@[7; 13)\n+      PATH_EXPR@[7; 8)\n+        PATH@[7; 8)\n+          PATH_SEGMENT@[7; 8)\n+            NAME_REF@[7; 8)\n+              IDENT@[7; 8) \"a\"\n+      EQ@[8; 9) \"=\"\n+      BIN_EXPR@[9; 13)\n+        LITERAL@[9; 11)\n+          INT_NUMBER@[9; 11) \"10\"\n+        PLUS@[11; 12) \"+\"\n+        LITERAL@[12; 13)\n+          INT_NUMBER@[12; 13) \"1\"\n+    SEMI@[13; 14) \";\"\n+  EXPR_STMT@[14; 15)\n+    PATH_EXPR@[14; 15)\n+      PATH@[14; 15)\n+        PATH_SEGMENT@[14; 15)\n+          NAME_REF@[14; 15)\n+            IDENT@[14; 15) \"a\"\"#,\n+    );\n+}\n+\n+// The following tests are port from intellij-rust directly\n+// https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n+\n+#[test]\n+fn test_path() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:path) => {\n+                fn foo() { let a = $ i; }\n+            }\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"fn foo () {let a = foo ;}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! { bar::<u8>::baz::<u8> }\",\n+        \"fn foo () {let a = bar ::< u8 >:: baz ::< u8 > ;}\",\n+    );\n+}\n+\n+#[test]\n+fn test_two_paths() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:path, $ j:path) => {\n+                fn foo() { let a = $ i; let b = $j; }\n+            }\n+        }\n+\"#,\n+    );\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! { foo, bar }\",\n+        \"fn foo () {let a = foo ; let b = bar ;}\",\n+    );\n+}\n+\n+#[test]\n+fn test_path_with_path() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:path) => {\n+                fn foo() { let a = $ i :: bar; }\n+            }\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { foo }\", \"fn foo () {let a = foo :: bar ;}\");\n+}\n+\n+#[test]\n+fn test_expr() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:expr) => {\n+                 fn bar() { $ i; } \n+            }\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! { 2 + 2 * baz(3).quux() }\",\n+        \"fn bar () {2 + 2 * baz (3) . quux () ;}\",\n+    );\n+}\n+\n+#[test]\n+fn test_expr_order() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:expr) => {\n+                 fn bar() { $ i * 2; } \n+            }\n+        }\n+\"#,\n+    );\n+\n+    assert_eq!(\n+        expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax().debug_dump().trim(),\n+        r#\"MACRO_ITEMS@[0; 15)\n+  FN_DEF@[0; 15)\n+    FN_KW@[0; 2) \"fn\"\n+    NAME@[2; 5)\n+      IDENT@[2; 5) \"bar\"\n+    PARAM_LIST@[5; 7)\n+      L_PAREN@[5; 6) \"(\"\n+      R_PAREN@[6; 7) \")\"\n+    BLOCK@[7; 15)\n+      L_CURLY@[7; 8) \"{\"\n+      EXPR_STMT@[8; 14)\n+        BIN_EXPR@[8; 13)\n+          BIN_EXPR@[8; 11)\n+            LITERAL@[8; 9)\n+              INT_NUMBER@[8; 9) \"1\"\n+            PLUS@[9; 10) \"+\"\n+            LITERAL@[10; 11)\n+              INT_NUMBER@[10; 11) \"1\"\n+          STAR@[11; 12) \"*\"\n+          LITERAL@[12; 13)\n+            INT_NUMBER@[12; 13) \"2\"\n+        SEMI@[13; 14) \";\"\n+      R_CURLY@[14; 15) \"}\"\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_last_expr() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! vec {\n+            ($($item:expr),*) => {\n+                {\n+                    let mut v = Vec::new();\n+                    $(\n+                        v.push($item);\n+                    )*\n+                    v\n+                }\n+            };\n+        }\n+\"#,\n+    );\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"vec!(1,2,3)\",\n+        \"{let mut v = Vec :: new () ; v . push (1) ; v . push (2) ; v . push (3) ; v}\",\n+    );\n+}\n+\n+#[test]\n+fn test_ty() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ty) => (\n+                fn bar() -> $ i { unimplemented!() }\n+            )\n+        }\n+\"#,\n+    );\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! { Baz<u8> }\",\n+        \"fn bar () -> Baz < u8 > {unimplemented ! ()}\",\n+    );\n+}\n+\n+#[test]\n+fn test_ty_with_complex_type() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:ty) => (\n+                fn bar() -> $ i { unimplemented!() }\n+            )\n+        }\n+\"#,\n+    );\n+\n+    // Reference lifetime struct with generic type\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        \"foo! { &'a Baz<u8> }\",\n+        \"fn bar () -> & 'a Baz < u8 > {unimplemented ! ()}\",\n+    );\n+\n+    // extern \"Rust\" func type\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"foo! { extern \"Rust\" fn() -> Ret }\"#,\n+        r#\"fn bar () -> extern \"Rust\" fn () -> Ret {unimplemented ! ()}\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_pat_() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:pat) => { fn foo() { let $ i; } }\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n+}\n+\n+#[test]\n+fn test_stmt() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:stmt) => (\n+                fn bar() { $ i; }\n+            )\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { 2 }\", \"fn bar () {2 ;}\");\n+    assert_expansion(MacroKind::Items, &rules, \"foo! { let a = 0 }\", \"fn bar () {let a = 0 ;}\");\n+}\n+\n+#[test]\n+fn test_single_item() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:item) => (\n+                $ i\n+            )\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, \"foo! {mod c {}}\", \"mod c {}\");\n+}\n+\n+#[test]\n+fn test_all_items() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ ($ i:item)*) => ($ (\n+                $ i\n+            )*)\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, r#\"\n+        foo! {\n+            extern crate a;\n+            mod b;\n+            mod c {}\n+            use d;\n+            const E: i32 = 0;\n+            static F: i32 = 0;\n+            impl G {}\n+            struct H;\n+            enum I { Foo }\n+            trait J {}\n+            fn h() {}\n+            extern {}\n+            type T = u8;\n+        }\n+\"#, r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#);\n+}\n+\n+#[test]\n+fn test_block() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:block) => { fn foo() $ i }\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Stmts, &rules, \"foo! { { 1; } }\", \"fn foo () {1 ;}\");\n+}\n+\n+#[test]\n+fn test_meta() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:meta) => (\n+                #[$ i]\n+                fn bar() {}\n+            )\n+        }\n+\"#,\n+    );\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"foo! { cfg(target_os = \"windows\") }\"#,\n+        r#\"# [cfg (target_os = \"windows\")] fn bar () {}\"#,\n+    );\n+}\n+\n+#[test]\n+fn test_tt_block() {\n+    let rules = create_rules(\n+        r#\"\n+            macro_rules! foo {\n+                ($ i:tt) => { fn foo() $ i }\n+            }\n+    \"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n+}\n+\n+#[test]\n+fn test_tt_group() {\n+    let rules = create_rules(\n+        r#\"\n+            macro_rules! foo {\n+                 ($($ i:tt)*) => { $($ i)* }\n+            }\n+    \"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n+}\n+#[test]\n+fn test_lifetime() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+              ($ lt:lifetime) => { struct Ref<$ lt>{ s: &$ lt str } }\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n+}\n+\n+#[test]\n+fn test_literal() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+              ($ type:ty $ lit:literal) => { const VALUE: $ type = $ lit;};\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, r#\"foo!(u8 0)\"#, r#\"const VALUE : u8 = 0 ;\"#);\n+}\n+\n+#[test]\n+fn test_vis() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+              ($ vis:vis $ name:ident) => { $ vis fn $ name() {}};\n+        }\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#);\n+\n+    // test optional casse\n+    assert_expansion(MacroKind::Items, &rules, r#\"foo!(foo);\"#, r#\"fn foo () {}\"#);\n+}\n+\n+#[test]\n+fn test_inner_macro_rules() {\n+    let rules = create_rules(\n+        r#\"\n+macro_rules! foo {\n+    ($a:ident, $b:ident, $c:tt) => {\n+\n+        macro_rules! bar {\n+            ($bi:ident) => {\n+                fn $bi() -> u8 {$c}\n+            }\n+        }\n+\n+        bar!($a);\n+        fn $b() -> u8 {$c}\n+    }\n+}        \n+\"#,\n+    );\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"foo!(x,y, 1);\"#,\n+        r#\"macro_rules ! bar {(bi : ident) => {fn bi () -> u8 {1}}} bar ! (x) ; fn y () -> u8 {1}\"#,\n+    );\n+}\n+\n+// The following tests are based on real world situations\n+#[test]\n+fn test_vec() {\n+    let rules = create_rules(\n+        r#\"\n+         macro_rules! vec {\n+            ($($item:expr),*) => {\n+                {\n+                    let mut v = Vec::new();\n+                    $(\n+                        v.push($item);\n+                    )*\n+                    v\n+                }\n+            };\n+}\n+\"#,\n+    );\n+    assert_expansion(MacroKind::Items, &rules, r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ; v}\"#);\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"vec![1u32,2]\"#,\n+        r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n+    );\n+\n+    assert_eq!(\n+        expand_to_expr(&rules, r#\"vec![1u32,2]\"#).syntax().debug_dump().trim(),\n+        r#\"BLOCK_EXPR@[0; 45)\n+  BLOCK@[0; 45)\n+    L_CURLY@[0; 1) \"{\"\n+    LET_STMT@[1; 20)\n+      LET_KW@[1; 4) \"let\"\n+      BIND_PAT@[4; 8)\n+        MUT_KW@[4; 7) \"mut\"\n+        NAME@[7; 8)\n+          IDENT@[7; 8) \"v\"\n+      EQ@[8; 9) \"=\"\n+      CALL_EXPR@[9; 19)\n+        PATH_EXPR@[9; 17)\n+          PATH@[9; 17)\n+            PATH@[9; 12)\n+              PATH_SEGMENT@[9; 12)\n+                NAME_REF@[9; 12)\n+                  IDENT@[9; 12) \"Vec\"\n+            COLONCOLON@[12; 14) \"::\"\n+            PATH_SEGMENT@[14; 17)\n+              NAME_REF@[14; 17)\n+                IDENT@[14; 17) \"new\"\n+        ARG_LIST@[17; 19)\n+          L_PAREN@[17; 18) \"(\"\n+          R_PAREN@[18; 19) \")\"\n+      SEMI@[19; 20) \";\"\n+    EXPR_STMT@[20; 33)\n+      METHOD_CALL_EXPR@[20; 32)\n+        PATH_EXPR@[20; 21)\n+          PATH@[20; 21)\n+            PATH_SEGMENT@[20; 21)\n+              NAME_REF@[20; 21)\n+                IDENT@[20; 21) \"v\"\n+        DOT@[21; 22) \".\"\n+        NAME_REF@[22; 26)\n+          IDENT@[22; 26) \"push\"\n+        ARG_LIST@[26; 32)\n+          L_PAREN@[26; 27) \"(\"\n+          LITERAL@[27; 31)\n+            INT_NUMBER@[27; 31) \"1u32\"\n+          R_PAREN@[31; 32) \")\"\n+      SEMI@[32; 33) \";\"\n+    EXPR_STMT@[33; 43)\n+      METHOD_CALL_EXPR@[33; 42)\n+        PATH_EXPR@[33; 34)\n+          PATH@[33; 34)\n+            PATH_SEGMENT@[33; 34)\n+              NAME_REF@[33; 34)\n+                IDENT@[33; 34) \"v\"\n+        DOT@[34; 35) \".\"\n+        NAME_REF@[35; 39)\n+          IDENT@[35; 39) \"push\"\n+        ARG_LIST@[39; 42)\n+          L_PAREN@[39; 40) \"(\"\n+          LITERAL@[40; 41)\n+            INT_NUMBER@[40; 41) \"2\"\n+          R_PAREN@[41; 42) \")\"\n+      SEMI@[42; 43) \";\"\n+    PATH_EXPR@[43; 44)\n+      PATH@[43; 44)\n+        PATH_SEGMENT@[43; 44)\n+          NAME_REF@[43; 44)\n+            IDENT@[43; 44) \"v\"\n+    R_CURLY@[44; 45) \"}\"\"#\n+    );\n+}\n+\n+#[test]\n+fn test_winapi_struct() {\n+    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n+\n+    let rules = create_rules(\n+        r#\"\n+macro_rules! STRUCT {\n+    ($(#[$attrs:meta])* struct $name:ident {\n+        $($field:ident: $ftype:ty,)+\n+    }) => (\n+        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n+        pub struct $name {\n+            $(pub $field: $ftype,)+\n+        }\n+        impl Clone for $name {\n+            #[inline]\n+            fn clone(&self) -> $name { *self }\n+        }\n+        #[cfg(feature = \"impl-default\")]\n+        impl Default for $name {\n+            #[inline]\n+            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n+        }\n+    );\n+}\n+\"#,\n+    );\n+    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n+    assert_expansion(MacroKind::Items, &rules, r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n+        \"# [repr (C)] # [derive (Copy)] pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n+    assert_expansion(MacroKind::Items, &rules, r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#, \n+        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n+}\n+\n+#[test]\n+fn test_int_base() {\n+    let rules = create_rules(\n+        r#\"\n+macro_rules! int_base {\n+    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::$Trait for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                $Radix.fmt_int(*self as $U, f)\n+            }\n+        }\n+    }\n+}            \n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#, \n+        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n+        );\n+}\n+\n+#[test]\n+fn test_generate_pattern_iterators() {\n+    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n+    let rules = create_rules(\n+        r#\"\n+macro_rules! generate_pattern_iterators {        \n+        { double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+        } => {\n+            fn foo(){}\n+        }\n+}\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str )\"#, \n+        \"fn foo () {}\");\n+}\n+\n+#[test]\n+fn test_impl_fn_for_zst() {\n+    // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n+    let rules = create_rules(\n+        r#\"\n+macro_rules! impl_fn_for_zst  {        \n+        {  $( $( #[$attr: meta] )*\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+$body: block; )+\n+        } => {\n+           $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+}\n+        }\n+}\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\"\n+impl_fn_for_zst !   { \n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   { \n+         c . escape_debug_ext ( false ) \n+     } ; \n+\n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   { \n+         c . escape_unicode ( ) \n+     } ; \n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   { \n+         c . escape_default ( ) \n+     } ; \n+ }\n+\"#, \n+        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\");\n+}\n+\n+#[test]\n+fn test_impl_nonzero_fmt() {\n+    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! impl_nonzero_fmt {\n+            ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+                fn foo () {}\n+            }\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n+        \"fn foo () {}\");\n+}\n+\n+#[test]\n+fn test_cfg_if_items() {\n+    // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! __cfg_if_items {\n+            (($($not:meta,)*) ; ) => {};\n+            (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+                 __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+            }\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,         \n+        \"__cfg_if_items ! {(rustdoc ,) ;}\");\n+}\n+\n+#[test]\n+fn test_cfg_if_main() {\n+    // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! cfg_if {\n+            ($(\n+                if #[cfg($($meta:meta),*)] { $($it:item)* }\n+            ) else * else {\n+                $($it2:item)*\n+            }) => {\n+                __cfg_if_items! {\n+                    () ;\n+                    $( ( ($($meta),*) ($($it)*) ), )*\n+                    ( () ($($it2)*) ),\n+                }\n+            }\n+        }\n+\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\"\n+cfg_if !   { \n+     if   # [ cfg ( target_env   =   \"msvc\" ) ]   { \n+         // no extra unwinder support needed \n+     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   { \n+         // no unwinder on the system! \n+     }   else   { \n+         mod   libunwind ; \n+         pub   use   libunwind :: * ; \n+     } \n+ }        \n+\"#,         \n+        \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n+}\n+\n+#[test]\n+fn test_proptest_arbitrary() {\n+    // from https://github.com/AltSysrq/proptest/blob/d1c4b049337d2f75dd6f49a095115f7c532e5129/proptest/src/arbitrary/macros.rs#L16\n+    let rules = create_rules(\n+        r#\"\n+macro_rules! arbitrary {\n+    ([$($bounds : tt)*] $typ: ty, $strat: ty, $params: ty;\n+        $args: ident => $logic: expr) => {\n+        impl<$($bounds)*> $crate::arbitrary::Arbitrary for $typ {\n+            type Parameters = $params;\n+            type Strategy = $strat;\n+            fn arbitrary_with($args: Self::Parameters) -> Self::Strategy {\n+                $logic\n+            }\n+        }\n+    };  \n+   \n+}\"#,\n+    );\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\"arbitrary !   ( [ A : Arbitrary ] \n+        Vec < A > , \n+        VecStrategy < A :: Strategy > , \n+        RangedParams1 < A :: Parameters > ; \n+        args =>   { let product_unpack !   [ range , a ] = args ; vec ( any_with :: < A >   ( a ) , range ) } \n+    ) ;\"#,\n+    \"impl <A : Arbitrary > $crate :: arbitrary :: Arbitrary for Vec < A > {type Parameters = RangedParams1 < A :: Parameters > ; type Strategy = VecStrategy < A :: Strategy > ; fn arbitrary_with (args : Self :: Parameters) -> Self :: Strategy {{let product_unpack ! [range , a] = args ; vec (any_with :: < A > (a) , range)}}}\");\n+}\n+\n+#[test]\n+fn test_old_ridl() {\n+    // This is from winapi 2.8, which do not have a link from github\n+    //\n+    let rules = create_rules(\n+        r#\"\n+#[macro_export]\n+macro_rules! RIDL {    \n+    (interface $interface:ident ($vtbl:ident) : $pinterface:ident ($pvtbl:ident)\n+        {$(\n+            fn $method:ident(&mut self $(,$p:ident : $t:ty)*) -> $rtr:ty\n+        ),+}\n+    ) => {\n+        impl $interface {\n+            $(pub unsafe fn $method(&mut self) -> $rtr {\n+                ((*self.lpVtbl).$method)(self $(,$p)*)\n+            })+\n+        }        \n+    };\n+}\"#,\n+    );\n+\n+    let expanded = expand(&rules, r#\"\n+RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n+    fn GetDataSize(&mut self) -> UINT\n+}}\"#);\n+    assert_eq!(expanded.to_string(), \"impl ID3D11Asynchronous {pub unsafe fn GetDataSize (& mut self) -> UINT {((* self . lpVtbl) .GetDataSize) (self)}}\");\n+}\n+\n+#[test]\n+fn test_quick_error() {\n+    let rules = create_rules(\n+        r#\"\n+macro_rules! quick_error {\n+\n+ (SORT [enum $name:ident $( #[$meta:meta] )*]\n+        items [$($( #[$imeta:meta] )*\n+                  => $iitem:ident: $imode:tt [$( $ivar:ident: $ityp:ty ),*]\n+                                {$( $ifuncs:tt )*} )* ]\n+        buf [ ]\n+        queue [ ]\n+    ) => {\n+        quick_error!(ENUM_DEFINITION [enum $name $( #[$meta] )*]\n+            body []\n+            queue [$(\n+                $( #[$imeta] )*                      \n+                => \n+                $iitem: $imode [$( $ivar: $ityp ),*]                       \n+            )*]\n+        );        \n+};\n+\n+}\n+\"#,\n+    );\n+\n+    let expanded = expand(\n+        &rules,\n+        r#\"\n+quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n+        => One : UNIT [] {} \n+        => Two : TUPLE [s :String] {display (\"two: {}\" , s) from ()}\n+    ] buf [] queue []) ;\n+\"#,\n+    );\n+\n+    assert_eq!(expanded.to_string(), \"quick_error ! (ENUM_DEFINITION [enum Wrapped # [derive (Debug)]] body [] queue [=> One : UNIT [] => Two : TUPLE [s : String]]) ;\");\n+}"}]}