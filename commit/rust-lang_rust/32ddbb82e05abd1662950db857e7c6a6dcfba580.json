{"sha": "32ddbb82e05abd1662950db857e7c6a6dcfba580", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZGRiYjgyZTA1YWJkMTY2Mjk1MGRiODU3ZTdjNmE2ZGNmYmE1ODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-11T18:50:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-11T18:50:46Z"}, "message": "auto merge of #20406 : TimDumol/rust/dlist-append-split-off, r=Gankro\n\nImplements the `append()` and `split_off()` methods proposed by the collections reform part 2 RFC.\r\n\r\nRFC: https://github.com/rust-lang/rfcs/pull/509\r\nTracking issue: https://github.com/rust-lang/rust/issues/19986", "tree": {"sha": "be2c12a604d8a2cde729f58a029ec265ef91ca25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be2c12a604d8a2cde729f58a029ec265ef91ca25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32ddbb82e05abd1662950db857e7c6a6dcfba580", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32ddbb82e05abd1662950db857e7c6a6dcfba580", "html_url": "https://github.com/rust-lang/rust/commit/32ddbb82e05abd1662950db857e7c6a6dcfba580", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32ddbb82e05abd1662950db857e7c6a6dcfba580/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e4cef4e78253beb4c08ed35416fad076d978344", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e4cef4e78253beb4c08ed35416fad076d978344", "html_url": "https://github.com/rust-lang/rust/commit/2e4cef4e78253beb4c08ed35416fad076d978344"}, {"sha": "d0bc0315f50929d06a05e9278cb0214cdca44ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0bc0315f50929d06a05e9278cb0214cdca44ac0", "html_url": "https://github.com/rust-lang/rust/commit/d0bc0315f50929d06a05e9278cb0214cdca44ac0"}], "stats": {"total": 202, "additions": 161, "deletions": 41}, "files": [{"sha": "4f918ceac578c636203cd0b60b6d318cb113b32e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 161, "deletions": 41, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/32ddbb82e05abd1662950db857e7c6a6dcfba580/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32ddbb82e05abd1662950db857e7c6a6dcfba580/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=32ddbb82e05abd1662950db857e7c6a6dcfba580", "patch": "@@ -221,9 +221,12 @@ impl<T> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n-    /// Adds all elements from `other` to the end of the list.\n+    /// Moves all elements from `other` to the end of the list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This reuses all the nodes from `other` and moves them into `self`. After\n+    /// this operation, `other` becomes empty.\n+    ///\n+    /// This operation should compute in O(1) time and O(1) memory.\n     ///\n     /// # Examples\n     ///\n@@ -237,16 +240,20 @@ impl<T> DList<T> {\n     /// b.push_back(3i);\n     /// b.push_back(4);\n     ///\n-    /// a.append(b);\n+    /// a.append(&mut b);\n     ///\n     /// for e in a.iter() {\n     ///     println!(\"{}\", e); // prints 1, then 2, then 3, then 4\n     /// }\n+    /// println!(\"{}\", b.len()); // prints 0\n     /// ```\n-    #[unstable = \"append should be by-mutable-reference\"]\n-    pub fn append(&mut self, mut other: DList<T>) {\n+    pub fn append(&mut self, other: &mut DList<T>) {\n         match self.list_tail.resolve() {\n-            None => *self = other,\n+            None => {\n+                self.length = other.length;\n+                self.list_head = other.list_head.take();\n+                self.list_tail = other.list_tail.take();\n+            },\n             Some(tail) => {\n                 // Carefully empty `other`.\n                 let o_tail = other.list_tail.take();\n@@ -261,6 +268,7 @@ impl<T> DList<T> {\n                 }\n             }\n         }\n+        other.length = 0;\n     }\n \n     /// Provides a forward iterator.\n@@ -404,6 +412,51 @@ impl<T> DList<T> {\n     pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n+\n+    /// Splits the list into two at the given index. Returns everything after the given index,\n+    /// including the index.\n+    ///\n+    /// This operation should compute in O(n) time.\n+    #[stable]\n+    pub fn split_off(&mut self, at: uint) -> DList<T> {\n+        let len = self.len();\n+        assert!(at < len, \"Cannot split off at a nonexistent index\");\n+        if at == 0 {\n+            return mem::replace(self, DList::new());\n+        }\n+\n+        // Below, we iterate towards the `i-1`th node, either from the start or the end,\n+        // depending on which would be faster.\n+        let mut split_node = if at - 1 <= len - 1 - (at - 1) {\n+            let mut iter = self.iter_mut();\n+            // instead of skipping using .skip() (which creates a new struct),\n+            // we skip manually so we can access the head field without\n+            // depending on implementation details of Skip\n+            for _ in range(0, at - 1) {\n+                iter.next();\n+            }\n+            iter.head\n+        }  else {\n+            // better off starting from the end\n+            let mut iter = self.iter_mut();\n+            for _ in range(0, len - 1 - (at - 1)) {\n+                iter.next_back();\n+            }\n+            iter.tail\n+        };\n+\n+        let mut splitted_list = DList {\n+            list_head: None,\n+            list_tail: self.list_tail,\n+            length: len - at\n+        };\n+\n+        mem::swap(&mut split_node.resolve().unwrap().next, &mut splitted_list.list_head);\n+        self.list_tail = split_node;\n+        self.length = at;\n+\n+        splitted_list\n+    }\n }\n \n #[unsafe_destructor]\n@@ -777,6 +830,108 @@ mod tests {\n         v.iter().map(|x| (*x).clone()).collect()\n     }\n \n+    #[test]\n+    fn test_append() {\n+        // Empty to empty\n+        {\n+            let mut m: DList<int> = DList::new();\n+            let mut n = DList::new();\n+            m.append(&mut n);\n+            check_links(&m);\n+            assert_eq!(m.len(), 0);\n+            assert_eq!(n.len(), 0);\n+        }\n+        // Non-empty to empty\n+        {\n+            let mut m = DList::new();\n+            let mut n = DList::new();\n+            n.push_back(2i);\n+            m.append(&mut n);\n+            check_links(&m);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            assert_eq!(n.len(), 0);\n+            check_links(&m);\n+        }\n+        // Empty to non-empty\n+        {\n+            let mut m = DList::new();\n+            let mut n = DList::new();\n+            m.push_back(2i);\n+            m.append(&mut n);\n+            check_links(&m);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+\n+        // Non-empty to non-empty\n+        let v = vec![1i,2,3,4,5];\n+        let u = vec![9i,8,1,2,3,4,5];\n+        let mut m = list_from(v.as_slice());\n+        let mut n = list_from(u.as_slice());\n+        m.append(&mut n);\n+        check_links(&m);\n+        let mut sum = v;\n+        sum.push_all(u.as_slice());\n+        assert_eq!(sum.len(), m.len());\n+        for elt in sum.into_iter() {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n+        assert_eq!(n.len(), 0);\n+        // let's make sure it's working properly, since we\n+        // did some direct changes to private members\n+        n.push_back(3);\n+        assert_eq!(n.len(), 1);\n+        assert_eq!(n.pop_front(), Some(3));\n+        check_links(&n);\n+    }\n+\n+    #[test]\n+    fn test_split_off() {\n+        // singleton\n+        {\n+            let mut m = DList::new();\n+            m.push_back(1i);\n+\n+            let p = m.split_off(0);\n+            assert_eq!(m.len(), 0);\n+            assert_eq!(p.len(), 1);\n+            assert_eq!(p.back(), Some(&1));\n+            assert_eq!(p.front(), Some(&1));\n+        }\n+\n+        // not singleton, forwards\n+        {\n+            let u = vec![1i,2,3,4,5];\n+            let mut m = list_from(u.as_slice());\n+            let mut n = m.split_off(2);\n+            assert_eq!(m.len(), 2);\n+            assert_eq!(n.len(), 3);\n+            for elt in range(1i, 3) {\n+                assert_eq!(m.pop_front(), Some(elt));\n+            }\n+            for elt in range(3i, 6) {\n+                assert_eq!(n.pop_front(), Some(elt));\n+            }\n+        }\n+        // not singleton, backwards\n+        {\n+            let u = vec![1i,2,3,4,5];\n+            let mut m = list_from(u.as_slice());\n+            let mut n = m.split_off(4);\n+            assert_eq!(m.len(), 4);\n+            assert_eq!(n.len(), 1);\n+            for elt in range(1i, 5) {\n+                assert_eq!(m.pop_front(), Some(elt));\n+            }\n+            for elt in range(5i, 6) {\n+                assert_eq!(n.pop_front(), Some(elt));\n+            }\n+        }\n+\n+    }\n+\n     #[test]\n     fn test_iterator() {\n         let m = generate_test();\n@@ -1065,41 +1220,6 @@ mod tests {\n         assert_eq!(i, v.len());\n     }\n \n-    #[allow(deprecated)]\n-    #[test]\n-    fn test_append() {\n-        {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n-            n.push_back(2i);\n-            m.append(n);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-        {\n-            let mut m = DList::new();\n-            let n = DList::new();\n-            m.push_back(2i);\n-            m.append(n);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        let v = vec![1i,2,3,4,5];\n-        let u = vec![9i,8,1,2,3,4,5];\n-        let mut m = list_from(v.as_slice());\n-        m.append(list_from(u.as_slice()));\n-        check_links(&m);\n-        let mut sum = v;\n-        sum.push_all(u.as_slice());\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum.into_iter() {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-    }\n-\n     #[bench]\n     fn bench_collect_into(b: &mut test::Bencher) {\n         let v = &[0i; 64];"}]}