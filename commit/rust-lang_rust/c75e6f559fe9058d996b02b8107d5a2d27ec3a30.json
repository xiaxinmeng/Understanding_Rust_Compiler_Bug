{"sha": "c75e6f559fe9058d996b02b8107d5a2d27ec3a30", "node_id": "C_kwDOAAsO6NoAKGM3NWU2ZjU1OWZlOTA1OGQ5OTZiMDJiODEwN2Q1YTJkMjdlYzNhMzA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-27T13:03:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-27T13:03:56Z"}, "message": "Rollup merge of #103394 - Pointerbender:unsafecell-docs, r=Amanieu\n\nClarify documentation about the memory layout of `UnsafeCell`\n\nThis PR addresses a [comment](https://github.com/rust-lang/rust/pull/101717#issuecomment-1279908390) by `@RalfJung` in PR #101717 to further clarify the documentation of `UnsafeCell<T>`. The previous PR was merged already before we had a chance to correct this, hence this second PR :)\n\nTo goal of this PR is:\n\n1. Split the paragraph about the memory layout of `UnsafeCell<T>` and the usage of `UnsafeCell::(raw_)get()` into two paragraphs, so that it is easier to digest for the reader.\n2. Slightly simplify the previously added examples in order to reduce redundancy between the new examples and the examples that already [existed](https://github.com/rust-lang/rust/blob/ddd119b2fed57eb6b19c44c18108de95c564a48d/library/core/src/cell.rs#L1858-L1908) before these 2 PRs (which remained untouched by both PRs).", "tree": {"sha": "5c60bae5685301d5e8f8ac842111e7c1577f7551", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c60bae5685301d5e8f8ac842111e7c1577f7551"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c75e6f559fe9058d996b02b8107d5a2d27ec3a30", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjWoG8CRBK7hj4Ov3rIwAAElkIAJny9RE5Ua8GszUrloEYStcX\n3N5gljF5BmpfC23yDdLUxWneAV2UKwS8WmJSZd+F9m4XH/GkNwLaEeMe4mVimNJh\nnEJp7Sdw3bR6oeouc20oVXaNxs2uiX5DpHNoTAQpw4hStDL/s7OdqnxqkOeiQYWZ\no3Scf7VOz8aXzAuzwmU1TStElMSJ4CBIVir0wwE2fVxIVxpETzH15Mj7WFYeb96C\nbnk+0/dtC9fZDz5Qj1scEbn6CHvJfpbrhb4DPzADdR9/iRbGobuOU1nbBNnRsLfb\ndZMNQ98djFInm8Lt/KweDsWSrqJZrAFOi55LoNy3VV5jd/QgaTGBfGt/WuMvT8U=\n=1M01\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c60bae5685301d5e8f8ac842111e7c1577f7551\nparent 16e74c78a10b5a7eb4fc6c89176820382447c497\nparent 166d8b8c2b282ba0d0cf4da277cf8829d30df94b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1666875836 +0200\ncommitter GitHub <noreply@github.com> 1666875836 +0200\n\nRollup merge of #103394 - Pointerbender:unsafecell-docs, r=Amanieu\n\nClarify documentation about the memory layout of `UnsafeCell`\n\nThis PR addresses a [comment](https://github.com/rust-lang/rust/pull/101717#issuecomment-1279908390) by `@RalfJung` in PR #101717 to further clarify the documentation of `UnsafeCell<T>`. The previous PR was merged already before we had a chance to correct this, hence this second PR :)\n\nTo goal of this PR is:\n\n1. Split the paragraph about the memory layout of `UnsafeCell<T>` and the usage of `UnsafeCell::(raw_)get()` into two paragraphs, so that it is easier to digest for the reader.\n2. Slightly simplify the previously added examples in order to reduce redundancy between the new examples and the examples that already [existed](https://github.com/rust-lang/rust/blob/ddd119b2fed57eb6b19c44c18108de95c564a48d/library/core/src/cell.rs#L1858-L1908) before these 2 PRs (which remained untouched by both PRs).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c75e6f559fe9058d996b02b8107d5a2d27ec3a30", "html_url": "https://github.com/rust-lang/rust/commit/c75e6f559fe9058d996b02b8107d5a2d27ec3a30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c75e6f559fe9058d996b02b8107d5a2d27ec3a30/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e74c78a10b5a7eb4fc6c89176820382447c497", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e74c78a10b5a7eb4fc6c89176820382447c497", "html_url": "https://github.com/rust-lang/rust/commit/16e74c78a10b5a7eb4fc6c89176820382447c497"}, {"sha": "166d8b8c2b282ba0d0cf4da277cf8829d30df94b", "url": "https://api.github.com/repos/rust-lang/rust/commits/166d8b8c2b282ba0d0cf4da277cf8829d30df94b", "html_url": "https://github.com/rust-lang/rust/commit/166d8b8c2b282ba0d0cf4da277cf8829d30df94b"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "7bf32cb0d98f27b3bf4db76847f8725cea272d65", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c75e6f559fe9058d996b02b8107d5a2d27ec3a30/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75e6f559fe9058d996b02b8107d5a2d27ec3a30/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=c75e6f559fe9058d996b02b8107d5a2d27ec3a30", "patch": "@@ -1816,6 +1816,8 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n ///\n /// [`.get_mut()`]: `UnsafeCell::get_mut`\n ///\n+/// # Memory layout\n+///\n /// `UnsafeCell<T>` has the same in-memory representation as its inner type `T`. A consequence\n /// of this guarantee is that it is possible to convert between `T` and `UnsafeCell<T>`.\n /// Special care has to be taken when converting a nested `T` inside of an `Outer<T>` type\n@@ -1825,35 +1827,44 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// Therefore this is not a valid conversion, despite `NonNull<u8>` and `UnsafeCell<NonNull<u8>>>`\n /// having the same memory layout. This is because `UnsafeCell` disables niche optimizations in\n /// order to avoid its interior mutability property from spreading from `T` into the `Outer` type,\n-/// thus this can cause distortions in the type size in these cases. Furthermore, it is only valid\n-/// to obtain a `*mut T` pointer to the contents of a _shared_ `UnsafeCell<T>` through [`.get()`]\n-/// or [`.raw_get()`]. A `&mut T` reference can be obtained by either dereferencing this pointer or\n-/// by calling [`.get_mut()`] on an _exclusive_ `UnsafeCell<T>`, e.g.:\n+/// thus this can cause distortions in the type size in these cases.\n+///\n+/// Note that the only valid way to obtain a `*mut T` pointer to the contents of a\n+/// _shared_ `UnsafeCell<T>` is through [`.get()`]  or [`.raw_get()`]. A `&mut T` reference\n+/// can be obtained by either dereferencing this pointer or by calling [`.get_mut()`]\n+/// on an _exclusive_ `UnsafeCell<T>`. Even though `T` and `UnsafeCell<T>` have the\n+/// same memory layout, the following is not allowed and undefined behavior:\n+///\n+/// ```rust,no_run\n+/// # use std::cell::UnsafeCell;\n+/// unsafe fn not_allowed<T>(ptr: &UnsafeCell<T>) -> &mut T {\n+///   let t = ptr as *const UnsafeCell<T> as *mut T;\n+///   // This is undefined behavior, because the `*mut T` pointer\n+///   // was not obtained through `.get()` nor `.raw_get()`:\n+///   unsafe { &mut *t }\n+/// }\n+/// ```\n+///\n+/// Instead, do this:\n ///\n /// ```rust\n-/// use std::cell::UnsafeCell;\n+/// # use std::cell::UnsafeCell;\n+/// // Safety: the caller must ensure that there are no references that\n+/// // point to the *contents* of the `UnsafeCell`.\n+/// unsafe fn get_mut<T>(ptr: &UnsafeCell<T>) -> &mut T {\n+///   unsafe { &mut *ptr.get() }\n+/// }\n+/// ```\n ///\n-/// let mut x: UnsafeCell<u32> = UnsafeCell::new(5);\n-/// let shared: &UnsafeCell<u32> = &x;\n-/// // using `.get()` is okay:\n-/// unsafe {\n-///     // SAFETY: there exist no other references to the contents of `x`\n-///     let exclusive: &mut u32 = &mut *shared.get();\n-/// };\n-/// // using `.raw_get()` is also okay:\n-/// unsafe {\n-///     // SAFETY: there exist no other references to the contents of `x` in this scope\n-///     let exclusive: &mut u32 = &mut *UnsafeCell::raw_get(shared as *const _);\n-/// };\n-/// // using `.get_mut()` is always safe:\n-/// let exclusive: &mut u32 = x.get_mut();\n+/// Coverting in the other direction from a `&mut T`\n+/// to an `&UnsafeCell<T>` is allowed:\n ///\n-/// // when we have exclusive access, we can convert it to a shared `&UnsafeCell`:\n-/// unsafe {\n-///     // SAFETY: `u32` has no niche, therefore it has the same layout as `UnsafeCell<u32>`\n-///     let shared: &UnsafeCell<u32> = &*(exclusive as *mut _ as *const UnsafeCell<u32>);\n-///     // SAFETY: there exist no other *active* references to the contents of `x` in this scope\n-///     let exclusive: &mut u32 = &mut *shared.get();\n+/// ```rust\n+/// # use std::cell::UnsafeCell;\n+/// fn get_shared<T>(ptr: &mut T) -> &UnsafeCell<T> {\n+///   let t = ptr as *mut T as *const UnsafeCell<T>;\n+///   // SAFETY: `T` and `UnsafeCell<T>` have the same memory layout\n+///   unsafe { &*t }\n /// }\n /// ```\n ///"}]}