{"sha": "42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYTRmMzczYzliY2I4MTliNDQ4NWM5N2VmMGRmNGI3ZDdmZTk4YzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-05T23:20:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-05T23:20:32Z"}, "message": "Auto merge of #41773 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 9 pull requests\n\n- Successful merges: #41064, #41307, #41512, #41582, #41678, #41722, #41734, #41761, #41763\n- Failed merges:", "tree": {"sha": "0f551f3943098a8a760d67f33b3be9213e3fcb8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f551f3943098a8a760d67f33b3be9213e3fcb8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "html_url": "https://github.com/rust-lang/rust/commit/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4209651ec4d4455dab4fc3f3a3456a897d9da7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4209651ec4d4455dab4fc3f3a3456a897d9da7f", "html_url": "https://github.com/rust-lang/rust/commit/f4209651ec4d4455dab4fc3f3a3456a897d9da7f"}, {"sha": "5bed9dc320144a523958dd5871164d86d363772e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bed9dc320144a523958dd5871164d86d363772e", "html_url": "https://github.com/rust-lang/rust/commit/5bed9dc320144a523958dd5871164d86d363772e"}], "stats": {"total": 2440, "additions": 1490, "deletions": 950}, "files": [{"sha": "6fa139b1630a9bb95dcd60cfc90aff9c19e54580", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -1 +1 @@\n-Subproject commit 616b98444ff4eb5260deee95ee3e090dfd98b947\n+Subproject commit 6fa139b1630a9bb95dcd60cfc90aff9c19e54580"}, {"sha": "6d85183faf75d9867b2f54d531b74e30973b9a07", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -277,8 +277,7 @@ impl<T> Arc<T> {\n         atomic::fence(Acquire);\n \n         unsafe {\n-            let ptr = *this.ptr;\n-            let elem = ptr::read(&(*ptr).data);\n+            let elem = ptr::read(&this.ptr.as_ref().data);\n \n             // Make a weak pointer to clean up the implicit strong-weak reference\n             let _weak = Weak { ptr: this.ptr };\n@@ -306,7 +305,7 @@ impl<T> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &(**this.ptr).data as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -345,7 +344,7 @@ impl<T> Arc<T> {\n         // `data` field from the pointer.\n         let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n         Arc {\n-            ptr: Shared::new(ptr as *const _),\n+            ptr: Shared::new(ptr as *mut u8 as *mut _),\n         }\n     }\n }\n@@ -452,17 +451,17 @@ impl<T: ?Sized> Arc<T> {\n         // `ArcInner` structure itself is `Sync` because the inner data is\n         // `Sync` as well, so we're ok loaning out an immutable pointer to these\n         // contents.\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n \n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = self.ptr.as_mut_ptr();\n+        let ptr = self.ptr.as_ptr();\n \n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut (*ptr).data);\n+        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n@@ -488,9 +487,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const ArcInner<T> = *this.ptr;\n-        let other_ptr: *const ArcInner<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -621,7 +618,7 @@ impl<T: Clone> Arc<T> {\n                 // here (due to zeroing) because data is no longer accessed by\n                 // other threads (due to there being no more strong refs at this\n                 // point).\n-                let mut swap = Arc::new(ptr::read(&(**weak.ptr).data));\n+                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n                 mem::swap(this, &mut swap);\n                 mem::forget(swap);\n             }\n@@ -634,8 +631,7 @@ impl<T: Clone> Arc<T> {\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n         unsafe {\n-            let inner = &mut *this.ptr.as_mut_ptr();\n-            &mut inner.data\n+            &mut this.ptr.as_mut().data\n         }\n     }\n }\n@@ -677,8 +673,7 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                let inner = &mut *this.ptr.as_mut_ptr();\n-                Some(&mut inner.data)\n+                Some(&mut this.ptr.as_mut().data)\n             }\n         } else {\n             None\n@@ -878,7 +873,7 @@ impl<T: ?Sized> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n }\n \n@@ -962,7 +957,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.as_ptr();\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n@@ -1143,7 +1138,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n "}, {"sha": "fc6929f896ecbaa70870751f9c59007cc1024983", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -156,7 +156,7 @@ fn make_place<T>() -> IntermediateBox<T> {\n     let align = mem::align_of::<T>();\n \n     let p = if size == 0 {\n-        heap::EMPTY as *mut u8\n+        mem::align_of::<T>() as *mut u8\n     } else {\n         let p = unsafe { heap::allocate(size, align) };\n         if p.is_null() {"}, {"sha": "5ff21c86483c80cbbef1ef02fe516cc425b5dab6", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -138,7 +138,9 @@ pub fn usable_size(size: usize, align: usize) -> usize {\n ///\n /// This preserves the non-null invariant for types like `Box<T>`. The address\n /// may overlap with non-zero-size memory allocations.\n-pub const EMPTY: *mut () = 0x1 as *mut ();\n+#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/Shared::empty() instead\")]\n+#[unstable(feature = \"heap_api\", issue = \"27700\")]\n+pub const EMPTY: *mut () = 1 as *mut ();\n \n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR trans will fail.\n@@ -147,7 +149,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n-        EMPTY as *mut u8\n+        align as *mut u8\n     } else {\n         let ptr = allocate(size, align);\n         if ptr.is_null() {"}, {"sha": "7edf07944ec50c812aead220f6e66b4c69402b6a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -22,13 +22,13 @@ use core::cmp;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces heap::EMPTY on zero-sized types\n-/// * Produces heap::EMPTY on zero-length allocations\n+/// * Produces Unique::empty() on zero-sized types\n+/// * Produces Unique::empty() on zero-length allocations\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes\n /// * Guards against overflowing your length\n /// * Aborts on OOM\n-/// * Avoids freeing heap::EMPTY\n+/// * Avoids freeing Unique::empty()\n /// * Contains a ptr::Unique and thus endows the user with all related benefits\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n@@ -55,15 +55,13 @@ impl<T> RawVec<T> {\n     /// it makes a RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {\n-        unsafe {\n-            // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+        // !0 is usize::MAX. This branch should be stripped at compile time.\n+        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n-            RawVec {\n-                ptr: Unique::new(heap::EMPTY as *mut T),\n-                cap: cap,\n-            }\n+        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        RawVec {\n+            ptr: Unique::empty(),\n+            cap: cap,\n         }\n     }\n \n@@ -101,7 +99,7 @@ impl<T> RawVec<T> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                heap::EMPTY as *mut u8\n+                mem::align_of::<T>() as *mut u8\n             } else {\n                 let align = mem::align_of::<T>();\n                 let ptr = if zeroed {\n@@ -148,10 +146,10 @@ impl<T> RawVec<T> {\n \n impl<T> RawVec<T> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// heap::EMPTY if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n-        *self.ptr\n+        self.ptr.as_ptr()\n     }\n \n     /// Gets the capacity of the allocation.\n@@ -563,7 +561,7 @@ unsafe impl<#[may_dangle] T> Drop for RawVec<T> {\n \n             let num_bytes = elem_size * self.cap;\n             unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+                heap::deallocate(self.ptr() as *mut u8, num_bytes, align);\n             }\n         }\n     }"}, {"sha": "d6dbf77bfac770466ff3dfb8de43e83397d217fd", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -230,7 +230,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::intrinsics::{abort, assume};\n+use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n use core::mem::{self, align_of_val, forget, size_of, size_of_val, uninitialized};\n@@ -358,7 +358,7 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &mut (*this.ptr.as_mut_ptr()).value as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -395,7 +395,11 @@ impl<T> Rc<T> {\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n         // `value` field from the pointer.\n-        Rc { ptr: Shared::new((ptr as *const u8).offset(-offset_of!(RcBox<T>, value)) as *const _) }\n+\n+        let ptr = (ptr as *const u8).offset(-offset_of!(RcBox<T>, value));\n+        Rc {\n+            ptr: Shared::new(ptr as *mut u8 as *mut _)\n+        }\n     }\n }\n \n@@ -451,7 +455,7 @@ impl<T> Rc<[T]> {\n             // Free the original allocation without freeing its (moved) contents.\n             box_free(Box::into_raw(value));\n \n-            Rc { ptr: Shared::new(ptr as *const _) }\n+            Rc { ptr: Shared::new(ptr as *mut _) }\n         }\n     }\n }\n@@ -553,8 +557,9 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n-            let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-            Some(&mut inner.value)\n+            unsafe {\n+                Some(&mut this.ptr.as_mut().value)\n+            }\n         } else {\n             None\n         }\n@@ -578,9 +583,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const RcBox<T> = *this.ptr;\n-        let other_ptr: *const RcBox<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -623,7 +626,7 @@ impl<T: Clone> Rc<T> {\n         } else if Rc::weak_count(this) != 0 {\n             // Can just steal the data, all that's left is Weaks\n             unsafe {\n-                let mut swap = Rc::new(ptr::read(&(**this.ptr).value));\n+                let mut swap = Rc::new(ptr::read(&this.ptr.as_ref().value));\n                 mem::swap(this, &mut swap);\n                 swap.dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n@@ -637,8 +640,9 @@ impl<T: Clone> Rc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-        &mut inner.value\n+        unsafe {\n+            &mut this.ptr.as_mut().value\n+        }\n     }\n }\n \n@@ -683,12 +687,12 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_mut_ptr();\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_strong();\n             if self.strong() == 0 {\n                 // destroy the contained object\n-                ptr::drop_in_place(&mut (*ptr).value);\n+                ptr::drop_in_place(self.ptr.as_mut());\n \n                 // remove the implicit \"strong weak\" pointer now that we've\n                 // destroyed the contents.\n@@ -925,7 +929,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n \n@@ -1067,7 +1071,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self.ptr;\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n@@ -1175,12 +1179,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }\n@@ -1189,12 +1188,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }"}, {"sha": "321fa2edd56c7717e9bb2aaa243392d175b5feb1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -31,7 +31,6 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(heap_api)]\n #![feature(generic_param_attrs)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]\n@@ -48,7 +47,6 @@ use std::mem;\n use std::ptr;\n use std::slice;\n \n-use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n /// An arena that can hold objects of only one type.\n@@ -140,7 +138,7 @@ impl<T> TypedArena<T> {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n-                let ptr = heap::EMPTY as *mut T;\n+                let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n                 &mut *ptr"}, {"sha": "52cdd39d8f963c0666bcc26ba71765ad977c6917", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -152,12 +152,12 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new(*ptr as *mut LeafNode<K, V>) }\n+        BoxedNode { ptr: Unique::new(ptr.get() as *mut LeafNode<K, V>) }\n     }\n \n     fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n         unsafe {\n-            NonZero::new(*self.ptr as *const LeafNode<K, V>)\n+            NonZero::new(self.ptr.as_ptr())\n         }\n     }\n }\n@@ -241,7 +241,7 @@ impl<K, V> Root<K, V> {\n     pub fn pop_level(&mut self) {\n         debug_assert!(self.height > 0);\n \n-        let top = *self.node.ptr as *mut u8;\n+        let top = self.node.ptr.as_ptr() as *mut u8;\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(self.as_mut()\n@@ -308,15 +308,15 @@ unsafe impl<K: Send, V: Send, Type> Send\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n         unsafe {\n-            &*(*self.node as *const InternalNode<K, V>)\n+            &*(self.node.get() as *const InternalNode<K, V>)\n         }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut InternalNode<K, V>)\n+            &mut *(self.node.get() as *mut InternalNode<K, V>)\n         }\n     }\n }\n@@ -358,7 +358,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     fn as_leaf(&self) -> &LeafNode<K, V> {\n         unsafe {\n-            &**self.node\n+            &*self.node.get()\n         }\n     }\n \n@@ -510,7 +510,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut LeafNode<K, V>)\n+            &mut *(self.node.get() as *mut LeafNode<K, V>)\n         }\n     }\n \n@@ -1253,13 +1253,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<InternalNode<K, V>>(),\n                     mem::align_of::<InternalNode<K, V>>()\n                 );\n             } else {\n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<LeafNode<K, V>>(),\n                     mem::align_of::<LeafNode<K, V>>()\n                 );"}, {"sha": "ae258083546f4fddcb52cbeb22920527de8f66a9", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -161,7 +161,7 @@ impl<T> LinkedList<T> {\n \n             match self.head {\n                 None => self.tail = node,\n-                Some(head) => (*head.as_mut_ptr()).prev = node,\n+                Some(mut head) => head.as_mut().prev = node,\n             }\n \n             self.head = node;\n@@ -173,12 +173,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n         self.head.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.head = node.next;\n \n             match self.head {\n                 None => self.tail = None,\n-                Some(head) => (*head.as_mut_ptr()).prev = None,\n+                Some(mut head) => head.as_mut().prev = None,\n             }\n \n             self.len -= 1;\n@@ -196,7 +196,7 @@ impl<T> LinkedList<T> {\n \n             match self.tail {\n                 None => self.head = node,\n-                Some(tail) => (*tail.as_mut_ptr()).next = node,\n+                Some(mut tail) => tail.as_mut().next = node,\n             }\n \n             self.tail = node;\n@@ -208,12 +208,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n         self.tail.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.tail = node.prev;\n \n             match self.tail {\n                 None => self.head = None,\n-                Some(tail) => (*tail.as_mut_ptr()).next = None,\n+                Some(mut tail) => tail.as_mut().next = None,\n             }\n \n             self.len -= 1;\n@@ -285,11 +285,11 @@ impl<T> LinkedList<T> {\n     pub fn append(&mut self, other: &mut Self) {\n         match self.tail {\n             None => mem::swap(self, other),\n-            Some(tail) => {\n-                if let Some(other_head) = other.head.take() {\n+            Some(mut tail) => {\n+                if let Some(mut other_head) = other.head.take() {\n                     unsafe {\n-                        (*tail.as_mut_ptr()).next = Some(other_head);\n-                        (*other_head.as_mut_ptr()).prev = Some(tail);\n+                        tail.as_mut().next = Some(other_head);\n+                        other_head.as_mut().prev = Some(tail);\n                     }\n \n                     self.tail = other.tail.take();\n@@ -477,7 +477,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        self.head.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.head.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n@@ -503,7 +505,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.head.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n@@ -523,7 +527,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.tail.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.tail.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -549,7 +555,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.tail.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.tail.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Adds an element first in the list.\n@@ -694,9 +702,9 @@ impl<T> LinkedList<T> {\n         let second_part_head;\n \n         unsafe {\n-            second_part_head = (*split_node.unwrap().as_mut_ptr()).next.take();\n-            if let Some(head) = second_part_head {\n-                (*head.as_mut_ptr()).prev = None;\n+            second_part_head = split_node.unwrap().as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n             }\n         }\n \n@@ -788,7 +796,8 @@ impl<'a, T> Iterator for Iter<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &node.element\n@@ -810,7 +819,8 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &node.element\n@@ -835,7 +845,8 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &mut node.element\n@@ -857,7 +868,8 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &mut node.element\n@@ -903,8 +915,8 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n             None => self.list.push_back(element),\n-            Some(head) => unsafe {\n-                let prev = match (**head).prev {\n+            Some(mut head) => unsafe {\n+                let mut prev = match head.as_ref().prev {\n                     None => return self.list.push_front(element),\n                     Some(prev) => prev,\n                 };\n@@ -915,8 +927,8 @@ impl<'a, T> IterMut<'a, T> {\n                     element: element,\n                 })));\n \n-                (*prev.as_mut_ptr()).next = node;\n-                (*head.as_mut_ptr()).prev = node;\n+                prev.as_mut().next = node;\n+                head.as_mut().prev = node;\n \n                 self.list.len += 1;\n             },\n@@ -948,7 +960,9 @@ impl<'a, T> IterMut<'a, T> {\n         if self.len == 0 {\n             None\n         } else {\n-            self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+            unsafe {\n+                self.head.as_mut().map(|node| &mut node.as_mut().element)\n+            }\n         }\n     }\n }\n@@ -1276,21 +1290,21 @@ mod tests {\n                     assert_eq!(0, list.len);\n                     return;\n                 }\n-                Some(node) => node_ptr = &**node,\n+                Some(node) => node_ptr = &*node.as_ptr(),\n             }\n             loop {\n                 match (last_ptr, node_ptr.prev) {\n                     (None, None) => {}\n                     (None, _) => panic!(\"prev link for head\"),\n                     (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, *pptr as *const Node<T>);\n+                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n                     }\n                     _ => panic!(\"prev link is none, not good\"),\n                 }\n                 match node_ptr.next {\n                     Some(next) => {\n                         last_ptr = Some(node_ptr);\n-                        node_ptr = &**next;\n+                        node_ptr = &*next.as_ptr();\n                         len += 1;\n                     }\n                     None => {"}, {"sha": "7ec5c29de6b4be49918d8bc5678f51a0ef665d29", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -67,7 +67,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n-use alloc::heap::EMPTY;\n use alloc::raw_vec::RawVec;\n use borrow::ToOwned;\n use borrow::Cow;\n@@ -1776,9 +1775,9 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n         // A common case is passing a vector into a function which immediately\n         // re-collects into a vector. We can short circuit this if the IntoIter\n         // has not been advanced at all.\n-        if *iterator.buf == iterator.ptr as *mut T {\n+        if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n             unsafe {\n-                let vec = Vec::from_raw_parts(*iterator.buf as *mut T,\n+                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(),\n                                               iterator.len(),\n                                               iterator.cap);\n                 mem::forget(iterator);\n@@ -2192,7 +2191,8 @@ impl<T> Iterator for IntoIter<T> {\n                     self.ptr = arith_offset(self.ptr as *const i8, 1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.ptr might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -2231,7 +2231,8 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n                     self.end = arith_offset(self.end as *const i8, -1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.end might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n \n@@ -2269,7 +2270,7 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n         for _x in self.by_ref() {}\n \n         // RawVec handles deallocation\n-        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_mut_ptr(), self.cap) };\n+        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n     }\n }\n \n@@ -2334,7 +2335,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_vec = &mut *self.vec.as_mut_ptr();\n+                let source_vec = self.vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n@@ -2456,8 +2457,7 @@ impl<'a, I: Iterator> Drop for Splice<'a, I> {\n \n         unsafe {\n             if self.drain.tail_len == 0 {\n-                let vec = &mut *self.drain.vec.as_mut_ptr();\n-                vec.extend(self.replace_with.by_ref());\n+                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                 return\n             }\n \n@@ -2498,7 +2498,7 @@ impl<'a, T> Drain<'a, T> {\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n     /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let range_start = vec.len;\n         let range_end = self.tail_start;\n         let range_slice = slice::from_raw_parts_mut(\n@@ -2518,7 +2518,7 @@ impl<'a, T> Drain<'a, T> {\n \n     /// Make room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;\n         vec.buf.reserve(used_capacity, extra_capacity);\n "}, {"sha": "e826c9432b516133663c57c94a5624d7bd41fb0f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -2160,7 +2160,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n \n-        let source_deque = unsafe { &mut *self.deque.as_mut_ptr() };\n+        let source_deque = unsafe { self.deque.as_mut() };\n \n         // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n         //"}, {"sha": "7886f90b66e85b64baa56590c174d0ba199fb8f0", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -132,7 +132,6 @@\n //! use std::cell::Cell;\n //! use std::ptr::Shared;\n //! use std::intrinsics::abort;\n-//! use std::intrinsics::assume;\n //!\n //! struct Rc<T: ?Sized> {\n //!     ptr: Shared<RcBox<T>>\n@@ -171,8 +170,7 @@\n //! impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n //!    fn inner(&self) -> &RcBox<T> {\n //!        unsafe {\n-//!            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-//!            &(**self.ptr)\n+//!            self.ptr.as_ref()\n //!        }\n //!    }\n //! }"}, {"sha": "d93085e96dbb2833910a6df764430669bc8a40d1", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -13,7 +13,7 @@\n             reason = \"needs an RFC to flesh out the design\",\n             issue = \"27730\")]\n \n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -46,15 +46,10 @@ impl<T: Zeroable> NonZero<T> {\n     pub const unsafe fn new(inner: T) -> NonZero<T> {\n         NonZero(inner)\n     }\n-}\n-\n-impl<T: Zeroable> Deref for NonZero<T> {\n-    type Target = T;\n \n-    #[inline]\n-    fn deref(&self) -> &T {\n-        let NonZero(ref inner) = *self;\n-        inner\n+    /// Gets the inner value.\n+    pub fn get(self) -> T {\n+        self.0\n     }\n }\n "}, {"sha": "a60abefc076504027bdc99141b9add789bda7060", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 127, "deletions": 44, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -17,7 +17,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n@@ -957,13 +957,25 @@ impl<T: ?Sized> PartialOrd for *mut T {\n }\n \n /// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n-/// of this wrapper owns the referent. This in turn implies that the\n-/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a raw\n-/// `*mut T` (which conveys no particular ownership semantics).  It\n-/// also implies that the referent of the pointer should not be\n-/// modified without a unique path to the `Unique` reference. Useful\n-/// for building abstractions like `Vec<T>` or `Box<T>`, which\n-/// internally use raw pointers to manage the memory that they own.\n+/// of this wrapper owns the referent. Useful for building abstractions like\n+/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n+///\n+/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n+/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n+/// the kind of strong aliasing guarantees an instance of `T` can expect:\n+/// the referent of the pointer should not be modified without a unique path to\n+/// its owning Unique.\n+///\n+/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n+/// consider using `Shared`, which has weaker semantics.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n+/// for any type which upholds Unique's aliasing requirements.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -991,6 +1003,20 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"unique\", issue = \"27730\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: Sized> Unique<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Unique::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n@@ -1002,41 +1028,72 @@ impl<T: ?Sized> Unique<T> {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n     /// Dereferences the content.\n-    pub unsafe fn get(&self) -> &T {\n-        &**self.pointer\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n     }\n \n     /// Mutably dereferences the content.\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n-        &mut ***self\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"unique\", issue= \"27730\")]\n-impl<T:?Sized> Deref for Unique<T> {\n-    type Target = *mut T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*mut T {\n-        unsafe { mem::transmute(&*self.pointer) }\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Clone for Unique<T> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Copy for Unique<T> { }\n+\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Unique<T> {\n+impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n \n-/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n+/// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper has shared ownership of the referent. Useful for\n-/// building abstractions like `Rc<T>` or `Arc<T>`, which internally\n-/// use raw pointers to manage the memory that they own.\n+/// building abstractions like `Rc<T>`, `Arc<T>`, or doubly-linked lists, which\n+/// internally use aliased raw pointers to manage the memory that they own.\n+///\n+/// This is similar to `Unique`, except that it doesn't make any aliasing\n+/// guarantees, and doesn't derive Send and Sync. Note that unlike `&T`,\n+/// Shared has no special mutability requirements. Shared may mutate data\n+/// aliased by other Shared pointers. More precise rules require Rust to\n+/// develop an actual aliasing model.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Shared<T>>` has the same size as `Shared<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Shared<T>` is covariant over `T`. If this is incorrect\n+/// for your use case, you should include some PhantomData in your type to\n+/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n+/// Usually this won't be necessary; covariance is correct for Rc, Arc, and LinkedList\n+/// because they provide a public API that follows the normal shared XOR mutable\n+/// rules of Rust.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"shared\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -1060,23 +1117,59 @@ impl<T: ?Sized> !Send for Shared<T> { }\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> !Sync for Shared<T> { }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: Sized> Shared<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Shared::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> Shared<T> {\n     /// Creates a new `Shared`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub unsafe fn new(ptr: *const T) -> Self {\n+    pub unsafe fn new(ptr: *mut T) -> Self {\n         Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n-}\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Shared<T> {\n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr_mut()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+\n     /// Acquires the underlying pointer as a `*mut` pointer.\n+    #[rustc_deprecated(since = \"1.19\", reason = \"renamed to `as_ptr` for ergonomics/consistency\")]\n+    #[unstable(feature = \"shared\", issue = \"27730\")]\n     pub unsafe fn as_mut_ptr(&self) -> *mut T {\n-        **self as _\n+        self.as_ptr()\n     }\n }\n \n@@ -1094,18 +1187,8 @@ impl<T: ?Sized> Copy for Shared<T> { }\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Shared<U>> for Shared<T> where T: Unsize<U> { }\n \n #[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Deref for Shared<T> {\n-    type Target = *const T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*const T {\n-        unsafe { mem::transmute(&*self.pointer) }\n-    }\n-}\n-\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Shared<T> {\n+impl<T: ?Sized> fmt::Pointer for Shared<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }"}, {"sha": "588fffda35fca3dc20158d2b48dff128fcd21d2a", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -31,12 +31,12 @@ fn test_match_on_nonzero_option() {\n         NonZero::new(42)\n     });\n     match a {\n-        Some(val) => assert_eq!(*val, 42),\n+        Some(val) => assert_eq!(val.get(), 42),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n \n     match unsafe { Some(NonZero::new(43)) } {\n-        Some(val) => assert_eq!(*val, 43),\n+        Some(val) => assert_eq!(val.get(), 43),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n }"}, {"sha": "e28dc6a6881fde06acd2fc3a3b97269643b0b020", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -166,10 +166,10 @@ fn test_set_memory() {\n \n #[test]\n fn test_unsized_unique() {\n-    let xs: &mut [i32] = &mut [1, 2, 3];\n-    let ptr = unsafe { Unique::new(xs as *mut [i32]) };\n-    let ys = unsafe { &mut **ptr };\n-    let zs: &mut [i32] = &mut [1, 2, 3];\n+    let xs: &[i32] = &[1, 2, 3];\n+    let ptr = unsafe { Unique::new(xs as *const [i32] as *mut [i32]) };\n+    let ys = unsafe { ptr.as_ref() };\n+    let zs: &[i32] = &[1, 2, 3];\n     assert!(ys == zs);\n }\n "}, {"sha": "3619be82829cade3559577dd57a0f9fe71da2d52", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -62,14 +62,14 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(*self.ptr, self.len) }\n+        unsafe { slice::from_raw_parts(self.ptr.as_ptr(), self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n         unsafe {\n-            libc::free(*self.ptr as *mut _);\n+            libc::free(self.ptr.as_ptr() as *mut _);\n         }\n     }\n }"}, {"sha": "03562b0cb26a00f49d4eaf18ca3e49608110b0c8", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -1 +1 @@\n-Subproject commit c34a802d1eb037b44c5252078c7270b5472e0f65\n+Subproject commit 03562b0cb26a00f49d4eaf18ca3e49608110b0c8"}, {"sha": "12e0d4d3ea26cf6907a7d608098d34b4abb543e0", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -81,6 +81,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TransCrateItem(D),\n     TransInlinedItem(D),\n     TransWriteMetadata,\n+    CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n     // table in the tcx (or elsewhere) maps to one of these\n@@ -89,6 +90,8 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    ItemVarianceConstraints(D),\n+    ItemVariances(D),\n     IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n@@ -180,6 +183,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             AssociatedItems,\n             ItemSignature,\n+            ItemVariances,\n             IsForeignItem,\n             AssociatedItemDefIds,\n             InherentImpls,\n@@ -201,6 +205,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             MirKrate => Some(MirKrate),\n             TypeckBodiesKrate => Some(TypeckBodiesKrate),\n             Coherence => Some(Coherence),\n+            CrateVariances => Some(CrateVariances),\n             Resolve => Some(Resolve),\n             Variance => Some(Variance),\n             PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n@@ -232,6 +237,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            ItemVariances(ref d) => op(d).map(ItemVariances),\n+            ItemVarianceConstraints(ref d) => op(d).map(ItemVarianceConstraints),\n             IsForeignItem(ref d) => op(d).map(IsForeignItem),\n             TypeParamPredicates((ref item, ref param)) => {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))"}, {"sha": "809bed939f54ca4bcb78e102d33077f0ba4499f7", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -18,7 +18,6 @@ mod raii;\n mod safe;\n mod shadow;\n mod thread;\n-mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n@@ -28,5 +27,4 @@ pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "bf3748659fe07f0e4f4e84e8bb7ccb7782a85eb0", "filename": "src/librustc/dep_graph/visit.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f4209651ec4d4455dab4fc3f3a3456a897d9da7f/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4209651ec4d4455dab4fc3f3a3456a897d9da7f/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=f4209651ec4d4455dab4fc3f3a3456a897d9da7f", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir;\n-use hir::def_id::DefId;\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use ty::TyCtxt;\n-\n-use super::dep_node::DepNode;\n-\n-/// Visit all the items in the krate in some order. When visiting a\n-/// particular item, first create a dep-node by calling `dep_node_fn`\n-/// and push that onto the dep-graph stack of tasks, and also create a\n-/// read edge from the corresponding AST node. This is used in\n-/// compiler passes to automatically record the item that they are\n-/// working on.\n-pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                     mut dep_node_fn: F,\n-                                                     visitor: &mut V)\n-    where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n-{\n-    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: TyCtxt<'visit, 'tcx, 'tcx>,\n-        dep_node_fn: &'visit mut F,\n-        visitor: &'visit mut V,\n-    }\n-\n-    impl<'visit, 'tcx, F, V> ItemLikeVisitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n-    {\n-        fn visit_item(&mut self, i: &'tcx hir::Item) {\n-            let item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-            self.visitor.visit_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-\n-        fn visit_trait_item(&mut self, i: &'tcx hir::TraitItem) {\n-            let trait_item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(trait_item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(trait_item_def_id));\n-            self.visitor.visit_trait_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-\n-        fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n-            let impl_item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(impl_item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n-            self.visitor.visit_impl_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-    }\n-\n-    let krate = tcx.dep_graph.with_ignore(|| tcx.hir.krate());\n-    let mut tracking_visitor = TrackingVisitor {\n-        tcx: tcx,\n-        dep_node_fn: &mut dep_node_fn,\n-        visitor: visitor,\n-    };\n-    krate.visit_all_item_likes(&mut tracking_visitor)\n-}\n-"}, {"sha": "def6b2b3421f6f4135e0741b575506381f5a2e10", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -88,7 +88,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n     /// that are inside of an item-like.\n     ///\n     /// **This is the most common choice.** A very commmon pattern is\n-    /// to use `tcx.visit_all_item_likes_in_krate()` as an outer loop,\n+    /// to use `visit_all_item_likes()` as an outer loop,\n     /// and to have the visitor that visits the contents of each item\n     /// using this setting.\n     OnlyBodies(&'this Map<'tcx>),"}, {"sha": "ce1a34faf5ee8a850df8e9ec91ce463009c1c9ad", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -19,9 +19,8 @@ use super::intravisit::Visitor;\n ///\n /// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n ///    - Example: find all items with a `#[foo]` attribute on them.\n-///    - How: Implement `ItemLikeVisitor` and call `tcx.visit_all_item_likes_in_krate()`.\n+///    - How: Implement `ItemLikeVisitor` and call `tcx.hir.krate().visit_all_item_likes()`.\n ///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n-///    - Pro: Integrates well into dependency tracking.\n ///    - Con: Don't get information about nesting\n ///    - Con: Don't have methods for specific bits of HIR, like \"on\n ///      every expr, do this\".\n@@ -30,7 +29,7 @@ use super::intravisit::Visitor;\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n ///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.visit_all_item_likes_in_krate(visitor.as_deep_visitor())`. Within\n+///      `tcx.hir.krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n ///      your `intravisit::Visitor` impl, implement methods like\n ///      `visit_expr()`; don't forget to invoke\n ///      `intravisit::walk_visit_expr()` to keep walking the subparts."}, {"sha": "74aac7b788b26263580a72d2043dcfb098bf090c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -470,9 +470,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n-    /// True if the variance has been computed yet; false otherwise.\n-    pub variance_computed: Cell<bool>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -744,7 +741,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n-            variance_computed: Cell::new(false),\n             trait_map: resolutions.trait_map,\n             export_map: resolutions.export_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),"}, {"sha": "a737e7caa3e59dc7639d69b49ec702d2134530bc", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -266,6 +266,12 @@ impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the variances for items in this crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n         format!(\"generating MIR shim for `{}`\",\n@@ -549,18 +555,6 @@ macro_rules! define_map_struct {\n         }\n     };\n \n-    // Detect things with the `pub` modifier\n-    (tcx: $tcx:tt,\n-     input: (([pub $($other_modifiers:tt)*] $attrs:tt $name:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            ready: ([pub] $attrs $name),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n     // No modifiers left? This is a private item.\n     (tcx: $tcx:tt,\n      input: (([] $attrs:tt $name:tt) $($input:tt)*),\n@@ -687,9 +681,13 @@ define_maps! { <'tcx>\n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n+    /// Get a map with the variance of every item; use `item_variance`\n+    /// instead.\n+    [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+\n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [pub] variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+    [] variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n     [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n@@ -825,3 +823,7 @@ fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n     DepNode::MirKeys\n }\n+\n+fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::CrateVariances\n+}"}, {"sha": "a361c80a2529f34090920688e728b255a6ffb2da", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -15,7 +15,7 @@ pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n-use dep_graph::{self, DepNode};\n+use dep_graph::DepNode;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -55,9 +55,9 @@ use rustc_const_math::ConstInt;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n use hir;\n-use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{FnSig, PolyFnSig};\n@@ -309,6 +309,27 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n+/// The crate variances map is computed during typeck and contains the\n+/// variance of every item in the local crate. You should not use it\n+/// directly, because to do so will make your pass dependent on the\n+/// HIR of every item in the local crate. Instead, use\n+/// `tcx.variances_of()` to get the variance for a *particular*\n+/// item.\n+pub struct CrateVariancesMap {\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n+\n+    /// For each item with generics, maps to a vector of the variance\n+    /// of its generics.  If an item has no generics, it will have no\n+    /// entry.\n+    pub variances: FxHashMap<DefId, Rc<Vec<ty::Variance>>>,\n+\n+    /// An empty vector, useful for cloning.\n+    pub empty_variance: Rc<Vec<ty::Variance>>,\n+}\n+\n #[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n@@ -2543,14 +2564,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.node_extent(id)))\n     }\n \n-    pub fn visit_all_item_likes_in_krate<V,F>(self,\n-                                              dep_node_fn: F,\n-                                              visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'gcx>\n-    {\n-        dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "dfa11b9c71a04c6c038621d4dc63330310fa986b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -124,14 +124,8 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n            a_subst,\n            b_subst);\n \n-    let variances;\n-    let opt_variances = if relation.tcx().variance_computed.get() {\n-        variances = relation.tcx().variances_of(item_def_id);\n-        Some(&*variances)\n-    } else {\n-        None\n-    };\n-    relate_substs(relation, opt_variances, a_subst, b_subst)\n+    let opt_variances = relation.tcx().variances_of(item_def_id);\n+    relate_substs(relation, Some(&opt_variances), a_subst, b_subst)\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,"}, {"sha": "c9ffcee51c20ad1e346b54109a98949c174d8112", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n impl<'tcx> Kind<'tcx> {\n     #[inline]\n     unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.get();\n         if ptr & TAG_MASK == tag {\n             Some(&*((ptr & !TAG_MASK) as *const _))\n         } else {\n@@ -102,7 +102,7 @@ impl<'tcx> fmt::Debug for Kind<'tcx> {\n         } else if let Some(r) = self.as_region() {\n             write!(f, \"{:?}\", r)\n         } else {\n-            write!(f, \"<unknwon @ {:p}>\", *self.ptr as *const ())\n+            write!(f, \"<unknwon @ {:p}>\", self.ptr.get() as *const ())\n         }\n     }\n }"}, {"sha": "ed5e539f245f10fb2280d4821e8bf39f38166796", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -43,7 +43,7 @@ mod indexes {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n                 fn index(self) -> usize {\n-                    *self.0 - 1\n+                    self.0.get() - 1\n                 }\n             }\n "}, {"sha": "078bb801751d0b2bf4bd54d43a2c4f8944888ed1", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -255,7 +255,7 @@ impl<'a, A: Array> Drop for Drain<'a, A> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_array_vec = &mut *self.array_vec.as_mut_ptr();\n+                let source_array_vec = self.array_vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_array_vec.len();\n                 let tail = self.tail_start;"}, {"sha": "023c56ca59be8fcfd97e4b9fd31d9e4dcb07401e", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -23,6 +23,6 @@ impl NodeIndex {\n     }\n \n     pub fn get(self) -> usize {\n-        (*self.index - 1) as usize\n+        (self.index.get() - 1) as usize\n     }\n }"}, {"sha": "46463944043bd63c8d2c983246a919df159361c1", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -9,21 +9,23 @@\n // except according to those terms.\n \n use bitvec::BitMatrix;\n-use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use fx::FxHashMap;\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use std::cell::RefCell;\n use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem;\n \n \n-\n #[derive(Clone)]\n-pub struct TransitiveRelation<T: Debug + PartialEq> {\n-    // List of elements. This is used to map from a T to a usize.  We\n-    // expect domain to be small so just use a linear list versus a\n-    // hashmap or something.\n+pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash + Clone> {\n+    // List of elements. This is used to map from a T to a usize.\n     elements: Vec<T>,\n \n+    // Maps each element to an index.\n+    map: FxHashMap<T, Index>,\n+\n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n     edges: Vec<Edge>,\n@@ -40,19 +42,20 @@ pub struct TransitiveRelation<T: Debug + PartialEq> {\n     closure: RefCell<Option<BitMatrix>>,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n struct Edge {\n     source: Index,\n     target: Index,\n }\n \n-impl<T: Debug + PartialEq> TransitiveRelation<T> {\n+impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n     pub fn new() -> TransitiveRelation<T> {\n         TransitiveRelation {\n             elements: vec![],\n+            map: FxHashMap(),\n             edges: vec![],\n             closure: RefCell::new(None),\n         }\n@@ -63,29 +66,35 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n-        self.elements.iter().position(|e| *e == *a).map(Index)\n+        self.map.get(a).cloned()\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        match self.index(&a) {\n-            Some(i) => i,\n-            None => {\n-                self.elements.push(a);\n-\n-                // if we changed the dimensions, clear the cache\n-                *self.closure.borrow_mut() = None;\n-\n-                Index(self.elements.len() - 1)\n-            }\n-        }\n+        let &mut TransitiveRelation {\n+            ref mut elements,\n+            ref closure,\n+            ref mut map,\n+            ..\n+        } = self;\n+\n+        map.entry(a.clone())\n+           .or_insert_with(|| {\n+               elements.push(a);\n+\n+               // if we changed the dimensions, clear the cache\n+               *closure.borrow_mut() = None;\n+\n+               Index(elements.len() - 1)\n+           })\n+           .clone()\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n     /// relation.  If `f` returns `None` for any end-point, returns\n     /// `None`.\n     pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n         where F: FnMut(&T) -> Option<U>,\n-              U: Debug + PartialEq,\n+              U: Clone + Debug + Eq + Hash + Clone,\n     {\n         let mut result = TransitiveRelation::new();\n         for edge in &self.edges {\n@@ -125,6 +134,20 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n         }\n     }\n \n+    /// Returns a vector of all things less than `a`.\n+    ///\n+    /// Really this probably ought to be `impl Iterator<Item=&T>`, but\n+    /// I'm too lazy to make that work, and -- given the caching\n+    /// strategy -- it'd be a touch tricky anyhow.\n+    pub fn less_than(&self, a: &T) -> Vec<&T> {\n+        match self.index(a) {\n+            Some(a) => self.with_closure(|closure| {\n+                closure.iter(a.0).map(|i| &self.elements[i]).collect()\n+            }),\n+            None => vec![],\n+        }\n+    }\n+\n     /// Picks what I am referring to as the \"postdominating\"\n     /// upper-bound for `a` and `b`. This is usually the least upper\n     /// bound, but in cases where there is no single least upper\n@@ -335,7 +358,7 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n }\n \n impl<T> Encodable for TransitiveRelation<T>\n-    where T: Encodable + Debug + PartialEq\n+    where T: Clone + Encodable + Debug + Eq + Hash + Clone\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_struct(\"TransitiveRelation\", 2, |s| {\n@@ -347,19 +370,23 @@ impl<T> Encodable for TransitiveRelation<T>\n }\n \n impl<T> Decodable for TransitiveRelation<T>\n-    where T: Decodable + Debug + PartialEq\n+    where T: Clone + Decodable + Debug + Eq + Hash + Clone\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n         d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            let elements = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n+            let elements: Vec<T> = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n             let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n-            Ok(TransitiveRelation { elements, edges, closure: RefCell::new(None) })\n+            let map = elements.iter()\n+                              .enumerate()\n+                              .map(|(index, elem)| (elem.clone(), Index(index)))\n+                              .collect();\n+            Ok(TransitiveRelation { elements, edges, map, closure: RefCell::new(None) })\n         })\n     }\n }\n \n impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n-    where T: HashStable<CTX> + PartialEq + Debug\n+    where T: HashStable<CTX> + Eq + Debug + Clone + Hash\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut CTX,\n@@ -369,6 +396,8 @@ impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n         let TransitiveRelation {\n             ref elements,\n             ref edges,\n+            // \"map\" is just a copy of elements vec\n+            map: _,\n             // \"closure\" is just a copy of the data above\n             closure: _\n         } = *self;"}, {"sha": "7905128bb6eca4266c734c38a9762e2628edcd3d", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -51,7 +51,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::ich::{ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n use graphviz::IntoCow;\n use std::env;\n@@ -80,7 +80,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                                           if_this_changed: vec![],\n                                           then_this_would_need: vec![] };\n         visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n@@ -166,17 +166,29 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id, &item.attrs);\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.process_attrs(trait_item.id, &trait_item.attrs);\n+        intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.process_attrs(impl_item.id, &impl_item.attrs);\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.process_attrs(s.id, &s.attrs);\n+        intravisit::walk_struct_field(self, s);\n     }\n }\n "}, {"sha": "796cb8c4d651d08f02a107965013af44899af221", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -240,8 +240,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-    fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n-        debug!(\"EntryBuilder::encode_item_variances({:?})\", def_id);\n+    fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+        debug!(\"EntryBuilder::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy_seq_from_slice(&tcx.variances_of(def_id))\n     }\n@@ -824,7 +824,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => self.encode_item_variances(def_id),\n+                hir::ItemTrait(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {"}, {"sha": "c1456e7978280cce003fbe8e6f855a36600653f9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -293,6 +293,7 @@ pub fn provide(providers: &mut Providers) {\n     collect::provide(providers);\n     coherence::provide(providers);\n     check::provide(providers);\n+    variance::provide(providers);\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -307,9 +308,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     })?;\n \n-    time(time_passes, \"variance inference\", ||\n-         variance::infer_variance(tcx));\n-\n     tcx.sess.track_errors(|| {\n         time(time_passes, \"impl wf inference\", ||\n              impl_wf_check::impl_wf_check(tcx));\n@@ -320,6 +318,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n           coherence::check_coherence(tcx));\n     })?;\n \n+    tcx.sess.track_errors(|| {\n+        time(time_passes, \"variance testing\", ||\n+             variance::test::test_variance(tcx));\n+    })?;\n+\n     time(time_passes, \"wf checking\", || check::check_wf_new(tcx))?;\n \n     time(time_passes, \"item-types checking\", || check::check_item_types(tcx))?;"}, {"sha": "592916178897c8ab203ec2dd6f06f852f325e742", "filename": "src/librustc_typeck/variance/README.md", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -97,51 +97,29 @@ types involved before considering variance.\n \n #### Dependency graph management\n \n-Because variance works in two phases, if we are not careful, we wind\n-up with a muddled mess of a dep-graph. Basically, when gathering up\n-the constraints, things are fairly well-structured, but then we do a\n-fixed-point iteration and write the results back where they\n-belong. You can't give this fixed-point iteration a single task\n-because it reads from (and writes to) the variance of all types in the\n-crate. In principle, we *could* switch the \"current task\" in a very\n-fine-grained way while propagating constraints in the fixed-point\n-iteration and everything would be automatically tracked, but that\n-would add some overhead and isn't really necessary anyway.\n-\n-Instead what we do is to add edges into the dependency graph as we\n-construct the constraint set: so, if computing the constraints for\n-node `X` requires loading the inference variables from node `Y`, then\n-we can add an edge `Y -> X`, since the variance we ultimately infer\n-for `Y` will affect the variance we ultimately infer for `X`.\n-\n-At this point, we've basically mirrored the inference graph in the\n-dependency graph. This means we can just completely ignore the\n-fixed-point iteration, since it is just shuffling values along this\n-graph. In other words, if we added the fine-grained switching of tasks\n-I described earlier, all it would show is that we repeatedly read the\n-values described by the constraints, but those edges were already\n-added when building the constraints in the first place.\n-\n-Here is how this is implemented (at least as of the time of this\n-writing). The associated `DepNode` for the variance map is (at least\n-presently) `Signature(DefId)`. This means that, in `constraints.rs`,\n-when we visit an item to load up its constraints, we set\n-`Signature(DefId)` as the current task (the \"memoization\" pattern\n-described in the `dep-graph` README). Then whenever we find an\n-embedded type or trait, we add a synthetic read of `Signature(DefId)`,\n-which covers the variances we will compute for all of its\n-parameters. This read is synthetic (i.e., we call\n-`variance_map.read()`) because, in fact, the final variance is not yet\n-computed -- the read *will* occur (repeatedly) during the fixed-point\n-iteration phase.\n-\n-In fact, we don't really *need* this synthetic read. That's because we\n-do wind up looking up the `TypeScheme` or `TraitDef` for all\n-references types/traits, and those reads add an edge from\n-`Signature(DefId)` (that is, they share the same dep node as\n-variance). However, I've kept the synthetic reads in place anyway,\n-just for future-proofing (in case we change the dep-nodes in the\n-future), and because it makes the intention a bit clearer I think.\n+Because variance is a whole-crate inference, its dependency graph\n+can become quite muddled if we are not careful. To resolve this, we refactor\n+into two queries:\n+\n+- `crate_variances` computes the variance for all items in the current crate.\n+- `variances_of` accesses the variance for an individual reading; it\n+  works by requesting `crate_variances` and extracting the relevant data.\n+  \n+If you limit yourself to reading `variances_of`, your code will only\n+depend then on the inference inferred for that particular item.\n+\n+Eventually, the goal is to rely on the red-green dependency management\n+algorithm. At the moment, however, we rely instead on a hack, where\n+`variances_of` ignores the dependencies of accessing\n+`crate_variances` and instead computes the *correct* dependencies\n+itself. To this end, when we build up the constraints in the system,\n+we also built up a transitive `dependencies` relation as part of the\n+crate map. A `(X, Y)` pair is added to the map each time we have a\n+constraint that the variance of some inferred for the item `X` depends\n+on the variance of some element of `Y`. This is to some extent a\n+mirroring of the inference graph in the dependency graph. This means\n+we can just completely ignore the fixed-point iteration, since it is\n+just shuffling values along this graph.\n \n ### Addendum: Variance on traits\n "}, {"sha": "e986a381cd963df034968e27a66fa463c2a5c2e6", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 149, "deletions": 95, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -15,19 +15,20 @@\n \n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n+use rustc::dep_graph::{AssertDepGraphSafe, DepNode};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n use super::xform::*;\n \n-use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n-\n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,\n \n@@ -38,6 +39,11 @@ pub struct ConstraintContext<'a, 'tcx: 'a> {\n     bivariant: VarianceTermPtr<'a>,\n \n     pub constraints: Vec<Constraint<'a>>,\n+\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n@@ -48,6 +54,20 @@ pub struct Constraint<'a> {\n     pub variance: &'a VarianceTerm<'a>,\n }\n \n+/// To build constriants, we visit one item (type, trait) at a time\n+/// and look at its contents. So e.g. if we have\n+///\n+///     struct Foo<T> {\n+///         b: Bar<T>\n+///     }\n+///\n+/// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n+/// the def-id and generics of `Foo`.\n+pub struct CurrentItem<'a> {\n+    def_id: DefId,\n+    generics: &'a ty::Generics,\n+}\n+\n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n                                             -> ConstraintContext<'a, 'tcx> {\n     let tcx = terms_cx.tcx;\n@@ -62,50 +82,93 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n         invariant: invariant,\n         bivariant: bivariant,\n         constraints: Vec::new(),\n+        dependencies: TransitiveRelation::new(),\n     };\n \n-    // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(VarianceDepNode, &mut constraint_cx);\n+    tcx.hir.krate().visit_all_item_likes(&mut constraint_cx);\n \n     constraint_cx\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let tcx = self.terms_cx.tcx;\n-        let did = tcx.hir.local_def_id(item.id);\n+        let def_id = tcx.hir.local_def_id(item.id);\n+\n+        // Encapsulate constructing the constraints into a task we can\n+        // reference later. This can go away once the red-green\n+        // algorithm is in place.\n+        //\n+        // See README.md for a detailed discussion\n+        // on dep-graph management.\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => {\n+                tcx.dep_graph.with_task(DepNode::ItemVarianceConstraints(def_id),\n+                                        AssertDepGraphSafe(self),\n+                                        def_id,\n+                                        visit_item_task);\n+            }\n+            _ => {\n+                // Nothing to do here, skip the task.\n+            }\n+        }\n+\n+        fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n+                                     def_id: DefId)\n+        {\n+            ccx.0.build_constraints_for_item(def_id);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+/// Is `param_id` a lifetime according to `map`?\n+fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n+    match map.find(param_id) {\n+        Some(hir_map::NodeLifetime(..)) => true,\n+        _ => false,\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.terms_cx.tcx\n+    }\n \n+    fn build_constraints_for_item(&mut self, def_id: DefId) {\n+        let tcx = self.tcx();\n+        let id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+        let item = tcx.hir.expect_item(id);\n         debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n \n         match item.node {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let generics = tcx.generics_of(did);\n+                let generics = tcx.generics_of(def_id);\n+                let current_item = &CurrentItem { def_id, generics };\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.adt_def(did).all_fields() {\n-                    self.add_constraints_from_ty(generics,\n+                for field in tcx.adt_def(def_id).all_fields() {\n+                    self.add_constraints_from_ty(current_item,\n                                                  tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n-            hir::ItemTrait(..) => {\n-                let generics = tcx.generics_of(did);\n-                let trait_ref = ty::TraitRef {\n-                    def_id: did,\n-                    substs: Substs::identity_for_item(tcx, did)\n-                };\n-                self.add_constraints_from_trait_ref(generics,\n-                                                    trait_ref,\n-                                                    self.invariant);\n-            }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemStatic(..) |\n@@ -116,38 +179,25 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemGlobalAsm(..) |\n             hir::ItemTy(..) |\n             hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {}\n+            hir::ItemDefaultImpl(..) => {\n+                span_bug!(item.span, \"`build_constraints_for_item` invoked for non-type-def\");\n+            }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.terms_cx.tcx\n+    /// Load the generics for another item, adding a corresponding\n+    /// relation into the dependencies to indicate that the variance\n+    /// for `current` relies on `def_id`.\n+    fn read_generics(&mut self, current: &CurrentItem, def_id: DefId) -> &'tcx ty::Generics {\n+        let generics = self.tcx().generics_of(def_id);\n+        if self.tcx().dep_graph.is_fully_enabled() {\n+            self.dependencies.add(current.def_id, def_id);\n+        }\n+        generics\n     }\n \n-    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n-        match self.terms_cx.inferred_map.get(&param_id) {\n-            Some(&index) => index,\n-            None => {\n-                bug!(\"no inferred index entry for {}\",\n-                     self.tcx().hir.node_to_string(param_id));\n-            }\n-        }\n+    fn opt_inferred_index(&self, param_id: ast::NodeId) -> Option<&InferredIndex> {\n+        self.terms_cx.inferred_map.get(&param_id)\n     }\n \n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n@@ -228,8 +278,27 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n-            let InferredIndex(index) = self.inferred_index(param_node_id);\n-            self.terms_cx.inferred_infos[index].term\n+            if let Some(&InferredIndex(index)) = self.opt_inferred_index(param_node_id) {\n+                self.terms_cx.inferred_infos[index].term\n+            } else {\n+                // If there is no inferred entry for a type parameter,\n+                // it must be declared on a (locally defiend) trait -- they don't\n+                // get inferreds because they are always invariant.\n+                if cfg!(debug_assertions) {\n+                    let item_node_id = self.tcx().hir.as_local_node_id(item_def_id).unwrap();\n+                    let item = self.tcx().hir.expect_item(item_node_id);\n+                    let success = match item.node {\n+                        hir::ItemTrait(..) => true,\n+                        _ => false,\n+                    };\n+                    if !success {\n+                        bug!(\"parameter {:?} has no inferred, but declared on non-trait: {:?}\",\n+                             item_def_id,\n+                             item);\n+                    }\n+                }\n+                self.invariant\n+            }\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -279,7 +348,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     fn add_constraints_from_trait_ref(&mut self,\n-                                      generics: &ty::Generics,\n+                                      current: &CurrentItem,\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n@@ -288,12 +357,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-        // This edge is actually implied by the call to\n-        // `trait_def`, but I'm trying to be future-proof. See\n-        // README.md for a discussion on dep-graph management.\n-        self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n-        self.add_constraints_from_substs(generics,\n+        self.add_constraints_from_substs(current,\n                                          trait_ref.def_id,\n                                          &trait_generics.types,\n                                          &trait_generics.regions,\n@@ -305,7 +369,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n@@ -325,34 +389,29 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyRef(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, region, contra);\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_region(current, region, contra);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyArray(typ, _) |\n             ty::TySlice(typ) => {\n-                self.add_constraints_from_ty(generics, typ, variance);\n+                self.add_constraints_from_ty(current, typ, variance);\n             }\n \n             ty::TyRawPtr(ref mt) => {\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyTuple(subtys, _) => {\n                 for &subty in subtys {\n-                    self.add_constraints_from_ty(generics, subty, variance);\n+                    self.add_constraints_from_ty(current, subty, variance);\n                 }\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.tcx().generics_of(def.did);\n+                let adt_generics = self.read_generics(current, def.did);\n \n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(def.did));\n-\n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  def.did,\n                                                  &adt_generics.types,\n                                                  &adt_generics.regions,\n@@ -364,12 +423,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let trait_ref = &data.trait_ref;\n                 let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  trait_ref.def_id,\n                                                  &trait_generics.types,\n                                                  &trait_generics.regions,\n@@ -380,25 +434,25 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyDynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, r, contra);\n+                self.add_constraints_from_region(current, r, contra);\n \n                 if let Some(p) = data.principal() {\n                     let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n-                    self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                    self.add_constraints_from_trait_ref(current, poly_trait_ref.0, variance);\n                 }\n \n                 for projection in data.projection_bounds() {\n-                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n+                    self.add_constraints_from_ty(current, projection.0.ty, self.invariant);\n                 }\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(generics.parent, None);\n+                assert_eq!(current.generics.parent, None);\n                 let mut i = data.idx as usize;\n-                if !generics.has_self || i > 0 {\n-                    i -= generics.regions.len();\n+                if !current.generics.has_self || i > 0 {\n+                    i -= current.generics.regions.len();\n                 }\n-                let def_id = generics.types[i].def_id;\n+                let def_id = current.generics.types[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -414,7 +468,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyFnDef(.., sig) |\n             ty::TyFnPtr(sig) => {\n-                self.add_constraints_from_sig(generics, sig, variance);\n+                self.add_constraints_from_sig(current, sig, variance);\n             }\n \n             ty::TyError => {\n@@ -433,7 +487,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    def_id: DefId,\n                                    type_param_defs: &[ty::TypeParameterDef],\n                                    region_param_defs: &[ty::RegionParameterDef],\n@@ -451,44 +505,44 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            self.add_constraints_from_ty(generics, substs_ty, variance_i);\n+            self.add_constraints_from_ty(current, substs_ty, variance_i);\n         }\n \n         for p in region_param_defs {\n             let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n-            self.add_constraints_from_region(generics, substs_r, variance_i);\n+            self.add_constraints_from_region(current, substs_r, variance_i);\n         }\n     }\n \n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                generics: &ty::Generics,\n+                                current: &CurrentItem,\n                                 sig: ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.0.inputs() {\n-            self.add_constraints_from_ty(generics, input, contra);\n+            self.add_constraints_from_ty(current, input, contra);\n         }\n-        self.add_constraints_from_ty(generics, sig.0.output(), variance);\n+        self.add_constraints_from_ty(current, sig.0.output(), variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    region: ty::Region<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(generics.parent, None);\n-                let i = data.index as usize - generics.has_self as usize;\n-                let def_id = generics.regions[i].def_id;\n+                assert_eq!(current.generics.parent, None);\n+                let i = data.index as usize - current.generics.has_self as usize;\n+                let def_id = current.generics.regions[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n-                    let index = self.inferred_index(node_id);\n+                    let &index = self.opt_inferred_index(node_id).unwrap();\n                     self.add_constraint(index, variance);\n                 }\n             }\n@@ -518,17 +572,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             hir::MutMutable => {\n                 let invar = self.invariant(variance);\n-                self.add_constraints_from_ty(generics, mt.ty, invar);\n+                self.add_constraints_from_ty(current, mt.ty, invar);\n             }\n \n             hir::MutImmutable => {\n-                self.add_constraints_from_ty(generics, mt.ty, variance);\n+                self.add_constraints_from_ty(current, mt.ty, variance);\n             }\n         }\n     }"}, {"sha": "1afe2725ac87d6fabbebe93b5c58a73b5d17b344", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -12,7 +12,12 @@\n //! parameters. See README.md for details.\n \n use arena;\n-use rustc::ty::TyCtxt;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n+use rustc::ty::maps::Providers;\n+use std::rc::Rc;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -24,13 +29,67 @@ mod constraints;\n /// Code to solve constraints and write out the results.\n mod solve;\n \n+/// Code to write unit tests of variance.\n+pub mod test;\n+\n /// Code for transforming variances.\n mod xform;\n \n-pub fn infer_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        variances_of,\n+        crate_variances,\n+        ..*providers\n+    };\n+}\n+\n+fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n+                             -> Rc<CrateVariancesMap> {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n-    solve::solve_constraints(constraints_cx);\n-    tcx.variance_computed.set(true);\n+    Rc::new(solve::solve_constraints(constraints_cx))\n+}\n+\n+fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n+                            -> Rc<Vec<ty::Variance>> {\n+    let item_id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let item = tcx.hir.expect_item(item_id);\n+    match item.node {\n+        hir::ItemTrait(..) => {\n+            // Traits are always invariant.\n+            let generics = tcx.generics_of(item_def_id);\n+            assert!(generics.parent.is_none());\n+            Rc::new(vec![ty::Variance::Invariant; generics.count()])\n+        }\n+\n+        hir::ItemEnum(..) |\n+        hir::ItemStruct(..) |\n+        hir::ItemUnion(..) => {\n+            // Everything else must be inferred.\n+\n+            // Lacking red/green, we read the variances for all items here\n+            // but ignore the dependencies, then re-synthesize the ones we need.\n+            let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n+            tcx.dep_graph.read(DepNode::ItemVarianceConstraints(item_def_id));\n+            for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n+                if dep_def_id.is_local() {\n+                    tcx.dep_graph.read(DepNode::ItemVarianceConstraints(dep_def_id));\n+                } else {\n+                    tcx.dep_graph.read(DepNode::ItemVariances(dep_def_id));\n+                }\n+            }\n+\n+            crate_map.variances.get(&item_def_id)\n+                               .unwrap_or(&crate_map.empty_variance)\n+                               .clone()\n+        }\n+\n+        _ => {\n+            // Variance not relevant.\n+            span_bug!(item.span, \"asked to compute variance for wrong kind of item\")\n+        }\n+    }\n }\n+"}, {"sha": "af8ad491ec00e7075ba0a5c3e2a56922bdb30ef5", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -15,7 +15,9 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n+use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n \n use super::constraints::*;\n@@ -31,8 +33,8 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext) {\n-    let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n+pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n+    let ConstraintContext { terms_cx, dependencies, constraints, .. } = constraints_cx;\n \n     let solutions = terms_cx.inferred_infos\n         .iter()\n@@ -45,7 +47,10 @@ pub fn solve_constraints(constraints_cx: ConstraintContext) {\n         solutions: solutions,\n     };\n     solutions_cx.solve();\n-    solutions_cx.write();\n+    let variances = solutions_cx.create_map();\n+    let empty_variance = Rc::new(Vec::new());\n+\n+    ty::CrateVariancesMap { dependencies, variances, empty_variance }\n }\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n@@ -83,7 +88,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn write(&self) {\n+    fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n         // Collect all the variances for a particular item and stick\n         // them into the variance map. We rely on the fact that we\n         // generate all the inferreds for a particular item\n@@ -95,11 +100,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let tcx = self.terms_cx.tcx;\n \n-        // Ignore the writes here because the relevant edges were\n-        // already accounted for in `constraints.rs`. See the section\n-        // on dependency graph management in README.md for more\n-        // information.\n-        let _ignore = tcx.dep_graph.in_ignore();\n+        let mut map = FxHashMap();\n \n         let solutions = &self.solutions;\n         let inferred_infos = &self.terms_cx.inferred_infos;\n@@ -127,19 +128,10 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n             let item_def_id = tcx.hir.local_def_id(item_id);\n \n-            // For unit testing: check for a special \"rustc_variance\"\n-            // attribute and report an error with various results if found.\n-            if tcx.has_attr(item_def_id, \"rustc_variance\") {\n-                span_err!(tcx.sess,\n-                          tcx.hir.span(item_id),\n-                          E0208,\n-                          \"{:?}\",\n-                          item_variances);\n-            }\n-\n-            tcx.maps.variances_of.borrow_mut()\n-               .insert(item_def_id, Rc::new(item_variances));\n+            map.insert(item_def_id, Rc::new(item_variances));\n         }\n+\n+        map\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "ad787c57e76f2a60ee49739eef874e17c4ae5665", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -32,8 +32,6 @@ use self::VarianceTerm::*;\n \n pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n-use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n-\n #[derive(Copy, Clone, Debug)]\n pub struct InferredIndex(pub usize);\n \n@@ -109,7 +107,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(|def_id| VarianceDepNode(def_id), &mut terms_cx);\n+    tcx.hir.krate().visit_all_item_likes(&mut terms_cx);\n \n     terms_cx\n }\n@@ -139,7 +137,6 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferreds_for_item(&mut self,\n                               item_id: ast::NodeId,\n-                              has_self: bool,\n                               generics: &hir::Generics) {\n         //! Add \"inferreds\" for the generic parameters declared on this\n         //! item. This has a lot of annoying parameters because we are\n@@ -149,38 +146,17 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         //!\n \n         // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n-\n-        let inferreds_on_entry = self.num_inferred();\n-\n-        if has_self {\n-            self.add_inferred(item_id, 0, item_id);\n-        }\n+        // `CrateVariancesMap`, we rely on the fact that all inferreds\n+        // for a particular item are assigned continuous indices.\n \n-        for (i, p) in generics.lifetimes.iter().enumerate() {\n+        for (p, i) in generics.lifetimes.iter().zip(0..) {\n             let id = p.lifetime.id;\n-            let i = has_self as usize + i;\n             self.add_inferred(item_id, i, id);\n         }\n \n-        for (i, p) in generics.ty_params.iter().enumerate() {\n-            let i = has_self as usize + generics.lifetimes.len() + i;\n+        for (p, i) in generics.ty_params.iter().zip(generics.lifetimes.len()..) {\n             self.add_inferred(item_id, i, p.id);\n         }\n-\n-        // If this item has no type or lifetime parameters,\n-        // then there are no variances to infer, so just\n-        // insert an empty entry into the variance map.\n-        // Arguably we could just leave the map empty in this\n-        // case but it seems cleaner to be able to distinguish\n-        // \"invalid item id\" from \"item id with no\n-        // parameters\".\n-        if self.num_inferred() == inferreds_on_entry {\n-            let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            self.tcx.maps.variances_of.borrow_mut()\n-                .insert(item_def_id, self.empty_variances.clone());\n-        }\n     }\n \n     fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n@@ -232,15 +208,10 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemEnum(_, ref generics) |\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, false, generics);\n-            }\n-            hir::ItemTrait(_, ref generics, ..) => {\n-                // Note: all inputs for traits are ultimately\n-                // constrained to be invariant. See `visit_item` in\n-                // the impl for `ConstraintContext` in `constraints.rs`.\n-                self.add_inferreds_for_item(item.id, true, generics);\n+                self.add_inferreds_for_item(item.id, generics);\n             }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemDefaultImpl(..) |"}, {"sha": "1acadb7e772365efc7b1cfd7c380dcc202b6e48e", "filename": "src/librustc_typeck/variance/test.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ty::TyCtxt;\n+\n+pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.hir.krate().visit_all_item_likes(&mut VarianceTest { tcx });\n+}\n+\n+struct VarianceTest<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let item_def_id = self.tcx.hir.local_def_id(item.id);\n+\n+        // For unit testing: check for a special \"rustc_variance\"\n+        // attribute and report an error with various results if found.\n+        if self.tcx.has_attr(item_def_id, \"rustc_variance\") {\n+            let variances_of = self.tcx.variances_of(item_def_id);\n+            span_err!(self.tcx.sess,\n+                      item.span,\n+                      E0208,\n+                      \"{:?}\",\n+                      variances_of);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n+}"}, {"sha": "9e2d85163335c6f066a493070c8b53aa968e2ef0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -104,7 +104,8 @@ pub fn run_core(search_paths: SearchPaths,\n                 externs: config::Externs,\n                 input: Input,\n                 triple: Option<String>,\n-                maybe_sysroot: Option<PathBuf>) -> (clean::Crate, RenderInfo)\n+                maybe_sysroot: Option<PathBuf>,\n+                allow_warnings: bool) -> (clean::Crate, RenderInfo)\n {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -119,7 +120,7 @@ pub fn run_core(search_paths: SearchPaths,\n         maybe_sysroot: maybe_sysroot,\n         search_paths: search_paths,\n         crate_types: vec![config::CrateTypeRlib],\n-        lint_opts: vec![(warning_lint, lint::Allow)],\n+        lint_opts: if !allow_warnings { vec![(warning_lint, lint::Allow)] } else { vec![] },\n         lint_cap: Some(lint::Allow),\n         externs: externs,\n         target_triple: triple.unwrap_or(config::host_triple().to_string()),"}, {"sha": "d08a7bde71c73ae874480f87ccd8bb57145d5e33", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -137,7 +137,6 @@ r##\"<!DOCTYPE html>\n         window.rootPath = \"{root_path}\";\n         window.currentCrate = \"{krate}\";\n     </script>\n-    <script src=\"{root_path}jquery.js\"></script>\n     <script src=\"{root_path}main.js\"></script>\n     <script defer src=\"{root_path}search-index.js\"></script>\n </body>"}, {"sha": "fa9315054a11f7359f944fb6051639374463fffa", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -660,8 +660,6 @@ fn write_shared(cx: &Context,\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n-    write(cx.dst.join(\"jquery.js\"),\n-          include_bytes!(\"static/jquery-2.1.4.min.js\"))?;\n     write(cx.dst.join(\"main.js\"),\n           include_bytes!(\"static/main.js\"))?;\n     write(cx.dst.join(\"rustdoc.css\"),"}, {"sha": "c69861aa70a237dd77f6ff611a215080b596e2f5", "filename": "src/librustdoc/html/static/COPYRIGHT.txt", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -27,11 +27,6 @@ included, and carry their own copyright notices and license terms:\n     Licensed under the SIL Open Font License, Version 1.1.\n     See Heuristica-LICENSE.txt.\n \n-* jQuery (jquery-2.1.4.min.js):\n-\n-    Copyright 2005, 2015 jQuery Foundation, Inc.\n-    Licensed under the MIT license (see LICENSE-MIT.txt).\n-\n * rustdoc.css, main.js, and playpen.js:\n \n     Copyright 2015 The Rust Developers."}, {"sha": "49990d6e14503798f142dcb0d5b23cb0c8f80244", "filename": "src/librustdoc/html/static/jquery-2.1.4.min.js", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4209651ec4d4455dab4fc3f3a3456a897d9da7f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.1.4.min.js", "raw_url": "https://github.com/rust-lang/rust/raw/f4209651ec4d4455dab4fc3f3a3456a897d9da7f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.1.4.min.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.1.4.min.js?ref=f4209651ec4d4455dab4fc3f3a3456a897d9da7f", "patch": "@@ -1,4 +0,0 @@\n-/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */\n-!function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m=\"2.1.4\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return\"object\"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,\"isPrototypeOf\")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf(\"use strict\")?(b=l.createElement(\"script\"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=\"length\"in a&&a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",L=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",M=\"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",N=M.replace(\"w\",\"w#\"),O=\"\\\\[\"+L+\"*(\"+M+\")(?:\"+L+\"*([*^$|!~]?=)\"+L+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+N+\"))|)\"+L+\"*\\\\]\",P=\":(\"+M+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+O+\")*)|.*)\\\\)|)\",Q=new RegExp(L+\"+\",\"g\"),R=new RegExp(\"^\"+L+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+L+\"+$\",\"g\"),S=new RegExp(\"^\"+L+\"*,\"+L+\"*\"),T=new RegExp(\"^\"+L+\"*([>+~]|\"+L+\")\"+L+\"*\"),U=new RegExp(\"=\"+L+\"*([^\\\\]'\\\"]*?)\"+L+\"*\\\\]\",\"g\"),V=new RegExp(P),W=new RegExp(\"^\"+N+\"$\"),X={ID:new RegExp(\"^#(\"+M+\")\"),CLASS:new RegExp(\"^\\\\.(\"+M+\")\"),TAG:new RegExp(\"^(\"+M.replace(\"w\",\"w*\")+\")\"),ATTR:new RegExp(\"^\"+O),PSEUDO:new RegExp(\"^\"+P),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+L+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+L+\"*(?:([+-]|)\"+L+\"*(\\\\d+)|))\"+L+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+K+\")$\",\"i\"),needsContext:new RegExp(\"^\"+L+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+L+\"*((?:-\\\\d)?\\\\d*)\"+L+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\\d$/i,$=/^[^{]+\\{\\s*\\[native \\w/,_=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,aa=/[+~]/,ba=/'|\\\\/g,ca=new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+L+\"?|(\"+L+\")|.)\",\"ig\"),da=function(a,b,c){var d=\"0x\"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,\"string\"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&\"object\"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute(\"id\"))?s=r.replace(ba,\"\\\\$&\"):b.setAttribute(\"id\",s),s=\"[id='\"+s+\"'] \",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(\",\")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute(\"id\")}}}return i(a.replace(R,\"$1\"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+\" \")>d.cacheLength&&delete b[a.shift()],b[c+\" \"]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement(\"div\");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split(\"|\"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return\"input\"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return(\"input\"===c||\"button\"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&\"undefined\"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?\"HTML\"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener(\"unload\",ea,!1):e.attachEvent&&e.attachEvent(\"onunload\",ea)),p=!f(g),c.attributes=ja(function(a){return a.className=\"i\",!a.getAttribute(\"className\")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment(\"\")),!a.getElementsByTagName(\"*\").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(\"undefined\"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute(\"id\")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c=\"undefined\"!=typeof a.getAttributeNode&&a.getAttributeNode(\"id\");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return\"undefined\"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if(\"*\"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML=\"<a id='\"+u+\"'></a><select id='\"+u+\"-\\f]' msallowcapture=''><option selected=''></option></select>\",a.querySelectorAll(\"[msallowcapture^='']\").length&&q.push(\"[*^$]=\"+L+\"*(?:''|\\\"\\\")\"),a.querySelectorAll(\"[selected]\").length||q.push(\"\\\\[\"+L+\"*(?:value|\"+K+\")\"),a.querySelectorAll(\"[id~=\"+u+\"-]\").length||q.push(\"~=\"),a.querySelectorAll(\":checked\").length||q.push(\":checked\"),a.querySelectorAll(\"a#\"+u+\"+*\").length||q.push(\".#.+[+~]\")}),ja(function(a){var b=g.createElement(\"input\");b.setAttribute(\"type\",\"hidden\"),a.appendChild(b).setAttribute(\"name\",\"D\"),a.querySelectorAll(\"[name=d]\").length&&q.push(\"name\"+L+\"*[*^$|!~]?=\"),a.querySelectorAll(\":enabled\").length||q.push(\":enabled\",\":disabled\"),a.querySelectorAll(\"*,:x\"),q.push(\",.*:\")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,\"div\"),s.call(a,\"[s!='']:x\"),r.push(\"!=\",P)}),q=q.length&&new RegExp(q.join(\"|\")),r=r.length&&new RegExp(r.join(\"|\")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,\"='$1']\"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c=\"\",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if(\"string\"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||\"\").replace(ca,da),\"~=\"===a[2]&&(a[3]=\" \"+a[3]+\" \"),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),\"nth\"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*(\"even\"===a[3]||\"odd\"===a[3])),a[5]=+(a[7]+a[8]||\"odd\"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||\"\":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(\")\",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return\"*\"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+\" \"];return b||(b=new RegExp(\"(^|\"+L+\")\"+a+\"(\"+L+\"|$)\"))&&y(a,function(a){return b.test(\"string\"==typeof a.className&&a.className||\"undefined\"!=typeof a.getAttribute&&a.getAttribute(\"class\")||\"\")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?\"!=\"===b:b?(e+=\"\",\"=\"===b?e===c:\"!=\"===b?e!==c:\"^=\"===b?c&&0===e.indexOf(c):\"*=\"===b?c&&e.indexOf(c)>-1:\"$=\"===b?c&&e.slice(-c.length)===c:\"~=\"===b?(\" \"+e.replace(Q,\" \")+\" \").indexOf(c)>-1:\"|=\"===b?e===c||e.slice(0,c.length+1)===c+\"-\":!1):!0}},CHILD:function(a,b,c,d,e){var f=\"nth\"!==a.slice(0,3),g=\"last\"!==a.slice(-4),h=\"of-type\"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?\"nextSibling\":\"previousSibling\",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p=\"only\"===a&&!o&&\"nextSibling\"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error(\"unsupported pseudo: \"+a);return e[u]?e(b):e.length>1?(c=[a,a,\"\",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,\"$1\"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||\"\")||ga.error(\"unsupported lang: \"+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute(\"xml:lang\")||b.getAttribute(\"lang\"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+\"-\");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&!!a.checked||\"option\"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&\"button\"===a.type||\"button\"===b},text:function(a){var b;return\"input\"===a.nodeName.toLowerCase()&&\"text\"===a.type&&(null==(b=a.getAttribute(\"type\"))||\"text\"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+\" \"];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R,\" \")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d=\"\";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&\"parentNode\"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||\"*\",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[\" \"],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:\" \"===a[i-2].type?\"*\":\"\"})).replace(R,\"$1\"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q=\"0\",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG(\"*\",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+\" \"];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n=\"function\"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&\"ID\"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split(\"\").sort(B).join(\"\")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement(\"div\"))}),ja(function(a){return a.innerHTML=\"<a href='#'></a>\",\"#\"===a.firstChild.getAttribute(\"href\")})||ka(\"type|href|height|width\",function(a,b,c){return c?void 0:a.getAttribute(b,\"type\"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML=\"<input/>\",a.firstChild.setAttribute(\"value\",\"\"),\"\"===a.firstChild.getAttribute(\"value\")})||ka(\"value\",function(a,b,c){return c||\"input\"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute(\"disabled\")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[\":\"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,w=/^.[^:#\\[\\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if(\"string\"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=\":not(\"+a+\")\"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if(\"string\"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+\" \"+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,\"string\"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if(\"string\"==typeof a){if(c=\"<\"===a[0]&&\">\"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?\"undefined\"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||\"string\"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?\"string\"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,\"parentNode\")},parentsUntil:function(a,b,c){return n.dir(a,\"parentNode\",c)},next:function(a){return D(a,\"nextSibling\")},prev:function(a){return D(a,\"previousSibling\")},nextAll:function(a){return n.dir(a,\"nextSibling\")},prevAll:function(a){return n.dir(a,\"previousSibling\")},nextUntil:function(a,b,c){return n.dir(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return n.dir(a,\"previousSibling\",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return\"Until\"!==a.slice(-5)&&(d=c),d&&\"string\"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a=\"string\"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);\"function\"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&\"string\"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[[\"resolve\",\"done\",n.Callbacks(\"once memory\"),\"resolved\"],[\"reject\",\"fail\",n.Callbacks(\"once memory\"),\"rejected\"],[\"notify\",\"progress\",n.Callbacks(\"memory\")]],c=\"pending\",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+\"With\"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+\"With\"](this===e?d:this,arguments),this},e[f[0]+\"With\"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler(\"ready\"),n(l).off(\"ready\"))))}});function I(){l.removeEventListener(\"DOMContentLoaded\",I,!1),a.removeEventListener(\"load\",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),\"complete\"===l.readyState?setTimeout(n.ready):(l.addEventListener(\"DOMContentLoaded\",I,!1),a.addEventListener(\"load\",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if(\"object\"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if(\"string\"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&\"string\"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d=\"data-\"+b.replace(O,\"-$1\").toLowerCase(),c=a.getAttribute(d),\"string\"==typeof c){try{c=\"true\"===c?!0:\"false\"===c?!1:\"null\"===c?null:+c+\"\"===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){\n-return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,\"hasDataAttrs\"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf(\"data-\")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,\"hasDataAttrs\",!0)}return e}return\"object\"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf(\"-\")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||\"fx\")+\"queue\",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||\"fx\";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};\"inprogress\"===e&&(e=c.shift(),d--),e&&(\"fx\"===b&&c.unshift(\"inprogress\"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+\"queueHooks\";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks(\"once memory\").add(function(){L.remove(a,[b+\"queue\",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return\"string\"!=typeof a&&(b=a,a=\"fx\",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),\"fx\"===a&&\"inprogress\"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};\"string\"!=typeof a&&(b=a,a=void 0),a=a||\"fx\";while(g--)c=L.get(f[g],a+\"queueHooks\"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,R=[\"Top\",\"Right\",\"Bottom\",\"Left\"],S=function(a,b){return a=b||a,\"none\"===n.css(a,\"display\")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement(\"div\")),c=l.createElement(\"input\");c.setAttribute(\"type\",\"radio\"),c.setAttribute(\"checked\",\"checked\"),c.setAttribute(\"name\",\"t\"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML=\"<textarea>x</textarea>\",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U=\"undefined\";k.focusinBubbles=\"onfocusin\"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||\"\").match(E)||[\"\"],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||\"\").split(\".\").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(\".\")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||\"\").match(E)||[\"\"],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||\"\").split(\".\").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp(\"(^|\\\\.)\"+p.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&(\"**\"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,\"events\"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,\"type\")?b.type:b,r=j.call(b,\"namespace\")?b.namespace.split(\".\"):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(\".\")>=0&&(r=q.split(\".\"),q=r.shift(),r.sort()),k=q.indexOf(\":\")<0&&\"on\"+q,b=b[n.expando]?b:new n.Event(q,\"object\"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join(\".\"),b.namespace_re=b.namespace?new RegExp(\"(^|\\\\.)\"+r.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,\"events\")||{})[b.type]&&L.get(g,\"handle\"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,\"events\")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||\"click\"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||\"click\"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+\" \",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:\"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:\"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:\"focusin\"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:\"focusout\"},click:{trigger:function(){return\"checkbox\"===this.type&&this.click&&n.nodeName(this,\"input\")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,\"a\")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if(\"object\"==typeof a){\"string\"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&(\"string\"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+\".\"+d.namespace:d.origType,d.selector,d.handler),this;if(\"object\"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||\"function\"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,ba=/<([\\w:]+)/,ca=/<|&#?\\w+;/,da=/<(?:script|style|link)/i,ea=/checked\\s*(?:[^=]|=\\s*.checked.)/i,fa=/^$|\\/(?:java|ecma)script/i,ga=/^true\\/(.*)/,ha=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,ia={option:[1,\"<select multiple='multiple'>\",\"</select>\"],thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,\"table\")&&n.nodeName(11!==b.nodeType?b:b.firstChild,\"tr\")?a.getElementsByTagName(\"tbody\")[0]||a.appendChild(a.ownerDocument.createElement(\"tbody\")):a}function ka(a){return a.type=(null!==a.getAttribute(\"type\"))+\"/\"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute(\"type\"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],\"globalEval\",!b||L.get(b[c],\"globalEval\"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||\"*\"):a.querySelectorAll?a.querySelectorAll(b||\"*\"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();\"input\"===c&&T.test(a.type)?b.checked=a.checked:(\"input\"===c||\"textarea\"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,\"script\"),g.length>0&&ma(g,!i&&oa(a,\"script\")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if(\"object\"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement(\"div\")),g=(ba.exec(e)||[\"\",\"\"])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,\"<$1></$2>\")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=\"\"}else l.push(b.createTextNode(e));k.textContent=\"\",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),\"script\"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||\"\")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,\"script\")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent=\"\");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if(\"string\"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(aa,\"<$1></$2>\");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&\"string\"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,\"script\"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,\"script\"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||\"\")&&!L.access(h,\"globalEval\")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,\"\")))}return this}}),n.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],\"display\");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),\"none\"!==c&&c||(qa=(qa||n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp(\"^(\"+Q+\")(?!px)[a-z%]+$\",\"i\"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(\"\"!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+\"\":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement(\"div\"),f=l.createElement(\"div\");if(f.style){f.style.backgroundClip=\"content-box\",f.cloneNode(!0).style.backgroundClip=\"\",k.clearCloneStyle=\"content-box\"===f.style.backgroundClip,e.style.cssText=\"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute\",e.appendChild(f);function g(){f.style.cssText=\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute\",f.innerHTML=\"\",d.appendChild(e);var g=a.getComputedStyle(f,null);b=\"1%\"!==g.top,c=\"4px\"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement(\"div\"));return c.style.cssText=f.style.cssText=\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\",c.style.marginRight=c.style.width=\"0\",f.style.width=\"1px\",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp(\"^(\"+Q+\")(.*)$\",\"i\"),Ba=new RegExp(\"^([+-])=(\"+Q+\")\",\"i\"),Ca={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Da={letterSpacing:\"0\",fontWeight:\"400\"},Ea=[\"Webkit\",\"O\",\"Moz\",\"ms\"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||\"px\"):b}function Ha(a,b,c,d,e){for(var f=c===(d?\"border\":\"content\")?4:\"width\"===b?1:0,g=0;4>f;f+=2)\"margin\"===c&&(g+=n.css(a,c+R[f],!0,e)),d?(\"content\"===c&&(g-=n.css(a,\"padding\"+R[f],!0,e)),\"margin\"!==c&&(g-=n.css(a,\"border\"+R[f]+\"Width\",!0,e))):(g+=n.css(a,\"padding\"+R[f],!0,e),\"padding\"!==c&&(g+=n.css(a,\"border\"+R[f]+\"Width\",!0,e)));return g}function Ia(a,b,c){var d=!0,e=\"width\"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g=\"border-box\"===n.css(a,\"boxSizing\",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?\"border\":\"content\"),d,f)+\"px\"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,\"olddisplay\"),c=d.style.display,b?(f[g]||\"none\"!==c||(d.style.display=\"\"),\"\"===d.style.display&&S(d)&&(f[g]=L.access(d,\"olddisplay\",ta(d.nodeName)))):(e=S(d),\"none\"===c&&e||L.set(d,\"olddisplay\",e?c:n.css(d,\"display\"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&\"none\"!==d.style.display&&\"\"!==d.style.display||(d.style.display=b?f[g]||\"\":\"none\"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,\"opacity\");return\"\"===c?\"1\":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":\"cssFloat\"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&\"get\"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,\"string\"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f=\"number\"),null!=c&&c===c&&(\"number\"!==f||n.cssNumber[h]||(c+=\"px\"),k.clearCloneStyle||\"\"!==c||0!==b.indexOf(\"background\")||(i[b]=\"inherit\"),g&&\"set\"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&\"get\"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),\"normal\"===e&&b in Da&&(e=Da[b]),\"\"===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each([\"height\",\"width\"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,\"display\"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,\"border-box\"===n.css(a,\"boxSizing\",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:\"inline-block\"},xa,[a,\"marginRight\"]):void 0}),n.each({margin:\"\",padding:\"\",border:\"Width\"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f=\"string\"==typeof c?c.split(\" \"):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return\"boolean\"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||\"swing\",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?\"\":\"px\")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,\"\"),b&&\"auto\"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp(\"^(?:([+-])=|)(\"+Q+\")([a-z%]*)$\",\"i\"),Pa=/queueHooks$/,Qa=[Va],Ra={\"*\":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?\"\":\"px\"),g=(n.cssNumber[a]||\"px\"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||\".5\",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e[\"margin\"+c]=e[\"padding\"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra[\"*\"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,\"fxshow\");c.queue||(h=n._queueHooks(a,\"fx\"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,\"fx\").length||h.empty.fire()})})),1===a.nodeType&&(\"height\"in b||\"width\"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,\"display\"),k=\"none\"===j?L.get(a,\"olddisplay\")||ta(a.nodeName):j,\"inline\"===k&&\"none\"===n.css(a,\"float\")&&(o.display=\"inline-block\")),c.overflow&&(o.overflow=\"hidden\",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||\"toggle\"===e,e===(p?\"hide\":\"show\")){if(\"show\"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))\"inline\"===(\"none\"===j?ta(a.nodeName):j)&&(o.display=j);else{q?\"hidden\"in q&&(p=q.hidden):q=L.access(a,\"fxshow\",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,\"fxshow\");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start=\"width\"===d||\"height\"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&\"expand\"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=[\"*\"]):a=a.split(\" \");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&\"object\"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:\"number\"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue=\"fx\"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,\"finish\"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return\"string\"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||\"fx\",[]),this.each(function(){var b=!0,e=null!=a&&a+\"queueHooks\",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||\"fx\"),this.each(function(){var b,c=L.get(this),d=c[a+\"queue\"],e=c[a+\"queueHooks\"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each([\"toggle\",\"show\",\"hide\"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||\"boolean\"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta(\"show\"),slideUp:Ta(\"hide\"),slideToggle:Ta(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||\"fx\",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement(\"input\"),b=l.createElement(\"select\"),c=b.appendChild(l.createElement(\"option\"));a.type=\"checkbox\",k.checkOn=\"\"!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement(\"input\"),a.value=\"t\",a.type=\"radio\",k.radioValue=\"t\"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),\n-void 0===c?d&&\"get\"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&\"set\"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+\"\"),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&\"radio\"===b&&n.nodeName(a,\"input\")){var c=a.value;return a.setAttribute(\"type\",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{\"for\":\"htmlFor\",\"class\":\"className\"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&\"set\"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&\"get\"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute(\"tabindex\")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\\t\\r\\n\\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=\"string\"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||\"\").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(ab,\" \"):\" \")){f=0;while(e=b[f++])d.indexOf(\" \"+e+\" \")<0&&(d+=e+\" \");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||\"string\"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||\"\").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(ab,\" \"):\"\")){f=0;while(e=b[f++])while(d.indexOf(\" \"+e+\" \")>=0)d=d.replace(\" \"+e+\" \",\" \");g=a?n.trim(d):\"\",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return\"boolean\"==typeof b&&\"string\"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if(\"string\"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||\"boolean\"===c)&&(this.className&&L.set(this,\"__className__\",this.className),this.className=this.className||a===!1?\"\":L.get(this,\"__className__\")||\"\")})},hasClass:function(a){for(var b=\" \"+a+\" \",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(\" \"+this[c].className+\" \").replace(ab,\" \").indexOf(b)>=0)return!0;return!1}});var bb=/\\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e=\"\":\"number\"==typeof e?e+=\"\":n.isArray(e)&&(e=n.map(e,function(a){return null==a?\"\":a+\"\"})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&\"set\"in b&&void 0!==b.set(this,e,\"value\")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&\"get\"in b&&void 0!==(c=b.get(e,\"value\"))?c:(c=e.value,\"string\"==typeof c?c.replace(bb,\"\"):null==c?\"\":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,\"value\");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f=\"select-one\"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute(\"disabled\"))||c.parentNode.disabled&&n.nodeName(c.parentNode,\"optgroup\"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each([\"radio\",\"checkbox\"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute(\"value\")?\"on\":a.value})}),n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,\"**\"):this.off(b,a||\"**\",c)}});var cb=n.now(),db=/\\?/;n.parseJSON=function(a){return JSON.parse(a+\"\")},n.parseXML=function(a){var b,c;if(!a||\"string\"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,\"text/xml\")}catch(d){b=void 0}return(!b||b.getElementsByTagName(\"parsererror\").length)&&n.error(\"Invalid XML: \"+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\\/\\//,kb=/^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,lb={},mb={},nb=\"*/\".concat(\"*\"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){\"string\"!=typeof b&&(c=b,b=\"*\");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])\"+\"===d[0]?(d=d.slice(1)||\"*\",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return\"string\"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e[\"*\"]&&g(\"*\")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while(\"*\"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader(\"Content-Type\"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+\" \"+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if(\"*\"===f)f=i;else if(\"*\"!==i&&i!==f){if(g=j[i+\" \"+f]||j[\"* \"+f],!g)for(e in j)if(h=e.split(\" \"),h[1]===f&&(g=j[i+\" \"+h[0]]||j[\"* \"+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a[\"throws\"])b=g(b);else try{b=g(b)}catch(l){return{state:\"parsererror\",error:g?l:\"No conversion from \"+i+\" to \"+f}}}return{state:\"success\",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:\"GET\",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":nb,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":n.parseJSON,\"text xml\":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){\"object\"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks(\"once memory\"),q=k.statusCode||{},r={},s={},t=0,u=\"canceled\",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+\"\").replace(eb,\"\").replace(jb,pb[1]+\"//\"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||\"*\").toLowerCase().match(E)||[\"\"],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||(\"http:\"===h[1]?\"80\":\"443\"))===(pb[3]||(\"http:\"===pb[1]?\"80\":\"443\")))),k.data&&k.processData&&\"string\"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger(\"ajaxStart\"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?\"&\":\"?\")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,\"$1_=\"+cb++):d+(db.test(d)?\"&\":\"?\")+\"_=\"+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader(\"If-Modified-Since\",n.lastModified[d]),n.etag[d]&&v.setRequestHeader(\"If-None-Match\",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader(\"Content-Type\",k.contentType),v.setRequestHeader(\"Accept\",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+(\"*\"!==k.dataTypes[0]?\", \"+nb+\"; q=0.01\":\"\"):k.accepts[\"*\"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u=\"abort\";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger(\"ajaxSend\",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort(\"timeout\")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,\"No Transport\");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||\"\",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader(\"Last-Modified\"),w&&(n.lastModified[d]=w),w=v.getResponseHeader(\"etag\"),w&&(n.etag[d]=w)),204===a||\"HEAD\"===k.type?x=\"nocontent\":304===a?x=\"notmodified\":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x=\"error\",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+\"\",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?\"ajaxSuccess\":\"ajaxError\",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger(\"ajaxComplete\",[v,k]),--n.active||n.event.trigger(\"ajaxStop\")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,\"json\")},getScript:function(a,b){return n.get(a,void 0,b,\"script\")}}),n.each([\"get\",\"post\"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:\"GET\",dataType:\"script\",async:!1,global:!1,\"throws\":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,\"body\")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\\[\\]$/,xb=/\\r?\\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+\"[\"+(\"object\"==typeof e?b:\"\")+\"]\",e,c,d)});else if(c||\"object\"!==n.type(b))d(a,b);else for(e in b)Ab(a+\"[\"+e+\"]\",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?\"\":b,d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join(\"&\").replace(vb,\"+\")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,\"elements\");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(\":disabled\")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,\"\\r\\n\")}}):{name:b.name,value:c.replace(xb,\"\\r\\n\")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent(\"onunload\",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&\"withCredentials\"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c[\"X-Requested-With\"]||(c[\"X-Requested-With\"]=\"XMLHttpRequest\");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,\"abort\"===a?f.abort():\"error\"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,\"string\"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b(\"error\"),b=Cb[g]=b(\"abort\");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/(?:java|ecma)script/},converters:{\"text script\":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter(\"script\",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\")}),n.ajaxTransport(\"script\",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n(\"<script>\").prop({async:!0,charset:a.scriptCharset,src:a.url}).on(\"load error\",c=function(a){b.remove(),c=null,a&&e(\"error\"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var a=Fb.pop()||n.expando+\"_\"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?\"url\":\"string\"==typeof b.data&&!(b.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Gb.test(b.data)&&\"data\");return h||\"jsonp\"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,\"$1\"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?\"&\":\"?\")+b.jsonp+\"=\"+e),b.converters[\"script json\"]=function(){return g||n.error(e+\" was not called\"),g[0]},b.dataTypes[0]=\"json\",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),\"script\"):void 0}),n.parseHTML=function(a,b,c){if(!a||\"string\"!=typeof a)return null;\"boolean\"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if(\"string\"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(\" \");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&\"object\"==typeof b&&(e=\"POST\"),g.length>0&&n.ajax({url:a,type:e,dataType:\"html\",data:b}).done(function(a){f=arguments,g.html(d?n(\"<div>\").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,\"position\"),l=n(a),m={};\"static\"===k&&(a.style.position=\"relative\"),h=l.offset(),f=n.css(a,\"top\"),i=n.css(a,\"left\"),j=(\"absolute\"===k||\"fixed\"===k)&&(f+i).indexOf(\"auto\")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),\"using\"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return\"fixed\"===n.css(c,\"position\")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],\"html\")||(d=a.offset()),d.top+=n.css(a[0],\"borderTopWidth\",!0),d.left+=n.css(a[0],\"borderLeftWidth\",!0)),{top:b.top-d.top-n.css(c,\"marginTop\",!0),left:b.left-d.left-n.css(c,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,\"html\")&&\"static\"===n.css(a,\"position\"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(b,c){var d=\"pageYOffset\"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each([\"top\",\"left\"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+\"px\":c):void 0})}),n.each({Height:\"height\",Width:\"width\"},function(a,b){n.each({padding:\"inner\"+a,content:b,\"\":\"outer\"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||\"boolean\"!=typeof d),g=c||(d===!0||e===!0?\"margin\":\"border\");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement[\"client\"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body[\"scroll\"+a],e[\"scroll\"+a],b.body[\"offset\"+a],e[\"offset\"+a],e[\"client\"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});"}, {"sha": "fbc7615588eed2fe4b820a9d5e30ffe43e2c9e8c", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 456, "deletions": 233, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -37,10 +37,63 @@\n                      \"associatedconstant\",\n                      \"union\"];\n \n+    function hasClass(elem, className) {\n+        if (elem && className && elem.className) {\n+            var elemClass = elem.className;\n+            var start = elemClass.indexOf(className);\n+            if (start == -1) {\n+                return false;\n+            } else if (elemClass.length == className.length) {\n+                return true;\n+            } else {\n+                if (start > 0 && elemClass[start - 1] != ' ') {\n+                    return false;\n+                }\n+                var end = start + className.length;\n+                if (end < elemClass.length && elemClass[end] != ' ') {\n+                    return false;\n+                }\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    function addClass(elem, className) {\n+        if (elem && className && !hasClass(elem, className)) {\n+            if (elem.className && elem.className.length > 0) {\n+                elem.className += ' ' + className;\n+            } else {\n+                elem.className = className;\n+            }\n+        }\n+    }\n+\n+    function removeClass(elem, className) {\n+        if (elem && className && elem.className) {\n+            elem.className = (\" \" + elem.className + \" \").replace(\" \" + className + \" \", \" \")\n+                                                         .trim();\n+        }\n+    }\n+\n+    function onEach(arr, func) {\n+        if (arr && arr.length > 0 && func) {\n+            for (var i = 0; i < arr.length; i++) {\n+                func(arr[i]);\n+            }\n+        }\n+    }\n+\n+    function isHidden(elem) {\n+        return (elem.offsetParent === null)\n+    }\n+\n     // used for special search precedence\n     var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n \n-    $('.js-only').removeClass('js-only');\n+    onEach(document.getElementsByClassName('js-only'), function(e) {\n+        removeClass(e, 'js-only');\n+    });\n \n     function getQueryStringParams() {\n         var params = {};\n@@ -65,18 +118,28 @@\n             from = parseInt(match[1], 10);\n             to = Math.min(50000, parseInt(match[2] || match[1], 10));\n             from = Math.min(from, to);\n-            if ($('#' + from).length === 0) {\n+            var elem = document.getElementById(from);\n+            if (!elem) {\n                 return;\n             }\n-            if (ev === null) { $('#' + from)[0].scrollIntoView(); };\n-            $('.line-numbers span').removeClass('line-highlighted');\n+            if (ev === null) {\n+                var x = document.getElementById(from);\n+                if (x) {\n+                    x.scrollIntoView();\n+                }\n+            };\n+            onEach(document.getElementsByClassName('line-numbers'), function(e) {\n+                onEach(e.getElementsByTagName('span'), function(i_e) {\n+                    removeClass(i_e, 'line-highlighted');\n+                });\n+            })\n             for (i = from; i <= to; ++i) {\n-                $('#' + i).addClass('line-highlighted');\n+                addClass(document.getElementById(i), 'line-highlighted');\n             }\n         }\n     }\n     highlightSourceLines(null);\n-    $(window).on('hashchange', highlightSourceLines);\n+    window.onhashchange = highlightSourceLines;\n \n     // Gets the human-readable string for the virtual-key code of the\n     // given KeyboardEvent, ev.\n@@ -99,23 +162,25 @@\n     }\n \n     function handleShortcut(ev) {\n-        if (document.activeElement.tagName == \"INPUT\")\n+        if (document.activeElement.tagName === \"INPUT\")\n             return;\n \n         // Don't interfere with browser shortcuts\n         if (ev.ctrlKey || ev.altKey || ev.metaKey)\n             return;\n \n+        var help = document.getElementById(\"help\");\n         switch (getVirtualKey(ev)) {\n         case \"Escape\":\n-            if (!$(\"#help\").hasClass(\"hidden\")) {\n+            var search = document.getElementById(\"search\");\n+            if (!hasClass(help, \"hidden\")) {\n                 ev.preventDefault();\n-                $(\"#help\").addClass(\"hidden\");\n-                $(\"body\").removeClass(\"blur\");\n-            } else if (!$(\"#search\").hasClass(\"hidden\")) {\n+                addClass(help, \"hidden\");\n+                removeClass(document.body, \"blur\");\n+            } else if (!hasClass(search, \"hidden\")) {\n                 ev.preventDefault();\n-                $(\"#search\").addClass(\"hidden\");\n-                $(\"#main\").removeClass(\"hidden\");\n+                addClass(search, \"hidden\");\n+                removeClass(document.getElementById(\"main\"), \"hidden\");\n             }\n             break;\n \n@@ -131,42 +196,76 @@\n             break;\n \n         case \"?\":\n-            if (ev.shiftKey && $(\"#help\").hasClass(\"hidden\")) {\n+            if (ev.shiftKey && hasClass(help, \"hidden\")) {\n                 ev.preventDefault();\n-                $(\"#help\").removeClass(\"hidden\");\n-                $(\"body\").addClass(\"blur\");\n+                removeClass(help, \"hidden\");\n+                addClass(document.body, \"blur\");\n             }\n             break;\n         }\n     }\n \n-    $(document).on(\"keypress\", handleShortcut);\n-    $(document).on(\"keydown\", handleShortcut);\n-    $(document).on(\"click\", function(ev) {\n-        if (!$(ev.target).closest(\"#help > div\").length) {\n-            $(\"#help\").addClass(\"hidden\");\n-            $(\"body\").removeClass(\"blur\");\n-        }\n-    });\n+    document.onkeypress = handleShortcut;\n+    document.onkeydown = handleShortcut;\n+    document.onclick = function(ev) {\n+        if (hasClass(ev.target, 'collapse-toggle')) {\n+            collapseDocs(ev.target);\n+        } else if (hasClass(ev.target.parentNode, 'collapse-toggle')) {\n+            collapseDocs(ev.target.parentNode);\n+        } else if (ev.target.tagName === 'SPAN' && hasClass(ev.target.parentNode, 'line-numbers')) {\n+            var prev_id = 0;\n+\n+            function set_fragment(name) {\n+                if (browserSupportsHistoryApi()) {\n+                    history.replaceState(null, null, '#' + name);\n+                    window.hashchange();\n+                } else {\n+                    location.replace('#' + name);\n+                }\n+            }\n \n-    $('.version-selector').on('change', function() {\n-        var i, match,\n-            url = document.location.href,\n-            stripped = '',\n-            len = rootPath.match(/\\.\\.\\//g).length + 1;\n+            var cur_id = parseInt(ev.target.id, 10);\n \n-        for (i = 0; i < len; ++i) {\n-            match = url.match(/\\/[^\\/]*$/);\n-            if (i < len - 1) {\n-                stripped = match[0] + stripped;\n+            if (ev.shiftKey && prev_id) {\n+                if (prev_id > cur_id) {\n+                    var tmp = prev_id;\n+                    prev_id = cur_id;\n+                    cur_id = tmp;\n+                }\n+\n+                set_fragment(prev_id + '-' + cur_id);\n+            } else {\n+                prev_id = cur_id;\n+\n+                set_fragment(cur_id);\n             }\n-            url = url.substring(0, url.length - match[0].length);\n+        } else if (!hasClass(document.getElementById(\"help\"), \"hidden\")) {\n+            addClass(document.getElementById(\"help\"), \"hidden\");\n+            removeClass(document.body, \"blur\");\n         }\n+    };\n \n-        url += '/' + $('.version-selector').val() + stripped;\n+    var x = document.getElementsByClassName('version-selector');\n+    if (x.length > 0) {\n+        x[0].onchange = function() {\n+            var i, match,\n+                url = document.location.href,\n+                stripped = '',\n+                len = rootPath.match(/\\.\\.\\//g).length + 1;\n \n-        document.location.href = url;\n-    });\n+            for (i = 0; i < len; ++i) {\n+                match = url.match(/\\/[^\\/]*$/);\n+                if (i < len - 1) {\n+                    stripped = match[0] + stripped;\n+                }\n+                url = url.substring(0, url.length - match[0].length);\n+            }\n+\n+            url += '/' + document.getElementsByClassName('version-selector')[0].value + stripped;\n+\n+            document.location.href = url;\n+        };\n+    }\n \n     /**\n      * A function to compute the Levenshtein distance between two strings\n@@ -214,8 +313,8 @@\n         // but only if the input bar is empty. This avoid the obnoxious issue\n         // where you start trying to do a search, and the index loads, and\n         // suddenly your search is gone!\n-        if ($(\".search-input\")[0].value === \"\") {\n-            $(\".search-input\")[0].value = params.search || '';\n+        if (document.getElementsByClassName(\"search-input\")[0].value === \"\") {\n+            document.getElementsByClassName(\"search-input\")[0].value = params.search || '';\n         }\n \n         /**\n@@ -484,7 +583,8 @@\n         }\n \n         function getQuery() {\n-            var matches, type, query, raw = $('.search-input').val();\n+            var matches, type, query, raw =\n+                document.getElementsByClassName('search-input')[0].value;\n             query = raw;\n \n             matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n@@ -502,54 +602,92 @@\n         }\n \n         function initSearchNav() {\n-            var hoverTimeout, $results = $('.search-results .result');\n+            var hoverTimeout;\n \n-            $results.on('click', function() {\n-                var dst = $(this).find('a')[0];\n+            var click_func = function(e) {\n+                var el = e.target;\n+                // to retrieve the real \"owner\" of the event.\n+                while (el.tagName !== 'TR') {\n+                    el = el.parentNode;\n+                }\n+                var dst = e.target.getElementsByTagName('a');\n+                if (dst.length < 1) {\n+                    return;\n+                }\n+                dst = dst[0];\n                 if (window.location.pathname === dst.pathname) {\n-                    $('#search').addClass('hidden');\n-                    $('#main').removeClass('hidden');\n+                    addClass(document.getElementById('search'), 'hidden');\n+                    removeClass(document.getElementById('main'), 'hidden');\n                     document.location.href = dst.href;\n                 }\n-            }).on('mouseover', function() {\n-                var $el = $(this);\n+            };\n+            var mouseover_func = function(e) {\n+                var el = e.target;\n+                // to retrieve the real \"owner\" of the event.\n+                while (el.tagName !== 'TR') {\n+                    el = el.parentNode;\n+                }\n                 clearTimeout(hoverTimeout);\n                 hoverTimeout = setTimeout(function() {\n-                    $results.removeClass('highlighted');\n-                    $el.addClass('highlighted');\n+                    onEach(document.getElementsByClassName('search-results'), function(e) {\n+                        onEach(e.getElementsByClassName('result'), function(i_e) {\n+                            removeClass(i_e, 'highlighted');\n+                        });\n+                    });\n+                    addClass(el, 'highlighted');\n                 }, 20);\n+            };\n+            onEach(document.getElementsByClassName('search-results'), function(e) {\n+                onEach(e.getElementsByClassName('result'), function(i_e) {\n+                    i_e.onclick = click_func;\n+                    i_e.onmouseover = mouseover_func;\n+                });\n             });\n \n-            $(document).off('keydown.searchnav');\n-            $(document).on('keydown.searchnav', function(e) {\n-                var $active = $results.filter('.highlighted');\n+            var search_input = document.getElementsByClassName('search-input')[0];\n+            search_input.onkeydown = null;\n+            search_input.onkeydown = function(e) {\n+                var actives = [];\n+                onEach(document.getElementsByClassName('search-results'), function(e) {\n+                    onEach(document.getElementsByClassName('highlighted'), function(e) {\n+                        actives.push(e);\n+                    });\n+                });\n \n                 if (e.which === 38) { // up\n-                    if (!$active.length || !$active.prev()) {\n+                    if (!actives.length || !actives[0].previousElementSibling) {\n                         return;\n                     }\n \n-                    $active.prev().addClass('highlighted');\n-                    $active.removeClass('highlighted');\n+                    addClass(actives[0].previousElementSibling, 'highlighted');\n+                    removeClass(actives[0], 'highlighted');\n                 } else if (e.which === 40) { // down\n-                    if (!$active.length) {\n-                        $results.first().addClass('highlighted');\n-                    } else if ($active.next().length) {\n-                        $active.next().addClass('highlighted');\n-                        $active.removeClass('highlighted');\n+                    if (!actives.length) {\n+                        var results = document.getElementsByClassName('search-results');\n+                        if (results.length > 0) {\n+                            var res = results[0].getElementsByClassName('result');\n+                            if (res.length > 0) {\n+                                addClass(res[0], 'highlighted');\n+                            }\n+                        }\n+                    } else if (actives[0].nextElementSibling) {\n+                        addClass(actives[0].nextElementSibling, 'highlighted');\n+                        removeClass(actives[0], 'highlighted');\n                     }\n                 } else if (e.which === 13) { // return\n-                    if ($active.length) {\n-                        document.location.href = $active.find('a').prop('href');\n+                    if (actives.length) {\n+                        document.location.href = actives[0].getElementsByTagName('a')[0].href;\n                     }\n-                } else {\n-                  $active.removeClass('highlighted');\n+                } else if (actives.length > 0) {\n+                    removeClass(actives[0], 'highlighted');\n                 }\n-            });\n+            };\n         }\n \n         function escape(content) {\n-            return $('<h1/>').text(content).html();\n+            let h1 = document.createElement('h1');\n+            h1.textContent = content;\n+            return h1.innerHTML;\n         }\n \n         function showResults(results) {\n@@ -619,10 +757,19 @@\n             }\n \n             output += \"</p>\";\n-            $('#main.content').addClass('hidden');\n-            $('#search.content').removeClass('hidden').html(output);\n-            $('#search .desc').width($('#search').width() - 40 -\n-                $('#search td:first-child').first().width());\n+            addClass(document.getElementById('main'), 'hidden');\n+            var search = document.getElementById('search');\n+            removeClass(search, 'hidden');\n+            search.innerHTML = output;\n+            var tds = search.getElementsByTagName('td');\n+            var td_width = 0;\n+            if (tds.length > 0) {\n+                td_width = tds[0].offsetWidth;\n+            }\n+            var width = search.offsetWidth - 40 - td_width;\n+            onEach(search.getElementsByClassName('desc'), function(e) {\n+                e.style.width = width + 'px';\n+            });\n             initSearchNav();\n         }\n \n@@ -645,17 +792,15 @@\n             }\n \n             // Update document title to maintain a meaningful browser history\n-            $(document).prop(\"title\", \"Results for \" + query.query + \" - Rust\");\n+            document.title = \"Results for \" + query.query + \" - Rust\";\n \n             // Because searching is incremental by character, only the most\n             // recent search query is added to the browser history.\n             if (browserSupportsHistoryApi()) {\n                 if (!history.state && !params.search) {\n-                    history.pushState(query, \"\", \"?search=\" +\n-                                                encodeURIComponent(query.raw));\n+                    history.pushState(query, \"\", \"?search=\" + encodeURIComponent(query.raw));\n                 } else {\n-                    history.replaceState(query, \"\", \"?search=\" +\n-                                                encodeURIComponent(query.raw));\n+                    history.replaceState(query, \"\", \"?search=\" + encodeURIComponent(query.raw));\n                 }\n             }\n \n@@ -744,49 +889,68 @@\n \n         function startSearch() {\n             var searchTimeout;\n-            $(\".search-input\").on(\"keyup input\",function() {\n+            var callback = function() {\n+                var search_input = document.getElementsByClassName('search-input');\n+                if (search_input.length < 1) { return; }\n+                search_input = search_input[0];\n                 clearTimeout(searchTimeout);\n-                if ($(this).val().length === 0) {\n+                if (search_input.value.length === 0) {\n                     if (browserSupportsHistoryApi()) {\n                         history.replaceState(\"\", \"std - Rust\", \"?search=\");\n                     }\n-                    $('#main.content').removeClass('hidden');\n-                    $('#search.content').addClass('hidden');\n+                    var main = document.getElementById('main');\n+                    if (hasClass(main, 'content')) {\n+                        removeClass(main, 'hidden');\n+                    }\n+                    var search_c = document.getElementById('search');\n+                    if (hasClass(search_c, 'content')) {\n+                        addClass(search_c, 'hidden');\n+                    }\n                 } else {\n                     searchTimeout = setTimeout(search, 500);\n                 }\n-            });\n-            $('.search-form').on('submit', function(e){\n+            };\n+            var search_input = document.getElementsByClassName(\"search-input\")[0];\n+            search_input.onkeyup = callback;\n+            search_input.oninput = callback;\n+            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e){\n                 e.preventDefault();\n                 clearTimeout(searchTimeout);\n                 search();\n-            });\n-            $('.search-input').on('change paste', function(e) {\n+            };\n+            search_input.onchange = function(e) {\n                 // Do NOT e.preventDefault() here. It will prevent pasting.\n                 clearTimeout(searchTimeout);\n                 // zero-timeout necessary here because at the time of event handler execution the\n                 // pasted content is not in the input field yet. Shouldn\u2019t make any difference for\n                 // change, though.\n                 setTimeout(search, 0);\n-            });\n+            };\n+            search_input.onpaste = search_input.onchange;\n \n             // Push and pop states are used to add search results to the browser\n             // history.\n             if (browserSupportsHistoryApi()) {\n                 // Store the previous <title> so we can revert back to it later.\n-                var previousTitle = $(document).prop(\"title\");\n+                var previousTitle = document.title;\n \n-                $(window).on('popstate', function(e) {\n+                window.onpopstate = function(e) {\n                     var params = getQueryStringParams();\n                     // When browsing back from search results the main page\n                     // visibility must be reset.\n                     if (!params.search) {\n-                        $('#main.content').removeClass('hidden');\n-                        $('#search.content').addClass('hidden');\n+                        var main = document.getElementById('main');\n+                        if (hasClass(main, 'content')) {\n+                            removeClass(main, 'hidden');\n+                        }\n+                        var search = document.getElementById('search');\n+                        if (hasClass(main, 'content')) {\n+                            addClass(main, 'hidden');\n+                        }\n                     }\n                     // Revert to the previous title manually since the History\n                     // API ignores the title parameter.\n-                    $(document).prop(\"title\", previousTitle);\n+                    document.title = previousTitle;\n                     // When browsing forward to search results the previous\n                     // search will be repeated, so the currentResults are\n                     // cleared to ensure the search is successful.\n@@ -795,14 +959,14 @@\n                     // perform the search. This will empty the bar if there's\n                     // nothing there, which lets you really go back to a\n                     // previous state with nothing in the bar.\n-                    $('.search-input').val(params.search);\n+                    document.getElementsByClassName('search-input')[0].value = params.search;\n                     // Some browsers fire 'onpopstate' for every page load\n                     // (Chrome), while others fire the event only when actually\n                     // popping a state (Firefox), which is why search() is\n                     // called both here and at the end of the startSearch()\n                     // function.\n                     search();\n-                });\n+                };\n             }\n             search();\n         }\n@@ -812,10 +976,12 @@\n \n         // Draw a convenient sidebar of known crates if we have a listing\n         if (rootPath === '../') {\n-            var sidebar = $('.sidebar');\n-            var div = $('<div>').attr('class', 'block crate');\n-            div.append($('<h3>').text('Crates'));\n-            var ul = $('<ul>').appendTo(div);\n+            var sidebar = document.getElementsByClassName('sidebar')[0];\n+            var div = document.createElement('div');\n+            div.className = 'block crate';\n+            div.innerHTML = '<h3>Crates</h3>';\n+            var ul = document.createElement('ul');\n+            div.appendChild(ul);\n \n             var crates = [];\n             for (var crate in rawSearchIndex) {\n@@ -828,29 +994,37 @@\n                 if (crates[i] === window.currentCrate) {\n                     klass += ' current';\n                 }\n-                var link = $('<a>', {'href': '../' + crates[i] + '/index.html',\n-                                     'title': rawSearchIndex[crates[i]].doc,\n-                                     'class': klass}).text(crates[i]);\n-                ul.append($('<li>').append(link));\n+                var link = document.createElement('a');\n+                link.href = '../' + crates[i] + '/index.html';\n+                link.title = rawSearchIndex[crates[i]].doc;\n+                link.className = klass;\n+                link.textContent = crates[i];\n+\n+                var li = document.createElement('li');\n+                li.appendChild(link);\n+                ul.appendChild(li);\n             }\n-            sidebar.append(div);\n+            sidebar.appendChild(div);\n         }\n     }\n \n     window.initSearch = initSearch;\n \n     // delayed sidebar rendering.\n     function initSidebarItems(items) {\n-        var sidebar = $('.sidebar');\n+        var sidebar = document.getElementsByClassName('sidebar')[0];\n         var current = window.sidebarCurrent;\n \n         function block(shortty, longty) {\n             var filtered = items[shortty];\n             if (!filtered) { return; }\n \n-            var div = $('<div>').attr('class', 'block ' + shortty);\n-            div.append($('<h3>').text(longty));\n-            var ul = $('<ul>').appendTo(div);\n+            var div = document.createElement('div');\n+            div.className = 'block ' + shortty;\n+            var h3 = document.createElement('h3');\n+            h3.textContent = longty;\n+            div.appendChild(h3);\n+            var ul = document.createElement('ul');\n \n             for (var i = 0; i < filtered.length; ++i) {\n                 var item = filtered[i];\n@@ -867,12 +1041,17 @@\n                 } else {\n                     path = shortty + '.' + name + '.html';\n                 }\n-                var link = $('<a>', {'href': current.relpath + path,\n-                                     'title': desc,\n-                                     'class': klass}).text(name);\n-                ul.append($('<li>').append(link));\n+                var link = document.createElement('a');\n+                link.href = current.relpath + path;\n+                link.title = desc;\n+                link.className = klass;\n+                link.textContent = name;\n+                var li = document.createElement('li');\n+                li.appendChild(link);\n+                ul.appendChild(li);\n             }\n-            sidebar.append(div);\n+            div.appendChild(ul);\n+            sidebar.appendChild(div);\n         }\n \n         block(\"primitive\", \"Primitive Types\");\n@@ -890,21 +1069,25 @@\n     window.initSidebarItems = initSidebarItems;\n \n     window.register_implementors = function(imp) {\n-        var list = $('#implementors-list');\n+        var list = document.getElementById('implementors-list');\n         var libs = Object.getOwnPropertyNames(imp);\n         for (var i = 0; i < libs.length; ++i) {\n             if (libs[i] === currentCrate) { continue; }\n             var structs = imp[libs[i]];\n             for (var j = 0; j < structs.length; ++j) {\n-                var code = $('<code>').append(structs[j]);\n-                $.each(code.find('a'), function(idx, a) {\n-                    var href = $(a).attr('href');\n+                var code = document.createElement('code');\n+                code.innerHTML = structs[j];\n+\n+                var x = code.getElementsByTagName('a');\n+                for (var i = 0; i < x.length; i++) {\n+                    var href = x[i].href;\n                     if (href && href.indexOf('http') !== 0) {\n-                        $(a).attr('href', rootPath + href);\n+                        x[i].href = rootPath + href;\n                     }\n-                });\n-                var li = $('<li>').append(code);\n-                list.append(li);\n+                }\n+                var li = document.createElement('li');\n+                li.appendChild(code);\n+                list.appendChild(li);\n             }\n         }\n     };\n@@ -922,146 +1105,186 @@\n         return \"\\u2212\"; // \"\\u2212\" is '\u2212' minus sign\n     }\n \n+    function onEveryMatchingChild(elem, className, func) {\n+        if (elem && className && func) {\n+            for (var i = 0; i < elem.childNodes.length; i++) {\n+                if (hasClass(elem.childNodes[i], className)) {\n+                    func(elem.childNodes[i]);\n+                } else {\n+                    onEveryMatchingChild(elem.childNodes[i], className, func);\n+                }\n+            }\n+        }\n+    }\n+\n     function toggleAllDocs() {\n-        var toggle = $(\"#toggle-all-docs\");\n-        if (toggle.hasClass(\"will-expand\")) {\n-            toggle.removeClass(\"will-expand\");\n-            toggle.children(\".inner\").text(labelForToggleButton(false));\n-            toggle.attr(\"title\", \"collapse all docs\");\n-            $(\".docblock\").show();\n-            $(\".toggle-label\").hide();\n-            $(\".toggle-wrapper\").removeClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").text(labelForToggleButton(false));\n+        var toggle = document.getElementById(\"toggle-all-docs\");\n+        if (hasClass(toggle, \"will-expand\")) {\n+            removeClass(toggle, \"will-expand\");\n+            onEveryMatchingChild(toggle, \"inner\", function(e) {\n+                e.innerHTML = labelForToggleButton(false);\n+            });\n+            toggle.title = \"collapse all docs\";\n+            onEach(document.getElementsByClassName(\"docblock\"), function(e) {\n+                e.style.display = 'block';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-label\"), function(e) {\n+                e.style.display = 'none';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-wrapper\"), function(e) {\n+                removeClass(e, \"collapsed\");\n+            });\n+            onEach(document.getElementsByClassName(\"collapse-toggle\"), function(e) {\n+                onEveryMatchingChild(e, \"inner\", function(i_e) {\n+                    i_e.innerHTML = labelForToggleButton(false);\n+                });\n+            });\n         } else {\n-            toggle.addClass(\"will-expand\");\n-            toggle.children(\".inner\").text(labelForToggleButton(true));\n-            toggle.attr(\"title\", \"expand all docs\");\n-            $(\".docblock\").hide();\n-            $(\".toggle-label\").show();\n-            $(\".toggle-wrapper\").addClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").text(labelForToggleButton(true));\n+            addClass(toggle, \"will-expand\");\n+            onEveryMatchingChild(toggle, \"inner\", function(e) {\n+                e.innerHTML = labelForToggleButton(true);\n+            });\n+            toggle.title = \"expand all docs\";\n+            onEach(document.getElementsByClassName(\"docblock\"), function(e) {\n+                e.style.display = 'none';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-label\"), function(e) {\n+                e.style.display = 'inline-block';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-wrapper\"), function(e) {\n+                addClass(e, \"collapsed\");\n+            });\n+            onEach(document.getElementsByClassName(\"collapse-toggle\"), function(e) {\n+                onEveryMatchingChild(e, \"inner\", function(i_e) {\n+                    i_e.innerHTML = labelForToggleButton(true);\n+                });\n+            });\n         }\n     }\n \n-    function collapseDocs(toggle, animate) {\n-        var relatedDoc = toggle.parent().next();\n-        if (relatedDoc.is(\".stability\")) {\n-            relatedDoc = relatedDoc.next();\n+    function collapseDocs(toggle) {\n+        if (!toggle || !toggle.parentNode) {\n+            return;\n         }\n-        if (relatedDoc.is(\".docblock\")) {\n-            if (relatedDoc.is(\":visible\")) {\n-                if (animate === true) {\n-                    relatedDoc.slideUp({\n-                        duration: 'fast',\n-                        easing: 'linear',\n-                        complete: function() {\n-                            toggle.children(\".toggle-label\").fadeIn();\n-                            toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n-                            toggle.children(\".inner\").text(labelForToggleButton(true));\n-                        },\n-                    });\n-                } else {\n-                    relatedDoc.hide();\n-                    toggle.children(\".toggle-label\").show();\n-                    toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n-                    toggle.children(\".inner\").text(labelForToggleButton(true));\n-                }\n+        var relatedDoc = toggle.parentNode.nextElementSibling;\n+        if (hasClass(relatedDoc, \"stability\")) {\n+            relatedDoc = relatedDoc.nextElementSibling;\n+        }\n+        if (hasClass(relatedDoc, \"docblock\")) {\n+            if (!isHidden(relatedDoc)) {\n+                relatedDoc.style.display = 'none';\n+                onEach(toggle.childNodes, function(e) {\n+                    if (hasClass(e, 'toggle-label')) {\n+                        e.style.display = 'inline-block';\n+                    }\n+                    if (hasClass(e, 'inner')) {\n+                        e.innerHTML = labelForToggleButton(true);\n+                    }\n+                });\n+                addClass(toggle.parentNode, 'collapsed');\n             } else {\n-                relatedDoc.slideDown({duration: 'fast', easing: 'linear'});\n-                toggle.parent(\".toggle-wrapper\").removeClass(\"collapsed\");\n-                toggle.children(\".inner\").text(labelForToggleButton(false));\n-                toggle.children(\".toggle-label\").hide();\n+                relatedDoc.style.display = 'block';\n+                removeClass(toggle.parentNode, 'collapsed');\n+                onEach(toggle.childNodes, function(e) {\n+                    if (hasClass(e, 'toggle-label')) {\n+                        e.style.display = 'none';\n+                    }\n+                    if (hasClass(e, 'inner')) {\n+                        e.innerHTML = labelForToggleButton(false);\n+                    }\n+                });\n             }\n         }\n     }\n \n-    $(\"#toggle-all-docs\").on(\"click\", toggleAllDocs);\n+    var x = document.getElementById('toggle-all-docs');\n+    if (x) {\n+        x.onclick = toggleAllDocs;\n+    }\n \n-    $(document).on(\"click\", \".collapse-toggle\", function() {\n-        collapseDocs($(this), true)\n-    });\n+    function insertAfter(newNode, referenceNode) {\n+        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n+    }\n \n-    $(function() {\n-        var toggle = $(\"<a/>\", {'href': 'javascript:void(0)', 'class': 'collapse-toggle'})\n-            .html(\"[<span class='inner'></span>]\");\n-        toggle.children(\".inner\").text(labelForToggleButton(false));\n+    var toggle = document.createElement('a');\n+    toggle.href = 'javascript:void(0)';\n+    toggle.className = 'collapse-toggle';\n+    toggle.innerHTML = \"[<span class='inner'>\"+labelForToggleButton(false)+\"</span>]\";\n \n-        $(\".method, .impl-items > .associatedconstant\").each(function() {\n-            if ($(this).next().is(\".docblock\") ||\n-                ($(this).next().is(\".stability\") && $(this).next().next().is(\".docblock\"))) {\n-                    $(this).children().last().after(toggle.clone());\n-            }\n-        });\n+    var func = function(e) {\n+        var next = e.nextElementSibling;\n+        if (!next) {\n+            return;\n+        }\n+        if (hasClass(next, 'docblock') ||\n+            (hasClass(next, 'stability') &&\n+             hasClass(next.nextElementSibling, 'docblock'))) {\n+            insertAfter(toggle.cloneNode(true), e.childNodes[e.childNodes.length - 1]);\n+        }\n+    }\n+    onEach(document.getElementsByClassName('method'), func);\n+    onEach(document.getElementsByClassName('impl-items'), function(e) {\n+        onEach(e.getElementsByClassName('associatedconstant'), func);\n+    });\n \n-        var mainToggle =\n-            $(toggle.clone()).append(\n-                $('<span/>', {'class': 'toggle-label'})\n-                    .css('display', 'none')\n-                    .html('&nbsp;Expand&nbsp;description'));\n-        var wrapper = $(\"<div class='toggle-wrapper'>\").append(mainToggle);\n-        $(\"#main > .docblock\").before(wrapper);\n-\n-        $(\".docblock.autohide\").each(function() {\n-            var wrap = $(this).prev();\n-            if (wrap.is(\".toggle-wrapper\")) {\n-                var toggle = wrap.children().first();\n-                if ($(this).children().first().is(\"h3\")) {\n-                    toggle.children(\".toggle-label\")\n-                          .text(\" Show \" + $(this).children().first().text());\n-                }\n-                $(this).hide();\n-                wrap.addClass(\"collapsed\");\n-                toggle.children(\".inner\").text(labelForToggleButton(true));\n-                toggle.children(\".toggle-label\").show();\n-            }\n-        });\n+    var span = document.createElement('span');\n+    span.className = 'toggle-label';\n+    span.style.display = 'none';\n+    span.innerHTML = '&nbsp;Expand&nbsp;description';\n \n-        var mainToggle =\n-            $(toggle).append(\n-                $('<span/>', {'class': 'toggle-label'})\n-                    .css('display', 'none')\n-                    .html('&nbsp;Expand&nbsp;attributes'));\n-        var wrapper = $(\"<div class='toggle-wrapper toggle-attributes'>\").append(mainToggle);\n-        $(\"#main > pre > .attributes\").each(function() {\n-            $(this).before(wrapper);\n-            collapseDocs($($(this).prev().children()[0]), false);\n-        });\n-    });\n+    var mainToggle = toggle.cloneNode(true);\n+    mainToggle.appendChild(span);\n \n-    $('pre.line-numbers').on('click', 'span', function() {\n-        var prev_id = 0;\n+    var wrapper = document.createElement('div');\n+    wrapper.className = 'toggle-wrapper';\n+    wrapper.appendChild(mainToggle);\n \n-        function set_fragment(name) {\n-            if (browserSupportsHistoryApi()) {\n-                history.replaceState(null, null, '#' + name);\n-                $(window).trigger('hashchange');\n-            } else {\n-                location.replace('#' + name);\n-            }\n+    onEach(document.getElementById('main').getElementsByClassName('docblock'), function(e) {\n+        if (e.parentNode.id === \"main\") {\n+            e.parentNode.insertBefore(wrapper, e);\n         }\n+    });\n \n-        return function(ev) {\n-            var cur_id = parseInt(ev.target.id, 10);\n-\n-            if (ev.shiftKey && prev_id) {\n-                if (prev_id > cur_id) {\n-                    var tmp = prev_id;\n-                    prev_id = cur_id;\n-                    cur_id = tmp;\n+    onEach(document.getElementsByClassName('docblock'), function(e) {\n+        if (hasClass(e, 'autohide')) {\n+            var wrap = e.previousElementSibling;\n+            if (wrap && hasClass(wrap, 'toggle-wrapper')) {\n+                var toggle = wrap.childNodes[0];\n+                if (e.childNodes[0].tagName === 'H3') {\n+                    onEach(toggle.getElementsByClassName('toggle-label'), function(i_e) {\n+                        i_e.innerHTML = \" Show \" + e.childNodes[0].innerHTML;\n+                    });\n                 }\n-\n-                set_fragment(prev_id + '-' + cur_id);\n-            } else {\n-                prev_id = cur_id;\n-\n-                set_fragment(cur_id);\n+                e.style.display = 'none';\n+                addClass(wrap, 'collapsed');\n+                onEach(toggle.getElementsByClassName('inner'), function(e) {\n+                    e.innerHTML = labelForToggleButton(true);\n+                });\n+                onEach(toggle.getElementsByClassName('toggle-label'), function(e) {\n+                    e.style.display = 'block';\n+                });\n             }\n-        };\n-    }());\n-\n+        }\n+    })\n+\n+    var span = document.createElement('span');\n+    span.className = 'toggle-label';\n+    span.style.display = 'none';\n+    span.innerHTML = '&nbsp;Expand&nbsp;attributes';\n+    toggle.appendChild(span);\n+\n+    var wrapper = document.createElement('div');\n+    wrapper.className = 'toggle-wrapper toggle-attributes';\n+    wrapper.appendChild(toggle);\n+    onEach(document.getElementById('main').getElementsByTagName('pre'), function(e) {\n+        onEach(e.getElementsByClassName('attributes'), function(i_e) {\n+            i_e.parentNode.insertBefore(wrapper, i_e);\n+            collapseDocs(i_e.previousSibling.childNodes[0]);\n+        });\n+    });\n }());\n \n // Sets the focus on the search bar at the top of the page\n function focusSearchBar() {\n-    $('.search-input').focus();\n+    document.getElementsByClassName('search-input')[0].focus();\n }"}, {"sha": "1156fadf8c02c146dd01b4b5539c067dc67745fb", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -173,6 +173,7 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                          or `#![doc(html_playground_url=...)]`\",\n                         \"URL\")),\n         unstable(optflag(\"\", \"enable-commonmark\", \"to enable commonmark doc rendering/testing\")),\n+        unstable(optflag(\"\", \"display-warnings\", \"to print code warnings when testing doc\")),\n     ]\n }\n \n@@ -280,14 +281,16 @@ pub fn main_args(args: &[String]) -> isize {\n     let crate_name = matches.opt_str(\"crate-name\");\n     let playground_url = matches.opt_str(\"playground-url\");\n     let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n+    let display_warnings = matches.opt_present(\"display-warnings\");\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type)\n+            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type,\n+                                  display_warnings)\n         }\n         (true, false) => {\n             return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot,\n-                             render_type)\n+                             render_type, display_warnings)\n         }\n         (false, true) => return markdown::render(input,\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n@@ -389,13 +392,15 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n \n     let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n+    let display_warnings = matches.opt_present(\"display-warnings\");\n \n     let (tx, rx) = channel();\n     rustc_driver::monitor(move || {\n         use rustc::session::config::Input;\n \n         let (mut krate, renderinfo) =\n-            core::run_core(paths, cfgs, externs, Input::File(cr), triple, maybe_sysroot);\n+            core::run_core(paths, cfgs, externs, Input::File(cr), triple, maybe_sysroot,\n+                           display_warnings);\n \n         info!(\"finished with rustc\");\n "}, {"sha": "057ce69d9de8bcf925f59cb3a9c7700763202d40", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -150,7 +150,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n-            render_type: RenderType) -> isize {\n+            render_type: RenderType, display_warnings: bool) -> isize {\n     let input_str = match load_string(input) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n@@ -166,6 +166,7 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     old_find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     test_args.insert(0, \"rustdoctest\".to_string());\n-    testing::test_main(&test_args, collector.tests);\n+    testing::test_main(&test_args, collector.tests,\n+                       testing::Options::new().display_output(display_warnings));\n     0\n }"}, {"sha": "d5237d629cfc1e7f8f40f2a9c3c9b53c6bdb0825", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -58,7 +58,8 @@ pub fn run(input: &str,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>,\n            maybe_sysroot: Option<PathBuf>,\n-           render_type: RenderType)\n+           render_type: RenderType,\n+           display_warnings: bool)\n            -> isize {\n     let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n@@ -127,7 +128,8 @@ pub fn run(input: &str,\n     test_args.insert(0, \"rustdoctest\".to_string());\n \n     testing::test_main(&test_args,\n-                       collector.tests.into_iter().collect());\n+                       collector.tests.into_iter().collect(),\n+                       testing::Options::new().display_output(display_warnings));\n     0\n }\n "}, {"sha": "f84662c3f86828874498915842c732676e131b9b", "filename": "src/libstd/build.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -43,11 +43,16 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=pthread\");\n     } else if target.contains(\"apple-darwin\") {\n         println!(\"cargo:rustc-link-lib=System\");\n+\n+        // res_init and friends require -lresolv on macOS/iOS.\n+        // See #41582 and http://blog.achernya.com/2013/03/os-x-has-silly-libsystem.html\n+        println!(\"cargo:rustc-link-lib=resolv\");\n     } else if target.contains(\"apple-ios\") {\n         println!(\"cargo:rustc-link-lib=System\");\n         println!(\"cargo:rustc-link-lib=objc\");\n         println!(\"cargo:rustc-link-lib=framework=Security\");\n         println!(\"cargo:rustc-link-lib=framework=Foundation\");\n+        println!(\"cargo:rustc-link-lib=resolv\");\n     } else if target.contains(\"windows\") {\n         println!(\"cargo:rustc-link-lib=advapi32\");\n         println!(\"cargo:rustc-link-lib=ws2_32\");"}, {"sha": "a15269cc87c5da08f9e0acd973f628ba83240bda", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::heap::{EMPTY, allocate, deallocate};\n+use alloc::heap::{allocate, deallocate};\n \n use cmp;\n use hash::{BuildHasher, Hash, Hasher};\n@@ -33,6 +33,7 @@ use self::BucketState::*;\n type HashUint = usize;\n \n const EMPTY_BUCKET: HashUint = 0;\n+const EMPTY: usize = 1;\n \n /// Special `Unique<HashUint>` that uses the lower bit of the pointer\n /// to expose a boolean tag.\n@@ -49,24 +50,25 @@ impl TaggedHashUintPtr {\n \n     #[inline]\n     fn set_tag(&mut self, value: bool) {\n-        let usize_ptr = &*self.0 as *const *mut HashUint as *mut usize;\n+        let mut usize_ptr = self.0.as_ptr() as usize;\n         unsafe {\n             if value {\n-                *usize_ptr |= 1;\n+                usize_ptr |= 1;\n             } else {\n-                *usize_ptr &= !1;\n+                usize_ptr &= !1;\n             }\n+            self.0 = Unique::new(usize_ptr as *mut HashUint)\n         }\n     }\n \n     #[inline]\n     fn tag(&self) -> bool {\n-        (*self.0 as usize) & 1 == 1\n+        (self.0.as_ptr() as usize) & 1 == 1\n     }\n \n     #[inline]\n     fn ptr(&self) -> *mut HashUint {\n-        (*self.0 as usize & !1) as *mut HashUint\n+        (self.0.as_ptr() as usize & !1) as *mut HashUint\n     }\n }\n \n@@ -1112,10 +1114,12 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|raw| unsafe {\n-            (*self.table.as_mut_ptr()).size -= 1;\n-            let (k, v) = ptr::read(raw.pair());\n-            (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+        self.iter.next().map(|raw| {\n+            unsafe {\n+                self.table.as_mut().size -= 1;\n+                let (k, v) = ptr::read(raw.pair());\n+                (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+            }\n         })\n     }\n "}, {"sha": "2487f6bcaf74f0861e48f65492eb90ce18bc8296", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -38,3 +38,8 @@ pub unsafe fn destroy(key: Key) {\n     let r = libc::pthread_key_delete(key);\n     debug_assert_eq!(r, 0);\n }\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "4e08c7a01256294f5db81fd53b49b05263661862", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -935,7 +935,6 @@ extern \"system\" {\n                           args: *const c_void)\n                           -> DWORD;\n     pub fn TlsAlloc() -> DWORD;\n-    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n     pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n     pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n     pub fn GetLastError() -> DWORD;"}, {"sha": "ad57f87dc1ff991b68b029c0884862d1c795142a", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 66, "deletions": 99, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use mem;\n use ptr;\n+use sync::atomic::AtomicPtr;\n+use sync::atomic::Ordering::SeqCst;\n use sys::c;\n-use sys_common::mutex::Mutex;\n-use sys_common;\n \n pub type Key = c::DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -34,8 +35,6 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // * All TLS destructors are tracked by *us*, not the windows runtime. This\n //   means that we have a global list of destructors for each TLS key that\n //   we know about.\n-// * When a TLS key is destroyed, we're sure to remove it from the dtor list\n-//   if it's in there.\n // * When a thread exits, we run over the entire list and run dtors for all\n //   non-null keys. This attempts to match Unix semantics in this regard.\n //\n@@ -50,13 +49,6 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n //                        /threading/thread_local_storage_win.cc#L42\n \n-// NB these are specifically not types from `std::sync` as they currently rely\n-// on poisoning and this module needs to operate at a lower level than requiring\n-// the thread infrastructure to be in place (useful on the borders of\n-// initialization/destruction).\n-static DTOR_LOCK: Mutex = Mutex::new();\n-static mut DTORS: *mut Vec<(Key, Dtor)> = ptr::null_mut();\n-\n // -------------------------------------------------------------------------\n // Native bindings\n //\n@@ -85,81 +77,64 @@ pub unsafe fn get(key: Key) -> *mut u8 {\n }\n \n #[inline]\n-pub unsafe fn destroy(key: Key) {\n-    if unregister_dtor(key) {\n-        // FIXME: Currently if a key has a destructor associated with it we\n-        // can't actually ever unregister it. If we were to\n-        // unregister it, then any key destruction would have to be\n-        // serialized with respect to actually running destructors.\n-        //\n-        // We want to avoid a race where right before run_dtors runs\n-        // some destructors TlsFree is called. Allowing the call to\n-        // TlsFree would imply that the caller understands that *all\n-        // known threads* are not exiting, which is quite a difficult\n-        // thing to know!\n-        //\n-        // For now we just leak all keys with dtors to \"fix\" this.\n-        // Note that source [2] above shows precedent for this sort\n-        // of strategy.\n-    } else {\n-        let r = c::TlsFree(key);\n-        debug_assert!(r != 0);\n-    }\n+pub unsafe fn destroy(_key: Key) {\n+    rtabort!(\"can't destroy tls keys on windows\")\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    true\n }\n \n // -------------------------------------------------------------------------\n // Dtor registration\n //\n-// These functions are associated with registering and unregistering\n-// destructors. They're pretty simple, they just push onto a vector and scan\n-// a vector currently.\n+// Windows has no native support for running destructors so we manage our own\n+// list of destructors to keep track of how to destroy keys. We then install a\n+// callback later to get invoked whenever a thread exits, running all\n+// appropriate destructors.\n //\n-// FIXME: This could probably be at least a little faster with a BTree.\n-\n-unsafe fn init_dtors() {\n-    if !DTORS.is_null() { return }\n+// Currently unregistration from this list is not supported. A destructor can be\n+// registered but cannot be unregistered. There's various simplifying reasons\n+// for doing this, the big ones being:\n+//\n+// 1. Currently we don't even support deallocating TLS keys, so normal operation\n+//    doesn't need to deallocate a destructor.\n+// 2. There is no point in time where we know we can unregister a destructor\n+//    because it could always be getting run by some remote thread.\n+//\n+// Typically processes have a statically known set of TLS keys which is pretty\n+// small, and we'd want to keep this memory alive for the whole process anyway\n+// really.\n+//\n+// Perhaps one day we can fold the `Box` here into a static allocation,\n+// expanding the `StaticKey` structure to contain not only a slot for the TLS\n+// key but also a slot for the destructor queue on windows. An optimization for\n+// another day!\n \n-    let dtors = box Vec::<(Key, Dtor)>::new();\n+static DTORS: AtomicPtr<Node> = AtomicPtr::new(ptr::null_mut());\n \n-    let res = sys_common::at_exit(move|| {\n-        DTOR_LOCK.lock();\n-        let dtors = DTORS;\n-        DTORS = 1 as *mut _;\n-        Box::from_raw(dtors);\n-        assert!(DTORS as usize == 1); // can't re-init after destructing\n-        DTOR_LOCK.unlock();\n-    });\n-    if res.is_ok() {\n-        DTORS = Box::into_raw(dtors);\n-    } else {\n-        DTORS = 1 as *mut _;\n-    }\n+struct Node {\n+    dtor: Dtor,\n+    key: Key,\n+    next: *mut Node,\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n-    DTOR_LOCK.lock();\n-    init_dtors();\n-    assert!(DTORS as usize != 0);\n-    assert!(DTORS as usize != 1,\n-            \"cannot create new TLS keys after the main thread has exited\");\n-    (*DTORS).push((key, dtor));\n-    DTOR_LOCK.unlock();\n-}\n+    let mut node = Box::new(Node {\n+        key: key,\n+        dtor: dtor,\n+        next: ptr::null_mut(),\n+    });\n \n-unsafe fn unregister_dtor(key: Key) -> bool {\n-    DTOR_LOCK.lock();\n-    init_dtors();\n-    assert!(DTORS as usize != 0);\n-    assert!(DTORS as usize != 1,\n-            \"cannot unregister destructors after the main thread has exited\");\n-    let ret = {\n-        let dtors = &mut *DTORS;\n-        let before = dtors.len();\n-        dtors.retain(|&(k, _)| k != key);\n-        dtors.len() != before\n-    };\n-    DTOR_LOCK.unlock();\n-    ret\n+    let mut head = DTORS.load(SeqCst);\n+    loop {\n+        node.next = head;\n+        match DTORS.compare_exchange(head, &mut *node, SeqCst, SeqCst) {\n+            Ok(_) => return mem::forget(node),\n+            Err(cur) => head = cur,\n+        }\n+    }\n }\n \n // -------------------------------------------------------------------------\n@@ -196,16 +171,12 @@ unsafe fn unregister_dtor(key: Key) -> bool {\n // # Ok, what's up with running all these destructors?\n //\n // This will likely need to be improved over time, but this function\n-// attempts a \"poor man's\" destructor callback system. To do this we clone a\n-// local copy of the dtor list to start out with. This is our fudgy attempt\n-// to not hold the lock while destructors run and not worry about the list\n-// changing while we're looking at it.\n-//\n-// Once we've got a list of what to run, we iterate over all keys, check\n-// their values, and then run destructors if the values turn out to be non\n-// null (setting them to null just beforehand). We do this a few times in a\n-// loop to basically match Unix semantics. If we don't reach a fixed point\n-// after a short while then we just inevitably leak something most likely.\n+// attempts a \"poor man's\" destructor callback system. Once we've got a list\n+// of what to run, we iterate over all keys, check their values, and then run\n+// destructors if the values turn out to be non null (setting them to null just\n+// beforehand). We do this a few times in a loop to basically match Unix\n+// semantics. If we don't reach a fixed point after a short while then we just\n+// inevitably leak something most likely.\n //\n // # The article mentions weird stuff about \"/INCLUDE\"?\n //\n@@ -259,25 +230,21 @@ unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID,\n unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in 0..5 {\n-        if !any_run { break }\n+        if !any_run {\n+            break\n+        }\n         any_run = false;\n-        let dtors = {\n-            DTOR_LOCK.lock();\n-            let ret = if DTORS as usize <= 1 {\n-                Vec::new()\n-            } else {\n-                (*DTORS).iter().map(|s| *s).collect()\n-            };\n-            DTOR_LOCK.unlock();\n-            ret\n-        };\n-        for &(key, dtor) in &dtors {\n-            let ptr = c::TlsGetValue(key);\n+        let mut cur = DTORS.load(SeqCst);\n+        while !cur.is_null() {\n+            let ptr = c::TlsGetValue((*cur).key);\n+\n             if !ptr.is_null() {\n-                c::TlsSetValue(key, ptr::null_mut());\n-                dtor(ptr as *mut _);\n+                c::TlsSetValue((*cur).key, ptr::null_mut());\n+                ((*cur).dtor)(ptr as *mut _);\n                 any_run = true;\n             }\n+\n+            cur = (*cur).next;\n         }\n     }\n }"}, {"sha": "a1897c8bd676e0ec53eb11893e668a4f4f20f56e", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -177,9 +177,22 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     };\n     let mut res = ptr::null_mut();\n     unsafe {\n-        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints,\n-                               &mut res))?;\n-        Ok(LookupHost { original: res, cur: res })\n+        match cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)) {\n+            Ok(_) => {\n+                Ok(LookupHost { original: res, cur: res })\n+            },\n+            #[cfg(unix)]\n+            Err(e) => {\n+                // The lookup failure could be caused by using a stale /etc/resolv.conf.\n+                // See https://github.com/rust-lang/rust/issues/41570.\n+                // We therefore force a reload of the nameserver information.\n+                c::res_init();\n+                Err(e)\n+            },\n+            // the cfg is needed here to avoid an \"unreachable pattern\" warning\n+            #[cfg(not(unix))]\n+            Err(e) => Err(e),\n+        }\n     }\n }\n "}, {"sha": "0ade90e64c307e66e98edce22e3923ae9a74f1ef", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -61,6 +61,7 @@\n use sync::atomic::{self, AtomicUsize, Ordering};\n \n use sys::thread_local as imp;\n+use sys_common::mutex::Mutex;\n \n /// A type for TLS keys that are statically allocated.\n ///\n@@ -145,20 +146,6 @@ impl StaticKey {\n     #[inline]\n     pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }\n \n-    /// Deallocates this OS TLS key.\n-    ///\n-    /// This function is unsafe as there is no guarantee that the key is not\n-    /// currently in use by other threads or will not ever be used again.\n-    ///\n-    /// Note that this does *not* run the user-provided destructor if one was\n-    /// specified at definition time. Doing so must be done manually.\n-    pub unsafe fn destroy(&self) {\n-        match self.key.swap(0, Ordering::SeqCst) {\n-            0 => {}\n-            n => { imp::destroy(n as imp::Key) }\n-        }\n-    }\n-\n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n         match self.key.load(Ordering::Relaxed) {\n@@ -168,6 +155,24 @@ impl StaticKey {\n     }\n \n     unsafe fn lazy_init(&self) -> usize {\n+        // Currently the Windows implementation of TLS is pretty hairy, and\n+        // it greatly simplifies creation if we just synchronize everything.\n+        //\n+        // Additionally a 0-index of a tls key hasn't been seen on windows, so\n+        // we just simplify the whole branch.\n+        if imp::requires_synchronized_create() {\n+            static INIT_LOCK: Mutex = Mutex::new();\n+            INIT_LOCK.lock();\n+            let mut key = self.key.load(Ordering::SeqCst);\n+            if key == 0 {\n+                key = imp::create(self.dtor) as usize;\n+                self.key.store(key, Ordering::SeqCst);\n+            }\n+            INIT_LOCK.unlock();\n+            assert!(key != 0);\n+            return key\n+        }\n+\n         // POSIX allows the key created here to be 0, but the compare_and_swap\n         // below relies on using 0 as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n@@ -227,7 +232,9 @@ impl Key {\n \n impl Drop for Key {\n     fn drop(&mut self) {\n-        unsafe { imp::destroy(self.key) }\n+        // Right now Windows doesn't support TLS key destruction, but this also\n+        // isn't used anywhere other than tests, so just leak the TLS key.\n+        // unsafe { imp::destroy(self.key) }\n     }\n }\n "}, {"sha": "7173040350ed96840428f5a180a00b2743e7e6bc", "filename": "src/libstd_unicode/tables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftables.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n+// NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n "}, {"sha": "5f9def02c7d1172e51c2cb441abe972d29cb3670", "filename": "src/libstd_unicode/unicode.py", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd_unicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibstd_unicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Funicode.py?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -35,7 +35,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n+// NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n '''", "previous_filename": "src/etc/unicode.py"}, {"sha": "f99f39dae6b07c2db865565c4855fa20042dda3e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -2700,6 +2700,19 @@ impl<'a> Parser<'a> {\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 (span, self.mk_unary(UnOp::Not, e))\n             }\n+            // Suggest `!` for bitwise negation when encountering a `~`\n+            token::Tilde => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                let span_of_tilde = lo;\n+                let mut err = self.diagnostic().struct_span_err(span_of_tilde,\n+                        \"`~` can not be used as an unary operator\");\n+                err.span_label(span_of_tilde, &\"did you mean `!`?\");\n+                err.help(\"use `!` instead of `~` if you meant to perform bitwise negation\");\n+                err.emit();\n+                (span, self.mk_unary(UnOp::Not, e))\n+            }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);"}, {"sha": "91746a2edd9b2a62abc70b84d7647ce277b5174a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -442,7 +442,7 @@ We're going to be building a module that looks more or less like:\n mod __test {\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n-    test::test_main_static(&::os::args()[], tests)\n+    test::test_main_static(&::os::args()[], tests, test::Options::new())\n   }\n \n   static tests : &'static [test::TestDescAndFn] = &[\n@@ -478,7 +478,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     //        pub fn main() {\n     //            #![main]\n     //            use std::slice::AsSlice;\n-    //            test::test_main_static(::std::os::args().as_slice(), TESTS);\n+    //            test::test_main_static(::std::os::args().as_slice(), TESTS, test::Options::new());\n     //        }\n \n     let sp = ignored_span(cx, DUMMY_SP);"}, {"sha": "35f2fbca69f8df2613da9e0ca38174e7002459a9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 68, "deletions": 6, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -76,7 +76,7 @@ pub mod test {\n     pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n              TrFailedMsg, TrIgnored, TrOk, Metric, MetricMap, StaticTestFn, StaticTestName,\n              DynTestName, DynTestFn, run_test, test_main, test_main_static, filter_tests,\n-             parse_opts, StaticBenchFn, ShouldPanic};\n+             parse_opts, StaticBenchFn, ShouldPanic, Options};\n }\n \n pub mod stats;\n@@ -252,14 +252,34 @@ impl Clone for MetricMap {\n     }\n }\n \n+/// In case we want to add other options as well, just add them in this struct.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Options {\n+    display_output: bool,\n+}\n+\n+impl Options {\n+    pub fn new() -> Options {\n+        Options {\n+            display_output: false,\n+        }\n+    }\n+\n+    pub fn display_output(mut self, display_output: bool) -> Options {\n+        self.display_output = display_output;\n+        self\n+    }\n+}\n+\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>) {\n-    let opts = match parse_opts(args) {\n+pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n+    let mut opts = match parse_opts(args) {\n         Some(Ok(o)) => o,\n         Some(Err(msg)) => panic!(\"{:?}\", msg),\n         None => return,\n     };\n+    opts.options = options;\n     if opts.list {\n         if let Err(e) = list_tests_console(&opts, tests) {\n             panic!(\"io error when listing tests: {:?}\", e);\n@@ -301,16 +321,17 @@ pub fn test_main_static(tests: &[TestDescAndFn]) {\n                                }\n                            })\n                            .collect();\n-    test_main(&args, owned_tests)\n+    test_main(&args, owned_tests, Options::new())\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum ColorConfig {\n     AutoColor,\n     AlwaysColor,\n     NeverColor,\n }\n \n+#[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n     pub filter: Option<String>,\n@@ -324,6 +345,7 @@ pub struct TestOpts {\n     pub quiet: bool,\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n+    pub options: Options,\n }\n \n impl TestOpts {\n@@ -342,6 +364,7 @@ impl TestOpts {\n             quiet: false,\n             test_threads: None,\n             skip: vec![],\n+            options: Options::new(),\n         }\n     }\n }\n@@ -481,6 +504,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         quiet: quiet,\n         test_threads: test_threads,\n         skip: matches.opt_strs(\"skip\"),\n+        options: Options::new(),\n     };\n \n     Some(Ok(test_opts))\n@@ -521,7 +545,9 @@ struct ConsoleTestState<T> {\n     measured: usize,\n     metrics: MetricMap,\n     failures: Vec<(TestDesc, Vec<u8>)>,\n+    not_failures: Vec<(TestDesc, Vec<u8>)>,\n     max_name_len: usize, // number of columns to fill when aligning names\n+    options: Options,\n }\n \n impl<T: Write> ConsoleTestState<T> {\n@@ -547,7 +573,9 @@ impl<T: Write> ConsoleTestState<T> {\n             measured: 0,\n             metrics: MetricMap::new(),\n             failures: Vec::new(),\n+            not_failures: Vec::new(),\n             max_name_len: 0,\n+            options: opts.options,\n         })\n     }\n \n@@ -703,9 +731,38 @@ impl<T: Write> ConsoleTestState<T> {\n         Ok(())\n     }\n \n+    pub fn write_outputs(&mut self) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &self.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n     pub fn write_run_finish(&mut self) -> io::Result<bool> {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n+        if self.options.display_output {\n+            self.write_outputs()?;\n+        }\n         let success = self.failed == 0;\n         if !success {\n             self.write_failures()?;\n@@ -824,7 +881,10 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                 st.write_log_result(&test, &result)?;\n                 st.write_result(&result)?;\n                 match result {\n-                    TrOk => st.passed += 1,\n+                    TrOk => {\n+                        st.passed += 1;\n+                        st.not_failures.push((test, stdout));\n+                    }\n                     TrIgnored => st.ignored += 1,\n                     TrMetrics(mm) => {\n                         let tname = test.name;\n@@ -901,6 +961,8 @@ fn should_sort_failures_before_printing_them() {\n         max_name_len: 10,\n         metrics: MetricMap::new(),\n         failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n+        options: Options::new(),\n+        not_failures: Vec::new(),\n     };\n \n     st.write_failures().unwrap();"}, {"sha": "3f568194e23d8071fc9bd67c7fe05d1f2120d02f", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -58,13 +58,15 @@ mod signatures {\n         fn method(&self, x: u32) { }\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     struct WillChanges {\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n         x: WillChange,\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n         y: WillChange\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    // The fields change, not the type itself.\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n     fn indirect(x: WillChanges) { }\n }\n "}, {"sha": "56636a00a313a26afb911c4cce8f3a32d517d709", "filename": "src/test/compile-fail/dep-graph-type-alias.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -23,15 +23,21 @@ fn main() { }\n #[rustc_if_this_changed]\n type TypeAlias = u32;\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+// The type alias directly affects the type of the field,\n+// not the enclosing struct:\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n struct Struct {\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     x: TypeAlias,\n     y: u32\n }\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n enum Enum {\n-    Variant1(TypeAlias),\n+    Variant1 {\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        t: TypeAlias\n+    },\n     Variant2(i32)\n }\n "}, {"sha": "9b621a13fc484b7200b44c96a81294ab127664bd", "filename": "src/test/compile-fail/dep-graph-variance-alias.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that changing what a `type` points to does not go unnoticed\n+// by the variance analysis.\n+\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+fn main() { }\n+\n+struct Foo<T> {\n+    f: T\n+}\n+\n+#[rustc_if_this_changed]\n+type TypeAlias<T> = Foo<T>;\n+\n+#[rustc_then_this_would_need(ItemVariances)] //~ ERROR OK\n+struct Use<T> {\n+    x: TypeAlias<T>\n+}"}, {"sha": "cd047cc580f8720b2c0df3c0873a5f7c74c7fcf1", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -60,7 +60,6 @@ struct Test6<'a, 'b:'a> { //~ ERROR [-, o]\n \n #[rustc_variance]\n struct Test7<'a> { //~ ERROR [*]\n-    //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n "}, {"sha": "60d4d73fe88b8845e08405d77869515eedf44c73", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -16,27 +16,23 @@\n \n #[rustc_variance]\n enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR [+, -, o, *]\n-    //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR [*, o, -, +]\n-    //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n struct Derived2<'a, 'b:'a, 'c> { //~ ERROR [o, o, *]\n-    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n struct Derived3<'a:'b, 'b, 'c> { //~ ERROR [o, -, *]\n-    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n "}, {"sha": "58fb785c48ca7b24a70c92e2cd5c9e897b6c9230", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -30,8 +30,7 @@ struct TestStruct<U,T:Setter<U>> { //~ ERROR [+, +]\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n+enum TestEnum<U,T:Setter<U>> { //~ ERROR [*, +]\n     Foo(T)\n }\n \n@@ -51,13 +50,11 @@ trait TestTrait3<U> { //~ ERROR [o, o]\n \n #[rustc_variance]\n struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n     t: T\n }\n "}, {"sha": "693573d53a4a27960c579a588d6b5f034707d0b8", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -72,6 +72,7 @@ else\n endif\n else\n ifeq ($(UNAME),Darwin)\n+\tEXTRACFLAGS := -lresolv\n else\n ifeq ($(UNAME),FreeBSD)\n \tEXTRACFLAGS := -lm -lpthread -lgcc_s"}, {"sha": "745fbbe769e60f91d563d55f04553f48ab3b855f", "filename": "src/test/run-pass-fulldeps/auxiliary/issue_24106.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_24106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_24106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_24106.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"lib\"]\n+\n+enum E { E0 = 0, E1 = 1 }\n+const E0_U8: u8 = E::E0 as u8;\n+const E1_U8: u8 = E::E1 as u8;\n+\n+pub fn go<T>() {\n+    match 0 {\n+        E0_U8 => (),\n+        E1_U8 => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "7cfd11537f4e942b3e3662a352bbbea4189e0365", "filename": "src/test/run-pass-fulldeps/issue_24106.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Frun-pass-fulldeps%2Fissue_24106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Frun-pass-fulldeps%2Fissue_24106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue_24106.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_24106.rs\n+\n+extern crate issue_24106;\n+\n+fn main() {\n+    issue_24106::go::<()>();\n+}"}, {"sha": "5091b9efc34226bc796b3b8bacb60fd2f1079f2f", "filename": "src/test/ui/did_you_mean/issue-41679.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = ~1;\n+}"}, {"sha": "5a89ec96e2470ef51a37983d1dd965ca50a8ddac", "filename": "src/test/ui/did_you_mean/issue-41679.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.stderr?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -0,0 +1,10 @@\n+error: `~` can not be used as an unary operator\n+  --> $DIR/issue-41679.rs:12:13\n+   |\n+12 |     let x = ~1;\n+   |             ^ did you mean `!`?\n+   |\n+   = help: use `!` instead of `~` if you meant to perform bitwise negation\n+\n+error: aborting due to previous error\n+"}, {"sha": "6fc7f9f07ac174c407a235adc4e173aea6bf8476", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -336,6 +336,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         test_threads: None,\n         skip: vec![],\n         list: false,\n+        options: test::Options::new(),\n     }\n }\n "}, {"sha": "28a55a8763c64e47c4720926bbadfcc9d5b1ad53", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=42a4f373c9bcb819b4485c97ef0df4b7d7fe98c5", "patch": "@@ -101,7 +101,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n            filename.starts_with(\".#\") {\n             return\n         }\n-        if filename == \"miniz.c\" || filename.contains(\"jquery\") {\n+        if filename == \"miniz.c\" {\n             return\n         }\n "}]}